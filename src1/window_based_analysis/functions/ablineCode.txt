plot(c(0,100), c(0,100)) axes= xlab= ylab= abline(a, b) abline(1, 3)
abline(2, 4)
abline(1, 1) col= lty= lwd=
-------------------------------------------------------------------------------------------------------
abline(model) z <- lm(dist ~ speed, data = cars)
 plot(cars)
 abline(z) # equivalent to abline(reg = z) or
 abline(coef = coef(z))
-------------------------------------------------------------------------------------------------------
print(p + geom_abline(intercept = inter, slope = slop, colour = "red", size = 1))
-------------------------------------------------------------------------------------------------------
p <- qplot(data = data.frame(x = x, y = y),
           x, y,   
           xlab = "Radius [km]", 
           ylab = "Services [log]",
           xlim = x_range,
           ylim = c(0,10),
           main = paste("Sample",i)
           ) + geom_abline(intercept = inter, slope = slop, colour = "red", size = 1) > summary(pltList[["a1"]])
data: x, y [50x2]
mapping:  x = x, y = y
scales:   x, y 
faceting: facet_grid(. ~ ., FALSE)
-----------------------------------
geom_point:  
stat_identity:  
position_identity: (width = NULL, height = NULL)

mapping: group = 1 
geom_abline: colour = red, size = 1 
stat_abline: intercept = 2.55595281266726, slope = 0.05543539319091 
position_identity: (width = NULL, height = NULL) data data: [0x0]
mapping:  x = x, y = y
scales:   x, y 
faceting: facet_grid(. ~ ., FALSE)
-----------------------------------
geom_point:  
stat_identity:  
position_identity: (width = NULL, height = NULL)

mapping: group = 1 
geom_abline: colour = red, size = 1 
stat_abline: intercept = 2.55595281266726, slope = 0.05543539319091 
position_identity: (width = NULL, height = NULL) x y
-------------------------------------------------------------------------------------------------------
abline(v=(seq(0,100,25)), col="lightgray", lty="dotted")
abline(h=(seq(0,100,25)), col="lightgray", lty="dotted")
-------------------------------------------------------------------------------------------------------
abline(h=mean(x)) points(mean(x)) pch ?boxplot boxplot(count ~ spray, data = InsectSprays, col = "lightgray")
means <- tapply(InsectSprays$count,InsectSprays$spray,mean)
points(means,col="red",pch=18) tapply function(x) mean(x,na.rm=T)
-------------------------------------------------------------------------------------------------------
geom_smooth() loess geom_smooth(se = FALSE) # First, I'll make a simple linear model and get its diagnostic stats.
library(ggplot2)
data(cars)
mod <- fortify(lm(speed ~ dist, data = cars))
attach(mod)
str(mod)

# Now I want to make sure the residuals are homoscedastic.
# By default, geom_smooth is loess and includes the 68% standard error bands.
qplot (x = dist, y = .resid, data = mod) + 
geom_abline(slope = 0, intercept = 0) +
geom_smooth()
-------------------------------------------------------------------------------------------------------
diseasesev<-c(1.9,3.1,3.3,4.8,5.3,6.1,6.4,7.6,9.8,12.4)
# Predictor variable, (Centigrade)
temperature<-c(2,1,5,5,20,20,23,10,30,25)

## For convenience, the data may be formatted into a dataframe
severity <- as.data.frame(cbind(diseasesev,temperature))

## Fit a linear model for the data and summarize the output from function lm()
severity.lm <- lm(diseasesev~temperature,data=severity)

# Function to plot the linear regression and overlay the confidence intervals   
ci.lines<-function(model,conf= .95 ,interval = "confidence"){
  x <- model[[12]][[2]]
  y <- model[[12]][[1]]
  xm<-mean(x)
  n<-length(x)
  ssx<- sum((x - mean(x))^2)
  s.t<- qt(1-(1-conf)/2,(n-2))
  xv<-seq(min(x),max(x),(max(x) - min(x))/100)
  yv<- coef(model)[1]+coef(model)[2]*xv

  se <- switch(interval,
        confidence = summary(model)[[6]] * sqrt(1/n+(xv-xm)^2/ssx),
        prediction = summary(model)[[6]] * sqrt(1+1/n+(xv-xm)^2/ssx)
              )
  # summary(model)[[6]] = 'sigma'

  ci<-s.t*se
  uyv<-yv+ci
  lyv<-yv-ci
  limits1 <- min(c(x,y))
  limits2 <- max(c(x,y))

  predictions <- predict(model, level = conf, interval = interval)

  insideCI <- predictions[,'lwr'] < y & y < predictions[,'upr']

  x_name <- rownames(attr(model[[11]],"factors"))[2]
  y_name <- rownames(attr(model[[11]],"factors"))[1]

  plot(x[insideCI],y[insideCI],
  pch=16,pty="s",xlim=c(limits1,limits2),ylim=c(limits1,limits2),
  xlab=x_name,
  ylab=y_name,
  main=paste("Graph of ", y_name, " vs ", x_name,sep=""))

  abline(model)

  points(x[!insideCI],y[!insideCI], pch = 16, col = 'red')

  lines(xv,uyv,lty=2,col=3)
  lines(xv,lyv,lty=2,col=3)
} ci.lines(severity.lm, conf= .95 , interval = "confidence")
ci.lines(severity.lm, conf= .85 , interval = "prediction")
-------------------------------------------------------------------------------------------------------
# This gets the coefficients of the linear regression (intercept and slope)
c <- coef(severity.lm)
abline(c[1], c[2]*2, col="red")
abline(c[1], c[2]/2, col="red")
-------------------------------------------------------------------------------------------------------
diseasesev<-c(1.9,3.1,3.3,4.8,5.3,6.1,6.4,7.6,9.8,12.4)

# Predictor variable, (Centigrade)
temperature<-c(2,1,5,5,20,20,23,10,30,25)

## For convenience, the data may be formatted into a dataframe
severity <- as.data.frame(cbind(diseasesev,temperature))

## Fit a linear model for the data and summarize the output from function lm()
severity.lm <- lm(diseasesev~temperature,data=severity)

line1 <- severity.lm$coefficients * c(1,2)
line2 <- severity.lm$coefficients * c(1,.5)

df <- as.data.frame(severity.lm[[12]])
df2 <- adply(df,1,function(x) cbind(line1[2]*x[[2]]+line1[1], line2[2]*x[[2]]+line2[1]))

plot(
  df2[df2[,1] >= min(df2[,c(3,4)]) & df2[,1] <= max(df2[,c(3,4)]),c(2,1)],
  xlab="Temperature",
  ylab="% Disease Severity",
  pch=16,
  pty="s",
  xlim=c(0,30),
  ylim=c(0,30)
)
title(main="Graph of % Disease Severity vs Temperature")
par(new=TRUE) # don't start a new plot
abline(severity.lm, col="blue")
abline(line1, col="cyan")
abline(line2, col="cyan")
points(df2[df2[,1] < min(df2[,c(3,4)]) | df2[,1] > max(df2[,c(3,4)]),c(2,1)], pch = 16, col = 'red')
-------------------------------------------------------------------------------------------------------
library(zoo)
library(tseries)

price <- get.hist.quote(instrument = "msft", quote = c("Cl", "Vol"))

dd.character <- c("February 28, 2010", "February 20, 2010",
    "February 20, 2010", "August 21, 2009")
dd.Date <- as.Date(dd.character, "%B %d, %Y")
dd.zoo <- aggregate(zoo(dd.Date), dd.Date, length)

plot(cbind(price$Close, dd.zoo), type = c("l", "h"), heights = c(3, 1)) plot(price$Close)
abline(v = time(dd.zoo))
-------------------------------------------------------------------------------------------------------
set.seed(100)
Data <- rbind(matrix(rnorm(100, sd = 0.3), ncol = 2),
           matrix(rnorm(100, mean = 1, sd = 0.3), ncol = 2))
colnames(x) <- c("x", "y")

# noise <- runif(100,0,.05)
line.width <- rep(.004, dim(Data)[1])
Y <- NULL
X <- NULL
k.range <- 2:10

plot(0,0, col = "white", xlim = c(1,10), ylim = c(-.5,1.6),
    xlab = "Number of clusters", ylab = "Clusters means", main = "(Basic) Clustergram")
axis(side =1, at = k.range)
abline(v = k.range, col = "grey")

centers.points <- list()

for(k in k.range)
{
    cl <- kmeans(Data, k)

    clusters.vec <- cl$cluster
    the.centers <- apply(cl$centers,1, mean)

    noise <- unlist(tapply(line.width, clusters.vec, cumsum))[order(seq_along(clusters.vec)[order(clusters.vec)])]  
    noise <- noise - mean(range(noise))
    y <- the.centers[clusters.vec] + noise
    Y <- cbind(Y, y)
    x <- rep(k, length(y))
    X <- cbind(X, x)

    centers.points[[k]] <- data.frame(y = the.centers , x = rep(k , k)) 
#   points(the.centers ~ rep(k , k), pch = 19, col = "red", cex = 1.5)
}

require(colorspace)
COL <- rainbow_hcl(100)
matlines(t(X), t(Y), pch = 19, col = COL, lty = 1, lwd = 1.5)

# add points
lapply(centers.points, function(xx) {with(xx,points(y~x, pch = 19, col = "red", cex = 1.3))})
-------------------------------------------------------------------------------------------------------
lattice reshape read.csv(textConnection("Label1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18
Label2,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18
Label3,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18
Label4,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18
Label5,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18
Label6,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18"), header = F)->data

colnames(data)[1] <- "ID"
colnames(data)[2:10] <- paste("exp",1:9, sep = "_")
colnames(data)[11:19] <- paste("base", 1:9, sep = "_")

library(reshape)
data.m <- melt(data, id = "ID")
data.m <- cbind(data.m, colsplit(data.m$variable, "_", names = c("Source","Measure"))) data.m lattice histogram(~value | Source + ID, data = data.m) data[,2] data[,11] data.comp <- cast(data.m, ID + Measure ~ Source)  
## I know ggplot2 better
library(ggplot2)
qplot(base, exp, data = data.comp)+
  geom_abline()+
  expand_limits(x = 0, y = 0)
-------------------------------------------------------------------------------------------------------
postscrpt() pdf() png() jpeg() postscript("filename.eps", horizontal=F, width=4, height=4, 
             paper="special", onefile=F)
plot(x)
dev.off() ?postscript dev.off() postscript("filename.eps", horizontal=F, width=4, height=4, 
             paper="special", onefile=F)
plot(x)    
text(5, 1, "This is a message for the aliens")
text(5, 0.5, "Pizza is tasty")
dev.off() regone <- glm(y ~ x1, data=mydata, family=...)
summary(regone)

postscript("filename.eps", horizontal=F, width=4, height=4, 
                 paper="special", onefile=F)
plot(x, y)
abline(regone)
dev.off()
-------------------------------------------------------------------------------------------------------
pdf("filename.pdf")
 plot(...)
 dev.off() write.table ?write.table x <- 1:10
y <- 2 * x + runif(10) 
plot (x, y, pch=20)
fit <- glm(y~x)
coefs <- coef(fit)
abline(coefs, lwd=2, col='red')
# Or also, without finding the coefficients
abline(fit, lwd=2, col='red')
-------------------------------------------------------------------------------------------------------
legend() R> DF <- data.frame(VAR1=rnorm(100), VAR2=rnorm(100))
R> with(DF, plot(VAR1, VAR2))
R> abline(fit <- lm(VAR2 ~ VAR1, data=DF), col='red')
R> legend("topright", bty="n", legend=paste("R2 is", 
+         format(summary(fit)$adj.r.squared, digits=4))) bty="n" format() text() main= sub= plot()
-------------------------------------------------------------------------------------------------------
x <- c(rexp(1000,0.5)+0.5,rexp(100,0.5)*100)

breaks<- c(0,0.1,0.2,0.5,1,2,5,10,20,50,100,200,500,1000,10000)
major <- c(0.1,1,10,100,1000,10000)


H <- hist(log10(x),plot=F)


plot(H$mids,H$counts,type="n",
      xaxt="n",
      xlab="X",ylab="Counts",
      main="Histogram of X",
      bg="lightgrey"
)
abline(v=log10(breaks),col="lightgrey",lty=2)
abline(v=log10(major),col="lightgrey")
abline(h=pretty(H$counts),col="lightgrey")
plot(H,add=T,freq=T,col="blue")
#Position of ticks
at <- log10(breaks)

#Creation X axis
axis(1,at=at,labels=10^at) ?par
-------------------------------------------------------------------------------------------------------
bigmacprice <- data.frame(
    country = c("Switzerland", "Brazil", "Euro area",
        "Canada", "Japan", "United States",
        "Britain", "Singapore", "South Korea",
        "South Africa", "Mexico", "Thailand",
        "Russia", "Malaysia", "China"),
    price = c(6.78, 5.26, 4.79, 4.18, 3.91, 3.71,
              3.63, 3.46, 3.03, 2.79, 2.58, 2.44,
              2.39, 2.25, 2.18)
)


plotbigmac <- function(mac, base = "United States", xlim = c(-40, 100)) {
    mac <- mac[order(mac$price),]
    base = which(mac$country == base)
    height <- (mac$price / mac[base, "price"] - 1) * 100
    par(bg = "#d0e0e7", col.main = "#262324", col.axis = "#393E46",
        mar = c(8, 8, 6, 6), las = 1)
    barplot(height, width = .1, space = .4,
        names.arg = mac$country, #cex.names = .8,
        col = "#01516c", border = "#7199a8", # border = "#577784",
        horiz = TRUE, xlim = c(-40, 100), axes = FALSE)
    axis(3, lty = 0)
    title(main = "Bunfight\nBig Mac index", col = "#393E46")

    abline(v = seq(-100, 100, 10), col = "white", lwd = 2)
    abline(v = 0, col = "#c8454e", lwd = 2)
    par(xpd = TRUE)
    for (i in 1:nrow(mac)) {
        rect(105, (i - 1) / 7, 118, i / 7 - 0.05,
        col = "white", border = "#7199a8")
        text(112, (i - 1) / 7 + 0.05, mac$price[i], cex = 0.8, col = "#393E46")
    }
    rect(-120, 2.5, -90, 3, col = "#c8454e", border = "#c8454e")
    text(-68, -.2, "Sources:", col = "#393E46")
    text(-64, -.3, "McDonald's;", col = "#393E46")
    text(-60, -.4, "The Economist", col = "#393E46")
}

plotbigmac(bigmacprice) barplot barplot plotBigMac <- function(mac, base = "United States") {
    old.par <- par(no.readonly = TRUE)
    on.exit(par(old.par))
    # Create data:
    mac <- mac[order(mac$price),]
    base = which(mac$country == base)
    height <- (mac$price / mac[base, "price"] - 1) * 100
    # Costume 'barplot'
    NN <- length(height)
    width <- rep(1, length.out = NN)
    delta <- width / 2
    w.r <- cumsum(width + 0.5)
    w.m <- w.r - delta
    w.l <- w.m - delta
    xlim <- c(range(-.01 * height, height)[1], 100)
    ylim <- c(min(w.l), max(w.r))
    par(bg = "#d0e0e7", col.main = "#262324", col.axis = "#393E46",
        mar = c(8, 8, 6, 6), las = 1, cex = 0.9)
    plot.new()
    plot.window(xlim, ylim)
    abline(v = seq(-100, 100, 20), col = "white", lwd = 2)
    rect(0, w.l, height, w.r, col = "#01516c", border = "#7199a8", lwd = 1)

    # Lines and axis
    abline(v = 0, col = "#c8454e", lwd = 2)
    axis(3, axTicks(3), abs(axTicks(3)), lty = 0)
    axis(2, labels = mac$country, at = w.m, lty = 0)

    # Move outside of plot area
    par(xpd = TRUE)

    # Text misc.
    text(5, (w.l[base] + w.r[base]) / 2, "nil", font = 3)
    text(8, w.r[NN] + 2.3, "+")
    text(-8, w.r[NN] + 2.3, "-")

    # Create price boxes:
    rect(105, w.l, 125, w.r,
        col = "white", border = "#7199a8", lwd = 1)
    text(115, (w.r + w.l)/2, mac$price, cex = 0.8, col = "#393E46")

}
-------------------------------------------------------------------------------------------------------
plot(speed ~ dist, cars)

fit1 = lm(speed ~ dist, cars) #fits a linear model
abline(fit1) #puts line on plot
fit2 = lm(speed ~ I(dist^2) + dist, cars) #fits a model with a quadratic term
fit2line = predict(fit2, data.frame(dist = -10:130))
lines(-10:130 ,fit2line, col=2) #puts line on plot coef(fit2)
-------------------------------------------------------------------------------------------------------
?with with expr data abline() ... with(subset(CO2,Type=="Quebec"),{plot(conc,uptake);abline(lm(uptake~conc))})
-------------------------------------------------------------------------------------------------------
abline() with() ... { } ; with(subset(CO2,Type=="Quebec"), {plot(conc,uptake); abline(lm(uptake~conc))}) { } with(subset(CO2,Type=="Quebec"), 
     {plot(conc,uptake)
      abline(lm(uptake~conc))}) plot(uptake ~ conc, data = CO2, subset = Type == "Quebec")
abline(lm(uptake ~ conc, data = CO2, subset = Type == "Quebec"), col = "red") with() ;
-------------------------------------------------------------------------------------------------------
plot.TukeyHSD2 <- function (x, ...) {
    for (i in seq_along(x)) {
        xi <- x[[i]][, -4, drop = FALSE]
        yvals <- nrow(xi):1
        plot(c(xi[, "lwr"], xi[, "upr"]), rep.int(yvals, 2), 
            type = "n", axes = FALSE, xlab = "", ylab = "", ...)
        axis(1, ...)
        axis(2, at = nrow(xi):1, labels = dimnames(xi)[[1L]], 
            srt = 0, ...)
        abline(h = yvals, lty = 1, lwd = 1, col = "lightgray")
        abline(v = 0, lty = 2, lwd = 1, ...)
        segments(xi[, "lwr"], yvals, xi[, "upr"], yvals, col="black", ...)
        segments(as.vector(xi), rep.int(yvals - 0.1, 3), as.vector(xi), 
            rep.int(yvals + 0.1, 3), col="black", ...)
        title(main = paste(format(100 * attr(x, "conf.level"), 
            2), "% family-wise confidence level\n", sep = ""), 
            xlab = paste("Differences in mean levels of", names(x)[i]))
        box()
    }
}
-------------------------------------------------------------------------------------------------------
qqplot.data <- function (vec) # argument: vector of numbers
{
  # following four lines from base R's qqline()
  y <- quantile(vec[!is.na(vec)], c(0.25, 0.75))
  x <- qnorm(c(0.25, 0.75))
  slope <- diff(y)/diff(x)
  int <- y[1L] - slope * x[1L]

  d <- data.frame(resids = vec)

  ggplot(d, aes(sample = resids)) + stat_qq() + geom_abline(slope = slope, intercept = int)

}
-------------------------------------------------------------------------------------------------------
plot(), lines(), abline(), points(), polygon(), segments(), rect(), box(), arrows(), ... set.seed(100)
x <- 1:10
y <- x^2
y2 <- x^3
yse <- abs(runif(10,2,4))

plot(x,y, type = "n")  # type="n" only plots the pane, no curves or points.

# plots the area between both curves
polygon(c(x,sort(x,decreasing=T)),c(y,sort(y2,decreasing=T)),col="grey")
# plot both curves
lines(x,y,col="purple")
lines(x, y2, col = "red")
# add the points to the first curve
points(x, y, col = "black")
# adds some lines indicating the standard error
segments(x,y,x,y+yse,col="blue")
# adds some flags indicating the standard error
arrows(x,y,x,y-yse,angle=90,length=0.1,col="darkgreen")
-------------------------------------------------------------------------------------------------------
# sample data
x <- rnorm(50,0,2)
y <- x+rnorm(50,0,2)

# construct polygons
div <- quantile(y-x,c(0.25,0.75))
x1 <- min(c(x,y))
x2 <- max(c(x,y))


plot(x,y,type="n")
polygon(x=c(x1,x1,x2,x2),y=c(x1+div,(x2+div)[c(2,1)]),col="grey")
abline(0,1)
points(x,y) qplot(x,y,geom="point") + stat_smooth(method="lm") sd(y-x) sd(residuals(lm(y~x)))
-------------------------------------------------------------------------------------------------------
require(MASS) ## for mvrnorm()
set.seed(1)
dat <- mvrnorm(1000, mu = c(4,5), Sigma = matrix(c(1,0.8,1,0.8), ncol = 2))
dat <- data.frame(dat)
names(dat) <- c("X","Y")
plot(dat) res <- resid(mod <- lm(Y ~ X, data = dat)) quantile() res.qt <- quantile(res, probs = c(0.05,0.95)) want <- which(res >= res.qt[1] & res <= res.qt[2]) plot(dat, type = "n")
points(dat[-want,], col = "black", pch = 21, bg = "black", cex = 0.8)
points(dat[want,], col = "red", pch = 21, bg = "red", cex = 0.8)
abline(mod, col = "blue", lwd = 2) > cor(dat)
          X         Y
X 1.0000000 0.8935235
Y 0.8935235 1.0000000
> cor(dat[want,])
          X         Y
X 1.0000000 0.9272109
Y 0.9272109 1.0000000
> cor(dat[-want,])
         X        Y
X 1.000000 0.739972
Y 0.739972 1.000000 ares <- abs(res)
absres.qt <- quantile(ares, prob = c(.9))
abswant <- which(ares <= absres.qt)
## plot - virtually the same, but not quite
plot(dat, type = "n")
points(dat[-abswant,], col = "black", pch = 21, bg = "black", cex = 0.8)
points(dat[abswant,], col = "red", pch = 21, bg = "red", cex = 0.8)
abline(mod, col = "blue", lwd = 2) > cor(dat[abswant,])
          X         Y
X 1.0000000 0.9272032
Y 0.9272032 1.0000000 cooks.distance() mod > head(cooks.distance(mod))
           1            2            3            4            5            6 
7.738789e-04 6.056810e-04 6.375505e-04 4.338566e-04 1.163721e-05 1.740565e-03 > any(cooks.distance(mod) > 1)
[1] FALSE
> any(cooks.distance(mod) > (4 * nrow(dat)))
[1] FALSE
-------------------------------------------------------------------------------------------------------
plotfun <- function(x) {
    plot( c(-0.5,-0.5,0.5,0.5), c(0,1,1,0), col='blue', xlim=c(-2,2),
         type='l', xlab='', ylab='' )
    if( x > -1 && x < 0 ) {
        polygon( c(-0.5, -0.5, x+0.5, x+0.5), c(0,1,1,0), col='yellow', border=NA )
        lines( c(-0.5, -0.5, 0.5, 0.5), c(0,1,1,0), col='blue' )
        lines( c(-1,x), c(0,x+1) )
    } else if( x >= 0 && x < 1 ) {
        polygon( c(x-0.5, x-0.5, 0.5, 0.5), c(0,1,1,0), col='yellow', border=NA )
        lines( c(-0.5, -0.5, 0.5, 0.5), c(0,1,1,0), col='blue' )
        lines( c(-1,0,x), c(0,1,1-x) )
    } else if (x >= 1) {
        lines( c(-1,0,1), c(0,1,0) )
    }
    abline(v=x, lty=3)
    lines( c(x-0.5,x-0.5,x+0.5,x+0.5), c(0,1,1,0), col='red' )
}

dev.new(height=3, width=6)

for(i in seq(-2.5, 2.5, 0.05) ) {
    plotfun(i)
    Sys.sleep(0.1)
} library(TeachingDemos)

tkexamp( plotfun, list(x=list('slider', from=-2.5, to=2.5, resolution=0.01)),
    vscale=1)
-------------------------------------------------------------------------------------------------------
#Generate the data for the four graphs
x <- seq(1, 50, 1)
y1 <- 10*rnorm(50)
y2 <- 100*rnorm(50)
y3 <- 1000*rnorm(50)
y4 <- 10000*rnorm(50)

#Set up the plot area so that multiple graphs can be crammed together
par(pty="m", plt=c(0.1, 1, 0, 1), omd=c(0.1,0.9,0.1,0.9))

#Set the area up for 4 plots
par(mfrow = c(4, 1))

#Plot the top graph with nothing in it =========================
plot(x, y1, xlim=range(x), type="n", xaxt="n", yaxt="n", main="", xlab="", ylab="")
mtext("Four Y Plots With the Same X", 3, line=1, cex=1.5)

#Store the x-axis data of the top plot so it can be used on the other graphs
pardat<-par()
xaxisdat<-seq(pardat$xaxp[1],pardat$xaxp[2],(pardat$xaxp[2]-pardat$xaxp[1])/pardat$xaxp[3])

#Get the y-axis data and add the lines and label
yaxisdat<-seq(pardat$yaxp[1],pardat$yaxp[2],(pardat$yaxp[2]-pardat$yaxp[1])/pardat$yaxp[3])
axis(2, at=yaxisdat, las=2, padj=0.5, cex.axis=0.8, hadj=0.5, tcl=-0.3)
abline(v=xaxisdat, col="lightgray")
abline(h=yaxisdat, col="lightgray")
mtext("y1", 2, line=2.3)
lines(x, y1, col="red")

#Plot the 2nd graph with nothing ================================
plot(x, y2, xlim=range(x), type="n", xaxt="n", yaxt="n", main="", xlab="", ylab="")

#Get the y-axis data and add the lines and label
pardat<-par()
yaxisdat<-seq(pardat$yaxp[1],pardat$yaxp[2],(pardat$yaxp[2]-pardat$yaxp[1])/pardat$yaxp[3])
axis(2, at=yaxisdat, las=2, padj=0.5, cex.axis=0.8, hadj=0.5, tcl=-0.3)
abline(v=xaxisdat, col="lightgray")
abline(h=yaxisdat, col="lightgray")
mtext("y2", 2, line=2.3)
lines(x, y2, col="blue")

#Plot the 3rd graph with nothing =================================
plot(x, y3, xlim=range(x), type="n", xaxt="n", yaxt="n", main="", xlab="", ylab="")

#Get the y-axis data and add the lines and label
pardat<-par()
yaxisdat<-seq(pardat$yaxp[1],pardat$yaxp[2],(pardat$yaxp[2]-pardat$yaxp[1])/pardat$yaxp[3])
axis(2, at=yaxisdat, las=2, padj=0.5, cex.axis=0.8, hadj=0.5, tcl=-0.3)
abline(v=xaxisdat, col="lightgray")
abline(h=yaxisdat, col="lightgray")
mtext("y3", 2, line=2.3)
lines(x, y3, col="green")

#Plot the 4th graph with nothing =================================
plot(x, y4, xlim=range(x), type="n", xaxt="n", yaxt="n", main="", xlab="", ylab="")

#Get the y-axis data and add the lines and label
pardat<-par()
yaxisdat<-seq(pardat$yaxp[1],pardat$yaxp[2],(pardat$yaxp[2]-pardat$yaxp[1])/pardat$yaxp[3])
axis(2, at=yaxisdat, las=2, padj=0.5, cex.axis=0.8, hadj=0.5, tcl=-0.3)
abline(v=xaxisdat, col="lightgray")
abline(h=yaxisdat, col="lightgray")
mtext("y4", 2, line=2.3)
lines(x, y4, col="darkgray")

#Plot the X axis =================================================
axis(1, at=xaxisdat, padj=-1.4, cex.axis=0.9, hadj=0.5, tcl=-0.3)
mtext("X Variable", 1, line=1.5)
-------------------------------------------------------------------------------------------------------
#Build the data
 t <- 1:1000
 x1 <- 100 * sin(0.01 * t)
 x2 <- 200 * cos(0.04 * t)

 #Set up the plot area for two "crammed" plots
 par(pty="m", plt=c(0.1, 1, 0, 1), omd=c(0.1,0.9,0.1,0.9))
 par(mfrow = c(2, 1))

 #Plot x1 and x2 together
 plot(t, x1, type="l", ylim = 1.5 * range(x1, x2), xaxt="n", xlab="", ylab="", main="", col="blue", las=2)
 lines(t, x2, lwd=1, col="red")
 mtext(side=2, "Top Plot", line=5.3, cex=0.8)
 mtext(side=2, "(units)", line=4, cex=0.8)
 grid()
 mtext(side=3, "2 Plots Crammed Together", line=1.5, cex=1.2)
 legend("topright", legend=c("100 * sin(0.01 * t)", "200 * cos(0.4 * t)"), bg="white", lwd=c(1, 1), col=c("blue", "red"), cex=0.9)

 #Place the 1st x-axis
 axis(side = 1, col="blue", col.axis="blue")
 linloc <- par()$usr[3]
 abline(h=linloc, col="blue")
 mtext(side=1, "First X-Axis", line=2.5, cex=0.8, col="blue")

 #Place the fake 2nd x-axis
 xaxis2 <- 1:10
 par(plt=c(0.1,1,0.6,1))
 plot(xaxis2, type="n", xaxt="n", xlab="", yaxt="n", ylab="", xlim=range(xaxis2), bty="n")
 axis(side = 1, col="red", col.axis="red")
 linloc <- par()$usr[3]
 abline(h=linloc, col="red")
 mtext(side=1, "Second X-Axis", line=2.5, cex=0.8, col="red")
-------------------------------------------------------------------------------------------------------
require(MASS)
set.seed(1)
dat <- data.frame(mvrnorm(100, mu = c(2,6,3), 
                          Sigma = matrix(c(10,   2,   4,
                                            2,   3, 0.5,
                                            4, 0.5,   2), ncol = 3))) dij <- dist(scale(dat, center = TRUE, scale = TRUE)) clust <- hclust(dij, method = "average") ord <- order(cutree(clust, k = 3)) coph <- cophenetic(clust) layout(matrix(1:4, ncol = 2))
image(as.matrix(dij)[ord, ord], main = "Original distances")
image(as.matrix(coph)[ord, ord], main = "Cophenetic distances")
image((as.matrix(coph) - as.matrix(dij))[ord, ord], 
      main = "Cophenetic - Original")
plot(coph ~ dij, ylab = "Cophenetic distances", xlab = "Original distances",
     main = "Shepard Plot")
abline(0,1, col = "red")
box()
layout(1)
-------------------------------------------------------------------------------------------------------
> dput(redata)
structure(c(1093L, 1182L, 1299L, 1372L, 1319L, 1362L, 1239L, 
1162L, 1059L, 921L, 815L, 720L, 835L, 853L, 1034L, 1030L, 1240L, 
1388L, 1429L, 1319L, 1231L, 1184L, 1076L, 825L, 991L, 1093L, 
854L, 808L, 1079L, 1092L, 1220L, 1251L, 1130L, 1131L, 1052L, 
951L, 950L, 1006L, 1112L, 1119L, 1250L, 1322L, 1347L, 1310L, 
1215L, 1128L, 1035L, 992L, 1079L, 1018L, 1112L, 1224L, 1323L, 
1344L, 1326L, 1267L, 1171L, 1075L, 916L, 932L, 888L, 904L, 939L, 
1018L, 1140L, 1174L, 1285L, 1311L, 1298L, 1231L, 1091L, 1088L, 
991L, 1028L, 1177L, 1322L, 1322L, 1398L, 1389L, 1174L, 1196L, 
1115L, 756L, 496L, 693L, 673L, 748L, 777L, 820L, 948L, 966L, 
1027L, 960L, 865L, 767L, 675L, 765L, 732L, 613L, 632L, 659L, 
705L, 684L, 734L, 715L, 626L, 551L, 487L, 500L, 536L, 575L, 595L, 
736L, 798L, 832L, 797L, 792L, 726L, 650L, 584L, 567L, 524L, 574L, 
571L, 591L, 657L, 699L, 756L, 867L, 795L, 760L, 685L, 609L, 588L, 
521L, 581L, 614L, 623L, 668L, 702L, 777L, 697L, 647L, 562L, 523L, 
508L, 493L, 504L, 534L, 586L, 621L, 620L, 636L, 600L, 549L, 557L
), .Dim = 12:13, .Dimnames = list(c("Jan", "Feb", "Mar", "Apr", 
"May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"), c("X1993", 
"X1994", "X1995", "X1996", "X1997", "X1998", "X1999", "X2000", 
"X2001", "X2002", "X2003", "X2004", "X2005"))) monthnames <- c(
"Jan",
"Feb",
"Mar",
"Apr",
"May",
"Jun",
"Jul",
"Aug",
"Sep",
"Oct",
"Nov",
"Dec"
)


# size of window
windows(w=6,h=3)

# margins
par(
mar=c(5.1,5.1,2.1,2.1),
cex.axis=0.7
)

# set up plot with the number of categories and the y limits 
# yaxs="i" sets the yaxis as having no separation from the corner point

ylimlp <-  c(0,max(redata))*1.06
plot(1:156, type="n", xaxt="n", ylim=ylimlp, ann=FALSE, yaxs="i", xaxs="i", bty="l", las="1")

abline(v=seq(13,156,13),lty=1,col="grey")

title(xlab="Month", col.lab=rgb(0,0,0), font.lab=2, cex.lab=0.75)
title(ylab="Listings", col.lab=rgb(0,0,0), font.lab=2, cex.lab=0.75)

lines(redata[1,],type="l",pch=NA,lwd=1,col="grey")
lines(c(rep(NA,13*1),redata[2,]),type="l",pch=NA,lwd=1,col="grey")
lines(c(rep(NA,13*2),redata[3,]),type="l",pch=NA,lwd=1,col="grey")
lines(c(rep(NA,13*3),redata[4,]),type="l",pch=NA,lwd=1,col="grey")
lines(c(rep(NA,13*4),redata[5,]),type="l",pch=NA,lwd=1,col="grey")
lines(c(rep(NA,13*5),redata[6,]),type="l",pch=NA,lwd=1,col="grey")
lines(c(rep(NA,13*6),redata[7,]),type="l",pch=NA,lwd=1,col="grey")
lines(c(rep(NA,13*7),redata[8,]),type="l",pch=NA,lwd=1,col="grey")
lines(c(rep(NA,13*8),redata[9,]),type="l",pch=NA,lwd=1,col="grey")
lines(c(rep(NA,13*9),redata[10,]),type="l",pch=NA,lwd=1,col="grey")
lines(c(rep(NA,13*10),redata[11,]),type="l",pch=NA,lwd=1,col="grey")
lines(c(rep(NA,13*11),redata[12,]),type="l",pch=NA,lwd=1,col="grey")

redatamonthmean <- apply(redata,1,mean)

lines(rep(redatamonthmean[1],13),type="l",pch=NA,lwd=1,col="black")
lines(c(rep(NA,13*1),rep(redatamonthmean[2],13)),type="l",pch=NA,lwd=1,col="black")
lines(c(rep(NA,13*2),rep(redatamonthmean[3],13)),type="l",pch=NA,lwd=1,col="black")
lines(c(rep(NA,13*3),rep(redatamonthmean[4],13)),type="l",pch=NA,lwd=1,col="black")
lines(c(rep(NA,13*4),rep(redatamonthmean[5],13)),type="l",pch=NA,lwd=1,col="black")
lines(c(rep(NA,13*5),rep(redatamonthmean[6],13)),type="l",pch=NA,lwd=1,col="black")
lines(c(rep(NA,13*6),rep(redatamonthmean[7],13)),type="l",pch=NA,lwd=1,col="black")
lines(c(rep(NA,13*7),rep(redatamonthmean[8],13)),type="l",pch=NA,lwd=1,col="black")
lines(c(rep(NA,13*8),rep(redatamonthmean[9],13)),type="l",pch=NA,lwd=1,col="black")
lines(c(rep(NA,13*9),rep(redatamonthmean[10],13)),type="l",pch=NA,lwd=1,col="black")
lines(c(rep(NA,13*10),rep(redatamonthmean[11],13)),type="l",pch=NA,lwd=1,col="black")
lines(c(rep(NA,13*11),rep(redatamonthmean[12],13)),type="l",pch=NA,lwd=1,col="black")

mtext(monthnames[1], side=1, cex=0.7, at=6.5)
mtext(monthnames[2], side=1, cex=0.7, at=6.5*3)
mtext(monthnames[3], side=1, cex=0.7, at=6.5*5)
mtext(monthnames[4], side=1, cex=0.7, at=6.5*7)
mtext(monthnames[5], side=1, cex=0.7, at=6.5*9)
mtext(monthnames[6], side=1, cex=0.7, at=6.5*11)
mtext(monthnames[7], side=1, cex=0.7, at=6.5*13)
mtext(monthnames[8], side=1, cex=0.7, at=6.5*15)
mtext(monthnames[9], side=1, cex=0.7, at=6.5*17)
mtext(monthnames[10], side=1, cex=0.7, at=6.5*19)
mtext(monthnames[11], side=1, cex=0.7, at=6.5*21)
mtext(monthnames[12], side=1, cex=0.7, at=6.5*23)
-------------------------------------------------------------------------------------------------------
?ts.plot
my.ts.panel <- function(x, col = col, bg = bg, pch = pch, type = type,  vpos=8.75, ...){
      lines(x, col = col, bg = bg, pch = pch, type = type, ...)
      abline(v=vpos)}
plot.ts(cbind(a, b, c, d, e, f, g, h),main="Time Series", panel=my.ts.panel) vpos=8.75
my.ts.panel <- function(x, col = col, bg = bg, pch = pch, type = type,   ...){
      lines(x, col = col, bg = bg, pch = pch, type = type, ...)
      abline(v=vpos)}
plot.ts(cbind(a, b, c, d, e, f, g, h),main="Time Series", panel=my.ts.panel)
-------------------------------------------------------------------------------------------------------
RasterLayer ## gives an error, but still plots 
raster:::.imageplot(shrunk)
points(shrunk.coords, pch = ".") .imageplot showMethods("plot", classes = "RasterLayer", includeDefs = TRUE) raster:::.plotraster raster:::.imageplot raster:::.plotraster(shrunk, col = rev(terrain.colors(255)), maxpixels = 5e+05)
points(shrunk.coords, pch = ".") raster:::.imageplot(shrunk)
 abline(h = c(-80, 80), v = c(-80, 80)) plot(shrunk)
abline(h = c(-80, 80), v = c(-80, 80)) par() raster:::.imageplot plot(shrunk)
axis(1, pos = 1)
-------------------------------------------------------------------------------------------------------
#---------- method --------------
 xyplot(-1:1 ~ -1:1, type="l")
trellis.focus("panel", 1, 1)
do.call("panel.abline", list(h=0,v=0, lty=3) )
trellis.unfocus()
# --- that method has the advantage of also demonstrating 
#        how to modify an existing plot

#---------- method 2--------------

 xp <-xyplot(-2:1 ~ -2:1, type="l", panel=function(...){
 panel.xyplot(...)
 panel.abline(h=0,v=0, lty=3)} )
xp
-------------------------------------------------------------------------------------------------------
lattice xyplot panel.abline my.df <- data.frame(a = runif(10, min = -1, max = 1), b = runif(10, min = -1, max = 1))
my.plot <- xyplot(b ~ a, data = my.df)
update(my.plot, panel = function(...) {
            panel.abline(h = 0, v = 0, lty = "dotted", col = "light grey")
            panel.xyplot(...)
        })
-------------------------------------------------------------------------------------------------------
lmodel2() ggplot dat <- data.frame(a=log10(rnorm(50, 30, 10)), b=log10(rnorm(50, 20, 2)))
mod <- lmodel2(a ~ b, data=dat,"interval", "interval", 99)

#EDIT: mod is a list, with components (data.frames) regression.results and 
#        confidence.intervals containing the intercepts+slopes for different 
#        estimation methods; just put the right values into geom_abline
ggplot(dat,aes(x=b,y=a)) + geom_point() + 
   geom_abline(intercept=mod$regression.results[4,2],
            slope=mod$regression.results[4,3],colour="blue") + 
   geom_abline(intercept=mod$confidence.intervals[4,2],
            slope=mod$confidence.intervals[4,4],colour="red") + 
   geom_abline(intercept=mod$confidence.intervals[4,3],
            slope=mod$confidence.intervals[4,5],colour="red") + 
   xlim(c(-10,10)) + ylim(c(-10,10)) geom_abline() lmodel2 xlim() ylim() ggplot() ggplot() ggplot(dat,aes(x=b,y=a)) + geom_point() + 
geom_abline(intercept=fit2[1,1],slope=fit2[2,1],colour="blue") + 
geom_abline(intercept=fit2[1,2],slope=fit2[2,2],colour="red") + 
geom_abline(intercept=fit2[1,3],slope=fit2[2,3],colour="red")
-------------------------------------------------------------------------------------------------------
geom_abline library(ggplot2)
library(lmodel2)

dat <- data.frame(a=log10(rnorm(50, 30, 10)), b=log10(rnorm(50, 20, 2)))
mod <- lmodel2(a ~ b, data=dat,"interval", "interval", 99)

reg <- mod$regression.results
names(reg) <- c("method", "intercept", "slope", "angle", "p-value")

ggplot(dat) + 
  geom_point(aes(b, a)) +
  geom_abline(data = reg, aes(intercept = intercept, slope = slope, colour = method))
-------------------------------------------------------------------------------------------------------
for #Set the number of bets and number of trials and % lines
numbet <- 6000 #6000 bets
numtri <- 1000 #Run 1000 trials of the 6000 bets
perlin <- 0.05 #Show the +/- 5% lines on the graph
rantri <- 60 #The 60th trial (just a random trial to be drawn)

#Fill a matrix where the rows are the cumulative bets and the columns are the trials
xcum <- matrix(NA, nrow=numbet, ncol=numtri)
for (i in 1:numtri) {
  x <- sample(c(-1,1), numbet, replace = TRUE)
  xcum[,i] <- cumsum(x)
}

#Plot the trials as transparent lines so you can see the build up
matplot(xcum, type="l", xlab="Number of Bets", ylab="Cumulative Sum", main="Cumulative Results", col=rgb(0.01, 0.01, 0.01, 0.02))
grid()

#Sort the trials of each bet so you can pick out the desired %
xcumsor <- xcum
for (i in 1:numbet) {
  xcumsor[i,] <- xcum[i,order(xcum[i,])]
}

#Draw the upper/lower limit lines and the 50% probability line     
lines(xcumsor[, perlin*numtri], type="l", lwd=2, col=rgb(1, 0.0, 0.0)) #Lower limit
lines(xcumsor[, 0.5*numtri], type="l", lwd=3, col=rgb(0, 1, 0.0)) #50% Line
lines(xcumsor[, (1-perlin)*numtri], type="l", lwd=2, col=rgb(1, 0.0, 0.0)) #Upper limit

#Show one of the trials
lines(xcum[, rantri], type="l", lwd=1, col=rgb(1, 0.8, 0)) #Random trial

#Draw the legend
legend("bottomleft", legend=c("Various Trials", "Single Trial", "50% Probability", "Upper/Lower % Limts"), bg="white", lwd=c(1, 1, 3, 2), col=c("darkgray", "orange", "green", "red")) #Set the bet sequence and the % lines
betseq <- 1:100000 #1 to 100,000 bets
perlin <- 0.05 #Show the +/- 5% lines on the graph

#Calculate the Upper and Lower limits using perlin
#qnorm() gives the multiplier for the square root
upplim <- qnorm(1-perlin)*sqrt(betseq)
lowlim <- qnorm(perlin)*sqrt(betseq)

#Get the range for y
yran <- range(upplim, lowlim)

#Plot the upper and lower limit lines
plot(betseq, upplim, ylim=yran, type="l", xlab="", ylab="")
lines(betseq, lowlim) dralim lines dralim #Set the bet sequence and the % lines
betseq <- 0:700 #0 to 700 bets
perlin <- 0.05 #Show the +/- 5% lines on the graph

#Define a function that plots the upper and lower % limit lines
dralim <- function(stax, endx, perlin) {
  lines(stax:endx, qnorm(1-perlin)*sqrt((stax:endx)-stax))
  lines(stax:endx, qnorm(perlin)*sqrt((stax:endx)-stax))
}

#Build the plot area and draw the vertical dashed lines
plot(betseq, rep(0, length(betseq)), type="l", ylim=c(-50, 50), main="", xlab="Trial Number", ylab="Cumulative Hits")
abline(h=0)
abline(v=35, lty="dashed") #Seg 1
abline(v=185, lty="dashed") #Seg 2
abline(v=385, lty="dashed") #Seg 3
abline(v=485, lty="dashed") #Seg 4
abline(v=585, lty="dashed") #Seg 5

#Draw the % limit lines that correspond to the vertical dashed lines by calling the
#new function dralim.
dralim(0, 35, perlin) #Seg 1
dralim(36, 185, perlin) #Seg 2
dralim(186, 385, perlin) #Seg 3
dralim(386, 485, perlin) #Seg 4
dralim(486, 585, perlin) #Seg 5
dralim(586, 701, perlin) #Seg 6
-------------------------------------------------------------------------------------------------------
dput(Corl) library(zoo)

Corl <- structure(list(Date = structure(c(15155, 15064, 14974, 14882,
  14790, 14699), class = "Date"), Survey = c(60L, 55L, 48L, 48L,
    56L, 57L), Actual = c(NA, 50L, 44L, 36L, 75L, 41L)), .Names = c("Date",
      "Survey", "Actual"), row.names = c(NA, -6L), class = "data.frame")

Corl.zoo <- read.zoo(Corl, FUN=as.yearqtr)
Corl.zoo

        Survey Actual
2010 Q1     57     41
2010 Q2     56     75
2010 Q3     48     36
2010 Q4     48     44
2011 Q1     55     50
2011 Q2     60     NA

plot(Corl.zoo) my.panel <- function(...) {
   lines(...)
   #This line adds the vertical grid lines
   abline(v=time(Corl.zoo), col="lightgray", lty=3)
   panel.number <- parent.frame()$panel.number
   # if bottom panel
   if (!length(panel.number) || panel.number == NCOL(Corl.zoo)) {
      # next line only if non-labelled ticks wanted for each point
      axis(1, at = time(Corl.zoo), lab = FALSE)
      labcou <- 1 #Put a label, counting between labels
      ix <- seq(1, length(Corl.zoo), labcou)
      labs <- format(time(Corl.zoo), "%Y\nQ%q\n ")
      axis(1, at = time(Corl.zoo)[ix], lab = labs[ix], tcl = -0.5, padj=0.6, cex.axis = 1)
   }
}

plot(Corl.zoo, panel = my.panel, xaxt = "n", main="My Title", xlab="")
-------------------------------------------------------------------------------------------------------
abline smooth ggplot p=ggplot(df, aes(x=x, y=y)) + 
    geom_point(shape=ifelse(nrow(df)>49, 1, 16)) +
    geom_smooth(method=lm, fill="white", aes(colour="Fitted", linetype="Fitted")) +
    geom_smooth(method=lm, fill="red") +
    geom_abline(intercept=0, slope=1, aes(colour="Ideal", linetype="Ideal")) +
    scale_colour_manual(name="Lines", values=c("Ideal"="blue", "Fitted"="red")) +
    scale_linetype_manual(name="Lines", values=c("Ideal"="solid", "Fitted"="twodash")) +
    opts(title="Method Comparison") +
    labs(x="Control", y="Evaluation") +
    theme_bw() labs()
-------------------------------------------------------------------------------------------------------
ggplot(df, aes(x=x, y=y)) + 
    geom_point(shape=ifelse(nrow(df)>49, 1, 16)) +
    geom_smooth(method=lm, fill="white", aes(colour="Fitted", linetype="Fitted")) +
    geom_smooth(method=lm, fill="red") +
    geom_abline(intercept=0, slope=1, colour = "blue", linetype = "solid" ) +
    geom_line(data = data.frame(x=0, y=0), aes(colour = "Ideal", linetype = "Ideal")) +
    scale_colour_manual(name="Lines", values=c("Ideal"="blue", "Fitted"="red")) +
    scale_linetype_manual(name="Lines", values=c("Ideal"="solid", "Fitted"="twodash")) +
    opts(title="Method Comparison") +
    labs(x="Control", y="Evaluation") +
    theme_bw()
-------------------------------------------------------------------------------------------------------
lm() subset lin <- data.frame(x = c(0:6), y = c(0.3, 0.1, 0.9, 3.1, 5, 4.9, 6.2))
linm <- lm(y ~ x, data = lin, subset = 2:4) R> linm

Call:
lm(formula = y ~ x, data = lin, subset = 2:4)

Coefficients:
(Intercept)            x  
     -1.633        1.500  

R> fitted(linm)
         2          3          4 
-0.1333333  1.3666667  2.8666667 log() logm1 <- lm(log(y) ~ log(x), data = dat, subset = 1:7)
logm2 <- lm(log(y) ~ log(x), data = dat, subset = 8:15) dat <- transform(dat, ind = factor(1:15 <= 7))
logm3 <- lm(log(y) ~ log(x) * ind, data = dat) R> coef(logm1)
  (Intercept)        log(x) 
-0.0001487042 -0.4305802355 
R> coef(logm2)
(Intercept)      log(x) 
  0.1428293  -1.4966954 R> coef(logm3)
   (Intercept)         log(x)        indTRUE log(x):indTRUE 
     0.1428293     -1.4966954     -0.1429780      1.0661152 ind logm3 logm2 logm2 logm3 log(x) logm1 R> coefs[1] + coefs[3]
  (Intercept) 
-0.0001487042 indTRUE R> coefs[2] + coefs[4]
    log(x) 
-0.4305802 logm1 coefs[2] coefs[4] abline() plot(y ~ x, data = lin)
abline(linm) pdat <- with(dat, data.frame(x = seq(from = head(x, 1), to = tail(x,1), 
                                     by = 0.1))
pdat <- transform(pdat, yhat = c(predict(logm1, pdat[1:70,, drop = FALSE]), 
                                 predict(logm2, pdat[71:141,, drop = FALSE]))) yhat plot(y ~ x, data = dat)
lines(exp(yhat) ~ x, dat = pdat, subset = 1:70, col = "red")
lines(exp(yhat) ~ x, dat = pdat, subset = 71:141, col = "blue") plot(log(y) ~ log(x), data = dat)
lines(yhat ~ log(x), dat = pdat, subset = 1:70, col = "red")
lines(yhat ~ log(x), dat = pdat, subset = 71:141, col = "blue") pdat <- with(dat, data.frame(x = seq(from = head(x, 1), to = tail(x,1), 
                                     by = 0.1)[1:140],
                             ind = factor(rep(c(TRUE, FALSE), each = 70))))
pdat <- transform(pdat, yhat = predict(logm3, pdat)) predict() logm3 plot(y ~ x, data = dat)
lines(exp(yhat) ~ x, dat = pdat, subset = 1:70, col = "red")
lines(exp(yhat) ~ x, dat = pdat, subset = 71:141, col = "blue")
-------------------------------------------------------------------------------------------------------
daten_fit <- lm(formula = y~x, data = daten[3:5, ])

plot(y ~ x, data = daten)
points(y ~ x, data = daten[3:5, ], col="red")
abline(reg=daten_fit, col="red") rug range #points(y ~ x, data = daten[3:5, ], col="red")
abline(reg=daten_fit, col="red")
rug(range(daten[3:5, 1]), lwd=3, col="red")
-------------------------------------------------------------------------------------------------------
abline() # The dataset:
daten <- data.frame(x = c(0:6), y = c(0.3, 0.1, 0.9, 3.1, 5, 4.9, 6.2))
# make a linear fit for the datapoints 3, 4, 5
mod <- lm(y~x, data = daten, subset = 3:5) x xr <- with(daten, range(x[3:5])) pred <- data.frame(x = seq(from = xr[1], to = xr[2], length = 50))
pred <- transform(pred, yhat = predict(mod, newdata = pred)) abline() plot(y ~ x, data = daten)
abline(mod) lines(yhat ~ x, data = pred, col = "red", lwd = 2) abline() ## range of all `x` data
xr2 <- with(daten, range(x))
## same as before
pred <- data.frame(x = seq(from = xr2[1], to = xr2[2], length = 100))
pred <- transform(pred, yhat = predict(mod, newdata = pred))

## plot the data and the fitted model line
plot(y ~ x, data = daten)
lines(yhat ~ x, data = pred)

## add emphasis to the interval used in fitting
with(pred, lines(yhat ~ x, data = pred, subset = x >= xr[1] & x <= xr[2],
                 lwd = 2, col = "red")) subset subset TRUE FALSE lines() R> head(with(pred, x >= xr[1] & x <= xr[2]))
[1] FALSE FALSE FALSE FALSE FALSE FALSE
-------------------------------------------------------------------------------------------------------
span.b <- 20
threshold.b <- 0.2
dy.b <- c(rep(NA, span.b), diff(y, lag = span.b))
span.f <- 10
threshold.f <- 0.05
dy.f <- c(diff(y, lag = span.f), rep(NA, span.f))
down <- which(dy.b < -1 * threshold.b & abs(dy.f) < threshold.f)
abline(v = down)
-------------------------------------------------------------------------------------------------------
x <- runif(50, -10, 10)
y <- runif(50, -10, 10) abline x=0 y=0 plot(x, y)
abline(h=0)
abline(v=0) ggplot2 library(ggplot2)
qplot(x, y) + geom_vline(xintercept=0) + geom_hline(yintercept=0)
-------------------------------------------------------------------------------------------------------
hist(data)
abline(v=mean(data),col="blue")
-------------------------------------------------------------------------------------------------------
x <- rnorm(100)
mx <- mean(x)
hist(x)
abline(v = mx, col = "blue", lwd = 2) x <- rnorm(100, mean = 10)
mx <- mean(x)
hist(x)
lines( c(mx,mx), c(0,15), col = "red", lwd = 2)
lines(c(10, 11.5), c(0, 10), col = "steelblue", lwd = 3, lty = 22)
text(mx, 18 , round(mx, 2))
text(mx, 12 , "big", cex = 5)
-------------------------------------------------------------------------------------------------------
fun1 <- function(x) 1-abs(x)
fun2 <- function(x) -(1-abs(x))
plot (fun1, -1, 1,xlim=c(-2,2),ylim=c(-2,2),pty="s",col=2);abline(h=0,v=0)
plot (fun2, -1, 1,col=2,add=TRUE)
-------------------------------------------------------------------------------------------------------
df <- data.frame(x=1, y=1)
df_poly <- data.frame(
    x=c(-Inf, Inf, -Inf),
    y=c(-Inf, Inf, Inf)
)

ggplot(df, aes(x, y)) + 
    geom_blank() + 
    geom_abline(slope=1, intercept=0) + 
    geom_polygon(data=df_poly, aes(x, y), fill="blue", alpha=0.2) +
-------------------------------------------------------------------------------------------------------
ggplot Inf -Inf ggplot ggplot ggplot buildPoly <- function(xr, yr, slope = 1, intercept = 0, above = TRUE){
    #Assumes ggplot default of expand = c(0.05,0)
    xrTru <- xr + 0.05*diff(xr)*c(-1,1)
    yrTru <- yr + 0.05*diff(yr)*c(-1,1)

    #Find where the line crosses the plot edges
    yCross <- (yrTru - intercept) / slope
    xCross <- (slope * xrTru) + intercept

    #Build polygon by cases
    if (above & (slope >= 0)){
        rs <- data.frame(x=-Inf,y=Inf)
        if (xCross[1] < yrTru[1]){
            rs <- rbind(rs,c(-Inf,-Inf),c(yCross[1],-Inf))
        }
        else{
            rs <- rbind(rs,c(-Inf,xCross[1]))
        }
        if (xCross[2] < yrTru[2]){
            rs <- rbind(rs,c(Inf,xCross[2]),c(Inf,Inf))
        }
        else{
            rs <- rbind(rs,c(yCross[2],Inf))
        }
    }
    if (!above & (slope >= 0)){
        rs <- data.frame(x= Inf,y= -Inf)
        if (xCross[1] > yrTru[1]){
            rs <- rbind(rs,c(-Inf,-Inf),c(-Inf,xCross[1]))
        }
        else{
            rs <- rbind(rs,c(yCross[1],-Inf))
        }
        if (xCross[2] > yrTru[2]){
            rs <- rbind(rs,c(yCross[2],Inf),c(Inf,Inf))
        }
        else{
            rs <- rbind(rs,c(Inf,xCross[2]))
        }
    }
    if (above & (slope < 0)){
        rs <- data.frame(x=Inf,y=Inf)
        if (xCross[1] < yrTru[2]){
            rs <- rbind(rs,c(-Inf,Inf),c(-Inf,xCross[1]))
        }
        else{
            rs <- rbind(rs,c(yCross[2],Inf))
        }
        if (xCross[2] < yrTru[1]){
            rs <- rbind(rs,c(yCross[1],-Inf),c(Inf,-Inf))
        }
        else{
            rs <- rbind(rs,c(Inf,xCross[2]))
        }
    }
    if (!above & (slope < 0)){
        rs <- data.frame(x= -Inf,y= -Inf)
        if (xCross[1] > yrTru[2]){
            rs <- rbind(rs,c(-Inf,Inf),c(yCross[2],Inf))
        }
        else{
            rs <- rbind(rs,c(-Inf,xCross[1]))
        }
        if (xCross[2] > yrTru[1]){
            rs <- rbind(rs,c(Inf,xCross[2]),c(Inf,-Inf))
        }
        else{
            rs <- rbind(rs,c(yCross[1],-Inf))
        }
    }

    return(rs)
} range() #Generate some data
dat <- data.frame(x=runif(10),y=runif(10))

#Select two of the points to define the line
pts <- dat[sample(1:nrow(dat),size=2,replace=FALSE),]

#Slope and intercept of line through those points
sl <- diff(pts$y) / diff(pts$x)
int <- pts$y[1] - (sl*pts$x[1])

#Build the polygon
datPoly <- buildPoly(range(dat$x),range(dat$y),
            slope=sl,intercept=int,above=FALSE)

#Make the plot
p <- ggplot(dat,aes(x=x,y=y)) + 
        geom_point() + 
        geom_abline(slope=sl,intercept = int) +
        geom_polygon(data=datPoly,aes(x=x,y=y),alpha=0.2,fill="blue")
print(p) set.seed(1)
dat <- data.frame(x=runif(6,-2,2),y=runif(6,-2,2),
        var1=rep(c("A","B"),3),var2=rep(c("C","D"),3))
#Create polygon data frame
df_poly <- buildPoly(range(dat$x),range(dat$y))

ggplot(data=dat,aes(x,y)) + 
    facet_wrap(~var2) +
    geom_abline(slope=1,intercept=0,lwd=0.5)+
    geom_point(aes(colour=var1),size=3) + 
    scale_color_manual(values=c("red","blue"))+
    geom_polygon(data=df_poly,aes(x,y),fill="blue",alpha=0.2)
-------------------------------------------------------------------------------------------------------
> coef(res)
  (Intercept) concentration 
   -210.61098      22.00441 concentration <- c(1,10,20,30,40,50)
signal <- c(4, 22, 44, 244, 643, 1102)
plot(concentration, signal)
res <- lm(signal ~ concentration)
abline(res) cfs <- coef(res)
distancePointLine(y=signal[5], x=concentration[5], slope=cfs[2], intercept=cfs[1]) concentration == 40 length(concentration) pt.sel <- ( concentration == 40 )
> pt.sel
[1] FALSE FALSE FALSE FALSE  TRUE FALSE
> distancePointLine(y=signal[pt.sel], x=concentration[pt.sel], slope=cfs["concentration"], intercept=cfs["(Intercept)"])
     1.206032
-------------------------------------------------------------------------------------------------------
x <- runif(100)
quantile(x,probs=c(.025,.975)) qts <- quantile(x,probs=c(.05,.95))
hist(x)
abline(v=qts[1],col="red")
abline(v=qts[2],col="red")
-------------------------------------------------------------------------------------------------------
abline(lm(vixee ~ returnee))
-------------------------------------------------------------------------------------------------------
plot(x, y, col = 'red', type = 'n', lwd = 3, pch = 15)
abline(h = seq(0, 10, .5), col = 'lightgray', lty = 3)
abline(v = seq(0, 10, .5), col = 'lightgray', lty = 3)
par(new=TRUE)
plot(x, y, col = 'red', type = 'o', lwd = 3, pch = 15) par
-------------------------------------------------------------------------------------------------------
plot() type = "n" abline() grid() points() x <- seq(0, 10)
y <- x
plot(x, y, type = "n")
abline(h = seq(0, 10, .5), col = 'lightgray', lty = 3)
abline(v = seq(0, 10, .5), col = 'lightgray', lty = 3)
points(x, y, col = 'red', type = 'o', lwd = 3, pch = 15) ## using `grid()`
plot(x, y, type = "n")
grid()
points(x, y, col = 'red', type = 'o', lwd = 3, pch = 15) ?grid abline()
-------------------------------------------------------------------------------------------------------
panel.first plot() abline() plot(1:4, panel.first = 
       c(abline(h = 1:4, lty = 2, col = 'grey') 
        ,abline(v = 1:4, lty = 2, col = 'grey')))
-------------------------------------------------------------------------------------------------------
par(bg = 3)
image.plot(s,xlab="P/E Ratio", ylab="VIX", 
    main="Contour Map of SPY Returns vs P/E Ratio and Vix") 
abline(v=(seq(0,100,5)), col=6, lty="dotted") 
abline(h=(seq(0,100,5)), col=6, lty="dotted") 
contour(s, add=TRUE)
-------------------------------------------------------------------------------------------------------
library(manipulate)
data = matrix(rnorm(20), ncol = 2)

example <- function(data, a, b){
  plot(data[,1],data[,2])
  abline(a = a, b = b)
}

manipulate(
  example(data, a, b),
  a = slider(-5,5),
  b = slider(-5,5)
) manipulate locator
-------------------------------------------------------------------------------------------------------
locator() repeat {
  click.loc <- locator(1)
  if(!is.null(click.loc)) abline(v=click.loc$x)
  else break
} abline(h=click.loc$y)
-------------------------------------------------------------------------------------------------------
locator() plot(cars)
xy <- locator(n=2)
lines(xy, col="red", lwd=5)
lm(y~x, xy)
abline(coef(lm(y~x, xy)))
coef(lm(y~x, xy))
(Intercept)           x 
  33.142094    1.529687 lm abline(coef(lm(dist~speed, cars)), col="blue") abline lm locator ?locator lm loess
-------------------------------------------------------------------------------------------------------
> intercept <- 1.0
> fit <- lm(I(x - intercept) ~ 0 + y, lin)
> summary(fit) 0 + lm > abline(intercept, coef(fit)) y ~ x x ~ y
-------------------------------------------------------------------------------------------------------
with(lin, plot(y,x) )
lm_shift_up <- lm(x ~ y +0 + offset(rep(1, nrow(lin))), data=lin)
abline(1,coef(lm_shift_up))
-------------------------------------------------------------------------------------------------------
boxplot(count ~ spray, data = InsectSprays, col = "lightgray", main = "plot title")
abline(h = 1:25, lty=1.5, lwd=0.5, col=336)
boxplot(count ~ spray, data = InsectSprays, col = "lightgray", add = TRUE)
-------------------------------------------------------------------------------------------------------
library(lattice)
?xyplot
?panel.violin
-------------------------------------------------------------------------------------------------------
plot(c(sw_sd,aa_sd),c(sw_r,aa_r), pch = 22, 
        col = rep(c('forestgreen','blue'),each = 2),main="Capital Allocation Lines", 
        xlab="Standard Deviation", ylab="Expected Return")
abline(lm(sw_r~sw_sd),col = 'forestgreen',lwd = 3)
abline(lm(aa_r~aa_sd),col = 'blue',lwd = 3) points lines plot points lines abline plot.new plot.window plot plot plot ?plot ?plot.default type = "n"
-------------------------------------------------------------------------------------------------------
lattice ?levelplot abline lattice panel panel.* panel.abline panel ?levelplot x <- seq(pi/4, 5 * pi, length.out = 100)
y <- seq(pi/4, 5 * pi, length.out = 100)
r <- as.vector(sqrt(outer(x^2, y^2, "+")))
grid <- expand.grid(x=x, y=y)
grid$z <- cos(r^2) * exp(-r/(pi^3))
levelplot(z~x*y, grid,
        panel = function(...){
            panel.levelplot(...)
            panel.abline(h = 2.5)
            panel.abline(v = 2.5)
        }, 
        cuts = 50, scales=list(log="e"), xlab="",
        ylab="", main="Weird Function", sub="with log scales",
        colorkey = FALSE, region = TRUE) panel.levelplot panel.abline
-------------------------------------------------------------------------------------------------------
mat2 mat1 statSim statObs statSim list( obs = statObs , sumFit = sum(statSim > statObs)/numR) obs sumFit max(statSim) sumFit max resamplerSimAlt <- function(mat1, mat2, numR, graph = FALSE)
{
  statSim <- numeric(numR)
  mat1vcv <- cov(mat1)
  mat2vcvT <- cov(mat2)
  ltM1 <- mat1vcv[col(mat1vcv) <= row(mat1vcv)]
  ltM2T <- mat2vcvT[col(mat2vcvT) <= row(mat2vcvT)]
  statObs <- cor(ltM1, ltM2T)                           
  indice <- c(1:length(mat2))
  resamplesIndices <- lapply(1:numR, function(i) sample(indice, replace = F))
  for (i in 1:numR)
  {
    ss <- mat2[sample(resamplesIndices[[i]])]
    ss <- matrix(ss, nrow = dim(mat2)[[1]], ncol = dim(mat2)[[2]])
    mat2ss <- cov(ss)
    ltM2ss <- mat2ss[col(mat2ss) <= row(mat2ss)]
    statSim[i] <- cor(ltM1, ltM2ss)
  }
  if (graph == TRUE)
  {
    plot(1, main = "resampled data density distribution", xlim = c(0, statObs+0.1), ylim = c(0,14))
    points(density(statSim), type="l", lwd=2)
    abline(v = statObs)
    text(10, 10, "observed corelation = ")
  }
  list( obs = statObs , sumFit = sum(statSim > statObs)/numR, max=max(statSim))
} > mat1 <- matrix(runif(25),5,5)
> mat2 <- mat1+0.2
> resamplerSimAlt(mat1, mat2, 10000)
$obs
[1] 1

$sumFit
[1] 0

$max
[1] 0.94463 mat2 > mat2 <- matrix(runif(25),5,5)
> resamplerSimAlt(mat1, mat2, 10000)
$obs
[1] 0.31144

$sumFit
[1] 0.9124

$max
[1] 0.9231
-------------------------------------------------------------------------------------------------------
lm optim set.seed(5)
d <- data.frame(x=seq(-5, 5, len=51))
d$y <- 50 - 0.3*d$x^2 + rnorm(nrow(d))
M <- 50 qM <- function(a, b, x, M) {
  c <- M - (3*b^2)/(4*a)
  a*x^2 + b*x + c
} ff <- function(ab, d, M) {
  p <- qM(ab[1], ab[2], d$x, M)
  y <- d$y
  sum((p-y)^2)
} lm m0 <- lm(y ~ I(x^2) + x, data=d)
start <- coef(m0)[2:3] ff o <- optim(start, ff, d=d, M=M)
o$par lm plot(d)
xs <- seq(-5, 5, len=101)
lines(xs, predict(m0, newdata=data.frame(x=xs)), col="gray")
lines(xs, qM(o$par[1], o$par[2], xs, M))
abline(h=50, lty=3)
-------------------------------------------------------------------------------------------------------
Time<- as.POSIXct(c("2011-10-16 09:33","2011-10-16 09:54") )
Y1<-c("50259", "41090") 
Y2<-c("9823", "98723") 

plot(Time,as.numeric(Y1),type="l",col="red", ylim=c(9800, 98800))
abline(lm(as.numeric(Y2)~Time),col="green")
-------------------------------------------------------------------------------------------------------
# Simulate data
set.seed(12345)
x = seq(0, 10, len=50)
y = 2 + 0.5 * x + rnorm(length(x), 0, 0.1)
data = data.frame(x, y) # Fit model
fit = lm(y ~ x, data=data)
summary(fit) > summary(fit)

Call:
lm(formula = y ~ x, data = data)

Residuals:
     Min       1Q   Median       3Q      Max 
-0.26017 -0.06434  0.02539  0.06238  0.20008 

Coefficients:
            Estimate Std. Error t value Pr(>|t|)    
(Intercept) 2.011759   0.030856   65.20   <2e-16 ***
x           0.501240   0.005317   94.27   <2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 

Residual standard error: 0.1107 on 48 degrees of freedom
Multiple R-squared: 0.9946, Adjusted R-squared: 0.9945 
F-statistic:  8886 on 1 and 48 DF,  p-value: < 2.2e-16 # Make plot
dev.new(width=4, height=4)
plot(x, y, ylim=c(0,10))
abline(fit$coef[1], fit$coef[2])
-------------------------------------------------------------------------------------------------------
plot (x = 1:10, y = rnorm (10, 5, 2))
grid (lty = 6, col = "cornsilk2")

xaxp <- par("xaxp")
yaxp <- par("yaxp")

abline(v=seq(xaxp[1], xaxp[2], (xaxp[2]-xaxp[1])/xaxp[3]), lty=6, col = "cornsilk2")
abline(h=seq(yaxp[1], yaxp[2], (yaxp[2]-yaxp[1])/yaxp[3]), lty=6, col = "cornsilk2")
-------------------------------------------------------------------------------------------------------
# Simulate data
n.row = 100
n.col = 10

set.seed(12345)
group = factor(sample(2, n.row, replace=T))
data  = data.frame(matrix(rnorm(n.row*n.col), nrow=n.row)) # Re-calculate columnwise test statisitics many times while permuting class labels
perms = replicate(500, apply(data[sample(nrow(data)), ], 2, function(x) wilcox.test(x[group==1], x[group==2], exact=F, alternative="two.sided", correct=T)$stat)) # For each permuted replication, calculate the max test statistic across the multiple comparisons
perms.max = apply(perms, 2, max) # Identify critical value 
crit = sort(perms.max)[round((1-0.05)*length(perms.max))] # Plot 
dev.new(width=4, height=4)
hist(perms.max)
abline(v=crit, col='red') > length(which(perms.max>1600))/length(perms.max)
[1] 0.074
-------------------------------------------------------------------------------------------------------
christi <- read.table("http://dl.dropbox.com/u/75403/stover_data.txt", sep="\t", header=TRUE) loess fit <- loess(org_count~date, data=christi) predict.loess diff x <- 200:800
px <- predict(fit, newdata=x)
px1 <- diff(px)

which.max(px1)
[1] 367 200+367=567 par(mfrow=c(1, 2))
plot(x, px, main="loess model")

plot(x[-1], px1, main="diff(loess model)")
abline(v=567, col="red")
-------------------------------------------------------------------------------------------------------
SwStr K plot(res$SwStr, res$K) with(res,plot(K~SwStr)) K SwStr lm abline(graphic,...) predict K=c(.259, .215, .224, .223, .262, .233)
SwStr=c(.130, .117, .117, .114, .113, .111)
g <- lm(K~SwStr-1)
par(las=1,bty="l")  ## my favourites
plot(K~SwStr)
P <- predict(g)
lines(SwStr,P) newdata predict
-------------------------------------------------------------------------------------------------------
plot(d)    
 abline(lm(x~y**2,data=d), col="black") lines(smooth.spline(x, y))
-------------------------------------------------------------------------------------------------------
panel.first plot.default hist ?plot.default hist(WindSpeed, breaks=c(0:31), freq=TRUE, col="blue", xaxt="n", yaxt="n", 
     xlab="Wind Speed (m/s)", main="Foo", 
     cex.main=1.5, cex.axis=1, cex.lab=1, tck=1, font.lab=2,
     panel.first={
        axis(1, tck=1, col.ticks="light gray")
        axis(1, tck=-0.015, col.ticks="black")
        axis(2, tck=1, col.ticks="light gray", lwd.ticks="1")
        axis(2, tck=-0.015)
        minor.tick(nx=5, ny=2, tick.ratio=0.5)
        box()
 })
-------------------------------------------------------------------------------------------------------
# Comparison of Linear Regression & PCA
# Generate sample data

set.seed(39) # gives a decent-looking example
np <- 10 # number of data points
x <- -np:np
e <- rnorm(length(x), 0, 10)
y <- rnorm(1, 0, 2) * x + 3*rnorm(1, 0, 2) + e

# Plot the main data & residuals

plot(x, y, main = "Regression minimizes the y-residuals & PCA the normals", asp = 1)
yx.lm <- lm(y ~ x)
lines(x, predict(yx.lm), col = "red", lwd = 2)
segments(x, y, x, fitted(yx.lm), col = "pink")

# Now the PCA using built-in functions
# rotation = loadings = eigenvectors

r <- prcomp(cbind(x,y), retx = TRUE)
b <- r$rotation[2,1] / r$rotation[1,1] # gets slope of loading/eigenvector 1
a <- r$center[2] - b * r$center[1]
abline(a, b, col = "blue") # Plot 1st PC

# Plot normals to 1st PC

X <- pointOnLineNearPoint(x, y, b, a)
segments( x, y, X[,1], X[,2], col = "lightblue1")

###### Needed Functions

pointOnLineNearPoint <- function(Px, Py, slope, intercept) {
    # Px, Py is the point to test, can be a vector.
    # slope, intercept is the line to check distance.

    Ax <- Px-10*diff(range(Px))
    Bx <- Px+10*diff(range(Px))
    Ay <- Ax * slope + intercept
    By <- Bx * slope + intercept
    pointOnLine(Px, Py, Ax, Ay, Bx, By)
    }

pointOnLine <- function(Px, Py, Ax, Ay, Bx, By) {

    # This approach based upon comingstorm's answer on
    # stackoverflow.com/questions/3120357/get-closest-point-to-a-line
    # Vectorized by Bryan

    PB <- data.frame(x = Px - Bx, y = Py - By)
    AB <- data.frame(x = Ax - Bx, y = Ay - By)
    PB <- as.matrix(PB)
    AB <- as.matrix(AB)
    k_raw <- k <- c()
    for (n in 1:nrow(PB)) {
        k_raw[n] <- (PB[n,] %*% AB[n,])/(AB[n,] %*% AB[n,])
        if (k_raw[n] < 0)  { k[n] <- 0
            } else { if (k_raw[n] > 1) k[n] <- 1
                else k[n] <- k_raw[n] }
        }
    x = (k * Ax + (1 - k)* Bx)
    y = (k * Ay + (1 - k)* By)
    ans <- data.frame(x, y)
    ans
    }
-------------------------------------------------------------------------------------------------------
dfrm <- data.frame(tm <-1:364, ev1=ev1, ev2=ev2) ev1dens <-  density(dfrm$tm, weights=dfrm$ev1/sum(dfrm$ev1), from=0, to=364, n=364)
 plot( ev1dens, lwd=5)
 which.max(ev1dens$y)
#[1] 326
 abline(v=326)  # which(cumsum(ev1dens$y[ order(ev1dens$y, decreasing =TRUE) ])/sum(ev1dens$y) > 0.9)[1]
#[1] 124
 ev1dens$x[order(ev1dens$y, decreasing =TRUE) ][124]
#1] 240.6612 ev1dens <-  density(dfrm$tm, weights=dfrm$ev1/sum(dfrm$ev1), from=0, to=364)
 which(cumsum(ev1dens$y[ order(ev1dens$y, decreasing =TRUE) ])/sum(ev1dens$y) > 0.9)[1]
# [1] 175
 ev1dens$x[order(ev1dens$y, decreasing =TRUE) ][175]
# [1] 240.0548
 idx <- order(ev1dens$y, decreasing =TRUE)
  lines(ev1dens$x[idx], ev1dens$y[idx], lty=3, lwd=2.5, col="red")
  abline(v=240, col="green", lwd=3) require(hexbin)
 hexev1 <- with(dfrm,  hexbin(tm, ev1))
 plot(hexev1)
 hexev2 <- with(dfrm,  hexbin(tm, ev2))
 plot(hexev2)
 plot(hexev1) > min(which(cumsum(ev1) >= sum(ev1)*(x/100) ) )
[1] 317
> min(which(cumsum(ev2) >= sum(ev2)*(x/100) ) )
[1] 112
-------------------------------------------------------------------------------------------------------
rq require(quantreg)
 data(stackloss); fit <- rq(stack.loss ~ Air.Flow, .5, data=stackloss)
 with(stackloss,   plot(Air.Flow, stack.loss))
 abline(a=coef(fit)[1], b=coef(fit)[2]) loess fit <-loess(stack.loss ~ Air.Flow, data=stackloss, family="symmetric")
plot(stack.loss ~ Air.Flow, data=stackloss)
with(stackloss, lines(sort(unique(Air.Flow)),  
                      predict(fit, data.frame(Air.Flow=sort(unique(Air.Flow))))))
-------------------------------------------------------------------------------------------------------
library(zoo)
my.ts <-zoo(0:1000,as.Date("2000-01-01")+0:1000)
plot(my.ts, xaxt="n")

years <-index(my.ts)[format(index(my.ts),"%m-%d") %in% "01-01"]
other.quarters <- index(my.ts)[ format(index(my.ts), "%m-%d") %in% c("04-01", "07-01","10-01")]
axis.Date(1, at=years, label=format(years,"%y"))
axis.Date(1, at=other.quarters, label=format(other.quarters, "%b")) grid(nx=NA, ny=NULL)
abline(v=c(years, other.quarters),col = "lightgray", lty = "dotted", lwd = par("lwd"))
-------------------------------------------------------------------------------------------------------
abline h v abline(h=0:50, v=c(0,5,10,15), lty=3, col="lightgrey")
-------------------------------------------------------------------------------------------------------
ind <- function(x) {
  # Divide each column by the first non-NA value
  # (There may already be a function to do that.)
  coredata(x) <- t(t(coredata(x)) / apply(coredata(x),2,function(u){ c(u[!is.na(u)&u!=0],NA)[1] }))
  x
}
x <- cbind( Ad(GSPC), Ad(VIX) )
x <- x["2011-11::"]

# Using base graphics
matplot( 
  index(x), coredata(ind(x)), 
  xlab="", ylab="", main="",
  type="l", lty=1, lwd=3, axes=FALSE 
)
abline(h=1, lty=3, col="lightgrey")
axis(2, las=1)
axis.Date(1, index(x))
box()
legend( "topleft", gsub("\\..*", "", names(x)), lty=1, lwd=3, col=1:2 )

# If you prefer ggplot2
library(ggplot2)
library(reshape2)
d <- data.frame( date = index(x), coredata(ind(x)) )
names(d) <- gsub("\\..*", "", names(d))
d <- melt(d, id.vars="date")
ggplot(d, aes(date, value, color=variable)) + geom_line(size=2)
-------------------------------------------------------------------------------------------------------
abline png("strangeplot.png",width=800)
#extend y-axis to fit inside labels and remove box
plot(b,type="n",xaxt="n",yaxt="n",ylab="",xlab="",ylim=c(min(b)-30,max(b)),bty="n"))
#use 'mpg' to get labels inside
axis(1,time(b)[ind], format(time(b)[ind]), las=2, cex.axis=0.6,tick=F,mgp=c(0,-2.5,0))
axis(2,tick=F,las=1)
#you locate lines slightly to the left of label...
abline(h=seq(0,200,by=50),v=time(b)[ind]-0.5,col=gray(0.9))
#...so you need to add extra single line in the end 
abline(v=max(time(b)[ind])+0.5,col=gray(0.9))
#plot at the end to get it above grid
points(b,type="l")
dev.off()
-------------------------------------------------------------------------------------------------------
plot(mydf$var2, mydf$var1, xlab="ave.ear", ylab="rtemp", 
    xlim=c(25,45), ylim=c(25,45), col=c('green', 'red')[surv+1])
abline(lm.pos1)
abline(h=37.6,v=0,col="gray10",lty=20)
text(25,38.1,parse(text='37.6*degree'),col='gray10')
abline(h=34,v=0,col="gray10",lty=20)
text(25,34.5,parse(text='34*degree'),col='gray10')
-------------------------------------------------------------------------------------------------------
is.OHLC plot plot.xts2 <- function (x, y = NULL, type = "l", auto.grid = TRUE, major.ticks = "auto", 
    minor.ticks = TRUE, major.format = TRUE, bar.col = "grey", 
    candle.col = "white", ann = TRUE, axes = TRUE, col = "black", ...) 
{
    series.title <- deparse(substitute(x))
    ep <- axTicksByTime(x, major.ticks, format = major.format)
    otype <- type
    if (xts:::is.OHLC(x) && type %in% c("candles", "bars")) {
        x <- x[, xts:::has.OHLC(x, TRUE)]
        xycoords <- list(x = .index(x), y = seq(min(x), max(x), 
                length.out = NROW(x)))
        type <- "n"
    }
    else {
        if (NCOL(x) > 1) 
            warning("only the univariate series will be plotted")
        if (is.null(y)) 
            xycoords <- xy.coords(.index(x), x[, 1])
    }
    plot(xycoords$x, xycoords$y, type = type, axes = FALSE, ann = FALSE, 
        col = col, ...)
    if (auto.grid) {
        abline(v = xycoords$x[ep], col = "grey", lty = 4)
        grid(NA, NULL)
    }
    if (xts:::is.OHLC(x) && otype == "candles") 
        plot.ohlc.candles(x, bar.col = bar.col, candle.col = candle.col, 
            ...)
    dots <- list(...)
    if (axes) {
        if (minor.ticks) 
            axis(1, at = xycoords$x, labels = FALSE, col = "#BBBBBB", 
                ...)
        axis(1, at = xycoords$x[ep], labels = names(ep), las = 1, 
            lwd = 1, mgp = c(3, 2, 0), ...)
        axis(2, ...)
    }
    box()
    if (!"main" %in% names(dots)) 
        title(main = series.title)
    do.call("title", list(...))
    assign(".plot.xts", recordPlot(), .GlobalEnv)
}

plot.xts2(as.xts(sample_matrix[,1]), col = "blue")
-------------------------------------------------------------------------------------------------------
X # generate some artificial data
reset
set sample 200
set table 'rnd.dat'
plot invnorm(rand(0))
unset table

# display the CDF
unset key
set yrange [0:1]
perc80=system("cat rnd.dat | sed '1,4d' | awk '{print $2}' | sort -n | \
          awk 'BEGIN{i=0} {s[i]=$1; i++;} END{print s[int(NR*0.8-0.5)]}'")
set arrow from perc80,0 to perc80,0.8 nohead lt 2 lw 2
set arrow from graph(0,0),0.8 to perc80,0.8 nohead lt 2 lw 2
plot 'rnd.dat' using 2:(1./200.) smooth cumulative perc90 arrow 0.8 table trunc(rank(x))/length(x) Rscript -e 'x=read.table("~/rnd.dat")[,2]; sort(x)[trunc(length(x)*.8)]' rnd.dat quantile x <- rnorm(200)
xs <- sort(x)
xf <- (1:length(xs))/length(xs)
plot(xs, xf, xlab="X", ylab="Cumulative frequency")
## quick outline of the 80th percentile rank
perc80 <- xs[trunc(length(x)*.8)]
abline(h=.8, v=perc80) 
## alternative solution
plot(ecdf(x))
segments(par("usr")[1], .8, perc80, .8)
segments(perc80, par("usr")[3], perc80, .8)
-------------------------------------------------------------------------------------------------------
axis Date axis.Date abline z=data.frame(
  x=seq(as.Date("2001-01-01"), by="+1 month", length.out=10)
  y=1:10
)
plot(y~x, data=z)
abline(v=axis.Date(1, z$x), col="grey80")
-------------------------------------------------------------------------------------------------------
?grid abline(h = ., v = .) plot(x,y)
abline(v = pretty(extendrange(z$x)), 
       h = pretty(extendrange(z$y)),
       col = 'lightgrey', lty = "dotted")
points(x,y, pch=16)
-------------------------------------------------------------------------------------------------------
abline x=strptime(20010101:20010110,format="%Y%m%d")
y=1:10

plot(x,y)
grid(nx=NA, ny=NULL)
abline(v=axis.POSIXct(1, x=pretty(x)),col = "lightgray", lty = "dotted", lwd = par("lwd")) my.grid <-function(){
grid(nx=NA, ny=NULL)
abline(v=axis.POSIXct(1, x=pretty(x)),col = "lightgray", lty = "dotted", lwd =
par("lwd"))
}

plot(x,y)
my.grid()
-------------------------------------------------------------------------------------------------------
?survreg library(survival)
y <- rweibull(1000, shape=2, scale=5)
r <- survreg(Surv(y)~1, dist="weibull")
a <- 1/r$scale      # Approximately 2
b <- exp( coef(r) ) # Approximately 5
y2 <- b * ( -ln( 1-runif(1000) ) ) ^(1/a)
y3 <- rweibull(1000, shape=a, scale=5)
# Check graphically that the distributions are the same
plot(sort(y), sort(y2))
abline(0,1)
-------------------------------------------------------------------------------------------------------
df<-data.frame(x=sort(x),y=qnorm(ppoints(length(x)))) 
probs <- c(0.01, 0.05, seq(0.1, 0.9, by = 0.1), 0.95, 0.99)
qprobs<-qnorm(probs)

xl <- quantile(x, c(0.25, 0.75))
yl <-  qnorm(c(0.25, 0.75))
slope <- diff(yl)/diff(xl)
int <- yl[1] - slope * xl[1]
ggplot(data = df, aes(x = x, y = y)) + geom_point() + geom_abline(intercept = int,slope = slope)+scale_y_continuous(limits=range(qprobs), breaks=qprobs, labels = 100*probs)+labs(y ="Percent" , x="Data") fd<-fitdistr(x, "normal") #Maximum-likelihood Fitting of Univariate Dist from MASS 
xp_hat<-fd$estimate[1]+qprobs*fd$estimate[2]  #estimated perc. for the fitted normal
v_xp_hat<- fd$sd[1]^2+qprobs^2*fd$sd[2]^2+2*qprobs*fd$vcov[1,2] #var. of estimated perc
xpl<-xp_hat + qnorm(0.025)*sqrt(v_xp_hat)  #lower bound
xpu<-xp_hat + qnorm(0.975)*sqrt(v_xp_hat)  #upper bound

df.bound<-data.frame(xp=xp_hat,xpl=xpl, xpu = xpu,nquant=qprobs) geom_line(data=df.bound,aes(x = xp, y = qprobs))+
geom_line(data=df.bound,aes(x = xpl, y = qprobs))+
geom_line(data=df.bound,aes(x = xpu, y = qprobs))
-------------------------------------------------------------------------------------------------------
dfrm <- data.frame(method=LETTERS[1:3], lcl=c(-5,-9,-8), 
                   mean=c(4,2,4), ucl=c(15,13,16), var=c(27,33,36))
# I use stripchart to avoid axis relabeling and casting of factor to numeric
# with default plot function
stripchart(mean ~ seq(1,3), data=dfrm, vertical=TRUE, ylim=c(-10,20),
           group.names=levels(dfrm$method), pch=19)
with(dfrm, arrows(1:3, mean-lcl, 1:3, mean+lcl, angle=90, code=3, length=.1))
abline(h=0, lty=2)
-------------------------------------------------------------------------------------------------------
## your data with different labels
dat <- data.frame(cutpoint = c(5, 7, 9),
                  TPR = c(0.56, 0.78, 0.91),
                  FPR = c(0.01, 0.19, 0.58))

## plot version 1    
op <- par(xaxs = "i", yaxs = "i")
plot(TPR ~ FPR, data = dat, xlim = c(0,1), ylim = c(0,1), type = "n")
with(dat, lines(c(0, FPR, 1), c(0, TPR, 1), type = "o", pch = 25, bg = "black"))
text(TPR ~ FPR, data = dat, pos = 3, labels = dat$cutpoint)
abline(0, 1)
par(op) plot() par() with(dat, lines(....)) type = "o" text(....) pos cutpoint abline() 0 1 0 1 op plot(TPR ~ FPR, data = dat, xlim = c(0,1), ylim = c(0,1), type = "n")
with(dat, lines(c(0, FPR, 1), c(0, TPR, 1), type = "o", pch = 25, bg = "black"))
text(TPR ~ FPR, data = dat, pos = 3, labels = dat$cutpoint)
abline(0, 1)
-------------------------------------------------------------------------------------------------------
plot(pos, type = 'n', xlim = range(c(start, end)), ylim = c(13,0))
grid()
segments(start, pos, end, pos) r <- par('usr') 
plot(pos, type = 'n', xlim = range(c(start, end)), ylim = c(13.5,0.5), xlab = '', 
    xaxt = 'n', yaxt = 'n', panel.first = rect(r[1], r[3], r[2], r[4], col = 'goldenrod'))
# abline(h = 1:13, col = 'white')
# abline(v = 1:13, col = 'white')
grid(lty = 1, col = 'white')
axis(1, 1:13, 1:13, cex.axis = 0.8)
axis(2, 1:13, 1:13, las = 1, cex.axis = 0.8)
segments(start, pos + 0.5, end, pos + 0.5, lwd = 2)
-------------------------------------------------------------------------------------------------------
barplot(VADeaths, beside=TRUE, las=1)
abline(h=0:100, col="white")
barplot(
  VADeaths, beside=TRUE, las=1,
  add=TRUE, col=FALSE
)
-------------------------------------------------------------------------------------------------------
dev.new() pdf xlims<-c(1,24)
ylims<-c(-2,2)

pdf(file='test1march.pdf', width=3.33,height=4)
plot(NULL,NULL,xlim=xlims,ylim=ylims,axes=FALSE, ann=FALSE)     
axis(1, at=c(0,4,8,12,16,20,24),cex.axis=0.7,mgp=c(3, .3, 0))
axis(2, las=1,cex.axis=0.7,at=c(-2,-1,0,1,2), mgp=c(3, .7, 0))
mtext(side = 1, text =expression('Hour'), line = 1,font=15)
mtext(side = 2, text = expression(paste('NEE ', m^-2,s^-1)), line = 1.5,font=15)
abline(0, 2/24)  # should give a diagonal line
box()
dev.off()
-------------------------------------------------------------------------------------------------------
panel.abline(reg = coef, lwd = 2) lwd
-------------------------------------------------------------------------------------------------------
adj.scores ####################
##########  proposal ratings project
##########  17 June 2011
##########  original code by:  jjb with help from es



##########------  functions to be read in and called when desired

##########  applying  this function to a single matrix will give detailed output 
##########  calculating generalizability theory components
##########  not a very robust formulation, but a good place to start
##########  for future, put panel facet on this design

    g.pxr.long = function(x)
     {
      m.raters <<- colMeans(x)
      n.raters <<- length(m.raters)

      m.props <<-  rowMeans(x)
      n.props <<-  length(m.props)

      m.total <<-  mean(x)
      n.total <<-  nrow(x)*ncol(x)

      m.raters.2 <<- m.raters^2
      m.props.2 <<- m.props^2

      sum.m.raters.2 <<- sum(m.raters.2)
      sum.m.props.2  <<- sum(m.props.2)

      ss.props <<- n.raters*(sum.m.props.2) - n.total*(m.total^2)
      ss.raters <<- n.props*(sum.m.raters.2) - n.total*(m.total^2)
      ss.pr  <<-  sum(x^2) - n.raters*(sum.m.props.2) - n.props*(sum.m.raters.2) +  n.total*(m.total^2)

      df.props <- n.props - 1
      df.raters <- n.raters - 1
      df.pr  <-  df.props*df.raters

      ms.props <- ss.props / df.props
      ms.raters <- ss.raters / df.raters
      ms.pr <- ss.pr / df.pr

      var.p <- (ms.props - ms.pr) / n.raters
      var.r <- (ms.raters - ms.pr) / n.props
      var.pr <- ms.pr


      out.1 <- as.data.frame( matrix(c( df.props, df.raters, df.pr, 
                                        ss.props, ss.raters, ss.pr, 
                                        ms.props, ms.raters, ms.pr,  
                                        var.p, var.r, var.pr), ncol = 4))

      out.2 <- as.data.frame(matrix(c("p", "r", "pr" ), ncol = 1))
      g.out.1 <- as.data.frame(cbind(out.2, out.1))
      colnames(g.out.1) <- c("   source", "   df  ", "   ss  ", "   ms  ", "   variance")



     var.abs <- (var.r / n.raters) + (var.pr / n.raters)
     var.rel <- (var.pr / n.raters)
     var.xbar <- (var.p / n.props) + (var.r / n.raters) + (var.pr / (n.raters*n.props) )

     gen.coef <- var.p / (var.p + var.rel)
     dep.coef <- var.p / (var.p + var.abs)

     out.3 <- as.data.frame(matrix(c(var.rel, var.abs, var.xbar, gen.coef, dep.coef), ncol=1))
     out.3 <- round(out.3, digits = 4)
     out.4 <- as.data.frame(matrix(c("relative error variance", "absolute error variance", "xbar error variance", "E(rho^2)", "Phi"), ncol=1))

     g.out.2 <- as.data.frame(cbind(out.4,out.3))
     colnames(g.out.2) <- c("   estimate ", "   value")

    outs <- list(g.out.1, g.out.2)
    names(outs) <- c("generalizability theory: G-study components", "G-study Indices")
    return(outs)

     }

##########-----  calculating confidence intervals using Chebychev, Cramer, and Normal   

##########-----  use this to find alpha for desired k

factor.choose = function(k)

    {
    alpha <- 1 / k^2
    return(alpha)   
    }




conf.intervals = function(dat, alpha)
    {   



    k <- sqrt( 1 / alpha )  # specifying what the k factor is...

    x.bar <- mean(dat)
    x.sd  <- sd(dat)

    n.obs <- length(dat)

    sem <- x.sd / sqrt(n.obs)

    ub.cheb <- x.bar + k*sem
    lb.cheb <- x.bar - k*sem

    ub.crem <- x.bar + (4/9)*k*sem
    lb.crem <- x.bar - (4/9)*k*sem

    ub.norm <- x.bar + qnorm(1-alpha/2)*sem
    lb.norm <- x.bar - qnorm(1-alpha/2)*sem

    out.lb <- matrix(c(lb.cheb,  lb.crem,  lb.norm), ncol=1)
    out.ub <- matrix(c(ub.cheb,  ub.crem, ub.norm), ncol=1)


    dat <- as.data.frame(dat)

    mean.raters <- as.matrix(rowMeans(dat))

    dat$z.values <- matrix((mean.raters - x.bar) / x.sd)

    select.cheb <- dat[ which(abs(dat$z.values) >= k ) , ]

    select.crem <- dat[ which(abs(dat$z.values) >= (4/9)*k ) , ]

    select.norm <- dat[ which(abs(dat$z.values) >=  qnorm(1-alpha/2)) , ]

    count.cheb <- nrow(select.cheb)
    count.crem <- nrow(select.crem)
    count.norm <- nrow(select.norm)

    out.dat <- list()

    out.dat <- list(select.cheb, select.crem, select.norm)
    names(out.dat) <- c("Selected cases: Chebychev", "Selected cases: Cramer's", "Selected cases: Normal")



    out.sum <- matrix(c(x.bar, x.sd, n.obs), ncol=3)
    colnames(out.sum) <- c("mean", "sd", "n")

    out.crit <- matrix(c(alpha, k, (4/9)*k, qnorm(1-alpha/2)) ,ncol=4 )
    colnames(out.crit) <- c("alpha", "k", "(4/9)*k", "z" )

    out.count <- matrix(c(count.cheb, count.crem, count.norm) ,ncol=3 )
    colnames(out.count) <- c("Chebychev", "Cramer" , "Normal")
    rownames(out.count) <- c("count")


    outs <- list(out.sum, out.crit, out.count, out.dat)
    names(outs) <- c("Summary of data", "Critical values", "Count of Selected Cases", "Selected Cases")

    return(outs)




    }


rm(list = ls())


set.seed(271828)

means <- matrix(c( rep(50,19), rep(70,1) ), ncol = 1)      #  matrix of true proposal values
bias.u <- matrix(c(0,2,4), nrow=1)                                  #  unidirectional bias
bias.b <- matrix(c(0,5, -5), nrow=1)                                #  bidirectional bias   


ones.u <- matrix(rep(1,ncol(bias.u)), nrow = 1)                 #  number of raters is the number of columns  (r)
ones.b <- matrix(rep(1,ncol(bias.b)), nrow = 1)
ones.2 <- matrix(rep(1,nrow(means)),  ncol = 1)                 #  number of proposals is the number of rows  (p)

true.ratings <- means%*%ones.u                                  #  gives matrix of true proposal value for each rater (p*r)
uni.bias    <- ones.2%*%bias.u
bid.bias    <- ones.2%*%bias.b                                  #  gives matrix of true rater bias for each proposal  (p*r)


pan.bias.pos <- matrix(20,nrow=nrow(true.ratings), ncol=ncol(true.ratings))  #  gives a matrix of bias for every member in a panel (p*r)



n.val <- nrow(true.ratings)*ncol(true.ratings)

#   true.ratings
#   uni.bias
#   bid.bias
#   pan.bias.pos



library(MASS)



#####
#####  generating replicate data...
#####




n.panels <- 10      #  put in the number of replicate panels that should be produced
reps     <- 2        #  put in the number of times each bias condition should be included in a panel 

t.reps <- list()

n.bias <- list()
u.bias <- list()
b.bias <- list()
pan.bias <- list()

n.bias.out <- list()
u.bias.out <- list()
b.bias.out <- list()
pan.bias.out <- list()


for (i in 1:n.panels)

    {
        {
            for(j in 1:reps) 
                n.bias[[j]] <- true.ratings + matrix(round(rnorm(n.val,4,2), digits=0), nrow = nrow(means)) 
            for(j in 1:reps)    
                u.bias[[j]] <- true.ratings + uni.bias + matrix(round(rnorm(n.val,4,2), digits=0), nrow = nrow(means))
            for(j in 1:reps)
                b.bias[[j]] <- true.ratings + bid.bias + matrix(round(rnorm(n.val,4,2), digits=0), nrow = nrow(means))

        }   

        pan.bias[[i]]  <- true.ratings + pan.bias.pos + matrix(round(rnorm(n.val,4,2), digits=0), nrow = nrow(means))

        n.bias.out[[i]] <- n.bias
        u.bias.out[[i]] <- u.bias
        b.bias.out[[i]] <- b.bias

        t.reps[[i]] <- c(n.bias, u.bias, b.bias, pan.bias[i])

    }

#  t.reps


#  rm(list = ls())



##########-----  this is the standardization formula to be applied to proposal ratings **WITHIN** a panel

adj.scores <- function(x, tot.dat)

    {
    t.sd <- sd(array(tot.dat))
    t.mn <- mean(array(tot.dat))

    ones.t.mn <- diag(1,ncol(x))

    p <- nrow(x)
    r <- ncol(x)

    ones.total <- matrix(1,p,r)

    r.sd <- diag(apply(x,2, sd))
    r.mn <- diag(apply(x,2, mean))


    den.r.sd <- ginv(r.sd)
    b.shift <- x%*%den.r.sd

    a <- t.mn*ones.t.mn - den.r.sd%*%r.mn
    a.shift <- ones.total%*%a


    l.x <- b.shift + a.shift

    return(l.x)
    }



##########-----  applying standardization formula and getting 
##########-----  proposal means for adjusted and unadjusted ratings

adj.rep <- list()
m.adj <- list()
m.reg <- list()

for (i in 1:n.panels)

    {

    panel.data <- array(unlist(t.reps[[i]]))

    adj.rep[[i]] <- lapply(t.reps[[i]], adj.scores, tot.dat = panel.data)

    m.adj[[i]] <- lapply(adj.rep[[i]], rowMeans)
    m.reg[[i]] <- lapply(t.reps[[i]], rowMeans)

    }









##########----- 
##########-----  This function extracts the replicate proposal means for each set of reviews    
##########-----  across panels.  So, if there are 8 sets of reviewers that are simulated 10 times, 
##########-----  this extracts the first set of means across the 10 replications and puts them together,
##########-----  and then extracts the second set of means across replications and puts them together, etc..
##########-----  The result will be 8 matrices made up of 10 columns with rows .
##########-----  



##########-----  first for unadjusted means 





means.reg <- matrix(unlist(m.reg), nrow=nrow(means))
sets <- length(m.reg[[1]])
counter <- n.panels*length(m.reg[[1]])


m.reg.panels.set <- list()

        for (j in 1:sets)

            {
                m.reg.panels.set[[j]] <- means.reg[ , c(seq( j, counter, sets))]

            }






##########-----  now for adjusted means


means.adj <- matrix(unlist(m.adj), nrow=nrow(means))
sets <- length(m.adj[[1]])
counter <- n.panels*length(m.adj[[1]])


m.adj.panels.set <- list()

        for (j in 1:sets)

            {
                m.adj.panels.set[[j]] <- means.adj[ , c(seq( j, counter, sets))]

            }    



##########   calculating msd as bias^2 and error^2




msd.calc <- function(x)
        {

            true.means  <- means
            calc.means  <- as.matrix(rowMeans(x))


            t.means.mat <- matrix(rep(true.means, n.panels), ncol=ncol(x))
            c.means.mat <- matrix(rep(calc.means, n.panels), ncol=ncol(x))

            msd <- matrix( rowSums( (x - t.means.mat )^2) / ncol(c.means.mat) )
            bias.2 <- (calc.means - true.means)^2
            e.var <-  matrix( rowSums( (x - c.means.mat )^2) / ncol(c.means.mat ) )

            msd <- matrix(c(msd, bias.2, e.var), ncol = 3)
            colnames(msd) <- c("msd", "bias^2", "e.var")

            return(msd)

        }


##########  checking work...

#       msd.calc <- bias.2 + e.var
#       all.equal(msd, msd.calc)


##########-----  applying function to each set across panels        

msd.reg.panels <- lapply(m.reg.panels.set, msd.calc)        

msd.adj.panels <- lapply(m.adj.panels.set, msd.calc)

msd.reg.panels
msd.adj.panels        

##########  for the unadjusted scores, the msd is very large (as is expected)
##########  for the adjusted scores, the msd is in line with the other panels






##########-----  trying to evaluate impact of adjusting scores on proposal awards



reg.panel.1 <- matrix(unlist(m.reg[[1]]), nrow=nrow(means))
adj.panel.1 <- matrix(unlist(m.adj[[1]]), nrow=nrow(means))


reg <- matrix(array(reg.panel.1), ncol=1)
adj <- matrix(array(adj.panel.1), ncol=1)

panels.1 <- cbind(reg,adj)

colnames(panels.1) <- c("unadjusted", "adjusted")

cor(panels.1, method="spearman")

plot(panels.1)
########   identify(panels.1)


plot(panels.1, xlim = c(25,95), ylim = c(25,95) )
abline(0,1, col="red")


##########  the adjustment greatly reduces variances of ratings 
##########  compare the projection of the panel means onto the respective margins



##########-----  examining the selection of the top 10% of the proposals


pro.names <- matrix(seq(1,nrow(reg),1))

df.reg <- as.data.frame(cbind(pro.names, reg))
colnames(df.reg) <- c("pro", "rating")
df.reg$q.pro <- ecdf(df.reg$rating)(df.reg$rating) 


df.adj <- as.data.frame(cbind(pro.names, adj))
colnames(df.adj) <- c("pro", "rating")
df.adj$q.pro <- ecdf(df.adj$rating)(df.adj$rating)


awards.reg <- df.reg[ which(df.reg$q.pro >= .90) , ]
awards.adj <- df.adj[ which(df.adj$q.pro >= .90) , ]


awards.reg[order(-awards.reg$q.pro) , ]
awards.adj[order(-awards.adj$q.pro) , ]


awards.reg[order(-awards.reg$pro) , ]
awards.adj[order(-awards.adj$pro) , ]


#####  using unadjusted scores, the top 10% of proposals come mostly from one (biased) panel, and the rest are made up of the 
#####  highest scoring proposal (from the biased rater) from the remaining panels.

#####  using the adjusted scores, the top 10% of proposals are made up of the highest scoring proposal (the biased rater) from the 
#####  several panels, and a few proposals from other panels.  Doesn't seem to be a systematic explanation as to why...




#########-----  treating rating data in an ANOVA model


ratings <- do.call("rbind", t.reps[[1]] )
panels <- factor(gl(7,20))



fit <- manova(ratings ~ panels)
summary(fit, test="Wilks")




adj.ratings <- do.call("rbind", adj.rep[[1]] )
adj.fit <- manova(adj.ratings ~ panels)
summary(adj.fit, test="Wilks")


##########-----  thinking... extra ideas for later

##########-----  calculating Mahalanobis distance to identify biased panels

mah.dist = function(dat)
        {md.dat <- as.matrix(mahalanobis(dat, center = colMeans(dat) , cov = cov(dat) ))
         md.pv <- as.matrix(pchisq(md.dat, df = ncol(dat), lower.tail = FALSE))

        out <- cbind(md.dat, md.pv)

        out.2 <- as.data.frame(out)
        colnames(out.2) <- c("MD", "pMD")


        return(out.2)
        }



mah.dist(ratings)

mah.dist(adj.ratings)
-------------------------------------------------------------------------------------------------------
# put x and y in a data frame
dat<-data.frame(x=x,y=y)
attach(dat)
plot(x,y) 
abline(lm(y ~ x))
-------------------------------------------------------------------------------------------------------
abline(0, 0, lty=2)
-------------------------------------------------------------------------------------------------------
sexi <- as.numeric(data.frame$sex)-1      #recode a factor as 0/1 numeric

beta <- numeric(60)              #Set up vector to Store the betas
deviance <- numeric(60)          #Set up vector to Store the deviances

for (i in 1:60){

  beta[i] <- 0.5 - (0.01*i)  
  #A vector of values either side of the fitted MLE (in this case -0.22)

  mod <- update(model,
                   .~. - sex             #Get rid of the fitted variable
                   + offset(   I(sexi*beta[i])   )   #Replace with offset term.
                )
  deviance[i] <- mod$deviance                        #Store i'th deviance
}

best <- which.min(deviance)                   
#Find the index of best deviance. Should be the fitted value from the model

deviance0 <- deviance - deviance[best]         
#Scale deviance to zero by subtracting best deviance

betahat <- beta[best]    #Store best beta. Should be the fitted value.
stderror <- 0.12187      #Store the std error of sex, found in summary(model)

quadratic <- ((beta-betahat)^2)*(1/(stderror^2))  
#Quadratic reference function to check quadratic assumption against

x11()                                    
plot(beta,deviance0,type="l",xlab="Beta(sex)",ylim=c(0,4))    
lines(beta,quadratic,lty=2,col=3)           #Add quadratic reference line
abline(3.84,0,lty=3)                #Add line at Deviance = 3.84
-------------------------------------------------------------------------------------------------------
abline() predict.lm() lines() f <- lm(y~x)
X <- c(1, 10)
Y <- predict(f, newdata=data.frame(x=X))

plot(x,y)
lines(x=X, y=Y)
-------------------------------------------------------------------------------------------------------
predict lines segments clip abline x <- 1:10
y <- 1:10
plot(x,y)
clip(1,10, -100, 100)
abline(lm(y~x))
-------------------------------------------------------------------------------------------------------
?barplot abline(x,y) require(grDevices) # for colours
tN <- table(Ni <- stats::rpois(100, lambda=5))

barplot(tN, space = 1.5, axisnames=FALSE)
abline(5,0) ?barplot
-------------------------------------------------------------------------------------------------------
set.seed(231)
 tN <- table(Ni <- stats::rpois(100, lambda=5))
 tNshift <- tN-5
 barplot(tNshift, space = 1.5, yaxt="n", xaxt="n", ylim=range(tNshift))
 abline(0,0)
 axis(2, at= c(-5, pretty(tNshift)), labels=c(0, pretty(tNshift)+5), xpd=TRUE)
-------------------------------------------------------------------------------------------------------
?legend plot(1:10,type = "n")
abline(v=seq(1,10,1), col='grey', lty='dotted')
legend(1, 5, "This legend text should not be disturbed by the dotted grey lines,\nbut the plotted dots should still be visible",box.lwd = 0,box.col = "white",bg = "white")
points(1:10,1:10) \n
-------------------------------------------------------------------------------------------------------
i "i" for (i in c("JUL","AUG","SEPT","OCT","NOV","DEC")){
  plot(Thorny.Lmm[["r",i]], Thorny.Lmm[["Lmm",i]], type="l")
  abline(h=0, lty=2) 
  title(main=paste("Thorny skate in", i))
}
dev.off()
-------------------------------------------------------------------------------------------------------
for (i in c("JUL","AUG","SEPT","OCT","NOV","DEC")){
  plot(Thorny.Lmm[["r",i]], Thorny.Lmm[["Lmm", i]], type="l")
  abline(h=0, lty=2) 
  title(main=paste("Thorny skate in", i))
}
dev.off() plotter <- function(month){
    plot(Thorny.Lmm[["r",month]], Thorny.Lmm[["Lmm",month]], type="l")
    abline(h=0, lty=2)
    title(main=paste("Thorny" month))
}

lapply(colnames(Thorny.Lmm), plotter)
-------------------------------------------------------------------------------------------------------
value<-rnorm(100,1000,200) ##create list of numbers, "scan()" may be used for real observations
nmbrs<-length(value) ## determine the length of vector
obrv<-1:length(value) ## create list of observations
par(xpd=FALSE)
sd1<-sd(value[1:20])*1 ## 1 standart deviation
sd2<-sd(value[1:20])*2 ## 2 standart deviations
sd3<-sd(value[1:20])*3 ## 3 standart deviations
usd1<-mean(value)+sd1 ## upper limit
lsd1<-mean(value)-sd1 ## lower limit
lsd2<-mean(value)-sd2 ## lower limit
usd2<-mean(value)+sd2 ## upper limit
usd3<-mean(value)+sd3 ## upper limit
lsd3<-mean(value)-sd3 ## lower limit

## ploting the grid
plot(obrv,value,type="n",xlab="Observations",ylab="Value",ylim=c(lsd3-sd1,usd3+sd1))
abline(h=mean(value),col=2,lty=1)
abline(h=usd1,col=3,lty=3)
abline(h=lsd1,col=3,lty=3)
abline(h=usd2,col=4,lty=2)
abline(h=lsd2,col=4,lty=2)
abline(h=usd3,col=6,lty=1)
abline(h=lsd3,col=6,lty=1)


## 20 first values for L-G chart for QC limits
for (i in 1:20) 
{
points(obrv[i],value[i],col="black")
}
lines(obrv[1:20],value[1:20],col="red")


## if over mean - "red", under mean - "blue"
for (i in 21:nmbrs) 
{
points(obrv[i],value[i],col="blue")
segments(obrv[i-1],value[i-1],obrv[i],value[i],col="blue")
}

# 1s points - blue; 2s points - red
#if (value[i]<usd1 || value[i]>lsd1) points(obrv[i],value[i],col="blue")
#if (value[i]>usd1 || value[i]<lsd1) points(obrv[i],value[i],col="red")

#12s violation rule
#if (value[i]>usd1 || value[i]<usd1) text(30, usd3, "12s violation")
#if (value[i]>usd1 || value[i]<usd1) text(30, usd3, "12s violation")
#segments(obrv[i-1],value[i-1],obrv[i],value[i],col="blue")
#if (value[i]>usd1) break
#}


#legend placement - might be omited
#legend(1,min(value)-sd1*0.2,bg=8,c("mean","sd1","sd2","sd3"),lty=c(1,3,2,1),lwd=c(2.5,2.5,2.5,2.5),col=c(2,3,4,6),cex=0.8)
-------------------------------------------------------------------------------------------------------
x.lm<-lm(x$Vol ~ x$Date) x.lm<-lm(x$vol ~ x$Date) predict() abline abline(x.lm, col="red") predict y <- x$vol
x <- x$Date
x.lm <- lm(y~x)
predict(x.lm, data.frame(x=1997:2000)) data.frame(x=1997:2000) lm() lm()
-------------------------------------------------------------------------------------------------------
x$Date = as.Date(x$Date,format="%m/%d/%Y")
x = xts(x=x$Used, order.by=x$Date)
# To get the start date (305)
#     > as.POSIXlt(x = "2011-11-01", origin="2011-11-01")$yday
##    [1] 304
# Add one since that starts at "0"
x.ts = ts(x, freq=365, start=c(2011, 305))
plot(forecast(ets(x.ts), 10)) 2011.85 365*.85 as.POSIXlt(x = "2011-11-01", origin="2011-11-01")$yday as.Date(310, origin="2011-01-01") x = ts(x$Used, start=c(2011, as.POSIXlt("2011-11-01")$yday+1), frequency=365)
# NOTE: We have only selected the "Used" variable 
# since ts will take care of dates
plot(forecast(ets(x), 10)) # 'start' calculation = `as.Date("2011-11-01")-as.Date("2011-01-01")+1`
# No need to convert anything to dates at this point using xts
x = ts(x$Used, start=c(2011, 305), frequency=365)
# Directly plot your forecast without your axes
plot(forecast(ets(x), 10), axes = FALSE)
# Generate labels for your x-axis
a = seq(as.Date("2011-11-01"), by="weeks", length=11)
# Plot your axes.
# `at` is an approximation--there's probably a better way to do this, 
# but the logic is approximately 365.25 days in a year, and an origin
# date in R of `January 1, 1970`
axis(1, at = as.numeric(a)/365.25+1970, labels = a, cex.axis=0.6)
axis(2, cex.axis=0.6) xts ts forecast Point x.fore > forecast(ets(x), 10)
         Point Forecast    Lo 80    Hi 80    Lo 95    Hi 95
2012.000       741.6437 681.7991 801.4884 650.1192 833.1682
2012.003       741.6437 676.1250 807.1624 641.4415 841.8459
2012.005       741.6437 670.9047 812.3828 633.4577 849.8298
2012.008       741.6437 666.0439 817.2435 626.0238 857.2637
2012.011       741.6437 661.4774 821.8101 619.0398 864.2476
2012.014       741.6437 657.1573 826.1302 612.4328 870.8547
2012.016       741.6437 653.0476 830.2399 606.1476 877.1399
2012.019       741.6437 649.1202 834.1672 600.1413 883.1462
2012.022       741.6437 645.3530 837.9345 594.3797 888.9078
2012.025       741.6437 641.7276 841.5599 588.8352 894.4523 lubridate require(lubridate)
y = ts(x$Used, start=c(2011, yday("2011-11-01")), frequency=365)
plot(forecast(ets(y), 10), xaxt="n")
a = seq(as.Date("2011-11-01"), by="weeks", length=11)
axis(1, at = decimal_date(a), labels = format(a, "%Y %b %d"), cex.axis=0.6)
abline(v = decimal_date(a), col='grey', lwd=0.5) ts
-------------------------------------------------------------------------------------------------------
prepanel=function(y, stderr, subscripts=subscripts, ...){
  uy <- as.numeric(y+stderr[subscripts])
  ly <- as.numeric(y-stderr[subscripts])
  list(ylim=range(y,uy,ly, finite=TRUE))
}
panel.err=function(x, y, subscripts, groups, stderr, box.ratio, ...){
  d <- 1/(nlevels(groups)+nlevels(groups)/box.ratio)
  g <- (as.numeric(groups[subscripts])-1); g <- (g-median(g))*d
  panel.arrows(as.numeric(x)+g,y-stderr[subscripts], as.numeric(x)+g, y+stderr[subscripts],
               code=3,angle=90, length=0.025)
}
barchart(Change~fTreat,groups=Process,change,
         stderr=change$stderr,
         ylab="Pocertage change",
         xlab="Treatment",
         ylim=-115:50,
         auto.key=list(points=FALSE,rectangles=TRUE,columns=2),
         scales=list(alternating=FALSE,
                     tick.number=7,
                     tck=c(-1,0)),
         prepanel=prepanel,
         panel=function(x, y, subscripts, groups, stderr, box.ratio, ...){
             panel.barchart(x, y, subscripts=subscripts,
                            groups=groups, box.ratio=box.ratio,origin=0, ...)
             panel.abline(h=0,col="black",...)
             panel.err(x, y, subscripts=subscripts,
                       groups=groups, box.ratio=box.ratio,stderr=change$stderr)
           }
         ) structure(list(Treat = structure(c(3L, 4L, 1L, 2L, 3L, 4L, 1L, 
2L), .Label = c("12-380", "12-750", "8-380", "8-750"), class = "factor"), 
    Process = structure(c(1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L), .Label = c("Respiration", 
    "Calcification"), class = c("ordered", "factor")), Change = c(-33L, 
    -35L, 21L, 18L, 7L, -29L, -8L, -79L), stderr = c(20L, 6L, 
    10L, 9L, 33L, 38L, 21L, 32L), fTreat = structure(c(1L, 2L, 
    3L, 4L, 1L, 2L, 3L, 4L), .Label = c("8-380", "8-750", "12-380", 
    "12-750"), class = c("ordered", "factor"))), .Names = c("Treat", 
"Process", "Change", "stderr", "fTreat"), row.names = c(NA, -8L
), class = "data.frame")
-------------------------------------------------------------------------------------------------------
read.csv read.table quartz=(title...) quartz(title=...) plot() attach lines curve abline glm lm() family=binomial family=gaussian dat <- read.csv("/Path/PopulationGrowth.csv")
with(dat,plot(Year,CentralOakland,xlab="Year",ylab="Population",
  main="Central Oakland Population vs. Year"))
g <- lm(CentralOakland~Year,data=dat)
abline(g)
## OR
yearvec <- seq(min(Year),max(Year),length=51)
lines(yearvec,predict(g,newdata=data.frame(Year=yearvec),type="response")) ## from http://en.wikipedia.org/wiki/Oakland,_California
dat <- structure(list(year = c(1860L, 1870L, 1880L, 1890L, 1900L, 1910L, 
1920L, 1930L, 1940L, 1950L, 1960L, 1970L, 1980L, 1990L, 2000L, 
2010L), pop = c(1543L, 10500L, 34555L, 48682L, 66960L, 150174L, 
216261L, 284063L, 302163L, 384575L, 367548L, 361561L, 339337L, 
372242L, 399484L, 390724L)), .Names = c("year", "pop"), 
  class = "data.frame", row.names = c(NA,-16L)) ## SSlogis() is a "self-starting" logistic
m1 <- nls(pop~SSlogis(year,asym,xmid,scal),
          data=dat) par(las=1,bty="l",mar=c(5,6,2,2)+0.1)  ## graphics tweaks
with(dat,plot(pop~year,ylab=""))
## add y-label separately 
mtext("population",side=2,las=0,line=4)
yearvec <- 1860:2010
lines(yearvec,predict(m1,newdata=data.frame(year=yearvec)))
-------------------------------------------------------------------------------------------------------
setHeader(header='Content-Disposition', 'attachment; filename=rpdf.pdf')
setContentType("application/pdf")
t <- tempfile()
pdf(t)
attach(mtcars)
plot(wt, mpg)
abline(lm(mpg~wt))
title("PDF Report")
dev.off()
setHeader('Content-Length',file.info(t)$size)
sendBin(readBin(t,'raw',n=file.info(t)$size))
-------------------------------------------------------------------------------------------------------
plot(dt[,3], pch="•", ylim=c(-20, 50), axes=F, ann=F, cex=1.5, bty = 'o')
abline(h=0, col=1, lty=2)
arrows(1:3, dt[,3], 1:3, dt[,4], angle = 90, length = 0.08) segments(1:3, dt[,3], 1:3, dt[,5])
segments(1:3, dt[,3], 1:3, dt[,4])
-------------------------------------------------------------------------------------------------------
x<-rnorm(100000,mean=10, sd=2)
hist(x,breaks=150,xlim=c(0,20),freq=FALSE)
abline(v=10, lwd=5)
abline(v=c(4,6,8,12,14,16), lwd=3,lty=3)
-------------------------------------------------------------------------------------------------------
x<-1:10
y<-1:10
plot(x,y)
abline(a=1,b=0,v=1)

changed to:

x<-1:10
y<-1:10
plot(x,y,xlim=c(-30,30))
abline(a=1,b=0,v=1) text text((0), min(y), "number", pos=2) abline(a=1,b=0,v=1)
axis(1, at=1,labels=1) plot(x,y,xlim=c(-30,30),yaxt="n")
axis(2, at=c(1.77,5,10,15,20,25)) par(mar = c(6.5, 6.5, 6.5, 6.5))
plot(x,y,xlim=c(-30,30))
abline(a=1,b=0,v=1)
axis(2, at=1.77,labels=1.77,mgp = c(10, 2, 0))
-------------------------------------------------------------------------------------------------------
# generate some fake points
x <- rnorm(100)
y <- rnorm(100)

# positions of the lines
vert = 0.5
horiz = 1.3 # compute the limits, in order for the lines to be centered
# REM we add a small fraction (here 10%) to leave some empty space, 
# available to plot the values inside the frame (useful for one the solutions, see below)
xlim = vert + c(-1.1, 1.1) * max(abs(x-vert))
ylim = horiz + c(-1.1, 1.1) * max(abs(y-horiz))

# do the main plotting
plot(x, y, xlim=xlim, ylim=ylim)
abline(h=horiz, v=vert) line mtext(c(vert, horiz), side=c(1,2)) text(x=vert, y=ylim[1], labels=vert, adj=c(1.1,1), col='blue')
text(x=xlim[1], y=horiz, labels=horiz, adj=c(0.9,-0.1), col='blue')
-------------------------------------------------------------------------------------------------------
x <- seq(-5,5)
y <- 3*x+rnorm(length(x))
fit.int <- lm(y~x)
fit <- lm(y~x-1)
summary(fit)

plot(y~x,xlim=c(-.1,.1),ylim=c(-.1,.1))
abline(fit,col="red")
abline(fit.int,col="blue")
abline(h=0)
abline(v=0)
-------------------------------------------------------------------------------------------------------
par("mar")
par(mar = c(par("mar")[1:3], 5.1))

plot(x,y, type="n", lwd=4, ylab="", xlab="threshold", xaxt="n",yaxt="n")

axis(1,lwd=4)
axis(2,lwd=4)

points(x, y, col="red", cex=2, pch=19)
abline(h=w, col="red", lwd=4)

par("usr")
par(usr = c(par("usr")[1:2], 80,90))

axis(4, lwd=4)
points(x, z, col="blue", cex=2, pch=19)
points(x, z, type="l", lwd=4)
abline(h=v, col="blue", lwd=4)

mtext("Your text", side = 4, col = "blue",line=3)
mtext("seconds", side = 2, col = "red",line=3)
-------------------------------------------------------------------------------------------------------
x   <- seq(0,20,length=1000)
y   <- dnorm(x,mean=10, sd=3)
plot(x,y, type="l", lwd=2)
abline(a=1,b=1,v=1,lty=3) abline
-------------------------------------------------------------------------------------------------------
print() capture.output() plot(rnorm(99))

capture.output({
    lapply(1:4, function(X) abline(v=20*X))
}, file = tempfile())

## Here's the output that was sunk by `capture.output()`
## (wrapping the call in `suppressMessages()` won't get rid of those "NULL"s)
lapply(1:4, function(X) abline(v=20*x))
[[1]]
NULL

[[2]]
NULL

[[3]]
NULL

[[4]]
NULL
-------------------------------------------------------------------------------------------------------
abline abline(v=c(39448, 39814), col="grey40")
abline(h=c(-0.6, -0.4, -0.2, 0.2,0.4,0.6), col="grey10", lty="dotted") v h lty color
-------------------------------------------------------------------------------------------------------
x <- rnorm(100)
hist(x,col="gray")
abline(h=seq(5,40,5),col="white")
-------------------------------------------------------------------------------------------------------
set.seed(42)
dat <- data.frame(x = runif(20, min = 0, max = 20),
                  y = runif(20, min = 0, max = 20))

p <- ggplot(dat, aes(x = x, y = y)) 
p + geom_point() + 
    geom_line(data = data.frame(x = c(0,15), y = c(0,15)),
              aes = aes(x = x, y = y), colour = "red") data ggplot() geom_line() aes() geom_line() aes() geom_abline() geom_segment() geom_line()
-------------------------------------------------------------------------------------------------------
plot.mcmc my.plot.mcmc <- function (x, trace = TRUE, density = TRUE, smooth = FALSE, bwf, 
    auto.layout = TRUE, ask = FALSE, parameters, ...) 
{
    oldpar <- NULL
    on.exit(par(oldpar))
    if (auto.layout) {
        mfrow <- coda:::set.mfrow(Nchains = nchain(x), Nparms = nvar(x), 
            nplots = trace + density)
        oldpar <- par(mfrow = mfrow)
    }
    for (i in 1:nvar(x)) {
        y <- mcmc(as.matrix(x)[, i, drop = FALSE], start(x), 
            end(x), thin(x))
        if (trace) 
            traceplot(y, smooth = smooth, ...)
        if (density) {
            if (missing(bwf)) {
                densplot(y, ...); abline(v=parameters[i])
            } else densplot(y, bwf = bwf, ...)
        }
        if (i == 1) 
            oldpar <- c(oldpar, par(ask = ask))
    }
} my.plot.mcmc(mod1.samples, parameters=c(Mu, Sigma)) parameters plot.mcmc set.mfrow coda:::set.mfrow ask=FALSE
-------------------------------------------------------------------------------------------------------
fun <- function(x, y) {
  plot(x, y)
  abline(lm(x~y))
}

fun(1:10, 10:1) ggplot fun <- function(df) {
  ggplot(df, aes(X, y)) + geom_point()
}

df <- data.frame(x=1:10, y=10:1)
p <- fun(df)

# examine p
str(p)

# plot p
p
-------------------------------------------------------------------------------------------------------
bwplot( mpg ~ as.factor(cyl), data=mtcars, 
  panel = function(x, y, ..., box.ratio ) {
    panel.abline(v = x, col = "gray")
    panel.violin(x, y, ..., box.ratio ) 
  } )
-------------------------------------------------------------------------------------------------------
plot(NULL, ylim=c(0,4), xlim=range(mydf$pos))
 abline(h=1:4 ,col=1:2 )
 with(mydf, segments(x0=pos, y0=as.numeric(interaction(mydf$grp, mydf$sgrp))-.2, 
                     y1=as.numeric(interaction(mydf$grp, mydf$sgrp))+.2,
                     col= mydf$grp, lty=as.numeric(mydf$sgrp)) ) ylim ylab yaxt="n" axis() plot(NULL, ylim=c(0.5,4.5), xlim=range(mydf$pos))
 with(mydf, segments(x0=pos, 
             y0=c(1.3,1.7,3.3,3.7)[as.numeric(interaction(mydf$grp, mydf$sgrp))]-.1, 
             y1=c(1.3,1.7,3.3,3.7)[as.numeric(interaction(mydf$grp, mydf$sgrp))]+.1, 
             col= mydf$sgrp, lty=as.numeric(mydf$grp)) )
abline(h=c(1.3,1.7,3.3,3.7) ,col= rep(1:2, each=2), lty=1:2,lwd=3)
-------------------------------------------------------------------------------------------------------
abline abline(-1.331, 2.522)
-------------------------------------------------------------------------------------------------------
abline abline(a=-1.331, b=2.522) a b ?abline
-------------------------------------------------------------------------------------------------------
options()$scipen options(scipen=10)
plot(INHABT, OSSADP, xlab="Inhabitants", ylab="Adoption of OSS") plot abline plot(INHABT/1000, OSSADP, xlab="Inhabitants", ylab="Adoption of OSS")
abline(lm(OSSADP~I(INHABT/1000))) # Fixed regression line. I / formula las
-------------------------------------------------------------------------------------------------------
asp asp asp <- 2

plot(1:10,1:10, asp=asp) 
abline(a=8, b=-1)
text(x=4, y=5, "reference line label", srt=180/pi*atan(-1*asp))

abline(a=4, b=-2)
text(x=1, y=3, "reference line label", srt=180/pi*atan(-2*asp)) asp asp <- 0.8

plot(1:10,1:10, asp=asp) 
abline(a=8, b=-1)
text(x=4, y=5, "reference line label", srt=180/pi*atan(-1*asp))

abline(a=4, b=-2)
text(x=1, y=3, "reference line label", srt=180/pi*atan(-2*asp))
-------------------------------------------------------------------------------------------------------
ggplot2 data <- data.frame(x = 1:10, y = 1:10)
intercept <- 10
slope <- -1
ggplot(data, aes(x,y)) + geom_point(shape=1) +  
  geom_abline(intercept = intercept, slope = slope) + 
  geom_text(x=4, y=5, label="my label", angle=atan(slope)*180/pi) intercept <- 10
slope <- -2
ggplot(data, aes(x,y)) + geom_point(shape=1) +  
  geom_abline(intercept = intercept, slope = slope) + 
  geom_text(x=4, y=5, label="my label", angle=atan(slope)*180/pi)
-------------------------------------------------------------------------------------------------------
par(mfrow=c(2,2))    
    plot_QQ=function(x) {for(i in 2:x){
    plot(data_raw[,Group1[i]],data_raw[,Group1[1]], xlab=paste("replicate",i), ylab="replicate 1")
    abline(lm(data_raw[,Group1[i]]~data_raw[,Group1[1]])}}
-------------------------------------------------------------------------------------------------------
horiz.hist <- function(Data, breaks="Sturges", col="transparent", las=1, 
ylim=range(HBreaks), labelat=pretty(ylim), labels=labelat, border=par("fg"), ... )
  {a <- hist(Data, plot=FALSE, breaks=breaks)
  HBreaks <- a$breaks
  HBreak1 <- a$breaks[1]
  hpos <<- function(Pos) (Pos-HBreak1)*(length(HBreaks)-1)/ diff(range(HBreaks))
  barplot(a$counts, space=0, horiz=T, ylim=hpos(ylim), col=col, border=border,...)      
  axis(2, at=hpos(labelat), labels=labels, las=las, ...) 
  print("use hpos() to address y-coordinates") } # Data and basic concept
set.seed(8); ExampleData <- rnorm(50,8,5)+5
hist(ExampleData)
horiz.hist(ExampleData, xlab="absolute frequency") 
# Caution: the labels at the y-axis are not the real coordinates!
# abline(h=2) will draw above the second bar, not at the label value 2. Use hpos:
abline(h=hpos(11), col=2)

# Further arguments
horiz.hist(ExampleData, xlim=c(-8,20)) 
horiz.hist(ExampleData, main="the ... argument worked!", col.axis=3) 
hist(ExampleData, xlim=c(-10,40)) # with xlim
horiz.hist(ExampleData, ylim=c(-10,40), border="red") # with ylim
horiz.hist(ExampleData, breaks=20, col="orange")
axis(2, hpos(0:10), labels=F, col=2) # another use of hpos()
-------------------------------------------------------------------------------------------------------
palvec <-  c(ATblue=ATblue, ATyellow=ATyellow, ATorange=ATorange) plot(1,1) # to set up plot window
abline(h=c(0.8,1,1.2), col= palvec[ c( 'ATblue', 'ATyellow', 'ATorange' ) ] , lwd=40) grep("lavender", colors(), ignore.case=TRUE, value=TRUE)
#[1] "lavender"       "lavenderblush"  "lavenderblush1" "lavenderblush2" 
#     "lavenderblush3" "lavenderblush4" ccodes <- as.hexmode( c(256^(2:0) %*% col2rgb("lavenderblush")) )
 ccodes
 #[1] "fff0f5" > ccodes <- as.hexmode( c(256^(2:0) %*% col2rgb("seagreen")) )
> ccodes
[1] "2e8b57 paste0 paste0("#", ccodes)
#[1] "#2e8b57"
 plot(1,1, col=paste0("#", ccodes) ) paste0 ccodes <- as.hexmode( c(256^(2:0) %*% col2rgb(colors()[20:25])) )
 paste0("#", ccodes)
#[1] "#ffe4c4" "#eed5b7" "#cdb79e" "#8b7d6b" "#000000" "#ffebcd"
-------------------------------------------------------------------------------------------------------
draw.ellipse plotrix RSiteSearch("ellipse", restrict="functions") ellipse <- function(xf1, yf1, xf2, yf2, k, new=TRUE,...){
    # xf1 and yf1 are the coordinates of your focus F1
    # xf2 and yf2 are the coordinates of your focus F2
    # k is your constant (sum of distances to F1 and F2 of any points on the ellipse)
    # new is a logical saying if the function needs to create a new plot or add an ellipse to an existing plot.
    # ... is any arguments you can pass to functions plot or lines (col, lwd, lty, etc.)
    t <- seq(0, 2*pi, by=pi/100)  # Change the by parameters to change resolution
    k/2 -> a  # Major axis
    xc <- (xf1+xf2)/2
    yc <- (yf1+yf2)/2  # Coordinates of the center
    dc <- sqrt((xf1-xf2)^2 + (yf1-yf2)^2)/2  # Distance of the foci to the center
    b <- sqrt(a^2 - dc^2)  # Minor axis
    phi <- atan(abs(yf1-yf2)/abs(xf1-xf2))  # Angle between the major axis and the x-axis
    xt <- xc + a*cos(t)*cos(phi) - b*sin(t)*sin(phi)
    yt <- yc + a*cos(t)*sin(phi) + b*sin(t)*cos(phi)
    if(new){ plot(xt,yt,type="l",...) }
    if(!new){ lines(xt,yt,...) }
    } F1 <- c(2,3)
F2 <- c(1,2)
plot(rbind(F1, F2), xlim=c(-1,5), ylim=c(-1, 5), pch=19)
abline(h=0, v=0, col="grey90")
ellipse(F1[1], F1[2], F2[1], F2[2], k=2, new=FALSE, col="red", lwd=2)
points((F1[1]+F2[1])/2, (F1[2]+F2[2])/2, pch=3)
-------------------------------------------------------------------------------------------------------
lattice panel.abline xyplot(Neff ~ Eeff, data = phuong,
       panel = function(x, y) {
         panel.xyplot(x, y)
         panel.abline(lm(y ~ x))
       }
       xlab = "Energy efficiency (%)", 
       ylab = "Nitrogen efficiency (%)")
-------------------------------------------------------------------------------------------------------
txta txtb text set.seed(1)
tmp <- matrix(replicate(4, rnorm(50)), ncol=4)
panel.cor <- function(x, y, digits=2, prefix="", cex.cor, ...)
{
  usr <- par("usr"); on.exit(par(usr))
  par(usr = c(0, 1, 0, 1))
  rp <- cor(x, y, method="pearson", use="pairwise.complete.obs")
  rs <- cor(x, y, method="spearman", use="pairwise.complete.obs")
  rp <- format(rp, digits=digits)
  rs <- format(rs, digits=digits)
  txt <- substitute(list(R[p] == rp, R[s] == rs), list(rp=rp, rs=rs))
  txta <- substitute(R[p] == rp, list(rp=rp))
  txtb <- substitute(R[s] == rs, list(rs=rs))
  if(missing(cex.cor)) cex.cor <- 0.8/strwidth(txt)
  text(0.5, 0.6, txta, cex = 1.5)
  text(0.5, 0.4, txtb, cex = 1.5)
}
panel.my.points <- function(x, y) {
  points(x, y)
  abline(0, 1)
}
pairs(tmp, 
      lower.panel=panel.cor, 
      upper.panel=panel.my.points, 
      labels=c("model 1\nD1", "model 2\nD1", "model 1\nD2", "model 2\nD2"))
-------------------------------------------------------------------------------------------------------
set.seed(1410)
df<-data.frame(
  "site.x"=c(rep("a",4),rep("b",4),rep("c",4),rep("d",4)),
  "site.y"=c(rep(c("e","f","g","h"),4)),
  "bond.strength"=sample(1:100,16, replace=TRUE), stringsAsFactors=FALSE)


Placement <- data.frame(site=c(unique(df$site.x),unique(df$site.y)), x = NA, y = NA, stringsAsFactors=FALSE)

Placement$x <- ifelse(Placement$site %in% unique(df$site.x), 0, 1)

Placement$y[Placement$x==0] <- seq(1,0,length=sum(Placement$x==0))
Placement$y[Placement$x==1] <- seq(1,0,length=sum(Placement$x==1))

cols <- rep("red",nrow(df))
cols[df$bond.strength < 33] <- "green"
cols[df$bond.strength >= 33 & df$bond.strength < 66] <- "yellow"

# Empty plot:
par(mar=c(0,0,0,0))
plot(1,type="n",xlim=c(-0.2,1.6),ylim=c(0,1),bty="n",axes=FALSE,xlab="",ylab="")
abline(v=c(0,1))
text(Placement$x + ifelse(Placement$x==0,-0.1,0.1),Placement$y,Placement$site)

for (i in 1:nrow(df))
{
  lines(c(0,1),Placement$y[c(match(df$site.x[i],Placement$site),match(df$site.y[i],Placement$site))],col=cols[i],lwd=2)
}

legend("right",col=c("green","yellow","red"),lty=1,lwd=2,legend=c("0-33","33-66","66-100"),title="bondstrength",cex=1.5,bty="n")
-------------------------------------------------------------------------------------------------------
y=a+b*x x=(y-a)/b cc <- coef(model)
(xnew <- (ynew-cc[1])/cc[2])
# [1]  31.43007 104.76689 178.10372

plot(x,y
abline(model)
points(xnew,ynew,col=2)
-------------------------------------------------------------------------------------------------------
chemCal inverse.predict x <- c(0, 40, 80, 120, 160, 200)
y <- c(6.52, 5.10, 4.43, 3.99, 3.75, 3.60)
plot(x,y)
model <- lm(y ~ x)
abline(model)
require(chemCal)
ynew <- c(5.5, 4.5, 3.5)
xpred<-t(sapply(ynew,function(y) inverse.predict(model,y)[1:2]))
#  Prediction Standard Error
#[1,] 31.43007   -38.97289     
#[2,] 104.7669   -36.45131     
#[3,] 178.1037   -39.69539
points(xpred[,1],ynew,col="red")
-------------------------------------------------------------------------------------------------------
ROC ROC ROC ROC2 if (any(!is.na(match("ROC", toupper(plot))))) {
        plot(1 - res[, 2], res[, 1], xlim = 0:1, xlab = "1-Specificity", 
            ylim = 0:1, ylab = "Sensitivity", type = "n", ...)
        if (is.numeric(grid)) 
            abline(h = grid/100, v = grid/100, col = gray(0.9))
        abline(0, 1, col = gray(0.4))
        box()
        lines(1 - res[, 2], res[, 1], lwd = lwd) col = "red" lines mycol lines(1 - res[, 2], res[, 1], lwd = lwd, col = mycol) ROC.tic Epi:::ROC.tic
-------------------------------------------------------------------------------------------------------
abline(h=0)
-------------------------------------------------------------------------------------------------------
panel.dotplot(...) panel=function(...){
              panel.dotplot(...)
              panel.abline(v=0.25)
              panel.abline(v=-0.25)
              } d1<-dotplot(Category ~Values, data = StandBias.df, groups = Groups,
            main = "Standardized Mean Differences", col = c("black", "grey50"), pch=c(22,15), xlab=NULL,
            key=list(text=list(c("Pre-Matching", "Post-Matching")),
                     points=list(col = c("black", "grey50"), pch=c(22,15)), 
                     space="bottom", border=T),
            panel=function(...){
              panel.dotplot(...)
              panel.abline(v=0.25)
              panel.abline(v=-0.25)
              }
)

Ttest.df = data.frame(
  Category= rep(c("A", "B", "C", "D", "E", "F"), 2),
  Groups = factor(c(rep("0", 6), rep("1", 6))),
  Values = c(0.12, 0.02, 0.69, 0.19, 0.05, 0.01, 0.62, 0.77, 0.54, 0.24, 0.92, 0.51))


d2<-dotplot(Category ~Values, data = Ttest.df, groups = Groups,
            main = "p-values", col = c("black", "grey50"), pch=c(22,15), xlab=NULL,
            key=list(text=list(c("Pre-Matching", "Post-Matching")),
                     points=list(col = c("black", "grey50"), pch=c(22,15)), 
                     space="bottom", border=T),
          panel=function(...){
            panel.dotplot(...)
            panel.abline(v=0.25)
            panel.abline(v=-0.25)
          }
)

grid.arrange(d1,d2,nrow=1)
-------------------------------------------------------------------------------------------------------
set.seed(1)

phuong <- data.frame(Eeff = rnorm(100,31))
phuong$Neff <- rnorm(100,19.7 + .36*phuong$Eeff)

# Create the lm object ahead of time
lm1 <- lm(Neff ~ Eeff, data = phuong)

# Create the character string that you want to print
tp <- sprintf("%s=%.1f + %.2f %s", all.vars(formula(lm1))[1],
  coef(lm1)[1], coef(lm1)[2], all.vars(formula(lm1))[2])

# Change the mypanel function to use the lm1 object
mypanel<-function(x,y,...){
  panel.xyplot(x, y, ...)
  panel.abline(lm1)
  panel.text(30,33,labels=tp)
}

library(lattice)

# and off we go.

xyplot(Neff~Eeff,data=phuong,panel=mypanel,
       col="black",
       pch=18,xlab="Energy efficiency (%)",
       ylab = "Nitrogen efficiency (%)", main="(a)")
-------------------------------------------------------------------------------------------------------
#Script

library(ggplot2)

## sampling from a Weibull distribution with parameters shape=2.1 and scale=1.1
x.wei<-rweibull(n=200,shape=2.1,scale=1.1) 

#Weibull population with known paramters shape=2 e scale=1
x.teo<-rweibull(n=200,shape=2, scale=1) ## theorical quantiles from a

#Figure
qqplot(x.teo,x.wei,main="QQ-plot distr. Weibull") ## QQ-plot
abline(0,1) ## a 45-degree reference line is plotted
-------------------------------------------------------------------------------------------------------
show_guide=TRUE p <- ggplot(df, aes(x, y)) +
geom_point(size=1.2) +
scale_x_continuous(expand=c(0,0)) +
scale_y_continuous(expand=c(0,0)) +
geom_smooth(method="lm", se=FALSE, formula=y~x, colour="blue", fill=NA, size=1.2) +
geom_abline(aes(colour="red"),intercept=0, slope=1, size=1.2,show_guide=TRUE) +
geom_text(aes(x=max(df[,1])/1.4, y=max(df[,2])/1.2, label="lm_eqn(df)"), colour="blue",  parse=TRUE) +
# doesn't work: scale_colour_manual("Lines", labels=c("Main Diagonal", "Regression"), values=c("red", "blue")) +
labs(x="X", y="Y") + opts(legend.position = 'left') + opts(legend.position = 'left') lm_eqn ""
-------------------------------------------------------------------------------------------------------
x<- read.table(text="Date Price1 Price2 NA.
 28.08.1987  18.30  19.44 1.24
 31.08.1987  18.65  19.75 1.12", sep="", header=TRUE)
x$Date <- as.Date(x$Date, "%d.%m.%Y")

plot(x$Date, x$NA.) # If we're trying to find the actual coordinates of some points on the plot
# here is what we find:
locator() 
$x
[1] 6449.495 6448.035 6450.967

$y
[1] 1.182379 1.186610 1.182908

# The x axis is running from 6448 to 6451 and here is the reason:

x$Date # Here is your date vector
[1] "1987-08-28" "1987-08-31"
as.numeric(x$Date) # And here it is converted in numerics
[1] 6448 6451 # Hence the values found on the plot with locator.

# The default origin for dates is the first of January, 1970
# 6448 is the number of days from that date to the 28th of August 1987.

# But you can still use regression tools:
lm(NA.~Date, data=x)->lmx
abline(lmx)  # YOu don't actually need to break your lm object into its coefficients, abline recognize lm objects. # And the same works with package zoo
library(zoo)
x<- read.table(text="Date Price1 Price2 NA.
 28.08.1987  18.30  19.44 1.24
 31.08.1987  18.65  19.77 1.12
 01.09.1987  18.65  19.75 1.10", sep="", header=TRUE)
x$Date <- as.Date(x$Date, "%d.%m.%Y")
SPRC<-zoo(x$NA.,x$Date)
SPRC2<-lag(SPRC, -1)
SPRC<-SPRC[2:length(SPRC)]
LMO<-lm(SPRC ~ SPRC2)
plot(SPRC)
abline(LMO)
-------------------------------------------------------------------------------------------------------
p <- ggplot(df, aes(x, y)) +
geom_point(size=1.2) +
scale_x_continuous(expand=c(0,0)) +
scale_y_continuous(expand=c(0,0)) +
geom_abline(aes(colour="red"),intercept=0, slope=1, size=1.2, aes(colour="1"), show_guide=TRUE) + # new code
geom_smooth(method="lm", se=FALSE, formula=y~x, fill=NA, size=1.2, aes(colour="2"), show_guide=TRUE) + # new code
scale_colour_manual("Lines", labels=c("Diagonal", "Regression"), values=c("red", "blue")) +
opts(legend.position = c(0.85, 0.15)) # relative values, must be set individually
-------------------------------------------------------------------------------------------------------
> plot.new()
> abline(0.1,0,lty='28282383') # works
> abline(0.2,0,lty='83282823') # works
> abline(0.3,0,lty='28238328') # segfault
> abline(0.4,0,lty='23832828') # segfault
> sessionInfo()
R version 2.15.0 (2012-03-30)
Platform: x86_64-apple-darwin9.8.0/x86_64 (64-bit)

locale:
[1] C/en_US.UTF-8/C/C/C/C

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
[1] reshape2_1.2.1

loaded via a namespace (and not attached):
[1] plyr_1.7.1    stringr_0.6.1 tools_2.15.0
-------------------------------------------------------------------------------------------------------
d <- data.frame(x=c(1,4,5,7),
                y=c(0.8,4.2,4.7,8)) lm1 <- lm(y~x,data=d) p_conf1 <- predict(lm1,interval="confidence")
p_pred1 <- predict(lm1,interval="prediction") nd <- data.frame(x=seq(0,8,length=51))
p_conf2 <- predict(lm1,interval="confidence",newdata=nd)
p_pred2 <- predict(lm1,interval="prediction",newdata=nd) plot(y~x,data=d,ylim=c(-5,12),xlim=c(0,8)) ## data
abline(lm1) ## fit
matlines(d$x,p_conf1[,c("lwr","upr")],col=2,lty=1,type="b",pch="+")
matlines(d$x,p_pred1[,c("lwr","upr")],col=2,lty=2,type="b",pch=1)
matlines(nd$x,p_conf2[,c("lwr","upr")],col=4,lty=1,type="b",pch="+")
matlines(nd$x,p_pred2[,c("lwr","upr")],col=4,lty=2,type="b",pch=1) confint type="terms" interval="none"
-------------------------------------------------------------------------------------------------------
stat_smooth(method="lm") library(ggplot2)
x <- rnorm(100)
y <-  + .7*x + rnorm(100)
f1 <- as.factor(c(rep("A",50),rep("B",50)))
f2 <- as.factor(rep(c(rep("C",25),rep("D",25)),2))
df <- data.frame(cbind(x,y))
df$f1 <- f1
df$f2 <- f2

ggplot(df,aes(x=x,y=y))+geom_point()+facet_grid(f1~f2)+stat_smooth(method="lm",se=FALSE) geom_abline() ggplot(df,aes(x=x,y=y))+geom_point()+facet_grid(f1~f2)+geom_abline(intercept = 0, slope = 1 )
-------------------------------------------------------------------------------------------------------
plot(speed ~ dist, data = cars)
fit1 = lm(speed ~ dist, cars) #fits a linear model
plot(speed ~ dist, data = cars)
abline(fit1) #puts line on plot
fit2 = lm(speed ~ I(dist^2) + dist, cars) #fits a model with a quadratic term
fit2line = predict(fit2, data.frame(dist = -10:130))
-------------------------------------------------------------------------------------------------------
plotAreaCorridor = function(x, y, col.poly1="lightgray", col.poly2="gray",...) {
   x.pol = c(x, rev(x), x[1])
   y.pol = c(y[,1], rev(y[,5]),y[,1][1])
   plot(x, y[,6]+1, type="n", ...) # ugly since type="n" does not work for factor
   polygon(x.pol, y.pol, col=col.poly1, lty=0)

   x.pol = c(x, rev(x), x[1])
   y.pol = c(y[,2], rev(y[,4]), y[,1][1])
   polygon(x.pol, y.pol, col=col.poly2, lty=0)

   lines(x, y[,3], col="blue") # median
   lines(x, y[,6], col="red")  # max

   return(invisible())
}
pause = gcdata$Pause.s.
hours = droplevels(cut(gcdata$date, breaks="hours")) # can I have 2 hours?
agg = aggregate(pause ~ hours, FUN=quantile, probs=c(5,20,50,80,95,100)/100)
x = agg$hours
ys = agg$pause
q99 <- function(x, ...) {  x <- quantile(x,probs=c(0.99)) }  
v99 = q99(gcdata$Pause.s.)
vmed = median(gcdata$Pause.s.)
plotAreaCorridor(x, ys,ylim=c(0,v99*1.5))
abline(h=vmed, col="lightblue")
abline(h=v99, col="grey")
label=paste("99%=",round(v99,digits=3),"s n=", length(gcdata$date),sep="")
text(x=30, y=v99, label, col="grey", pos=3)
title("NewPar Collection Activity")
-------------------------------------------------------------------------------------------------------
period.apply() endpoints() library(zoo)                                # for zoo objects
library(xts)                                # for period.apply

gcdata <- read.table("http://bernd.eckenfels.net/view/gc1001.ygc.csv",
                     header=TRUE, sep=",", dec=".")
timestamps <- gcdata$Timestamp + 
              as.POSIXct(strptime("2012-01-01 00:00:00", 
                         format="%Y-%m-%d %H:%M:%S"))
gcdatazoo <- zoo(gcdata[-1], order.by=timestamps)    # as zoo object zoo plotAreaCorridor <- function(x, y, col.poly1="lightgray", col.poly2="gray",...) {
    x.pol <- c(x, rev(x), x[1])
    y.pol <- c(y[,1], rev(y[,5]),y[,1][1])
    plot(x, y[,6]+1, type="n", ...) 
    polygon(x.pol, y.pol, col=col.poly1, lty=0)

    x.pol <- c(x, rev(x), x[1])
    y.pol <- c(y[,2], rev(y[,4]), y[,1][1])
    polygon(x.pol, y.pol, col=col.poly2, lty=0)

    lines(x, y[,3], col="blue") # median
    lines(x, y[,6], col="red")  # max

    invisible(NULL)
} agg <- period.apply(gcdatazoo[,"Pause.s."],               # to which data
                    INDEX=endpoints(gcdatazoo, "hours", k=2), # every 2 hours
                    FUN=function(x) quantile(x,               # what fun.
                                             probs=c(5,20,50,80,95,100)/100)) 

#v99 = q99(gcdata$Pause.s.)        # what is q99 ?
v99 <- mean(agg[,5])                  # mean of 95-th percentile?
plotAreaCorridor(index(agg),          # use time index as x axis
                 coredata(agg),       # and matrix part of zoo object as data
                 ylim=c(0,max(agg[,5])*1.5),
                 ylab="Quantiles of GC events",
                 main="NewPar Collection Activity")
abline(h=median(gcdatazoo[,"Pause.s."]), col="lightblue")
abline(h=v99, col="grey")
labeltxt <- paste("99%=",round(v99,digits=3),"s n=", nrow(gcdatazoo),sep="")
text(x=index(agg)[20], y=1.5*v99, labeltxt, col="grey", pos=3)  # or legend()
-------------------------------------------------------------------------------------------------------
library(dynlm)
set.seed(771104)
x <- 5 + seq(1, 10, len=100) + rnorm(100)
y <- x + rnorm(100)
model <- dynlm(x ~ y)

par(oma=c(1,1,1,2))
plotModel(x, model) # works with models which accept 'predict' and 'residuals' plotModel plotModel =  function(x, model) {
  ymodel1 = range(x, fitted(model), na.rm=TRUE)
  ymodel2 = c(2*ymodel1[1]-ymodel1[2], ymodel1[2])
  yres1   = range(residuals(model), na.rm=TRUE)
  yres2   = c(yres1[1], 2*yres1[2]-yres1[1])
  plot(x, type="l", col="red", lwd=2, ylim=ymodel2, axes=FALSE,
       ylab="", xlab="")
  axis(1)
  mtext("residuals", 1, adj=0.5, line=2.5)
  axis(2, at=pretty(ymodel1))
  mtext("observed/modeled", 2, adj=0.75, line=2.5)
  lines(fitted(model), col="green", lwd=2)
  par(new=TRUE)
  plot(residuals(model), col="blue", type="l", ylim=yres2, axes=FALSE, 
       ylab="", xlab="")
  axis(4, at=pretty(yres1))
  mtext("residuals", 4, adj=0.25, line=2.5)
  abline(h=quantile(residuals(model), probs=c(0.1,0.9)), lty=2, col="gray")
  abline(h=0)
  box()  
}
-------------------------------------------------------------------------------------------------------
qqline(diffbp,probs=c(0.3,0.7)) qqline() set.seed(101)
z <- rgamma(1000,shape=1)
newprobs <- c(0.1,0.9)
## png("qq.png")
qqnorm(z,pch=".")
qqline(z,col="red")
qqline(z,col="blue",probs=newprobs)
## add reference lines
abline(h=quantile(z,c(0.25,0.75)),col="red",lty=2)
abline(h=quantile(z,newprobs),col="blue",lty=2)
abline(v=qnorm(c(0.25,0.75)),col="red",lty=2)
abline(v=qnorm(newprobs),col="blue",lty=2)
## dev.off()
-------------------------------------------------------------------------------------------------------
stats qqline myQqplot <- function(data, probs){
  qqnorm(data)
  theQuants <- quantile(data, probs = probs)
  lm1 <- lm(theQuants~qnorm(probs))
  abline(lm1)
  invisible()
}

myQqplot(diffbp, c(.5,.99)) probs
-------------------------------------------------------------------------------------------------------
x <- 1:10
set.seed(1)
y <- 2*x+rnorm(10)

plot(y~x)

fit <- lm(y~x)
abline(fit)

resi <- resid(fit)
#below the fit:
sum(resi < 0)
#above the fit:
sum(resi > 0) x <- 1:10
set.seed(1)
y <- 2*x+rnorm(10)

plot(y~x)
abline(-0.17,2.05) yfit <- 2.05 * x - 0.17
resi <- y - yfit

sum(resi < 0)
sum(resi > 0)
-------------------------------------------------------------------------------------------------------
library( maps )
map( "world" )
points(  -0.11832, 51.50939, pch= 19, col= "red" )
text(  -0.11832, 51.50939, "London", pos=3, col= "red" )
abline( h= 0 )
text( -150, 0, "Equator", pos= 3 )
abline( v= 0 )
-------------------------------------------------------------------------------------------------------
abline conne <- file("Landcover.bin", "rb")
sd<- readBin(conne, integer(), size=1,  n=360*720, signed=F)
y<-matrix(sd,ncol=360,nrow=720)
image(y[,360:1])

lats=seq(-90,90,by=30)
longs=seq(-180,180,by=30) 

trans.lats=(lats+90) / 180
trans.longs=(longs+180) / 360

abline(h=trans.lats,v=trans.longs)
-------------------------------------------------------------------------------------------------------
plot.stacked plot.stacked <- function(x,y, ylab="", xlab="", ncol=1, xlim=range(x, na.rm=T), ylim=c(0, 1.2*max(rowSums(y), na.rm=T)), border = NULL, col=rainbow(length(y[1,]))){

    plot(x,y[,1], ylab=ylab, xlab=xlab, ylim=ylim, xaxs="i", yaxs="i", xlim=xlim, t="n")
    bottom=0*y[,1]
    for(i in 1:length(y[1,])){
        top=rowSums(as.matrix(y[,1:i]))
        polygon(c(x, rev(x)), c(top, rev(bottom)), border=border, col=col[i])
        bottom=top
    }
    abline(h=seq(0,200000, 10000), lty=3, col="grey")
    legend("topleft", rev(colnames(y)), ncol=ncol, inset = 0, fill=rev(col), bty="0", bg="white", cex=0.8, col=col)
    box()
} set.seed(1)
m <- 500
n <- 15
x <- seq(m)
y <- matrix(0, nrow=m, ncol=n)
colnames(y) <- seq(n)
for(i in seq(ncol(y))){
    mu <- runif(1, min=0.25*m, max=0.75*m)
    SD <- runif(1, min=5, max=30)
    TMP <- rnorm(1000, mean=mu, sd=SD)
    HIST <- hist(TMP, breaks=c(0,x), plot=FALSE)
    fit <- smooth.spline(HIST$counts ~ HIST$mids)
    y[,i] <- fit$y
}

    plot.stacked(x,y) plot.stream library(devtools)
source_url('https://gist.github.com/menugget/7864454/raw/f698da873766347d837865eecfa726cdf52a6c40/plot.stream.4.R')

set.seed(1)
m <- 500
n <- 50
x <- seq(m)
y <- matrix(0, nrow=m, ncol=n)
colnames(y) <- seq(n)
for(i in seq(ncol(y))){
    mu <- runif(1, min=0.25*m, max=0.75*m)
    SD <- runif(1, min=5, max=30)
    TMP <- rnorm(1000, mean=mu, sd=SD)
    HIST <- hist(TMP, breaks=c(0,x), plot=FALSE)
    fit <- smooth.spline(HIST$counts ~ HIST$mids)
    y[,i] <- fit$y
}
y <- replace(y, y<0.01, 0)

#order by when 1st value occurs
ord <- order(apply(y, 2, function(r) min(which(r>0))))
y2 <- y[, ord]
COLS <- rainbow(ncol(y2))

png("stream.png", res=400, units="in", width=12, height=4)
par(mar=c(0,0,0,0), bty="n")
plot.stream(x,y2, axes=FALSE, xlim=c(100, 400), xaxs="i", center=TRUE, spar=0.2, frac.rand=0.1, col=COLS, border=1, lwd=0.1)
dev.off() #plot.stream makes a "stream plot" where each y series is plotted 
#as stacked filled polygons on alternating sides of a baseline.
#
#Arguments include:
#'x' - a vector of values
#'y' - a matrix of data series (columns) corresponding to x
#'order.method' = c("as.is", "max", "first") 
#  "as.is" - plot in order of y column
#  "max" - plot in order of when each y series reaches maximum value
#  "first" - plot in order of when each y series first value > 0
#'center' - if TRUE, the stacked polygons will be centered so that the middle,
#i.e. baseline ("g0"), of the stream is approximately equal to zero. 
#Centering is done before the addition of random wiggle to the baseline. 
#'frac.rand' - fraction of the overall data "stream" range used to define the range of
#random wiggle (uniform distrubution) to be added to the baseline 'g0'
#'spar' - setting for smooth.spline function to make a smoothed version of baseline "g0"
#'col' - fill colors for polygons corresponding to y columns (will recycle)
#'border' - border colors for polygons corresponding to y columns (will recycle) (see ?polygon for details)
#'lwd' - border line width for polygons corresponding to y columns (will recycle)
#'...' - other plot arguments
plot.stream <- function(
    x, y, 
    order.method = "as.is", frac.rand=0.1, spar=0.2,
    center=TRUE,
    ylab="", xlab="",  
    border = NULL, lwd=1, 
    col=rainbow(length(y[1,])),
    ylim=NULL, 
    ...
){

if(sum(y < 0) > 0) error("y cannot contain negative numbers")

if(is.null(border)) border <- par("fg")
border <- as.vector(matrix(border, nrow=ncol(y), ncol=1))
col <- as.vector(matrix(col, nrow=ncol(y), ncol=1))
lwd <- as.vector(matrix(lwd, nrow=ncol(y), ncol=1))

if(order.method == "max") {
    ord <- order(apply(y, 2, which.max))
    y <- y[, ord]
    col <- col[ord]
    border <- border[ord]
}

if(order.method == "first") {
    ord <- order(apply(y, 2, function(x) min(which(r>0))))
    y <- y[, ord]
    col <- col[ord]
    border <- border[ord]
}

bottom.old <- x*0
top.old <- x*0
polys <- vector(mode="list", ncol(y))
for(i in seq(polys)){
    if(i %% 2 == 1){ #if odd
        top.new <- top.old + y[,i]
        polys[[i]] <- list(x=c(x, rev(x)), y=c(top.old, rev(top.new)))
        top.old <- top.new
    }
    if(i %% 2 == 0){ #if even
        bottom.new <- bottom.old - y[,i]
        polys[[i]] <- list(x=c(x, rev(x)), y=c(bottom.old, rev(bottom.new)))
        bottom.old <- bottom.new
    }
}

ylim.tmp <- range(sapply(polys, function(x) range(x$y, na.rm=TRUE)), na.rm=TRUE)
outer.lims <- sapply(polys, function(r) rev(r$y[(length(r$y)/2+1):length(r$y)]))
mid <- apply(outer.lims, 1, function(r) mean(c(max(r, na.rm=TRUE), min(r, na.rm=TRUE)), na.rm=TRUE))

#center and wiggle
if(center) {
    g0 <- -mid + runif(length(x), min=frac.rand*ylim.tmp[1], max=frac.rand*ylim.tmp[2])
} else {
    g0 <- runif(length(x), min=frac.rand*ylim.tmp[1], max=frac.rand*ylim.tmp[2])
}

fit <- smooth.spline(g0 ~ x, spar=spar)

for(i in seq(polys)){
    polys[[i]]$y <- polys[[i]]$y + c(fit$y, rev(fit$y))
}

if(is.null(ylim)) ylim <- range(sapply(polys, function(x) range(x$y, na.rm=TRUE)), na.rm=TRUE)
plot(x,y[,1], ylab=ylab, xlab=xlab, ylim=ylim, t="n", ...)
for(i in seq(polys)){
    polygon(polys[[i]], border=border[i], col=col[i], lwd=lwd[i])
}

}
-------------------------------------------------------------------------------------------------------
abline(v=quantile(data1,c(0.25,0.5,0.75))
abline(h=quantile(data2,c(0.25,0.5,0.75))
-------------------------------------------------------------------------------------------------------
?plotmath ## Generate Sample Data
x = c(2,4,6,8,9,4,5,7,8,9,10)
y = c(4,7,6,5,8,9,5,6,7,9,10)

## Create a dataframe to resemble existing data
mydata = data.frame(x,y)

## fit model
fit <- lm(y~x, data = mydata) bquote() .(foo) foo substitute() ## Calculate RMSE and other values
rmse <- round(sqrt(mean(resid(fit)^2)), 2)
coefs <- coef(fit)
b0 <- round(coefs[1], 2)
b1 <- round(coefs[2],2)
r2 <- round(summary(fit)$r.squared, 2) ?plotmath eqn <- bquote(italic(y) == .(b0) + .(b1)*italic(x) * "," ~~ 
                  r^2 == .(r2) * "," ~~ RMSE == .(rmse)) ## Plot the data
plot(y ~ x, data = mydata)
abline(fit)
text(2, 10, eqn, pos = 4)
-------------------------------------------------------------------------------------------------------
data <- c(rnorm(100,mean=20),rnorm(100,mean=12))

peakfinder <- function(d){
  dh <- hist(d,plot=FALSE)
  ins <- dh[["intensities"]]
  nbins <- length(ins)
  ss <- which(rank(ins)%in%seq(from=nbins-2,to=nbins)) ## pick the top 3 intensities
  dh[["mids"]][ss]
}

peaks <- peakfinder(data)

hist(data)
sapply(peaks,function(x) abline(v=x,col="red"))
-------------------------------------------------------------------------------------------------------
DF MeansByNum <- tapply(DF$Percent, DF$Num, mean) #Create an array of means by Num
NewDF <- data.frame(cbind(Num = as.numeric(as.vector(names(MeansByNum))),
                          Percent = as.numeric(MeansByNum)))
plot(Percent~Num, DF)
points(NewDF$Num, NewDF$Percent, col="red")
abline(lm(Percent~Num, NewDF))
-------------------------------------------------------------------------------------------------------
grDevices::devAskNewPage(ask = TRUE) readline abline plot(y) myFun <- function() {
     x = rnorm(20)
        y = 7*x^2 - 0.5*x + rnorm(20)
    y.0 = lm(y ~ 1)
    plot(y)
       # We'd get the same constant by just doing mean(y), but fitting it as a
       # regression model means functions like residuals() and predict() are
       # available for use later, the same as our other models
    abline(h=y.0$coefficients[1])
    # Get evenly spaced points for pretty plotting of other models
    d = seq(min(x),max(x),length.out=200)
    # Fit polynomials of order 1 to 9
    # It would be nicer if we let this run from 0 to 9, but R doesn't allow us to do a polynomial of degree 0
    for (degree in 1:9) {
        fm = lm(y ~ poly(x,degree))
        # Store the results in models called y.1, y.2, through y.9
        # The assign/paste trick here is often useful for storing results
            # which do not fit well into arrays!
            # check: y.1; y.2;...
        assign(paste("y",degree,sep="."), fm)
        # Plot them, with different line types
        readline('Press return to see the next line added')
        lines(d, predict(fm, data.frame(x=d)), lty=(degree+1))
    }

        x.new = rnorm(2e4)
        y.new = 7*x.new^2 - 0.5*x.new + rnorm(2e4)
        plot(x.new,y.new,xlab="x",ylab="y",pch=24,cex=0.1,col="blue")
        curve(7*x^2-0.5*x,col="grey",add=TRUE)  # the old curve
        abline(h=y.0$coefficients[1])
        d = seq(from=min(x.new),to=max(x.new),length.out=200)
        for (degree in 1:9) {
           fm = get(paste("y",degree,sep="."))
           readline('Press return to see the next line added')
           lines(d, predict(fm,data.frame(x=d)),lty=(degree+1))
        }
        points(x,y,col="red")
}
myFun()
-------------------------------------------------------------------------------------------------------
VerticalHist <- function(x, xscale = NULL, xwidth, hist,
                         fillCol = "gray80", lineCol = "gray40") {
    ## x (required) is the x position to draw the histogram
    ## xscale (optional) is the "height" of the tallest bar (horizontally),
    ##   it has sensible default behavior
    ## xwidth (required) is the horizontal spacing between histograms
    ## hist (required) is an object of type "histogram"
    ##    (or a list / df with $breaks and $density)
    ## fillCol and lineCol... exactly what you think.
    binWidth <- hist$breaks[2] - hist$breaks[1]
    if (is.null(xscale)) xscale <- xwidth * 0.90 / max(hist$density)
    n <- length(hist$density)
    x.l <- rep(x, n)
    x.r <- x.l + hist$density * xscale
    y.b <- hist$breaks[1:n]
    y.t <- hist$breaks[2:(n + 1)]

    rect(xleft = x.l, ybottom = y.b, xright = x.r, ytop = y.t,
         col = fillCol, border = lineCol)
}



## Usage example
require(plyr) ## Just needed for the round_any() in this example
n <- 1000
numberOfHists <- 4
data <- data.frame(ReleaseDOY = rnorm(n, 110, 20),
                   bin = as.factor(rep(c(1, 2, 3, 4), n / 4)))
binWidth <- 1
binStarts <- c(1, 2, 3, 4)
binMids <- binStarts + binWidth / 2
axisCol <- "gray80"

## Data handling
DOYrange <- range(data$ReleaseDOY)
DOYrange <- c(round_any(DOYrange[1], 15, floor),
                      round_any(DOYrange[2], 15, ceiling))

## Get the histogram obects
histList <- with(data, tapply(ReleaseDOY, bin, hist, plot = FALSE,
    breaks = seq(DOYrange[1], DOYrange[2], by = 5)))
DOYmean <- with(data, tapply(ReleaseDOY, bin, mean))

## Plotting
par(mar = c(5, 5, 1, 1) + .1)
plot(c(0, 5), DOYrange, type = "n",
     ann = FALSE, axes = FALSE, xaxs = "i", yaxs = "i")

axis(1, cex.axis = 1.2, col = axisCol)
mtext(side = 1, outer = F, line = 3, "Length at tagging (mm)",
      cex = 1.2)
axis(2, cex.axis = 1.2, las = 1, line = -.7, col = "white",
    at = c(75, 107, 138, 169),
    labels = c("March", "April", "May", "June"), tck = 0)
mtext(side = 2, outer = F, line = 3.5, "Date tagged", cex = 1.2)
box(bty = "L", col = axisCol)

## Gridlines
abline(h = c(60, 92, 123, 154, 184), col = "gray80")

biggestDensity <- max(unlist(lapply(histList, function(h){max(h[[4]])})))
xscale <- binWidth * .9 / biggestDensity

## Plot the histograms
for (lengthBin in 1:numberOfHists) {
    VerticalHist(binStarts[lengthBin], xscale = xscale,
                         xwidth = binWidth, histList[[lengthBin]])
    }
-------------------------------------------------------------------------------------------------------
datf datf <- datf[order(datf$pollut, datf$lag), ] datfPlusNA <- lapply(split(datf, datf$pollut), function(x) rbind(NA, x, NA))
datf <- do.call(rbind, datfPlusNA) nr <- nrow(datf)  # find out how many rows all together
with(datf, {# this allows entering your commands more succinctly
    # first you could set up the plot so you can select the order of drawing
    plot(1:nr, or, ylim = c(0.8, 1.3), type = 'n', xaxt = 'n', xlab = '', ylab = 'Odds Ratio and 95% CI', frame.plot = TRUE, panel.first = grid(nx = NA, ny = NULL))
    # arrows(1:nr, lcl, 1:nr, ucl, length = 0.02, angle = 90, code = 3, col = factor(lag)) 
    # you could use arrows above but you don't want ends so segments is easier
    segments(1:nr, lcl, 1:nr, ucl, col = factor(lag))
    # add your points
    points(1:nr, or, pch = 19, cex = 0.6)
    xLabels <- na.omit(unique(pollut))
    axis(1, seq(4, 34, by = 6) - 0.5, xLabels)
})
abline(h = 1.0)
-------------------------------------------------------------------------------------------------------
densityplot(~gcsescore | factor(score), data=Chem97,
    panel=function(x,...){
      panel.densityplot(x,...)
      median.values <- median(x) 
      panel.abline(v=median.values, col.line="red") 
    })
-------------------------------------------------------------------------------------------------------
?par xaxs par(xaxs="r")       #The default  
plot(1:10, 1:10) abline(v=1-(diff(range(1:10)))*0.04, col="red")
abline(v=10+(diff(range(1:10)))*0.04, col="red")
-------------------------------------------------------------------------------------------------------
year lm df$year2 <- as.numeric(factor(year))    

library(gplots)
plotmeans(value ~ year, data= df, p = 0.99, connect= FALSE)
abline(h=c(100), col= "blue", lty= 2)
abline(lm(value ~ year2, data= df))
-------------------------------------------------------------------------------------------------------
h <- getRdates()
# Find version release rate
library(plyr)
h <- subset(h,select=c(-Description))
Version <- sub("^R-([0-9a-z.-]+)\\.t.*","\\1",h$Name)
h$bigVersion <- as.numeric(sub("^([0-9])\\..+","\\1",Version))
h$smallVersion <- as.numeric(sub("^[0-9]\\.([0-9]+).+","\\1",Version))
h$majorVersion <- as.numeric(paste(h$bigVersion,sprintf( "%02.0f", h$smallVersion ),sep="."))
h <- ddply( h, .(bigVersion,majorVersion), function(x) {
    x$tinyVersion <- seq(nrow(x))
    x
})

# Plot
plot( majorVersion~Date, data=h, pch=".",cex=3)
abline(h=seq(1,2),col="red") library(lattice)
print(xyplot( smallVersion~Date|bigVersion, data=h, pch=".",cex=3)) h <- ddply( h, .(bigVersion), function(x) {
   x$bigElapsedTime <- x$Date - min(x$Date)
   x
})

png("c:/temp/Rplot3.png")
plot( smallVersion~bigElapsedTime, data=h, pch=".",cex=3,col=h$bigVersion+1)
dev.off() # How many minor releases per major release

> table(rle(h$majorVersion)$lengths, substring(rle(h$majorVersion)$values,1,1))

    0 1 2
  1 1 0 0
  2 5 5 9
  3 1 1 6
  4 2 4 1
  5 1 0 0
-------------------------------------------------------------------------------------------------------
y <- c(1,2,3,5)
barplot(rep(NA,length(y)),ylim=c(0,max(y)),axes=FALSE)
abline(h=mean(y))
barplot(y, add=T)
-------------------------------------------------------------------------------------------------------
ab ab xts xtsExtra xtsExtra library(xts)

ab=structure(c(-1, 0.579760106421202, -0.693649703427259, 0.0960078627769613, 
           0.829770469089809, -0.804276208608663, 0.72574639798749, 0.977165659135716, 
           -0.880178529686181, -0.662078620277974, -1, 2.35268982675599, 
           -0.673979231663719, 0.0673890875594205, 1.46584597734824, 0.38403707067242, 
           -1.53638088345349, 0.868743976582955, -1.8394614923913, 0.246736581314485), .Dim = c(10L, 2L), .Dimnames = list(NULL, c("a", "b")), index = structure(c(1354683600, 
          1354770000, 1354856400, 1354942800, 1355029200, 1355115600, 1355202000, 
          1355288400, 1355374800, 1355461200), tzone = "", tclass = "Date"), class = c("xts", 
          "zoo"), .indexCLASS = "Date", .indexTZ = "", tclass = "Date", tzone = "")

#Set up the plot area so that multiple graphs can be crammed together
#In the "par()" statement below, the "mar=c(0.3, 0, 0, 0)" part is used to change
#the spacing between the graphs.   "mar=c(0, 0, 0, 0)" is zero spacing.
par(pty="m", plt=c(0.1, 0.9, 0.1, 0.9), omd=c(0.1, 0.9, 0.2, 0.9), mar=c(0.3, 0, 0, 0))

#Set the area up for 2 plots
par(mfrow = c(2, 1))

#Build the x values so that plot() can be used, allowing more control over the format
xval <- index(ab)

#Plot the top graph with nothing in it =========================
plot(x=xval, y=ab$a, type="n", xaxt="n", yaxt="n", main="", xlab="", ylab="")
mtext(text="ab", side=3, font=2, line=0.5, cex=1.5)

#Store the x-axis data of the top plot so it can be used on the other graphs
pardat <- par()

#Layout the x axis tick marks
xaxisdat <- index(ab)

#If you want the default plot tick mark locations, un-comment the following calculation
#xaxisdat <- seq(pardat$xaxp[1], pardat$xaxp[2], (pardat$xaxp[2]-pardat$xaxp[1])/pardat$xaxp[3])

#Get the y-axis data and add the lines and label
yaxisdat <- seq(pardat$yaxp[1], pardat$yaxp[2], (pardat$yaxp[2]-pardat$yaxp[1])/pardat$yaxp[3])
axis(side=2, at=yaxisdat, las=2, padj=0.5, cex.axis=0.8, hadj=0.5, tcl=-0.3)
abline(v=xaxisdat, col="lightgray")
abline(h=yaxisdat, col="lightgray")
mtext(text="ab$a", side=2, line=2.3)
lines(x=xval, y=ab$a, col="red")
box() #Draw an outline to make sure that any overlapping abline(v)'s or abline(h)'s are covered

#Plot the 2nd graph with nothing in it ================================
plot(x=xval, y=ab$b,  type="n", xaxt="n", yaxt="n", main="", xlab="", ylab="")

#Get the y-axis data and add the lines and label
pardat <- par()
yaxisdat <- seq(pardat$yaxp[1], pardat$yaxp[2], (pardat$yaxp[2]-pardat$yaxp[1])/pardat$yaxp[3])
axis(side=2, at=yaxisdat, las=2, padj=0.5, cex.axis=0.8, hadj=0.5, tcl=-0.3)
abline(v=xaxisdat, col="lightgray")
abline(h=yaxisdat, col="lightgray")
mtext(text="ab$b", side=2, line=2.3)
lines(x=xval, y=ab$b, col="blue")
box() #Draw an outline to make sure that any overlapping abline(v)'s or abline(h)'s are covered

#Plot the X axis =================================================
axis(side=1, label=format(as.Date(xaxisdat), "%b %d\n%Y\n") , at=xaxisdat, padj=0.4, cex.axis=0.8, hadj=0.5, tcl=-0.3)
mtext(text="Date", side=1, line=2.5)
-------------------------------------------------------------------------------------------------------
data(sunspots)
sunspots = as.numeric(sunspots)
smoothover = 21 # Try smaller values here to see the failure
y = filter(sunspots,rep(1/smoothover,smoothover),circular=TRUE)
plot(y)
thresh =30
abline(h=thresh)
cross = which(diff(sign(y-thresh))!=0)-1
rug(cross)
-------------------------------------------------------------------------------------------------------
abline(coef(lm(weight~pronotum))  # works if dataframe is attached. wtpro<-lm(weight~pronotum, data= morpho)
with( morpho ,  plot(weight,pronotum) )
abline( coef(wtpro) )
-------------------------------------------------------------------------------------------------------
y <- rnorm(10)
x <- rnorm(10) + 5 plot(y,x)
abline(lm(y~x), col='red', main='Check the axis labels') plot(x,y)
abline(lm(y~x), col='red', main='Check the axis labels')
-------------------------------------------------------------------------------------------------------
#this is how to create vectors of sequential integers integers in R
a <- c(1:33)
b <- c(1:33)
c <- c(1:33)
d <- c(1:33,267:300)

#this is how to create an empty vector
means <- rep(NA,length(a)*length(b)*length(c)*length(d))
#set up for a loop
i <- 1

#how you run a loop to perform this operation
for(j in 1:length(a)){
    for(k in 1:length(b)){
        for(l in 1:length(c)){
            for(m in 1:length(d)){
                y <- c(a[j],b[k],c[l],d[m])
                means[i] <- mean(y)
                i <- i+1
            }
        }
    }
}

#and to graph your output
hist(means, col='brown')
#lets put a mean line through the histogram
abline(v=mean(means), col='white', lwd=2)
-------------------------------------------------------------------------------------------------------
checkbox require(gWidgets2) ## from github
options(guiToolkit="Qt") ## other choices too
source(system.file("examples", "manipulate.R", package="gWidgets2"))

manipulate({
  plot(mpg ~ wt, mtcars)
  if(do_lm)
    abline(lm(mpg ~ wt, mtcars))
  if(do_loess)
    with(mtcars, lines(lowess(wt, mpg)))
  ## ...
},
           do_lm=checkbox("Add regression line"),
           do_loess = checkbox("Add lowess fit")
           )
-------------------------------------------------------------------------------------------------------
my.symbols ms.polygon ms.arrows plot(c(-2,2),c(-2,2), axes=FALSE, xlab='', ylab='', type='n', asp=1)
abline(v=0, col='lightgrey')
abline(h=0, col='lightgrey')
my.symbols(c(0,0),c(0,0),ms.polygon, xsize=c(2,4), lwd=c(1,2), n=360)

theta <- seq(pi/4, 3*pi/4, length=250)
lines( 2.03*cos(theta), 2.03*sin(theta), lwd=2, lty='dashed' )
lines( c(0,0), c(0,2), lty='dashed', lwd=2 )

a <- c(300,305,355,0,5,45,65)
l <- c(1.1, .5, .4,1,.6,.7,1.25)

my.symbols( rep(0,7), rep(0,7), ms.arrows, xsize=2, r=l, adj=0, 
        angle=pi/2 - pi/180*a )
-------------------------------------------------------------------------------------------------------
plot(log(area)~log(weight), df) LM.Log <- lm(log(area)~log(weight), df)
abline(LM.Log, col="red") Power <- coef(LM.Log)[2]
LM.Normal <- lm(area~I(weight^Power)+0, df)
plot(area~weight, df)
plot(function(x) coef(LM.Normal)*x^Power, 0, 2, add=T, col="blue")
-------------------------------------------------------------------------------------------------------
my1 <- data.frame (company = rep(c("A", "B", "C"), each = 7), skillsDg = rep(c("Basic", "HighSc", "Undgd", "MAST", "PHD", "EXPD", "EXECT"), 3), number = c(200, 100, 40, 30, 10, 0, 0, 220, 110, 35, 10, 0, 4, 1, 140, 80, 120, 50, 52, 52, 3) )

my2 <- split(my1,my1$company) #split your dataframe into a list where each element is a company
# The next line create the layout
layout(matrix(1:(length(my2)+1), nrow=1), width=c(1,rep(4,length(my2))))
# Then we draw the x-axis:
par(mar=c(3,0,3,0))
plot(NA,axes=F, xlim=c(0,1),ylim=c(1,nlevels(my1$skillsDg)))
axis(side=4,tick=F,labels=unique(my1$skillsDg),
     at=seq_along(unique(my1$skillsDg)), las=2, line=-4)
# Then we apply a graphing function to each company:
lapply(my2,function(x){
    par(mar=c(3,0,3,0))
    plot(NA, xlim=c(-max(my1$number),max(my1$number)), 
             ylim=c(1,nlevels(my1$skillsDg)),axes=F)
    title(sub=x$company[1],line=1)
    abline(h=seq_along(x$skillsDg), col="grey80")
    polygon(x=c(x$number,rev(-1*x$number)), 
            y=c(seq_along(x$skillsDg),rev(seq_along(x$skillsDg))), 
            col=as.numeric(x$company))
    }) lapply layout(matrix(1:(length(my2)+1), nrow=1), width=c(1,rep(4,length(my2))))
par(mar=c(3,0,3,0))
plot(NA,axes=F, xlim=c(0,1),ylim=c(1,nlevels(my1$skillsDg)))
axis(side=4,tick=F,labels=unique(my1$skillsDg),
    at=seq_along(unique(my1$skillsDg)), las=2, line=-4)
lapply(my2,function(x){
    par(mar=c(3,0,3,0))
    plot(NA, xlim=c(-max(my1$number)-50,max(my1$number)+50), 
        ylim=c(1,nlevels(my1$skillsDg)),axes=F)
    title(sub=x$company[1],line=1)
    abline(h=seq_along(x$skillsDg), col="grey80")
    text(x=x$number+5, y=seq_along(x$skillsDg)+.1, label=x$number, pos=4)
    polygon(x=c(x$number,rev(-1*x$number)), 
        y=c(seq_along(x$skillsDg),rev(seq_along(x$skillsDg))), 
        col=as.numeric(x$company))
    })
-------------------------------------------------------------------------------------------------------
axis(side = 1, at = c([all the ticks you want])); ticks # Cumulative Distribuition
pdf("g1_3.pdf");

plot(x = f$V2, y = cumsum(f$V1), log = "x", pch = 3,
     xlab = "Frequency", ylab = "P(X <= x)", axes = FALSE);

ticks = c(1, 5, 10, 40, 150, 500, 1000);
axis(side = 1, at = ticks);
axis(side = 2);

abline(h = seq(0, 1, 0.2), v = ticks, col = "lightgray", lty = 3);
box();
-------------------------------------------------------------------------------------------------------
?grid par(las=1,bty="l")
h <- hist(bulkdata$discovered,breaks=bins,
     col='gray',ylab="Discovered",xlab="Year",main="",
     ylim=c(0,100),axes=FALSE)
yrs <- 1989:2012
yvals <- seq(0,100,by=10)
axis(1, at=yrs)
axis(2, at=yvals)
abline(h=yvals,v=yrs,col="gray",lty=3)
hist(bulkdata$discovered,breaks=bins,
     col='gray',ylab="Discovered",xlab="Year",main="", add=TRUE)
-------------------------------------------------------------------------------------------------------
set.seed(0815)
x <- 1:10
F <- runif(10,1,2) 
L <- runif(10,0,1)
U <- runif(10,2,3)

require(plotrix)
plotCI(x, F, ui=U, li=L) set.seed(0815)
df <- data.frame(x =1:10,
                 F =runif(10,1,2),
                 L =runif(10,0,1),
                 U =runif(10,2,3))

require(ggplot2)
ggplot(df, aes(x = x, y = F)) +
  geom_point(size = 4) +
  geom_errorbar(aes(ymax = U, ymin = L)) set.seed(1234)
x <- rnorm(20)
df <- data.frame(x = x,
                 y = x + rnorm(20))

plot(y ~ x, data = df)

# model
mod <- lm(y ~ x, data = df)

# predicts + interval
newx <- seq(min(df$x), max(df$x), length.out=100)
preds <- predict(mod, newdata = data.frame(x=newx), 
                 interval = 'confidence')

# plot
plot(y ~ x, data = df, type = 'n')
# add fill
polygon(c(rev(newx), newx), c(rev(preds[ ,3]), preds[ ,2]), col = 'grey80', border = NA)
# model
abline(mod)
# intervals
lines(newx, preds[ ,3], lty = 'dashed', col = 'red')
lines(newx, preds[ ,2], lty = 'dashed', col = 'red')
-------------------------------------------------------------------------------------------------------
n<-50
x<-sample(40:70,n,rep=T)
y<-.7*x+rnorm(n,sd=5)
plot(x,y,xlim=c(20,90),ylim=c(0,80))
mylm<-lm(y~x)
abline(mylm,col="red")
newx<-seq(20,90)
prd<-predict(mylm,newdata=data.frame(x=newx),interval = c("confidence"), 
level = 0.90,type="response")
lines(newx,prd[,2],col="red",lty=2)
lines(newx,prd[,3],col="red",lty=2) x <- rnorm(15)
y <- x + rnorm(15)
new <- data.frame(x = seq(-3, 3, 0.5))

pred.w.clim <- predict(lm(y ~ x), new, interval="confidence")


# Just create a blank plot region with axes first. We'll add to this
plot(range(new$x), range(pred.w.clim), type = "n", ann = FALSE)


# For convenience
CI.U <- pred.w.clim[, "upr"]
CI.L <- pred.w.clim[, "lwr"]

# Create a 'loop' around the x values. Add values to 'close' the loop
X.Vec <- c(new$x, tail(new$x, 1), rev(new$x), new$x[1])

# Same for y values
Y.Vec <- c(CI.L, tail(CI.U, 1), rev(CI.U), CI.L[1])

# Use polygon() to create the enclosed shading area
# We are 'tracing' around the perimeter as created above
polygon(X.Vec, Y.Vec, col = "grey", border = NA)


# Use matlines() to plot the fitted line and CI's
# Add after the polygon above so the lines are visible
matlines(new$x, pred.w.clim, lty = c(1, 2, 2), type = "l", col =  
c("black", "red", "red"))
-------------------------------------------------------------------------------------------------------
xyplot(
  Petal.Width  ~ Petal.Length,
  groups = Species,
  data = iris,
  panel = function(x, y, ...) {
    panel.superpose(x, y, ...,
                    panel.groups = function(x,y, col, col.symbol, ...) {
                      panel.xyplot(x, y, col=col.symbol, ...)
                      panel.abline(lm(y~x), col.line=col.symbol)
                    }
    )
  },
  grid = TRUE,
  auto.key = list(title='Species', space='right')
)
-------------------------------------------------------------------------------------------------------
piece_area <- c(0, (x[-1] - x[-length(x)])*(y[-1] + y[-length(y)]) / 2)
cum_area <- cumsum(piece_area)
total_area <- cum_area[length(cum_area)]
idx095 <- min(which(cum_area > 0.95 * total_area))

abline(v = x[idx095])
-------------------------------------------------------------------------------------------------------
xyplot(speed ~ dist, data=cars,
       panel=function(x, y, col, ...) {
         panel.xyplot(x, y, col='red', ...)
         panel.abline(lm(y~x), col='blue')
       },
       type='l'
)
-------------------------------------------------------------------------------------------------------
base scales library(scales)
xy.poly <- data.frame(Freq=c(xy.pop$Freq, rep(0,nrow(xy.pop))), 
                      Var1=c(xy.pop$Var1, rev(xy.pop$Var1)))
xx.poly <- data.frame(Freq=c(xx.pop$Freq, rep(0,nrow(xx.pop))), 
                      Var1=c(xx.pop$Var1, rev(xx.pop$Var1)))
xrange <- range(c(xy.poly$Freq, xx.poly$Freq))
yrange <- range(c(xy.poly$Var1, xx.poly$Var1))

par(mfcol=c(1,2))
par(mar=c(5,4,4,0))
plot(xy.poly,type="n", main="Men", xlab="", ylab="", xaxs="i", 
     xlim=rev(xrange), ylim=yrange, axes=FALSE)
rect(-1,0,100,100, col="blue")
abline(h=0:15, col="white", lty=3)
polygon(xy.poly, col=alpha("grey",0.6))
axis(1, at=seq(0,20,by=5))
axis(2, las=2)
box()

par(mar=c(5,0,4,4))
plot(xx.poly,type="n", main="Women", xaxs="i", xlab="", ylab="",
     xlim=xrange, ylim=yrange, axes=FALSE)
rect(-1,0,100,100, col="red")
abline(h=0:15, col="white", lty=3)
axis(1, at=seq(5,20,by=5))
axis(4, las=2)
polygon(xx.poly, col=alpha("grey",0.6))
box()
-------------------------------------------------------------------------------------------------------
xyplot(Comp1~ln1wr, 
        data=moose,
        groups=Season,
        xlab = "Wolf risk", ylab = "Principal component 1",
        par.settings=list(superpose.symbol=list(pch=1:2, col=1),
                          superpose.line=list(lty=1:2, col=1)),
        panel = function(x, y, ...) {
          panel.superpose(x, y, ...,
                          panel.groups = function(x,y, col, col.symbol, lty, ...) {
                            panel.xyplot(x, y, col=col.symbol, ...)
                            panel.abline(lm(y~x), col.line=col.symbol, lty=lty)
                          }
          )
        },
        auto.key=list(title='Season', space='inside', 
                      #text=c('Summer', 'Winter'),
                      lines=TRUE)
 )
-------------------------------------------------------------------------------------------------------
panel.smooth.spline <-  function(x, y,
                                 w=NULL, df, spar = NULL, cv = FALSE,
                                 lwd=plot.line$lwd, lty=plot.line$lty,col, 
                                 col.line=plot.line$col,type, ... )
{
  x <- as.numeric(x)
  y <- as.numeric(y)
  ok <- is.finite(x) & is.finite(y)
  if (sum(ok) < 1)
    return()
  if (!missing(col)) {
    if (missing(col.line))
      col.line <- col
  }
  plot.line <- trellis.par.get("plot.line")
  spline <-   smooth.spline(x[ok], y[ok],
                            w=w, df=df, spar = spar, cv = cv)
  pred = predict(spline,x= seq(min(x),max(x),length.out=150))
  panel.lines(x = pred$x, y = pred$y, col = col.line,
              lty = lty, lwd = lwd, ...)
  panel.abline(h=y[which.min(x)],col=col.line,lty=2)
}
-------------------------------------------------------------------------------------------------------
require(fortunes)
 fortune("every question")

Lastly, by what we could call the 'Liaw-Baron principle', every question that can be 
asked has in fact  already been asked.
   -- Dirk Eddelbuettel (citing Andy Liaw's and Jonathan Baron's opinion on unique 
            questions on R-help)
      R-help (January 2006)

polygon(x= c(X[order(X)],    rev(X[order(X)]) ), # both x and y  go "out" in order; 
          y=c(L[order(X)], rev(U[order(X)])),  # and then come "back in reverse order
             col=rgb(1,0,0,0.3) )    # transparent pink.

> plot(X,Y, pch="+")
> abline(reg, col="red")
> polygon(x= c(X\[order(X)\], rev(X\[order(X)\]) ), y=c(L\[order(X)\],rev(U\[order(X)\])), col=rgb(1,0,0,0.3) )
-------------------------------------------------------------------------------------------------------
textbox plot(dat$Date,dat$Minimum)
 abline(coef(lm(Minimum~Date, data=dat)))
-------------------------------------------------------------------------------------------------------
year<-seq(from=2008,to=2010.75,by=.25)
cpi<-c(162.2,164.6,166.5,166.0,166.4,167.0,168.6,169.5,170.0,172.0,173.3,174.0)
df <- data.frame(year,cpi)
plot(df)+abline(lm(df$cpi~df$year))
-------------------------------------------------------------------------------------------------------
sctrl <- seg.control(toll = 1e-04, it.max = 1, display = FALSE,
     stop.if.error = TRUE, K = 10, quant = FALSE, last = TRUE, maxit.glm = 25, h = 1, 
     n.boot=20, size.boot=NULL, gap=FALSE, jt=FALSE, nonParam=TRUE,
     random=TRUE, powers=c(1,1), seed=NULL)
 linear.model2<-lm(y2~x)
 segmented.mod3<-segmented(linear.model2,seg.Z= ~x, control=sctrl, 
                                psi=c(0.0000001,0.000001))
 plot(log(x) ,predict(segmented.mod3))
 abline(v=log(0.0000001))           # cannot see anything of value on original scale
 abline(v=log(0.000001))
-------------------------------------------------------------------------------------------------------
density x = rnorm(100)
d = density(x, from=-5, to = 5, n = 1000)
d$x
d$y z x z = c(-2, -1, 2)
x = seq(-5, 5, 0.01) plot(0, 0, xlim=c(-5, 5), ylim=c(-0.02, 0.8), 
     pch=NA, ylab="", xlab="z")
for(i in 1:length(z)) {
   points(z[i], 0, pch="X", col=2)
}
 abline(h=0) ## Now we combine the kernels,
x_total = numeric(length(x))
for(i in 1:length(x_total)) {
  for(j in 1:length(z)) {
    x_total[i] = x_total[i] + 
      dnorm(x[i], z[j], sd=1)
  }
} lines(x, x_total, col=4, lty=2) ## Just as a histogram is the sum of the boxes, 
## the kernel density estimate is just the sum of the bumps. 
## All that's left to do, is ensure that the estimate has the
## correct area, i.e. in this case we divide by $n=3$:

plot(x, x_total/3, 
       xlim=c(-5, 5), ylim=c(-0.02, 0.8), 
       ylab="", xlab="z", type="l")
abline(h=0) density(z, adjust=1, bw=1)
-------------------------------------------------------------------------------------------------------
uniroot n*pi (n+1)*pi y = function(x) x-1/tan(x)
curve(y,xlim=c(-10,10),n=501,ylim=c(-5,5))
abline(v=(-3:3)*pi,col="gray")
abline(h=0,col=2) eps f <- function(n,eps=1e-6) uniroot(y,c(n*pi+eps,(n+1)*pi-eps))$root
sapply(0:3,f)
## [1] 0.8603337 3.4256204 6.4372755 9.5293334
-------------------------------------------------------------------------------------------------------
R > y = function(x) { x - 1/tan(x) }
R > curve(y, xlim = c(-10, 10))
R > abline(h = 0, color = 'red') uniroot R > uniroot(y, interval = c(0, 3))
$root
[1] 0.8603

$f.root
[1] 6.612e-06

$iter
[1] 7

$estim.prec
[1] 6.104e-05
-------------------------------------------------------------------------------------------------------
require(tikzDevice)


setwd("/Path/To/LaTeX/Files/")

#Names of LaTeX symbols
syms <- c('alpha', 'theta', 'tau', 'beta', 'vartheta', 'pi', 'upsilon', 'gamma', 'varpi', 'phi', 'delta', 'kappa', 'rho', 'varphi', 'epsilon', 'lambda', 'varrho', 'chi', 'varepsilon', 'mu', 'sigma', 'psi', 'zeta', 'nu', 'varsigma', 'omega', 'eta', 'xi', 'Gamma', 'Lambda', 'Sigma', 'Psi', 'Delta', 'Xi', 'Upsilon', 'Omega', 'Theta', 'Pi', 'Phi')
len <- length(syms)

# random colors (red, green, blue)
r <- round(runif(len), 2)
g <- round(runif(len), 2)
b <- round(runif(len), 2)

# calculate dummy data points
x <- runif(50,1,10)
y <- x + rnorm(length(x))
fit <- lm(y ~ x)
rsq <- summary(fit)$r.squared
rsq <- signif(rsq,4)

# plot the result, will create symbol-regression.tex in the working
# directory the first time this is run it may take a long time because the
# process of calulating string widths for proper placement is
# computationally intensive, the results will get cached for the current R
# session or will get permenantly cached if you set
# options( tikzMetricsDictionary='/path/to/dictionary' ) which will be
# created if it does not exist.  Also if the flag standAlone is not set to
# TRUE then a file is created which can be included with \include{}

tikz('symbolr.tex', width = 4,height = 4,pointsize = 12)

# The syntax is mar=c(bottom, left, top, right).
par(mar=c(2,2,2,2))
# plot the box and the regression line
plot(x, y, type='n', xlab='', ylab='')
box()
abline(fit)

# add the latex symbols as points
text(x, y, paste('\\color[rgb]{',r,',',g,',',b,'}{$\\',syms,'$}',sep=''))
# Display the correlation coefficient
mtext(paste("Linear model: $R^{2}=",rsq,"$" ),line=0.5)
# and the equation of the line
legend('bottom', legend = paste("$y = ", round(coef(fit)[2],3),'x +', round(coef(fit)[1],3), '$',  sep=''), bty= 'n')

# Close the device
dev.off()
-------------------------------------------------------------------------------------------------------
newdata predict ?predict.lm abline(v=min(x), col=4, lty=3)
-------------------------------------------------------------------------------------------------------
base ggplot2 bandline<-function(x, low.col, high.col, axis=TRUE){
    l <- max(unlist(lapply(x, length)), na.r=TRUE)
    r <- range(unlist(x), na.rm=TRUE)
    par(mfcol=c(length(x), 1))
    for(i in 1:length(x)){
        y <- boxplot.stats(x[[i]])
        ifelse(i==1, par(mar=c(0,3,3,3)), 
                     ifelse(i==length(x), par(mar=c(3,3,0,3)), 
                                          par(mar=c(0,3,0,3))))
        plot(NA, axes=F, bty="n", xlim=c(1,l), ylim=r, xaxs="i")
        rect(1,y$stats[2], l, y$stats[1], col="grey80", border=NA)
        rect(1,y$stats[4], l, y$stats[2], col="grey60", border=NA)
        rect(1,y$stats[5], l, y$stats[4], col="grey40", border=NA)
        abline(h=y$stats[3],col="white", lwd=2)
        lines(seq_along(x[[i]]), x[[i]])
        zhigh <- zlow <- x[[i]]
        zhigh[zhigh<=y$stats[5]]<-NA
        zlow[zlow>=y$stats[1]]<-NA
        points(seq_along(x[[i]]), zlow, bg=low.col, pch=21,cex=2)
        points(seq_along(x[[i]]), zhigh, bg=high.col, pch=21, cex=2)
        if(axis==TRUE){
            axis(2, at=pretty(x[[i]]), las=2)
            ifelse(i==1, axis(3, at=seq_len(l)), 
                         ifelse(i==length(x),axis(1, at=seq_len(l)),""))
            }
        mtext(names(x)[i], side=4, srt=270, line=1)
    }
} set.seed(1)
dat<-list(a=rnorm(100), b=rnorm(100), c=rnorm(100), d=rnorm(100))
bandline(dat, "black", "white", axis=FALSE)
-------------------------------------------------------------------------------------------------------
x <- rnorm(100,1)
y <- rnorm(100,1)

plot(x,y,axes=F)
abline(h=1)
abline(v=1)
-------------------------------------------------------------------------------------------------------
plot(x = 1:10, y = rnorm(10, 5, 2), xlim=c(1, 10), ylim=c(1, 10), panel.first=grid()) plot(x = 1:10, y = rnorm(10, 5, 2), xaxp=c(1, 10, 10), yaxp=c(1, 10, 10), axes=FALSE)
axis(1, 1:10)
axis(2, 1:10)
abline(h=1:10, v=1:10, col="gray", lty=3)
-------------------------------------------------------------------------------------------------------
apply(MSA, 2, function(x1) {
  apply(MSA, 2, function(x2) {
    t.test(x1, x2)
  })
}) cis <- apply(MSA, 2, function(x) mean(x) + c(-1, 1) * sd(x) * 1.96)
plot.new()
plot.window(xlim=c(1, ncol(cis)), ylim=range(cis))
segments(1:ncol(cis), cis[1, ], 1:ncol(cis), cis[2, ])
axis(1, at=1:ncol(cis), labels=colnames(MSA))
axis(2)
box()
abline(h=mean(MSA), lty='dashed')
title('Forest plot of 95% confidence intervals of MSA')
-------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------
arrows set.seed(1); ts.plot(x <-rnorm(10,0,1), ylim=c(-1.6,1.6))  # some random data
arrows(x0=1:length(x), y0=0, y1=x, code=2, col=2, length=.1) # adding arrows
text(x=1:10, y=x+.1, 0, labels=round(x,2), cex=0.65) # adding text
abline(h=0) # adding a horizontal line at y=0
-------------------------------------------------------------------------------------------------------
lattice set.seed(1234)
dat = data.frame(x=1:10, y = rnorm(10,0,1))
xyplot(y~x,data=dat, type =c('l','p'),
       panel = function(x,y,...){
         panel.fill(col=rgb(1,1,0,0.5))
         panel.xyplot(x,y,...)
         panel.arrows(x, y0=0,x1=x, y1=y, code=2, col=2, length=.1)
         panel.text(x,y,label=round(y,2),adj=1.2,cex=1.5)
         panel.abline(a=0)

       })
-------------------------------------------------------------------------------------------------------
geom_abline() geom_abline(aes(intercept=a,slope=b))
-------------------------------------------------------------------------------------------------------
ggplot() stat_qq() qplot() g<-ggplot(df, aes(sample = x)) + stat_qq() ggplot_build() data[[1]] df.new<-ggplot_build(g)$data[[1]]
head(df.new)
           x          y     sample theoretical PANEL group
1 -2.0368341 -2.7014255 -2.7014255  -2.0368341     1     1
2 -1.5341205 -2.0396294 -2.0396294  -1.5341205     1     1
3 -1.2581616 -0.8621446 -0.8621446  -1.2581616     1     1
4 -1.0544725 -0.7393900 -0.7393900  -1.0544725     1     1
5 -0.8871466 -0.5645608 -0.5645608  -0.8871466     1     1
6 -0.7415940 -0.4231126 -0.4231126  -0.7415940     1     1 order() df.new$name<-df$name[order(df$x)] geom_point() geom_text() ggplot(df.new,aes(theoretical,sample,label=name))+geom_text()+ 
  geom_abline(linetype = "dotted") + theme_bw()
-------------------------------------------------------------------------------------------------------
clpl <- function(xdata, names, y=1, dy=0.25, add=FALSE){
  o = order(xdata)
  xdata=xdata[o]
  names=names[o]
  if(!add)plot(0,type="n",ylim=c(y-1,y+2),xlim=range(xdata),axes=F,ylab="",xlab="")
  abline(h=1,lwd=4)
  dy=0.25
  segments(xdata,y-dy,xdata,y+dy)
  tpos = seq(min(xdata),max(xdata),len=length(xdata))
  text(tpos,y+2*dy,names,srt=90,adj=0)
  segments(xdata,y+dy,tpos,y+2*dy)
} clpl(mydf$position[lg1:lg2],mydf$mylab[lg1:lg2])
-------------------------------------------------------------------------------------------------------
# set the margins
tmpmar <- par("mar")
tmpmar[3] <- 0.5
par(mar=tmpmar)

# get underlying plot
x <- 1:10
y <- jitter(x^2)
plot(x, y, pch=20)

# basic straight line of fit
fit <- glm(y~x)
co <- coef(fit)
abline(fit, col="blue", lwd=2)

# exponential
f <- function(x,a,b) {a * exp(b * x)}
fit <- nls(y ~ f(x,a,b), start = c(a=1, b=1)) 
co <- coef(fit)
curve(f(x, a=co[1], b=co[2]), add = TRUE, col="green", lwd=2) 

# logarithmic
f <- function(x,a,b) {a * log(x) + b}
fit <- nls(y ~ f(x,a,b), start = c(a=1, b=1)) 
co <- coef(fit)
curve(f(x, a=co[1], b=co[2]), add = TRUE, col="orange", lwd=2) 

# polynomial
f <- function(x,a,b,d) {(a*x^2) + (b*x) + d}
fit <- nls(y ~ f(x,a,b,d), start = c(a=1, b=1, d=1)) 
co <- coef(fit)
curve(f(x, a=co[1], b=co[2], d=co[3]), add = TRUE, col="pink", lwd=2) # legend
legend("topleft",
    legend=c("linear","exponential","logarithmic","polynomial"),
    col=c("blue","green","orange","pink"),
    lwd=2,
    )
-------------------------------------------------------------------------------------------------------
x<-rnorm(100)
y<-2*x+rnorm(100)
fit<-lm(y~x)
plot(x=x,y=y)
abline(fit) #same as
abline(a=fit$coef[1],b=fit$coef[2])
-------------------------------------------------------------------------------------------------------
m <- read.table(header=T, text='
       X        Y
     0.5      6.0
      1.5      5.0
      2.5      6.7
      3.5      7.1
      4.5      6.1
      5.5      8.1
      6.5      8.0
      7.5      7.9
      8.5      8.0
     9.5      6.0')

with(m,plot(X,Y)) lm_xy <- lm(Y~X,m)

abline(lm_xy,col='blue')

summary(lm_xy) lm nls pn_xy <- nls(Y ~ a*(X - b)^2 + c, start = c(a=0.05, b=8, c=8),data=m)

lines(m$X,predict(pn_xy,m$X),col='red')

summary(pn_xy)
-------------------------------------------------------------------------------------------------------
with(list(p=0.5, m=50, n=20, alpha=0.1),
 with(list(phat=rbinom(m,n,p)/n, zstar=1-alpha/2),
      with(list(SE=sqrt((1-phat)*phat/n)),{
        matplot(rbind(phat-SE*zstar,phat+SE*zstar),
                rbind(1:m,1:m), type='l',
                lty=1)
        abline(v=p)}))) local({
  p=0.5;m=50;n=20;alpha=0.1
  phat=rbinom(m,n,p)/n
  zstar=1-alpha/2
  SE=sqrt((1-phat)*phat/n)
  matplot(rbind(phat-SE*zstar,phat+SE*zstar),rbind(1:m,1:m), type='l',lty=1)
  abline(v=p)
})
-------------------------------------------------------------------------------------------------------
as.matrix pi/2 #sample data
set.seed(1) #for consistency of random-generated data
d <- matrix(c(sort(runif(50)),sort(runif(50))),ncol=2)

#rotation about point A
rotA <- function(d) {
d.offset <- apply(d,2,function(z) z - z[1]) #offset data
  endpoint <- d.offset[nrow(d.offset),] #gets difference
  rot <- function(angle) matrix(
    c(cos(angle),-sin(angle),sin(angle),cos(angle)),nrow=2) #CCW rotation matrix
  if(endpoint[2] == 0) {
    return(d) #if y-diff is 0, then no action required
  } else if (endpoint[1] == 0) { 
    rad <- pi/2 #if x-diff is 0, then rotate by a right angle
  } else {rad <- atan(endpoint[2]/endpoint[1])}
  d.offset.rotate <- d.offset %*% rot(-rad) #rotation
  d.rotate <- sapply(1:2,function(z) d.offset.rotate[,z] + d[1,z]) #undo offset
  d.rotate
}

#results and plotting to check visually
d.rotate <- rotA(d)
plot(d.rotate)
abline(h=d[1,2])
-------------------------------------------------------------------------------------------------------
hexbin grid base grid.abline grid.abline(325,0) ggplot2 library(ggplot2)
ggplot(data,aes(x=alpha,y=beta)) + geom_hex(bins=10) + geom_hline(yintercept=0.5)
-------------------------------------------------------------------------------------------------------
hexbinplot() panel style hexbinplot library(hexbin)
library(lattice)
x <- rnorm(1e6)
y <- rnorm(1e6)
hexbinplot(x ~ y, aspect = 1, bins=50, 
           xlab = expression(alpha), ylab = expression(beta), 
           style = "nested.centroids",
           panel = function(...) {
             panel.hexbinplot(...)
             panel.abline(h=0)
             })
-------------------------------------------------------------------------------------------------------
lattice y x xyplot(foodexp~income , data =engel, 
       type = c("g"),
       auto.key=list(x=.8,y=.35,cex=.8,cex.title=.8, title="", points=TRUE), 
       scales=list(tck=-1),ylab=list("Food Expenditure",font=3),
       xlab=list("Household Income",font=3),
       panel=function(x,y,...){
         panel.xyplot(x,y)
         panel.grid()
         panel.abline(rq(y ~ x, tau = 0.5))
         panel.points(x, y, cex = 0.5, col = "blue")
         panel.abline(rq(y ~ x, tau = 0.5), col = "blue")
         panel.abline(lm(y ~ x), lty = 2, col = "red")
         taus <- c(0.05, 0.1, 0.25, 0.75, 0.9, 0.95)
         for (i in 1:length(taus)) {
           panel.abline(rq(y ~ x, tau = taus[i]),
                  col = "gray")
         }

       }
)
-------------------------------------------------------------------------------------------------------
abline(line, col="blue",untf=TRUE)
-------------------------------------------------------------------------------------------------------
slope intercept g <- ggplot(data.frame(x=-10:10, y=-10:10), aes(x, y))+geom_point()
my_coefs <- data.frame(slope=-5:5, intercept=-5:5)

g + geom_abline(data=my_coefs, aes(slope=slope, intercept=intercept))
-------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------
wp <- structure(list(M.1990 = c(325814, 295272, 269351, 265163, 249651, 220027, 196523, 178295, 141789, 115097, 106579, 91763, 77150, 56845, 38053, 25716, 19442), M.2000 = c(319675, 317296, 317072, 290827, 262992, 256378, 241401, 212924, 188905, 169133, 131813, 103162, 90921, 72231, 53449, 32707, 25868), M.2010 = c(328759, 315119, 311456, 312831, 311077, 284258, 255596, 248575, 232217, 202633, 176241, 153494, 114194, 83129, 65266, 43761, 39223), F.1990 = c(308121, 281322, 257432, 254065, 238856, 211943, 188433, 170937, 138358, 112931, 106510, 93425, 82667, 67057, 47679, 37435, 36724), F.2000 = c(298455, 297012, 299757, 277706, 252924, 248127, 233583, 207518, 183646, 165444, 132307, 105429, 96681, 80227, 64956, 45832, 46413), F.2010 = c(307079, 293664, 290598, 293313, 295739, 273379, 247383, 241938, 226914, 201142, 176440, 156283, 121200, 92071, 77990, 56895, 66029)), .Names = c("M.1990", "M.2000", "M.2010", "F.1990", "F.2000", "F.2010"), row.names = c("0-4", "5-9", "10-14", "15-19", "20-24", "25-29", "30-34", "35-39", "40-44", "45-49", "50-54", "55-59", "60-64", "65-69", "70-74", "75-79", "80+"), class = "data.frame")

wp
      M.1990 M.2000 M.2010 F.1990 F.2000 F.2010
0-4   325814 319675 328759 308121 298455 307079
5-9   295272 317296 315119 281322 297012 293664
10-14 269351 317072 311456 257432 299757 290598
15-19 265163 290827 312831 254065 277706 293313
20-24 249651 262992 311077 238856 252924 295739
25-29 220027 256378 284258 211943 248127 273379
30-34 196523 241401 255596 188433 233583 247383
35-39 178295 212924 248575 170937 207518 241938
40-44 141789 188905 232217 138358 183646 226914
45-49 115097 169133 202633 112931 165444 201142
50-54 106579 131813 176241 106510 132307 176440
55-59  91763 103162 153494  93425 105429 156283
60-64  77150  90921 114194  82667  96681 121200
65-69  56845  72231  83129  67057  80227  92071
70-74  38053  53449  65266  47679  64956  77990
75-79  25716  32707  43761  37435  45832  56895
80+    19442  25868  39223  36724  46413  66029

xrange <- range(c(0,wp))
yrange <- range(c(0,nrow(wp))) par(mfcol=c(1,2))
par(mar=c(5,4,4,0))
plot(NA,type="n", main="Men", xlab="", ylab="", xaxs="i", 
     xlim=rev(xrange), ylim=yrange, axes=FALSE, yaxs="i")
rect(xrange[1],yrange[1],xrange[2],yrange[2], col="cadetblue")
abline(v=seq(0,xrange[2],by=1e5), col="white")
# All years with bars you want to represent filled 
# should be entered in reverse order
polygon(c(0,rep(wp$M.2000,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)),
        col="lightblue",border="lightblue")
polygon(c(0,rep(wp$M.1990,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)), 
        col="darkblue",border="darkblue")
# And those you want with just a border, afterwards:
polygon(c(0,rep(wp$M.2010,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)), 
        col=NA,border="darkred",lwd=2)
axis(1, at=c(0,1e5,2e5,3e5), labels=format(c(0,1e5,2e5,3e5),scientific=FALSE))
axis(2, at=1:nrow(wp)-0.5,labels=row.names(wp),las=2)
box()

par(mar=c(5,0,4,4))
plot(NA,type="n", main="Women", xlab="", ylab="", xaxs="i", 
     xlim=xrange, ylim=yrange, axes=FALSE, yaxs="i")
rect(xrange[1],yrange[1],xrange[2],yrange[2], col="cadetblue")
abline(v=seq(0,xrange[2],by=1e5), col="white")
polygon(c(0,rep(wp$F.2000,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)),
        col="lightblue",border="lightblue")
polygon(c(0,rep(wp$F.1990,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)), 
        col="darkblue",border="darkblue")
polygon(c(0,rep(wp$F.2010,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)), 
        col=NA,border="darkred",lwd=2)
axis(1, at=c(0,1e5,2e5,3e5), labels=format(c(0,1e5,2e5,3e5),scientific=FALSE))
axis(4, at=1:nrow(wp)-0.5,labels=row.names(wp),las=2)
box() library(scales)
[...]
polygon(c(0,rep(wp$M.1990,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)), 
        col=alpha("darkblue",0.4),border="darkblue")
[...]
polygon(c(0,rep(wp$F.1990,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)), 
        col=alpha("darkblue",0.4),border="darkblue")
[...]
-------------------------------------------------------------------------------------------------------
plot(lin,which=5) lin2 <- lm(y~x,weights=1/x)
summary(lin2)

Call:
lm(formula = y ~ x, weights = 1/x)

Weighted Residuals:
      Min        1Q    Median        3Q       Max 
-0.006699 -0.003383 -0.002407  0.002521  0.012733 

Coefficients:
             Estimate Std. Error t value Pr(>|t|)    
(Intercept) 3.099e-01  1.092e-01   2.838  0.00835 ** 
x           4.317e-06  5.850e-07   7.381 4.89e-08 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 

Residual standard error: 0.005674 on 28 degrees of freedom
Multiple R-squared: 0.6605, Adjusted R-squared: 0.6484 
F-statistic: 54.47 on 1 and 28 DF,  p-value: 4.888e-08 


plot(lin2,which=5) plot(x, y, log="xy",ylim=c(0.1,350))
abline(lin, col="blue", untf=TRUE)
abline(lin2, col="green", untf=TRUE)
-------------------------------------------------------------------------------------------------------
# fix the data because we're going to use it twice:
d=sample(data)
# plot it with X and Y coords known (note 1 larger than dimension)
image(1:51,1:3,matrix(d,nrow=50, ncol=2),las=1)
# add diagonal shading
polygon(x=c(1,51,51,1),y=c(1,1,3,3),density=3,col="red")
# replot. The NA's show through:
image(1:51,1:3,matrix(d,nrow=50, ncol=2),las=1,add=TRUE)
# outline the cells.
abline(h=1:3)
abline(v=1:51) x0=c(1:50,1:50)
x1=x0+1
y0=c(rep(1,50),rep(2,50))
y1=y0+1
image(1:51,1:3,matrix(d,nrow=50, ncol=2),las=1)
segments(x0,y0,x1,y1,col="red",lwd=2)
image(1:51,1:3,matrix(d,nrow=50, ncol=2),las=1,add=TRUE)
abline(v=1:51);abline(h=1:3)
-------------------------------------------------------------------------------------------------------
levelplot latticeExtra library(latticeExtra)
levelplot(count~Var1*Var2,data=dat,
          panel=function(x,y,z,...)
          {
            panel.abline(h=x,v=y,lty=2)
            cex <- scale(z)*3
            panel.levelplot.points(x,y,z,...,cex=5)
            panel.text(x,y,label=z,cex=0.8)
          },scales=(x=list(abbreviate=TRUE))) ## to get short labels library(latticeExtra)
levelplot(count~Var1*Var2,data=dat,
          panel=function(x,y,z,...)
          {
            panel.abline(h=x,v=y,lty=2)
            cex <- scale(z)*3
            panel.levelplot.points(x,y,z,...,cex=5)
            panel.text(x,y,label=z,cex=0.8)

          })
-------------------------------------------------------------------------------------------------------
tmp <- tapply( iris$Petal.Length, iris$Species, function(x) hist(x, plot=FALSE) )

plot.new()
tmp.r <- do.call( range, lapply(tmp, `[[`, 'breaks') )
plot.window(xlim=c(1/2,length(tmp)+1/2), ylim=tmp.r)
abline(v=seq_along(tmp))

for( i in seq_along(tmp) ) {
    h <- tmp[[i]]
    rf <- h$counts/sum(h$counts)
    rect( i-rf/2, head(h$breaks, -1), i+rf/2, tail(h$breaks, -1) )
}

axis(1, at=seq_along(tmp), labels=names(tmp))
axis(2)
box()
-------------------------------------------------------------------------------------------------------
Cx A Cy Cx B Cy Cx A Cy Cx B Cy Cx Cx Cx = mean(x) nls() nls(y ~ ifelse(x < mean(x),ya+A*x,yb+B*x), 
               data = data.frame(x,y), 
               start = c(A=-1000,B=-1000,ya=3,yb=0)) Nonlinear regression model
  model:  y ~ ifelse(x < mean(x), ya + A * x, yb + B * x) 
   data:  data.frame(x, y) 
        A         B        ya        yb 
-1325.537 -1335.918     2.628     2.652 
 residual sum-of-squares: 0.06614

Number of iterations to convergence: 1 
Achieved convergence tolerance: 2.294e-08 Cx [min(x),max(x)] x atan() [-inf,+inf] [0,1] trans <- function(x) 0.5+atan(x)/pi
xs <- sort(x)
xlo <- xs[3]
xhi <- xs[length(xs)-2]
nls(y ~ ifelse(x < xlo+(xhi-xlo)*trans(f),ya+A*x,yb+B*x), 
               data = data.frame(x,y), 
               start = c(A=-1000,B=-1000,ya=3,yb=0,f=0)) singular gradient matrix at initial parameters nls() Cx Cx optimize() xs <- sort(x)
xlo <- xs[3]
xhi <- xs[length(xs)-2]
nn <- function(f) nls(y ~ ifelse(x < xlo+(xhi-xlo)*f,ya+A*x,yb+B*x), 
               data = data.frame(x,y), 
               start = c(A=-1000,B=-1000,ya=3,yb=0))
ssr <- function(f) sum(residuals(nn(f))^2)
f = optimize(ssr,interval=c(0,1))
print (f$minimum)
print (nn(f$minimum))
summary(nn(f$minimum)) [1] 0.8541683
Nonlinear regression model
  model:  y ~ ifelse(x < xlo + (xhi - xlo) * f, ya + A * x, yb + B * x) 
   data:  data.frame(x, y) 
        A         B        ya        yb 
-1317.215  -872.002     2.620     1.407 
 residual sum-of-squares: 0.0414

Number of iterations to convergence: 1 
Achieved convergence tolerance: 2.913e-08 

Formula: y ~ ifelse(x < xlo + (xhi - xlo) * f, ya + A * x, yb + B * x)

Parameters:
     Estimate Std. Error t value Pr(>|t|)    
A  -1.317e+03  1.792e+01 -73.493  < 2e-16 ***
B  -8.720e+02  1.207e+02  -7.222 1.14e-07 ***
ya  2.620e+00  2.791e-02  93.854  < 2e-16 ***
yb  1.407e+00  3.200e-01   4.399 0.000164 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 

Residual standard error: 0.0399 on 26 degrees of freedom

Number of iterations to convergence: 1 A B ya yb f nls() lm() function (x,y) 
{
    f <- function (Cx) 
        {
        lhs <- function(x) ifelse(x < Cx,Cx-x,0)
        rhs <- function(x) ifelse(x < Cx,0,x-Cx)
        fit <- lm(y ~ lhs(x) + rhs(x))
        c(summary(fit)$r.squared, 
            summary(fit)$coef[1], summary(fit)$coef[2],
            summary(fit)$coef[3])
        }

    r2 <- function(x) -(f(x)[1])

    res <- optimize(r2,interval=c(min(x),max(x)))
    res <- c(res$minimum,f(res$minimum))

    best_Cx <- res[1]
    coef1 <- res[3]
    coef2 <- res[4]
    coef3 <- res[5]
    plot(x,y)
    abline(coef1+best_Cx*coef2,-coef2) #lhs  
    abline(coef1-best_Cx*coef3,coef3)  #rs
}
-------------------------------------------------------------------------------------------------------
range_x<-max(x)-min(x)
intervals=1000
coef1=c()
coef2=c()
coef3=c()
r2=c()

for (i in 1:intervals)  
{
Cx<-min(x)+(i-1)*(range_x/intervals)
lhs <- function(x) ifelse(x < Cx,Cx-x,0)
rhs <- function(x) ifelse(x < Cx,0,x-Cx)
fit <- lm(y ~ lhs(x) + rhs(x))
coef1[i]<-summary(fit)$coef[1]
coef2[i]<-summary(fit)$coef[2]
coef3[i]<-summary(fit)$coef[3]
r2[i]<-summary(fit)$r.squared
}
best_r2<-max(r2)                             # get best r squared
pos<-which.max(r2)                                          
best_Cx<-min(x)+(pos-1)*(range_x/intervals)  # get Cx for best r2

plot(x,y)
abline(coef1[pos]+best_Cx*coef2[pos],-coef2[pos]) #lhs  
abline(coef1[pos]-best_Cx*coef3[pos],coef3[pos])  #rs
-------------------------------------------------------------------------------------------------------
g2 <- lm(altura$marido~altura$esposa with(altura,plot(marido~esposa)) with(altura,plot(esposa~marido)) set.seed(1021)

x <- rnorm(100)
y <- 3*x + rnorm(100)
m1 <- lm(y~x)
plot(y~x)
abline(m1$coefficients)
m2 <- lm(x~y)
abline(m2$coefficients, col = 'red')
-------------------------------------------------------------------------------------------------------
plot(x$Totali.i.kredisë)
abline(lm(Totali.i.kredisë ~ index, data=cbind(x, index=as.numeric(rownames(x)))))
-------------------------------------------------------------------------------------------------------
mycomplicatedPlot <- function(x, ...){
    hist(x,...)
    abline(v=mean(x))
    abline(v=quantile(x, probs=c(0.025, 0.975)), lty=2, col="red")
}

pdf(file="test.all.pdf",width=7,height=10,pointsize=12,bg="white",paper="letter",pagecentre=T)
    par(mfrow=c(3,2))

    for(i in 1:12){
      temp <- rnorm(500,i,1)
      pdf(paste0("test_",i,".pdf"))
          mycomplicatedPlot(temp, main=i)
      dev.off()
    mycomplicatedPlot(temp, main=i)
    }
dev.off()
-------------------------------------------------------------------------------------------------------
var # Sample data
M <- 2736
N <- 3648
im <- matrix( FALSE, M, N );
y <- as.vector(row(im))
x <- as.vector(col(im))
im[ abs( y - M/2 ) < M/3 & abs( x - N/2 ) < N/3 ] <- TRUE
#image(im)
theta <- runif(1, -pi/12, pi/12)
xy <- cbind(x+1-N/2,y+1-M/2) %*% matrix(c( cos(theta), sin(theta), -sin(theta), cos(theta) ), 2, 2)
#plot(xy[,1]+N/2-1, xy[,2]+M/2-1); abline(h=c(1,M),v=c(1,N))
f <- function(u, lower, upper) pmax(lower,pmin(round(u),upper))
im[] <- im[cbind( f(xy[,2] + M/2 - 1,1,M), f(xy[,1] + N/2 - 1,1,N) )]
image(1:N, 1:M, t(im), asp=1)

# Variance matrix of the points in the rectangle
i <- which(im)
V <- var(cbind( col(im)[i], row(im)[i] ))
# Their eigenvectors
u <- eigen(V)$vectors
abline( M/2-N/2*u[2,1]/u[1,1], u[2,1]/u[1,1], lwd=5 )
abline( M/2-N/2*u[2,2]/u[1,2], u[2,2]/u[1,2] )
-------------------------------------------------------------------------------------------------------
base brX <- seq(min(myd$X),max(myd$X),length=11)
brY <- seq(min(myd$Y),max(myd$Y),length=11)

layout(matrix(c(1,0,2,3),nrow=2),width=c(2,8),height=c(8,2))
par(mar=c(0,3,5,0))
plot(NA,ylim=range(myd$Y),xlim=c(0,1),axes=F,ann=F,xaxs="i")
rect(0,brY[-length(brY)],1,brY[-1], 
     col=colorRampPalette(c("red","yellow","green"))(length(brY)-1))

par(mar=c(0,0,5,5))
plot(NA,xlim=range(myd$X),ylim=range(myd$Y),ann=F,xaxt="n",yaxt="n")
abline(h=pretty(myd$Y),v=pretty(myd$X), col="grey95")
points(myd$X,myd$Y,pch=21)
axis(3)
axis(4)

par(mar=c(3,0,0,5))
plot(NA,xlim=range(myd$X),ylim=c(0,1),axes=F,ann=F,yaxs="i")
rect(brX[-length(brX)],0,brX[-1],1, 
     col=colorRampPalette(c("blue","white","red"))(length(brX)-1))
-------------------------------------------------------------------------------------------------------
library(rootSolve) # for the uniroot.all function
pfind<-function(k=3,gamma=7) 
{
pdiff <-function(p0) p0-plogis(-k + gamma * p0) 
uniroot.all(p.diff,c(0,1))
}
> fps= pfind()
> fps
[1] 0.08036917 0.32257992 0.97925817 pseq =seq(0,1,length=100)
plot(x=pseq ,y= plogis(-k + gamma *pseq),type= 'l')
abline(0,1,col='grey')
points(matrix(rep(fps,each=2), ncol=2, byrow=TRUE),pch=19,col='red')
-------------------------------------------------------------------------------------------------------
bquote .() f<-function(x,alpha=0.9){ .... plot(x) legend("topleft", bquote(.(alpha)) ) } ?plotmath substitute alpha=0.2
 substitute( alpha, list(alpha=alpha) )
 #0.2 bquote x<-seq(0,60,length=150) 
 y<-rnorm(150,0,10) 
 yy<-x+y 
 d<-cbind(x,yy) 
 m<-lm(d[,2]~d[,1]) 
 plot(x,yy) > abline(m) 
 label1<-summary(m)$'r.squared' 
 label2<-summary(m)$'adj.r.squared' 
 legend("topleft", legend=bquote( R^2==.(label1)*";"~Adj.R^2==.(label2) ) )
-------------------------------------------------------------------------------------------------------
data.frame test test <- read.table(file="insert.your.file.here",header=TRUE) time plot lines matplot matplot(test["time"],test[c("x","y")],type="l") y x lm time x y lm(y ~ time, data=test), col="red")
lm(x ~ time, data=test), col="black") abline(lm(y ~ time, data=test), col="red"))
abline(lm(x ~ time, data=test), col="black"))
-------------------------------------------------------------------------------------------------------
nmod <- (lm(I(y-50)~I(x-10) +0, test))

abline(predict(nmod, newdata = list(x=0))+50, coef(nmod), col='red')
-------------------------------------------------------------------------------------------------------
lm() p=10
q=50

abline(lm(I(y-q) ~ I(x-p) + 0, data=test), col="red")
-------------------------------------------------------------------------------------------------------
dmode <- function(x) {
      den <- density(x, kernel=c("gaussian"))
        ( den$x[den$y==max(den$y)] )   
    }  

    n.modes <- function(x) {  
       den <- density(x, kernel=c("gaussian"))
       den.s <- smooth.spline(den$x, den$y, all.knots=TRUE, spar=0.8)
         s.0 <- predict(den.s, den.s$x, deriv=0)
         s.1 <- predict(den.s, den.s$x, deriv=1)
       s.derv <- data.frame(s0=s.0$y, s1=s.1$y)
       nmodes <- length(rle(den.sign <- sign(s.derv$s1))$values)/2
       if ((nmodes > 10) == TRUE) { nmodes <- 10 }
          if (is.na(nmodes) == TRUE) { nmodes <- 0 } 
       ( nmodes )
    }

# Example
x <- runif(1000,0,100)
  plot(density(x))
    abline(v=dmode(x))
-------------------------------------------------------------------------------------------------------
NA geom_text geom_text(data = out[!is.na(out$V1),], label = "test") rownames plotAll<-function(data){
  combs <- expand.grid(names(data), names(data))
  out <- do.call(rbind, apply(combs, 1, function(x) {
    tt <- data[, x]; names(tt) <- c("V1", "V2")
    tt <- cbind(tt, id1 = x[1], id2 = x[2])
  }))

  library(plyr)
  df.text=ddply(out[out$id1==out$id2,],.(id1,id2),summarise,
                pos=max(V1)-(max(V1)-min(V1))/2)
  out[out$id1==out$id2,c("V1","V2")]<-NA
  out$labels <- rownames(out)
  ggplot(data = out, aes(x = V2, y = V1)) + geom_text(data = out[!is.na(out$V1),], aes(label = labels)) +
    facet_grid(id1 ~ id2,scales="fixed")+
    geom_text(data=df.text,aes(pos,pos,label=id1)) + geom_abline( slope=1 ) + 
    ggtitle("Corralation between measured & calculated affinities") +
    ylab("") + xlab("") + theme(panel.grid.minor.x=element_blank(), panel.grid.major.x=element_blank())
}
plotAll(data)
-------------------------------------------------------------------------------------------------------
group panel.superpose() mtcars library(lattice)
library(MASS)

myPanel <- function(x,y,...) {
    panel.xyplot(x,y,...)
    panel.abline(rlm(y~x), ...)
}

xyplot(mpg~disp, group=cyl, data=mtcars,
       panel=function(...) panel.superpose(panel.groups=myPanel, ...))
-------------------------------------------------------------------------------------------------------
abline # Estimating the model
model <-  lm(snowfall~elevation, data=snowfallElevationPlot)

# Plot 
plot(elevation, snowfall)

# Adding the regression line to the plot
abline(model)
-------------------------------------------------------------------------------------------------------
library(lattice)
library(grid)

set.seed(20)
a <- data.frame(par1=runif(10, min=1, max=100),par2=runif(10, min=1, max=100))

print(xyplot( par1 ~ par2,
              data=a,
              panel = function(x,y){
                n <- length(x)
                r <- round(cor(x, y, use="pairwise.complete.obs"), 2)
                rc <- 1
                panel.abline(a=0, b=1, lty=2, col="grey59", lwd=1.5)
                panel.xyplot(x,y, type = c("p", "g"), col="grey29", cex=0.75)
                panel.abline(lm(y ~ x), col = "red", lwd=1.5)
                grid.text(paste("n=",length(x), "\n", "r=", r, "\n", sep=""), 0.60, .90, gp=gpar(col="black", fontsize=11), just="left")
                grid.text(bquote(r[c] == .(rc)), 0.60, .86, gp=gpar(col="black", fontsize=11), just="left")
              }
))
-------------------------------------------------------------------------------------------------------
panel plot.zoo ax.date <-as.POSIXlt("2013-01-06")+(0:167)*3600 #Dummy date for POSIXlt method

my.panel <- function(x, y, ..., pf = parent.frame()) {
 grid(NA,NULL)
 abline(v=seq(1,168,24),col = "lightgray", lty = "dotted", lwd = par("lwd"))
 lines(x, y, ...)

 #if bottom panel
 if (with(pf, length(panel.number) == 0 ||
        panel.number %% nr == 0 || panel.number == nser)) {
      # create ticks at x values and then label every 24th tick
      axis(side = 1, at = x, labels = FALSE, tcl=-0.3) #hour ticks
      axis(side = 1, at = seq(1,168,6), labels = FALSE) #6hour ticks ticks
      axis(1,at=seq(1,168,24), labels=format(ax.date[seq(1,168,24)],"%a")) #day of the week
      axis(1,at=seq(13,168,24),labels=format(ax.date[seq(13,168,24)],"%H"), cex.axis=0.7) #noon ticks
   }
 }
 plot(z[,3:5], panel = my.panel,yax.flip=TRUE,col=1:3,xaxt="n")
-------------------------------------------------------------------------------------------------------
barplot x <- 1:10
y1 <- rnorm(10)
y2 <- rnorm(10)
y.mat <- rbind(y1, y2)
mybar <- barplot(y.mat)
mylm <- lm(y1 ~ mybar )
abline(mylm$coef)
-------------------------------------------------------------------------------------------------------
> set.seed(9)
> df <- data.frame(
    a = sample(0:10, 100, replace = TRUE),
    b = sample(0:1, 100, replace = TRUE)
    )
> dft <- table(df) > dft
    b
a    0 1
  0  2 4
  1  7 5
  2  9 6
  3  1 5
  4  7 5
  5  4 4
  6  3 2
  7  5 3
  8  4 1
  9  4 6
  10 6 7 > (dft <- t(dft / rowSums(dft)))
   a
b           0         1         2         3         4         5         6         7         8         9        10
  0 0.3333333 0.5833333 0.6000000 0.1666667 0.5833333 0.5000000 0.6000000 0.6250000 0.8000000 0.4000000 0.4615385
  1 0.6666667 0.4166667 0.4000000 0.8333333 0.4166667 0.5000000 0.4000000 0.3750000 0.2000000 0.6000000 0.5384615 > barplot(dft, col = c('orange', 'green')) > df <- as.data.frame(dft)
> df <- df[which(df$b == 0), ]
> (fit <- lm(Freq ~ as.numeric(a), df))

Call:
lm(formula = Freq ~ as.numeric(a), data = df)

Coefficients:
  (Intercept)  as.numeric(a)  
       0.4353         0.0131 abline(fit, col = "red")
-------------------------------------------------------------------------------------------------------
panel.text #plot hisotgrams for each spp in 1cm bins
for (i in sp){
    BIN_WIDTH <- 1 #desired bin width
    print(histogram(~ Length..cm. | Method, #create and print histogram
    data = hist.data[hist.data$Scientific_name == i,], 
    nint = (max(hist.data$Length..cm.) - min(hist.data$Length..cm.)+1)/BIN_WIDTH,
    layout = c(1,2),
    type = "density",
    main = substitute(expr = expression(paste("Length-Frequency of ", italic(i), " by Gear")), env = list(i=i)),
    xlab = "Length (cm)",
    panel = function(x, ...){
        mean.values <- mean(x)
        panel.abline(v=mean.values, col.line="red", lty = 2)
        sample.n <- length(x)
        panel.text(lab = paste("Sample size = ", sample.n), mean.values*1.2, .26)
        panel.text(lab = paste("Mean = ", round(mean.values, 1)), mean.values*1.2, .23)
        panel.histogram(x,...)
        panel.mathdensity(dmath = dnorm, col = "black",
                      args = list(mean = mean(x), sd= sd(x)), ...)     
    }
    ))

    #save histogram to PDF file
    quartz.save(paste("Length-Frequency of", i, "by method.png", sep = " "), type = "png")
    dev.off() #close graphics diver
}
-------------------------------------------------------------------------------------------------------
Date abline x <- as.Date("2013-05-27")+0:99
y <- cumsum(rnorm(100))
plot(x,y)
abline(v=as.Date("2013-08-01"))
-------------------------------------------------------------------------------------------------------
ggplot2 mdf <- as.data.frame( rbind(XM1, XM2) )
names(mdf) <- c("x1", "x2")
mdf$f <- c( rep( "a", nrow(XM1) ), rep( "b", nrow(XM2) ) )
head(mdf)
  x1 x2 f
1  4  2 a
2  2  4 a
3  2  3 a
4  3  6 a
5  4  4 a
6  9 10 b library(ggplot2)
ggplot( mdf, aes(x=x1, y=x2, col=f) ) +
  geom_point( size = 4, aes(shape = f) ) +
  geom_abline( slope = eg$vectors[2,1] / eg$vectors[1,1], colour = "green"  ) +
  scale_shape_manual(values=c(16,15)) +
  expand_limits( y = 0, x = 0) +
  labs( title = paste("LDA projection vector with highest eigen value =", round(eg$values[1], 2)) ) +
  theme_bw()
-------------------------------------------------------------------------------------------------------
par1 <- par(no.readonly=TRUE) par2 <- par(no.readonly=TRUE) par(mfg=c(1,1)) par(mfrow=c(2,1))

plot( 1:10, 1:10 )
par1 <- par(no.readonly=TRUE)

plot( 101:110, 110:101 )
par2 <- par(no.readonly=TRUE)

par(par1)
par(mfg=c(1,1))
abline(h=5)

par(par2)
par(mfg=c(2,1))
abline(h=105) par(mfg=...
-------------------------------------------------------------------------------------------------------
mfg par() A <- sample(seq(from=-2, to=2, by=0.1), size=10, replace=TRUE)

par(mfrow=c(2, 1))
plot(seq(1:10), A, main="Plot 1") 
    abline(1.2, 0, col="red")
plot(seq(1:10), A, main="Plot 2") 
    abline(0.7, 0, col="green") 

par(mfg=c(1, 1))
    abline(-0.3, 0, col="blue")

par(mfg=c(2, 1))
    abline(-0.5, 0, col="purple")
-------------------------------------------------------------------------------------------------------
?plot ?abline ?text d <- data.frame(Name=LETTERS, Odds_Ratio_log2=runif(26, -8, 8), 
                p_value=runif(26))
plot(d$Odds_Ratio_log2, d$p_value, pch=20, xlim=c(-8, 8), ylim=c(0, 1),
     axes=F, xlab='', ylab='', yaxs='i')
abline(v=0, lwd=3)
axis(3, lwd=3, at=seq(-8, 8, 1), cex.axis=0.8, lwd.ticks=1)
mtext('Odds (Log2)', 3, line=2.5)
text(d$Odds_Ratio_log2, d$p_value, d$Name, pos=4, cex=0.7) yaxs='i' plot axes=F ?axis mtext ylab '' plot mtext('p-value', 2) segments text segments(-0.1, seq(0, 1, 0.1), 0, seq(0, 1, 0.1), lwd=2)
text(rep(0, 10), seq(0, 1, 0.1), seq(0, 1, 0.1), cex=0.7, pos=2) opar <- par(no.readonly = TRUE)
d <- data.frame(Name=LETTERS, Odds_Ratio_log2=runif(26, -8, 8), 
                p_value=runif(26))
plot(d$Odds_Ratio_log2, d$p_value, pch=20, xlim=c(-8, 8), ylim=c(0, 1),
     axes=F, xlab='', ylab='', yaxs='i', col='gray20')
abline(v=0, lwd=3)
axis(3, lwd=3, at=seq(-8, 8, 1), cex.axis=0.8, lwd.ticks=1)
mtext('Odds (Log2)', 3, line=2.5)
text(d$Odds_Ratio_log2, d$p_value, d$Name, pos=4, offset=0.3, cex=0.7)

par(xpd=NA)
segments(-0.1, seq(0.1, 0.9, 0.1), 0, seq(0.1, 0.9, 0.1), lwd=2)
text(rep(0, 10), seq(0.1, 0.9, 0.1), seq(0.1, 0.9, 0.1), 
     cex=0.7, pos=2, offset=0.3)
par(opar)
-------------------------------------------------------------------------------------------------------
h h v abline abline(v=mg,col="red")
-------------------------------------------------------------------------------------------------------
abline(0.22483, -0.07115)
-------------------------------------------------------------------------------------------------------
df1 <- data.frame(Response1=rnorm(100,0,1), Continuous=rnorm(100,0,1))
df2 <- data.frame(Response1=rnorm(100,0,1), Continuous=rnorm(100,0,1))
fit1 <- with(df1, lm(Response1 ~ Continuous))
with(df2, plot(Response1 ~ Continuous)) # plot df2 data
abline(coef(fit1)) # plot df1 model over it
-------------------------------------------------------------------------------------------------------
set.seed(1)
x <- runif(50)
y <- 2.5 + (3 * x) + rnorm(50, mean = 2.5, sd = 2)
dat <- data.frame(x = x, y = y) mod <- lm(y ~ x, data = dat) x res <- stack(data.frame(Observed = dat$y, Predicted = fitted(mod)))
res <- cbind(res, x = rep(dat$x, 2))
head(res) require("lattice")

xyplot(values ~ x, data = res, group = ind, auto.key = TRUE) xyplot(y ~ x, data = dat, type = c("p","r"), col.line = "red") xyplot(y ~ x, data = dat, col.line = "red",
       panel = function(x, y, ...) {
         panel.xyplot(x, y, ...)
         panel.abline(coef = coef(mod), ...) ## using mod from earlier
       }
      ) mod <- train(y ~ x, data = dat, method = "lm",
             trControl = trainControl(method = "cv"))

xyplot(y ~ x, data = dat, col.line = "red",
       panel = function(x, y, ...) {
         panel.xyplot(x, y, ...)
         panel.abline(coef = coef(mod$finalModel), ...) ## using mod from caret
       }
      )
-------------------------------------------------------------------------------------------------------
aes() colour='#E41A1C' +geom_abline(slope=-0.062712, intercept=0.165886,colour='#E41A1C')
-------------------------------------------------------------------------------------------------------
geom_abline(slope=-0.062712, intercept=0.165886,aes(colour='A')) +
  geom_abline(slope= -0.052300, intercept=-0.038691,aes(colour='B')) cc <- data.frame(sl = c(-0.062712,-0.052300), 
                  int = c(0.165886,-0.038691), 
                  Area = c('A','B')) map slope intercept colour geom_abline p <- ggplot(dat, aes(x=log(Explan), y=Response)) + 
    geom_point(aes(group=Area, colour=Area))+
    geom_abline(data = cc, aes(slope =sl, intercept = int,colour = Area)) +
    scale_x_continuous("log(Mass) (g)")+
    theme(axis.title.y=element_text(size=rel(1.2),vjust=0.2),
          axis.title.x=element_text(size=rel(1.2),vjust=0.2),
          axis.text.x=element_text(size=rel(1.3)),
          axis.text.y=element_text(size=rel(1.3)),
          text = element_text(size=13)) +
    scale_colour_brewer(palette="Set1")
p
-------------------------------------------------------------------------------------------------------
lm my[[12]] qplot lm(my[[8]]~my[[12]] plot lm lm plot x <- rnorm(100)
y <- rnorm(100)
plot(x,y)
abline(lm(y ~x)) plot plot(y ~ x)
abline(lm(y ~x))
-------------------------------------------------------------------------------------------------------
add.expr x  <- as.matrix(mtcars)
rc <- rainbow(nrow(x), start=0, end=.3)
cc <- rainbow(ncol(x), start=0, end=.3)
hv <- heatmap(x, col = cm.colors(256), scale="column",
               RowSideColors = rc, ColSideColors = cc, margin=c(5,10),
               xlab = "specification variables", ylab= "Car Models",
               main = "heatmap(<Mtcars data>, ..., scale = \"column\")",
               # IMPORTANT BIT HERE
               add.expr = abline(h=5, v=2))
-------------------------------------------------------------------------------------------------------
lm(dat[[4]]~dat[[3]])


Call:
lm(formula = dat[[4]] ~ dat[[3]])

Coefficients:
(Intercept)     dat[[3]]  
     -2e-01       -7e-06  

plot(dat[[3]],dat[[4]])
abline(coef(lm(dat[[4]]~dat[[3]])))
-------------------------------------------------------------------------------------------------------
xyplot(sepal.length ~ petal.width | iris.type, data = iris,
    panel = function( x,y,...) {
        panel.abline( h=y[ which(x==0.5) ], lty = "dotted", col = "black")
        panel.xyplot( x,y,...)
}) ... (h=y[ which(x %in% values) ] , ... which
-------------------------------------------------------------------------------------------------------
lattice panel function xyplot geom_point panel.abline geom_abline grid.polygon geom_polygon panel.loess stat_smooth panel.arrows geom_errobar panel.arrows(x.bar, ybar.hat$fit + ybar.hat$se.fit * 
      t.quant, x.bar, ybar.hat$fit - ybar.hat$se.fit * 
      t.quant, col = "darkgrey", length = 0.05, angle = 90, 
      code = 3) dat.arrow <- data.frame(x=x.bar, ymax= ybar.hat$fit + ybar.hat$se.fit * 
             t.quant, ymin= ybar.hat$fit - ybar.hat$se.fit * 
             t.quant)
 pl <- pl +  geom_errorbar(data=dat.arrow, aes(x,ymin=ymin,ymax=ymax),
              col = "darkgrey", width = 0.10) equivalence.ggplot equivalence.xyplot equivalence.ggplot <- function(x,y, alpha, b0.ii, b1.ii,
                               b0.absolute = FALSE,add.smooth=FALSE){
  x.bar <- mean(x, na.rm = TRUE)
  min.x <- min(x, na.rm = TRUE)
  max.x <- max(x, na.rm = TRUE)
  the.model <- lm(y ~ x)

  if (b0.absolute) 
    y.poly <- x.bar + b0.ii * c(-1, 1, 1, -1)
  else y.poly <- x.bar * (1 + b0.ii * c(-1, 1, 1, -1))
  dat.poly <- data.frame(x = c(min.x, min.x, max.x, max.x), 
                         y = y.poly)
  dat <- data.frame(x,y)
  p <- function(dat,dat.poly){
    h <- ggplot(dat) +
    geom_polygon(data=dat.poly,aes(x,y),col = "light gray", fill = gray(0.9)) +
    geom_point(aes(x,y)) +
    stat_smooth(data=dat,col='black',
                  aes(x=x,y=y),method="lm", se=FALSE,
                  fullrange =TRUE)+

    theme_bw()
    if (add.smooth) 
      h <- h +  geom_smooth(aes(x,y),method='loess')
    h
  }
  pl <- p(dat,dat.poly)

  n <- sum(complete.cases(cbind(x, y)))
  ybar.hat <- predict(the.model, newdata = data.frame(x = x.bar), 
                      se = TRUE)
  t.quant <- qt(1 - alpha/2, df.residual(the.model))
  dat.arrow <- data.frame(x=x.bar, ymax= ybar.hat$fit + ybar.hat$se.fit * 
                 t.quant, ymin= ybar.hat$fit - ybar.hat$se.fit * 
                 t.quant)
  pl <- pl + 
    geom_errorbar(data=dat.arrow, aes(x,ymin=ymin,ymax=ymax),
                  col = "darkgrey", width = 0.10)
  pl

  se.slope <- coef(summary(the.model))[2, 2]
  dat.arrow1 <- data.frame(x=x.bar, ymax=  ybar.hat$fit + se.slope * t.quant * 
                             x.bar, ymin=ybar.hat$fit - se.slope * t.quant * 
                             x.bar)

  pl <- pl + 
    geom_errorbar(data=dat.arrow1, aes(x,ymin=ymin,ymax=ymax),
                  col = "black", width = 0.10)
  addLines <- function(pl,the.model){
  pl <- pl + geom_abline(intercept = coef(summary(the.model))[1, 1], slope = 1 - 
                 b1.ii, col = "darkgrey", lty = 2) + 
    geom_abline(intercept = coef(summary(the.model))[1, 1], slope = 1 + 
                 b1.ii, col = "darkgrey", lty = 2)  
  }
  pl <- addLines(pl,the.model)
  pl

} library(gridExtra)
p.gg  <- equivalence.ggplot(mydata$x,mydata$y,alpha=0.05, b0.ii=0.25, b1.ii=0.25)
p.lat <- equivalence.xyplot(mydata$y~mydata$x,alpha=0.05, b0.ii=0.25, b1.ii=0.25)
grid.arrange(p.gg,p.lat)
-------------------------------------------------------------------------------------------------------
x <- qnorm(seq(0,1,l=1002))  # Theoretical normal quantiles
x <- x[-c(1, length(x))]  # Drop ends because they are -Inf and Inf
y <- rnorm(1000)  # Actual data. 1000 points drawn from a normal distribution
l.1 <- lm(sort(y)~sort(x))
qqplot(x, y, xlab="Theoretical Quantiles", ylab="Actual Quantiles")
abline(coef(l.1)[1], coef(l.1)[2])
-------------------------------------------------------------------------------------------------------
plot.spei plot.spei <- 
function (x, ...) 
{
    ## label <- ifelse(as.character(x$call)[1] == "spei", "SPEI", 
    ##     "SPI")

    ser <- ts(as.matrix(x$fitted[-c(1:x$scale), ]), end = end(x$fitted), 
        frequency = frequency(x$fitted))
    ser[is.nan(ser - ser)] <- 0
    se <- ifelse(ser == 0, ser, NA)
    tit <- dimnames(x$coefficients)[2][[1]]
    if (start(ser)[2] == 1) {
        ns <- c(start(ser)[1] - 1, 12)
    }
    else {
        ns <- c(start(ser)[1], start(ser)[2] - 1)
    }
    if (end(ser)[2] == 12) {
        ne <- c(end(ser)[1] + 1, 1)
    }
    else {
        ne <- c(end(ser)[1], end(ser)[2] + 1)
    }
    n <- ncol(ser)
    if (is.null(n)) 
        n <- 1
    par(mar = c(4, 4, 2, 1) + 0.1)
    if (n > 1 & n < 5) 
        par(mfrow = c(n, 1))
    if (n > 1 & n >= 5) 
        par(mfrow = c({
            n + 1
        }%/%2, 2))
    for (i in 1:n) {
        datt <- ts(c(0, ser[, i], 0), frequency = frequency(ser), 
            start = ns, end = ne)
        datt.pos <- ifelse(datt > 0, datt, 0)
        datt.neg <- ifelse(datt <= 0, datt, 0)
        plot(datt, type = "n", xlab = "", main = tit[i], ...)
        if (!is.null(x$ref.period)) {
            k <- ts(5, start = x$ref.period[1, ], end = x$ref.period[2, 
                ], frequency = 12)
            k[1] <- k[length(k)] <- -5
            polygon(k, col = "light grey", border = NA, density = 20)
            abline(v = x$ref.period[1, 1] + (x$ref.period[1, 2] - 1)/12, col = "grey")
            abline(v = x$ref.period[2, 1] + (x$ref.period[2, 2] - 1)/12, col = "grey")
        }
        grid(col = "black")
        polygon(datt.pos, col = "blue", border = NA)
        polygon(datt.neg, col = "red", border = NA)
        lines(datt, col = "dark grey")
        abline(h = 0)
        points(se, pch = 21, col = "white", bg = "black")
    }
} ylab plot(spi1, ylab = "SPI") ts par(mfrow = c(3, 4))
listofmonths <- split(fitted(spi1), cycle(fitted(spi1)))
names(listofmonths) <- month.abb

require(plyr)
l_ply(seq_along(listofmonths), function(x) {
       plot(x = seq_along(listofmonths[[x]]), y = listofmonths[[x]],
            type = "l", xlab = "", ylab = "SPI")
       title(names(listofmonths)[x])
   }) monthplot(fitted(spi1), labels = month.abb, cex.axis = 0.8)
boxplot(fitted(spi1) ~ cycle(fitted(spi1)), names = month.abb, cex.axis = 0.8)
-------------------------------------------------------------------------------------------------------
predict tail # Sample data
library(quantmod)
getSymbols("^GSPC", from="2009-01-01")

# Rolling regression (unweighted), with prediction intervals
x <- rollapplyr( 
  as.zoo(Ad(GSPC)), 
  width=300, by.column = FALSE, 
  FUN = function(x) {
    r <- lm( x ~ index(x) )
    tail(predict(r, interval="prediction"),1)
  } 
)

# Plots
plot( index(GSPC), Ad(GSPC), type="l", lwd=3, las=1 )
lines( index(x), x$fit, col="purple", lwd=3 )
lines( index(x), x$lwr, col="purple", lwd=3, lty=3 )
lines( index(x), x$upr, col="purple", lwd=3, lty=3 )
abline( lm( Ad(GSPC) ~ index(GSPC) ), col="light blue", lwd=3 )
-------------------------------------------------------------------------------------------------------
my_line <- function(x,y,...){
    points(x,y,...)
    abline(a = 0,b = 1,...)
}
pairs(USJudgeRatings, lower.panel = my_line, upper.panel = panel.cor)
-------------------------------------------------------------------------------------------------------
axis x = sin(1:100) + rnorm(100, 0,.125)
breaks = c(10,33,85, 96)

plot(x)
sapply(breaks, function(x){abline(v=x, lty=2)})
axis(1, breaks, as.character(breaks)) plot(x, axes=F)
sapply(breaks, function(x){abline(v=x, lty=2)})
axis(1, breaks, as.character(breaks))
axis(2)
box()
-------------------------------------------------------------------------------------------------------
lin <- data.frame(x = c(0:6), y = c(0.3, 0.1, 0.9, 3.1, 5, 4.9, 6.2))
linm <- lm(y ~ x, data = lin, subset = 2:4)
plot(y ~ x, data = lin)
abline(linm)
rect(0,0,3,3, col=rgb(.5,.5,.5,.5),border=NA)
-------------------------------------------------------------------------------------------------------
ylim xlim c(0, 3) op <- par(no.readonly = TRUE)

lin <- data.frame(x = c(0:6), y = c(0.3, 0.1, 0.9, 3.1, 5, 4.9, 6.2))
linm <- lm(y ~ x, data = lin, subset = 2:4)
plot(y ~ x, data = lin)
abline(linm)

par(new=TRUE, oma=c(3,1,1,2))
layout(matrix(1:4,2))

lin <- data.frame(x = c(0:6), y = c(0.3, 0.1, 0.9, 3.1, 5, 4.9, 6.2))
linm <- lm(y ~ x, data = lin, subset = 2:4)
plot(y ~ x, data = lin, ylim=c(0,3), xlim=c(0, 3))
abline(linm)

par(op)
-------------------------------------------------------------------------------------------------------
lm(log(counts) ~ log(x)) plot(log(counts) ~ log(x))
abline(reg=lm(log(counts) ~ log(x)))
-------------------------------------------------------------------------------------------------------
dlist <- lapply ( ls(patt='^data'), get)
lapply(dlist, function(df) 
                 plot(NA, xlim=range(df$variable), ylim=range(df$response)
                 abline( coef( lm(response ~ variable, data=df) ) )
         ) names(dlist) <- paste("data", i, sep = "")
-------------------------------------------------------------------------------------------------------
fmla = lm(log(datatest$ERmammal_0_1)~log(datatest$MEAN_intact_for)) abline(a = fmla$coefficients[1], b = fmla$coefficients[2])
-------------------------------------------------------------------------------------------------------
abline(h=summary(a)[1])  # ........ abline(h=min(a) ) abline( h=boxplot.stats$stats[1] )
-------------------------------------------------------------------------------------------------------
boxplot b <- boxplot(a,ylim=c(-5,15))
abline(h=b$stats[1,],col="red")
abline(h=b$stats[5,],col="red")
-------------------------------------------------------------------------------------------------------
lin <- data.frame(x = c(0:6), y = c(0.3, 0.1, 0.9, 3.1, 5, 4.9, 6.2))
linm <- lm(y ~ x, data = lin, subset = 2:4)
plot(y ~ x, data = lin)
abline(linm)
## to overlap the 2 plots
par(new=TRUE, oma=c(3,1,1,2))
## create a layout to plot the subplot in the right bottom corner
layout(matrix(1:4,2))
## use xlim and ylim to zoom the subplot
plot(y ~ x, data = lin,xlim=c(0,2), ylim=c(0,2))
abline(linm)
-------------------------------------------------------------------------------------------------------
forest.default() addpoly() forest(dm$logor, ci.lb=log(dm$cill), ci.ub=log(dm$ciul), atransf=exp, rows=7:3, ylim=c(.5,10))
addpoly(dmres, row=1, atransf=exp)
abline(h=2)
-------------------------------------------------------------------------------------------------------
plot(density(data), xlim=range(c(data, estimate+10) ) )
abline(v = estimate, col='red')
-------------------------------------------------------------------------------------------------------
library(plotrix)

d <- density(data)
gap.plot(c(-8000,d$x), c(0,d$y), gap=range(c(-7990,-3620)), 
         gap.axis="x", type="l", xlab="x", ylab="Density", 
         xtics=c(-8000,seq(-3600,-3300,by=100)))
abline(v=-8000, col="red", lwd=2)
-------------------------------------------------------------------------------------------------------
myplot <- xyplot(noOfInst ~ instSize, data = inst, 
                 type = "h", col = "blue",
                 xlab = "Instance Size (Number of Aircraft)",
                 ylab = "Number Of Instances",
                 scales=list(
                   y=list(
                     at=seq(0,150,10),
                     labels=seq(0,150,10) ),
                   x=list(
                     at=seq(10,27,1),
                     labels=seq(10,27,1) )
                 ),
                 panel=function(...){
                   panel.abline(h=seq(0,150,10))
                   panel.xyplot(...)
                 }
) col panel.abline()
-------------------------------------------------------------------------------------------------------
myplot <- xyplot(noOfInst ~ instSize, data = inst, 
             type = c("h"), col = "blue",
             xlab = "Instance Size (Number of Aircraft)",
             ylab = "Number Of Instances",
             panel=function(...){
               panel.abline(h=seq(0,150,10),col="grey")
               panel.xyplot(...)
             },
             scales=list(
               y=list(
                 at=seq(0,150,10),
                 labels=seq(0,150,10) ),
               x=list(
                 at=seq(10,27,1),
                 labels=seq(10,27,1) )
             )
             )
-------------------------------------------------------------------------------------------------------
?grid abline plot(as.Date(data[["Date"]]), -data[["dbns"]], type="l")
grid(NA,NULL,lwd=3)
v <- as.numeric(as.Date(paste0(c(1970,1980,1990,2000,2010),'-01-01')))
abline(v = v,lty = "dotted",col = "lightgray",lwd = 3)
-------------------------------------------------------------------------------------------------------
Axis.Date Date par('xaxp') grid # assuming your data is called DD
DD$Date <- as.Date(as.character(DD$Date), format = '%d/%m/%Y')
# don't plot the x axis (xaxt = 'n')
plot(-dbns~Date,data = DD[order(DD$Date),], type="l", xaxt = 'n')
# create the axis and  save the tick locations
at <- as.numeric(Axis(side = 1, x = DD$Date))
grid(NA,NULL,lwd=3)
abline(v = at,lty = "dotted",col = "lightgray",lwd = 3)
-------------------------------------------------------------------------------------------------------
... bwplot(coef ~ habitat, data = res, panel=function(...) {
    panel.abline(h=0, col="green")
    panel.bwplot(...)
}) res = data.frame(coef=rnorm(99) + (-1):1, habitat=sample(letters[1:3], 99, TRUE),
                 grp=c("W", "X", "Y"))
bwplot(coef ~ habitat | grp, data = res, panel=function(x, y, ...) {
    ## green line at panel-median y value
    panel.abline(h=median(y), col="green")
    panel.bwplot(x, y, ...)
})
-------------------------------------------------------------------------------------------------------
Error in savePlot(paste0("file_", f), "png") : 
  can only copy from 'windows' devices png("file_%03d.png")
for (f in unique(df$month)) {
  p = bwplot(x ~ country|type, data = df[df$month == f,], panel=function(...) {
    panel.abline(h=0, col="green")
    panel.bwplot(...)
  })
  print(p)
}
dev.off()
-------------------------------------------------------------------------------------------------------
#Example Data
n = 6
time02H = abs(rnorm(n))
time06H = abs(rnorm(n))
time24H = abs(rnorm(n))

allPAL.DE = data.frame(time02H,time06H,time24H)

plot(0,0,xlab="Time",ylab="Values",type="n",xlim=c(0,2),ylim=c(min(allPAL.DE,0),max(allPAL.DE)),axes="FALSE")
box()
axis(1,0:2,c("time02H","time06H","time24H"))
axis(2)
abline(h=0,col="grey",lty=2,lwd=2)

for(i in 1:nrow(allPAL.DE)){
    lines(0:2,allPAL.DE[i,],col=i,lwd=2)
}
-------------------------------------------------------------------------------------------------------
abline plot(1:10, 1:10,xlim=c(0,10), ylim=c(0,10))
sapply(seq(0,20,by=2), function(a) abline(a=a, b=-1,lty=3,col="red"))
sapply(seq(-10,10,by=2), function(a) abline(a,b=1,lty=3,col="red")) angle=pi/8; rot=tan(angle); backrot=tan(angle+pi/2)
sapply(seq(-10,10,by=2), function(inter) abline(a=inter, b=rot,lty=3,col="red"))
sapply(seq(0,40,by=2), function(inter) abline(a=inter, b=backrot, lty=3,col="red")) 
grid segments lines plot(1:10, 1:10,xlim=c(0,10), ylim=c(0,10)); angle=pi/8; rot=tan(angle);backrot=tan(angle+pi/2)
x0y0 <- matrix( c(rep(-20,41), -20:20), 41)
x1y1 <- matrix( c(rep(20,41), -20:20), 41)
# The rot function will construct a rotation matrix
rot <- function(theta) matrix(c( cos( theta ) , sin( theta ) ,
 -sin( theta ), cos( theta ) ), 2)
# Leave origianal set of point untouched but create rotated version
 rotx0y0 <- x0y0%*%rot(pi/8)
 rotx1y1 <- x1y1%*%rot(pi/8)
 segments(rotx0y0[,1] ,rotx0y0[,2], rotx1y1[,1], rotx1y1[,2], col="blue")
# Use originals again, ... or could write to rotate the new points
 rotx0y0 <- x0y0%*%rot(pi/8+pi/2)
 rotx1y1 <- x1y1%*%rot(pi/8+pi/2)
 segments(rotx0y0[,1] ,rotx0y0[,2], rotx1y1[,1], rotx1y1[,2], col="blue")
-------------------------------------------------------------------------------------------------------
x0 <- numeric()
object.size(x0)
# 40 bytes typeof() sizes <- sapply(0:50, function(n) object.size(seq_len(n)))
plot(c(0, 50), c(0, max(sizes)), xlab = "Length", ylab = "Bytes", 
  type = "n")
abline(h = 40, col = "grey80")
abline(h = 40 + 128, col = "grey80")
abline(a = 40, b = 4, col = "grey90", lwd = 4)
lines(sizes, type = "s") sizes - 40
#  [1]   0   8   8  16  16  32  32  32  32  48  48  48  48  64  64  64  64 128 128 128 128
# [22] 128 128 128 128 128 128 128 128 128 128 128 128 136 136 144 144 152 152 160 160 168
# [43] 168 176 176 184 184 192 192 200 200 # diff(sizes)
#  [1]  8  0  8  0 16  0  0  0 16  0  0  0 16  0  0  0 64  0  0  0  0  0  0  0  0  0  0  0
# [29]  0  0  0  0  8  0  8  0  8  0  8  0  8  0  8  0  8  0  8  0  8  0 xv <- numeric()
xm <- matrix(xv)

object.size(xm)
# 200 bytes

object.size(xm) - object.size(xv)
# 160 bytes list() object.size(pairlist(dims = c(1L, 1L)))
# 160 bytes msizes <- sapply(0:50, function(n) object.size(as.matrix(seq_len(n))))
plot(c(0, 50), c(160, max(msizes)), xlab = "Length", ylab = "Bytes", 
  type = "n")
abline(h = 40 + 160, col = "grey80")
abline(h = 40 + 160 + 128, col = "grey80")
abline(a = 40 + 160, b = 4, col = "grey90", lwd = 4)
lines(msizes, type = "s")
-------------------------------------------------------------------------------------------------------
heatmap.2(xx,
       add.expr=eval( abline(v=linePosition, lwd=3)))
-------------------------------------------------------------------------------------------------------
ggplot(ex, aes(x=x, y=y)) + geom_point() + 
  geom_abline(slope=1, intercept=0) +
  facet_wrap(~f) geom_point()
-------------------------------------------------------------------------------------------------------
singer bwplot(height~voice.part, singer) scales=list(y=list(at=c(250, 750, 1500)) ?bwplot at scales at <- seq(60, 75, 2.5)
bwplot(height~voice.part, singer, scales=list(y=list(at=at))) panel.abline panel.bwplot ?panel.bwplot grid ?bwplot at bwplot(height~voice.part, singer, scales=list(y=list(at=at)),
       panel=function(...) {
           panel.abline(h=at, col="gray")
           panel.bwplot(...)
       }) ?panel.bwplot fill fill lvls <- levels(singer$voice.part)
fill <- rep("white", length(lvls))
fill[lvls %in% c("Tenor 1", "Tenor 2")] <- "gray" bwplot(height~voice.part, singer, scales=list(y=list(at=at)),
       fill=fill, panel=function(...) {
           panel.abline(h=at, col="gray")
           panel.bwplot(...)
       })
-------------------------------------------------------------------------------------------------------
# Generate an artificial dataset
library(MASS)
set.seed(1)

# Suitably chosen covariance matrix
covariancematrix <- matrix(c(0.02,0.019,0.019,0.02), nrow=2)
#> print(cov2cor(covariancematrix))
#     [,1] [,2]
#[1,] 1.00 0.95
#[2,] 0.95 1.00

# Randomize 20,000 observations and constraint them to a p-value like range
pvalues <- mvrnorm(20000, mu=c(0.5,0.5), Sigma=covariancematrix)
colnames(pvalues) <- c("p value condition 1", "p value condition 2")
rownames(pvalues) <- paste("Probe/gene id", 1:20000)
# p-values should be within range [0,1]
pvalues[pvalues<0] <- 0
pvalues[pvalues>1] <- 1

#> str(pvalues)
# num [1:20000, 1:2] 0.461 0.54 0.52 0.518 0.61 ...
# - attr(*, "dimnames")=List of 2
#  ..$ : chr [1:20000] "Probe/gene id 1" "Probe/gene id 2" "Probe/gene id 3" "Probe/gene id 4" ...
#  ..$ : chr [1:2] "p value condition 1" "p value condition 2"
#> head(pvalues)
#                p value condition 1 p value condition 2
#Probe/gene id 1           0.4614707           0.4767356
#Probe/gene id 2           0.5398754           0.5583752
#Probe/gene id 3           0.5196980           0.5251556
#Probe/gene id 4           0.5182167           0.4471374
#Probe/gene id 5           0.6097540           0.5745387
#Probe/gene id 6           0.4652409           0.3940416

# The plotting call itself
plot(   # If this is a 2-column matrix, then first column pvalues[,1] will be by default the x-axis and second column pvalue[,2] the y-axis
    # Can be a matrix with 2 columns or a data.frame with 2 columns
    x = pvalues, 
    # Analogous if you have two separated vectors instead of two columns, change to something like:
    # x = pvalues[,1], # x-axis observation values
    # y = pvalues[,2], # y-axis observation values
    # x- and y-axis ranges [0,1]
    xlim=c(0,1), 
    ylim=c(0,1), 
    # Select filled dots as the symbols
    pch=16, 
    # Conditional color vector based on where the observation is located
    col=apply(pvalues, MARGIN=1, FUN=function(x) { ifelse(1*x[1] +0.05 > x[2] & 1*x[1] -0.05 < x[2], 
        # Color for dots inside the area (semi-transparent black)
        "#00000075", 
        # Color for dots outside the area (semi-transparent blue)
        "#0000FF75") 
        } ),
    # Axis labels
    xlab="p values in differences condition 1", 
    ylab="p values in differences condition 2"
    )
# Draw the lines, formula:
# y = 1*x + 0.05
abline(a=0.05, b=1, col="red", lwd=2)
# y = 1*x - 0.05
abline(a=-0.05, b=1, col="red", lwd=2)
-------------------------------------------------------------------------------------------------------
xaxt = "n" yaxt = "n" box grid month.name seq.int x <- matrix(
  c(
    200, 227, 196, 
    210, 279, 319, 
    220, 126, 111,
    230, 196, 123,
    240, 106, 94,
    250, 154, 233,
    260, 226, 218
  ),
  nrow = 3,
  ncol = 7
)
colnames(x) <- month.name[c(11:12, 1:5)]
rownames(x) <- c("Hornberg", "Strick", "Huetten")


par(mar = c(5, 4, 1.5, 0.5), ps = 12, cex  = 1, cex.main = 2, las = 1)

barplot(
  x, 
  beside      = TRUE, 
  ylim        = c(0,350),
  xlab        = "Month", 
  axes        = TRUE,
  axis.lty    = 1, 
  ylab        = "Monthly Precipitation [mm]",
  col         = c("darkblue", "dodgerblue3", "deepskyblue1"),
  panel.first =  abline(
    h    =  seq.int(50, 300, 50), 
    col  =  "grey", 
    lty  =  2
  )
)
box()
grid()
-------------------------------------------------------------------------------------------------------
plot(v2, type="l", col="darkblue", lwd=2)
# v2 <- smooth(v2, kind="3")  # optional
lines(v2, lwd=1, col="red")
d2 <- diff(v2)
d2 <- d2>0
d2 <- d2*2 -1 
k <- 5
cutoff <- 10
scores <- sapply(k:(length(d2)-k), FUN=function(i){
  score <- abs(mean(-d2[ i-1:k ], na.rm=T) + mean(d2[ i+0:k ], na.rm=T))
})


scores <- sapply(k:(length(v2)-k), FUN=function(i){
  left <- (v2[sapply(i-1:k, max, 1) ]<v2[i])*2-1
  right <- (v2[sapply(i+1:k, min, length(v2)) ]<v2[i])*2-1

  score <- abs(sum(left) + sum(right))
})

inflections <- (k:(length(v2)-k))[scores>=cutoff]

plot(v2, type="l")
abline(v=inflections, col="red", lwd=3)
print(inflections) #  6 11 18 25 32 (missed 51, if you make cutoff=8 it'll catch it...)
-------------------------------------------------------------------------------------------------------
# here I'm generating some example data
set.seed(5)
topic_list1 <- paste(sample(letters, 20, replace=T), sep=";")
topic_list2 <- paste(sample(letters, 15, replace=T), sep=";")

# I don't make the tables right away
tl1      <- unlist(strsplit(topic_list1, split=";"))
tl2      <- unlist(strsplit(topic_list2, split=";"))
big_list <- unique(c(tl1, tl2))

# this computes your frequencies
lbl         <- length(big_list)
tMat1       <- matrix(rep(tl1, lbl), byrow=T, nrow=lbl)
tMat2       <- matrix(rep(tl2, lbl), byrow=T, nrow=lbl)
tMat1       <- cbind(big_list, tMat1)
tMat2       <- cbind(big_list, tMat2)
counts1     <- apply(tMat1, 1, function(x){sum(x[1]==x[2:length(x)])})
counts2     <- apply(tMat2, 1, function(x){sum(x[1]==x[2:length(x)])})
total_freqs <- rbind(counts1, counts2, counts1-counts2)

# this makes it nice looking & user friendly
colnames(total_freqs) <- big_list
rownames(total_freqs) <- c("topics1", "topics2", "difference")
total_freqs           <- total_freqs[ ,order(total_freqs[3,])]
total_freqs
            d  l  a  z  b f s y m r x h n i g k c v o
topics1     0  0  0  0  0 2 1 1 1 1 2 2 1 1 1 1 2 2 2
topics2     2  2  2  1  1 2 1 1 1 0 1 1 0 0 0 0 0 0 0
difference -2 -2 -2 -1 -1 0 0 0 0 1 1 1 1 1 1 1 2 2 2 windows()
  dotchart(t(total_freqs)[,3], main="Frequencies of topics1 - topics2")
  abline(v=0)
-------------------------------------------------------------------------------------------------------
segmented n psi=NA K=n # example data:
bullard <- structure(list(Rt = c(5.1861, 10.5266, 11.6688, 19.2345, 59.2882, 
68.6889, 320.6442, 340.4545, 479.3034, 482.6092, 484.048, 485.7009, 
486.4204, 488.1337, 489.5725, 491.2254, 492.3676, 493.2297, 494.3719, 
495.2339, 496.3762, 499.6819, 500.253, 501.1151, 504.5417, 505.4038, 
507.6278, 508.4899, 509.6321, 522.1321, 524.4165, 527.0027, 529.2871, 
531.8733, 533.0155, 544.6534, 547.9592, 551.4075, 553.0604, 556.9397, 
558.5926, 561.1788, 562.321, 563.1831, 563.7542, 565.0473, 566.1895, 
572.801, 573.9432, 575.6674, 576.2385, 577.1006, 586.2382, 587.5313, 
589.2446, 590.1067, 593.4125, 594.5547, 595.8478, 596.99, 598.7141, 
599.8563, 600.2873, 603.1429, 604.0049, 604.576, 605.8691, 607.0113, 
610.0286, 614.0263, 617.3321, 624.7564, 626.4805, 628.1334, 630.9889, 
631.851, 636.4198, 638.0727, 638.5038, 639.646, 644.8184, 647.1028, 
647.9649, 649.1071, 649.5381, 650.6803, 651.5424, 652.6846, 654.3375, 
656.0508, 658.2059, 659.9193, 661.2124, 662.3546, 664.0787, 664.6498, 
665.9429, 682.4782, 731.3561, 734.6619, 778.1154, 787.2919, 803.9261, 
814.335, 848.1552, 898.2568, 912.6188, 924.6932, 940.9083), Tem = c(12.7813, 
12.9341, 12.9163, 14.6367, 15.6235, 15.9454, 27.7281, 28.4951, 
34.7237, 34.8028, 34.8841, 34.9175, 34.9618, 35.087, 35.1581, 
35.204, 35.2824, 35.3751, 35.4615, 35.5567, 35.6494, 35.7464, 
35.8007, 35.8951, 36.2097, 36.3225, 36.4435, 36.5458, 36.6758, 
38.5766, 38.8014, 39.1435, 39.3543, 39.6769, 39.786, 41.0773, 
41.155, 41.4648, 41.5047, 41.8333, 41.8819, 42.111, 42.1904, 
42.2751, 42.3316, 42.4573, 42.5571, 42.7591, 42.8758, 43.0994, 
43.1605, 43.2751, 44.3113, 44.502, 44.704, 44.8372, 44.9648, 
45.104, 45.3173, 45.4562, 45.7358, 45.8809, 45.9543, 46.3093, 
46.4571, 46.5263, 46.7352, 46.8716, 47.3605, 47.8788, 48.0124, 
48.9564, 49.2635, 49.3216, 49.6884, 49.8318, 50.3981, 50.4609, 
50.5309, 50.6636, 51.4257, 51.6715, 51.7854, 51.9082, 51.9701, 
52.0924, 52.2088, 52.3334, 52.3839, 52.5518, 52.844, 53.0192, 
53.1816, 53.2734, 53.5312, 53.5609, 53.6907, 55.2449, 57.8091, 
57.8523, 59.6843, 60.0675, 60.8166, 61.3004, 63.2003, 66.456, 
67.4, 68.2014, 69.3065)), .Names = c("Rt", "Tem"), class = "data.frame", row.names = c(NA, 
-109L))


library(segmented)  # Version: segmented_0.2-9.4

# create a linear model
out.lm <- lm(Tem ~ Rt, data = bullard)

# Set X breakpoints: Set psi=NA and K=n:
o <- segmented(out.lm, seg.Z=~Rt, psi=NA, control=seg.control(display=FALSE, K=3))
slope(o)  # defaults to confidence level of 0.95 (conf.level=0.95)

# Trickery for placing text labels
r <- o$rangeZ[, 1]
est.psi <- o$psi[, 2]
v <- sort(c(r, est.psi))
xCoord <- rowMeans(cbind(v[-length(v)], v[-1]))
Z <- o$model[, o$nameUV$Z]
id <- sapply(xCoord, function(x) which.min(abs(x - Z)))
yCoord <- broken.line(o)[id]

# create the segmented plot, add linear regression for comparison, and text labels
plot(o, lwd=2, col=2:6, main="Segmented regression", res=TRUE)
abline(out.lm, col="red", lwd=1, lty=2)  # dashed line for linear regression
text(xCoord, yCoord, 
    labels=formatC(slope(o)[[1]][, 1] * 1000, digits=1, format="f"), 
    pos = 4, cex = 1.3)
-------------------------------------------------------------------------------------------------------
par(mfrow=c(1, length(levels(A))))
for (day in levels(A)){
  subs <- subset(data, A==day)
  plot(subs$C, subs$B, main=day)
  abline(lm(C~B), col="red")  
} xlim ylim
-------------------------------------------------------------------------------------------------------
?predict.survreg predict lfit <- survreg(Surv(time, status) ~ ph.ecog, data=lung)
pct <- 1:98/100   # The 100th percentile of predicted survival is at +infinity
ptime <- predict(lfit, newdata=data.frame(ph.ecog=2), type='quantile',
                 p=pct, se=TRUE)
matplot(cbind(ptime$fit, ptime$fit + 2*ptime$se.fit,
                          ptime$fit - 2*ptime$se.fit)/30.5, 1-pct,
         xlab="Months", ylab="Survival", type='l', lty=c(1,2,2), col=1)
 # The plot should be examined since you asked for a median survival time
 abline(h= 0.5)
 # You can  drop a vertical from the intersection to get that graphically str(ptime)
List of 2
 $ fit   : num [1:98] 9.77 16.35 22.13 27.46 32.49 ...
 $ se.fit: num [1:98] 2.39 3.53 4.42 5.16 5.82 ... ptime$fit[which((1-pct)==0.5)]
# [1] 221.6023
-------------------------------------------------------------------------------------------------------
box.rectangle box.umbrella names(trellis.par.get()) thickBoxSettings <- list(box.rectangle=list(lwd=2), box.umbrella=list(lwd=2))

bwplot(x ~ type|month, data = df, 
       par.settings = thickBoxSettings,
       panel = function(...) {
           panel.abline(h=0, col="green")
           panel.bwplot(...)
       })
-------------------------------------------------------------------------------------------------------
myBW <- bwplot(x ~ type|month, data = df, panel=function(...) {
    panel.abline(h=0, col="green")
    panel.bwplot(...)
})
newBW <- update(myBW, par.settings=list(box.rectangle=list(lwd=4) ))
plot(newBW)   # need to print or plot a grid object trellis.focus
-------------------------------------------------------------------------------------------------------
# Make a fake dataset since it is inconvenient to copy & paste the data you show
set.seed(13)
False <- rnorm(10, mean=50, sd=10)
True <- rnorm(10, mean=50, sd=10)
MotifId <- letters[1:10]
Dataset <- data.frame(False, True, MotifId) Dataset$stderr <- 7 # This will recycle to the number of rows of Dataset arrow plot(Dataset$True,Dataset$False, 
     xlim=c(0,100), ylim=c(0,100), 
     main="Average % of disorder", 
     xlab="True", ylab="False", 
     pch=19,col= "blue")
text(Dataset$True,Dataset$False, 
     labels=Dataset$MotifId, 
     cex= 0.7, pos=3)
abline(0,1)
arrows(x0=Dataset$True, y0=Dataset$False - Dataset$stderr, 
       x1=Dataset$True, y1=Dataset$False + Dataset$stderr, 
       angle=90, code=3, length=0.05) ggplot2 require(ggplot2)
# Build the plot from layers 
p <- ggplot(Dataset, aes(x=True, y=False, label=MotifId)) + 
       geom_point() + 
       geom_text(, vjust=1, hjust=1) +
       geom_errorbar(aes(ymin=False-stderr, ymax=False+stderr), width=1) +
       geom_abline(slope=1, intercept=0) +
       xlim(c(0, 100)) +
       ylim(c(0, 100)) +
       ggtitle("Average % of disorder") +
       theme_bw()
print(p)
-------------------------------------------------------------------------------------------------------
> corperm = function(A,B,1000) {
Error: unexpected numeric constant in "corperm = function(A,B,1000" > corperm <- function(A, B, n=1000) {
# etc obs = abs(cor(A,B))
tmp = sapply(1:n,function(z) {abs(cor(sample(A,replace=TRUE),B))})
return(1-sum(obs>tmp)/n) corperm <- function(x, y, N=1000, plot=FALSE){
    reps <- replicate(N, cor(sample(x), y))
    obs <- cor(x,y)
    p <- mean(obs > reps) # shortcut for sum(obs>reps)/N
    if(plot){
        hist(reps)
        abline(v=obs, col="red")
        }
     p
     } corperm(A[,1], B[,1]) for mapply for mapply res <- matrix(NA, nrow=NCOL(A), ncol=NCOL(B))
for(iii in 1:3) for(jjj in 1:3) res[iii,jjj] <- corperm(A[,iii], B[,jjj], plot=FALSE)
rownames(res)<-names(A)
colnames(res) <- names(B)
print(res)
-------------------------------------------------------------------------------------------------------
entex <- function(x,uplim,lwlim) {

  result <- vector("integer",0)
  upr <- which(x>=uplim)
  lwr <- which(x<=lwlim)

  while(length(upr) > 0) {
    if(min(upr) > max(lwr)) {
      result <- unique(c(result,upr))
      upr <- upr[upr > max(result)]
    } else
    {
      result <- unique(c(result,upr[1]:(min(lwr[lwr>upr[1]])-1)))
      lwr <- lwr[lwr > max(result)]
      upr <- upr[upr > max(result)]
    }
  }
  result
} plot(x,pch=19,type="o")
abline(h=c(0,5),col="lightblue")
result <- entex(x,5,0)
abline(v=result,col="red") x x <- c(-0.6, -0.3, 0.5, 0.6, 3, 4.1, 6.7, 3.7, 7.5, 4.1, 6.8, 4.8, 3.3,
       1.6, 3.1, 2, 1.3, 2.9, 2.8, 1.9, 0, -0.5, -0.6, 0.3, 1.9, 5.1, 6.4)
-------------------------------------------------------------------------------------------------------
# Define function for ploting
example <- function(...){
  plot(cars)
  i <- 1
  for (my.control in list(...)) {
    if (my.control) abline(0, i)
    i <- i+1
  }
}

# Define your controls
custom.args <- list()
for (i in 1:5) {
  custom.args <- append(custom.args, list(checkbox(FALSE, paste("Ceckbox", i))))
}
names(custom.args) <- paste("checkbox", 1:5, sep="")

# Pass everything to manipulate
library(manipulate)
manipulate(
  eval(parse(text=sprintf('example(%s)', 
                          paste(names(custom.args), collapse=","))
             )),
  custom.args)
-------------------------------------------------------------------------------------------------------
x <- rnorm(100)
y<- rchisq(100,1)
plot(x,y, xlim=c(-3.5,3.5))
abline(v= c(-1.96, 1.96), col='red')
abline(h= 3.84, col='red')
text(x[ abs(x) > 2|y > 3.8], y[abs(x) > 2|y > 3.8]+.15, 
        paste0("(",round(x[ abs(x) > 2|y > 3.8],1), " , ", 
                   round(y[ abs(x) > 2|y > 3.8],1),
                ")" ) )
-------------------------------------------------------------------------------------------------------
true_Y = c(1,1,1,1,2,1,2,1,2,2)
probs = c(1,0.999,0.999,0.973,0.568,0.421,0.382,0.377,0.146,0.11)

getROC_AUC = function(probs, true_Y){
    probsSort = sort(probs, decreasing = TRUE, index.return = TRUE)
    val = unlist(probsSort$x)
    idx = unlist(probsSort$ix)  

    roc_y = true_Y[idx];
    stack_x = cumsum(roc_y == 2)/sum(roc_y == 2)
    stack_y = cumsum(roc_y == 1)/sum(roc_y == 1)    

    auc = sum((stack_x[2:length(roc_y)]-stack_x[1:length(roc_y)-1])*stack_y[2:length(roc_y)])
    return(list(stack_x=stack_x, stack_y=stack_y, auc=auc))
}

aList = getROC_AUC(probs, true_Y) 

stack_x = unlist(aList$stack_x)
stack_y = unlist(aList$stack_y)
auc = unlist(aList$auc)

plot(stack_x, stack_y, type = "l", col = "blue", xlab = "False Positive Rate", ylab = "True Positive Rate", main = "ROC")
axis(1, seq(0.0,1.0,0.1))
axis(2, seq(0.0,1.0,0.1))
abline(h=seq(0.0,1.0,0.1), v=seq(0.0,1.0,0.1), col="gray", lty=3)
legend(0.7, 0.3, sprintf("%3.3f",auc), lty=c(1,1), lwd=c(2.5,2.5), col="blue", title = "AUC")
-------------------------------------------------------------------------------------------------------
simulate <- function(n.obs=10^4, beta=c(5, 3, -2), R.sq=0.8) {
    stopifnot(length(beta) == 3)
    df <- data.frame(x1=rnorm(n.obs), x2=rnorm(n.obs))  # x1 and x2 are independent
    var.epsilon <- (beta[2]^2 + beta[3]^2) * (1 - R.sq) / R.sq
    stopifnot(var.epsilon > 0)
    df$epsilon <- rnorm(n.obs, sd=sqrt(var.epsilon))
    df$y <- with(df, beta[1] + beta[2]*x1 + beta[3]*x2 + epsilon)
    return(df)
}
get.R.sq <- function(desired) {
    model <- lm(y ~ x1 + x2, data=simulate(R.sq=desired))
    return(summary(model)$r.squared)
}
df <- data.frame(desired.R.sq=seq(from=0.05, to=0.95, by=0.05))
df$actual.R.sq <- sapply(df$desired.R.sq, FUN=get.R.sq)
plot(df)
abline(a=0, b=1, col="red", lty=2)
-------------------------------------------------------------------------------------------------------
which.max myden$x[which.max(myden$y)]
# [1] 5.91428 plot(myden, col='red')
abline(v=myden$x[which.max(myden$y)])
-------------------------------------------------------------------------------------------------------
DF newdata DF <- data.frame(type = factor(rep(c("A", "B", "C"), 5)),
                 xvariable = 1:15,
                 yvariable = 2 * (1:15) + rnorm(15, 0, 2)) ggplot geom_abline stat_smooth colour aes ggplot(DF, aes(x = xvariable, y = yvariable)) +
  geom_point(size = 3) + 
  geom_abline(aes(colour="one-to-one"), intercept =0, slope = 1, size = 1) +
  stat_smooth(aes(colour="best fit"), method = "lm", se = FALSE, size = 1) + 
  facet_wrap(~ type) +
  scale_colour_discrete("")
-------------------------------------------------------------------------------------------------------
plot.xts add plot.xts plot.xtsMODIFIED<-function (x, y = NULL, type = "l", auto.grid = TRUE, major.ticks = "auto", 
    minor.ticks = TRUE, major.format = TRUE, bar.col = "grey", 
    candle.col = "white", ann = TRUE, axes = TRUE, ...) 
{
    series.title <- deparse(substitute(x))
    ep <- axTicksByTime(x, major.ticks, format.labels = major.format)
    otype <- type
    if (is.OHLC(x) && type %in% c("candles", "bars")) {
        x <- x[, has.OHLC(x, TRUE)]
        xycoords <- list(x = .index(x), y = seq(min(x), max(x), 
            length.out = NROW(x)))
        type <- "n"
    }
    else {
        if (NCOL(x) > 1) 
            warning("only the univariate series will be plotted")
        if (is.null(y)) 
            xycoords <- xy.coords(.index(x), x[, 1])
    }
    ###The next three lines are the only modifications i made to the function####
    plot(xycoords$x, xycoords$y, type = "n", axes = FALSE, ann = FALSE) 
    rect(par("usr")[1], par("usr")[3], par("usr")[2], par("usr")[4], col ="white")
    if(type=="l"){lines(xycoords$x, xycoords$y, ...)}

    if (auto.grid) {
        abline(v = xycoords$x[ep], col = "grey", lty = 4)
        grid(NA, NULL)
    }
    if (is.OHLC(x) && otype == "candles") 
        plot.ohlc.candles(x, bar.col = bar.col, candle.col = candle.col, 
            ...)
    dots <- list(...)
    if (axes) {
        if (minor.ticks) 
            axis(1, at = xycoords$x, labels = FALSE, col = "#BBBBBB", 
                ...)
        axis(1, at = xycoords$x[ep], labels = names(ep), las = 1, 
            lwd = 1, mgp = c(3, 2, 0), ...)
        axis(2, ...)
    }
    box()
    if (!"main" %in% names(dots)) 
        title(main = series.title)
    do.call("title", list(...))
    assign(".plot.xts", recordPlot(), .GlobalEnv)
} library(quantmod)
getSymbols('SPY', from='1998-01-01', to='2011-07-31', adjust=T)

GRAPH_BLUE<-rgb(43/255, 71/255,153/255)
GRAPH_BACKGROUND<-rgb(180/255, 226/255, 244/255)

par(bg=GRAPH_BACKGROUND)

plot.xtsMODIFIED(SPY, col=GRAPH_BLUE) Error in axis(1, at = xycoords$x, labels = FALSE, col = "#BBBBBB", ...) : formal argument "col" matched by multiple actual arguments. plot.xts ... col axis plot lines ...
axis(1, at = xycoords$x, labels = FALSE, col = "#BBBBBB", 
            ...)
... ...
axis(1, at = xycoords$x, labels = FALSE, ...)
... plot.xts plot.xtsMODIFIED<-function (x, y = NULL, type = "l", auto.grid = TRUE, major.ticks = "auto", 
                             minor.ticks = TRUE, major.format = TRUE, bar.col = "grey", 
                             candle.col = "white", ann = TRUE, axes = TRUE, 
                             lcol, ...) 
{
...
if(type=="l"){lines(xycoords$x, xycoords$y, lcol, ...)}
...
} plot.xtsMODIFIED(SPY, lcol=GRAPH_BLUE)
-------------------------------------------------------------------------------------------------------
abline plot(duration ~ waiting, data=faithful)
abline(lm(duration ~ waiting, data=faithful))
-------------------------------------------------------------------------------------------------------
fit1 <- glm( I(Species=='versicolor') ~ Petal.Length + Petal.Width, 
   data=iris, family=binomial )
coef(fit1)

dummydata <- data.frame( Petal.Length = rnorm(10), Petal.Width=rnorm(10),
    Species = rep(c('versicolor','other'), each=5) )

fit2 <- glm( I(Species=='versicolor') ~ 0 + 
  offset(-2.863708 + 1.563076*Petal.Length - 3.153165*Petal.Width),
    data=dummydata, family=binomial )

pred1 <- predict(fit1, newdata=iris)
pred2 <- predict(fit2, newdata=iris)
plot(pred1,pred2)
abline(0,1, col='green')
-------------------------------------------------------------------------------------------------------
?plot.zoo panel parent.frame$panel.number hline # create values for hline, one for each panel
hlines <- c(50, 50, 48, 50)

# panel function that loops over panels
my.panel <- function(x, ...) {
  lines(x, ...)
  panel.number <- parent.frame()$panel.number
  abline(h = hlines[panel.number], col = "red", lty = "solid", lwd = 1.5)
}

plot.zoo(x, main = "title", type = "o", lwd = 1.5, col = "blue", panel = my.panel)
-------------------------------------------------------------------------------------------------------
pdf(file="myplot.pdf", width = 10, height =13) #create new pdf
plot(diff ~ abund_mean) #see data
abline(lm<- lm(diff ~ abund_mean)) #add regression to plot 
legend("topright", bty="n", legend=paste
("R2 is", format(summary(lm)$adj.r.squared, digits=4))) #print the regr. coeff. on plot
dev.off() #end of pdf creation
summary(lm) #see all the regression coefficients (F-statistic, RSE, etc.)
-------------------------------------------------------------------------------------------------------
set.seed(9)
df <- data.frame(x = rnorm(10), y = rnorm(10))
plot(df)

abline(v = 0.5, h = 1.2, col = "red") # 'original' crosshairs
while (T) {
  loc <- locator(1) # click location in plot, then ESC
  plot(df) # clear 'original' crosshairs
  abline(h = loc$y, v = loc$x, col = "green") # crosshairs at new position
}
-------------------------------------------------------------------------------------------------------
graphicalBMI <- function(meter, kg, showPlot=TRUE){

  BMI <- kg/(meter^2)

  if(showPlot){
    x <- seq(1.5, 1.9, by = 0.001)
    y <- seq(30, 200, by = 0.5)

    # here we call graphicalBMI by setting showPlot=F to avoid infinite recursion
    z <- outer(x, y, FUN = function(x, y) {graphicalBMI(x, y, FALSE)})
    contour(x, y, z, nlevels = 10, method = "edge", main = "BMI")
    abline(h = kg, v= meter, col="darkgrey") 
    points(meter, kg, col="red", cex=2, pch=16, bg="red")
  }
  return(BMI)
}


# usage example:
graphicalBMI(1.8,70) # plot produced

graphicalBMI(1.8,70,FALSE) # no plot produced
-------------------------------------------------------------------------------------------------------
library(foreign)
dat <- read.arff(url("http://www.cs.umb.edu/~rickb/files/UCI/autos.arff")) train <- dat[1:150,]
test <- dat[151:nrow(dat),] fit <- lm(`city-mpg` ~ `peak-rpm`+horsepower+`wheel-base`,data=train)
temp_test <- predict(fit,test) par(las=1,bty="l") ## cosmetic
plot(test[["peak-rpm"]],temp_test,xlab="peak rpm",ylab="predicted") cf <- coef(fit)
abline(a=cf["(Intercept)"]+
          mean(test$horsepower)*cf["horsepower"]+
          mean(test$`wheel-base`)*cf["`wheel-base`"],
          b=coef(fit)["`peak-rpm`"]) predict() newdat <- with(test,
            data.frame(horsepower=mean(horsepower),
                       "wheel-base"=mean(`wheel-base`),
                       "peak-rpm"=seq(min(`peak-rpm`),
                                        max(`peak-rpm`),
                                        length=41),
                       check.names=FALSE))
newdat["city-mpg"] <- predict(fit,newdat)
with(newdat,lines(`peak-rpm`,`city-mpg`,col=4)) fit2 <- lm(`city-mpg` ~ `peak-rpm`,data=train)
abline(fit2,col="red")
-------------------------------------------------------------------------------------------------------
tmp <- table(msleep$order)
barplot(tmp, col='black', las=3)
abline(h=seq(5, max(tmp), by=5), col='white', lwd=2)
-------------------------------------------------------------------------------------------------------
gap.plot library(plotrix)
par(bty="n") # deleting the box
gap.plot(x,y, gap=c(2,7.5), gap.axis="x", pch=16,
         col="blue", ylim=range(c(y,z)),
         xtics=c(0:3,8:10), xticlab=c(0:3,8:10))

gap.plot(x,z, gap=c(2,7.5), gap.axis="x", pch=17,
         col="red", ylim=range(c(y,z)), add=TRUE); axis(2)

abline(v=seq(1.99,2.09,.001), col="white")  # hiding vertical lines
axis.break(1,2,style="slash")               # plotting slashes for breakpoints
-------------------------------------------------------------------------------------------------------
# get threshold value
cutoff <- sort(DT$IncMSE, decreasing=TRUE)[10]

dotplot(feature ~ IncMSE, 
        data = DT[which(DT$IncMSE>=cutoff),], # this only includes top values
        aspect = 1.5,
        xlab = "Variable Importance, Scale 2",
        scales = list(cex = .6),
        panel = function (x, y) {
          panel.abline(h = as.numeric(y), col = "gray", lty = 2)
          panel.xyplot(x, as.numeric(y), col = "black", pch = 16)})
-------------------------------------------------------------------------------------------------------
x y plot(log(x), log(y))
abline(model, col="red")
-------------------------------------------------------------------------------------------------------
log='xy' plot(log(x), log(y), axes=FALSE, xlab="X", ylab="Y")
box()
axis(side=1,     at=log(c(1,2, 10,20, 100,200)), 
             labels=c(    1,2, 10,20, 100,200))
axis(side=2,     at=log(c(125,135, 250,260, 350, 500)), 
             labels=c(    125,135, 250,260, 350, 500))
abline(model, col="red")
-------------------------------------------------------------------------------------------------------
data.table D <- data.table(d)
MaxDate <- D[, max(date)] + 10
MinDate <- D[, min(date)]
D2 <- D[, list( date, firstdate = min(date)), by = id]
D2[, plot(date, id, type='n', bty='n',axes=FALSE, xlab = "", ylab ="")]
D2[date!=firstdate, points(date, id, pch =4)]
D2[date==firstdate, points(date, id)]
D2[date==firstdate, arrows(x0=date, y0=as.numeric(id), x1=MaxDate, length=0.1)]
abline(v=MaxDate - 5)
abline(v=MinDate)
axis(side= 2, tick = FALSE, at=D[, unique(id)], labels=D[, paste0("ID = ",  as.character(unique(id)))], las=2)
axis(side = 1, tick= FALSE, at=c(MinDate, MaxDate), labels = strftime(c(MinDate, MaxDate),format="Week %W, %Y") )
-------------------------------------------------------------------------------------------------------
x <- 1:10
y <- c(0, 0, 1, 0, 1, 1, 0, 1, 1, 1)
plot(x, y) abline(mod <- lm(y ~ x)) mod coef() coef(mod)

R> coef(mod)
(Intercept)           x 
    0.06667     0.09697 coef() coef(mod)[2]

R> coef(mod)[2]
      x 
0.09697 mod <- lm(y ~ x)
abline(mod) mod
-------------------------------------------------------------------------------------------------------
xyplot(nbsp~FRic, groups = Ecoregion,
       data=dataplot, xlab="Functional Richness", 
       ylab="Species Richness",
       panel=function(x, y, groups=groups,...) {
         panel.xyplot(x, y, groups=groups,...)
         panel.abline(lm(y~x), col='blue')
         panel.abline(lm(y~x+0), col='red')
       },
       type='l',
       auto.key = list(title='Ecoregion', space='right')
)
-------------------------------------------------------------------------------------------------------
scan(pipe("python scraper.py | cat")) import urllib2
from collections import Counter
from bs4 import BeautifulSoup

# get the html page of your target blog
soup = BeautifulSoup(urllib2.urlopen('http://datafireball.com/'))
# first, you need to retrieve the content of the blog
content = soup.find("div", {"id":"content"}).text.encode('utf-8')
# second, you count the frequency
cnt = Counter(content.split())
# print out the result to verify it works
print cnt Counter({'the': 73, 'to': 41, 'of': 34, 'is': 28, 'a': 27, 'R': 27, 'in': 24, 'you': 21, 'can': 17, 'and': 15, 'that': 13, 'it': 11, '<-': 10, 'read': 10, 'all': 9, 'data': 9, 'how': 9, 'will': 9, '$': 9, 'by': 9, 'into': 9, 'this': 8, 'on': 8, 'line': 8, 'with': 8, '1': 7, 'not': 7, 'which': 7, 'I': 7, 'model': 7, 'for': 7, 'install': 6, 'linear': 6, 'standard': 6, '>': 6, 'You': 6, 'be': 6, 'your': 6, ':': 6, 'Redhat': 5, '.entry-header': 5, 'use': 5, 'chr': 5, '.entry-meta': 5, '2013': 5, 'need': 5, 'note': 5, 'The': 5, 'do': 5, 'Leave': 5, 'datafireball': 5, '.entry-content': 5, '#post-##': 5, 'Python': 5, 'or': 5, 'but': 5, '\xe2\x80\x93': 5, 'row': 4, 'R-squared': 4, 'num': 4, 'are': 4, 'from': 4, 'October': 4, 'List': 4, 'then': 4, 'our': 4, '2': 4, '=': 4, 'find': 4, 'make': 4, 'command': 4, 'In': 4, 'R,': 4, 'some': 4, 'To': 4, 'file': 4, 'code': 3, 'very': 3, 'what': 3, '3.': 3, 'working': 3, 'write': 3, 'help': 3, 'fit': 3, 'actually': 3, '2.': 3, 'R.': 3, 'out': 3, 'squared': 3, 'x': 3, 'first': 3, 'script': 3, '1.': 3, 'Then': 3, '3': 3, 'import': 3, 'we': 3, '~': 3, 'parse': 3, 'result': 3, 'really': 3, 'page': 3, 'package': 3, 'there': 3, 'up': 3, 'an': 3, 'kinds': 3, 'As': 3, 'code,': 3, '-c': 2, '-y': 2, 'string': 2, 'every': 2, '"a"': 2, 'Python.': 2, 'current': 2, '10,': 2, 'here': 2, 'change': 2, 'makes': 2, 'few': 2, '6': 2, 'tell': 2, '98': 2, 'flag': 2, 'my': 2, 'indicates': 2, 'Coefficient': 2, '0.9693628': 2, 'product': 2, '"B"': 2, 'su': 2, 'What': 2, 'R-squared:': 2, 'Here': 2, 'python': 2, 'easily': 2, 'all,': 2, 'From': 2, 'print': 2, 'created': 2, 'could': 2, '*': 2, 'white': 2, 'x,': 2, 'kind': 2, 'seamlessly': 2, 'Package': 2, 'points': 2, 'Hadoop': 2, 'Note,': 2, 'one': 2, 'title': 2, 'only': 2, 'pretty': 2, 'get': 2, 'see': 2, 'closed': 2, 'connection.': 2, 'BeautifulSoup': 2, 'much': 2, 'look': 2, 'while': 2, 'if': 2, 'connection': 2, 'check': 2, 'python.exec(\xe2\x80\x9cprint': 2, 'uses': 2, 'datafireball.com': 2, 'well': 2, 'y': 2, 'If': 2, 'just': 2, 'However,': 2, 'directory,': 2, 'input': 2, 'using': 2, 'like': 2, '[1]': 2, 'back': 2, '/': 2, 'noise': 2, 'run': 2, 'power': 2, 'anything': 2, 'trying': 2, 'called': 2, 'as': 2, 'when': 2, '4.': 2, 'together': 2, 'at': 2, 'sometimes,': 1, 'Web': 1, 'existing': 1, 'arguments,': 1, 'BeautifulSoup(stream)': 1, 'Take': 1, '(which': 1, '[yes/no]\xe2\x80\x98': 1, 'whose': 1, 'calculate': 1, 'default,': 1, "{\xe2\x80\x98class\xe2\x80\x99:'site-description\xe2\x80\x99}).text.encode(\xe2\x80\x98utf-8\xe2\x80\xb2)": 1, 'Residual': 1, 'str_py_dict': 1, 'languages': 1, 'asking': 1, 'method=\xe2\x80\x9dpearson\xe2\x80\x9d)': 1, 'otherwise,': 1, '***': 1, 'level': 1, 'list': 1, 'leave': 1, 'guy': 1, 'refer': 1, 'Rscript!': 1, 'lm(formula': 1, 'Functions': 1, 'Stats': 1, '\xe2\x80\x98**\xe2\x80\x99': 1, 'else,': 1, 'data(iris)': 1, '3Q': 1, '27,': 1, 'range.': 1, 'object.': 1, '"A"': 1, '"(1,\'a\',': 1, 'R-core-devel': 1, 'Determination.)': 1, '+': 1, '4': 1, 'version': 1, 'tips': 1, 'satisfy': 1, '10)': 1, 'Combining': 1, "input<-file('stdin',": 1, 'datafireball.py': 1, 'objects': 1, 'python.load(\xe2\x80\x98/tmp/datafireball.py\xe2\x80\x99)': 1, 'write(result,': 1, '(JSON),': 1, 'Never\xc2\xa0Use': 1, 'error:': 1, '"[1,\'a\',': 1, 'commonly': 1, 'here,': 1, '{': 1, 'Pythonic': 1, 'divide': 1, "'rpm": 1, 'Correlation': 1, 'type.': 1, 'sys': 1, 'output,': 1, 'apply': 1, 'unit': 1, 'figure': 1, '0': 1, 'edit(data)': 1, '/user/bin/R': 1, 'going': 1, 'm1': 1, '\xe2\x80\x9cshebang\xe2\x80\x9d': 1, '0.9691': 1, '0.001': 1, 'flat': 1, 'started': 1, 'freedom': 1, 'line.': 1, 'screen.': 1, 'So': 1, 'work': 1, 'Actually,': 1, 'soup': 1, '-0.6669': 1, 'py_iris.keys()\xe2\x80\x9d)': 1, '0.9694,': 1, 'stream': 1, 'Min': 1, '0.1': 1, '<2e-16': 1, 'something': 1, 'want': 1, 'Signif.': 1, 'Coefficients:': 1, 'r^2': 1, 'means': 1, 'Also,': 1, 'utilize': 1, 'command"),': 1, 'parameter': 1, 'len(py_iris)\xe2\x80\x9d)': 1, 'information': 1, '(Move': 1, '\xe2\x80\x9cR\xe2\x80\x9d': 1, 'processed.': 1, '(References:\xc2\xa0Pearson': 1, 'lines': 1, 'happen.': 1, 'string/stdout()': 1, 'so': 1, 'correlation': 1, 'again.': 1, 'sd': 1, 'lm(y': 1, 'record.': 1, 'already': 1, 'through': 1, 'looks': 1, 'defination):': 1, 'type=\xe2\x80\x9do\xe2\x80\x9d,': 1, 'mentioned': 1, 'interpreter': 1, 'still': 1, 'set.seed(100)': 1, 'its': 1, 'readLines:': 1, 'Multiple': 1, '-Uvh': 1, 'degrees': 1, '0.0003613\xc2\xa0,': 1, '2,': 1, '<': 1, 'good': 1, 'computer\xe2\x80\x99s': 1, 'introduce': 1, 'they': 1, "u'Sepal.Width',": 1, 'cluster.': 1, 'name': 1, '"")': 1, 'fully': 1, 'above(sd=5).': 1, 'mode': 1, 'each': 1, 'found': 1, 'side': 1, 'soup.find(\xe2\x80\x98div\xe2\x80\x99,': 1, '(Pearson\xe2\x80\x99s': 1, 'doing': 1, 'series': 1, 'idea': 1, '\xe2\x80\x93\xc2\xa0stdin/stdout': 1, 'Which': 1, 'happen': 1, 'python.load()': 1, 'is:': 1, 'df': 1, 'Std.': 1, 'Residuals:': 1, 'matrix': 1, 'Very': 1, 'content': 1, 'time.': 1, 'install.': 1, 'got': 1, 'file()/file_test()/file.access()/file.remove()/file.copy()/file.exist()/file.info()/file.append()/file.symlink()/file.link()/file.path()/file.show()': 1, 'written': 1, 'This': 1, 'python.assign(PyObject,RObject)': 1, 'gap.': 1, 'base': 1, '$cat': 1, 'put': 1, 'testData': 1, 'python.exec("python': 1, 'definition': 1, 'str(python.get(str_py_tuple))': 1, 'length': 1, 'yum': 1, '\'B\']"': 1, 'go:': 1, 'stdout:': 1, '1Q': 1, 'There': 1, 'yourself': 1, '6.': 1, 'input\xe2\x80\x99': 1, 'says': 1, 'open': 1, 'RGui': 1, 'IDE': 1, 'plot(y': 1, '0.01': 1, 'system': 1, '0.05': 1, 'their': 1, 'Rstudio.': 1, 'perfectly': 1, 'Data': 1, '#!/usr/bin/Rscript': 1, 'gives': 1, 'x)': 1, 'str(python.get(str_py_list))': 1, 'Install': 1, 'Enterprise': 1, 'easier.': 1, 'from?': 1, "http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm'": 1, '10': 1, 'translate': 1, '1:': 1, 'r': 1, 'df)': 1, '\xe2\x80\x9cstdin\xe2\x80\x9d': 1, '\xe2\x80\x98standard': 1, 'stdin': 1, 'cases,': 1, 'bs4': 1, 'turned': 1, '-0.2093': 1, 'have': 1, 'cleaned': 1, 'Service),': 1, 'tells': 1, 'F-statistic:': 1, '-': 1, 'end,': 1, 'build': 1, 'deviation.': 1, 'order.': 1, 'sure': 1, 'node': 1, 'data.frame': 1, '55.684': 1, 'sum(m1$residuals^2)': 1, 'most': 1, 'curve.': 1, 'connected': 1, 'RPython': 1, 'see,': 1, 'extremely': 1, 'str_py_list': 1, 'request': 1, 'pipe': 1, 'col=\xe2\x80\x9dred\xe2\x80\x9d)': 1, '}': 1, '1.37592': 1, '1:100': 1, 'slope': 1, 'returned.': 1, '2.06135': 1, 'n=1)': 1, 'pride,': 1, 'Manager)': 1, 'abline(m1,': 1, "'yum": 1, 'sudo': 1, 'y,': 1, 'Pr(>|t|)': 1, 'list).': 1, '\xe2\x80\x98r\xe2\x80\x99': 1, 'x))': 1, 'Windows).': 1, 'Base': 1, 'readLines(input,': 1, 'main=\xe2\x80\x9dy': 1, 'beat': 1, 'str(python.get(str_py_dict))': 1, 'codes:': 1, 'cannot': 1, 'during': 1, 'description': 1, '0.506': 1, 'Linux).': 1, 'summary': 1, 'bad': 1, '6.4': 1, 'them.': 1, '\xe2\x80\x98Is': 1, 'where': 1, 'inside': 1, 'xinch': 1, 'package,': 1, 'decided': 1, '0.03544': 1, 'close': 1, 'into\xc2\xa0R': 1, '#': 1, 'Again,': 1, 'please': 1, 'opened': 1, 'pump': 1, 'determination(\xe5\x86\xb3\xe5\xae\x9a\xe7\xb3\xbb\xe6\x95\xb0),': 1, 'across': 1, '0,': 1, 'available': 1, 'sd=10\xe2\x80\xb3)': 1, 'R-dev..': 1, 'connection,': 1, 'answers': 1, 'interface': 1, 'packages': 1, 'come': 1, 'EPEL(Extra': 1, '26.1505': 1, 'conlusion,': 1, 'R),': 1, 'cov(x,': 1, 'way,': 1, 'delete': 1, 'comes': 1, 'library(\xe2\x80\x98rPython\xe2\x80\x99)': 1, '1+1}"': 1, 'point': 1, 'dataframe': 1, 'file=\xe2\x80\x9ddata\xe2\x80\x9d\xe2\x80\xa6),': 1, 'ETL': 1, 'there,': 1, 'R-core': 1, 'we\xe2\x80\x99ve': 1, "u'Petal.Width',": 1, 'basic': 1, 'line..': 1, 'empty': 1, 'life': 1, 'options.': 1, 'covariance': 1, 'posts,': 1, 'catch': 1, 'Estimate': 1, 'And': 1, 'Adjusted': 1, 'edit/vi/emacs/xemacs/xedit': 1, '1.97333': 1, 'summary(m1': 1, 'python.get': 1, 'value': 1, 'versa.': 1, 'write(x,': 1, 'loop': 1, 'Rscript': 1, 'Above': 1, 'n=1': 1, 'cluster': 1, 'rnorm(length(x),': 1, '1000,': 1, 'regression': 1, 'different': 1, 'flag.': 1, '(sd(x)*sd(y))': 1, '2.2e-16': 1, 'html': 1, 'inch': 1, 'mode,': 1, 'document': 1, 'used': 1, 'http': 1, '\xe2\x80\x98*\xe2\x80\x99': 1, 'moment': 1, 'datatypes': 1, 'Coefficient,': 1, 'object': 1, 'this(Wikipedia': 1, 'getwd()/write()/unlink()': 1, 'str_py_tuple': 1, '10.23': 1, 'sys.path.append(\xe2\x80\x98/Library/Python/2.7/site-packages/beautifulsoup4-4.2.1-py2.7.egg\xe2\x80\x99)': 1, 'squared\xe2\x80\x9d': 1, 'distribute': 1, '(record)': 1, 'computing.': 1, 'stored': 1, 'questions': 1, 'rule..': 1, 'yes': 1, 'case,': 1, 'C-level': 1, 'console': 1, 'combine': 1, 'easy': 1, '-22.6284': 1, '\xc2\xa0You': 1, "'r')": 1, 'smart': 1, 'Pearson': 1, '6.1186': 1, 'format': 1, 'know': 1, 'helpful': 1, 'OK': 1, '\xe2\x80\x9cR\xc2\xa0squared\xe2\x80\x9d': 1, 'Streaming': 1, '5.': 1, 't': 1, 'popular': 1, 'output': 1, 'yinch': 1, 'simple,': 1, 'often': 1, 'people': 1, 'successfully': 1, 'library': 1, 'Call:': 1, '"{1:2,': 1, 'duration': 1, "[u'Petal.Length',": 1, 'users': 1, 'happens': 1, 'stdin/stdout': 1, 'does': 1, 'urllib2.urlopen(\xe2\x80\x98http://datafireball.com/&#8217;)': 1, 'either': 1, 'process': 1, 'while(length(row)>0)': 1, 'post': 1, 'super': 1, "'a':'A',": 1, 'First': 1, 'here(clearly,': 1, '\xe2\x80\x98.\xe2\x80\x99': 1, 'comment,': 1, 'important': 1, 'B:': 1, 'RPM(Redhat': 1, 'Use': 1, 'own': 1, '0.667': 1, 'Bash,': 1, 'file:': 1, 'coefficient': 1, 'dataset': 1, 'determine': 1, 'python.assign(\xe2\x80\x98py_iris\xe2\x80\x99,': 1, '\xe2\x80\x9cR': 1, 'R-core,': 1, 'a:': 1, 'computer': 1, 'datasets.': 1, 'DF,': 1, 'question': 1, 'start': 1, '\xe2\x80\x9crt\xe2\x80\x9d': 1, 'low': 1, "'B':": 1, 'call': 1, 'November': 1, 'function': 1, 'urllib2,': 1, 'complete': 1, 'enough': 1, 'properly': 1, 'Error': 1, 'p-value:': 1, 'open,': 1, 'sum((y-mean(y))^2)': 1, 'embedded': 1, '\'B\')"': 1, 'functions,': 1, 'below': 1, '(Intercept)': 1, '0.9694': 1, 'on\xc2\xa0Redhat6': 1, 'organize': 1, 'Usually,': 1, 'distribution': 1, '(Amazon': 1, 'etc.': 1, 'plotting)': 1, 'interactive': 1, 'Squared': 1, 'single': 1, 'model.': 1, "u'Sepal.Length',": 1, '15,': 1, 'fill': 1, 'machine': 1, 'functions': 1, 'read.csv\xe2\x80\xa6etc.': 1, 'output.': 1, 'Read': 1, 'Max': 1, '3101': 1, "R-devel'": 1, '5': 1, 'nonsense\xe2\x80\xa6': 1, 'small.': 1, 'deviation': 1, "u'Species']": 1, 'Streaming.': 1, 'Median': 1, 'urllib2': 1, 'journey': 1, '\xe2\x80\xa6': 1, '-6.8113': 1, 'debian': 1, 'position.': 1, '\xe2\x80\x94': 1, 'vice': 1, '\xe2\x80\x99': 1, '\xe2\x80\x98': 1, '\xe2\x80\x98***\xe2\x80\x99': 1})
-------------------------------------------------------------------------------------------------------
plot.new()
plot.window(xlim=c(0,100),ylim=c(0,100))
lines(c(0,50,100), c(50,0,0))
axis(1)
axis(2)
title(main="Graph")
title(xlab="X")
title(ylab="Y")
box()
-------------------------------------------------------------------------------------------------------
segments Draw line segments between pairs of points. plot.new()
plot.window(xlim=c(0,100),ylim=c(0,100))
#abline(a=50,b=-1)
#abline(a=0,b=0)
segments(0,50,50,0)
segments(50,0,100,0)
axis(1)
axis(2)
title(main="Graph")
title(xlab="X")
title(ylab="Y")
box()
-------------------------------------------------------------------------------------------------------
panel = function(...){
                 # panel.levelplot(...) # insead of marking up 
                 # on top of the plotted values
                   sp.polygons(imap) 
                   panel.levelplot(...)   
                   panel.abline(v=(71:88),col="dark red")              
                   panel.abline(h=(17:31),col="dark red")         
                     } panel.levelplot(...) # shift the long lat to the cell center. In this case, 
# the centroid is convenetly, .5 up
# and .5 over, so you can do it in-line:
levelplot(surface_aod~I(longitude+.5)+I(latitude+.5),data=s.data,
        panel = function(...){
            panel.levelplot(...)
            panel.abline(v=(71:88),col="dark red")              
            panel.abline(h=(17:31),col="dark red")    
            #sp.polygons(imap)         
        }, 
        col.regions = heat.colors(100),
        aspect="iso", 
        region=TRUE,
        scales=list(x=list(at=seq(from=71,to=88, by=1)), 
                y=list(at=seq(from=17,to=31, by=1)),
                cex=.7, 
                alternating=3),
        xlim=c(70,90), 
        ylim=c(16,32)
)
-------------------------------------------------------------------------------------------------------
a<-ifelse(data$ICS==10,"a",ifelse(data$ICS==11,"b",ifelse(data$ICS==12,"c",ifelse(data$ICS==13,"d",ifelse(data$ICS==14,"e","f"))))) #ICS as characters
cls<-c(2,"orange",7,3,6,4) [factor(a)] #10-11-12-13-14-15: red,orange,yellow,green,purple,blue
b<-data$Site
shapes<-c(0,1,2,8)[factor(b)] #Square is RDC liv, Circle is RDC V, Triangle is RVC V, Star is RVC CCJ
BAplot <- function(x,y,yAxisLim=c(-50,50),xlab="Average", ylab="Difference",col=cls,pch=shapes) {
  d <- ((x + y)/2)
  diff <- x - y        
  plot(diff ~ d,ylim=yAxisLim,xlim=c(0,60),xlab=xlab,ylab=ylab,col=cls,pch=shapes)
  abline(h=(mean(na.omit(diff))-c(-0.96,0,0.96)*sd(na.omit(diff))),lty=2)
}
plot.ops<-BAplot(data$Op.1,data$Op.2,xlab="(Op1 vs Op 2)/2", ylab="Op1-mean of Op1+Op2",col=cls,pch=shapes)
title(main="Bland-Altman plots of Op1 vs Op2")
legend (34,53,legend=c("RDC Liver","RDC V","RVC V","RVC CCJ"), pch=c(0,1,2,8), pt.cex=2, y.intersp=0.8) #legend for shape
legend (49,53,legend=c("10th ICS","11th ICS","12th ICS","13th ICS","14th ICS","15th ICS"), pch=22, pt.cex=2, pt.bg=c(2,"orange",7,3,6,4), y.intersp=0.6) #legend for the colours shapes<-c(0,1,2,8)[factor(data$Site)] b<-data$Site
shapes<-c(0,1,2,8)[factor(b)]
-------------------------------------------------------------------------------------------------------
data[, 1] abline(v = data[data[, 2] == 1, 1], col = 'blue')
abline(v = data[data[, 2] == -1, 1], col = 'red')
-------------------------------------------------------------------------------------------------------
abline abline(v=m[,1], col=c('red', NA, 'blue')[as.numeric(as.factor(m[,2]))])
-------------------------------------------------------------------------------------------------------
plot(lm(...)) ggQQ = function(lm) {
  # extract standardized residuals from the fit
  d <- data.frame(std.resid = rstandard(lm))
  # calculate 1Q/4Q line
  y <- quantile(d$std.resid[!is.na(d$std.resid)], c(0.25, 0.75))
  x <- qnorm(c(0.25, 0.75))
  slope <- diff(y)/diff(x)
  int <- y[1L] - slope * x[1L]

  p <- ggplot(data=d, aes(sample=std.resid)) +
    stat_qq(shape=1, size=3) +           # open circles
    labs(title="Normal Q-Q",             # plot title
         x="Theoretical Quantiles",      # x-axis label
         y="Standardized Residuals") +   # y-axis label
    geom_abline(slope = slope, intercept = int, linetype="dashed")  # dashed reference line
  return(p)
} # sample data (y = x + N(0,1), x in [1,100])
df <- data.frame(cbind(x=c(1:100),y=c(1:100+rnorm(100))))
ggQQ(lm(y~x,data=df))
-------------------------------------------------------------------------------------------------------
plot_one plot_one <- function(d){
  with(d, plot(Days, Count, t="n", tck=1, main=unique(d$ID), cex.main = 0.8, ylab = "", yaxt = 'n', xlab = "", xaxt="n",  xlim=c(0,1000), ylim=c(0,1200))) # set limits
  grid(lwd = 0.3, lty = 7)
  with(d[d$Treat == 0,], points(Days, Count, col = 1)) 
  with(d[d$Treat == 1,], points(Days, Count, col = 2))
  mod = lm(Count ~ Days, data = d[d$Treat == 0,])
  abline(reg = mod)
  text(x=500, y=800, mod$coefficients[2])
}
-------------------------------------------------------------------------------------------------------
0.05 * 3036 = 151.8 NA library(matrixStats)

# To extract your values...
myfun <- function(k, q){x[k, x[k,] > q]}
x <- matrix(sample(1:100, 60*3036, replace=TRUE), ncol=3036)
xx <- mapply(myfun, seq(along=x[,1]), rowQuantiles(x, probs=.95))
# xx is a list, xx[[1]] contains the values of x[1,] > quantile(x[1, ], .95)

# The number of selected values depends on their distribution - with NORM should be stable
x11() ; par(mfrow=c(2,1))
hist(sample(1:100, 60*3036, replace=TRUE)) # UNIF DISTRIB
n.val <- sapply(xx, length)
hist(n.val, xlab="n.val > q_95%")
abline(v=152, col="red", lwd=5)

# Assuming you want the same number of value for each row
n <- min(n.val)
myfun <- function(x){sample(x, n)} # Representative sample - Ordering is possible but introduce bias. Depends on your goals
xx <- t(sapply(xx, myfun))
dim(xx) # 60 n
-------------------------------------------------------------------------------------------------------
maps mapproject expand.grid(long,lat) library("mapproj")
m <- map( "world", "Antarctica", plot=FALSE)
map("world", "Antarctica", proj="conic", param=-90, fill=TRUE, col="gray")
map.grid(m, nx=4, ny=6, col="black")

front.lim <- data.frame(x=seq(-180, 180, length.out=1000),
                        y=rep(-62, 1000))
front.lim <- mapproject(front.lim$x, front.lim$y, projection="conic", parameters=-90)
lines(front.lim$x, front.lim$y, col="red", lwd=2) map(add=TRUE) plot(c(-10, 45), c(30, 60), type="n", xlab="", ylab="") # image(ncdf)
map(add=TRUE, fill=TRUE, col="gray")
abline(v=seq(-10, 45, 7.5), lty=2)
abline(h=seq(-30, 60, 7.5), lty=2)
-------------------------------------------------------------------------------------------------------
y = 2*x x <- rnorm(100)
y <- rnorm(100)
type <- y<2*x
plot(x,y,pch=type+1)
abline(0,2) type pch col abline() ggplot require(ggplot2)
df <- data.frame(x,y,type)
ggplot(df,aes(x,y,shape=type)) + geom_point() + geom_abline(slope=2) color=type shape=type
-------------------------------------------------------------------------------------------------------
par(mfrow=c(2,2))                            # Split plot window in 2 row and 2 col
plot(chl ~ latitude, data=d1, type="l")      # type="p" for points
plot(sst ~ latitude, data=d1, type="l")      # type="b" for points and line
plot(upwelling ~ latitude, data=d1, type="l")

myreg <- lm(upwelling ~ latitude, data=d1)
abline(myreg, col="blue")
summary(myreg)                               # Sum up results
    # See also predict(), coefficients(), confint(), ... ...

plot(myreg)                                  # To plot residuals etc...
-------------------------------------------------------------------------------------------------------
plot(log(y)~log(x)) y plot(log(y)~x)
modlm <- lm(log(y)~x)
abline(modlm) summary(modlm)

Call:
lm(formula = log(y) ~ x)

Residuals:
       Min         1Q     Median         3Q        Max 
-0.0081825 -0.0009194  0.0000952  0.0008455  0.0070058 

Coefficients:
              Estimate Std. Error t value Pr(>|t|)    
(Intercept)  6.927e+00  4.567e-04 15166.4   <2e-16 ***
x           -1.227e-04  3.516e-07  -349.1   <2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 0.002185 on 64 degrees of freedom
Multiple R-squared:  0.9995,    Adjusted R-squared:  0.9995 
F-statistic: 1.219e+05 on 1 and 64 DF,  p-value: < 2.2e-16 nls modnls <- nls(y~exp(a+b*x), start=list(a=coef(modlm)[[1]], b=coef(modlm)[[2]]))
plot(y~x)
xnew <- seq(min(x), max(x), by=0.5)
lines(xnew, exp(coef(modnls)[[1]]+xnew*coef(modnls)[[2]])) summary(modnls)

Formula: y ~ exp(a + b * x)

Parameters:
    Estimate Std. Error t value Pr(>|t|)    
a  6.926e+00  4.384e-04 15797.5   <2e-16 ***
b -1.225e-04  3.831e-07  -319.7   <2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 1.904 on 64 degrees of freedom

Number of iterations to convergence: 2 
Achieved convergence tolerance: 6.25e-08 lm nls y x
-------------------------------------------------------------------------------------------------------
legend(x = 0.25, y = 35, c("seed match", "background"), bty="n", lty=c(1,1), col=c("red","black"), cex=0.8, inset=0)
-------------------------------------------------------------------------------------------------------
abline(lm(logdiff[,2]~logdiff[,1]),col=2)
-------------------------------------------------------------------------------------------------------
#basic plot
plot(NULL, ann = F, xlim = c(-10,20), ylim = c(-10,20))
abline(h = -10:20, col = grey(0.75), lty = 2)
abline(v = -10:20, col = grey(0.75), lty = 2)

#starting coordinates
A_coords = c(0,0)
B_coords = c(10,0)
text(A_coords[1], A_coords[2], "A", col = "red")
text(B_coords[1], B_coords[2], "B", col = "blue")

for(i in 1:15000)
 {
  Sys.sleep(1)

  text(A_coords[1], A_coords[2], "A", col = "white")
  text(B_coords[1], B_coords[2], "B", col = "white")
                                                       #used jonas's idea
  A <- A_coords + unlist(sample(list(c(0, 1), c(1, 0), c(-1, 0), c(0, -1)), 1)) 
  B <- B_coords + unlist(sample(list(c(0, 1), c(1, 0), c(-1, 0), c(0, -1)), 1))

  lines(c(A_coords[1], A[1]), c(A_coords[2], A[2]), col = "red")
  lines(c(B_coords[1], B[1]), c(B_coords[2], B[2]), col = "blue")

  A_coords <- A
  B_coords <- B

  text(A_coords[1], A_coords[2], "A", col = "red")
  text(B_coords[1], B_coords[2], "B", col = "blue")

  if(all(abs(A_coords - B_coords) <= 1)) break
 }

list(steps = i, A_coordinates = A_coords, B_coordinates = B_coords)
-------------------------------------------------------------------------------------------------------
plot_robots <- function(rob1, rob2){
  plot(1, xlim = c(-20, 20), ylim =c(-20, 20), type = "n", xaxs = "i", yaxs = "i")
  abline(h =-20:20, v = -20:20)
  points(c(rob1[1], rob2[1]), c(rob2[2], rob2[2]), pch = 21, cex = 2, bg = c("red", "blue"))
}

rob1 <- c(0, 0)
rob2 <- c(10, 0)

plot_robots(rob1, rob2)

for(i in 1:15000){
 rob1 <- rob1 + sample(list(c(0, 1), c(1, 0), c(-1, 0), c(0, -1)), 1)[[1]]
 rob2 <- rob2 + sample(list(c(0, 1), c(1, 0), c(-1, 0), c(0, -1)), 1)[[1]]
 plot_robots(rob1, rob2)
 Sys.sleep(.1)
}
-------------------------------------------------------------------------------------------------------
?plot.function curve abline plot( function(x) x^2 - 3*x - 10 , -15, 15) ; abline(h=0,v=0,lty=3) curve(x^2 - 3*x - 10 , -15, 15) ; abline(h=0,v=0,lty=3)
-------------------------------------------------------------------------------------------------------
g<-qplot(log(X),log(Y),geom=c("point","smooth"))
lookinside<-ggplot_build(g)$data[[2]]
smooth<-data.frame(cbind(x=lookinside$x,y=lookinside$ymax-lookinside$ymin))
lm(smooth$x~smooth$y)

  Call:
    lm(formula = smooth$x ~ smooth$y)

  Coefficients:
    (Intercept)     smooth$y  
  1.25482      0.06275 


qplot(smooth$x,smooth$y)+geom_abline(intercept=1.25482,slope=0.06275,color="red")
-------------------------------------------------------------------------------------------------------
set.seed(10)
dat <- data.frame(A = rnorm(20), B = rnorm(20), C = rnorm(20)) # create a QQ-plot of B as a function of A
qqplot(dat$A, dat$B, xlim = range(dat), ylim = range(dat), 
       xlab = "A", ylab = "B/C")
# create a diagonal line
abline(a = 0, b = 1)
# add the points of C
points(sort(dat$A), sort(dat$C), col = "red")
# create a legend
legend("bottomright", legend = c("B", "C"), pch = 1, col = c("black", "red"))
-------------------------------------------------------------------------------------------------------
#create log probablity plot
#MPM 131201
#Make some dummy data
set.seed(21)
Dt<-as.data.frame(rlnorm(625, log(10), log(2.5)))
names(Dt)<-"Au_ppm"

#Create probablity scale lines and associated labels - 
PrbGrd <- qnorm(c(0.001,0.01, 0.05, 0.10,0.20,0.30,0.40, 0.50, 0.60, 0.70,0.80,0.90,0.95,0.99,0.999))
PrbGrdL<-c("0.1","1","5","10","20","30","40","50","60","70","80","90","95","99","99.9")

#create some value grid lines then convert to logs
ValGrd<-c(seq(0.001,0.01,0.001),seq(0.01,0.1,0.01),seq(0.1,1,0.1),seq(1,10,1),seq(10,100,10))
ValGrd<-log10(ValGrd)

#load up lattice packages - latticeExtra for nice log scale
require(lattice)
require(latticeExtra)

#Use qqmath to make the plot (note lattice does not work for weighted data - shame about that)

qqmath(~ Au_ppm, 
        data= Dt,
            distribution = function(p) qnorm(p),
        main = "Normal probablity / log (base 10) plot",
        pch=20,
        cex=0.5,
        xlab="Normal distribution scale (%)",
        scales=list(y=list(log=10,alternating=1),x = list(at = PrbGrd, labels = PrbGrdL, cex = 0.8)),
        yscale.components=yscale.components.log10ticks,
        panel=function(x,...){
            panel.abline(v=PrbGrd ,col="grey",lty=3)
            panel.abline(h=ValGrd,col="grey",lty=3)
            panel.qqmath(x,distribution=qnorm)
        }

    )
-------------------------------------------------------------------------------------------------------
x = seq(0, 3, len = 100)
y1 = function(x) x^2 -2*x +2
y2 = function(x) -4*x + 1
z = function(x) y1(x)/(y1(x)-y2(x)) plot(x,y1(x),ylim=c(-12,5),type="l",ylab="y")
lines(x,y2(x),col="blue")
lines(x,z(x),col="red")
abline(h=0,v=0,col="gray")
legend("bottomleft",c("y1(x)","y2(x)","z(x)"),fill=c("black","blue","red"))
-------------------------------------------------------------------------------------------------------
wireframe panel panel.xyplot panel.abline panel=function(...) {panel.xyplot(...); panel.abline(0,1); panel.abline(0,-1)}
-------------------------------------------------------------------------------------------------------
curve(f, 0, 0.035) abline(h=0.04, col="red") uniroot f_inverse <- function(y, lower=0.0, upper=0.02) 
   uniroot((function (x) f(x) - y), lower = lower, upper = upper)$root

f_inverse(0.04)
## [1] 0.01250961

f_inverse(0.04, 0.02, 0.04) # to get the other root...
## [1] 0.02561455 optimize(f, lower=0, upper=1) optim <- optimize(f, lower=0, upper=1)
seq1 <- seq(f(0), optim$objective, length=100)
inv1 <- sapply(seq1, f_inverse, lower=0, upper=optim$minimum)
seq2 <- seq(optim$objective, f(0.04), length=100)
inv2 <- sapply(seq2, f_inverse, lower=optim$minimum, upper=1)
plot(c(seq1, seq2), c(inv1, inv2), type="l") curve(f, 0, .04)
-------------------------------------------------------------------------------------------------------
clss ctg mapply # get colour for each combination
x <- sample(colours(), length(unique(paste0(df$clss, df$ctg)))) 
# how many of each combination are there
q <-  aggregate(df$intercept, by=list(paste0(df$clss, df$ctg)), length)
# make a colour vector
mycols <- rep(x, q[,2])


mapply(function(x,y,z) { abline(x, y, col=z) }, 
       df$intercept, df$slope, 
       as.list(mycols) )

#You could obviously pick the colours yourself or choose a gradient
-------------------------------------------------------------------------------------------------------
ggplot library(ggplot2)
gg       <- df
gg$color <- paste(gg$clss,".",gg$ctg,sep="")
ggplot(gg) +
  geom_point(aes(x=-10,y=-10,color=color)) +   # need this to display a legend...
  geom_abline(aes(slope=slope, intercept=intercept, color=color)) +
  xlim(0,10) + ylim(0,10) + labs(x="X",y="Y")
-------------------------------------------------------------------------------------------------------
x    <-  c( 1,  3,  1,  3,  2,  4,  2,  4)
y    <-  c( 1,  3,  2,  4,  1,  3,  2,  4)
type <-  c("A","A","B","B","C","C","D","D")
data <-  data.frame(x,y,type)

int   <- c(5,5,5,5)
slope <- c(-1,-1,-1,-1)
type  <- c("A","B","C","D")
ref   <- data.frame(int, slope, type)
ggplot(data, aes(x,y)) + geom_line() + facet_wrap(~type, scales="free") +
  geom_abline(data = ref, aes(intercept=int, slope=slope), color="red", size=2)
-------------------------------------------------------------------------------------------------------
z <- exp(-seq(0,3, by=0.1)^2 )
plot(z)
plot(diff(z))
z[ which(abs(diff(z))==max(abs(diff(z))) )]
# [1] 0.6126264
# could have also tested for min() instead of max(abs())
plot(z)
abline( v = which(abs(diff(z))==max(abs(diff(z))) ) )
abline( h = z[which(abs(diff(z))==max(abs(diff(z))) ) ] ) diff(z) [ which(abs(diff(z))==max(abs(diff(z))) )  ]
[1] -0.08533397
-------------------------------------------------------------------------------------------------------
scatterplot() layout par("mfg") abline() set.seed(1)
d <- data.frame(x=rnorm(10,mean=10),y=rnorm(10,mean=12))
library(car) scatterplot(y~x,data=d,reset.par=FALSE)
k <- 1              
for (i in 1:2) {
   for (j in 1:2) {
      par(mfg=c(i,j,2,2))
        abline(0,1,lwd=3,col=k)
        k <- k+1
  } scatterplot() scatterplot(y~x,data=d)
 uu <- par("usr")
 ## mimic layout frolm car:::scatterplot.default.  Would be different if we were drawing only one
 ## of x-boxes or y-boxes
 layout(matrix(c(1, 0, 3, 2), 2, 2), widths = c(5, 95), 
        heights = c(95, 5))
 oldmar <- par(mar=rep(0,4))  ## zero out margins so we can plot in sub-boxes without errors
 ## now skip through the first two sub-plots
 par(new=TRUE); plot.new(); par(new=TRUE); plot.new()
 par(oldmar)  ## reset margins
 ## blank plot with user limits set and 'interior' axis calculations
 plot(0:1,0:1,xlab="",ylab="",xlim=uu[1:2],ylim=uu[3:4],xaxs="i",yaxs="i")
 ## add annotation
 abline(a=0,b=1,col=4,lwd=3) scatterplot abline()
-------------------------------------------------------------------------------------------------------
geom_abline(slope=1, intercept=-15)
-------------------------------------------------------------------------------------------------------
# Set a seed to get a reproducible example
set.seed(12345)

num.points <- 100

# Create some data
x.vals <- 1:num.points
values <- rnorm(n=num.points, mean=0, sd=10)

# Plot the graph
plot(x.vals, values, t="o", pch=20, xlab="", ylab="", las=1)
abline(h=0, col="darkgray", lwd=2)

# We need to find the intersections of the curve with the x axis
# Those lie between positive and negative points
# When the sign changes the product between subsequent elements
# will be negative
crossings <- values[-length(values)] * values[-1]
crossings <- which(crossings < 0)

# You can draw the points to check (uncomment following line)
# points(x.vals[crossings], values[crossings], col="red", pch="X")

# We now find the exact intersections using a proportion
# See? Those high school geometry problems finally come in handy
intersections <- NULL
for (cr in crossings)
  {
  new.int <- cr + abs(values[cr])/(abs(values[cr])+abs(values[cr+1]))
  intersections <- c(intersections, new.int)
  }

# Again, let's check the intersections
# points(intersections, rep(0, length(intersections)), pch=20, col="red", cex=0.7)

last.intersection <- 0
for (i in intersections)
  {
  ids <- which(x.vals<=i & x.vals>last.intersection)
  poly.x <- c(last.intersection, x.vals[ids], i)
  poly.y <- c(0, values[ids], 0)
  if (max(poly.y) > 0)
    {
    col="green"
    }
  else
    {
    col="red"
    }
  polygon(x=poly.x, y=poly.y, col=col)

  last.intersection <- i
  }
-------------------------------------------------------------------------------------------------------
rworldmap xlim ylim xlim ylim xlim ylim xlim library(rworldmap)

#worldMap <- getMap(resolution = "high")
#this makes it quicker & illustrates the same thing
worldMap <- getMap(resolution="low")

#fixedLatitude <- c(36.76, 38.76)
#making the latitudinal difference smaller
#so that the longitudinal difference always determines map scale
fixedLatitude <- c(36.76, 37.76)

# Fixed lower limit of the X axis
fixedMinLongitude <- 20.64
# Varying the upper limit of the X axis 
maxLongitudes <- seq(22, 25, length.out = 4)
longitudes <- lapply(maxLongitudes, function(x) c(fixedMinLongitude, x))

#create blank object to store left space
proportionLeftSpace <- seq(0,0, length.out = 4)

#alternative to put all 4 plots together on windows, comment out png & dev.off
#windows()
#op <- par(mfrow = c(2, 2))

countMaps <- 1
for (ln in longitudes){
  png(paste("xlimtest", countMaps, ".png", sep = ""))
  mapCountryData(worldMap,
                 xlim = ln,
                 ylim = fixedLatitude,
                 addLegend = F, mapTitle = "")


  abline(v=ln)
  abline(h=fixedLatitude)

  #from celacanto
  plotRegionMinX <- par("usr")[1]
  spaceBeforeXlim <-  ln[1] -  plotRegionMinX
  onePercentXAxis <- diff(ln)/100
  proportionLeftSpace[countMaps] <- spaceBeforeXlim/onePercentXAxis

  dev.off()
  countMaps <- countMaps + 1
}

proportionLeftSpace proportionLeftSpace
-------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------
x=runif(100,1,5)
y=2*x+rnorm(100)

plot(x,y)
fit=lm(y~x)
abline(fit,col=2)
-------------------------------------------------------------------------------------------------------
x = 1:400
y = x^2
plot(x, y, type="l", col="red")
title(main="Funzioni", col.main="blue", font.main=4) x = 1:400
y = x^2
plot(x, y, type="l", col="red", xlim=c(-400, 400), ylim=c(-16000, 16000))
abline(h=0)
abline(v=0)
title(main="Funzioni", col.main="blue", font.main=4)
-------------------------------------------------------------------------------------------------------
plot(Landsat7 ~ Landsat8)
abline(lm(Landsat7 ~ Landsat8))
-------------------------------------------------------------------------------------------------------
geom_smooth() method="lm" ggplot(d, aes(x, y)) + geom_point() + geom_smooth(method="lm",se=FALSE)+
  scale_y_log10() + scale_x_log10() geom_abline() untf=TRUE abline() geom_line() predict() ggplot(d, aes(x, y)) + geom_point() + 
  geom_line(data=data.frame(x=d$x,y=coef(fit)[1]+coef(fit)[2]*d$x))+
  scale_y_log10() + scale_x_log10()

ggplot(d, aes(x, y)) + geom_point() + 
  geom_line(data=data.frame(x=d$x,y=predict(fit)))+
  scale_y_log10() + scale_x_log10()
-------------------------------------------------------------------------------------------------------
df$YM <- as.Date(paste0("01",df$YearMonth), format="%d%Y%m")
rangeYM <- range(df$YM)

plot(NA,ylim=c(-1,1),xlim=rangeYM,ann=FALSE,axes=FALSE)
abline(h=0,lwd=2,col="#5B7FA3")

ypts <- rep_len(c(-1,1), length.out=nrow(df))
txtpts <- rep_len(c(1,3), length.out=nrow(df))
segments(df$YM,0,df$YM,ypts,col="gray80")

axis.Date(
 1,
 at=seq.Date(rangeYM[1],rangeYM[2],by="month"),
 format="%Y-%m",
 cex.axis=0.6,
 pos=0,
 lwd=0,
 lwd.tick=2,
 col="#5B7FA3",
 font=2
)

points(df$YM,y=ypts, pch="-", cex=1.5, col="#5B7FA3")
par(xpd=NA)
text(
  df$YM, y=ypts,
  labels=paste(df$Person1,df$Person2,df$Event,sep="\n"), cex=0.7, pos=txtpts
)
par(xpd=FALSE)
-------------------------------------------------------------------------------------------------------
?text myloadings= data.frame(Comp.1= c(0.18, -0.5, -.55, 0.6), 
                       Comp.2=c(0.95, 0.22,0.06, -0.13))
rownames(myloadings)=c("MPS", "PC", "Voc", "Arith") plot(myloadings,pch=16,col='blue',xlim=c(-1,1),ylim=c(-1,1))
abline(v=0)
abline(h=0) text(myloadings, labels=rownames(myloadings), adj=2)
-------------------------------------------------------------------------------------------------------
vCenter_slope <- 600.7472
flN <- transform(flN,w=1/as.numeric(timeError_4_8)^2)
# slope fixed
m1 <- lm(as.numeric(arrivalTime_4_8) ~ 1 + offset(vCenter*vCenter_slope), data = flN, weights=w)
# slope chosen by lm(...)
m0 <- lm(as.numeric(arrivalTime_4_8) ~ vCenter, data=flN, weights=w)

library(ggplot2)
ggp <- ggplot(flN)
ggp <- ggp + geom_point(aes(x=vCenter,y=arrivalTime_4_8))
ggp <- ggp + geom_errorbar(aes(x=vCenter, ymin=arrivalTime_4_8-timeError_4_8,ymax=arrivalTime_4_8+timeError_4_8),width=0)
ggp <- ggp + geom_errorbarh(aes(x=vCenter, y=arrivalTime_4_8, xmax=vHigh, xmin=vLow),height=0)
ggp <- ggp + geom_abline(slope=600.7472, intercept=coef(m1)[1])
ggp <- ggp + geom_abline(slope=coef(m0)[2], intercept=coef(m0)[1],color="red")
ggp lm(...) vCenter vCenter
-------------------------------------------------------------------------------------------------------
ggplot # OP's code...
# ...

glist <- sign(datam %*% g)

library(reshape2)  # for melt(...)
library(plyr)      # for .(...)
library(ggplot2)
df <- data.frame(datam,f=ylist,g=glist) # df has columns: X1, X2, X3, f, g
gg <- melt(df,id.vars=c("X1","X2","X3"),variable.name="model")

ggp <- ggplot(gg, aes(x=X2, y=X3, color=factor(value)))
ggp <- ggp + geom_point()
ggp <- ggp + geom_abline(subset=.(model=="f"),intercept=-f[1]/f[3],slope=-f[2]/f[3])
ggp <- ggp + geom_abline(subset=.(model=="g"),intercept=-g[1]/g[3],slope=-g[2]/g[3])
ggp <- ggp + facet_wrap(~model)
ggp <- ggp + scale_color_discrete(name="Mistake")
ggp <- ggp + labs(title=paste0("Comparison of Target (f) and Hypothesis (g) [n=",n,"]"))
ggp <- ggp + theme(plot.title=element_text(face="bold"))
ggp n=200, 500, and 1000 n=100, g=c(1,0,0) n~500 ggplot df X2 and X3 f g melt(...) gg gg X1, X2, X3, model, and value gg$model f or g gg$value ggplot(...) geom_point(...) geom_abline(...) facet_wrap(...)
-------------------------------------------------------------------------------------------------------
baseSum=0.0
Visits = NULL
while(baseSum < 100)
{
  Screen=(rpois (1, lambda=3)) 
  y=runif(Screen,0,1) 
  Base = length(which(y<=0.5))
  baseSum = baseSum + Base
  SF = Screen - Base
  Visits=rbind(Visits,c("Screen"=Screen,"BaseCount"=Base,"SFCount"=SF))    
}
plot(cumsum(Visits[,"BaseCount"]),type="b");grid()
sum(Visits[,"BaseCount"]) tooManyRuns = t(sapply(rpois (110, lambda=3) , function(X) { y=runif(X,0,1); Base = length(which(y<=0.5)); SF = X-Base; return(c("Screen"=X,"BaseCount"=Base,"SFCount"=SF)) } ))
Visits =tooManyRuns[1:min(which(cumsum(tooManyRuns[,"BaseCount"])>=100.0)),]
plot(cumsum(Visits[,"BaseCount"]),type="b");grid()
sum(Visits[,"BaseCount"]) numRunsNeeded = sapply(1:1000,
       function(...)
       {
        tooManyRuns = t(sapply(rpois (110, lambda=3) , function(X) { y=runif(X,0,1); Base = length(which(y<=0.5)); SF = X-Base; return(c("Screen"=X,"BaseCount"=Base,"SFCount"=SF)) } ))
        return(min(which(cumsum(tooManyRuns[,"BaseCount"])>=100.0)))
       } )   

plot(density(numRunsNeeded));rug(numRunsNeeded);abline(v=mean(numRunsNeeded));abline(v=median(numRunsNeeded),lty=2)
-------------------------------------------------------------------------------------------------------
Collimator Head geom_abline() library(plyr)
#subset only firt two values
 df2<-ddply(df,.(Collimator,Head),function(x) head(x,2))
 head(df2)
   A0   T         A Counts    CR Head Collimator
1  76  97  63.45388  99780  3326   H1       HRGP
2 274  98 228.34282 317952 10598   H1       HRGP
3  76  85  64.88609 102830  3428   H2       HRGP
4 274  87 233.06284 328231 10941   H2       HRGP
5  76 328  41.29136 121230  4041   H1       LEGP
6 274 330 148.31347 424329 14144   H1       LEGP

#caclulate slope and intercept
 df3<-ddply(df2,.(Collimator,Head),summarise, int=coefficients(lm(CR~A))[1],
                      slop=coefficients(lm(CR~A))[2])
 df3
  Collimator Head      int      slop
1       HRGP   H1 527.5309  44.10241
2       HRGP   H2 529.3279  44.67324
3       LEGP   H1 143.0519  94.40105
4       LEGP   H2 146.2766  96.95737
5       LEHS   H1 567.3029 155.85205
6       LEHS   H2 694.4843 162.54077

ggplot(df,aes(x=A,y=CR,col=Head))+geom_point()+geom_line() + 
  facet_grid(Collimator~Head, scales="fixed") + 
  scale_x_continuous("Activity [MBq]", expand = c(0,0))+ ylim(0,80000) + 
  ylab("Count Rate [cps]") + 
  theme_bw()+theme(legend.position = "none")+
  geom_abline(data=df3,aes(intercept=int,slope=slop,color=Head))
-------------------------------------------------------------------------------------------------------
ggplot(gg,aes(x=Hour.of.day, y=Distance.travelled)) +
    geom_pointrange(aes(ymin=Distance.travelled-ci,ymax=Distance.travelled+ci,color=Model))+
    facet_grid(Model~.) + 
    stat_smooth(formula=y~1, method="lm",linetype=2,se=F)+
    geom_abline(aes(slope=0,intercept=mean(Distance.travelled)),linetype=3) stat_smooth(...)
-------------------------------------------------------------------------------------------------------
graphics species species = unique(carbon2$Species) # c("Acru", "Arte", ...)
bin.name = c("Acer rubrum", "Arundinaria tecta", "Clethra alnifolia",
             "Eupatorium rotundifolium", "Gaylussacia frondosa", 
             "Ilex glabra", "Lyonia lucida", "Oxydendrum arboreum",
             "Persea palustris")

sites = c(7,8) # sites to use
color = c("blue", "green") # colors for each site

fit.bio = list() # list to save all models

par(mfrow=c(3,3), cex=.3) 

for(isp in seq_along(species)) {

  sp.data = carbon2[carbon2$Species==species[isp], ] 

  fit.bio[[isp]] <- lm(LogRecBio ~ LogPreBiomass, data=sp.data)

  sp.label     = paste(letters[isp], ") ", bin.name[isp], sep="")
  sp.r.squared = paste("R²", "=", round(summary(fit.bio[[isp]])$adj.r.squared, 3))
  plot(LogRecBio ~ LogPreBiomass, data=sp.data, 
       font.lab=2,font.main=2, font.sub=3, ylim=c(-5,4),
       mgp=c(2.5,1,0), cex.lab=2, cex.main=1.5, 
       axes=FALSE, lwd=1.5, cex=2.5, ann=FALSE)

  for(isite in seq_along(sites)) {
    # loop for each selected site
    site.data  = sp.data[sp.data$site==sites[isite], ]
    site.model = lm(LogRecBio ~ LogPreBiomass, data=site.data)
    abline(site.model, lwd=2, col=color[isite])

  }

  abline(fit.bio[[isp]], lwd=2, col='red') # all data

  axis(1,at=c(-2,-1,0,1,2,3,4),font=2,cex.axis=3)
  axis(2,at=c(-5,-4,-3,-2,-1,0,1,2),font=2,cex.axis=3)
  box()

  mtext(sp.label, 3, line=-2.5, adj=0.05, font=3, cex=0.75)
  mtext(sp.r.squared, 3, line=-2.5, adj=0.95, cex=0.75)

}
-------------------------------------------------------------------------------------------------------
x <- seq(0,10,by=2)
y <- seq(0, 30, by=10)
grid <- expand.grid(x, y)
N <- 100
points <- cbind(runif(N, 0, 10), runif(N, 0, 30))

plot(grid, t="n", xaxs="i", yaxs="i")
points(points, col="blue", pch="+") 
abline(v=x, h=y)

binxy <- data.frame(x=findInterval(points[,1], x),
                    y=findInterval(points[,2], y))

(results <- table(binxy))
d <- as.data.frame.table(results)
xx <- x[-length(x)] + 0.5*diff(x)
d$x <- xx[d$x]
yy <- y[-length(y)] + 0.5*diff(y)
d$y <- yy[d$y]
with(d, text(x, y, label=Freq))
-------------------------------------------------------------------------------------------------------
y/x glm(...) (y/x) glm(...) y/(y+(x-y)) = y/x fit = glm(cbind(y,x-y)~x+z, data=mydata, family=binomial(logit))
summary(fit)
# Call:
# glm(formula = cbind(y, x - y) ~ x + z, family = binomial(logit), 
#     data = mydata)

# Deviance Residuals: 
#        1         2         3         4         5         6  
# -0.59942  -0.35394   0.62705   0.08405  -0.75590   0.81160  

# Coefficients:
#             Estimate Std. Error z value Pr(>|z|)  
# (Intercept)  -2.0264     1.2177  -1.664   0.0961 .
# x             0.6786     0.2695   2.518   0.0118 *
# z            -0.2778     0.1933  -1.437   0.1507  
# ---
# Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

# (Dispersion parameter for binomial family taken to be 1)

#     Null deviance: 13.7587  on 5  degrees of freedom
# Residual deviance:  2.1149  on 3  degrees of freedom
# AIC: 15.809

par(mfrow=c(2,2))
plot(fit)         # residuals, Q-Q, Scale-Location, and Leverage Plots mydata$pred <- predict(fit, type="response")
par(mfrow=c(1,1))
plot(mydata$y/mydata$x,mydata$pred,xlim=c(0,1),ylim=c(0,1), xlab="Actual", ylab="Predicted")
abline(0,1, lty=2, col="blue")
-------------------------------------------------------------------------------------------------------
axisG <- function(side, ...){
  if (side == "top"){
    at <- unique(test$GROUP)
    panel.axis(side = side, outside = TRUE, at = at, labels = at, rot = 0)
  }
  else axis.default(side = side, ...) 
}

plot(hexbinplot(test$VAR1 ~ test$VAR2,
                axis = axisG,
                panel = function(...){
                  panel.hexbinplot(...)
                  panel.abline(v = test$GROUP)}
))
-------------------------------------------------------------------------------------------------------
