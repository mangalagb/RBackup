valact <- subset(val, variable=='actual')
valsort <- valact[ order(-valact[,"Value"]),] boxplot() op <- par(mar=c(3,3,3,3)) 
bp <- barplot(valsort [ , "Value"], ylab="", xlab="", ylim=c(0,1),    
              names.arg=as.character(valsort[,"State"]), main="How's that?") 
lines(bp, cumsum(valsort[,"Value"])/sum(valsort[,"Value"]), 
      ylim=c(0,1.05), col='red') 
axis(4)
box() 
par(op) lines()
-------------------------------------------------------------------------------------------------------
x <- seq(as.POSIXct("1949-01-01", tz="GMT"), length=36, by="months")
y <- rnorm(length(x))

plot(x, y, type="l", xaxt="n")
rect(xleft=as.POSIXct("1950-01-01", tz="GMT"),
     xright=as.POSIXct("1950-12-01", tz="GMT"),
     ybottom=-4, ytop=4, col="#123456A0") # use alpha value in col
idx <- seq(1, length(x), by=6)
axis(side=1, at=x[idx], labels=format(x[idx], "%Y-%m")) plot(x, y, type="n", xaxt="n")
rect(xleft=as.POSIXct("1950-01-01", tz="GMT"),
     xright=as.POSIXct("1950-12-01", tz="GMT"),
     ybottom=-4, ytop=4, col="lightblue")
lines(x, y)
idx <- seq(1, length(x), by=6)
axis(side=1, at=x[idx], labels=format(x[idx], "%Y-%m"))
box()
-------------------------------------------------------------------------------------------------------
## create a long monthly sequence and a sub-sequence
months <- seq( as.Date("1950-01-01"), as.Date("2009-12-12"), by="month")
subset <- seq( as.Date("1970-01-01"), as.Date("1979-12-31"), by="month")

## generate some random values
set.seed(42)
values <- cumsum(rnorm(length(months)))

## plot as a zoo object, overlay a gray background and overplot a line in red
library(zoo)
Z <- zoo(values, months)
plot(Z)
rect(xleft=head(subset,1), xright=tail(subset,1),
     ybottom=par("usr")[3], ytop=par("usr")[4],
     density=NA, col="lightgray")
lines(Z[subset], col='red')
box() par("usr") zoo
-------------------------------------------------------------------------------------------------------
require(gplots) 

# example data, bivariate normal, no correlation
x <- rnorm(2000, sd=4) 
y <- rnorm(2000, sd=1) 

# separate scales for each axis, this looks circular
hist2d(x,y, nbins=50, col = c("white",heat.colors(16))) 
rug(x,side=1) 
rug(y,side=2) 
box() library("geneplotter")  ## from BioConductor
require("RColorBrewer") ## from CRAN

x1  <- matrix(rnorm(1e4), ncol=2)
x2  <- matrix(rnorm(1e4, mean=3, sd=1.5), ncol=2)
x   <- rbind(x1,x2)

layout(matrix(1:4, ncol=2, byrow=TRUE))
op <- par(mar=rep(2,4))
smoothScatter(x, nrpoints=0)
smoothScatter(x)
smoothScatter(x, nrpoints=Inf,
              colramp=colorRampPalette(brewer.pal(9,"YlOrRd")),
              bandwidth=40)
colors  <- densCols(x)
plot(x, col=colors, pch=20)

par(op)
-------------------------------------------------------------------------------------------------------
shpFile <- system.file("shapes/sids.shp", package="maptools");  
  shp<-importShapefile(shpFile,projection="LL");  
  bb <- qbbox(lat = shp[,"Y"], lon = shp[,"X"]);  
  MyMap <- GetMap.bbox(bb$lonR, bb$latR, destfile = "SIDS.jpg");  
  #compute regularized SID rate  
  sid <- 100*attr(shp, "PolyData")$SID74/(attr(shp, "PolyData")$BIR74+500)  
  b <- as.integer(cut(sid, quantile(sid, seq(0,1,length=8)) ));  
  b[is.na(b)] <- 1;  
  opal <- col2rgb(grey.colors(7), alpha=TRUE)/255;  opal["alpha",] <- 0.2;  
  shp[,"col"] <- rgb(0.1,0.1,0.1,0.2);  
  for (i in 1:length(b)) shp[shp[,"PID"] == i,"col"] <- rgb(opal[1,b[i]],opal[2,b[i]],opal[3,b[i]],opal[4,b[i]]);  
  PlotPolysOnStaticMap(MyMap, shp, lwd=.5, col = shp[,"col"], add = F);
-------------------------------------------------------------------------------------------------------
# functions we'll need...
add.num.before.and.after <- function(vec, num = NULL)
{
    # this will add a number before and after every number in a vector.
    # the deafult adds the number which is one more then the length of the vector 
        # assuming that later we will add a zero column to a data.frame and will use that column to add the zero columns...
    if(is.null(num)) num <- rep(length(vec) +1, length(vec))
    if(length(num)==1) num <- rep(num, length(vec))

    #x <- as.list(vec)
    list.num.x.num <- sapply(seq_along(vec) , function(i) c(num[i], vec[i], num[i]),  simplify = F)
    num.x.num <- unlist(list.num.x.num)

    return(num.x.num)
}

add.0.columns.to.DF <- function(DF, zero.column.name = " ")
{
    # this function gets a data frame
    # and returns a data.frame with extra two columns (of zeros) before and after every column

    zero.column <- rep(0, dim(DF)[1])   # the column of zeros
    column.seq <- seq_len(dim(DF)[2])   # the column ID for the original data.frame

    DF.new.order <- add.num.before.and.after(column.seq)    # add the last column id before and after every element in the column id vector

    DF.and.zero <- cbind(DF, zero.column)   # making a new data.frame with a zero column at the end

    new.DF <- DF.and.zero[,DF.new.order]    # moving the zero column (and replicating it) before and after every column in the data.frame

    # renaming the zero columns to be " "
    columns.to.erase.names <- ! (colnames(new.DF) %in% colnames(DF))        
    colnames(new.DF)[columns.to.erase.names] <- zero.column.name

    return(new.DF)
}


angles.by.weight <-  function(angles,  weights = NULL)
{

    angles <- angles[-1]    # remove the 0 from "angles"
    angles <- c(angles, 2*pi) # add last slice angle
    number.of.slices = length(angles)
    if(is.null(weights)) weights <- rep(.6, number.of.slices)   # Just for the example

    slice.angle <- diff(angles)[1]

    #new.angles <- rep(0, 3*length(angles))
    new.angles <- numeric()

    for(i in seq_along(angles))
    {
        weighted.slice.angle <- slice.angle*weights[i]
        half.leftover.weighted.slice.angle <- slice.angle* ((1-weights[i])/2)

        angle1 <- angles[i] - (weighted.slice.angle + half.leftover.weighted.slice.angle)
        angle2 <- angles[i] - half.leftover.weighted.slice.angle
        angle3 <- angles[i]

        new.angles <- c(new.angles,
                        angle1,angle2,angle3)                       
    }

    new.angles.length <- length(new.angles)
    new.angles <- c(0, new.angles[-new.angles.length])

    return(new.angles)
}

# The updated stars function
stars2 <-
    function (x, full = TRUE, scale = TRUE, radius = TRUE, labels =
            dimnames(x)[[1L]], 
                locations = NULL, nrow = NULL, ncol = NULL, len = 1, key.loc = NULL, 
                key.labels = dimnames(x)[[2L]], key.xpd = TRUE, xlim = NULL, 
                ylim = NULL, flip.labels = NULL, draw.segments = FALSE, col.segments = 1L:n.seg, 
                col.stars = NA, axes = FALSE, frame.plot = axes, main = NULL, 
                sub = NULL, xlab = "", ylab = "", cex = 0.8, lwd = 0.25, 
                lty = par("lty"), xpd = FALSE, mar = pmin(par("mar"), 1.1 + 
                    c(2 * axes + (xlab != ""), 2 * axes + (ylab != ""), 1, 
            #            0)), add = FALSE, plot = TRUE, ...) 
                        0)), add = FALSE, plot = TRUE, col.radius = NA, polygon = TRUE, 
                        key.len = len,
                        segment.weights = NULL, 
                        ...)
{
    if (is.data.frame(x)) 
        x <- data.matrix(x)
    else if (!is.matrix(x)) 
        stop("'x' must be a matrix or a data frame")
    if (!is.numeric(x)) 
        stop("data in 'x' must be numeric")


    # this code was moved here so that the angles will be proparly created...
    n.seg <- ncol(x) # this will be changed to the ncol of the new x - in a few rows...
    # creates the angles
    angles <- if (full) 
        seq.int(0, 2 * pi, length.out = n.seg + 1)[-(n.seg + 1)]
    else if (draw.segments) 
        seq.int(0, pi, length.out = n.seg + 1)[-(n.seg + 1)]
    else seq.int(0, pi, length.out = n.seg)
    if (length(angles) != n.seg) 
        stop("length of 'angles' must equal 'ncol(x)'")

    # changing to allow weighted segments
    angles <- angles.by.weight(angles, segment.weights)
    #angles <- angles.by.weight.2(angles)   # try2
    # try3 
    # weights <- sample(c(.3,.9), length(angles)-1, replace = T)
    # angles <- weights / sum(weights) * 2 * pi
    # angles <- c(0,angles )




    # changing to allow weighted segments
     col.segments <- add.num.before.and.after(col.segments, "white") # for colors
     x <- add.0.columns.to.DF(x)







    n.loc <- nrow(x)
    n.seg <- ncol(x)
    if (is.null(locations)) {
        if (is.null(nrow)) 
            nrow <- ceiling(if (!is.numeric(ncol)) sqrt(n.loc) else n.loc/ncol)
        if (is.null(ncol)) 
            ncol <- ceiling(n.loc/nrow)
        if (nrow * ncol < n.loc) 
            stop("nrow * ncol <  number of observations")
        ff <- if (!is.null(labels)) 
            2.3
        else 2.1
        locations <- expand.grid(ff * 1L:ncol, ff * nrow:1)[1L:n.loc, 
            ]
        if (!is.null(labels) && (missing(flip.labels) ||
!is.logical(flip.labels))) 
            flip.labels <- ncol * mean(nchar(labels, type = "c")) > 
                30
    }
    else {
        if (is.numeric(locations) && length(locations) == 2) {
            locations <- cbind(rep.int(locations[1L], n.loc), 
                rep.int(locations[2L], n.loc))
            if (!missing(labels) && n.loc > 1) 
                warning("labels do not make sense for a single location")
            else labels <- NULL
        }
        else {
            if (is.data.frame(locations)) 
                locations <- data.matrix(locations)
            if (!is.matrix(locations) || ncol(locations) != 2) 
                stop("'locations' must be a 2-column matrix.")
            if (n.loc != nrow(locations)) 
                stop("number of rows of 'locations' and 'x' must be equal.")
        }
        if (missing(flip.labels) || !is.logical(flip.labels)) 
            flip.labels <- FALSE
    }
    xloc <- locations[, 1]
    yloc <- locations[, 2]

    # Here we created the angles, but I moved it to the beginning of the code


    if (scale) {
        x <- apply(x, 2L, function(x) (x - min(x, na.rm = TRUE))/diff(range(x, 
            na.rm = TRUE)))
    }
    x[is.na(x)] <- 0
    mx <- max(x <- x * len)
    if (is.null(xlim)) 
        xlim <- range(xloc) + c(-mx, mx)
    if (is.null(ylim)) 
        ylim <- range(yloc) + c(-mx, mx)
    deg <- pi/180
    op <- par(mar = mar, xpd = xpd)
    on.exit(par(op))
    if (plot && !add) 
        plot(0, type = "n", ..., xlim = xlim, ylim = ylim, main = main, 
            sub = sub, xlab = xlab, ylab = ylab, asp = 1, axes = axes)
    if (!plot) 
        return(locations)
    s.x <- xloc + x * rep.int(cos(angles), rep.int(n.loc, n.seg))
    s.y <- yloc + x * rep.int(sin(angles), rep.int(n.loc, n.seg))
    if (draw.segments) {
        aangl <- c(angles, if (full) 2 * pi else pi)
        for (i in 1L:n.loc) {
            px <- py <- numeric()
            for (j in 1L:n.seg) {
                k <- seq.int(from = aangl[j], to = aangl[j + 
                  1], by = 1 * deg)
                px <- c(px, xloc[i], s.x[i, j], x[i, j] * cos(k) + 
                  xloc[i], NA)
                py <- c(py, yloc[i], s.y[i, j], x[i, j] * sin(k) + 
                  yloc[i], NA)
            }
            polygon3(px, py, col = col.segments, lwd = lwd, lty = lty)
        }
    }
    else {
        for (i in 1L:n.loc) {
#            polygon3(s.x[i, ], s.y[i, ], lwd = lwd, lty = lty, 
#                col = col.stars[i])
            if (polygon)
                polygon3(s.x[i, ], s.y[i, ], lwd = lwd, lty = lty, 
                  col = col.stars[i])
            if (radius) 
                segments(rep.int(xloc[i], n.seg), rep.int(yloc[i], 
#                  n.seg), s.x[i, ], s.y[i, ], lwd = lwd, lty = lty)
                  n.seg), s.x[i, ], s.y[i, ], lwd = lwd, lty = lty, col =
col.radius)
        }
    }
    if (!is.null(labels)) {
        y.off <- mx * (if (full) 
            1
        else 0.1)
        if (flip.labels) 
            y.off <- y.off + cex * par("cxy")[2L] * ((1L:n.loc)%%2 - 
                if (full) 
                  0.4
                else 0)
        text(xloc, yloc - y.off, labels, cex = cex, adj = c(0.5, 
            1))
    }
    if (!is.null(key.loc)) {
        par(xpd = key.xpd)
        key.x <- key.len * cos(angles) + key.loc[1L]
        key.y <- key.len * sin(angles) + key.loc[2L]
        if (draw.segments) {
            px <- py <- numeric()
            for (j in 1L:n.seg) {
                k <- seq.int(from = aangl[j], to = aangl[j + 
                  1], by = 1 * deg)
                px <- c(px, key.loc[1L], key.x[j], key.len * cos(k) + 
                  key.loc[1L], NA)
                py <- c(py, key.loc[2L], key.y[j], key.len * sin(k) + 
                  key.loc[2L], NA)
            }
            polygon3(px, py, col = col.segments, lwd = lwd, lty = lty)
        }
        else {
#            polygon3(key.x, key.y, lwd = lwd, lty = lty)
            if (polygon)
                polygon3(key.x, key.y, lwd = lwd, lty = lty)
            if (radius) 
                segments(rep.int(key.loc[1L], n.seg), rep.int(key.loc[2L], 
#                  n.seg), key.x, key.y, lwd = lwd, lty = lty)
                  n.seg), key.x, key.y, lwd = lwd, lty = lty, col = col.radius)
        }


        lab.angl <- angles + if (draw.segments) 
            (angles[2L] - angles[1L])/2
        else 0
        label.x <- 1.1 * key.len * cos(lab.angl) + key.loc[1L]
        label.y <- 1.1 * key.len * sin(lab.angl) + key.loc[2L]
        for (k in 1L:n.seg) {
            text.adj <- c(if (lab.angl[k] < 90 * deg || lab.angl[k] > 
                270 * deg) 0 else if (lab.angl[k] > 90 * deg && 
                lab.angl[k] < 270 * deg) 1 else 0.5, if (lab.angl[k] <= 
                90 * deg) (1 - lab.angl[k]/(90 * deg))/2 else if (lab.angl[k] <=
                270 * deg) (lab.angl[k] - 90 * deg)/(180 * deg) else 1 - 
                (lab.angl[k] - 270 * deg)/(180 * deg))
            text(label.x[k], label.y[k], labels = key.labels[k], 
                cex = cex, adj = text.adj)
        }
    }
    if (frame.plot) 
        box(...)
    invisible(locations)
} #require(debug)
# mtrace(stars2)
stars(mtcars[1:3, 1:8],
        draw.segments = T,
        main = "Motor Trend Cars : stars(*, full = F)", full = T, col.segments = 1:2)

stars2(mtcars[1:3, 1:8],
        draw.segments = T,
        main = "Motor Trend Cars : stars(*, full = F)", full = T, col.segments = 0:3,
        segment.weights = c(.2,.2,1,1,.4,.4,.6,.9))
-------------------------------------------------------------------------------------------------------
require(ggplot2)


## a simple web page
w <- gwindow("Make a neat graph")
g <- ggroup(cont=w, horizontal=FALSE)
glabel("Select a  data frame to produce a graph", cont=g)
cb <- gcombobox(names(mapNameToFile), selected=-1, cont=g)
f <- gframe("Summary", cont=g)
t <- ghtml("", cont=g)
f <- gframe("Plot", cont=g)
ourDevice <- gsvg(width=500, height=500, cont=f)

addHandlerChanged(cb, handler=function(h,...) {
  makePlot(svalue(h$obj))
})

visible(w) <- TRUE

## Below here you must change to suit your application:
## example of map from names to some other object
mapNameToFile <- list("mtcars"=mtcars,
                      "CO2" = CO2)
## your main function
makePlot <- function(nm) {
  df <- mapNameToFile[[nm]]
  if(is.null(df)) {
    galert(sprintf("Can't find file %s", nm))
    return()
  }
  ## your plot
  p <- qplot(df[,1], df[,2])
  ## put into svg device
  f <- getStaticTmpFile(ext=".svg")
  require(RSVGTipsDevice, quietly=TRUE, warn=FALSE)
  devSVGTips(f)
  print(p)
  dev.off()
  svalue(ourDevice) <- f
  ## write a summary
  svalue(t) <- paste("<pre>",
                     paste(capture.output(summary(df)), collapse="<br>"),
                     "</pre>",
                     sep="")
}
-------------------------------------------------------------------------------------------------------
ttkcombobox require(tcltk)
tt <- tktoplevel()
tkwm.title(tt, "Fruits!")
tkwm.geometry(tt, "200x150+300+300") 

onOK <- function()
    {
    fav <- tclvalue(favFruit)
    worst <- tclvalue(worstFruit)

    if (fav != "Choose one")
        tkmessageBox(title="Favorite fruit", message = paste("Your favorite fruit is", fav))
    if (worst != "Choose one")
        tkmessageBox(title="Worst fruit", message = paste("The fruit you like the least is", worst))

    if (fav == "Choose one" & worst == "Choose one")
        tkmessageBox(title="Well...", message = "Select a fruit!")
    }

label1 <- tklabel(tt, text="What's your favorite fruit?")
label2 <- tklabel(tt, text="What fruit you like the least?")

fruits <- c("Choose one", "Apple", "Orange", "Banana", "Pear")
# Default selections for the two combo boxes
favFruit <- tclVar("Choose one")
worstFruit <- tclVar("Choose one")

# 1st box
combo.1 <- ttkcombobox(tt, values=fruits, textvariable=favFruit, state="readonly") 
# 2nd box
combo.2 <- ttkcombobox(tt, values=fruits, textvariable=worstFruit, state="readonly") 
# If you need to do something when the user changes selection just use
# tkbind(combo.1, "<<ComboboxSelected>>", functionname)

OK.but <- tkbutton(tt,text="   OK   ", command = onOK)

tkpack(label1, combo.1)
tkpack(label2, combo.2)
tkpack(OK.but)

tkfocus(tt) tcltk RGtk2
-------------------------------------------------------------------------------------------------------
library(gWidgets)
options(guiToolkit="tcltk") ## or RGtk2 or Qt

w <- gwindow("Multiple comboboxes")
tbl <- glayout(cont=w, horizontal=FALSE)

fruit <- c("Apple","Orange","Banana","Pear")


tbl[1,1] <- "Favorite fuits"
tbl[1,2] <- (cb1 <- gcombobox(fruit, cont=tbl))

tbl[2,1] <- "Other fruit?"
tbl[2,2] <- (cb2 <- gcombobox(fruit, cont=tbl))

tbl[3,2] <- (b <- gbutton("Ok", cont=tbl))

addHandlerClicked(b, handler=function(h,...) {
  cat(sprintf("You picked %s and %s\n", svalue(cb1), svalue(cb2)))
})
-------------------------------------------------------------------------------------------------------
"date","sunrise"
2009-01-01,05:31
2009-01-02,05:31
2009-01-03,05:33
2009-01-05,05:34
2009-01-06,05:35
2009-01-07,05:36
2009-01-08,05:37
2009-01-09,05:38
2009-01-10,05:39
2009-01-11,05:40
2009-01-12,05:40
2009-01-13,05:41 read.csv() colClasses dat <- read.csv("foo.txt", colClasses = "character")
## Now convert the imported data to appropriate types
dat <- within(dat, {
date <- as.Date(date) ## no need for 'format' argument as data in correct format
sunrise <- as.POSIXct(sunrise, format = "%H:%M")
})
str(dat) plot(sunrise ~ date, data = dat)
## or
with(dat, plot(date, sunrise)) axis.FOO FOO Date POSIXct plot(sunrise ~ date, data = dat, axes = FALSE)
with(dat, axis.POSIXct(x = sunrise, side = 2, format = "%H:%M"))
with(dat, axis.Date(x = date, side = 1))
box() ## complete the plot frame
-------------------------------------------------------------------------------------------------------
plot(1:10, 1:10, axes = FALSE)
axis(side = 1, at = c(1,5,10))
axis(side = 2, at = c(1,3,7,10))
box()
-------------------------------------------------------------------------------------------------------
> d <- qplot(carat, price, data=dsamp, colour=clarity) +
+  scale_color_hue("clarity") +
+  guide_legends_box("clarity",horizontal=T)
-------------------------------------------------------------------------------------------------------
... plot legend legend foo.plot <- function(x,y,...) {
    plot(x,y,...)
    legend("bottomleft", "bar", pch = 1, ...)
} > foo.plot(1, 1, xjust = 0.5)
Warning messages:
1: In plot.window(...) : "xjust" is not a graphical parameter
2: In plot.xy(xy, type, ...) : "xjust" is not a graphical parameter
3: In axis(side = side, at = at, labels = labels, ...) :
  "xjust" is not a graphical parameter
4: In axis(side = side, at = at, labels = labels, ...) :
  "xjust" is not a graphical parameter
5: In box(...) : "xjust" is not a graphical parameter
6: In title(...) : "xjust" is not a graphical parameter plot.default axis box localPlot() plot() bar.plot <- function(x, y, pch = 1, ...) {
    localPlot <- function(..., legend, fill, border, angle, density,
                          xjust, yjust, x.intersp, y.intersp,
                          text.width, text.col, merge, trace, plot = TRUE, ncol,
                          horiz, title, inset, title.col, box.lwd,
                          box.lty, box.col, pt.bg, pt.cex, pt.lwd) plot(...)
    localPlot(x, y, pch = pch, ...)
    legend(x = "bottomleft", legend = "bar", pch = pch, ...)
} 'plot' TRUE bar.plot(1, 1, xjust = 0.5, title = "foobar", pch = 3) bty bty 'pch' bar.plot() 'pch' lme() la.args <- function(x = "bottomleft", legend = "bar", pch = 1, ...)
    c(list(x = x, legend = legend, pch = pch), list(...))

foo.plot <- function(x,y, legend.args = la.args(), ...) {
    plot(x, y, ...)
    do.call(legend, legend.args)
} foo.plot(1,1, xaxt = "n", legend.args=la.args(bg = "yellow", title = "legend")) la.args() la.args()
-------------------------------------------------------------------------------------------------------
set.seed(1001)
tmpf <- function() {
  duration <- rpois(500, 10) # For duration data I assume Poisson distributed
  hist(duration,
       probability = TRUE, # In stead of frequency
       breaks = "FD",      # For more breaks than the default
       col = "darkslategray4", border = "seashell3",
       main="",ann=FALSE,axes=FALSE,xlim=c(0,25),ylim=c(0,0.15))
  box()
  lines(density(duration),   # Add the kernel density estimate
        col = "firebrick2", lwd = 3)
  par(new=TRUE)
  plot(table(factor(duration,levels=0:25))/length(duration),
       xlim=c(0,25),ylim=c(0,0.15),col=4,ann=FALSE,axes=FALSE)
}

par(mfrow=c(3,3),mar=rep(0,4))
replicate(9,tmpf())
-------------------------------------------------------------------------------------------------------
x <- 10*(1:nrow(volcano))
 y <- 10*(1:ncol(volcano))
 image(x, y, volcano, col = terrain.colors( length(seq(90, 200, by = 5))-1), axes = FALSE, breaks= seq(90, 200, by = 5) )
 axis(1, at = seq(100, 800, by = 100))
 axis(2, at = seq(100, 600, by = 100))
 box()
 title(main = "Maunga Whau Volcano", font.main = 4)



 x <- 10*(1:nrow(volcano))
 y <- 10*(1:ncol(volcano))
 image(x, y, volcano, col = terrain.colors( length(seq(150, 200, by = 5))-1), axes = FALSE, breaks= seq(150, 200, by = 5) )
 axis(1, at = seq(100, 800, by = 100))
 axis(2, at = seq(100, 600, by = 100))
 box()
 title(main = "Maunga Whau Volcano Restricted to elevations above 150", font.main = 4)
-------------------------------------------------------------------------------------------------------
plot.TukeyHSD2 <- function (x, ...) {
    for (i in seq_along(x)) {
        xi <- x[[i]][, -4, drop = FALSE]
        yvals <- nrow(xi):1
        plot(c(xi[, "lwr"], xi[, "upr"]), rep.int(yvals, 2), 
            type = "n", axes = FALSE, xlab = "", ylab = "", ...)
        axis(1, ...)
        axis(2, at = nrow(xi):1, labels = dimnames(xi)[[1L]], 
            srt = 0, ...)
        abline(h = yvals, lty = 1, lwd = 1, col = "lightgray")
        abline(v = 0, lty = 2, lwd = 1, ...)
        segments(xi[, "lwr"], yvals, xi[, "upr"], yvals, col="black", ...)
        segments(as.vector(xi), rep.int(yvals - 0.1, 3), as.vector(xi), 
            rep.int(yvals + 0.1, 3), col="black", ...)
        title(main = paste(format(100 * attr(x, "conf.level"), 
            2), "% family-wise confidence level\n", sep = ""), 
            xlab = paste("Differences in mean levels of", names(x)[i]))
        box()
    }
}
-------------------------------------------------------------------------------------------------------
plot(), lines(), abline(), points(), polygon(), segments(), rect(), box(), arrows(), ... set.seed(100)
x <- 1:10
y <- x^2
y2 <- x^3
yse <- abs(runif(10,2,4))

plot(x,y, type = "n")  # type="n" only plots the pane, no curves or points.

# plots the area between both curves
polygon(c(x,sort(x,decreasing=T)),c(y,sort(y2,decreasing=T)),col="grey")
# plot both curves
lines(x,y,col="purple")
lines(x, y2, col = "red")
# add the points to the first curve
points(x, y, col = "black")
# adds some lines indicating the standard error
segments(x,y,x,y+yse,col="blue")
# adds some flags indicating the standard error
arrows(x,y,x,y-yse,angle=90,length=0.1,col="darkgreen")
-------------------------------------------------------------------------------------------------------
import matplotlib.pyplot as PLT
from matplotlib.offsetbox import AnnotationBbox, OffsetImage
from matplotlib._png import read_png

fig = PLT.gcf()
fig.clf()
ax = PLT.subplot(111)

# add a first image
arr_hand = read_png('/path/to/this/image.png')
imagebox = OffsetImage(arr_hand, zoom=.1)
xy = [0.25, 0.45]               # coordinates to position this image

ab = AnnotationBbox(imagebox, xy,
    xybox=(30., -30.),
    xycoords='data',
    boxcoords="offset points")                                  
ax.add_artist(ab)

# add second image
arr_vic = read_png('/path/to/this/image2.png')
imagebox = OffsetImage(arr_vic, zoom=.1)
xy = [.6, .3]                  # coordinates to position 2nd image

ab = AnnotationBbox(imagebox, xy,
    xybox=(30, -30),
    xycoords='data',
    boxcoords="offset points")
ax.add_artist(ab)

# rest is just standard matplotlib boilerplate
ax.grid(True)
PLT.draw()
PLT.show()
-------------------------------------------------------------------------------------------------------
depth.class <- cut(quakes$depth, c(40, 120, 200, 300, 400, 500, 600, 680), include.lowest = TRUE) mean.mag <- tapply(quake$mag, depth.class, mean) mean.mag <- tapply(quake$mag, depth.class, mean, na.rm = TRUE) plot(mean.mag, type = "l", xlab = "magnitude class") plot(mean.mag, type = "l", xlab = "magnitude class", axes = FALSE)
axis(1, 1:nlevels(depth.class), levels(depth.class))
axis(2)
box()
-------------------------------------------------------------------------------------------------------
## dummy data
dat <- data.frame(Depth = sample(c(3:6), 20, replace = TRUE), OM = 5 * runif(20)) side = 2 ## margin for side 2 is 7 lines in size
op <- par(mar = c(5,7,4,2) + 0.1) ## default is c(5,4,4,2) + 0.1 ## draw the plot but without annotation
boxplot(OM ~ Depth, data = dat, axes = FALSE, ann = FALSE)
## add axes
axis(1, at = 1:4, labels = c(" ", "Shallow", "Deep", " "), cex.axis = 1.5)
axis(2, cex.axis = 2)
## now draw the y-axis annotation on a different line out from the plot
## using the extra margin space:
title(ylab = "Loss of Percent Organic Matter per Year", cex.lab = 1.5,
      line = 4.5)
## draw the box to finish off
box() par(op) ylab op <- par(mar = c(5,7,4,2) + 0.1) ## default is c(5,4,4,2) + 0.1 op title() title(ylab = "Loss of Percent Organic Matter per Year", cex.lab = 1.5,
      line = 4.5) 4.5 5 'line' 'line' title()
-------------------------------------------------------------------------------------------------------
require(MASS)
set.seed(1)
dat <- data.frame(mvrnorm(100, mu = c(2,6,3), 
                          Sigma = matrix(c(10,   2,   4,
                                            2,   3, 0.5,
                                            4, 0.5,   2), ncol = 3))) dij <- dist(scale(dat, center = TRUE, scale = TRUE)) clust <- hclust(dij, method = "average") ord <- order(cutree(clust, k = 3)) coph <- cophenetic(clust) layout(matrix(1:4, ncol = 2))
image(as.matrix(dij)[ord, ord], main = "Original distances")
image(as.matrix(coph)[ord, ord], main = "Cophenetic distances")
image((as.matrix(coph) - as.matrix(dij))[ord, ord], 
      main = "Cophenetic - Original")
plot(coph ~ dij, ylab = "Cophenetic distances", xlab = "Original distances",
     main = "Shepard Plot")
abline(0,1, col = "red")
box()
layout(1)
-------------------------------------------------------------------------------------------------------
set.seed(1)
baseball <- data.frame(pitchNumber = seq_len(50),
                       outcome = factor(sample(c("B","H","S","S","X","H"), 
                                               50, replace = TRUE)))
> head(baseball)
  pitchNumber outcome
1           1       H
2           2       S
3           3       S
4           4       H
5           5       H
6           6       H ## better colours - like ggplot for the cool kids
##cols <- c("red","green","blue","yellow")
cols <- head(hcl(seq(from = 0, to = 360,
                    length.out = nlevels(with(baseball, outcome)) + 1), 
                 l = 65, c = 100), -1) pitchNumber type = "h" with(baseball, plot(pitchNumber, y = rep(1, length(pitchNumber)), type = "h", 
                    ylim = c(0, 1.2), col = cols[outcome],
                    ylab = "", xlab = "Pitch", axes = FALSE, lwd = 2))
with(baseball, points(pitchNumber, y = rep(1, length(pitchNumber)), pch = 16, 
                      col = cols[outcome])) axis(side = 1)
box()
## note: this assumes that the levels are in alphabetical order B,H,S,X...
legend("topleft", legend = c("Ball","Hit","Swinging Strike","X??"), lty = 1,
       pch = 16, col = cols, bty = "n", ncol = 2, lwd = 2)
-------------------------------------------------------------------------------------------------------
Date dates tbl <- within(tbl, Date <- as.Date(Date, "%d/%m/%Y")) op <- par(mar = c(6,4,4,2) + 0.1) ## larger bottom margin
## plot data but suppress axes and annotation
plot(Version ~ Date, data = tbl, type = "o", axes = FALSE, ann = FALSE)
## Use Axis to plot the Date axis, in 1 month increments
## format the sequence of dates `ds` as abbreviated month name and Year
with(tbl, Axis(Date, at = (ds <- seq(min(Date), max(Date), by = "months")),
               side = 1, labels = format(ds, format = "%b %Y"), las = 2))
## Add y-axis and plot frame
axis(2)
box()
## add on the axis labels
title(ylab = "Version", main = "Releases")
title(xlab = "Date", line = 5) ## pushing the x-axis label down a bit
par(op) ## reset the pars with(tbl, Axis(Date, at = (ds <- seq(min(Date), max(Date), by = "2 months")),
               side = 1, labels = format(ds, format = "%b %y"), las = 2)) with(....)
-------------------------------------------------------------------------------------------------------
axes = FALSE plot() plot(x, y, type="h", log="xy", axes = FALSE) axis(side = 1, at = (locs <- 1/c(1,10,100,1000)), labels = locs)
axis(side = 2)
box() tcl axis() -0.5 foo <- function(i, x, by) seq(x[i,1], x[i, 2], by = by[i])
locs2 <- unlist(lapply(seq_along(locs[-1]), FUN = foo, 
                       x= embed(locs, 2), by = abs(diff(locs)) / 9)) locs2 <- c(outer(1:10, c(10, 100, 1000), "/")) R> locs2
 [1] 0.100 0.200 0.300 0.400 0.500 0.600 0.700 0.800 0.900 1.000 0.010 0.020
[13] 0.030 0.040 0.050 0.060 0.070 0.080 0.090 0.100 0.001 0.002 0.003 0.004
[25] 0.005 0.006 0.007 0.008 0.009 0.010 axis() axis(side = 1, at = locs2, labels = NA, tcl = -0.2) labels = NA at plot(x, y, type="h", log="xy", axes = FALSE)
axis(side = 1, at = (locs <- 1/c(1,10,100,1000)), labels = locs)
axis(side = 1, at = locs2, labels = NA, tcl = -0.3)
axis(side = 2)
box() ylim plot() plot(x, y, type="h", log="xy", axes = FALSE, ylim = c(0.2, 1))
axis(side = 1, at = (locs <- 1/c(1,10,100,1000)), labels = locs)
axis(side = 2)
box()
-------------------------------------------------------------------------------------------------------
\documentclass{article}
\begin{document}
<<>>=
data("USDistLag", package = "lmtest")
library(dynlm)
dfm1 <- dynlm(consumption ~ gnp + L(consumption), data = USDistLag)
@ 

<<echo=FALSE>>=
cc <-dfm1$call
f <- cc$formula
LHS <- as.character(f)[2]
RHS <- as.character(f)[3]
coefs <- gsub(" +","",strsplit(RHS,"\\+")[[1]])
mbox <- function(x) { paste("\\\\mbox{",x,"}",sep="") }
pars <- paste("\\\\beta_",0:(length(coefs)-1),sep="")
p <- paste(mbox(LHS),"=",paste(pars,mbox(coefs),sep=" \\\\cdot ",collapse="+"),
           "+ \\\\epsilon")
@ 

$$
\Sexpr{p}
$$
\end{document} \documentclass{article}
\begin{document}
\begin{Schunk}
\begin{Sinput}
> data("USDistLag", package = "lmtest")
> library(dynlm)
> dfm1 <- dynlm(consumption ~ gnp + L(consumption), data = USDistLag)
\end{Sinput}
\end{Schunk}


$$
\mbox{consumption} = \beta_0 \cdot \mbox{gnp}+\beta_1 \cdot \mbox{L(consumption)} + \epsilon
$$
\end{document}
-------------------------------------------------------------------------------------------------------
weekdays(dat) ## days of the week
days <- c('Sun','Mon','Tues','Wed','Thurs','Fri','Sat')

## sample with replacement to generate data for this example
samples <- sample(days,100,replace=TRUE)

## convert to factor
## specify levels to specify the order
samples <- factor(samples,levels=days)

hist(unclass(samples),xaxt="n")
axis(1,at=1:nlevels(samples),lab=levels(samples))
box()
-------------------------------------------------------------------------------------------------------
fv.colors = colorRampPalette(c("white","tan4","green")) ## define the color ramp
colorlut = fv.colors(100)[c(1,seq(50,100,length.out=99))] ## select colors to use
plot(0:1,0:1,type='n',xaxs='i',yaxs='i') ## define the plotting area
## illustrate the vector of colors using rectangles
rect(seq(0,0.99,0.01),rep(0,100),seq(0.01,1,0.01),rep(1,100),col = colorlut,border = NA)
box() ## make sure that the graph's frame is not covered up
-------------------------------------------------------------------------------------------------------
axis plot(1:10, axes = FALSE) axis(1, at = (1:10) + 0.5, labels = 10:1, tick = FALSE) axis(1, at = (1:10), labels = FALSE, tick = TRUE)
box() axis(2, ...) axis(2)
-------------------------------------------------------------------------------------------------------
box("figure") depths <- c(1:10)
split.screen(c(2,2))
screen(1)
box("figure")
split.screen(c(2,2))
par(cex=0.5)
screen(5)
plot(depths)
-------------------------------------------------------------------------------------------------------
plotrix textbox() require(plotrix)
txt <- "Some notes about this plot"
plot(1:5)
textbox(x = c(1, 1 + 1.1*strwidth(txt)),
        y = 4,
        textlist = txt)
-------------------------------------------------------------------------------------------------------
cal <- function(month, year) {

        if(!require(chron)) stop('Unable to load chron package')

     if(missing(year) && missing(month)) {
         tmp <- month.day.year(Sys.Date())
         year <- tmp$year
         month <- tmp$month
     }


    if(missing(year) || missing(month)){  # year calendar
        if(missing(year)) year <- month
        par(mfrow=c(4,3))
        tmp <- seq.dates( from=julian(1,1,year), to=julian(12,31,year) )
        tmp2 <- month.day.year(tmp)
        wd <- do.call(day.of.week, tmp2)
        par(mar=c(1.5,1.5,2.5,1.5))
        for(i in 1:12){
            w <- tmp2$month == i
            cs <- cumsum(wd[w]==0)
            if(cs[1] > 0) cs <- cs - 1
            nr <- max( cs ) + 1
            plot.new()
            plot.window( xlim=c(0,6), ylim=c(0,nr+1) )
            text( wd[w], nr - cs -0.5 , tmp2$day[w] )
            title( main=month.name[i] )
            text( 0:6, nr+0.5, c('S','M','T','W','T','F','S') )
        }

    } else {  # month calendar

        ld <- seq.dates( from=julian(month,1,year), length=2, by='months')[2]-1
        days <- seq.dates( from=julian(month,1,year), to=ld)
        tmp <- month.day.year(days)
        wd <- do.call(day.of.week, tmp)
        cs <- cumsum(wd == 0)
        if(cs[1] > 0) cs <- cs - 1
        nr <- max(cs) + 1
        par(oma=c(0.1,0.1,4.6,0.1))
        par(mfrow=c(nr,7))
        par(mar=c(0,0,0,0))
        for(i in seq_len(wd[1])){ 
            plot.new()
            #box()
        }
        day.name <- c('Sun','Mon','Tues','Wed','Thur','Fri','Sat')
        for(i in tmp$day){
            plot.new()
            box()
            text(0,1, i, adj=c(0,1))
            if(i < 8) mtext( day.name[wd[i]+1], line=0.5,
                at=grconvertX(0.5,to='ndc'), outer=TRUE ) 
        }
        mtext(month.name[month], line=2.5, at=0.5, cex=1.75, outer=TRUE)
        #box('inner') #optional 
    }
} par(mfg=c(r,c)) updateusr subplot TeachingDemos cal(10,2011)
par(mfg=c(3,2))  # monday oct 10
text(.5,.5, 'Some\nText', cex=2)

par(mfg=c(2,3)) #Tues oct 4
text(1,1, 'Top Right', adj=c(1,1))

par(mfg=c(2,4)) # Wed oct 5
text(0,0, 'Bottom Left', adj=c(0,0))

par(mfg=c(6,2)) # oct 31
tmp.x <- runif(25)
tmp.y <- rnorm(25,tmp.x,.1)
par(usr=c( range(tmp.x), range(tmp.y) ) )
points(tmp.x,tmp.y)
-------------------------------------------------------------------------------------------------------
library(gWidgets)
items <- data.frame(id=numeric(0), gender=character(0), age=numeric(0), race=character(0), stringsAsFactors=FALSE)
genders <- c("Male", "Female")
race <- c("Black", "Hispanic", "Other")

w <- gwindow("Capn's GUI", visible=FALSE)
g <- ggroup(cont=w, horizontal=FALSE)
lyt <- glayout(cont=g)
lyt[1,1] <- "Gender:"
lyt[1,2] <- gradio(genders, cont=lyt)

lyt[2,1] <- "Age:"
lyt[2,2] <- gedit("40", coerce.with=as.numeric, cont=lyt)

lyt[3,1] <- "Race:"
lyt[3,2] <- gcombobox(race, selected=0L, cont=lyt)

lyt[4,2] <- gbutton("Add", cont=lyt, handler=function(h,...) {
  vals <- lapply(lyt[1:3, 2], svalue)
  id <- nrow(items) + 1                 # or roll your own
  items[id, ] <<- c(id, vals)
  tbl[] <- items
})
gseparator(cont=g)
tbl <- gtable(items, cont=g)


visible(w) <- TRUE
-------------------------------------------------------------------------------------------------------
text(axTicks(1), par("usr")[3] - 2, srt=45, adj=1, labels=lab, xpd=T, cex=0.8) axTicks(1) > axTicks(1)
[1]  5 10 15 1:19 text(1:19, par("usr")[3] - 2, srt=45, adj=1, labels=lab, xpd=T, cex=0.8) Runtime <- c(579,0,581,610,830,828,592,651,596,596,591,581,587,
             594,604,606,447,434,445)
g_range <- range(0,Runtime)
lab <- c('2011-07-20','2011-08-03','2011-08-10','2011-08-17','2011-08-24',
         '2011-08-25','2011-08-27','2011-08-31','2011-09-07','2011-09-10',
         '2011-09-14','2011-09-21','2011-09-28','2011-10-05','2011-10-06',
         '2011-10-07','2011-10-13','2011-10-19','2011-10-31')
## plot
op <- par(mar = c(6,4,4,2) + 0.1) ## bigger bottom margin
plot(Runtime, type="o", col="blue", ylim=g_range, axes=FALSE, ann=FALSE)
box()
axis(1, at=1:19, lab=FALSE)
text(1:19, par("usr")[3] - 40, srt=45, adj=1.2, labels=lab, xpd=T, cex=0.7)
axis(2, las=1, at=500*0:g_range[2])
title(main="Runtime", col.main="red", font.main=4)
title(xlab="Build", col.lab=rgb(0,0.5,0), line = 4.5)
title(ylab="MS", col.lab=rgb(0,0.5,0))
legend("topright", c("AveElapsedTime"), cex=0.8, col=c("blue"), pch=21, lty=1)
## reset par
par(op) y y ## load gridBase
require(gridBase)

## do the base plot parts
op <- par(mar = c(6,4,4,2) + 0.1) ## bigger bottom margin
plot(1:19, Runtime, type="o", col="blue", ylim=g_range, axes=FALSE, ann=FALSE)
box()
axis(1, at=1:19, lab=FALSE)
axis(2, las=1, at=500*0:g_range[2])
title(main="Runtime", col.main="red", font.main=4)
title(xlab="Build", col.lab=rgb(0,0.5,0), line = 4.5)
title(ylab="MS", col.lab=rgb(0,0.5,0))
legend("topright", c("AveElapsedTime"), cex=0.8, col=c("blue"), pch=21, lty=1)
## at this point, DO NOT alter the dimensions of the plotting window

## now do the grid business
vps <- baseViewports()
pushViewport(vps$inner, vps$figure, vps$plot)
## this adds the text
grid.text(lab, x = unit(1:19, "native"), y = unit(-1, "lines"),
          just = "right", rot = 60, gp = gpar(cex = 0.7))
## this finishes off the viewport - you have to do this or things will go wrong:
popViewport(3)
## reset par
par(op) pdf()
-------------------------------------------------------------------------------------------------------
as.expression(z) drawGraph <- function(x, y, z) {
    g_range <- range(0,x)
    plot(x, type="o", col="blue", ylim=g_range,axes=FALSE, ann=FALSE)
    box()
    axis(1, at=1:19, lab=FALSE)
    text(1:19, labels=y,par("usr")[3] - 2, srt=45, adj=1.2, xpd=T, cex=0.3)
    axis(2, las=1, at=500*0:g_range[2])
    main_title<-as.expression(z)
    title(main=main_title, col.main="red", font.main=4)
    title(xlab="Build", col.lab=rgb(0,0.5,0))
    title(ylab="MS", col.lab=rgb(0,0.5,0))
    legend("topright", g_range[2], c("z"), cex=0.8, col=c("blue"), pch=21, lty=1);
}
x <- rpois(19, 4)
AveElapsedTime=paste("The average time with ranges:", 
                       round(range(x)[1], 3), 
                        "to" , round(range(x), 3)[1])
lab=1:19
drawGraph(AET, lab, AveElapsedTime)
-------------------------------------------------------------------------------------------------------
axes = FALSE axis() # no call to par() needed
plot(c(1:10), axes = FALSE)
axis(1)                     # x-Axis
ticks <- seq(3, 9, 1)       # sequence for ticks and labels
axis(2, at = ticks,         # y-Axis
    labels = ticks)
box()                       # and a box around the plot
-------------------------------------------------------------------------------------------------------
pupilplot <- function (wf, cp = NULL, col = topo.colors(256), addContours = FALSE, 
cscale = TRUE, ...) 
 {
     if (cscale) {
         mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar
        on.exit(par(par.orig))
        w <- (3 + mar.orig[2]) * par("csi") * 2.54
        layout(matrix(c(2, 1), ncol = 2), widths = c(1, lcm(w)))
        par(las = 1)
        mar <- mar.orig
        mar[4] <- mar[2]
        mar[2] <- 1
        par(mar = mar) 
    thelist <- list(...)  
    findz <- which(names(thelist) == 'zlim')  
    if (length(findz) > 0 ) {   
        zlim <- thelist$zlim  
        }else{  
                zlim <- range(wf, finite = TRUE) #the original line  
        } 
 # end of my hack  
        levels <- seq(zlim[1], zlim[2], length = length(col))
        plot.new()
        plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i", yaxs = "i")
        rect(0, levels[-length(levels)], 1, levels[-1], col = col,  density = NA)
        axis(4)
         box()
        mar <- mar.orig
        mar[4] <- 0
        par(mar = mar)
    }
    if (is.null(cp)) {
        axis1 <- 1:nrow(wf)
        axis2 <- 1:ncol(wf)
    }
    else {
         axis1 <- ((1:nrow(wf)) - cp$xc)/cp$rx
        axis2 <- ((1:ncol(wf)) - cp$yc)/cp$ry
    }
    image(axis1, axis2, wf, col = col, asp = 1, xlab = "X", ylab = "Y",  ...)
     if (addContours) 
        contour(axis1, axis2, wf, add = TRUE)
}
-------------------------------------------------------------------------------------------------------
stackbox <- function(x,y,n,size,maxheight=5){ stackbox <- function(x,y,n,size,maxheight=5,...){
  stackheight = seq(0,n,by=maxheight)
  stackheight=diff(unique(c(stackheight,n)))

  for(col in 1:length(stackheight)){
    xl=rep(x+(col-1)*size,stackheight[col]) - (length(stackheight)/2)*size
    yb=y+size*((1:stackheight[col])-1) - (max(stackheight)/2)*size
    xr=xl+size
    yt=yb+size
    rect(xl,yb,xr,yt,...)
  }
} plot(1:10)
for(i in 1:10){
 stackbox(i,i,i,3,size=.1,col="red",border="white")
} africa=readShapeSpatial(file.path(mapLib,"africa.shp"))
plot(africa,border="gray")
coords=coordinates(africa)
for(i in 1:nrow(africa)){
  if(cases[i]>0){
    stackbox(coords[i,1],coords[i,2],africa$cases[i],1,border="#606060",col="#0083FE")
  }
}
-------------------------------------------------------------------------------------------------------
box(lwd=3) par(mgp=c(3,1.5,0) )  # second element is number of lines below the box for the labels # use par() to increase left margins par( mgp=c(4,1.5,0) ) # First element in mgp vector ..., xaxs="i", yaxs="i", ... # can be done in `par` or in the plot call postscript('doudou.eps',
               width=7, height=6,
               colormodel="cmyk",
               family = "ComputerModern",
               horizontal = FALSE,
               onefile=FALSE,
               paper = "special",
               encoding = "TeXtext.enc",
               pagecentre=FALSE)
par( mgp=c(4,1.5,0), mai=c(1.5, 1.5, 1.5, .75) )  # using inches as the spacing unit
with(test.frame, plot(ratio, value, ylab= "Hello", 
                            xaxs="i", yaxs="i",
                                   xlab="Wonderful",
                                   type="o",        # line and markers
                                   bty="o",         # box around graph
                                   lty="solid",     # solid line or put 1
                                   lwd=3,            # line width
                                   pch=1,            # or enclose symbol in quotes
                                   cex=3,             # size of markers
                                   cex.lab=2,        # label size
                                   cex.axis=3,    # axis annot size problem if big
                                   cex.main=2,          # main title size
                                   xaxp=c(0, 200, 4),  #c(x1, x2, n)
                                   col=2,              # plotting color
                                   xlim=c(0,200),
                                   yaxt = "n",         #suppresses axis
                                   main=" My curve"))

axis(2,seq(0,1, by=0.5), las=2,cex=3,cex.lab=2,cex.axis=1.4, cex.main=2)
box(lwd=3)
dev.off()
-------------------------------------------------------------------------------------------------------
panel.first plot.default hist ?plot.default hist(WindSpeed, breaks=c(0:31), freq=TRUE, col="blue", xaxt="n", yaxt="n", 
     xlab="Wind Speed (m/s)", main="Foo", 
     cex.main=1.5, cex.axis=1, cex.lab=1, tck=1, font.lab=2,
     panel.first={
        axis(1, tck=1, col.ticks="light gray")
        axis(1, tck=-0.015, col.ticks="black")
        axis(2, tck=1, col.ticks="light gray", lwd.ticks="1")
        axis(2, tck=-0.015)
        minor.tick(nx=5, ny=2, tick.ratio=0.5)
        box()
 })
-------------------------------------------------------------------------------------------------------
raster library(sp)
library(ggplot2)
loadMeuse()

# Generate a grid to sample on
bb = bbox(meuse)
grd = spsample(meuse, type = "regular", n = 4000)
# Come up with mean cadmium value
# of all points < 1000m.
mn_value = sapply(1:length(grd), function(pt) {
  d = spDistsN1(meuse, grd[pt,])
  return(mean(meuse[d < 1000,]$cadmium))
})

# Make a new object
dat = data.frame(coordinates(grd), mn_value)
ggplot(aes(x = x1, y = x2, fill = mn_value), data = dat) + 
   geom_tile() + 
   scale_fill_continuous(low = "white", high = muted("blue")) + 
   coord_equal() library(automap)
kr = autoKrige(cadmium~1, meuse, meuse.grid)
dat = as.data.frame(kr$krige_output)

ggplot(aes(x = x, y = y, fill = var1.pred), data = dat) + 
   geom_tile() + 
   scale_fill_continuous(low = "white", high = muted("blue")) + 
   coord_equal()
-------------------------------------------------------------------------------------------------------
dfr <- data.frame(x = 1:10, y = runif(10))
win <- gwindow()
btnEdit <- gbutton(
  "Edit", 
  container = win,
  handler = function(h, ...) dfr <<- edit(dfr)
) win <- gwindow()
btnEdit <- gbutton(
  "Edit", 
  container = win,
  handler = function(h, ...) 
  {
    if(svalue(chkReadonly)) View(dfr) else dfr <<- edit(dfr)
  }
)
chkReadonly <- gcheckbox(
  "Read-only", 
  FALSE,
  container = win,
  handler = function(h, ...) 
  {
    svalue(btnEdit) <- if(svalue(h$obj)) "View" else "Edit"
  }
) gdf tbl <- gdf(dfr, container = win)
-------------------------------------------------------------------------------------------------------
filled.contour scatter.fill <- function (x, y, z, 
                              nlevels = 20, plot.title, plot.axes, 
                              key.title, key.axes, asp = NA, xaxs = "i", 
                              yaxs = "i", las = 1, 
                              axes = TRUE, frame.plot = axes, ...) 
    {
        mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar
        on.exit(par(par.orig))
        w <- (3 + mar.orig[2L]) * par("csi") * 2.54
        layout(matrix(c(2, 1), ncol = 2L), widths = c(1, lcm(w)))
        par(las = las)
        mar <- mar.orig
        mar[4L] <- mar[2L]
        mar[2L] <- 1
        par(mar = mar)

        #Some simplified level/color picking
        levels <- seq(min(z),max(z),length.out = nlevels)
  col <- colorRampPalette(c("blue","red"))(nlevels)[rank(z)]

        plot.new()
        plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i", 
            yaxs = "i")
  rect(0, levels[-length(levels)], 1, levels[-1L], col = colorRampPalette(c("blue","red"))(nlevels)
        if (missing(key.axes)) {
            if (axes) 
                axis(4)
        }
        else key.axes
        box()
        if (!missing(key.title)) 
            key.title
        mar <- mar.orig
        mar[4L] <- 1
        par(mar = mar)

        #Simplified scatter plot construction
        plot(x,y,type = "n")
        points(x,y,col = col,...)

        if (missing(plot.axes)) {
            if (axes) {
                title(main = "", xlab = "", ylab = "")
                Axis(x, side = 1)
                Axis(y, side = 2)
            }
        }
        else plot.axes
        if (frame.plot) 
            box()
        if (missing(plot.title)) 
            title(...)
        else plot.title
        invisible()
    } x <- runif(40)
y <- runif(40)
z <- runif(40)
scatter.fill(x,y,z,nlevels = 40,pch = 20) filled.contour
-------------------------------------------------------------------------------------------------------
> length(Y)
[1] 30
> length(2:25)
[1] 24 plot(1, 1, xlim=c(108,172), axes=FALSE, type='n', ylim=c(1,30),
    xlab="Average number of syllables per 100 words", 
    ylab="Average number of sentences per 100 words", 
    main="Fry Graph for Estimating Reading Ages (grade level)",
    xaxs = 'i', yaxs = 'i')

axis(1, at = 108:172, labels = TRUE)
axis(2, at = 1:30,  labels=Y, las=2)
grid(nx=64, ny=46, lty="solid", col="gold")
grid(nx=32, ny=23, lty="solid", col="gray65")
box()
-------------------------------------------------------------------------------------------------------
rect() usr plot(1:10, 1:10, type = "n", axes = FALSE) ## no axes
lim <- par("usr")
rect(2, lim[3]-1, 4, lim[4]+1, border = "red", col = "red")
axis(1) ## add axes back
axis(2)
box()   ## and the plot frame rect() X <- c(1,3)
Y <- c(2,4)
plot(1:10, 1:10, type = "n", axes = FALSE) ## no axes
lim <- par("usr")
rect(X[1], Y[1], X[2], Y[2], border = "red", col = "red")
axis(1) ## add axes back
axis(2)
box()   ## and the plot frame botleft <- c(1,2)
topright <- c(3,4)
plot(1:10, 1:10, type = "n", axes = FALSE) ## no axes
lim <- par("usr")
rect(botleft[1], botleft[2], topright[1], topright[2], border = "red",
     col = "red")
axis(1) ## add axes back
axis(2)
box()   ## and the plot frame
-------------------------------------------------------------------------------------------------------
scipen ?options las ?par x <- rnorm(20)^2 * 10000000
layout(matrix(1:2, ncol = 2))
plot(x)
getOption("scipen")
opt <- options("scipen" = 20)
getOption("scipen")
plot(x)
options(opt)
layout(1) plot(x / 10000000, axes = FALSE)
axis(1)
pts <- pretty(x / 10000000)
axis(2, at = pts, labels = paste(pts, "MM", sep = ""))
box() pretty() plot() axis() box() opt <- options("scipen" = 20)
op <- par(mar = c(5,7,4,2) + 0.1) ## extra margin to accommodate tick labs
x <- rnorm(20)^2 * 10000000
plot(x, las = 1, ylab = "")       ## no y-axis label 
title(ylab = "label", line = 5.5) ## need to plot the axis label
par(op)
options(opt) las plot() las = 1 axis() op <- par(mar = c(5,5,4,2) + 0.1)
plot(x / 10000000, axes = FALSE, ylab = "")
axis(1)
pts <- pretty(x / 10000000)
axis(2, at = pts, labels = paste(pts, "MM", sep = ""), las = 1)
title(ylab = "my label", line = 4)
box()
par(op)
-------------------------------------------------------------------------------------------------------
ind <- function(x) {
  # Divide each column by the first non-NA value
  # (There may already be a function to do that.)
  coredata(x) <- t(t(coredata(x)) / apply(coredata(x),2,function(u){ c(u[!is.na(u)&u!=0],NA)[1] }))
  x
}
x <- cbind( Ad(GSPC), Ad(VIX) )
x <- x["2011-11::"]

# Using base graphics
matplot( 
  index(x), coredata(ind(x)), 
  xlab="", ylab="", main="",
  type="l", lty=1, lwd=3, axes=FALSE 
)
abline(h=1, lty=3, col="lightgrey")
axis(2, las=1)
axis.Date(1, index(x))
box()
legend( "topleft", gsub("\\..*", "", names(x)), lty=1, lwd=3, col=1:2 )

# If you prefer ggplot2
library(ggplot2)
library(reshape2)
d <- data.frame( date = index(x), coredata(ind(x)) )
names(d) <- gsub("\\..*", "", names(d))
d <- melt(d, id.vars="date")
ggplot(d, aes(date, value, color=variable)) + geom_line(size=2)
-------------------------------------------------------------------------------------------------------
is.OHLC plot plot.xts2 <- function (x, y = NULL, type = "l", auto.grid = TRUE, major.ticks = "auto", 
    minor.ticks = TRUE, major.format = TRUE, bar.col = "grey", 
    candle.col = "white", ann = TRUE, axes = TRUE, col = "black", ...) 
{
    series.title <- deparse(substitute(x))
    ep <- axTicksByTime(x, major.ticks, format = major.format)
    otype <- type
    if (xts:::is.OHLC(x) && type %in% c("candles", "bars")) {
        x <- x[, xts:::has.OHLC(x, TRUE)]
        xycoords <- list(x = .index(x), y = seq(min(x), max(x), 
                length.out = NROW(x)))
        type <- "n"
    }
    else {
        if (NCOL(x) > 1) 
            warning("only the univariate series will be plotted")
        if (is.null(y)) 
            xycoords <- xy.coords(.index(x), x[, 1])
    }
    plot(xycoords$x, xycoords$y, type = type, axes = FALSE, ann = FALSE, 
        col = col, ...)
    if (auto.grid) {
        abline(v = xycoords$x[ep], col = "grey", lty = 4)
        grid(NA, NULL)
    }
    if (xts:::is.OHLC(x) && otype == "candles") 
        plot.ohlc.candles(x, bar.col = bar.col, candle.col = candle.col, 
            ...)
    dots <- list(...)
    if (axes) {
        if (minor.ticks) 
            axis(1, at = xycoords$x, labels = FALSE, col = "#BBBBBB", 
                ...)
        axis(1, at = xycoords$x[ep], labels = names(ep), las = 1, 
            lwd = 1, mgp = c(3, 2, 0), ...)
        axis(2, ...)
    }
    box()
    if (!"main" %in% names(dots)) 
        title(main = series.title)
    do.call("title", list(...))
    assign(".plot.xts", recordPlot(), .GlobalEnv)
}

plot.xts2(as.xts(sample_matrix[,1]), col = "blue")
-------------------------------------------------------------------------------------------------------
rnorm x <- seq(-5,5,length=100)
plot(x, pnorm(1 - 0.5*x), ty='n', lwd=2, bty='n', xlab='x', ylab="Pr(y=1)", 
     xaxs = 'i', ylim=c(0, 1))

params <- processres(npb.par)
sims <- 100000
sim.mat <- matrix(NA, ncol=length(x), nrow=sims)
for (i in 1:sims) {
  alpha <- rnorm(1, params[1, 1], params[1, 3])
  beta <- rnorm(1, params[2, 1], params[2, 3])
  sim.mat[i, ] <- pnorm(alpha - beta*x)
}

CI <- apply(sim.mat, 2, function(x) quantile(x, c(0.05, 0.95)))
polygon(c(x, rev(x)), c(CI[1, ], rev(CI[2, ])), col='gray', border=NA)
lines(x, pnorm(params[1, 1] - params[2, 1]*x), lwd=2)
rug(dat100$x)
box()
-------------------------------------------------------------------------------------------------------
Spatial* raster Spatial* bbox(shp) bbox(ras) library(rgdal)
library(raster)
# Create a raster
ras <- raster(ncols=36, nrows=18)
ras[] <- runif(ncell(ras))
# Create a SpatialPoints object
shpPts <- spsample(Spatial(bbox=bbox(ras)), 20, type="random")
# Create a SpatialPolygons object
p1 <- rbind(c(-10,0), c(140,60), c(160,0), c(140,-55), c(-10,0))
shpPolys <- SpatialPolygons( list(Polygons(list(Polygon(p1)), 1)))

# Plot them, one layer after another
plot(ras)
plot(shpPts, pch=16, col="red", add=TRUE)
plot(shpPolys, col="yellow", add=TRUE)
-------------------------------------------------------------------------------------------------------
lattice raster rasterVis vectorplot() spplot() levelplot() base graphics plot() "RasterLayer" levelplot() require(raster)
require(rasterVis)

## Create a raster and a SpatialPoints object.
r <- raster()
r[] <- 1:ncell(r)
SP <- spsample(Spatial(bbox=bbox(r)), 10, type="random")

## Then plot them    
levelplot(r, col.regions = rev(terrain.colors(255)), cuts=254, margin=FALSE) +
layer(sp.points(SP, col = "red"))

## Or use this, which produces the same plot.
# spplot(r, scales = list(draw=TRUE), 
#        col.regions = rev(terrain.colors(255)), cuts=254) +
# layer(sp.points(SP, col = "red")) SpatialPoints ## A function to test whether points fall within a raster's extent
inExtent <- function(SP_obj, r_obj) {
    crds <- SP_obj@coord
    ext  <- extent(r_obj)
    crds[,1] >= ext@xmin  &  crds[,1] <= ext@xmax &
    crds[,2] >= ext@ymin  &  crds[,2] <= ext@ymax
}
## Remove any points in SP that don't fall within the extent of the raster 'r'
SP <- SP[inExtent(SP, r), ] plot(r) plot raster rasterImage() image() useRaster plot() useRaster=TRUE ## Chain of functions dispatched by `plot(r, useRaster=TRUE)`
getMethod("plot", c("RasterLayer", "missing"))
raster:::.plotraster2
raster:::.rasterImagePlot

## Call within .rasterImagePlot() that sets up the plotting region
plot(NA, NA, xlim = e[1:2], ylim = e[3:4], type = "n",
           , xaxs = "i", yaxs = "i", asp = asp, ...)

## Example showing why the above call produces the 'wrong' y-axis limits
plot(c(-180,180), c(-90,90), 
     xlim = c(-180,180), ylim = c(-90,90), pch = 16,
     asp = 1,
     main = "plot(r, useRaster=TRUE) -> \nincorrect y-axis limits") useRaster=FALSE ## Chain of functions dispatched by `plot(r, useRaster=FALSE)`
getMethod("plot", c("RasterLayer", "missing"))
raster:::.plotraster2
raster:::.imageplot
image.default

## Call within image.default() that sets up the plotting region
plot(NA, NA, xlim = xlim, ylim = ylim, type = "n", xaxs = xaxs, 
     yaxs = yaxs, xlab = xlab, ylab = ylab, ...)

## Example showing that the above call produces the wrong aspect ratio
plot(c(-180,180), c(-90,90), 
     xlim = c(-180,180), ylim = c(-90,90), pch = 16,
     main = "plot(r,useRaster=FALSE) -> \nincorrect aspect ratio")
-------------------------------------------------------------------------------------------------------
dev.new() pdf xlims<-c(1,24)
ylims<-c(-2,2)

pdf(file='test1march.pdf', width=3.33,height=4)
plot(NULL,NULL,xlim=xlims,ylim=ylims,axes=FALSE, ann=FALSE)     
axis(1, at=c(0,4,8,12,16,20,24),cex.axis=0.7,mgp=c(3, .3, 0))
axis(2, las=1,cex.axis=0.7,at=c(-2,-1,0,1,2), mgp=c(3, .7, 0))
mtext(side = 1, text =expression('Hour'), line = 1,font=15)
mtext(side = 2, text = expression(paste('NEE ', m^-2,s^-1)), line = 1.5,font=15)
abline(0, 2/24)  # should give a diagonal line
box()
dev.off()
-------------------------------------------------------------------------------------------------------
lapply summary_text <- function(d) {
  do.call(rbind, lapply( d, function(u)
    data.frame(
      Type    = class(u)[1],
      Min     = if(is.numeric(u)) min(   u, na.rm=TRUE) else NA,
      Mean    = if(is.numeric(u)) mean(  u, na.rm=TRUE) else NA,
      Median  = if(is.numeric(u)) median(u, na.rm=TRUE) else NA,
      Max     = if(is.numeric(u)) max(   u, na.rm=TRUE) else NA,
      Missing = sum(is.na(u))
    )    
  ) )
}
summary_text(iris) summary_plot <- function(d, aspect=1) {
  # Split the screen: find the optimal number of columns 
  # and rows to be as close as possible from the desired aspect ratio.
  n <- ncol(d)
  dx <- par()$din[1]
  dy <- par()$din[2]
  f <- function(u,v) {
    if( u*v >= n && (u-1)*v < n && u*(v-1) < n ) {
      abs(log((dx/u)/(dy/v)) - log(aspect))
    } else { 
      NA 
    }
  }
  f <- Vectorize(f)
  r <- outer( 1:n, 1:n, f )
  r <- which( r == min(r,na.rm=TRUE), arr.ind=TRUE )
  r <- r[1,2:1]

  op <- par(mfrow=c(1,1),mar=c(2,2,2,2))
  plot.new()
  if( is.null( names(d) ) ) { names(d) <- 1:ncol(d) }
  ij <- matrix(seq_len(prod(r)), nr=r[1], nc=r[2], byrow=TRUE)
  for(k in seq_len(ncol(d))) {
    i <- which(ij==k, arr.ind=TRUE)[1]
    j <- which(ij==k, arr.ind=TRUE)[2]
    i <- r[1] - i + 1
    f <- c(j-1,j,i-1,i) / c(r[2], r[2], r[1], r[1] )
    par(fig=f, new=TRUE)
    if(is.numeric(d[,k])) { 
      hist(d[,k], las=1, col="grey", main=names(d)[k], xlab="", ylab="")
      o <- par(fig=c(
          f[1]*.4  + f[2]*.6,
          f[1]*.15 + f[2]*.85,
          f[3]*.4  + f[4]*.6,
          f[3]*.15 + f[4]*.85
        ), 
        new=TRUE,
        mar=c(0,0,0,0)
      )
      qqnorm(d[,k],axes=FALSE,xlab="",ylab="",main="")
      qqline(d[,k])
      box()
      par(o)
    } else {
      o <- par(mar=c(2,5,2,2))
      barplot(table(d[,k]), horiz=TRUE, las=1, main=names(d)[k])
      par(o)
    }
  }
  par(op)
}
summary_plot(iris)
-------------------------------------------------------------------------------------------------------
y y2 # do first plot. Don't draw axis (we'll do it later)
plot(y~x,data=t,axes=F,ylab='y')
# draw y axis (see ?axis, 1=bottom, 2=left, 3=top, 4=right)
axis(2,pretty(range(t$y)))

# tell R to draw over the first plot
par(new=T)

# do second plot. 
plot(y2~x,data=t,axes=F,ylab="")
# draw second axis on the right
axis(4,pretty(range(t$y2)),ylab='y2')

# draw x axis on the bottom
axis(1,pretty(range(t$x)))

# draw the box if you want
box() axis(2,pretty(range(t$y))) pretty par(new=T) y2 x y2 y2 x y2 y par(mar=c(top,left,bottom,right)) ?par c(5,4,4,2)+.1 # get the current margins (top, left, bottom, right)
m <- par('mar')
# make sure the right margin is the same as the left.
m[4]<-m[2]
# set the new margins
par(mar=m)

# .... perform plotting as above. mtext mtext('y2',4,line=2) 'y2' line=2 # margin
m <- par('mar')
m[4] <- m[2]
par(mar=m)

# plotting
plot(y~x,data=t,axes=F,ylab='y')
axis(2,pretty(range(t$y)))
par(new=T)
plot(y2~x,data=t,axes=F,ylab="")
axis(4,pretty(range(t$y2)),ylab='y2')
axis(1,pretty(range(t$x)))
box()

# right-hand ylabel
mtext('y2',4,line=2)
-------------------------------------------------------------------------------------------------------
index coredata # Sample data
library(quantmod)
getSymbols("^GSPC")
x <- Vo(GSPC)
n <- length(x)

# Plot
plot(index(x), coredata(x), type="n", las=1, ylim=range(0,x))
polygon( 
  index(x)[c(1,1:n,n)], 
  c(0,coredata(x),0), 
  col="grey" 
)
box()
-------------------------------------------------------------------------------------------------------
pairs2 <- 
  function (x, labels, panel = points, ..., lower.panel = panel, 
            upper.panel = panel, diag.panel = NULL, text.panel = textPanel, 
            label.pos = 0.5 + has.diag/3, cex.labels = NULL, font.labels = 1, 
            row1attop = TRUE, gap = 1) 
  {
    textPanel <- function(x = 0.5, y = 0.5, txt, cex, font) text(x, 
                                                                 y, txt, cex = cex, font = font)
    localAxis <- function(side, x, y, xpd, bg, col = NULL, main, 
                          oma, ...) {
      if (side%%2 == 1) 
        Axis(x, side = side, xpd = NA, ...)
      else Axis(y, side = side, xpd = NA, ...)
    }
    localPlot <- function(..., main, oma, font.main, cex.main) plot(...)
    localLowerPanel <- function(..., main, oma, font.main, cex.main) lower.panel(...)
    localUpperPanel <- function(..., main, oma, font.main, cex.main) upper.panel(...)
    localDiagPanel <- function(..., main, oma, font.main, cex.main) diag.panel(...)
    dots <- list(...)
    nmdots <- names(dots)
    if (!is.matrix(x)) {
      x <- as.data.frame(x)
      for (i in seq_along(names(x))) {
        if (is.factor(x[[i]]) || is.logical(x[[i]])) 
          x[[i]] <- as.numeric(x[[i]])
        if (!is.numeric(unclass(x[[i]]))) 
          stop("non-numeric argument to 'pairs'")
      }
    }
    else if (!is.numeric(x)) 
      stop("non-numeric argument to 'pairs'")
    panel <- match.fun(panel)
    if ((has.lower <- !is.null(lower.panel)) && !missing(lower.panel)) 
      lower.panel <- match.fun(lower.panel)
    if ((has.upper <- !is.null(upper.panel)) && !missing(upper.panel)) 
      upper.panel <- match.fun(upper.panel)
    if ((has.diag <- !is.null(diag.panel)) && !missing(diag.panel)) 
      diag.panel <- match.fun(diag.panel)
    if (row1attop) {
      tmp <- lower.panel
      lower.panel <- upper.panel
      upper.panel <- tmp
      tmp <- has.lower
      has.lower <- has.upper
      has.upper <- tmp
    }
    nc <- ncol(x)
    if (nc < 2) 
      stop("only one column in the argument to 'pairs'")
    has.labs <- TRUE
    if (missing(labels)) {
      labels <- colnames(x)
      if (is.null(labels)) 
        labels <- paste("var", 1L:nc)
    }
    else if (is.null(labels)) 
      has.labs <- FALSE
    oma <- if ("oma" %in% nmdots) 
      dots$oma
    else NULL
    main <- if ("main" %in% nmdots) 
      dots$main
    else NULL
    if (is.null(oma)) {
      oma <- c(4, 4, 4, 4)
      if (!is.null(main)) 
        oma[3L] <- 6
    }
    opar <- par(mfrow = c(nc, nc), mar = rep.int(gap/2, 4), oma = oma)
    on.exit(par(opar))
    dev.hold()
    on.exit(dev.flush(), add = TRUE)
    for (i in if (row1attop) 
      1L:nc
         else nc:1L) for (j in 1L:nc) {
           localPlot(x[, j], x[, i], xlab = "", ylab = "", axes = FALSE, 
                     type = "n", ...)
           if (i == j || (i < j && has.lower) || (i > j && has.upper)) {
             box()
             # edited here...
             #           if (i == 1 && (!(j%%2) || !has.upper || !has.lower)) 
             #           localAxis(1 + 2 * row1attop, x[, j], x[, i], 
             #                       ...)
             # draw x-axis
             if (i == nc & j != nc) 
               localAxis(1, x[, j], x[, i], 
                         ...)
             # draw y-axis
             if (j == 1 & i != 1) 
               localAxis(2, x[, j], x[, i], ...)
             #           if (j == nc && (i%%2 || !has.upper || !has.lower)) 
             #             localAxis(4, x[, j], x[, i], ...)
             mfg <- par("mfg")
             if (i == j) {
               if (has.diag) 
                 localDiagPanel(as.vector(x[, i]), ...)
               if (has.labs) {
                 par(usr = c(0, 1, 0, 1))
                 if (is.null(cex.labels)) {
                   l.wid <- strwidth(labels, "user")
                   cex.labels <- max(0.8, min(2, 0.9/max(l.wid)))
                 }
                 text.panel(0.5, label.pos, labels[i], cex = cex.labels, 
                            font = font.labels)
               }
             }
             else if (i < j) 
               localLowerPanel(as.vector(x[, j]), as.vector(x[, 
                                                              i]), ...)
             else localUpperPanel(as.vector(x[, j]), as.vector(x[, 
                                                                 i]), ...)
             if (any(par("mfg") != mfg)) 
               stop("the 'panel' function made a new plot")
           }
           else par(new = FALSE)
         }
    if (!is.null(main)) {
      font.main <- if ("font.main" %in% nmdots) 
        dots$font.main
      else par("font.main")
      cex.main <- if ("cex.main" %in% nmdots) 
        dots$cex.main
      else par("cex.main")
      mtext(main, 3, 3, TRUE, 0.5, cex = cex.main, font = font.main)
    }
    invisible(NULL)
  }
data(iris)
pairs2(iris[1:4], main = "Anderson's Iris Data -- 3 species",pch = 21, bg = c("red", "green3", "blue")[unclass(iris$Species)])
-------------------------------------------------------------------------------------------------------
fig # Sample data
n <- 100
k <- 6
d <- matrix(rnorm(k*n),nc=k)
d[,2] <- d[,1]  # To help check the results
colnames(d) <- LETTERS[1:k]
x <- apply(d,2,cumsum)
r <- hclust(dist(t(d)))
# Plot
op <- par(mar=c(0,0,0,0),oma=c(0,2,0,0))
plot(NA,ylim=c(.5,k+.5), xlim=c(0,4),axes=FALSE)
# Dendrogram. See ?hclust for details.
xc <- yc <- rep(NA,k)
o <- 1:k
o[r$order] <- 1:k
for(i in 1:(k-1)) {
  a <- r$merge[i,1]
  x1 <- if( a<0 ) o[-a] else xc[a]
  y1 <- if( a<0 ) 0 else yc[a]
  b <- r$merge[i,2]
  x2 <- if( b<0 ) o[-b] else xc[b]
  y2 <- if( b<0 ) 0 else yc[b]
  lines( 
    3+c(y1,i,i,y2)/k,
    c(x1,x1,x2,x2),
    lwd=k-i
  )
  xc[i] <- (x1+x2)/2
  yc[i] <- i
}
# Time series
axis(2,1:k,colnames(d)[r$order],las=1)
u <- par()$usr
for(i in 1:k) {
  f <- c(0,3,i-.5,i+.5)
  f <- c( 
    (f[1]-u[1])/(u[2]-u[1]), 
    (f[2]-u[1])/(u[2]-u[1]), 
    (f[3]-u[3])/(u[4]-u[3]), 
    (f[4]-u[3])/(u[4]-u[3])
  )
  par(new=TRUE,fig=f)
  plot(x[,r$order[i]],axes=FALSE,xlab="",ylab="",main="",type="l",col="navy",lwd=2)
  box()
}
par(op) layout
-------------------------------------------------------------------------------------------------------
multhist(l, col=c("red","green","blue"),
  breaks=seq(0,5,by=0.2),names.arg=rep("",25))
box(bty="l")  ## add box around bottom and left edges multhist barplot
-------------------------------------------------------------------------------------------------------
map('state', plot = TRUE, fill = FALSE, col = palette()) import math
from collections import defaultdict

to_rad = math.pi / 180.0   # convert lat or lng to radians
fname = "site.tsv"        # file format: LAT\tLONG
threshhold_dist=50         # adjust to your needs
threshhold_locations=15    # minimum # of locations needed in a cluster

def dist(lat1,lng1,lat2,lng2):
    global to_rad
    earth_radius_km = 6371

    dLat = (lat2-lat1) * to_rad
    dLon = (lng2-lng1) * to_rad
    lat1_rad = lat1 * to_rad
    lat2_rad = lat2 * to_rad

    a = math.sin(dLat/2) * math.sin(dLat/2) + math.sin(dLon/2) * math.sin(dLon/2) * math.cos(lat1_rad) * math.cos(lat2_rad)
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a)); 
    dist = earth_radius_km * c
    return dist

def bounding_box(src, neighbors):
    neighbors.append(src)
    # nw = NorthWest se=SouthEast
    nw_lat = -360
    nw_lng = 360
    se_lat = 360
    se_lng = -360

    for (y,x) in neighbors:
        if y > nw_lat: nw_lat = y
        if x > se_lng: se_lng = x

        if y < se_lat: se_lat = y
        if x < nw_lng: nw_lng = x

    # add some padding
    pad = 0.5
    nw_lat += pad
    nw_lng -= pad
    se_lat -= pad
    se_lng += pad

    # sutiable for r's map() function
    return (se_lat,nw_lat,nw_lng,se_lng)

def sitesDist(site1,site2): 
    #just a helper to shorted list comprehension below 
    return dist(site1[0],site1[1], site2[0], site2[1])

def load_site_data():
    global fname
    sites = defaultdict(tuple)

    data = open(fname,encoding="latin-1")
    data.readline() # skip header
    for line in data:
        line = line[:-1]
        slots = line.split("\t")
        lat = float(slots[0])
        lng = float(slots[1])
        lat_rad = lat * math.pi / 180.0
        lng_rad = lng * math.pi / 180.0
        sites[(lat,lng)] = (lat,lng) #(lat_rad,lng_rad)
    return sites

def main():
    sites_dict = {}
    sites = load_site_data()
    for site in sites: 
        #for each site put it in a dictionary with its value being an array of neighbors 
        sites_dict[site] = [x for x in sites if x != site and sitesDist(site,x) < threshhold_dist] 

    results = {}
    for site in sites: 
        j = len(sites_dict[site])
        if j >= threshhold_locations:
            coord = bounding_box( site, sites_dict[site] )
            results[coord] = coord

    for bbox in results:
        yx="ylim=c(%s,%s), xlim=c(%s,%s)" % (results[bbox]) #(se_lat,nw_lat,nw_lng,se_lng)
        print('map("county", plot=T, fill=T, col=palette(), %s)' % yx)
        rect='rect(%s,%s, %s,%s, col=c("red"))' % (results[bbox][2], results[bbox][0], results[bbox][3], results[bbox][2])
        print(rect)
        print("")

main() LAT     LONG
36.3312 -94.1334
36.6828 -121.791
37.2307 -121.96
37.3857 -122.026
37.3857 -122.026
37.3857 -122.026
37.3895 -97.644
37.3992 -122.139
37.3992 -122.139
37.402  -122.078
37.402  -122.078
37.402  -122.078
37.402  -122.078
37.402  -122.078
37.48   -122.144
37.48   -122.144
37.55   126.967 rect(-74.989,39.7667, -73.0419,41.5209, col=c("red"))
rect(-123.005,36.8144, -121.392,38.3672, col=c("green"))
rect(-78.2422,38.2474, -76.3,39.9282, col=c("blue")) map("county", plot=T )
rect(-122.644,36.7307, -121.46,37.98, col=c("red")) ylim xlim map("county", plot=T, ylim=c(36.7307,37.98), xlim=c(-122.644,-121.46))
# or for more coloring, but choose one or the other map("country") commands
map("county", plot=T, fill=T, col=palette(), ylim=c(36.7307,37.98), xlim=c(-122.644,-121.46))
rect(-122.644,36.7307, -121.46,37.98, col=c("red")) map("world", plot=T ) threshhold_dist is the size of the bounding box, ie: the geographical area
theshhold_location is the number of lat/lng points needed with in
    the bounding box in order for it to be considered a cluster. # pyclusters.py
# May-02-2013
# -John Taylor

# latlng.tsv is located at http://pastebin.com/cyvEdx3V
# use the "RAW Paste Data" to preserve the tab characters

import math
from collections import defaultdict

# See also: http://www.geomidpoint.com/example.html
# See also: http://www.movable-type.co.uk/scripts/latlong.html

to_rad = math.pi / 180.0  # convert lat or lng to radians
fname = "latlng.tsv"      # file format: LAT\tLONG
threshhold_dist=20        # adjust to your needs
threshhold_locations=20   # minimum # of locations needed in a cluster
earth_radius_km = 6371

def coord2cart(lat,lng):
    x = math.cos(lat) * math.cos(lng)
    y = math.cos(lat) * math.sin(lng)
    z = math.sin(lat)
    return (x,y,z)

def cart2corrd(x,y,z):
    lon = math.atan2(y,x)
    hyp = math.sqrt(x*x + y*y)
    lat = math.atan2(z,hyp)
    return(lat,lng)

def dist(lat1,lng1,lat2,lng2):
    global to_rad, earth_radius_km

    dLat = (lat2-lat1) * to_rad
    dLon = (lng2-lng1) * to_rad
    lat1_rad = lat1 * to_rad
    lat2_rad = lat2 * to_rad

    a = math.sin(dLat/2) * math.sin(dLat/2) + math.sin(dLon/2) * math.sin(dLon/2) * math.cos(lat1_rad) * math.cos(lat2_rad)
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a)); 
    dist = earth_radius_km * c
    return dist

def bounding_box(src, neighbors):
    neighbors.append(src)
    # nw = NorthWest se=SouthEast
    nw_lat = -360
    nw_lng = 360
    se_lat = 360
    se_lng = -360

    for (y,x) in neighbors:
        if y > nw_lat: nw_lat = y
        if x > se_lng: se_lng = x

        if y < se_lat: se_lat = y
        if x < nw_lng: nw_lng = x

    # add some padding
    pad = 0.5
    nw_lat += pad
    nw_lng -= pad
    se_lat -= pad
    se_lng += pad

    #print("answer:")
    #print("nw lat,lng : %s %s" % (nw_lat,nw_lng))
    #print("se lat,lng : %s %s" % (se_lat,se_lng))

    # sutiable for r's map() function
    return (se_lat,nw_lat,nw_lng,se_lng)

def sitesDist(site1,site2): 
    # just a helper to shorted list comprehensioin below 
    return dist(site1[0],site1[1], site2[0], site2[1])

def load_site_data():
    global fname
    sites = defaultdict(tuple)

    data = open(fname,encoding="latin-1")
    data.readline() # skip header
    for line in data:
        line = line[:-1]
        slots = line.split("\t")
        lat = float(slots[0])
        lng = float(slots[1])
        lat_rad = lat * math.pi / 180.0
        lng_rad = lng * math.pi / 180.0
        sites[(lat,lng)] = (lat,lng) #(lat_rad,lng_rad)
    return sites

def main():
    color_list = ( "red", "blue", "green", "yellow", "orange", "brown", "pink", "purple" )
    color_idx = 0
    sites_dict = {}
    sites = load_site_data()
    for site in sites: 
        #for each site put it in a dictionarry with its value being an array of neighbors 
        sites_dict[site] = [x for x in sites if x != site and sitesDist(site,x) < threshhold_dist] 

    print("")
    print('map("state", plot=T)') # or use: county instead of state
    print("")


    results = {}
    for site in sites: 
        j = len(sites_dict[site])
        if j >= threshhold_locations:
            coord = bounding_box( site, sites_dict[site] )
            results[coord] = coord

    for bbox in results:
        yx="ylim=c(%s,%s), xlim=c(%s,%s)" % (results[bbox]) #(se_lat,nw_lat,nw_lng,se_lng)

        # important!
        # if you want an individual map for each cluster, uncomment this line
        #print('map("county", plot=T, fill=T, col=palette(), %s)' % yx)
        if len(color_list) == color_idx:
            color_idx = 0
        rect='rect(%s,%s, %s,%s, col=c("%s"))' % (results[bbox][2], results[bbox][0], results[bbox][3], results[bbox][1], color_list[color_idx])
        color_idx += 1
        print(rect)
    print("")


main()
-------------------------------------------------------------------------------------------------------
years <- seq(1975,1989,2)
db <- data.frame(Dallas=c( 25, 28, 27, 29, 31, 33, 35, 37),
 Houston=c( 33, 38, 43, 48, 53, 58, 63, 68),
 Lubbock=c( 28, 29, 31, 33, 35, 37, 39, 41),
 Austin= c(22, 24, 26, 28, 30, 32, 34, 36),
 San_Antonio= c(31, 32, 33, 34, 35, 36, 37, 38)
)
db <- as.matrix(db)

#plot
layout(matrix(c(1,2), nrow=1, ncol=2), widths=c(4,1), heights=c(4))
layout.show(2)
par(mar=c(5,5,1,1))
image(x=years, z=db, yaxt="n")
axis(2, at=seq(0,1,,dim(db)[2]), labels=colnames(db))
#image.scale from http://menugget.blogspot.de/2011/08/adding-scale-to-image-plot.html
par(mar=c(5,0,1,5))
image.scale(db, horiz=FALSE, yaxt="n", xaxt="n", xlab="", ylab="")
axis(4)
mtext("temp", side=4, line=2)
box()
-------------------------------------------------------------------------------------------------------
dat <- read.table(text="info  mean  sd
info1 20.84 4.56
info2 29.18 5.41
info3 38.90 6.22", header=T)

dat <- transform(dat, lower= mean-3*sd, upper= mean+3*sd)

plot(x=c(min(dat$lower)-2, max(dat$upper)+2), y=c(0, .25), ylab="", 
    xlim=c(min(dat$lower)-2, max(dat$upper)+2), xlab="", 
    axes=FALSE, xaxs = "i", type="n")
box()

FUN <- function(rownum) {
    par(new=TRUE)
    curve(dnorm(x,dat[rownum, 2], dat[rownum, 3]),
        xlim=c(c(min(dat$lower)-2, max(dat$upper)+2)), 
        ylim=c(0, .22),
        ylab="", xlab="")
}

lapply(seq_len(nrow(dat)), function(i) FUN(i))
-------------------------------------------------------------------------------------------------------
?image dat <- data.matrix(data.frame(Germany = c(0,1,0), Italy = c(1,0,0)))
rownames(dat) <- c("Rain","Hail","Sunny") image(z = dat, col = c("white","red")) op <- par(mar = c(5,5,4,2) + 0.1)
image(z = dat, col = c("white","red"), axes = FALSE)
axis(side = 1, labels = rownames(dat), 
     at = seq(0, by = 0.5, length.out = nrow(dat)))
axis(side = 2, labels = colnames(dat), at = c(0,1), las = 1)
box()
par(op) dat image(z = t(dat), ....) axis() side 2 1 las = 1 op <- par(mar = c(5,5,4,2) + 0.1)
image(z = t(dat2), col = c("white","red"), axes = FALSE)
axis(side = 2, labels = rownames(dat2), 
     at = seq(0, by = 0.5, length.out = nrow(dat2)), las = 1)
axis(side = 1, labels = colnames(dat2), at = c(0,1))
box()
par(op)
-------------------------------------------------------------------------------------------------------
rgeos gIsValid library(rgeos)
p4 = readWKT("POLYGON ((0 40, 0 0, 40 40, 40 0, 0 40))")
gIsValid(p4, reason = TRUE)
[1] "Self-intersection[20 20]" reason gIsValid(p4)
[1] FALSE
Warning message:
In RGEOSUnaryPredFunc(spgeom, byid, "rgeos_isvalid") :
  Self-intersection at or near point 20 20 plot(p4, col = "grey")
points(20, 20, pch = 3, cex = 3, col = "red")
axis(1);axis(2);box() byid library(maptools)
xx <- readShapePoly(system.file("shapes/sids.shp", package="maptools")[1],
  IDvar="FIPSNO", proj4string=CRS("+proj=longlat +ellps=clrk66"))
gIsValid(xx, byid = TRUE)
37001 37003 37005 37007 37009 37011 
 TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
...
-------------------------------------------------------------------------------------------------------
plot(rnorm(99), bty="n", axes=FALSE, xlab="", ylab="")
box(col="dodgerblue")
axis(1, col="dodgerblue", col.ticks="green", col.axis="orange", cex.axis=2)
axis(2, col="dodgerblue", col.ticks="green", col.axis="orange", cex.axis=0.8)
mtext("Index", side=1, line=3, col="red", cex=2)
mtext("Value", side=2, line=3, col="purple", cex=0.8)
-------------------------------------------------------------------------------------------------------
parse(text='70^o*N') o *N labelsX=parse(text=paste(abs(seq(-100, -50, 10)), "^o ", "*W", sep=""))
labelsY=parse(text=paste(seq(50,100,10), "^o ", "*N", sep=""))
plot(-100:-50, 50:100, type="n", xlab="", ylab="", axes=FALSE)
axis(1, seq(-100, -50, 10), labels=labelsX)
axis(2, seq(50, 100, 10), labels=labelsY)
box()
-------------------------------------------------------------------------------------------------------
n sample_data sample() sample_data ecdf(sample_data) # Create some example data
sample_data <- runif(100)

n <- 10
X <- replicate(1000, sum(sample(sample_data, size=n, replace=TRUE)))

# Plot the estimated distribution of the sum of n variates.
hist(X, breaks=40, col="grey", main=expression(sum(x[i], i==1, n)))
box(bty="l")

# Plot the ecdf of the sum
plot(ecdf(X))
-------------------------------------------------------------------------------------------------------
box plot.histogram par x<-rnorm(2000, 0, 30)
hist(x)
box(bty = "l") par bty
-------------------------------------------------------------------------------------------------------
maps SpatialLines SpatialLines rgeos lon_0 PROJ_4 spTransform() rgdal rgeos spTransform() base lattice spTransform() SpatialLines library(sp)
library(maps)
library(maptools)   ## map2SpatialLines(), pruneMap()
library(rgdal)      ## CRS(), spTransform()
library(rgeos)      ## readWKT(), gIntersects(), gBuffer(), gDifference() 

## Convert a "maps" map to a "SpatialLines" map
makeSLmap <- function() {
    llCRS <- CRS("+proj=longlat +ellps=WGS84")
    wrld <- map("world", interior = FALSE, plot=FALSE,
            xlim = c(-179, 179), ylim = c(-89, 89))
    wrld_p <- pruneMap(wrld, xlim = c(-179, 179))
    map2SpatialLines(wrld_p, proj4string = llCRS)
}

## Clip SpatialLines neatly along the antipodal meridian
sliceAtAntipodes <- function(SLmap, lon_0) {
    ## Preliminaries
    long_180 <- (lon_0 %% 360) - 180
    llCRS  <- CRS("+proj=longlat +ellps=WGS84")  ## CRS of 'maps' objects
    eqcCRS <- CRS("+proj=eqc")
    ## Reproject the map into Equidistant Cylindrical/Plate Caree projection 
    SLmap <- spTransform(SLmap, eqcCRS)
    ## Make a narrow SpatialPolygon along the meridian opposite lon_0
    L  <- Lines(Line(cbind(long_180, c(-89, 89))), ID="cutter")
    SL <- SpatialLines(list(L), proj4string = llCRS)
    SP <- gBuffer(spTransform(SL, eqcCRS), 10)
    ## Use it to clip any SpatialLines segments that it crosses
    ii <- which(gIntersects(SLmap, SP, byid=TRUE))
    # Replace offending lines with split versions
    # (but skip when there are no intersections (as, e.g., when lon_0 = 0))
    if(length(ii)) { 
        SPii <- gDifference(SLmap[ii], SP, byid=TRUE)
        SLmap <- rbind(SLmap[-ii], SPii)  
    }
    return(SLmap)
}

## re-center, and clean up remaining streaks
recenterAndClean <- function(SLmap, lon_0) {
    llCRS <- CRS("+proj=longlat +ellps=WGS84")  ## map package's CRS
    newCRS <- CRS(paste("+proj=eqc +lon_0=", lon_0, sep=""))
    ## Recenter 
    SLmap <- spTransform(SLmap, newCRS)
    ## identify remaining 'scratch-lines' by searching for lines that
    ## cross 2 of 3 lines of longitude, spaced 120 degrees apart
    v1 <-spTransform(readWKT("LINESTRING(-62 -89, -62 89)", p4s=llCRS), newCRS)
    v2 <-spTransform(readWKT("LINESTRING(58 -89, 58 89)",   p4s=llCRS), newCRS)
    v3 <-spTransform(readWKT("LINESTRING(178 -89, 178 89)", p4s=llCRS), newCRS)
    ii <- which((gIntersects(v1, SLmap, byid=TRUE) +
                 gIntersects(v2, SLmap, byid=TRUE) +
                 gIntersects(v3, SLmap, byid=TRUE)) >= 2)
    SLmap[-ii]
}

## Put it all together:
Recenter <- function(lon_0 = -100, grid=FALSE, ...) {                        
    SLmap <- makeSLmap()
    SLmap2 <- sliceAtAntipodes(SLmap, lon_0)
    recenterAndClean(SLmap2, lon_0)
}

## Try it out
par(mfrow=c(2,2), mar=rep(1, 4))
plot(Recenter(-90), col="grey40"); box() ## Centered on 90w 
plot(Recenter(0),   col="grey40"); box() ## Centered on prime meridian
plot(Recenter(90),  col="grey40"); box() ## Centered on 90e
plot(Recenter(180), col="grey40"); box() ## Centered on International Date Line
-------------------------------------------------------------------------------------------------------
R library(ggplot2)
library(grid)
library(maps)
library(mapproj)
library(png)
library(RgoogleMaps)

counties <- map_data("county", region="virginia")
states <- map_data("state")

tmp <- tempfile(fileext=".png")
bg <- GetMap.bbox(range(counties$long), range(counties$lat), destfile=tmp, 
     maptype="satellite", format="png32")
background <- readPNG(tmp)
background <- rasterGrob(unclass(background))

p <- ggplot(counties, aes(long, lat)) +
   coord_map(xlim=c(bg$BBOX$ll[2], bg$BBOX$ur[2]), 
             ylim=c(bg$BBOX$ll[1], bg$BBOX$ur[1])) +
   geom_path(aes(group=group), color="darkgrey") +
   geom_path(data=states, aes(group=group), color="white", size=1) +
   opts(axis.line=theme_blank(),
        axis.text.x=theme_blank(),
        axis.text.y=theme_blank(),
        axis.ticks=theme_blank(),
        axis.title.x=theme_blank(),
        axis.title.y=theme_blank(),
        axis.ticks.length=unit(0, "lines"),
        axis.ticks.margin=unit(0, "lines"),
        panel.border=theme_blank(),
        panel.background=function(...)background,
        panel.grid.major=theme_blank(),
        panel.grid.minor=theme_blank(),
        panel.margin=unit(0, "lines"),
        legend.position="none",
        legend.title=theme_blank(),
        legend.background=theme_blank(),
        plot.margin=unit(0*c(-1.5, -1.5, -1.5, -1.5), "lines"))

pdf("plot.pdf", height=7, width=7)
p
dev.off() pdf() dev.off()
-------------------------------------------------------------------------------------------------------
image() axes = FALSE set.seed(42)
X <- as.POSIXct(1:100, origin = "1970-1-1")
Z <- matrix(rnorm(100*100), 100)
image(x = X, z = Z, axes = FALSE)
axis(side = 2)
axis.POSIXct(side = 1, x = X)
box() Axis() image(x = X, z = Z, axes = FALSE)
axis(side = 2)
Axis(x = X, side = 1)
box() Image <- function(x = seq(0, 1, length.out = nrow(z)),
                  y = seq(0, 1, length.out = ncol(z)),
                  z, ...) {
    image(x = X, z = Z, ..., axes = FALSE)
    Axis(x = y, side = 2, ...)
    Axis(x = X, side = 1, ...)
    box()
} Axis() x y image() Image() image() x image.default() x image.default() ?Startup
-------------------------------------------------------------------------------------------------------
box(bty='L') lines segments abline grconvertX grconvertY
-------------------------------------------------------------------------------------------------------
ggplot ggplot(data = data, aes(x = x, y = y)) ggmap ggmap ggamp ggplot ggmap ggmap geom_map inherit.aes = FALSE geom_map ggplot() + myMap + Limits inherit.aes = FALSE geom_map ggmap geom_map library(sp)
library(spdep)
library(ggplot2)
library(ggmap)
library(rgdal)

#Get and fiddle with data:
nc.sids <- readShapePoly(system.file("etc/shapes/sids.shp", package="spdep")[1],ID="FIPSNO", proj4string=CRS("+proj=longlat +ellps=clrk66"))
nc.sids=spTransform(nc.sids,CRS("+init=epsg:4326"))

#Get background map from stamen.com, plot, looks nice:
ncmap = get_map(location=as.vector(bbox(nc.sids)),source="stamen",maptype="toner",zoom=7)
ggmap(ncmap)

#Create a data frame with long,lat,Z, and plot over the map and a blank plot:
ncP = data.frame(coordinates(nc.sids),runif(nrow(nc.sids)))
colnames(ncP)=c("long","lat","Z")

ggmap(ncmap)+geom_point(aes(x=long,y=lat,col=Z),data=ncP)
ggplot()+geom_point(aes(x=long,y=lat,col=Z),data=ncP)

#give it some unique ids called 'id' and fortify (with vitamins and iron?)
nc.sids@data[,1]=1:nrow(nc.sids)
names(nc.sids)[1]="id"
ncFort = fortify(nc.sids)

#Now, my map and my limits, I want to plot the 74 birth rate:
myMap = geom_map(inherit.aes = FALSE, aes(fill=BIR74,map_id=id), map=ncFort,data=nc.sids@data)
Limits = expand_limits(x=ncFort$long,y=ncFort$lat)

# and on a blank plot I can:
ggplot() + myMap + Limits

# but on a ggmap I cant:
ggmap(ncmap) + myMap + Limits
-------------------------------------------------------------------------------------------------------
ylim ylim library(maps)
library(mapproj)

ylim = c(-90,-45)
orientation=c(-90, 0, 0)

x11()
par(mar=c(1,1,1,1))
m <- map("world", plot=FALSE)
map("world",project="stereographic", orientation=orientation, ylim=ylim, col = "transparent")
map("world",project="stereographic", orientation=orientation, ylim=ylim + c(-5, 5), add = TRUE)
map.grid(m, nx=18,ny=18, col=8)
box()
-------------------------------------------------------------------------------------------------------
orientation=c(-90, 0, 0)

ylim <- c(mapproject(x=-180,y=-45, project="stereographic", orientation=orientation)$y, mapproject(x=0,y=-45, project="stereographic", orientation=orientation)$y)
xlim <- c(mapproject(x=-90,y=-45, project="stereographic", orientation=orientation)$x, mapproject(x=90,y=-45, project="stereographic", orientation=orientation)$x)

x11(width=6,height=6)
par(mar=c(1,1,1,1))
plot(0,0, t="n", ylim=ylim, xlim=xlim, xaxs="i", yaxs="i", xlab="", ylab="", xaxt="n", yaxt="n")
map("world",project="stereographic", orientation=orientation, add=TRUE)
map.grid(nx=18,ny=18, col=8)
box()
-------------------------------------------------------------------------------------------------------
maptools library(maptools)
data(wrld_simpl)
xrange <- c(-180, 180, 0, 0)
yrange <- c(-90, -45, -90, -45)

stere <- "+proj=stere +lat_0=-90 +lat_ts=-71 +lon_0=0 +k=1 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"

library(rgdal)

w <- spTransform(wrld_simpl, CRS(stere))

xy <- project(cbind(xrange, yrange), stere)
plot(w, xlim = range(xy[,1]), ylim = range(xy[,2]))
box()
-------------------------------------------------------------------------------------------------------
#See if this is sufficient:
hist(...)
box()

#If not, try custom axes:
hist(..., xlim = c(-.5, .5), axes = F)
box()
axis(1, seq(-.5, .5, length = 6))
axis(2, seq(0, 30, by = 5))
-------------------------------------------------------------------------------------------------------
osmosis  --read-xml SloveniaGarmin.osm --tee 4 --bounding-box left=15 top=46 --write-xml SloveniaGarminSE.osm --bounding-box left=15 bottom=46 --write-xml SloveniaGarminNE.osm --bounding-box right=15 top=46 --write-xml SloveniaGarminSW.osm --bounding-box right=15 bottom=46 --write-xml SloveniaGarminNW.osm osmosis gzip demo gzip library(osmar)
download.file("http://osmar.r-forge.r-project.org/muenchen.osm.gz","muenchen.osm.gz")
system("gzip -d muenchen.osm.gz")
# At this point, check the directory listed by getwd(). It should contain muenchen.osm.
src <- osmsource_osmosis(file = "muenchen.osm",osmosis = "osmosis")
muc_bbox <- center_bbox(11.575278, 48.137222, 3000, 3000)
debug(osmar:::get_osm_data.osmosis)
get_osm(muc_bbox, src)
# Press Enter till you get to
# request <- osm_request(source, what, destination)
# Then type request to get the command it is sending. request osmosis --read-xml enableDateParsing=no file=muenchen.osm --bounding-box top=48.1507120588903 left=11.5551240885889 bottom=48.1237319411097 right=11.5954319114111 --write-xml file=<your path> undebug(osmar:::get_osm_data.osmosis) Q
-------------------------------------------------------------------------------------------------------
xpd=FALSE b <- barplot(c(363.2, 377.4), beside = TRUE, 
   ylim = c(340,380), col = c("orange", "blue"),xpd=FALSE)
axis(side=1,at=b,labels=c("group 1", "group 2"))
box(bty="l")
-------------------------------------------------------------------------------------------------------
#required function from www.menugget.blogspot.com
matrix.poly <- function(x, y, z=mat, n=NULL){
 if(missing(z)) stop("Must define matrix 'z'")
 if(missing(n)) stop("Must define at least 1 grid location 'n'")
 if(missing(x)) x <- seq(0,1,,dim(z)[1])
 if(missing(y)) y <- seq(0,1,,dim(z)[2])
 poly <- vector(mode="list", length(n))
 for(i in seq(n)){
  ROW <- ((n[i]-1) %% dim(z)[1]) +1
  COL <- ((n[i]-1) %/% dim(z)[1]) +1

  dist.left <- (x[ROW]-x[ROW-1])/2
  dist.right <- (x[ROW+1]-x[ROW])/2
  if(ROW==1) dist.left <- dist.right
  if(ROW==dim(z)[1]) dist.right <- dist.left

  dist.down <- (y[COL]-y[COL-1])/2
  dist.up <- (y[COL+1]-y[COL])/2
  if(COL==1) dist.down <- dist.up
  if(COL==dim(z)[2]) dist.up <- dist.down

  xs <- c(x[ROW]-dist.left, x[ROW]-dist.left, x[ROW]+dist.right, x[ROW]+dist.right)
  ys <- c(y[COL]-dist.down, y[COL]+dist.up, y[COL]+dist.up, y[COL]-dist.down)
  poly[[i]] <- data.frame(x=xs, y=ys)
 }
 return(poly)
}

#make vector of grids for hatching
incl <- which(over==1)

#make polygons for each grid for hatching
polys <- matrix.poly(1:12, 1:6, z=over, n=incl)

    #plot
png("hatched_image.png")
image(1:12, 1:6, data)
for(i in seq(polys)){
    polygon(polys[[i]], density=10, angle=45, border=NA)
    polygon(polys[[i]], density=10, angle=-45, border=NA)
}
box()
dev.off() png("hatched_image2.png")
image(1:12, 1:6, data)
for(i in seq(polys)){
    xran <- range(polys[[i]]$x)
    yran <- range(polys[[i]]$y)
    xs <- seq(xran[1], xran[2],,5)
    ys <- seq(yran[1], yran[2],,5)
    grd <- expand.grid(xs,ys)
    points(grd, pch=19, cex=0.5)
}
box()
dev.off()
-------------------------------------------------------------------------------------------------------
box box(lwd=4) bty box(lwd=4, bty="u") # For all the different kind of boxes see ?par. font cex.lab cex.axis plot axis axis(1, font=2, cex.axis=1.1) #font=2 correspond to bold face. See ?par for more information family ?x11 axis(1, family="Times") #This will work with Cairo devices for example. cex.axis
-------------------------------------------------------------------------------------------------------
par ?par dev.new( width= 16, height= 7 )
## set outer margins
par( mar=c(5, 4, 4, 4), cex= 0.9 )
plot( 1:100, type="n", xlab = "", ylab = "", axes = F, las = 2, cex = 0.7 )
axis( 4, at = c ( 0, 30, 60, 90, 120, 150, 180 ), labels = c( "0", "30", "60", "90", "120", "150", "180" ), las = 0, cex.axis = .8,col.lab = "gray80",
tck = 0.01 )
rect( 153, -5.5, 169, 185, col = "gray80", border = NA)
rect( 246, -5.5, 272, 185, col = "gray80", border = NA)
lines( 1:200, col = "gray20" )
#text("Moon phase ()", 330, 90, cex = .9 )
mtext(side = 4, text = "Moon phase ()", line = 2, cex = .9 )
mtext(side = 1, text = "Dates", line = 4, cex = .9 )

par( new = T )
plot( 1:220, type = "n", lwd= 1.2, xlab= "", ylab= "Photoperiod (h)", axes = F, cex = .8, col.lab = "red" )
axis( side= 1, at = c ( 1, 20, 51, 82, 112, 143, 173, 204, 235, 264, 295, 324 ), labels = c ( "12 Jun'07", "1 Jul'07", "1 Aug'07", "1 Sep'07", "1 Oct'07", "1 Nov'07", "1 Dec'07", "1 Jan'08", "1 Feb'08", "1 Mar'08", "1 Apr'08", "30 Apr'08" ), las = 2, cex.axis = .75 )
axis ( side = 2, at = c( 12, 13, 14, 15, 16 ), labels = c( "12", "13", "14", "15", "16" ), cex.axis = .8, las = 2)
box()
-------------------------------------------------------------------------------------------------------
plot.default # need a helper function for this
 tweak <- function(x) c(range(x)[1], range(x)[2]+.00001)
 # Replace xy <- xy.coords(x, y, xlabel, ylabel, log)
 xy <- xy.coords(x[findInterval(x, tweak(xlim))==1], 
                 y[findInterval(x, tweak(xlim))==1], 
                 xlabel, ylabel, log) plotsub <- function(x,y = NULL, type = "p", xlim = NULL, ylim = NULL, 
    log = "", main = NULL, sub = NULL, xlab = NULL, ylab = NULL, 
    ann = par("ann"), axes = TRUE, frame.plot = axes, panel.first = NULL, 
    panel.last = NULL, asp = NA, ...) 
{   ylim=range(y);  tweak <- function(x) c(range(x)[1], range(x)[2]+.00001)
    localAxis <- function(..., col, bg, pch, cex, lty, lwd) Axis(...)
    localBox <- function(..., col, bg, pch, cex, lty, lwd) box(...)
    localWindow <- function(..., col, bg, pch, cex, lty, lwd) plot.window(...)
    localTitle <- function(..., col, bg, pch, cex, lty, lwd) title(...)
    xlabel <- if (!missing(x)) 
        deparse(substitute(x))
    ylabel <- if (!missing(y)) 
        deparse(substitute(y))
    xy <- xy.coords(x[findInterval(x, tweak(xlim))==1], y[findInterval(x,tweak(xlim))==1], xlabel, ylabel, log)
    xlab <- if (is.null(xlab)) 
        xy$xlab
    else xlab
    ylab <- if (is.null(ylab)) 
        xy$ylab
    else ylab
    xlim <- if (is.null(xlim)) 
        range(xy$x[is.finite(xy$x)])
    else xlim
    ylim <- if (is.null(ylim)) 
        range(xy$y[is.finite(xy$y)])
    else ylim
    dev.hold()
    on.exit(dev.flush())
    plot.new()
    localWindow(xlim, ylim, log, asp, ...)
    panel.first
    plot.xy(xy, type, ...)
    panel.last
    if (axes) {
        localAxis(if (is.null(y)) 
            xy$x
        else x, side = 1, ...)
        localAxis(if (is.null(y)) 
            x
        else y, side = 2, ...)
    }
    if (frame.plot) 
        localBox(...)
    if (ann) 
        localTitle(main = main, sub = sub, xlab = xlab, ylab = ylab, 
            ...)
    invisible()
} plotsub(1:10, 1:10, type = "l", xlim = c(1, 5), ylim=c(1,10) )
-------------------------------------------------------------------------------------------------------
```{r clock, fig.width=7, fig.height=6, fig.show='animate'}
par(mar = rep(3, 4))
for (i in seq(pi/2, -4/3 * pi, length = 12)) {
    plot(0, 0, pch = 20, ann = FALSE, axes = FALSE)
    arrows(0, 0, cos(i), sin(i))
    axis(1, 0, "VI"); axis(2, 0, "IX")
    axis(3, 0, "XII"); axis(4, 0, "III"); box()
}
```
-------------------------------------------------------------------------------------------------------
ROC ROC ROC ROC2 if (any(!is.na(match("ROC", toupper(plot))))) {
        plot(1 - res[, 2], res[, 1], xlim = 0:1, xlab = "1-Specificity", 
            ylim = 0:1, ylab = "Sensitivity", type = "n", ...)
        if (is.numeric(grid)) 
            abline(h = grid/100, v = grid/100, col = gray(0.9))
        abline(0, 1, col = gray(0.4))
        box()
        lines(1 - res[, 2], res[, 1], lwd = lwd) col = "red" lines mycol lines(1 - res[, 2], res[, 1], lwd = lwd, col = mycol) ROC.tic Epi:::ROC.tic
-------------------------------------------------------------------------------------------------------
voronoipolygons <- function(x,poly) {
  require(deldir)
  if (.hasSlot(x, 'coords')) {
    crds <- x@coords  
  } else crds <- x
  bb = bbox(poly)
  rw = as.numeric(t(bbox(pznall)))
  z <- deldir(crds[,1], crds[,2],rw=rw)
  w <- tile.list(z)
  polys <- vector(mode='list', length=length(w))
  require(sp)
  for (i in seq(along=polys)) {
    pcrds <- cbind(w[[i]]$x, w[[i]]$y)
    pcrds <- rbind(pcrds, pcrds[1,])
    polys[[i]] <- Polygons(list(Polygon(pcrds)), ID=as.character(i))
  }
  SP <- SpatialPolygons(polys)

  voronoi <- SpatialPolygonsDataFrame(SP, data=data.frame(x=crds[,1],
                                                          y=crds[,2], row.names=sapply(slot(SP, 'polygons'), 
                                                                                       function(x) slot(x, 'ID'))))

  return(voronoi)

} pzn.coords<-voronoipolygons(coords,pznall)
library(rgeos)
gg = gIntersection(pznall,pzn.coords,byid=TRUE)
plot(gg) gg
-------------------------------------------------------------------------------------------------------
extent xmin min ymax xmax # create a dummy raster
r1 <- raster(nrows=108, ncols=21, xmn=0, xmx=10)
r1[] <-1

extent(r1)
## class       : Extent 
## xmin        : 0 
## xmax        : 10 
## ymin        : -90 
## ymax        : 90 xmin(r1)
## [1] 0
xmax(r1)
##[1] 10
ymin(r1)
## [1] -90
ymax(r1)
## [1] 90 SpatialGridDataFrame bbox .grid <- as(r1,'SpatialGridDataFrame')

bbox(.grid)
##    min max
## s1   0  10
##  2 -90  90 cellFromXY id NA # some data
 .points <- rbind(c(1,1),c(-4,1))
 # the first point lies within the raster, the second not

 # cell from XY will tell you this.
 cellFromXY(r1,.points)
 ## [1] 1116   NA get_map ggmap raster bb hdf <- get_map()
  attr(hdf,'bb')
##    ll.lat    ll.lon   ur.lat    ur.lon
## 1 29.38048 -95.80204 30.14344 -94.92313 ggmap_rasterlayer <- function(map){
  map_bbox <- attr(map, 'bb') 
  .extent <- extent(as.numeric(map_bbox[c(2,4,1,3)]))
  my_map <- raster(.extent, nrow= nrow(map), ncol = ncol(map))
  rgb_cols <- setNames(as.data.frame(t(col2rgb(map))), c('red','green','blue'))
  red <- my_map
  values(red) <- rgb_cols[['red']]
  green <- my_map
  values(green) <- rgb_cols[['green']]
  blue <- my_map
  values(blue) <- rgb_cols[['blue']]
  stack(red,green,blue)

}

my_map <- ggmap_rasterlayer(hdf)
-------------------------------------------------------------------------------------------------------
box() hist(...., axes = FALSE) ## .... is where your other args go
axis(side = 2)
axis(side = 1, at = seq(1730, 1830, by = 20)) axis(side = 1, at = seq(1725, 1835, by = 20))
-------------------------------------------------------------------------------------------------------
?curve ?axis ## draw the curve
curve(1-exp(-x^2/730),from=0,to=370,axes=FALSE)
axis(side=2)  ## add default lefthand axis
axis(side=1,at=seq(0,370,by=10))  ## add custom bottom axis
box(bty="l")  ## add a box cex.axis=0.5 staxlab plotrix
-------------------------------------------------------------------------------------------------------
quantile() rug() set.seed(1)
X <- rnorm(200)
boxplot(X, yaxt = "n")

## compute the required quantiles
qntl <- quantile(X, probs = c(0.85, 0.90))

## add them as a rgu plot to the left hand side
rug(qntl, side = 2, col = "blue", lwd = 2)

## add the box and axes
axis(2)
box() str() set.seed(1) ## make reproducible
HWD <- data.frame(Hour = rep(0:23, 10),
                  Houston_Load = rnorm(24*10)) Hour Hour quantile() quants <- sapply(split(HWD$Houston_Load, list(HWD$Hour)),
                 quantile, probs = c(0.85, 0.9)) R> quants <- sapply(split(HWD$Houston_Load, list(HWD$Hour)),
+                  quantile, probs = c(0.85, 0.9))
R> quants
            0         1        2         3         4         5        6
85% 0.3576510 0.8633506 1.581443 0.2264709 0.4164411 0.2864026 1.053742
90% 0.6116363 0.9273008 2.109248 0.4218297 0.5554147 0.4474140 1.366114
            7         8        9       10        11        12       13       14
85% 0.5352211 0.5175485 1.790593 1.394988 0.7280584 0.8578999 1.437778 1.087101
90% 0.8625322 0.5969672 1.830352 1.519262 0.9399476 1.1401877 1.763725 1.102516
           15        16        17        18       19        20       21
85% 0.6855288 0.4874499 0.5493679 0.9754414 1.095362 0.7936225 1.824002
90% 0.8737872 0.6121487 0.6078405 1.0990935 1.233637 0.9431199 2.175961
          22        23
85% 1.058648 0.6950166
90% 1.145783 0.8436541 boxplot(Houston_Load ~ Hour, data = HWD, axes = FALSE)
xlocs <- 1:24 ## where to draw marks
tickl <- 0.15 ## length of marks used
for(i in seq_len(ncol(quants))) {
    segments(x0 = rep(xlocs[i] - 0.15, 2), y0 = quants[, i],
             x1 = rep(xlocs[i] + 0.15, 2), y1 = quants[, i],
             col = c("red", "blue"), lwd = 2)
}
title(xlab = "Hour", ylab = "Houston Load")
axis(1, at = xlocs, labels = xlocs - 1)
axis(2)
box()
legend("bottomleft", legend = paste(c("0.85", "0.90"), "quantile"),
       bty = "n", lty = "solid", lwd = 2, col = c("red", "blue"))
-------------------------------------------------------------------------------------------------------
box(lwd=5)
-------------------------------------------------------------------------------------------------------
table prop.table set.seed(001) # For the simulation to be reproducible.
simulated_roulette_wheel = sample(roulette_wheel, size=500, replace = TRUE)

tab <-table(simulated_roulette_wheel)                  # Frequency of each factor
prop.tab <- prop.table(tab) * 100                      # % Relative Freq.
barplot(prop.tab, xaxs='i', ylab="Relative %") ; box() # Barplot barplot xaxs="i" box() prop.tab prop.tab[1:10]
simulated_roulette_wheel
  0  00  B1 B10 B11 B12 B13 B14 B15 B16 
2.4 2.8 4.6 3.4 2.2 3.0 1.8 2.4 2.2 2.2 prop.table(tab)
-------------------------------------------------------------------------------------------------------
?par cex col par col.lab col.axis main col.main x <- 1:10
y <- 1:10

plot(x , y,xlab="x axis", ylab="y axis",  pch=19, col.axis = 'blue', col.lab = 'red', cex.axis = 1.5, cex.lab = 2) ?axis ?box box plot(x , y,xlab="x axis", ylab="y axis",  pch=19,  cex.lab = 2, axes = F,col.lab = 'red')
box(col = 'lightblue')
axis(1, col = 'blue', col.axis = 'purple', col.ticks = 'darkred', cex.axis = 1.5, font = 2, family = 'serif')
axis(2, col = 'maroon', col.axis = 'pink', col.ticks = 'limegreen', cex.axis = 0.9, font =3, family = 'mono')
-------------------------------------------------------------------------------------------------------
ylabel <- c(0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6, 1.8, 2.0, 2.2, 2.4, 2.6)
y_range <- range(0, ylabel)
0.2*0:y_range[1] R> 0.2*0:y_range[1]
[1] 0 y_range R> 0.2*0:y_range[2]
[1] 0.0 0.2 0.4
R> 0:y_range[2]
[1] 0 1 2 : x:y seq(from = x, to = y, by = 1) 2.6+1 2.6 to 0, 1, 2 ylabel <- seq(0, 2.6, by = 0.2)
axis(2, at = ylabel) ylabel R> ylabel
[1] 0.0 0.2 0.4 0.6 0.8 1.0 1.2 1.4 1.6 1.8 2.0 2.2 2.4 2.6 dat <- data.frame(y = runif(20, min = 0, max = 3),
                  x = rnorm(20))

plot(y ~ x, data = dat, axes = FALSE)
ylabel <- seq(0, 2.6, by = 0.2)
axis(1)
axis(2, at = ylabel, las = 1)
box()
-------------------------------------------------------------------------------------------------------
polygon y98 = aggregate(gcdata$Pause.s. ~ hours, data=gcdata, FUN=q98)
y02 = aggregate(gcdata$Pause.s. ~ hours, data=gcdata, FUN=q02)
ymax = aggregate(gcdata$Pause.s. ~ hours, data=gcdata, FUN=max)
ymin = aggregate(gcdata$Pause.s. ~ hours, data=gcdata, FUN=min)
ymean = aggregate(gcdata$Pause.s. ~ hours, data=gcdata, FUN=mean)

x = ymean[,1]
y1 = cbind(y02[,2], ymean[,2], y98[,2])
y2 = cbind(ymin[,2], ymean[,2], ymax[,2])

plotAreaCI(x,y2, ylim=c(0,2), xlab="time", ylab="variable")
plotAreaCI(x,y1, ylim=c(0,2), poly.col="blue", add=TRUE) plotAreaCI(x,y2, ylim=c(0,2), xlab="time", ylab="variable", nice.x = TRUE)
plotAreaCI(x,y1, ylim=c(0,2), mean.lwd=2, poly.col="blue", add=TRUE) plotAreaCI plotAreaCI = function(x, y, add=FALSE, nice.x = FALSE,
                          xlim=NULL, ylim=NULL,
                          mean.col="black", mean.lwd=1.5,
                          poly.col="gray", poly.lty=3,
                          xlab=NULL, ylab=NULL, main="",
                          ...) {
      isFactorX = isClass("factor", x)
      if(isFactorX) {
        x.label = x
        x = as.numeric(x)
      }
      if(is.null(xlim)) xlim=range(x, na.rm=TRUE)
      if(is.null(ylim)) ylim=range(y, na.rm=TRUE)
      x.pol = c(x, rev(x), x[1])
      y.pol = c(y[,1], rev(y[,3]), y[,1][3])
      if(!add) {
        plot.new()
        plot.window(xlim=xlim, ylim=ylim, ...)
        if(!nice.x & isFactorX) {
          axis(1, at=x, labels=x.label)
        } else {
          xticks = axTicks(1)
          if(isFactorX) {
            xticks = xticks[xticks>=1]
            axis(1, at=xticks, labels=x.label[xticks])
          } else {
            axis(1)
          }
        }
            axis(2, las=1)
        box()
        title(xlab=xlab, ylab=ylab, main=main)
      }
      polygon(x.pol, y.pol, col=poly.col, lty=poly.lty)
      lines(x, y[,2], col=mean.col, lwd=mean.lwd)
      return(invisible())
    }
-------------------------------------------------------------------------------------------------------
library(dynlm)
set.seed(771104)
x <- 5 + seq(1, 10, len=100) + rnorm(100)
y <- x + rnorm(100)
model <- dynlm(x ~ y)

par(oma=c(1,1,1,2))
plotModel(x, model) # works with models which accept 'predict' and 'residuals' plotModel plotModel =  function(x, model) {
  ymodel1 = range(x, fitted(model), na.rm=TRUE)
  ymodel2 = c(2*ymodel1[1]-ymodel1[2], ymodel1[2])
  yres1   = range(residuals(model), na.rm=TRUE)
  yres2   = c(yres1[1], 2*yres1[2]-yres1[1])
  plot(x, type="l", col="red", lwd=2, ylim=ymodel2, axes=FALSE,
       ylab="", xlab="")
  axis(1)
  mtext("residuals", 1, adj=0.5, line=2.5)
  axis(2, at=pretty(ymodel1))
  mtext("observed/modeled", 2, adj=0.75, line=2.5)
  lines(fitted(model), col="green", lwd=2)
  par(new=TRUE)
  plot(residuals(model), col="blue", type="l", ylim=yres2, axes=FALSE, 
       ylab="", xlab="")
  axis(4, at=pretty(yres1))
  mtext("residuals", 4, adj=0.25, line=2.5)
  abline(h=quantile(residuals(model), probs=c(0.1,0.9)), lty=2, col="gray")
  abline(h=0)
  box()  
}
-------------------------------------------------------------------------------------------------------
xlim ylim R> plot(EU, ylim=c(30, 70), xlim=c(-10, 44))
R> box()
-------------------------------------------------------------------------------------------------------
spplot sp.layout spCounty <- list("sp.polygons", county, col = NA)
spState <- list("sp.polygons", state) sp.layout # spplot(county, zcol = "z", col = NA, sp.layout = list(spCounty, spState))
# actually, you only need to pass the second layout item to sp.layout
spplot(county, zcol = "z", col = NA, sp.layout = spState) bbox(obj) theMin <- pmin(bbox(county)[,1], bbox(state)[,1])
theMax <- pmax(bbox(county)[,2], bbox(state)[,2])

spplot(county, zcol = "z", col = NA, sp.layout = spState,
  ylim = c(theMin[2], theMax[2]), xlim = c(theMin[1], theMax[1]))
-------------------------------------------------------------------------------------------------------
glayout do_expand=FALSE size<- library(gWidgets)
options(guiToolkit="RGtk2")
w <- gwindow()
g <- ggroup(cont=w)
do_expand=TRUE
options <- glayout(cont=g, spacing=5, expand=do_expand)
items <- ""

options[1,1] = "vanilla"
options[1,2] <- gcombobox(items, cont=options)

options[2,1] = "expand"
options[2,2, expand=TRUE] <- gcombobox(items, cont=options)

options[3,1] = "expand, fill"
options[3,2, expand=TRUE, fill="y"] <- gcombobox(items, cont=options)

options[4,1] = "size"
options[4,2] <- (cb <- gcombobox(items, cont=options))
size(cb) <- c(250, -1)

## populate comboboxes 
items <- state.name 
sapply(options[,2], function(i) i[] <- items)
-------------------------------------------------------------------------------------------------------
plot.stacked plot.stacked <- function(x,y, ylab="", xlab="", ncol=1, xlim=range(x, na.rm=T), ylim=c(0, 1.2*max(rowSums(y), na.rm=T)), border = NULL, col=rainbow(length(y[1,]))){

    plot(x,y[,1], ylab=ylab, xlab=xlab, ylim=ylim, xaxs="i", yaxs="i", xlim=xlim, t="n")
    bottom=0*y[,1]
    for(i in 1:length(y[1,])){
        top=rowSums(as.matrix(y[,1:i]))
        polygon(c(x, rev(x)), c(top, rev(bottom)), border=border, col=col[i])
        bottom=top
    }
    abline(h=seq(0,200000, 10000), lty=3, col="grey")
    legend("topleft", rev(colnames(y)), ncol=ncol, inset = 0, fill=rev(col), bty="0", bg="white", cex=0.8, col=col)
    box()
} set.seed(1)
m <- 500
n <- 15
x <- seq(m)
y <- matrix(0, nrow=m, ncol=n)
colnames(y) <- seq(n)
for(i in seq(ncol(y))){
    mu <- runif(1, min=0.25*m, max=0.75*m)
    SD <- runif(1, min=5, max=30)
    TMP <- rnorm(1000, mean=mu, sd=SD)
    HIST <- hist(TMP, breaks=c(0,x), plot=FALSE)
    fit <- smooth.spline(HIST$counts ~ HIST$mids)
    y[,i] <- fit$y
}

    plot.stacked(x,y) plot.stream library(devtools)
source_url('https://gist.github.com/menugget/7864454/raw/f698da873766347d837865eecfa726cdf52a6c40/plot.stream.4.R')

set.seed(1)
m <- 500
n <- 50
x <- seq(m)
y <- matrix(0, nrow=m, ncol=n)
colnames(y) <- seq(n)
for(i in seq(ncol(y))){
    mu <- runif(1, min=0.25*m, max=0.75*m)
    SD <- runif(1, min=5, max=30)
    TMP <- rnorm(1000, mean=mu, sd=SD)
    HIST <- hist(TMP, breaks=c(0,x), plot=FALSE)
    fit <- smooth.spline(HIST$counts ~ HIST$mids)
    y[,i] <- fit$y
}
y <- replace(y, y<0.01, 0)

#order by when 1st value occurs
ord <- order(apply(y, 2, function(r) min(which(r>0))))
y2 <- y[, ord]
COLS <- rainbow(ncol(y2))

png("stream.png", res=400, units="in", width=12, height=4)
par(mar=c(0,0,0,0), bty="n")
plot.stream(x,y2, axes=FALSE, xlim=c(100, 400), xaxs="i", center=TRUE, spar=0.2, frac.rand=0.1, col=COLS, border=1, lwd=0.1)
dev.off() #plot.stream makes a "stream plot" where each y series is plotted 
#as stacked filled polygons on alternating sides of a baseline.
#
#Arguments include:
#'x' - a vector of values
#'y' - a matrix of data series (columns) corresponding to x
#'order.method' = c("as.is", "max", "first") 
#  "as.is" - plot in order of y column
#  "max" - plot in order of when each y series reaches maximum value
#  "first" - plot in order of when each y series first value > 0
#'center' - if TRUE, the stacked polygons will be centered so that the middle,
#i.e. baseline ("g0"), of the stream is approximately equal to zero. 
#Centering is done before the addition of random wiggle to the baseline. 
#'frac.rand' - fraction of the overall data "stream" range used to define the range of
#random wiggle (uniform distrubution) to be added to the baseline 'g0'
#'spar' - setting for smooth.spline function to make a smoothed version of baseline "g0"
#'col' - fill colors for polygons corresponding to y columns (will recycle)
#'border' - border colors for polygons corresponding to y columns (will recycle) (see ?polygon for details)
#'lwd' - border line width for polygons corresponding to y columns (will recycle)
#'...' - other plot arguments
plot.stream <- function(
    x, y, 
    order.method = "as.is", frac.rand=0.1, spar=0.2,
    center=TRUE,
    ylab="", xlab="",  
    border = NULL, lwd=1, 
    col=rainbow(length(y[1,])),
    ylim=NULL, 
    ...
){

if(sum(y < 0) > 0) error("y cannot contain negative numbers")

if(is.null(border)) border <- par("fg")
border <- as.vector(matrix(border, nrow=ncol(y), ncol=1))
col <- as.vector(matrix(col, nrow=ncol(y), ncol=1))
lwd <- as.vector(matrix(lwd, nrow=ncol(y), ncol=1))

if(order.method == "max") {
    ord <- order(apply(y, 2, which.max))
    y <- y[, ord]
    col <- col[ord]
    border <- border[ord]
}

if(order.method == "first") {
    ord <- order(apply(y, 2, function(x) min(which(r>0))))
    y <- y[, ord]
    col <- col[ord]
    border <- border[ord]
}

bottom.old <- x*0
top.old <- x*0
polys <- vector(mode="list", ncol(y))
for(i in seq(polys)){
    if(i %% 2 == 1){ #if odd
        top.new <- top.old + y[,i]
        polys[[i]] <- list(x=c(x, rev(x)), y=c(top.old, rev(top.new)))
        top.old <- top.new
    }
    if(i %% 2 == 0){ #if even
        bottom.new <- bottom.old - y[,i]
        polys[[i]] <- list(x=c(x, rev(x)), y=c(bottom.old, rev(bottom.new)))
        bottom.old <- bottom.new
    }
}

ylim.tmp <- range(sapply(polys, function(x) range(x$y, na.rm=TRUE)), na.rm=TRUE)
outer.lims <- sapply(polys, function(r) rev(r$y[(length(r$y)/2+1):length(r$y)]))
mid <- apply(outer.lims, 1, function(r) mean(c(max(r, na.rm=TRUE), min(r, na.rm=TRUE)), na.rm=TRUE))

#center and wiggle
if(center) {
    g0 <- -mid + runif(length(x), min=frac.rand*ylim.tmp[1], max=frac.rand*ylim.tmp[2])
} else {
    g0 <- runif(length(x), min=frac.rand*ylim.tmp[1], max=frac.rand*ylim.tmp[2])
}

fit <- smooth.spline(g0 ~ x, spar=spar)

for(i in seq(polys)){
    polys[[i]]$y <- polys[[i]]$y + c(fit$y, rev(fit$y))
}

if(is.null(ylim)) ylim <- range(sapply(polys, function(x) range(x$y, na.rm=TRUE)), na.rm=TRUE)
plot(x,y[,1], ylab=ylab, xlab=xlab, ylim=ylim, t="n", ...)
for(i in seq(polys)){
    polygon(polys[[i]], border=border[i], col=col[i], lwd=lwd[i])
}

}
-------------------------------------------------------------------------------------------------------
plot(x, y, log='x') xnew <- ifelse(x<10, x, x/10)
plot(xnew, y, axes=FALSE, xlab='x')
axis(1, at=c(0, 10, 20), labels=c(0, 10, 100))
axis(2)
box()
-------------------------------------------------------------------------------------------------------
par('mar') pdf(file = "ExampleOutput2.pdf",
    width = 6.61,
    height = 6.61,
    pointsize = 10
    )
set.seed(42)
catA <- factor(c("m100", "m500", "m1000", "m2000", "m3000", "m5000"))
catB <- factor(20:28)
samples <- 100
rsample <- function(v) v[ceiling(runif(samples, max=length(v)))]
Tab <- data.frame(catA = rsample(catA),
                  catB = rsample(catB),
                  valA = rnorm(samples, 150, 8),
                  valB = pmin(1,pmax(0,rnorm(samples, 0.5, 0.3))))
par(mfrow = c(2,2), mar= c(3, 4, 1, 1) + 0.1)
for (i in 0:3) {
  x <- Tab[[1 + i %% 2]]
  plot(x, Tab[[3 + i %/% 2]], mar= if(i %/%2 == 0) {c(4, 4, 1, 1) + 0.1 
                                              }else{c(1, 1, 1, 1) + 0.1},
       xlab = if (i %/% 2 == 1) "Some Categories" else NULL,
       ylab = if (i %% 2 == 0) "Some Values" else NULL,
       axes = FALSE
       )
  axis(side = 1,
       at=1:nlevels(x),
       labels = if (i %/% 2 == 1) levels(x) else FALSE)
  axis(side = 2, labels = (i %% 2 == 0))
  box(which = "plot", bty = "l")
}
par(mfrow = c(1,1))
dev.off()
-------------------------------------------------------------------------------------------------------
title() outer = TRUE op <- par(mfrow = c(2,2),
          oma = c(5,4,0,0) + 0.1,
          mar = c(0,0,1,1) + 0.1) op 5 4 mar mar for() title(xlab = "Some Categories",
      ylab = "Some Values",
      outer = TRUE, line = 3) set.seed(42)
catA <- factor(c("m100", "m500", "m1000", "m2000", "m3000", "m5000"))
catB <- factor(20:28)
samples <- 100
rsample <- function(v) v[ceiling(runif(samples, max=length(v)))]
Tab <- data.frame(catA = rsample(catA),
                  catB = rsample(catB),
                  valA = rnorm(samples, 150, 8),
                  valB = pmin(1,pmax(0,rnorm(samples, 0.5, 0.3))))
op <- par(mfrow = c(2,2),
          oma = c(5,4,0,0) + 0.1,
          mar = c(0,0,1,1) + 0.1)
for (i in 0:3) {
  x <- Tab[[1 + i %% 2]]
  plot(x, Tab[[3 + i %/% 2]], axes = FALSE)
  axis(side = 1,
       at=1:nlevels(x),
       labels = if (i %/% 2 == 1) levels(x) else FALSE)
  axis(side = 2, labels = (i %% 2 == 0))
  box(which = "plot", bty = "l")
}
title(xlab = "Some Categories",
      ylab = "Some Values",
      outer = TRUE, line = 3)
par(op)
-------------------------------------------------------------------------------------------------------
box() frame()
plot.window(xlim=c(0,1), ylim=c(-.6, .8))
axis(1, at=c(0, .2, .4, .6, .8, 1.0), lwd=2)
axis(2, at=c(-.6, -.4, -.2, 0, .2, .4, .6, .8), lwd=2)
box(lwd = 2)
-------------------------------------------------------------------------------------------------------
ggplot plot rgeos library(rgeos)
library(RColorBrewer)

# Get centroids of countries
theCents <- coordinates(world.map)

# extract the polygons objects
pl <- slot(world.map, "polygons")

# Create square polygons that cover the east (left) half of each country's bbox
lpolys <- lapply(seq_along(pl), function(x) {
  lbox <- bbox(pl[[x]])
  lbox[1, 2] <- theCents[x, 1]
  Polygon(expand.grid(lbox[1,], lbox[2,])[c(1,3,4,2,1),])
})

# Slightly different data handling
wmRN <- row.names(world.map)

n <- nrow(world.map@data)
world.map@data[, c("growth", "category")] <- list(growth = 4*runif(n),
                 category = factor(sample(1:5, n, replace=TRUE)))

# Determine the intersection of each country with the respective "left polygon"
lPolys <- lapply(seq_along(lpolys), function(x) {
  curLPol <- SpatialPolygons(list(Polygons(lpolys[x], wmRN[x])),
    proj4string=CRS(proj4string(world.map)))
  curPl <- SpatialPolygons(pl[x], proj4string=CRS(proj4string(world.map)))
  theInt <- gIntersection(curLPol, curPl, id = wmRN[x])
  theInt
})

# Create a SpatialPolygonDataFrame of the intersections
lSPDF <- SpatialPolygonsDataFrame(SpatialPolygons(unlist(lapply(lPolys,
  slot, "polygons")), proj4string = CRS(proj4string(world.map))),
  world.map@data)

##########
## EDIT ##
##########
# Create a slightly less harsh color set
s_growth <- scale(world.map@data$growth,
  center = min(world.map@data$growth), scale = max(world.map@data$growth))
growthRGB <- colorRamp(c("red", "blue"))(s_growth)
growthCols <- apply(growthRGB, 1, function(x) rgb(x[1], x[2], x[3],
  maxColorValue = 255))
catCols <- brewer.pal(nlevels(lSPDF@data$category), "Pastel2")

# and plot
plot(world.map, col = growthCols, bg = "grey90")

plot(lSPDF, col = catCols[lSPDF@data$category], add = TRUE) ggplot2 ggplot2 coordinates(lSPDF) rSPDF # Create square polygons that cover west (right) half of each country's bbox
rpolys <- lapply(seq_along(pl), function(x) {
  rbox <- bbox(pl[[x]])
  rbox[1, 1] <- theCents[x, 1]
  Polygon(expand.grid(rbox[1,], rbox[2,])[c(1,3,4,2,1),])
})

# Determine the intersection of each country with the respective "right polygon"
rPolys <- lapply(seq_along(rpolys), function(x) {
  curRPol <- SpatialPolygons(list(Polygons(rpolys[x], wmRN[x])),
    proj4string=CRS(proj4string(world.map)))
  curPl <- SpatialPolygons(pl[x], proj4string=CRS(proj4string(world.map)))
  theInt <- gIntersection(curRPol, curPl, id = wmRN[x])
  theInt
})

# Create a SpatialPolygonDataFrame of the western (right) intersections
rSPDF <- SpatialPolygonsDataFrame(SpatialPolygons(unlist(lapply(rPolys,
  slot, "polygons")), proj4string = CRS(proj4string(world.map))),
  world.map@data) lSPDF rSPDF points(coordinates(rSPDF), col = factor(rSPDF@data$REGION))
# or
text(coordinates(lSPDF), labels = lSPDF@data$FIPS, cex = .7)
-------------------------------------------------------------------------------------------------------
output$plot_Total <- reactivePlot(function() { 
  plot.new()
   plot.window(xlim=c(1850,2020), ylim = c(0,5000000))
   axis(1)
   axis(2)
   title(main="Numbers over the years")
   title(xlab="Year")
   title(ylab="Number of people")
   box()
   points(dat$Year, dat$Total, col="red")
   lines(dat$Year, dat$Total, col="red")
  if (input$RC) {   lines(dat$Year, dat$dat)}
  })
-------------------------------------------------------------------------------------------------------
VerticalHist <- function(x, xscale = NULL, xwidth, hist,
                         fillCol = "gray80", lineCol = "gray40") {
    ## x (required) is the x position to draw the histogram
    ## xscale (optional) is the "height" of the tallest bar (horizontally),
    ##   it has sensible default behavior
    ## xwidth (required) is the horizontal spacing between histograms
    ## hist (required) is an object of type "histogram"
    ##    (or a list / df with $breaks and $density)
    ## fillCol and lineCol... exactly what you think.
    binWidth <- hist$breaks[2] - hist$breaks[1]
    if (is.null(xscale)) xscale <- xwidth * 0.90 / max(hist$density)
    n <- length(hist$density)
    x.l <- rep(x, n)
    x.r <- x.l + hist$density * xscale
    y.b <- hist$breaks[1:n]
    y.t <- hist$breaks[2:(n + 1)]

    rect(xleft = x.l, ybottom = y.b, xright = x.r, ytop = y.t,
         col = fillCol, border = lineCol)
}



## Usage example
require(plyr) ## Just needed for the round_any() in this example
n <- 1000
numberOfHists <- 4
data <- data.frame(ReleaseDOY = rnorm(n, 110, 20),
                   bin = as.factor(rep(c(1, 2, 3, 4), n / 4)))
binWidth <- 1
binStarts <- c(1, 2, 3, 4)
binMids <- binStarts + binWidth / 2
axisCol <- "gray80"

## Data handling
DOYrange <- range(data$ReleaseDOY)
DOYrange <- c(round_any(DOYrange[1], 15, floor),
                      round_any(DOYrange[2], 15, ceiling))

## Get the histogram obects
histList <- with(data, tapply(ReleaseDOY, bin, hist, plot = FALSE,
    breaks = seq(DOYrange[1], DOYrange[2], by = 5)))
DOYmean <- with(data, tapply(ReleaseDOY, bin, mean))

## Plotting
par(mar = c(5, 5, 1, 1) + .1)
plot(c(0, 5), DOYrange, type = "n",
     ann = FALSE, axes = FALSE, xaxs = "i", yaxs = "i")

axis(1, cex.axis = 1.2, col = axisCol)
mtext(side = 1, outer = F, line = 3, "Length at tagging (mm)",
      cex = 1.2)
axis(2, cex.axis = 1.2, las = 1, line = -.7, col = "white",
    at = c(75, 107, 138, 169),
    labels = c("March", "April", "May", "June"), tck = 0)
mtext(side = 2, outer = F, line = 3.5, "Date tagged", cex = 1.2)
box(bty = "L", col = axisCol)

## Gridlines
abline(h = c(60, 92, 123, 154, 184), col = "gray80")

biggestDensity <- max(unlist(lapply(histList, function(h){max(h[[4]])})))
xscale <- binWidth * .9 / biggestDensity

## Plot the histograms
for (lengthBin in 1:numberOfHists) {
    VerticalHist(binStarts[lengthBin], xscale = xscale,
                         xwidth = binWidth, histList[[lengthBin]])
    }
-------------------------------------------------------------------------------------------------------
plot.new()
par(mfcol=c(1,2))
plot(1:5,ann=FALSE,bty="n",type="l",ylim=c(0,25))
grid(ny=NA)
par(mar=c(5.1, 0, 4.1, 2.1))
plot(c(10,20,30,40,50),c(8,5,15,20,20),yaxt="n",ann=FALSE,bty="n",type="l",ylim=c(0,25))
grid(ny=NA)
par(new=TRUE)
par(mfcol=c(1,1))
par(bty="l")
par(mar=c(5.1, 4.1, 4.1, 2.1))
plot(NA,ylim=c(0,25),type="n",xaxt="n",yaxt="n",ann=FALSE)
box()
grid(nx=NA,ny=NULL)
-------------------------------------------------------------------------------------------------------
fig.align="left" par(mar) ?par par(mar = c(0, 0, 0, 0)) \parindent \documentclass{book}
\setlength{\parindent}{0pt}
\begin{document}
<<chunk.maps, fig.height=12, fig.width=21, out.width="6in", fig.align='left'>>=
library(maptools)
data(wrld_simpl)
par(mar = c(0, 0, 0, 0))
plot(wrld_simpl)
box()
@
\end{document} \parindent
-------------------------------------------------------------------------------------------------------
ab ab xts xtsExtra xtsExtra library(xts)

ab=structure(c(-1, 0.579760106421202, -0.693649703427259, 0.0960078627769613, 
           0.829770469089809, -0.804276208608663, 0.72574639798749, 0.977165659135716, 
           -0.880178529686181, -0.662078620277974, -1, 2.35268982675599, 
           -0.673979231663719, 0.0673890875594205, 1.46584597734824, 0.38403707067242, 
           -1.53638088345349, 0.868743976582955, -1.8394614923913, 0.246736581314485), .Dim = c(10L, 2L), .Dimnames = list(NULL, c("a", "b")), index = structure(c(1354683600, 
          1354770000, 1354856400, 1354942800, 1355029200, 1355115600, 1355202000, 
          1355288400, 1355374800, 1355461200), tzone = "", tclass = "Date"), class = c("xts", 
          "zoo"), .indexCLASS = "Date", .indexTZ = "", tclass = "Date", tzone = "")

#Set up the plot area so that multiple graphs can be crammed together
#In the "par()" statement below, the "mar=c(0.3, 0, 0, 0)" part is used to change
#the spacing between the graphs.   "mar=c(0, 0, 0, 0)" is zero spacing.
par(pty="m", plt=c(0.1, 0.9, 0.1, 0.9), omd=c(0.1, 0.9, 0.2, 0.9), mar=c(0.3, 0, 0, 0))

#Set the area up for 2 plots
par(mfrow = c(2, 1))

#Build the x values so that plot() can be used, allowing more control over the format
xval <- index(ab)

#Plot the top graph with nothing in it =========================
plot(x=xval, y=ab$a, type="n", xaxt="n", yaxt="n", main="", xlab="", ylab="")
mtext(text="ab", side=3, font=2, line=0.5, cex=1.5)

#Store the x-axis data of the top plot so it can be used on the other graphs
pardat <- par()

#Layout the x axis tick marks
xaxisdat <- index(ab)

#If you want the default plot tick mark locations, un-comment the following calculation
#xaxisdat <- seq(pardat$xaxp[1], pardat$xaxp[2], (pardat$xaxp[2]-pardat$xaxp[1])/pardat$xaxp[3])

#Get the y-axis data and add the lines and label
yaxisdat <- seq(pardat$yaxp[1], pardat$yaxp[2], (pardat$yaxp[2]-pardat$yaxp[1])/pardat$yaxp[3])
axis(side=2, at=yaxisdat, las=2, padj=0.5, cex.axis=0.8, hadj=0.5, tcl=-0.3)
abline(v=xaxisdat, col="lightgray")
abline(h=yaxisdat, col="lightgray")
mtext(text="ab$a", side=2, line=2.3)
lines(x=xval, y=ab$a, col="red")
box() #Draw an outline to make sure that any overlapping abline(v)'s or abline(h)'s are covered

#Plot the 2nd graph with nothing in it ================================
plot(x=xval, y=ab$b,  type="n", xaxt="n", yaxt="n", main="", xlab="", ylab="")

#Get the y-axis data and add the lines and label
pardat <- par()
yaxisdat <- seq(pardat$yaxp[1], pardat$yaxp[2], (pardat$yaxp[2]-pardat$yaxp[1])/pardat$yaxp[3])
axis(side=2, at=yaxisdat, las=2, padj=0.5, cex.axis=0.8, hadj=0.5, tcl=-0.3)
abline(v=xaxisdat, col="lightgray")
abline(h=yaxisdat, col="lightgray")
mtext(text="ab$b", side=2, line=2.3)
lines(x=xval, y=ab$b, col="blue")
box() #Draw an outline to make sure that any overlapping abline(v)'s or abline(h)'s are covered

#Plot the X axis =================================================
axis(side=1, label=format(as.Date(xaxisdat), "%b %d\n%Y\n") , at=xaxisdat, padj=0.4, cex.axis=0.8, hadj=0.5, tcl=-0.3)
mtext(text="Date", side=1, line=2.5)
-------------------------------------------------------------------------------------------------------
require(maptools)
require(rgdal)

fixup <- function(usa,alaskaFix,hawaiiFix){

  alaska=usa[usa$STATE_NAME=="Alaska",]
  alaska = fix1(alaska,alaskaFix)
  proj4string(alaska) <- proj4string(usa)

  hawaii = usa[usa$STATE_NAME=="Hawaii",]
  hawaii = fix1(hawaii,hawaiiFix)
  proj4string(hawaii) <- proj4string(usa)

  usa = usa[! usa$STATE_NAME %in% c("Alaska","Hawaii"),]
  usa = rbind(usa,alaska,hawaii)

  return(usa)

}

fix1 <- function(object,params){
  r=params[1];scale=params[2];shift=params[3:4]
  object = elide(object,rotate=r)
  size = max(apply(bbox(object),1,diff))/scale
  object = elide(object,scale=size)
  object = elide(object,shift=shift)
  object
} rgdal us = readOGR(dsn = "states_21basic",layer="states") usAEA = spTransform(us,CRS("+init=epsg:2163"))
usfix = fixup(usAEA,c(-35,1.5,-2800000,-2600000),c(-35,1,6800000,-1600000))
plot(usfix) usfixLL = spTransform(usfix,CRS("+init=epsg:4326"))
plot(usfixLL) ggplot spTransform ggplot2 usfix
-------------------------------------------------------------------------------------------------------
polygrid geoR SpatialPoints expand.grid overlay data(meuse.grid)
 coordinates(meuse.grid) = ~x+y
 x <- chull(meuse.grid@coords)
 borders <- meuse.grid@coords[c(x,x[1]),]

 ROI <- SpatialPolygons(list(Polygons(list(Polygon(borders)), ID = 'border'))) polygrid polygrid # get the bounding box for ROI an convert to a list
bboxROI <- apply(bbox(ROI), 1, as.list)
# create a sequence from min(x) to max(x) in each dimension
seqs <- lapply(bboxROI, function(x) seq(x$min, x$max, by= 10))

# rename to xgrid and ygrid
names(seqs) <- c('xgrid','ygrid')

thegrid <- do.call(polygrid,c(seqs, borders = list(ROI@polygons[[1]]@Polygons[[1]]@coords)))
-------------------------------------------------------------------------------------------------------
manipulate(
   barplot(as.matrix(longley[,factor]), 
           beside = TRUE, main = factor),
   factor = picker(1,2,2:3)) 2:3 manipulate(matplot(foo[,1],foo[,c(which(c(fp2,fp3)==1))],t='l'), 
           fp2 = checkbox(TRUE,'col2') ,
           fp3 = checkbox(TRUE,'col3')) fp4 fpick[4]=checkbox(TRUE,'col4')
-------------------------------------------------------------------------------------------------------
checkbox require(gWidgets2) ## from github
options(guiToolkit="Qt") ## other choices too
source(system.file("examples", "manipulate.R", package="gWidgets2"))

manipulate({
  plot(mpg ~ wt, mtcars)
  if(do_lm)
    abline(lm(mpg ~ wt, mtcars))
  if(do_loess)
    with(mtcars, lines(lowess(wt, mpg)))
  ## ...
},
           do_lm=checkbox("Add regression line"),
           do_loess = checkbox("Add lowess fit")
           )
-------------------------------------------------------------------------------------------------------
df <- data.frame(cond = factor( rep(c("A"), each=200) ), 
                 rating = c(rnorm(200),rnorm(200, mean=.8)))

library(lattice)
bwplot(cond ~ rating, data=df,gp=gpar(fill='blue'),
       par.settings = list( box.umbrella=list(col= c( "red")), 
                            box.dot=list(col= c("green")), 
                            box.rectangle = list(fill= c( "blue"),alpha=0.6))) downViewport("plot_01.panel.1.1.vp") segs <- grid.get('segments',grep=T)
cap.segs <- grid.get('cap.segments',grep=T) drawbox <- function(x0 = segs$x0[1] , col ='red',
                    width.vp = segs$x0[2] - segs$x0[1]){
  vpd <- viewport(
            x = x0 ,
            y = cap.segs$y1[2] + unit(0.5,'native'),
            width  = width.vp,
            height = unit(2,'cm'),
            just   = c('left','bottom'),
            name   = 'vpd')
  pushViewport(vpd)
    grid.rect(gp=(gpar(fill=col)))
    # The compute of percent is a little bit tricky due we can't apply '/'
    value <- as.numeric(convertUnit(width.vp,'native'))
    value <- value/as.numeric(convertUnit(cap.segs$x0[2]- cap.segs$x0[1],'native'))
    grid.text(label = paste(round(value*100),'%',sep='') , gp= gpar(cex=3))
  upViewport(1)
} drawbox()
drawbox(col='yellow',width=segs$x0[1] - cap.segs$x0[1], x0= cap.segs$x0[1])
drawbox(col='green',width.vp= cap.segs$x0[2]- segs$x0[2],x0 = segs$x0[2])
-------------------------------------------------------------------------------------------------------
ggplot2 ggplot ggplot(platelay, aes(y = factor(rown, rev(levels(rown))),x = factor(coln))) + 
     geom_point(aes(colour = colorvar), size =18)  +theme_bw() +
     labs(x=NULL, y = NULL) # plot with grey colour dictated by rank, no axes or labels
with(platelay, plot( x=as.numeric(coln), y= rev(as.numeric(rown)), pch= 19, cex = 2, 
 col = grey(rank(platelay[['colorvar']] ) / nrow(platelay)), axes = F, xlab= '', ylab = ''))
# add circular outline
with(platelay, points( x=as.numeric(coln), y= rev(as.numeric(rown)), pch= 21, cex = 2))
# add the axes
axis(3, at =1:12, labels = 1:12)
axis(2, at = 1:8, labels = LETTERS[8:1])
# the background grid
grid()
# and a box around the outside
box()
-------------------------------------------------------------------------------------------------------
dev.new(width=6,height=4)

rown <- unique(platelay$rown)
coln <- unique(platelay$coln)

plot(NA,ylim=c(0.5,length(rown)+0.5),xlim=c(0.5,length(coln)+0.5),ann=FALSE,axes=FALSE)
box()

axis(2,at=seq_along(rown),labels=rev(rown),las=2)
axis(3,at=seq_along(coln),labels=coln)

colgrp <- findInterval(platelay$colorvar,seq(min(platelay$colorvar),max(platelay$colorvar),length.out=10))
colfunc <- colorRampPalette(c("green", "blue"))
collist <- colfunc(length(unique(colgrp))) 

symbols(platelay$coln,
        factor(platelay$rown, rev(levels(platelay$rown))),
        circles=rep(0.2,nrow(platelay)),
        add=TRUE,
        inches=FALSE,
        bg=collist[colgrp])
-------------------------------------------------------------------------------------------------------
axis(side = 1, at = c([all the ticks you want])); ticks # Cumulative Distribuition
pdf("g1_3.pdf");

plot(x = f$V2, y = cumsum(f$V1), log = "x", pch = 3,
     xlab = "Frequency", ylab = "P(X <= x)", axes = FALSE);

ticks = c(1, 5, 10, 40, 150, 500, 1000);
axis(side = 1, at = ticks);
axis(side = 2);

abline(h = seq(0, 1, 0.2), v = ticks, col = "lightgray", lty = 3);
box();
-------------------------------------------------------------------------------------------------------
[ handler=function(h,...){  
         browser()
         label <- h$obj[]
         if(!svalue(h$obj)) ## I remove the item
            GraphFiles <<- GraphFiles[GraphFiles!=label]   ## note the use of the global 
                                                              operator
         else               ## I add the item
            GraphFiles  <<- c(GraphFiles,FileNamesOrig[FileNamesOrig==label])

 }) library(gWidgetsRGtk2)
FileNamesOrig <- paste('file',1:3,sep='')
GraphFiles <- FileNamesOrig
w <- gwindow("Tag Density Checkboxes")
g <- ggroup(container = w)
lyt <- glayout(cont = g, horizontal = T)
for(x in seq_along(FileNamesOrig)){
  gcheckbox(FileNamesOrig[x], 
            container=g, 
            checked=TRUE, 
            handler=function(h,...){  
                  label <- h$obj[]
                  if(!svalue(h$obj)) GraphFiles <<- GraphFiles[GraphFiles!=label]
                  else GraphFiles  <<- c(GraphFiles,FileNamesOrig[FileNamesOrig==label])
                 print(GraphFiles) ## edit to show the changes
            })
}
-------------------------------------------------------------------------------------------------------
base scales library(scales)
xy.poly <- data.frame(Freq=c(xy.pop$Freq, rep(0,nrow(xy.pop))), 
                      Var1=c(xy.pop$Var1, rev(xy.pop$Var1)))
xx.poly <- data.frame(Freq=c(xx.pop$Freq, rep(0,nrow(xx.pop))), 
                      Var1=c(xx.pop$Var1, rev(xx.pop$Var1)))
xrange <- range(c(xy.poly$Freq, xx.poly$Freq))
yrange <- range(c(xy.poly$Var1, xx.poly$Var1))

par(mfcol=c(1,2))
par(mar=c(5,4,4,0))
plot(xy.poly,type="n", main="Men", xlab="", ylab="", xaxs="i", 
     xlim=rev(xrange), ylim=yrange, axes=FALSE)
rect(-1,0,100,100, col="blue")
abline(h=0:15, col="white", lty=3)
polygon(xy.poly, col=alpha("grey",0.6))
axis(1, at=seq(0,20,by=5))
axis(2, las=2)
box()

par(mar=c(5,0,4,4))
plot(xx.poly,type="n", main="Women", xaxs="i", xlab="", ylab="",
     xlim=xrange, ylim=yrange, axes=FALSE)
rect(-1,0,100,100, col="red")
abline(h=0:15, col="white", lty=3)
axis(1, at=seq(5,20,by=5))
axis(4, las=2)
polygon(xx.poly, col=alpha("grey",0.6))
box()
-------------------------------------------------------------------------------------------------------
image() #using image() function
x<-c(0, 5, 30, 80, 1000)
y<-c(150, 2000, 2010, 3000)
grd <- expand.grid(x=x, y=y)
z<-matrix(grd$x*2-grd$y*3, nrow=length(x), ncol=length(y), byrow=TRUE)
image(x=x, y=y, z=z, col=rainbow(20))

#another option with z-scale
source("image.scale.r") #http://menugget.blogspot.de/2011/08/adding-scale-to-image-plot.html
x11(width=5, height=4)
layout(matrix(1:2, nrow=1, ncol=2), widths=c(4,1), heights=4, respect=TRUE)
layout.show(2)
par(mar=c(4,4,1,1))
image(x=x, y=y, z=z, col=rainbow(20))
par(mar=c(4,0,1,4))
image.scale(z, col=rainbow(20), horiz=FALSE, xlab="", ylab="", xaxt="n", yaxt="n")
axis(4)
box()
-------------------------------------------------------------------------------------------------------
n n.restarts n n.restarts ... func2 <- function (lb, ub, ..., n.restarts = 5, n.sim = 10){
  writeLines(paste("Value of `n.restarts` is", n.restarts))
  arg.curve.user <- as.list(substitute(list(...)))
  output <- gosolnp(fun = func1, LB = lb, UB = ub,  n.restarts =  n.restarts, 
                    n.sim =  n.sim)$par
  func3(fun = func1, arg.curve.user = arg.curve.user)
  output
} > func2 (lb = 0, ub = 8, n.restarts = 2, n.sim = 10, n = 200,
+        from = 0, to = 8)
Value of `n.restarts` is 2          <---- Here!

Iter: 1 fn: 6.926e-15    Pars:  2.00000
Iter: 2 fn: 2.501e-15    Pars:  2.00000
solnp--> Completed in 2 iterations

Iter: 1 fn: 8.336e-16    Pars:  2.00000
Iter: 2 fn: 8.336e-16    Pars:  2.00000
solnp--> Completed in 2 iterations
[1] 2
> func2 (lb = 0, ub = 8, nrestarts = 2, n.sim = 10, n = 200,
+        from = 0, to = 8)
Value of `n.restarts` is 5          <---- Here! Default

Iter: 1 fn: 2.83e-15     Pars:  2.00000
Iter: 2 fn: 2.5e-15  Pars:  2.00000
solnp--> Completed in 2 iterations

Iter: 1 fn: 2.037e-15    Pars:  2.00000
Iter: 2 fn: 2.037e-15    Pars:  2.00000
solnp--> Completed in 2 iterations

Iter: 1 fn: 1.087e-15    Pars:  2.00000
Iter: 2 fn: 1.087e-15    Pars:  2.00000
solnp--> Completed in 2 iterations

Iter: 1 fn: 8.558e-16    Pars:  2.00000
Iter: 2 fn: 8.558e-16    Pars:  2.00000
solnp--> Completed in 2 iterations

Iter: 1 fn: 7.147e-16    Pars:  2.00000
Iter: 2 fn: 7.147e-16    Pars:  2.00000
solnp--> Completed in 2 iterations
[1] 2
Warning messages:
1: In plot.window(...) : "nrestarts" is not a graphical parameter
2: In plot.xy(xy, type, ...) : "nrestarts" is not a graphical parameter
3: In axis(side = side, at = at, labels = labels, ...) :
  "nrestarts" is not a graphical parameter
4: In axis(side = side, at = at, labels = labels, ...) :
  "nrestarts" is not a graphical parameter
5: In box(...) : "nrestarts" is not a graphical parameter
6: In title(...) : "nrestarts" is not a graphical parameter
-------------------------------------------------------------------------------------------------------
library(Rsolnp)

func1 <- function (x) (x-2)^2

func3 <- function (fun, col = "blue", n = 1000, main = "This is a test", ...){
  curve(func1, ..., n = n, col = col, main = main)
}

# optimizes func1 and call func2 to plot func1
func2 <- function (lb, ub, n.restarts = 5, n.sim = 10, ...){
  output <- gosolnp(fun = func1, LB = lb, UB = ub, n.restarts = n.restarts, 
  n.sim =  n.sim)$par
  func3(fun = func1, ...)
  return(output)
} func2 ( lb = 0, ub = 8, nrestarts = 5, n.sim = 10, n = 200, from = 0, to = 8) Warning messages:
1: In plot.window(...) : "nrestarts" is not a graphical parameter
2: In plot.xy(xy, type, ...) : "nrestarts" is not a graphical parameter
3: In axis(side = side, at = at, labels = labels, ...) :
  "nrestarts" is not a graphical parameter
4: In axis(side = side, at = at, labels = labels, ...) :
  "nrestarts" is not a graphical parameter
5: In box(...) : "nrestarts" is not a graphical parameter
6: In title(...) : "nrestarts" is not a graphical parameter
-------------------------------------------------------------------------------------------------------
ggplot2 df<-data.frame(x = rep(1:5,times=5),
               y = rep(c("A", "B", "C", "D", "E"),each=5),
               z= c(sort(sample(x=seq(0,1,0.1),size=5, replace=F)),
                    sort(sample(x=seq(0,1,0.1),size=5, replace=F)),
                    sort(sample(x=seq(0,1,0.1),size=5, replace=F)),
                    sort(sample(x=seq(0,1,0.1),size=5, replace=F)),
                    sort(sample(x=seq(0,1,0.1),size=5, replace=F)))) geom_tile() y z library(ggplot2)
ggplot(df,aes(x=x,y=y,fill=z))+geom_tile()+
  scale_x_continuous(expand = c(0, 0)) + scale_y_discrete(expand = c(0, 0)) image() z cbind() z2<-cbind(z.a,z.b,z.c,z.d,z.e)
x2<-1:5
y2<-1:5 z image() axis() image.plot() fields col= image.plot() par(mar=c(5,5,5,8)) #sets space for legend on right side
image(x2,y2,z2,axes=F,col=rainbow(10))
axis(1,at=1:5)
axis(2,at=1:5,labels=c("A", "B", "C", "D", "E"))
box()
library(fields)
image.plot(x2,y2,z2,legend.only=T,col=rainbow(10))
-------------------------------------------------------------------------------------------------------
interp akima age2100 <- read.table("temp.csv",header=TRUE,sep=",")

x <- age2100$x
y <- age2100$y
z <- age2100$z

require(akima)

fld <- interp(x,y,z)

par(mar=c(5,5,1,1))
filled.contour(fld) image image.scale source("image.scale.R") # http://menugget.blogspot.de/2011/08/adding-scale-to-image-plot.html

x11(width=5, height=6)
layout(matrix(c(1,2), nrow=1, ncol=2), widths=c(4,1), height=6, respect=TRUE)
layout.show(2)

par(mar=c(4,4,1,1))
image(fld)
contour(fld, add=TRUE)
points(age2100$x,age2100$y, pch=".", cex=2)

par(mar=c(4,0,1,4))
image.scale(fld$z, xlab="", ylab="", xaxt="n", yaxt="n", horiz=FALSE)
box()
axis(4)
mtext("text", side=4, line=2.5)
-------------------------------------------------------------------------------------------------------
require(tikzDevice)


setwd("/Path/To/LaTeX/Files/")

#Names of LaTeX symbols
syms <- c('alpha', 'theta', 'tau', 'beta', 'vartheta', 'pi', 'upsilon', 'gamma', 'varpi', 'phi', 'delta', 'kappa', 'rho', 'varphi', 'epsilon', 'lambda', 'varrho', 'chi', 'varepsilon', 'mu', 'sigma', 'psi', 'zeta', 'nu', 'varsigma', 'omega', 'eta', 'xi', 'Gamma', 'Lambda', 'Sigma', 'Psi', 'Delta', 'Xi', 'Upsilon', 'Omega', 'Theta', 'Pi', 'Phi')
len <- length(syms)

# random colors (red, green, blue)
r <- round(runif(len), 2)
g <- round(runif(len), 2)
b <- round(runif(len), 2)

# calculate dummy data points
x <- runif(50,1,10)
y <- x + rnorm(length(x))
fit <- lm(y ~ x)
rsq <- summary(fit)$r.squared
rsq <- signif(rsq,4)

# plot the result, will create symbol-regression.tex in the working
# directory the first time this is run it may take a long time because the
# process of calulating string widths for proper placement is
# computationally intensive, the results will get cached for the current R
# session or will get permenantly cached if you set
# options( tikzMetricsDictionary='/path/to/dictionary' ) which will be
# created if it does not exist.  Also if the flag standAlone is not set to
# TRUE then a file is created which can be included with \include{}

tikz('symbolr.tex', width = 4,height = 4,pointsize = 12)

# The syntax is mar=c(bottom, left, top, right).
par(mar=c(2,2,2,2))
# plot the box and the regression line
plot(x, y, type='n', xlab='', ylab='')
box()
abline(fit)

# add the latex symbols as points
text(x, y, paste('\\color[rgb]{',r,',',g,',',b,'}{$\\',syms,'$}',sep=''))
# Display the correlation coefficient
mtext(paste("Linear model: $R^{2}=",rsq,"$" ),line=0.5)
# and the equation of the line
legend('bottom', legend = paste("$y = ", round(coef(fit)[2],3),'x +', round(coef(fit)[1],3), '$',  sep=''), bty= 'n')

# Close the device
dev.off()
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(gridExtra)
title <- "Default title"
data(movies)

## Init dialog
require(tkrplot)
if (!exists("slider.env")) slider.env <<- new.env(parent = .GlobalEnv)
require(tcltk)
nt <- tktoplevel()
tkwm.title(nt, title)
tkwm.geometry(nt, "480x600+0+10")
assign("tktop.slider", nt, envir = slider.env)
"relax"
nt.bak <- nt
sl.frame <- tkframe(nt)
gr.frame <- tkframe(nt)
tx.frame <- tkframe(nt)
tkpack(sl.frame, tx.frame, gr.frame, side = "bottom")
## First default plot
newpl <- function(...) {
  dummydf <- data.frame('x'=1:10, 'y'=1:10)
  dummy <- ggplot(dummydf, aes(x=x, y=y)) + geom_point(size=0) + xlim(0, 10) + ylim(0, 100) + 
    geom_text(aes(label='Generating plot...', x=5, y=50), size=9)
  print(dummy)
  }
img <- tkrplot::tkrplot(gr.frame, newpl, vscale = 1, hscale = 1)
tkpack(img, side = "top")
assign("img", img, envir = slider.env)
tkpack(fr <- tkframe(sl.frame), side = 'top')

##Creating slider, textbox and labels
sc <- tkscale(fr, from = 0, to = 5, showvalue = TRUE, resolution = 0.1, orient = "horiz")
tb <- tkentry(fr, width=4)
lab <- tklabel(fr, text = 'Select binwidth ', width = "16")
orlabel <- tklabel(fr, text=' or ', width='4')
tkpack(lab, sc, orlabel, tb, side = 'left')
tkpack(textinfo <- tkframe(tx.frame), side = 'top')


## Creating objects and variables associated with slider and textbox
assign("sc", sc, envir = slider.env)
assign("tb", tb, envir = slider.env)
assign('inputsc', tclVar(2.5), envir=slider.env)
assign('inputtb', tclVar('2.5'), envir=slider.env)
eval(parse(text = "tkconfigure(sc, variable=inputsc)"), envir = slider.env)
eval(parse(text = "tkconfigure(tb, textvariable=inputtb)"), envir = slider.env)

## Function to update the textbox value when the slider has changed
sync_textbox <- function() {
  bwidth_sl <- tclvalue(get('inputsc', envir=slider.env))
  assign('inputtb', tclVar(bwidth_sl), envir=slider.env)
  eval(parse(text = "tkconfigure(tb, textvariable=inputtb)"), envir = slider.env)
}

## Function to update the slider value when the textbox has changed
sync_slider <- function() {
  bwidth_tb <- tclvalue(get('inputtb', envir=slider.env))
  assign('inputsc', tclVar(bwidth_tb), envir=slider.env)
  eval(parse(text = "tkconfigure(sc, variable=inputsc)"), envir = slider.env)
}

## Function to refresh the plot
refresh <- function(bwidth) {
  histplot <- ggplot(data=movies, aes_string(x="rating")) +
     geom_histogram(binwidth=bwidth, 
                    aes(y = ..density..), fill='skyblue') + 
                      theme(axis.title.x=element_text(size=15), axis.title.y=element_text(size=15), 
                            axis.text.x=element_text(size=10, colour='black'),
                            axis.text.y=element_text(size=10, colour='black'))
  print(histplot)
}

## Bindings : association of certain functions to certain events for the slider
## and the textbox

tkbind(sc, "<ButtonRelease>", function(...) {
  bwidth <- as.numeric(tclvalue(get('inputsc', envir=slider.env)))
  tkrreplot(get('img',envir=slider.env),fun=function() { refresh(bwidth); sync_textbox()})
})

tkbind(tb, "<Return>", function(...) {
  bwidth <- as.numeric(tclvalue(get('inputtb', envir=slider.env)))
  tkrreplot(get('img',envir=slider.env),fun=function() { refresh(bwidth); sync_slider()})
})
-------------------------------------------------------------------------------------------------------
species <- levels(raw$SpCode)
for(i in 1:length(species))  
            {
            #open the file for writing
             pdf(paste0(species[i],".pdf"),width=5,height=4)
             plot (wrld_simpl, xlim=c(-100,-55), ylim=c(23,63), axes=TRUE, col='light grey')
             box() #adds box around map
             title(main=species[i]) #adds main title to map which should be the species name associated with the data
             points(raw$longitude[raw$SpCode == species[i]],raw$latitude[raw$SpCode == species[i]], col='black', pch=21, bg="red", cex=0.85)
             dev.off()
             }
-------------------------------------------------------------------------------------------------------
apply(MSA, 2, function(x1) {
  apply(MSA, 2, function(x2) {
    t.test(x1, x2)
  })
}) cis <- apply(MSA, 2, function(x) mean(x) + c(-1, 1) * sd(x) * 1.96)
plot.new()
plot.window(xlim=c(1, ncol(cis)), ylim=range(cis))
segments(1:ncol(cis), cis[1, ], 1:ncol(cis), cis[2, ])
axis(1, at=1:ncol(cis), labels=colnames(MSA))
axis(2)
box()
abline(h=mean(MSA), lty='dashed')
title('Forest plot of 95% confidence intervals of MSA')
-------------------------------------------------------------------------------------------------------
"SpatialPoints" over() "SpatialPolygonDataFrame" "SpatialPoints" library(rgdal)

## (1) Read in an example shapefile
dsn <- system.file("vectors", package = "rgdal")[1]
scot_BNG <- readOGR(dsn=dsn, layer="scot_BNG")
scot_BNG <- scot_BNG[1:5,]  # Let's just use part of it

## (2) Set up a SpatialPoints object with the grid of points 
##     for which you want to extract values
res <- 10000            ## Distance between grid points (30 in OP's question) 
BB <- bbox(scot_BNG)
BB <- res*round(BB/res) ## Pretty up the bounding box
GT <- GridTopology(cellcentre.offset = BB[,1], 
                   cellsize = c(res, res),
                   cells.dim = (c(diff(BB[1,]), diff(BB[2,]))/res) + 1)
SP <- SpatialPoints(GT, proj4string = CRS(proj4string(scot_BNG)))

## (3) Extract the values
vals <- over(SP, scot_BNG)
res <- cbind(coordinates(SP), vals)

## Finally, have a look at a few of the points.
x <- res[!is.na(res$SP_ID),]
rbind(head(x,3), tail(x,3))[1:10]
#          x      y SP_ID       NAME ID_x COUNT   SMR  LONG  LAT    PY
# 4   230000 970000     0 Sutherland   12     5 279.3 58.06 4.64 37521
# 5   240000 970000     0 Sutherland   12     5 279.3 58.06 4.64 37521
# 25  220000 960000     0 Sutherland   12     5 279.3 58.06 4.64 37521
# 425 260000 780000     4   Bedenoch   17     2 186.9 57.06 4.09 27075
# 426 270000 780000     4   Bedenoch   17     2 186.9 57.06 4.09 27075
# 427 280000 780000     4   Bedenoch   17     2 186.9 57.06 4.09 27075
-------------------------------------------------------------------------------------------------------
tile.list secr::pointsInPolygon # Sample data
x <- matrix( rnorm(20), nc = 2 )
y <- matrix( rnorm(1000), nc=2 )

# Tessellation
library(deldir)
d <- deldir(x[,1], x[,2])
plot(d, wlines="tess")

# Pick a cell at random 
cell <- sample( tile.list(d), 1 )[[1]]
points( cell$pt[1], cell$pt[2], pch=16 )
polygon( cell$x, cell$y, lwd=3 )

# Select the points inside that cell
library(secr)
i <- pointsInPolygon(
  y, 
  cbind( 
    c(cell$x,cell$x[1]), 
    c(cell$y,cell$y[1])
  )
)
points(y[!i,], pch=".")
points(y[i,], pch="+")

# Compute a tessellation of those points
dd <- deldir(y[i,1], y[i,2])
plot(dd, wlines="tess", add=TRUE) distance_to_segment <- function(M, A, B) {
  norm <- function(u) sqrt(sum(u^2))
  lambda <- sum( (B-A) * (M-A) ) / norm(B-A)^2
  if( lambda <= 0 ) {
    norm(M-A)
  } else if( lambda >= 1 ) {
    norm(M-B)
  } else {
    N <- A + lambda * (B-A)
    norm(M-N)
  }
}
A <- c(-.5,0)
B <- c(.5,.5)
x <- seq(-1,1,length=100)
y <- seq(-1,1,length=100)
z <- apply(
  expand.grid(x,y), 
  1, 
  function(u) distance_to_segment( u, A, B )
)
par(las=1)
image(x, y, matrix(z,nr=length(x)))
box()
segments(A[1],A[2],B[1],B[2],lwd=3)

library(secr)
distance_to_polygon <- function(x, poly) {
  closed_polygon <- rbind(poly, poly[1,])
  if( pointsInPolygon( t(x), closed_polygon ) )
    return(0)
  d <- rep(Inf, nrow(poly))
  for(i in 1:nrow(poly)) {
    A <- closed_polygon[i,]
    B <- closed_polygon[i+1,]
    d[i] <- distance_to_segment(x,A,B)
  }
  min(d)
}
x <- matrix(rnorm(20),nc=2)
poly <- x[chull(x),]
x <- seq(-5,5,length=100)
y <- seq(-5,5,length=100)
z <- apply(
  expand.grid(x,y), 
  1, 
  function(u) distance_to_polygon( u, poly )
)
par(las=1)
image(x, y, matrix(z,nr=length(x)))
box()
polygon(poly, lwd=3) x --> lambda * x + a
y --> lambda * y + b # Sample data 
x <- matrix(rnorm(20),nc=2)
x <- x[chull(x),]
y <- matrix( c(1,2) + 5*rnorm(20), nc=2 )
plot(y, axes=FALSE, xlab="", ylab="")
polygon(x)

# Function to minimize:
# either the sum of the squares of the distances to the polygon, 
# if at least one point is outside, 
# or minus the square of the scaling factor.
# It is not continuous, but (surprisingly) that does not seem to be a problem.
f <- function( p ) {
  lambda <- log( 1 + exp(p[1]) )
  a <- p[2:3]
  y0 <- colMeans(y)
  transformed_points <- t( lambda * (t(y)-y0) + a )
  distances <- apply(
    transformed_points, 
    1, 
    function(u) distance_to_polygon(u, x)
  )
  if( all(distances == 0) ) - lambda^2
  else                      sum( distances^2 )
}
# Minimize this function
p <- optim(c(1,0,0), f)$par
# Compute the optimal parameters
lambda <- log( 1 + exp(p[1]) )
a <- p[2:3]
y0 <- colMeans(y)
# Compute the new coordinates
transformed_points <- t( lambda * (t(y)-y0) + a )
# Plot them
segments( y[,1], y[,2], transformed_points[,1], transformed_points[,2], lty=3 )
points( transformed_points, pch=3 )
library(deldir)
plot( 
  deldir( transformed_points[,1], transformed_points[,2] ), 
  wlines="tess", add=TRUE 
)
-------------------------------------------------------------------------------------------------------
## setfont properties
setfont_hack <- function(cb, spec) {
  require(RGtk2)
  widget <- getToolkitWidget(cb)$getChildren()[[1]]
  font_descr <- pangoFontDescriptionNew()
  if(!is.null(spec$weight))
    font_desc$setWeight(PangoWeight[spec$weight])
  if(!is.null(spec$style))
    font_desc$setStyle(PangoStyle[spec$style])
  if(!is.null(spec$scale))
    font_desc$setSize(spec$scale * PANGO_SCALE)
  if(!is.null(spec$family))
    font_desc$setFamily(spec$family)
  widget$modifyFont(font_desc)

  if(!is.null(spec$color))
    widget$modifyFg(GtkStateType[1], spec$color)
}

cb <- gcheckbox("label", cont=gwindow())
setfont_hack(cb, list(weight="bold", color="blue")) gWidgets2RGtk2 require(RGtk2)
label <- getToolkitWidget(cb)$getChildren()[[1]]
cb$set_rgtk2_font(label, list(weight="bold"))
-------------------------------------------------------------------------------------------------------
?as.Date as.integer(as.Date("0/1/1"))
[1] -719528

as.integer(seq(as.Date("0/1/1"),length=2,by="-10000 years"))
[1]  -719528 -4371953

seq(as.Date(-4371953,origin="1970-01-01"),Sys.Date(),by="1000 years")
# nonsense
 [1] "0000-01-01" "'000-01-01" "(000-01-01" ")000-01-01" "*000-01-01"
 [6] "+000-01-01" ",000-01-01" "-000-01-01" ".000-01-01" "/000-01-01"
[11] "0000-01-01" "1000-01-01" "2000-01-01"

> as.integer(seq(as.Date(-4371953,origin="1970-01-01"),Sys.Date(),by="1000 years"))
# also possibly nonsense
 [1] -4371953 -4006710 -3641468 -3276225 -2910983 -2545740 -2180498 -1815255
 [9] -1450013 -1084770  -719528  -354285    10957 yrs1000 <- seq(as.Date(-4371953,origin="1970-01-01"),Sys.Date(),by="1000 years")
plot(yrs1000,rep(1,length(yrs1000)),axes=FALSE,ann=FALSE)
box()
axis(2)
axis(1,at=yrs1000,labels=c(paste(seq(10000,1000,by=-1000),"BC",sep=""),"0AD","1000AD","2000AD"))
title(xlab="Year",ylab="Value")
-------------------------------------------------------------------------------------------------------
library(rgdal)
library(raster)

## Read in the ecoregion shapefile (located in R's current working directory)
teow <- readOGR(dsn = "official_teow/official", layer = "wwf_terr_ecos")

## Set up a raster "template" to use in rasterize()
ext <-  extent (-95, -50, 24, 63)
xy <- abs(apply(as.matrix(bbox(ext)), 1, diff))
n <- 5
r <- raster(ext, ncol=xy[1]*5, nrow=xy[2]*5)

## Rasterize the shapefile
rr <-rasterize(teow, r)

## A couple of outputs
writeRaster(rr, "teow.asc")
plot(rr)
-------------------------------------------------------------------------------------------------------
intersects <- list()

## find all intersections (NULLs do nothing to the result)
for (i in 1:nrow(Soils)) {
  for (j in 1:nrow(Parcels)) {
    intersects[[sprintf("%sx%s", i, j)]] <- gIntersection(Soils[i,],
                                                          Parcels[j,]) 
  }
}

result <- list()
## let's try Parcels, transfer data attributes to new pieces
for (i in 1:nrow(Parcels)) {
  for (j in seq_along(intersects))
   if(gContains(Parcels[i,], intersects[[j]])) {
     result <- c(result, SpatialPolygonsDataFrame(intersects[[j]],     as.data.frame(Parcels[i,]), match.ID = FALSE))

   }
}


## plot
plot(Parcels, xlim = range(c(bbox(Parcels)[1,], bbox(Soils[1,]))),
     ylim = range(c(bbox(Parcels)[2,], bbox(Soils[2,]))))
plot(Soils, add = TRUE)

cols <- colorRampPalette(c("lightblue", "darkblue"))(length(result))
for (i in 1:length(result)) plot(result[[i]], col = cols[i], add = TRUE)
for (i in 1:length(result)) text(coordinates(result[[i]]), label =     as.data.frame(result[[i]])[,"soilType"])
-------------------------------------------------------------------------------------------------------
> set.seed(1)
> DF <- data.frame(2000:2009,matrix(rnorm(50, 1000, 200), ncol=5))
> colnames(DF) <- c('Year', paste0('Country', 2:ncol(DF)))
> DF # this is how the data.frame looks like:
   Year  Country2  Country3  Country4  Country5  Country6
1  2000  874.7092 1302.3562 1183.7955 1271.7359  967.0953
2  2001 1036.7287 1077.9686 1156.4273  979.4425  949.3277
3  2002  832.8743  875.7519 1014.9130 1077.5343 1139.3927
4  2003 1319.0562  557.0600  602.1297  989.2390 1111.3326
5  2004 1065.9016 1224.9862 1123.9651  724.5881  862.2489
6  2005  835.9063  991.0133  988.7743  917.0011  858.5010
7  2006 1097.4858  996.7619  968.8409  921.1420 1072.9164
8  2007 1147.6649 1188.7672  705.8495  988.1373 1153.7066
9  2008 1115.1563 1164.2442  904.3700 1220.0051  977.5308
10 2009  938.9223 1118.7803 1083.5883 1152.6351 1176.2215
> matplot(DF[,-1], col=1:ncol(DF), type='l', lty=1, ylim=range(DF), axes=FALSE)
> axis(1, 1:nrow(DF), as.character(DF[,1]))
> axis(2)
> box() #- to make it look "as usual"
> legend('topright', names(DF), col=1:ncol(DF), lty=1, cex=.65)
-------------------------------------------------------------------------------------------------------
par(fig=..., new=TRUE) x <- rnorm(100)
hist( x, col = "light blue" )
par( fig = c(.7, .95, .7, .95), mar=.1+c(0,0,0,0), new = TRUE )
qqnorm(x, axes=FALSE, xlab="", ylab="", main="")
qqline(x, col="blue", lwd=2)
box()
-------------------------------------------------------------------------------------------------------
box() par(mfrow=c(2,1))
boxplot(count ~ spray, data = InsectSprays, col = "lightgray")
boxplot(count ~ spray, data = InsectSprays,
        notch = TRUE, add = TRUE, col = "blue")
require(grDevices) # for colours
tN <- table(Ni <- stats::rpois(100, lambda=5))
r <- barplot(tN, col=rainbow(20))
box()
lines(r, tN, type='h', col='red', lwd=2)
-------------------------------------------------------------------------------------------------------
xlim=c(0,40) mp<-barplot(as.matrix(t(df[,2:4])),beside=TRUE,xlim=c(0,40),ann=FALSE)
mp
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
[1,]  1.5  5.5  9.5 13.5 17.5 21.5 25.5 29.5 33.5  37.5
[2,]  2.5  6.5 10.5 14.5 18.5 22.5 26.5 30.5 34.5  38.5
[3,]  3.5  7.5 11.5 15.5 19.5 23.5 27.5 31.5 35.5  39.5 par(new=TRUE) plot() lines() mp axis() par(new=TRUE)
plot(mp[2,],df$CS1,xlim=c(0,40),type="l",col="red",axes=FALSE,ylim=c(0,100),ann=FALSE)
lines(mp[2,],df$CS2,col="blue")
lines(mp[2,],df$CS3,col="green")
axis(1,at=mp[2,],labels=df$V)
axis(4,at=seq(0,100,10))
box()
-------------------------------------------------------------------------------------------------------
layout layout(rbind(c(1, 2),
             c(3, 3),
             c(4, 5)),
       heights=c(3, 1.5, 3),
       respect=FALSE)
tN <- table(Ni <- stats::rpois(100, lambda = 5))
barplot(tN, col = 2:3)
barplot(tN, col = 2:3)
plot.new()
#box()
text(0.5,0.5,'legend in center',cex=3)
barplot(tN, col = 2:3)
barplot(tN, col = 2:3)
-------------------------------------------------------------------------------------------------------
w=gwindow()
b1=gradio(c("a","b"),container=w)
b2=gcombobox(c(1:2),container=w)
id = addHandlerClicked(b2,handler=function(h,...) print("clicked b2"))
addHandlerClicked(b1,handler=function(h,...) {
  blockHandler(b2, id)
  b2[,]=c(1:10)
  unblockHandler(b2, id)
}) options("guiToolkit"="RGtk2")
library(gWidgets2)

w=gwindow()
g = ggroup(cont=w)  ## only one child for a gwindow instance is enforced
b1=gradio(c("a","b"),container=g)
b2=gcombobox(c(1:2),container=g, expand=TRUE)
id = addHandlerChanged(b2,handler=function(h,...) print("clicked b2"))
addHandlerChanged(b1,handler=function(h,...) {
  b2[]=c(1:10)
})
-------------------------------------------------------------------------------------------------------
test <- with(df1,table(age,income))
test <- as.matrix(as.data.frame.matrix(test))
plot(
  row(test),
  col(test),
  cex=test/3,pch=20,
  xlim=c(0.5,nrow(test)+0.5),
  ylim=c(0.5,ncol(test)+0.5),
  axes=FALSE,
  ann=FALSE
)
axis(1,at=1:nrow(test),labels=rownames(test),cex.axis=0.8)
axis(2,at=1:ncol(test),labels=colnames(test),cex.axis=0.8)
title(xlab="Age Group",ylab="Income")
box()
-------------------------------------------------------------------------------------------------------
axis > axis(side=1, at=c(0:23)) plot(0:23, d, type='b', axes=FALSE)
axis(side=1, at=c(0:23))
axis(side=2, at=seq(0, 600, by=100))
box()
-------------------------------------------------------------------------------------------------------
wp <- structure(list(M.1990 = c(325814, 295272, 269351, 265163, 249651, 220027, 196523, 178295, 141789, 115097, 106579, 91763, 77150, 56845, 38053, 25716, 19442), M.2000 = c(319675, 317296, 317072, 290827, 262992, 256378, 241401, 212924, 188905, 169133, 131813, 103162, 90921, 72231, 53449, 32707, 25868), M.2010 = c(328759, 315119, 311456, 312831, 311077, 284258, 255596, 248575, 232217, 202633, 176241, 153494, 114194, 83129, 65266, 43761, 39223), F.1990 = c(308121, 281322, 257432, 254065, 238856, 211943, 188433, 170937, 138358, 112931, 106510, 93425, 82667, 67057, 47679, 37435, 36724), F.2000 = c(298455, 297012, 299757, 277706, 252924, 248127, 233583, 207518, 183646, 165444, 132307, 105429, 96681, 80227, 64956, 45832, 46413), F.2010 = c(307079, 293664, 290598, 293313, 295739, 273379, 247383, 241938, 226914, 201142, 176440, 156283, 121200, 92071, 77990, 56895, 66029)), .Names = c("M.1990", "M.2000", "M.2010", "F.1990", "F.2000", "F.2010"), row.names = c("0-4", "5-9", "10-14", "15-19", "20-24", "25-29", "30-34", "35-39", "40-44", "45-49", "50-54", "55-59", "60-64", "65-69", "70-74", "75-79", "80+"), class = "data.frame")

wp
      M.1990 M.2000 M.2010 F.1990 F.2000 F.2010
0-4   325814 319675 328759 308121 298455 307079
5-9   295272 317296 315119 281322 297012 293664
10-14 269351 317072 311456 257432 299757 290598
15-19 265163 290827 312831 254065 277706 293313
20-24 249651 262992 311077 238856 252924 295739
25-29 220027 256378 284258 211943 248127 273379
30-34 196523 241401 255596 188433 233583 247383
35-39 178295 212924 248575 170937 207518 241938
40-44 141789 188905 232217 138358 183646 226914
45-49 115097 169133 202633 112931 165444 201142
50-54 106579 131813 176241 106510 132307 176440
55-59  91763 103162 153494  93425 105429 156283
60-64  77150  90921 114194  82667  96681 121200
65-69  56845  72231  83129  67057  80227  92071
70-74  38053  53449  65266  47679  64956  77990
75-79  25716  32707  43761  37435  45832  56895
80+    19442  25868  39223  36724  46413  66029

xrange <- range(c(0,wp))
yrange <- range(c(0,nrow(wp))) par(mfcol=c(1,2))
par(mar=c(5,4,4,0))
plot(NA,type="n", main="Men", xlab="", ylab="", xaxs="i", 
     xlim=rev(xrange), ylim=yrange, axes=FALSE, yaxs="i")
rect(xrange[1],yrange[1],xrange[2],yrange[2], col="cadetblue")
abline(v=seq(0,xrange[2],by=1e5), col="white")
# All years with bars you want to represent filled 
# should be entered in reverse order
polygon(c(0,rep(wp$M.2000,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)),
        col="lightblue",border="lightblue")
polygon(c(0,rep(wp$M.1990,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)), 
        col="darkblue",border="darkblue")
# And those you want with just a border, afterwards:
polygon(c(0,rep(wp$M.2010,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)), 
        col=NA,border="darkred",lwd=2)
axis(1, at=c(0,1e5,2e5,3e5), labels=format(c(0,1e5,2e5,3e5),scientific=FALSE))
axis(2, at=1:nrow(wp)-0.5,labels=row.names(wp),las=2)
box()

par(mar=c(5,0,4,4))
plot(NA,type="n", main="Women", xlab="", ylab="", xaxs="i", 
     xlim=xrange, ylim=yrange, axes=FALSE, yaxs="i")
rect(xrange[1],yrange[1],xrange[2],yrange[2], col="cadetblue")
abline(v=seq(0,xrange[2],by=1e5), col="white")
polygon(c(0,rep(wp$F.2000,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)),
        col="lightblue",border="lightblue")
polygon(c(0,rep(wp$F.1990,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)), 
        col="darkblue",border="darkblue")
polygon(c(0,rep(wp$F.2010,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)), 
        col=NA,border="darkred",lwd=2)
axis(1, at=c(0,1e5,2e5,3e5), labels=format(c(0,1e5,2e5,3e5),scientific=FALSE))
axis(4, at=1:nrow(wp)-0.5,labels=row.names(wp),las=2)
box() library(scales)
[...]
polygon(c(0,rep(wp$M.1990,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)), 
        col=alpha("darkblue",0.4),border="darkblue")
[...]
polygon(c(0,rep(wp$F.1990,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)), 
        col=alpha("darkblue",0.4),border="darkblue")
[...]
-------------------------------------------------------------------------------------------------------
tmp <- tapply( iris$Petal.Length, iris$Species, function(x) hist(x, plot=FALSE) )

plot.new()
tmp.r <- do.call( range, lapply(tmp, `[[`, 'breaks') )
plot.window(xlim=c(1/2,length(tmp)+1/2), ylim=tmp.r)
abline(v=seq_along(tmp))

for( i in seq_along(tmp) ) {
    h <- tmp[[i]]
    rf <- h$counts/sum(h$counts)
    rect( i-rf/2, head(h$breaks, -1), i+rf/2, tail(h$breaks, -1) )
}

axis(1, at=seq_along(tmp), labels=names(tmp))
axis(2)
box()
-------------------------------------------------------------------------------------------------------
contour contourLines polygon plot(datax[,1], datax[,2],axes=FALSE,ann=FALSE, type="n")
box()
cL <- contourLines(xp, yp, zM,nlevels = 1)
lapply(cL,function(x)polygon(x$x,x$y,col="red"))
points(datax[,1], datax[,2],pch = datay+1) library(splancs)
ord <- sapply(lapply(cL,function(x)datay[inout(datax,cbind(x$x,x$y))]),
              median) #Check what values are present in the polygon and 
                      #take the most common one
plot(datax[,1], datax[,2],axes=FALSE,ann=FALSE, type="n")
box()
lapply(cL[ord==1],function(x)polygon(x$x,x$y,col="blue"))
lapply(cL[ord==0],function(x)polygon(x$x,x$y,col="white"))
points(datax[,1], datax[,2],pch = datay+1) image image(xp, yp, zM, col=c("transparent","blue"))
points(datax[,1], datax[,2],pch = datay+1)
-------------------------------------------------------------------------------------------------------
library(gWidgets)

w <- gwindow("Testing", visible=FALSE)
g <- ggroup(cont=w, horizontal=FALSE)
fb <- gfilebrowse("Choose a CSV file", quote=FALSE,
                  filter = list("CSV files"=list(patterns="*.csv")),
                  cont=g)
cb <- gcombobox("", cont=g)

addHandlerChanged(fb, handler=function(h,...) {
  x <- read.csv(svalue(fb))
  cb[] <- colnames(x)
})

visible(w) <- TRUE
-------------------------------------------------------------------------------------------------------
#' Plot two dimensional histogram
#'
#' @param hist matrix or two dimensional array containing the number of counts
#' in each of the bins.
#' @param borders_x the x-borders of the bins in the histogram. Should be a
#' numeric vector with lenght one longer than the number of columns of
#' \code{hist}
#' @param borders_y the y-borders of the bins in the histogram. Should be a
#' numeric vector with lenght one longer than the number of rows of
#' \code{hist}
#' @param type a character specifying the type of plot. Valid values are "text",
#' "area" and "color". See details for more information.
#' @param add add the plot to an existing one or create a new plot.
#' @param add_lines logical specifying whether or not lines should be drawn
#' between the bins.
#' @param draw_empty if \code{FALSE} empty bins (numer of counts equal to zero)
#' are not drawn. They are shown using the background color.
#' @param col for types "area" and "text" the color of the boxes and text.
#' @param line_col the color of the lines between the bins.
#' @param background_col the background color of the bins.
#' @param lty the line type of the lines between the bins.
#' @param text_cex the text size used for type "text". See \code{\link{par}} for
#' more information.
#' @param col_range the color scale used for type "color". Should be a function
#' which accepts as first argument the number of colors that should be
#' generated. The first color generated is used for the zero counts; the
#' last color for the highest number of counts in the histogram.
#' @param ... additional arguments are passed on to \code{\link{plot}}.
#'
#' @details
#' There are three plot types: "area", "text", and "color". In case of "area"
#' rectangles are drawn inside the bins with area proportional to the number of
#' counts in the bins. In case of text the number of counts is shown as text in
#' the bins. In case of color a color scale is used (by default heat.colors) to
#' show the number of counts.
#'
#' @seealso \code{\link{image}} which can be used to create plots similar to
#' type "color". \code{\link{contour}} may also be of interest.
#'
#' @examples
#' histplot2(volcano - min(volcano), type="color")
#' histplot2(volcano - min(volcano), add_lines=FALSE, type="area")
#' histplot2(volcano - min(volcano), type="text", text_cex=0.5)
#'
#' @export
histplot2 <- function(hist, borders_x=seq(0, ncol(hist)),
        borders_y=seq(0, nrow(hist)), type="area", add=FALSE, add_lines=TRUE,
        draw_empty=FALSE, col="black", line_col="#00000030",
        background_col="white", lty=1, text_cex=0.6, col_range=heat.colors, ...) {
    # create new plot
    rangex <- c(min(borders_x), max(borders_x))
    rangey <- c(min(borders_y), max(borders_y))
    if (add == FALSE) {
        plot(rangex, rangey, type='n', xaxs='i', yaxs='i', ...)
        rect(rangex[1], rangey[1], rangex[2], rangey[2], col=background_col,
            border=NA)
    }
    # prepare data
    nx <- length(borders_x)-1
    ny <- length(borders_y)-1
    wx <- rep(diff(borders_x), each=ny)
    wy <- rep(diff(borders_y), times=nx)
    sx <- 0.95*min(wx)/sqrt(max(hist))
    sy <- 0.95*min(wy)/sqrt(max(hist))
    x <- rep((borders_x[-length(borders_x)] + borders_x[-1])/2, each=ny)
    y <- rep((borders_y[-length(borders_y)] + borders_y[-1])/2, times=nx)
    h <- as.numeric(hist)
    # plot type "area"
    if (type == "area") {
        dx <- sqrt(h)*sx*0.5
        dy <- sqrt(h)*sy*0.5
        rect(x-dx, y-dy, x+dx, y+dy, col=col, border=NA)
    # plot type "text"
    } else if (type == "text") {
        if (draw_empty) {
            text(x, y, format(h), cex=text_cex, col=col)
        } else {
            text(x[h!=0], y[h!=0], format(h[h!=0]), cex=text_cex, col=col)
        }
    # plot type "color"
    } else if (type == "color" | type == "colour") {
        #h <- h/(wx*wy)
        col <- col_range(200)
        col <- col[floor(h/max(h)*200*(1-.Machine$double.eps))+1]
        sel <- rep(TRUE, length(x))
        if (!draw_empty) sel <- h > 0
        rect(x[sel]-wx[sel]/2, y[sel]-wy[sel]/2, x[sel]+wx[sel]/2,
            y[sel]+wy[sel]/2, col=col[sel], border=NA)
    } else {
        stop("Unknown plot type: options are 'area', 'text' and 'color'.")
    }
    # add_lines
    if (add_lines) {
        lines(rbind(borders_x, borders_x, NA),
            rbind(rep(rangey[1], nx+1), rep(rangey[2], nx+1), NA),
            col=line_col, lty=lty)
        lines(rbind(rep(rangex[1], ny+1), rep(rangex[2], ny+1), NA),
            rbind(borders_y, borders_y, NA), col=line_col, lty=lty)
    }
    # add border
    if (add == FALSE) box()
} X <- matrix(nrow=3, ncol=3)
X[1,] <- c(0.3, 0.4, 0.45)
X[2,] <- c(0.3, 0.7, 0.65)
X[3,] <- c(0.3, 0.4, 0.45)
centers <- c(1.5, 3, 4)

centers_to_borders <- function(centers) {
    nc <- length(centers)
    d0 <- centers[2]-centers[1]
    d1 <- centers[nc]-centers[nc-1]
    c(centers[1]-d0/2, 
      (centers[2:nc] + centers[1:(nc-1)])/2, centers[nc]+d1/2)
}

histplot2(X, centers_to_borders(centers), 
    centers_to_borders(centers), type="color") plot_range <- function(hist, col_range = heat.colors) {
    r <- range(c(0, X))
    par(cex=0.7, mar=c(8, 1, 8, 2.5))
    plot(0, 0, type='n', xlim=c(0,1), ylim=r, xaxs='i',
        yaxs='i', bty='n', xaxt='n', yaxt='n', xlab='', ylab='')
    axis(4)
    y <- seq(r[1], r[2], length.out=200)
    yc <- floor(y/max(y)*5*(1-.Machine$double.eps))+1
    col <- col_range(5)[yc]
    b <- centers_to_borders(y)
    rect(rep(0, length(y)), b[-length(b)], rep(1, length(y)), 
        b[-1], col=col, border=NA)
} layout layout(matrix(c(1,2), nrow = 1), widths = c(0.9, 0.1))
par(mar = c(5, 4, 4, 2) + 0.1)
histplot2(X, centers_to_borders(centers), 
    centers_to_borders(centers), type="color")
plot_range(X) histplot2 h <- h/(wx*wy)
-------------------------------------------------------------------------------------------------------
p4 = "+proj=lcc +lat_1=50  +lat_2=50 +lat_0=0  +lon_0=253 +x_0=0  +y_0=0" rgdal:spTransform coordinates(dat)=~lon+lat
proj4string(dat)=CRS("+init=epsg:4326")
dat2=spTransform(dat,CRS(p4))
bb=bbox(dat2)
lonx=seq(bb[1,1],  bb[1,2],len=277)
laty=seq(bb[2,1], bb[2,2],len=349)
r=raster(list(x=laty,y=lonx,z=md))
plot(r)
contour(r,add=TRUE)
-------------------------------------------------------------------------------------------------------
filled.contour filled.contour my.filled.contour <-
function (x = seq(0, 1, length.out = nrow(z)), y = seq(0, 1,
    length.out = ncol(z)), z, xlim = range(x, finite = TRUE),
    ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE),
    levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors,
    col = color.palette(length(levels) - 1), plot.title, plot.axes,
    key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1,
    axes = TRUE, frame.plot = axes, ...)
{
    if (missing(z)) {
        if (!missing(x)) {
            if (is.list(x)) {
                z <- x$z
                y <- x$y
                x <- x$x
            }
            else {
                z <- x
                x <- seq.int(0, 1, length.out = nrow(z))
            }
        }
        else stop("no 'z' matrix specified")
    }
    else if (is.list(x)) {
        y <- x$y
        x <- x$x
    }
    if (any(diff(x) <= 0) || any(diff(y) <= 0))
        stop("increasing 'x' and 'y' values expected")
    mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar
    on.exit(par(par.orig))
    w <- (3 + mar.orig[2L]) * par("csi") * 2.54
    layout(matrix(c(2, 1), ncol = 2L), widths = c(1, lcm(w)))
    par(las = las)
    mar <- mar.orig
    mar[4L] <- mar[2L]
    mar[2L] <- 1
    par(mar = mar)
    plot.new()
    plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i",
        yaxs = "i")
#    rect(0, levels[-length(levels)], 1, levels[-1L], col = col)
#    if (missing(key.axes)) {
#        if (axes)
#            axis(4)
#    }
#    else key.axes
#    box()
    if (!missing(key.title))
        key.title
    mar <- mar.orig
    mar[4L] <- 1
    par(mar = mar)
    plot.new()
    plot.window(xlim, ylim, "", xaxs = xaxs, yaxs = yaxs, asp = asp)
    if (!is.matrix(z) || nrow(z) <= 1L || ncol(z) <= 1L)
        stop("no proper 'z' matrix specified")
    if (!is.double(z))
        storage.mode(z) <- "double"
    .Internal(filledcontour(as.double(x), as.double(y), z, as.double(levels),
        col = col))
    if (missing(plot.axes)) {
        if (axes) {
            title(main = "", xlab = "", ylab = "")
            Axis(x, side = 1)
            Axis(y, side = 2)
        }
    }
    else plot.axes
    if (frame.plot)
        box()
    if (missing(plot.title))
        title(...)
    else plot.title
    invisible()
} my.filled.contour(x=x, y=y, z=z,
               levels=levels,
               col=colorpanel(length(levels) + 1, "white", "grey10"),
               xlim=rev(range(x)),
               ylim=rev(range(y)),
               plot.axes={axis(1, c(0.18, 0.01), label=TRUE, tcl=-0.5)
                          axis(2, c(0.18, 0.01), label=TRUE, tcl=-0.5)
                          draw.contour()},
               xlab="x",
               frame=FALSE)
-------------------------------------------------------------------------------------------------------
par("usr") grconvert[XY] par(fig=...) plot(d0)
u <- par("usr")
v <- c(
  grconvertX(u[1:2], "user", "ndc"),
  grconvertY(u[3:4], "user", "ndc")
)
v <- c( (v[1]+v[2])/2, v[2], (v[3]+v[4])/2, v[4] )
par( fig=v, new=TRUE, mar=c(0,0,0,0) )
plot(d0_inset, axes=FALSE, xlab="", ylab="")
box()
-------------------------------------------------------------------------------------------------------
minor.tick box() minor.tick
-------------------------------------------------------------------------------------------------------
d <- rlnorm(1000, 3)
d.cut <- cut(d, c(seq(0, 120, 10), Inf))
hist(as.numeric(d.cut), breaks=0:13, xaxt='n', xlab='', 
     col=1, border=0, main='', cex.axis=0.8, las=1)
axis(1, at=0:13, labels=c(seq(0, 120, 10), '>120'), cex.axis=0.8)
box()
-------------------------------------------------------------------------------------------------------
par("usr") xaxs="i" xlim par(mar=c(5,5,2,5)) # change margins
x = barplot(Sales, ylim=c(0,1000)) # barplot, keep middle points of bars
mtext("Sales", 2, line=3) # first y-axis label
xlim = par("usr")[1:2] # get xlim from plot
par(new=TRUE) 
plot.new() # new plot
plot.window(xlim=xlim, ylim=c(0,1), xaxs="i", yaxs="i") # new plot area, same xlim
lines(x,Change,type="b") # the lines in the middle points
axis(4) # secondary y-axis
mtext("Change", 4, line=3) # secondary y-axis label
box()
-------------------------------------------------------------------------------------------------------
axis at labels las=2 plot(meanResidents, axes=FALSE, xlab="dorms")
axis(2)
axis(1, at=seq_along(meanResidents),labels=as.character(rmNumber), las=2)
box()
-------------------------------------------------------------------------------------------------------
yaxs = "i" plot.ecdf(x1, col="blue",
     main="Distribution XYZ",
     xlab="x_i", ylab="Prob(x_i<=y)", yaxs = "i") ylim plot.ecdf box() box()
-------------------------------------------------------------------------------------------------------
spplot spplot.grid(obj, zcol = names(obj), ..., names.attr, scales = list(draw = FALSE),
  xlab = NULL, ylab = NULL, aspect = mapasp(obj,xlim,ylim),
  panel = panel.gridplot, sp.layout = NULL, formula, xlim = bbox(obj)[1, ],
  ylim = bbox(obj)[2, ], checkEmptyRC = TRUE)

....................................................................
....................................................................
....................................................................

 obj: object of class extending Spatial-class

zcol: character; attribute name(s) or column number(s) in attribute
      table
....................................................................
....................................................................
.................................................................... zcol meuse.grid require(sp)
data(meuse.grid) 
coordinates(meuse.grid) = c("x", "y") 
gridded(meuse.grid) <- TRUE

class(meuse.grid)
[1] "SpatialPixelsDataFrame"
attr(,"package")
[1] "sp"

names(meuse.grid)
[1] "part.a" "part.b" "dist"   "soil"   "ffreq" 

spplot(meuse.grid, "soil") spplot(meuse.grid["soil"])
-------------------------------------------------------------------------------------------------------
plot(1:10, rnorm(10), ylim=c(0,1), ylim=c(-1,100))
Error in plot.default(1:10, rnorm(10), ylim = c(0, 1), ylim = c(-1, 100)) : 
  formal argument "ylim" matched by multiple actual arguments hist(x, prob = TRUE, main = main2, xlab = xlab2, ylim = c(0, maxy), ...) maxy <- max(max(a$density), 0.3989 * mix.object$lambda/mix.object$sigma) library(mixtools)
wait = faithful$waiting
mixmdl = normalmixEM(wait)
plot.new()
plot.window(xlim=c(25,110), ylim=c(0,0.5))
plot(mixmdl, which = 2, nclass=20, add = TRUE)
lines(density(wait), lty = 2, lwd = 2)
box(); axis(1); axis(2); title(xlab="Data", ylab="Density")
-------------------------------------------------------------------------------------------------------
lattice Reasonstats <- read.table(text="      Category      Reason   Species
   Decline       Genuine      24
  Improved       Genuine      16
  Improved Misclassified      85
   Decline Misclassified      41
   Decline     Taxonomic       2
  Improved     Taxonomic       7
   Decline       Unclear      41
  Improved       Unclear     117", header=T)

ReasonstatsDec <- Reasonstats[which(Reasonstats$Category=="Decline"),]
ReasonstatsImp <- Reasonstats[which(Reasonstats$Category=="Improved"),]
Reasonstats3   <- cbind(ReasonstatsImp[,3], ReasonstatsDec[,3])
colnames(Reasonstats3) <- c("Improved", "Decline")
rownames(Reasonstats3) <- ReasonstatsImp$Reason

windows()
  barplot(t(Reasonstats3), beside=T, ylab="number of species", 
          cex.names=0.8, las=2, ylim=c(0,120), col=c("darkblue","red"))
  box(bty="l") Decline Improved Reason barplot() barplot() barplot()
-------------------------------------------------------------------------------------------------------
textbox textbox(x,y) c(180,0) x 1 y textbox(-180,0,col=8, "lalalala", box=FALSE)
textbox(-180,-45,col=8, "lalalala", box=FALSE)
textbox(-180,45,col=8, "lalalala", box=FALSE)
-------------------------------------------------------------------------------------------------------
> require(sp)
> bbox(e)
   min max
s1   0  20
s2  35  60 > extent(bbox(e))
class       : Extent 
xmin        : 0 
xmax        : 20 
ymin        : 35 
ymax        : 60
-------------------------------------------------------------------------------------------------------
filled contour image image.scale source("image.scale.R") # http://menugget.blogspot.de/2011/08/adding-scale-to-image-plot.html

x = c(20:200/100)
y = c(20:200/100)
z = as.matrix(exp(x^2)) %*% exp(y^2)

pal <- colorRampPalette(c('green','yellow','red'))
breaks <- c(1:60/3,30,50,150,250,1000,3000)
ncolors <- length(breaks)-1
labs <- c(0.5, 1, 3,30,50,150,250,1000,3000)

#x11(width=6, height=6)
layout(matrix(1:2, nrow=1, ncol=2), widths=c(5,1), heights=c(6))
layout.show(2)

par(mar=c(5,5,1,1))
image(x=x,y=y,z=log(z), col=pal(ncolors), breaks=log(breaks))
box()

par(mar=c(5,0,1,4))
image.scale(log(z), col=pal(ncolors), breaks=log(breaks), horiz=FALSE, xlab="", ylab="", xaxt="n", yaxt="n")
axis(4, at=log(labs), labels=labs)
box()
-------------------------------------------------------------------------------------------------------
?par
 barplot(graph.frame[1,], ylab = "AAA", col = terrain.colors(3),
         ylim="c(0,10),  xaxt = "n")

pdf("data_output.pdf", height = 8.5, width = 14)
graph.frame <- cbind(c(1,2,3,4),c(5,6,7,8),c(9,10,2,2))
par(mfrow = c(1,3), mar = c(7.6, 4.1, 6.1, 2.1))
colnames(graph.frame) <- c("OneOneOne", "TwoTwoTwo", "ThreeThreeThree")
labels <- colnames(graph.frame)
temp1 <- barplot(graph.frame[1,], ylim=c(0,10),ylab = "AAA", col = terrain.colors(3), xaxt = "n")
temp2 <- temp1[1:length(labels)]
text(temp2, par("usr")[3] - 0.35, srt = 45, adj = 1,
     labels = labels, xpd = TRUE)
box()
temp1 <- barplot(graph.frame[2,], ylim=c(0,10),main = "Title", ylab = "BBB", 
                 col = terrain.colors(3), xaxt = "n")
temp2 <- temp1[1:length(labels)]
text(temp2, par("usr")[3] - 0.35, srt = 45, adj = 1,
     labels = labels, xpd = TRUE)
box()
temp1 <- barplot(graph.frame[3,],ylim=c(0,10),ylab = "CCC", col = terrain.colors(3),
                 xaxt = "n")
temp2 <- temp1[1:length(labels)]
text(temp2, par("usr")[3] - 0.35, srt = 45, adj = 1,
     labels = labels, xpd = TRUE)
box()
dev.off()
-------------------------------------------------------------------------------------------------------
axis x = sin(1:100) + rnorm(100, 0,.125)
breaks = c(10,33,85, 96)

plot(x)
sapply(breaks, function(x){abline(v=x, lty=2)})
axis(1, breaks, as.character(breaks)) plot(x, axes=F)
sapply(breaks, function(x){abline(v=x, lty=2)})
axis(1, breaks, as.character(breaks))
axis(2)
box()
-------------------------------------------------------------------------------------------------------
dev.new(width=0.3,height=0.3)
par(mar=c(0.01,0.01,0.01,0.01))

set.seed(13)
x <- 1:10
y <- runif(10)

plot(x,y,type="n",xaxs="i",yaxs="i",ylim=c(0,1))
polygon( c(1,x,max(x),0), c(0,y,0,0), col="lightblue", border=NA)
lines(x,y,lwd=1)

box(lwd=1)
-------------------------------------------------------------------------------------------------------
png dev.new(width=1.3,height=0.3)
# repeat from here onwards only for png call below
par(mar=c(0,0,0,0))
set.seed(13)
x <- 1:10
y <- runif(10)
plot(x,y,type="n",xaxs="i",yaxs="i",ylim=c(0,1),bty="n")
polygon( c(1,x,max(x),0), c(0,y,0,0), col="lightblue", border=NA)
lines(x,y,lwd=1)
box(lwd=1) png png("textbox_direct.png",width=116,height=27)
# take code block from above
dev.off()
-------------------------------------------------------------------------------------------------------
> print(data.frame(n=2:3, x=1:6))
- n x
1 2 1
2 3 2
3 2 3
4 3 4
5 2 5
6 3 6 > print(expand.grid(x=1:5, n=2:3))
-  x n
1  1 2
2  2 2
3  3 2
4  4 2
5  5 2
6  1 3
7  2 3
8  3 3
9  4 3
10 5 3 lapply(2:3, FUN=function(n) (f(n, x=1:5)))
#[[1]]
#[1] 0.0004981910 0.0006066275 0.0007328627 0.0008786344 0.0010456478
#
#[[2]]
#[1] 0.0007464956 0.0009087272 0.0010974595 0.0013152213 0.0015644676 wrapper <- function(i, x, n, fti){
    # As was provided by OP
    g<-function(x) {do.call(paste("d",i,sep=""),c(list(x=x),fti$estimate))}

    G<-function(x) {do.call(paste("p",i,sep=""),c(list(q=x),fti$estimate))}
    # does the i in fti refer to fit of i:th distribution, i.e. should it be a list where i:th location in ft is i:th distribution estimates?

    f<-function(n,x) {n*g(x)*(1-G(x))^(n-1)}
    # was missing a '-' and a '}'

    h<- function(n) {integrate(function(x) {x*f(n,x)},0,Inf)}

    list(gres = g(x), Gres = G(x), fres = f(n,x), hres = h(n))
}

# Example data
require("fitdistrplus")
data(groundbeef)
serving <- groundbeef$serving

# Gumbel distribution
d1 <- function(x, a, b) 1/b*exp((a-x)/b)*exp(-exp((a-x)/b))
p1 <- function(q, a, b) exp(-exp((a-q)/b))
q1 <- function(p, a, b) a-b*log(-log(p))

fti1 <- fitdist(serving, "1", start=list(a=10, b=10))
#> fti1$estimate
#       a        b 
#56.95893 29.07871

# Normal distribution

# dnorm, pnorm and qnorm are available in the default environment
d2 <- dnorm
p2 <- pnorm
q2 <- qnorm

fti2 <- fitdist(serving, "2", start=list(mean=0, sd=1))
#> fti2$estimate
#    mean       sd 
#73.67743 35.92581

# Sequence of x-values
xs <- seq(-100, 100, by=1)

print((resultdist1n2 <- wrapper(i=1, x=xs, n=2, fti=fti1))$hres)
print((resultdist1n3 <- wrapper(i=1, x=xs, n=3, fti=fti1))$hres)
print((resultdist2n2 <- wrapper(i=2, x=xs, n=2, fti=fti2))$hres)
print((resultdist2n3 <- wrapper(i=2, x=xs, n=3, fti=fti2))$hres)

plot(xs, resultdist1n2$fres, col=1, type="l", ylim=c(0,0.025), xlab="x", ylab="f(n, x)")
points(xs, resultdist1n3$fres, col=2, type="l")
points(xs, resultdist2n2$fres, col=3, type="l")
points(xs, resultdist2n3$fres, col=4, type="l")
legend("topleft", legend=c("Gamma (i=1) n=2", "Gamma (i=1) n=3", "Normal (i=2) n=2", "Normal (i=2) n=3"), col=1:4, lty=1) h(n=2) for distribution i=1:
53.59385 with absolute error < 0.00022
h(n=3) for distribution i=1:
45.23146 with absolute error < 4.5e-05
h(n=2) for distribution i=2:
53.93748 with absolute error < 1.1e-05
h(n=3) for distribution i=2:
44.06331 with absolute error < 2e-05 ns <- 0:256
res1 <- lapply(ns, FUN=function(nseq) wrapper(i=1, x=xs, n=nseq, fti=fti1))
par(mfrow=c(1,2))
plot.new()
plot.window(xlim=c(-100,100), ylim=c(0, 0.05))
box(); axis(1); axis(2); title(xlab="x", ylab="f(n,x)", main="f(n,x) for gamma (i=1), n=0:256")
for(i in 1:length(ns)) points(xs, res1[[i]]$fres, col=rainbow(257)[i], type="l")
# perform similarly for the other distributions by calling with i=2, fti=fti2
# h as a function of n for dist i=1
plot(ns, unlist(lapply(res1, FUN=function(x) x$hres$value)), col=rainbow(257), xlab="n", ylab="h(n)", main="h(n) for gamma (i=1), n=0:256")
-------------------------------------------------------------------------------------------------------
library(gWidgets)
options("guiToolkit"="RGtk2")
library(MASS)



x <- Cars93
fac_levels <- levels(x$Type)
n_levels <- length(fac_levels)

## create a GUI with mutually exclusive comboboxes
w <- gwindow()
g <- ggroup(horizontal=FALSE, cont=w)

widgets <- lapply(1:4, function(i) {
  gcombobox(fac_levels, selected=i, cont=g)
})


## make exclusive
sapply(1:length(widgets), function(i) {
  addHandlerChanged(widgets[[i]], handler=function(h,...) {
    all_selected <- sapply(widgets, svalue)
    selected <- svalue(h$obj)

    ind <- which(selected == all_selected)

    if(length(ind) > 1) {
      j <- setdiff(ind, i)
      remaining <- setdiff(fac_levels, all_selected)
      tmp <- widgets[[j]]
      svalue(tmp) <- remaining[1]
    }
  })
})
-------------------------------------------------------------------------------------------------------
library(gWidgets)
options("guiToolkit"="RGtk2")
library(MASS)





varSelector <- NULL

## create a GUI with mutually exclusive comboboxes
w <- gwindow()
g <- ggroup(horizontal=FALSE, cont=w)
select_file <- gfilebrowse("Select a file", cont=g, quote=FALSE)
g1 <- ggroup(horizontal=FALSE, cont=g)
b <- gbutton("List selected", cont=g, handler=function(h,...) {
  if (!is.null(varSelector))
    print(varSelector$get_values())
})


addHandlerChanged(select_file, handler=function(h,...) {
  csvfile <- svalue(h$obj)
  x <- read.csv(csvfile)
  fac_levels <- Filter(function(nm) is.factor(x[[nm]]), names(x))
  if (length(fac_levels) > 4) {
    varSelector <<- VarSelect$new(fac_levels, g1)
  }
})

##


VarSelect <- setRefClass("VarSelect",
                         fields=list(
                           widgets="list",
                           fac_levels="character",
                           flag="logical"
                           ),
                         methods=list(
                           initialize=function(levels=character(), cont=gwindow(), ...) {
                             g <- ggroup(horizontal=FALSE, cont=cont, ...)
                             initFields(
                               fac_levels=levels,
                               flag=FALSE
                               )
                             widgets <<- lapply(1:4, function(i) {
                               gcombobox(fac_levels, selected=i, cont=g)
                             })
                             if(length(fac_levels) > 4)
                               make_exclusive()
                             .self

                           },
                           set_levels=function(levels) {
                             fac_levels <<- levels
                             lapply(widgets, blockHandler)
                             lapply(widgets, function(widget) widget[] <- fac_levels)
                             if (!flag) {
                               make_exclusive()
                               flag <<- TRUE
                             }
                             lapply(widgets, unblockHandler)
                           },
                           make_exclusive=function() {
                             sapply(1:length(widgets), function(i) {
                               addHandlerChanged(widgets[[i]], handler=function(h,...) {
                                 all_selected <- sapply(widgets, svalue)
                                 selected <- svalue(h$obj)

                                 ind <- which(selected == all_selected)

                                 if(length(ind) > 1) {
                                   j <- setdiff(ind, i)
                                   remaining <- setdiff(fac_levels, all_selected)
                                   tmp <- widgets[[j]]
                                   svalue(tmp) <- remaining[1]
                                 }
                               })
                             })
                           },
                           get_values = function() lapply(widgets, svalue)
                         ))
-------------------------------------------------------------------------------------------------------
#Example Data
n = 6
time02H = abs(rnorm(n))
time06H = abs(rnorm(n))
time24H = abs(rnorm(n))

allPAL.DE = data.frame(time02H,time06H,time24H)

plot(0,0,xlab="Time",ylab="Values",type="n",xlim=c(0,2),ylim=c(min(allPAL.DE,0),max(allPAL.DE)),axes="FALSE")
box()
axis(1,0:2,c("time02H","time06H","time24H"))
axis(2)
abline(h=0,col="grey",lty=2,lwd=2)

for(i in 1:nrow(allPAL.DE)){
    lines(0:2,allPAL.DE[i,],col=i,lwd=2)
}
-------------------------------------------------------------------------------------------------------
palette(c("red","green","yellow","blue","black"))
plot.default(
  as.data.frame.table(t(mat))[1:2],
  col=findInterval(t(mat),c(0,0.2,0.4,0.6,0.9)),
  pch=19,
  axes=FALSE,ann=FALSE,
  panel.first=grid()
)
axis(2,at=1:length(rownames(mat)),labels=rownames(mat),lwd=0,lwd.ticks=1,las=1)
axis(1,at=1:length(colnames(mat)),labels=colnames(mat),lwd=0,lwd.ticks=1)
box()
palette("default")
-------------------------------------------------------------------------------------------------------
xaxt = "n" yaxt = "n" box grid month.name seq.int x <- matrix(
  c(
    200, 227, 196, 
    210, 279, 319, 
    220, 126, 111,
    230, 196, 123,
    240, 106, 94,
    250, 154, 233,
    260, 226, 218
  ),
  nrow = 3,
  ncol = 7
)
colnames(x) <- month.name[c(11:12, 1:5)]
rownames(x) <- c("Hornberg", "Strick", "Huetten")


par(mar = c(5, 4, 1.5, 0.5), ps = 12, cex  = 1, cex.main = 2, las = 1)

barplot(
  x, 
  beside      = TRUE, 
  ylim        = c(0,350),
  xlab        = "Month", 
  axes        = TRUE,
  axis.lty    = 1, 
  ylab        = "Monthly Precipitation [mm]",
  col         = c("darkblue", "dodgerblue3", "deepskyblue1"),
  panel.first =  abline(
    h    =  seq.int(50, 300, 50), 
    col  =  "grey", 
    lty  =  2
  )
)
box()
grid()
-------------------------------------------------------------------------------------------------------
corrgram set.seed(42)
library(corrgram)

# This panel adds significance starts, or NS for not significant
panel.signif <-  function (x, y, corr = NULL, col.regions, digits = 2, cex.cor, 
                           ...) {
  usr <- par("usr")
  on.exit(par(usr))
  par(usr = c(0, 1, 0, 1))
  results <- cor.test(x, y, alternative = "two.sided")
  est <- results$p.value
  stars <- ifelse(est < 5e-4, "***", 
                  ifelse(est < 5e-3, "**", 
                         ifelse(est < 5e-2, "*", "NS")))
  cex.cor <- 0.4/strwidth(stars)
  text(0.5, 0.5, stars, cex = cex.cor)
}

# This panel combines edits the "shade" panel from the package
# to overlay the correlation value as requested
panel.shadeNtext <- function (x, y, corr = NULL, col.regions, ...) 
{
  if (is.null(corr)) 
    corr <- cor(x, y, use = "pair")
  ncol <- 14
  pal <- col.regions(ncol)
  col.ind <- as.numeric(cut(corr, breaks = seq(from = -1, to = 1, 
                                               length = ncol + 1), include.lowest = TRUE))
  usr <- par("usr")
  rect(usr[1], usr[3], usr[2], usr[4], col = pal[col.ind], 
       border = NA)
  box(col = "lightgray")
  on.exit(par(usr))
  par(usr = c(0, 1, 0, 1))
  r <- formatC(corr, digits = 2, format = "f")
  cex.cor <- .8/strwidth("-X.xx")
  text(0.5, 0.5, r, cex = cex.cor)
}

# Generate some sample data
sample.data <- matrix(rnorm(100), ncol=10)

# Call the corrgram function with the new panel functions
# NB: call on the data, not the correlation matrix
corrgram(sample.data, type="data", lower.panel=panel.shadeNtext, 
         upper.panel=panel.signif) corrplot panel.shadeNtext <- function (x, y, corr = NULL, col.regions, ...) 
{
  corr <- cor(x, y, use = "pair")
  results <- cor.test(x, y, alternative = "two.sided")
  est <- results$p.value
  stars <- ifelse(est < 5e-4, "***", 
                  ifelse(est < 5e-3, "**", 
                         ifelse(est < 5e-2, "*", "")))
  ncol <- 14
  pal <- col.regions(ncol)
  col.ind <- as.numeric(cut(corr, breaks = seq(from = -1, to = 1, 
                                               length = ncol + 1), include.lowest = TRUE))
  usr <- par("usr")
  rect(usr[1], usr[3], usr[2], usr[4], col = pal[col.ind], 
       border = NA)
  box(col = "lightgray")
  on.exit(par(usr))
  par(usr = c(0, 1, 0, 1))
  r <- formatC(corr, digits = 2, format = "f")
  cex.cor <- .8/strwidth("-X.xx")
  fonts <- ifelse(stars != "", 2,1)
  # option 1: stars:
  text(0.5, 0.4, paste0(r,"\n", stars), cex = cex.cor)
  # option 2: bolding:
  #text(0.5, 0.5, r, cex = cex.cor, font=fonts)
}

# Generate some sample data
sample.data <- matrix(rnorm(100), ncol=10)

# Call the corrgram function with the new panel functions
# NB: call on the data, not the correlation matrix
corrgram(sample.data, type="data", lower.panel=panel.shadeNtext, 
         upper.panel=NULL)
-------------------------------------------------------------------------------------------------------
# Define function for ploting
example <- function(...){
  plot(cars)
  i <- 1
  for (my.control in list(...)) {
    if (my.control) abline(0, i)
    i <- i+1
  }
}

# Define your controls
custom.args <- list()
for (i in 1:5) {
  custom.args <- append(custom.args, list(checkbox(FALSE, paste("Ceckbox", i))))
}
names(custom.args) <- paste("checkbox", 1:5, sep="")

# Pass everything to manipulate
library(manipulate)
manipulate(
  eval(parse(text=sprintf('example(%s)', 
                          paste(names(custom.args), collapse=","))
             )),
  custom.args)
-------------------------------------------------------------------------------------------------------
boxplots data(tips, package = 'reshape2')
p3 <- rPlot(x = 'day', y = 'box(tip)', data = tips, type = 'box')
p3
-------------------------------------------------------------------------------------------------------
plot.xts add plot.xts plot.xtsMODIFIED<-function (x, y = NULL, type = "l", auto.grid = TRUE, major.ticks = "auto", 
    minor.ticks = TRUE, major.format = TRUE, bar.col = "grey", 
    candle.col = "white", ann = TRUE, axes = TRUE, ...) 
{
    series.title <- deparse(substitute(x))
    ep <- axTicksByTime(x, major.ticks, format.labels = major.format)
    otype <- type
    if (is.OHLC(x) && type %in% c("candles", "bars")) {
        x <- x[, has.OHLC(x, TRUE)]
        xycoords <- list(x = .index(x), y = seq(min(x), max(x), 
            length.out = NROW(x)))
        type <- "n"
    }
    else {
        if (NCOL(x) > 1) 
            warning("only the univariate series will be plotted")
        if (is.null(y)) 
            xycoords <- xy.coords(.index(x), x[, 1])
    }
    ###The next three lines are the only modifications i made to the function####
    plot(xycoords$x, xycoords$y, type = "n", axes = FALSE, ann = FALSE) 
    rect(par("usr")[1], par("usr")[3], par("usr")[2], par("usr")[4], col ="white")
    if(type=="l"){lines(xycoords$x, xycoords$y, ...)}

    if (auto.grid) {
        abline(v = xycoords$x[ep], col = "grey", lty = 4)
        grid(NA, NULL)
    }
    if (is.OHLC(x) && otype == "candles") 
        plot.ohlc.candles(x, bar.col = bar.col, candle.col = candle.col, 
            ...)
    dots <- list(...)
    if (axes) {
        if (minor.ticks) 
            axis(1, at = xycoords$x, labels = FALSE, col = "#BBBBBB", 
                ...)
        axis(1, at = xycoords$x[ep], labels = names(ep), las = 1, 
            lwd = 1, mgp = c(3, 2, 0), ...)
        axis(2, ...)
    }
    box()
    if (!"main" %in% names(dots)) 
        title(main = series.title)
    do.call("title", list(...))
    assign(".plot.xts", recordPlot(), .GlobalEnv)
} library(quantmod)
getSymbols('SPY', from='1998-01-01', to='2011-07-31', adjust=T)

GRAPH_BLUE<-rgb(43/255, 71/255,153/255)
GRAPH_BACKGROUND<-rgb(180/255, 226/255, 244/255)

par(bg=GRAPH_BACKGROUND)

plot.xtsMODIFIED(SPY, col=GRAPH_BLUE) Error in axis(1, at = xycoords$x, labels = FALSE, col = "#BBBBBB", ...) : formal argument "col" matched by multiple actual arguments. plot.xts ... col axis plot lines ...
axis(1, at = xycoords$x, labels = FALSE, col = "#BBBBBB", 
            ...)
... ...
axis(1, at = xycoords$x, labels = FALSE, ...)
... plot.xts plot.xtsMODIFIED<-function (x, y = NULL, type = "l", auto.grid = TRUE, major.ticks = "auto", 
                             minor.ticks = TRUE, major.format = TRUE, bar.col = "grey", 
                             candle.col = "white", ann = TRUE, axes = TRUE, 
                             lcol, ...) 
{
...
if(type=="l"){lines(xycoords$x, xycoords$y, lcol, ...)}
...
} plot.xtsMODIFIED(SPY, lcol=GRAPH_BLUE)
-------------------------------------------------------------------------------------------------------
log='xy' plot(log(x), log(y), axes=FALSE, xlab="X", ylab="Y")
box()
axis(side=1,     at=log(c(1,2, 10,20, 100,200)), 
             labels=c(    1,2, 10,20, 100,200))
axis(side=2,     at=log(c(125,135, 250,260, 350, 500)), 
             labels=c(    125,135, 250,260, 350, 500))
abline(model, col="red")
-------------------------------------------------------------------------------------------------------
griddg Tps xvals <- seq(-10, 4, len=20)
yvals <- seq(49, 63, len=20)
griddf <- expand.grid(lon=xvals, lat=yvals)
griddg <- predict(fit, x=as.matrix(griddf) )

dat2 <- cbind(griddf, mm=griddg)
head(dat2)
fit <- Tps(cbind(dat2$lon, dat2$lat), dat2$mm, scale.type="unscaled")
surface (fit, nx=100, ny=100)
world(add=TRUE) Tps #option 2
source("matrix.poly.r") #http://menugget.blogspot.de/2012/04/create-polygons-from-matrix.html
source("val2col.R") # http://menugget.blogspot.de/2011/09/converting-values-to-color-levels.html
source("image.scale.R") # http://menugget.blogspot.de/2011/08/adding-scale-to-image-plot.html

#new grid and predition
xvals <- seq(-10, 4, len=100)
yvals <- seq(49, 63, len=100)
griddf <- expand.grid(lon=xvals, lat=yvals)
griddg <- predict(fit, x=as.matrix(griddf) )

#make polygons for new grid, calculate color levels
mat <- matrix(griddg, nrow=length(xvals), ncol=length(yvals))
poly <- matrix.poly(xvals, yvals, z=mat, n=seq(mat))
pal <- colorRampPalette(c("blue", "cyan", "yellow", "red"))
COL <- val2col(mat, col=pal(100))

#required packages
library(maps)
library(mapproj)

#plot
png("tmp.png", width=5, height=4, res=400, units="in")
layout(matrix(1:2, nrow=1, ncol=2), widths=c(4,1), heights=4)
par(mar=c(1,1,1,1))
map("world", proj="stereographic", orient=c(mean(yvals),mean(xvals),0), par=NULL, t="n", xlim=range(xvals), ylim=range(yvals))
for(i in seq(poly)){
 polygon(mapproject(poly[[i]]), col=COL[i], border=COL[i], lwd=0.3)
}
map("world", proj="stereographic", orient=c(mean(yvals),mean(xvals),0), par=NULL, add=T)
map.grid(col=rgb(0,0,0,0.5), labels=F)
box()

par(mar=c(5,0,5,4))
image.scale(mat, col=pal(100), horiz=FALSE, axes=FALSE, xlab="", ylab="")
axis(4)
mtext("mm", side=4, line=2.5)
box()

dev.off()
-------------------------------------------------------------------------------------------------------
# This is equivalent to your for-loops, use whatever you prefer
x0 <- do.call(rbind, lapply(1:350, function(i) {
  arima.sim(list(order=c(1,0,0), ar=ifelse(i <= 150, 0.9, -0.9)), n=76)
}))

plotStuff <- function(indices, ...) {
  plot.new()
  plot.window(xlim=c(1, ncol(x0)), ylim=range(x0[indices,]))
  box()
  for (i in indices)
    lines(x0[i,], ...)
}

par(mfrow=c(2,1), mar=rep(1,4)) # two rows, reduced margin
plotStuff(1:150,   col="orange")
plotStuff(151:350, col="blue")
-------------------------------------------------------------------------------------------------------
plot.new()
plot.window(xlim=c(0,100),ylim=c(0,100))
lines(c(0,50,100), c(50,0,0))
axis(1)
axis(2)
title(main="Graph")
title(xlab="X")
title(ylab="Y")
box()
-------------------------------------------------------------------------------------------------------
segments Draw line segments between pairs of points. plot.new()
plot.window(xlim=c(0,100),ylim=c(0,100))
#abline(a=50,b=-1)
#abline(a=0,b=0)
segments(0,50,50,0)
segments(50,0,100,0)
axis(1)
axis(2)
title(main="Graph")
title(xlab="X")
title(ylab="Y")
box()
-------------------------------------------------------------------------------------------------------
scatter_fill <- function (x, y, z,xlim=c(min(x),max(x)),ylim=c(min(y),max(y)),zlim=c(min(z),max(z)),
                          nlevels = 20, plot.title, plot.axes, 
                          key.title, key.axes, asp = NA, xaxs = "i", 
                          yaxs = "i", las = 1, 
                          axes = TRUE, frame.plot = axes, ...) 
{
  mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar
  on.exit(par(par.orig))
  w <- (3 + mar.orig[2L]) * par("csi") * 2.54
  layout(matrix(c(2, 1), ncol = 2L), widths = c(1, lcm(w)))
  par(las = las)
  mar <- mar.orig
  mar[4L] <- mar[2L]
  mar[2L] <- 1
  par(mar = mar)

# choose colors to interpolate
levels <- seq(zlim[1],zlim[2],length.out = nlevels)
col <- colorRampPalette(c("red","yellow","dark green"))(nlevels)  
colz <- col[cut(z,nlevels)]  
#   
plot.new()
plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i", yaxs = "i")

rect(0, levels[-length(levels)], 1, levels[-1L],col=col,border=col) 
if (missing(key.axes)) {if (axes){axis(4)}}
       else key.axes
   box()
   if (!missing(key.title)) 
     key.title
   mar <- mar.orig
   mar[4L] <- 1
   par(mar = mar)

   # points
   plot(x,y,type = "n",xaxt='n',yaxt='n',xlab="",ylab="",xlim=xlim,ylim=ylim,bty="n")
   points(x,y,col = colz,xaxt='n',yaxt='n',xlab="",ylab="",bty="n",...)

   ## options to make mapping more customizable

        if (missing(plot.axes)) {
          if (axes) {
            title(main = "", xlab = "", ylab = "")
            Axis(x, side = 1)
            Axis(y, side = 2)
          }
        }
        else plot.axes
        if (frame.plot) 
          box()
        if (missing(plot.title)) 
          title(...)
        else plot.title
        invisible()
 } # random vectors
vx <- rnorm(40,0,1)
vy <- rnorm(40,0,1)
vz <- rnorm(40,10,10)

scatter_fill(vx,vy,vz,nlevels=15,xlim=c(-1,1),ylim=c(-1,5),zlim=c(-10,10),main="TEST",pch=".",cex=8)
-------------------------------------------------------------------------------------------------------
xlim <- c(min(x1,x2),max(x1,x2))
ylim <- c(min(y1,y2),max(y1,y2))
xlim <- xlim+c(-1,1)*(xlim[2]-xlim[1])*0.04 # extend by 4% on each side
ylim <- ylim+c(-1,1)*(ylim[2]-ylim[1])*0.04 # extend by 4% on each side
n1 <- length(x1)
n2 <- length(x2)
xS <- c(xlim[1],xlim,rev(xlim),xlim[1])
yS <- c(0,rep(ylim,each=2),0)
plot(NA,xlim=xlim,ylim=ylim,xaxs='i',yaxs='i')
polygon(xS,yS,border=NA,col=rgb(0,0,0))
polygon(c(x1,xS),c(y1,yS),border=NA,col=rgb(1,1,1))
polygon(c(x2,xS),c(y2,yS),border=NA,col=rgb(1,1,1))
box()
polygon(x1,y1)
polygon(x2,y2)
-------------------------------------------------------------------------------------------------------
plot(seq_along(x),intensity,type = "l",axes = FALSE)
axis(side = 2)
axis(side = 1,at = seq_along(x),labels = x) box()
-------------------------------------------------------------------------------------------------------
# gen data
x <- 1:30
y <- 1:30
hello <- matrix(0:1, nrow=30, ncol=30)

# make basic plot of hello matrix
image(  1:ncol(hello), 1:nrow(hello), 
        t(hello), col=ifelse(t(hello)==1,"yellow","white"),
        ylab="rows",xlab="columns"      )
box()

# now let's decide whether or not a coordinate should be plotted, 
# depending on the value of hello for this coordinate ...
# by cycling through each pair of coordinates and saving T/F in iffer
iffer <- NULL
for(i in seq_along(x)) iffer <- c( iffer, hello[ y[i] , x[i] ]==1 )

# plotting of the adequate subset of points that had a hello value of 1 
points( x[iffer] , y[iffer], col="green")
-------------------------------------------------------------------------------------------------------
barplot(c(54.0, 56.7, 55.9, 59.0), ylim=c(50,60), xpd = FALSE)
box() #maybe nicer if you add this too
-------------------------------------------------------------------------------------------------------
axis(1, at=time) time time axis(1, at=..., labels=...) plot.ts 2010 2013.75 at axis time 2010, 2010.25, 2010.50 ... seq(from=2010, to=2013.25, by=0.25) plot.ts(y,axes=F) # don't plot the axes yet
axis(2) # plot the y axis
axis(1, labels=time, at=seq(from=2010, by=0.25, length.out=length(time)) )
box() # and the box around the plot
-------------------------------------------------------------------------------------------------------
image.plot fields image.plot image graphics library(grid)
x=1:10
y=1:10
z=matrix(-50:49,10,10)

layout(matrix(c(1,2),ncol=2), widths=c(2,1))         
par(mar=c(5,3,5,3))
image(x,y,z,yaxt="n",xaxt="n", ylab="", xlab="",col=heat.colors(50)) 
cap <- grid.cap()
grid.newpage()
grid.raster(cap, x=unit(0.6,'npc'), #You can modify that if the plot 
            y=unit(0.5,'npc'),      #ends up outside the figure area
            vp=viewport(angle=36))
mtext("Some fancy title",side=3,cex=1.5,line=2) #Plot your title
par(mar=c(5,8,5,3))
plot(NA,ax=F,ann=F,type="n",xlim=c(0,1),ylim=c(0,50),yaxs="i")
for(i in 1:50)rect(0,i-1,1,i,col=heat.colors(50)[i],border=NA)
box()
axis(4,las=2,at=seq(0,50,by=10),labels=seq(-50,50,by=20))
-------------------------------------------------------------------------------------------------------
reference ggplot(d, aes(x, y)) + geom_point() + theme_bw() +
  scale_x_continuous(limits=c(0, 10)) + scale_y_continuous(limits=c(0, 10)) +
  geom_subplot(data=d, aes(x=5, y=1, group = grp, subplot = geom_point(aes(x, y))), width=4, height=4,reference=ref_box(fill = "grey90", color = "black"))
-------------------------------------------------------------------------------------------------------
## plotting area with no axes
plot(unrate.df, type = "n")
lim <- par("usr")
## adding one rectangle
for (i in 1:nrow(recessions.trim)) {
     rect(recessions.trim[i, 1], lim[3], 
          recessions.trim[i, 2], lim[4], border = "pink", col = "pink")
}
## adding the data
lines(unrate.df)
box()
-------------------------------------------------------------------------------------------------------
graphics species species = unique(carbon2$Species) # c("Acru", "Arte", ...)
bin.name = c("Acer rubrum", "Arundinaria tecta", "Clethra alnifolia",
             "Eupatorium rotundifolium", "Gaylussacia frondosa", 
             "Ilex glabra", "Lyonia lucida", "Oxydendrum arboreum",
             "Persea palustris")

sites = c(7,8) # sites to use
color = c("blue", "green") # colors for each site

fit.bio = list() # list to save all models

par(mfrow=c(3,3), cex=.3) 

for(isp in seq_along(species)) {

  sp.data = carbon2[carbon2$Species==species[isp], ] 

  fit.bio[[isp]] <- lm(LogRecBio ~ LogPreBiomass, data=sp.data)

  sp.label     = paste(letters[isp], ") ", bin.name[isp], sep="")
  sp.r.squared = paste("R", "=", round(summary(fit.bio[[isp]])$adj.r.squared, 3))
  plot(LogRecBio ~ LogPreBiomass, data=sp.data, 
       font.lab=2,font.main=2, font.sub=3, ylim=c(-5,4),
       mgp=c(2.5,1,0), cex.lab=2, cex.main=1.5, 
       axes=FALSE, lwd=1.5, cex=2.5, ann=FALSE)

  for(isite in seq_along(sites)) {
    # loop for each selected site
    site.data  = sp.data[sp.data$site==sites[isite], ]
    site.model = lm(LogRecBio ~ LogPreBiomass, data=site.data)
    abline(site.model, lwd=2, col=color[isite])

  }

  abline(fit.bio[[isp]], lwd=2, col='red') # all data

  axis(1,at=c(-2,-1,0,1,2,3,4),font=2,cex.axis=3)
  axis(2,at=c(-5,-4,-3,-2,-1,0,1,2),font=2,cex.axis=3)
  box()

  mtext(sp.label, 3, line=-2.5, adj=0.05, font=3, cex=0.75)
  mtext(sp.r.squared, 3, line=-2.5, adj=0.95, cex=0.75)

}
-------------------------------------------------------------------------------------------------------
gWidgets2 w <- gwindow()
g <- gvbox(cont=w)
e <- gedit("5", cont=g, coerce=as.integer)
cb <- gcombobox(1:5, cont=g)
b <- gbutton("do clustering", cont=g)

addHandlerChanged(e, handler=function(h,...) {
  ## check svalue(e) is non-NA
  cb[] <- seq_len(svalue(e))
})

addHandlerClicked(b, handler=function(h,...) {
  print(sprintf("Do clustering with %s", svalue(cb)))
})
-------------------------------------------------------------------------------------------------------
dat <- matrix(c(
                c(0.25,0.25,0.25,0.25),
                c(0.05,0,0.95,0),
                c(0.4,0.1,0.1,0.4)),
                nrow=4,ncol=3,byrow=FALSE,
                dimnames=list(c("A","C","G","T"),
                              c("E","S","I"))
                )

  barplot(dat,border=FALSE,beside=TRUE,
          col=rainbow(4),ylim=c(0,1),
          legend=rownames(dat),main="Plot name",
          xlab="State",ylab="observation")
  grid()
  box()
-------------------------------------------------------------------------------------------------------
