png(file="notitle.png",width=400, height=350)
par(mar=c(5,3,2,2)+0.1)
hist(rnorm(100),ylab=NULL,main=NULL)
dev.off()
-------------------------------------------------------------------------------------------------------
hist() ,prob=TRUE plot(mydata_hist$count, log="y", type='h', lwd=10, lend=2) hist(log(x), ...)
-------------------------------------------------------------------------------------------------------
X <- c(rep(65, times=5), rep(25, times=5), rep(35, times=10), rep(45, times=4))
hist(X, prob=TRUE)            # prob=TRUE for probabilities not counts
lines(density(X))             # add a density estimate with defaults
lines(density(X, adjust=2), lty="dotted")   # add another "smoother" density
-------------------------------------------------------------------------------------------------------
foo <- rnorm(100, mean=1, sd=2)
hist(foo, prob=TRUE)
curve(dnorm(x, mean=mean(foo), sd=sd(foo)), add=TRUE)
-------------------------------------------------------------------------------------------------------
den<-dnorm #replace with your own density

#calculates the cdf by numerical integration
cdf<-function(x) integrate(den,-Inf,x)[[1]]

#inverts the cdf
inverse.cdf<-function(x,cdf,starting.value=0){
 lower.found<-FALSE
 lower<-starting.value
 while(!lower.found){
  if(cdf(lower)>=(x-.000001))
   lower<-lower-(lower-starting.value)^2-1
  else
   lower.found<-TRUE
 }
 upper.found<-FALSE
 upper<-starting.value
 while(!upper.found){
  if(cdf(upper)<=(x+.000001))
   upper<-upper+(upper-starting.value)^2+1
  else
   upper.found<-TRUE
 }
 uniroot(function(y) cdf(y)-x,c(lower,upper))$root
}

#generates 1000 random variables of distribution 'den'
vars<-apply(matrix(runif(1000)),1,function(x) inverse.cdf(x,cdf))
hist(vars)
-------------------------------------------------------------------------------------------------------
x <- rlnorm(1000)
hx <- hist(x, plot=FALSE)
plot(hx$counts, type="h", log="y", lwd=10, lend="square") plot(hx$counts, type="h", log="y", lwd=10, lend="square", axes = FALSE)
Axis(side=1)
Axis(side=2) lwd lattice ggplot par(lend="square")
bordercol <- "blue"
fillcol <- "pink"
linewidth <- 24
plot(hx$counts, type="h", log="y", lwd=linewidth, col=bordercol, axes = FALSE)
lines(hx$counts, type="h", lwd=linewidth-2, col=fillcol)
Axis(side=1)
Axis(side=2)
-------------------------------------------------------------------------------------------------------
x = rnorm(100)
hist(x,br=10,col=c(rep(0,9),1))
-------------------------------------------------------------------------------------------------------
highlight <- function(x, value, col.value, col=NA, ...){
   hst <- hist(x, ...)
   idx <- findInterval(value, hst$breaks)
   cols <- rep(col, length(hst$counts))
   cols[idx] <- col.value
   hist(x, col=cols, ...)
} x <- rnorm(100)
highlight(x, 1.2, "red")
-------------------------------------------------------------------------------------------------------
we <- gsub(",", "", we)   # remove comma
 we <- as.numeric(we)      # turn into numbers hist(we)
-------------------------------------------------------------------------------------------------------
Reduce('+', lapply(mylist, function(x) hist(x[1]:x[2], breaks = (0:6) * 100, plot = F)$counts)) breaks
-------------------------------------------------------------------------------------------------------
def pair(data, labels=None):
    """ Generate something similar to R `pair` """

    nVariables = data.shape[1]
    if labels is None:
        labels = ['var%d'%i for i in range(nVariables)]
    fig = pl.figure()
    for i in range(nVariables):
        for j in range(nVariables):
            nSub = i * nVariables + j + 1
            ax = fig.add_subplot(nVariables, nVariables, nSub)
            if i == j:
                ax.hist(data[:,i])
                ax.set_title(labels[i])
            else:
                ax.plot(data[:,i], data[:,j], '.k')

    return fig
-------------------------------------------------------------------------------------------------------
y <- c(1,23,24,11,33,22,5,6,7,8,3,2)
h <- hist(y, seq(0, 40, 10), plot=0) # plot=0 avoids plotting the histogram
# Refer to h$counts to get the counts in each bin
-------------------------------------------------------------------------------------------------------
hist(rnorm(20),xlab=parse(text=varname))
-------------------------------------------------------------------------------------------------------
R> a <- c(1,2,1,1,1,3,1,2,3,3)
R> b <- hist(a, plot=FALSE)
R> str(b)
List of 7
 $ breaks     : num [1:5] 1 1.5 2 2.5 3
 $ counts     : int [1:4] 5 2 0 3
 $ intensities: num [1:4] 1 0.4 0 0.6
 $ density    : num [1:4] 1 0.4 0 0.6
 $ mids       : num [1:4] 1.25 1.75 2.25 2.75
 $ xname      : chr "a"
 $ equidist   : logi TRUE
 - attr(*, "class")= chr "histogram"
R>
-------------------------------------------------------------------------------------------------------
hist seq br <- seq(0.9, 9.9, 1)
num <- hist(a, br, plot=F)$counts which num <- length(which(a == 1))
-------------------------------------------------------------------------------------------------------
## open connection
library(RODBC)
channel <- odbcConnect("")

## generate a plot and save it to a temp file
x <- rnorm(100,0,1)
hist(x, col="light blue")
savePlot("temp.jpg", type="jpeg")

## read back in the temp file as binary
plot_binary <- paste(readBin("temp.jpg", what="raw", n=1e6), collapse="")

## insert it into a table
sqlQuery(channel, paste("insert into test values (1, x'",plot_binary,"')", sep=""))

## close connection
odbcClose(channel)
-------------------------------------------------------------------------------------------------------
plotOverlappingHist <- function(a, b, colors=c("white","gray20","gray50"),
                            breaks=NULL, xlim=NULL, ylim=NULL){

  ahist=NULL
  bhist=NULL

  if(!(is.null(breaks))){
    ahist=hist(a,breaks=breaks,plot=F)
    bhist=hist(b,breaks=breaks,plot=F)
  } else {
    ahist=hist(a,plot=F)
    bhist=hist(b,plot=F)

    dist = ahist$breaks[2]-ahist$breaks[1]
    breaks = seq(min(ahist$breaks,bhist$breaks),max(ahist$breaks,bhist$breaks),dist)

    ahist=hist(a,breaks=breaks,plot=F)
    bhist=hist(b,breaks=breaks,plot=F)
  }

  if(is.null(xlim)){
    xlim = c(min(ahist$breaks,bhist$breaks),max(ahist$breaks,bhist$breaks))
  }

  if(is.null(ylim)){
    ylim = c(0,max(ahist$counts,bhist$counts))
  }

  overlap = ahist
  for(i in 1:length(overlap$counts)){
    if(ahist$counts[i] > 0 & bhist$counts[i] > 0){
      overlap$counts[i] = min(ahist$counts[i],bhist$counts[i])
    } else {
      overlap$counts[i] = 0
    }
  }

  plot(ahist, xlim=xlim, ylim=ylim, col=colors[1])
  plot(bhist, xlim=xlim, ylim=ylim, col=colors[2], add=T)
  plot(overlap, xlim=xlim, ylim=ylim, col=colors[3], add=T)
} a = rnorm(10000,5)
b = rnorm(10000,3)
plotOverlappingHist(a,b) a=rnorm(1000, 3, 1)
b=rnorm(1000, 6, 1)
hist(a, xlim=c(0,10), col="red")
hist(b, add=T, col=rgb(0, 1, 0, 0.5)
-------------------------------------------------------------------------------------------------------
hist(rbinom(1000,2000,0.0001),breaks=function(x) length(unique(x)))
-------------------------------------------------------------------------------------------------------
x <- rbinom(1000, 2000, 0.001)
tmp <- hist(x, breaks=0:(max(x)+1), xaxt="n", right=FALSE, freq=FALSE)
axis(1, at=tmp$mids, labels=0:max(x))
-------------------------------------------------------------------------------------------------------
x <- rbinom(10000, 20000, 0.0001)
hist(x, br = seq(-0.01, max(x)+1, 1), freq=F, col="black") col="black"
-------------------------------------------------------------------------------------------------------
## create a plot
x <- rnorm(100,0,1)
hist(x, col="light blue")

## save plot as temp file
png(filename="temp.png", width=500, height=500)
print(p)
dev.off()

## read temp file as a binary string
plot_binary <- paste(readBin("temp.png", what="raw", n=1e6), collapse="")
-------------------------------------------------------------------------------------------------------
## generate some random data
carrotLengths <- rnorm(1000,15,5)
cucumberLengths <- rnorm(200,20,7)
## calculate the histograms - don't plot yet
histCarrot <- hist(carrotLengths,plot = FALSE)
histCucumber <- hist(cucumberLengths,plot = FALSE)
## calculate the range of the graph
xlim <- range(histCucumber$breaks,histCarrot$breaks)
ylim <- range(0,histCucumber$intensities,
              histCarrot$intensities)
## plot the first graph
plot(histCarrot,xlim = xlim, ylim = ylim,
     col = rgb(1,0,0,0.4),xlab = 'Lengths',
     freq = FALSE, ## relative, not absolute frequency
     main = 'Distribution of carrots and cucumbers')
## plot the second graph on top of this
opar <- par(new = FALSE)
plot(histCucumber,xlim = xlim, ylim = ylim,
     xaxt = 'n', yaxt = 'n', ## don't add axes
     col = rgb(0,0,1,0.4), add = TRUE,
     freq = FALSE) ## relative, not absolute frequency
## add a legend in the corner
legend('topleft',c('Carrots','Cucumbers'),
       fill = rgb(1:0,0,0:1,0.4), bty = 'n',
       border = NA)
par(opar) hist
-------------------------------------------------------------------------------------------------------
plotOverlappingHist <- function(a, b, colors=c("white","gray20","gray50"),
                                breaks=NULL, xlim=NULL, ylim=NULL){

  ahist=NULL
  bhist=NULL

  if(!(is.null(breaks))){
    ahist=hist(a,breaks=breaks,plot=F)
    bhist=hist(b,breaks=breaks,plot=F)
  } else {
    ahist=hist(a,plot=F)
    bhist=hist(b,plot=F)

    dist = ahist$breaks[2]-ahist$breaks[1]
    breaks = seq(min(ahist$breaks,bhist$breaks),max(ahist$breaks,bhist$breaks),dist)

    ahist=hist(a,breaks=breaks,plot=F)
    bhist=hist(b,breaks=breaks,plot=F)
  }

  if(is.null(xlim)){
    xlim = c(min(ahist$breaks,bhist$breaks),max(ahist$breaks,bhist$breaks))
  }

  if(is.null(ylim)){
    ylim = c(0,max(ahist$counts,bhist$counts))
  }

  overlap = ahist
  for(i in 1:length(overlap$counts)){
    if(ahist$counts[i] > 0 & bhist$counts[i] > 0){
      overlap$counts[i] = min(ahist$counts[i],bhist$counts[i])
    } else {
      overlap$counts[i] = 0
    }
  }

  plot(ahist, xlim=xlim, ylim=ylim, col=colors[1])
  plot(bhist, xlim=xlim, ylim=ylim, col=colors[2], add=T)
  plot(overlap, xlim=xlim, ylim=ylim, col=colors[3], add=T)
} a=rnorm(1000, 3, 1)
b=rnorm(1000, 6, 1)
hist(a, xlim=c(0,10), col="red")
hist(b, add=T, col=rgb(0, 1, 0, 0.5) )
-------------------------------------------------------------------------------------------------------
set.seed(42)
p1 <- hist(rnorm(500,4))                     # centered at 4
p2 <- hist(rnorm(500,6))                     # centered at 6
plot( p1, col=rgb(0,0,1,1/4), xlim=c(0,10))  # first histogram
plot( p2, col=rgb(1,0,0,1/4), xlim=c(0,10), add=T)  # second
-------------------------------------------------------------------------------------------------------
sendMessage<-function(contents,subject,from,to,attMIME,attachment,control){    
   msg<-list(contents,sendmailR:::.file_attachment(attachment,attachment,attMIME));
   sendmail(from=from,to=to,subject=subject,msg=msg,control=control);
} png('a.png');hist(rnorm(700));dev.off()
sendMessage('Here you have a nice histogram:',
'Nice picture',
'from@example.com',
'to@example.com',
'image/png',
'a.png',list(smtpServer="..."))
-------------------------------------------------------------------------------------------------------
c <- 1
d <- 2

a <- -2
b <- 3.5

ll <- pnorm(a, c, d)
ul <- pnorm(b, c, d)

x <- qnorm( runif(3000, ll, ul), c, d )
hist(x)
range(x)
mean(x)
sd(x)
plot(x, type='l') library(distr)

N <- Norm(c,d)
N2 <- Truncate(N, lower=a, upper=b)

plot(N2)
x <- r(N2)(3000)
hist(x)
range(x)
mean(x)
sd(x)
plot(x, type='l') plot( rnorm(3000, c, d), ylim=c(a,b) )
-------------------------------------------------------------------------------------------------------
library(ggplot2)
dfr <- data.frame(x = rlnorm(100, sdlog = 3))
ggplot(dfr, aes(x)) + geom_histogram() + scale_x_log10() h <- hist(log10(dfr$x), axes = FALSE) 
Axis(side = 2)
Axis(at = h$breaks, labels = 10^h$breaks, side = 1) library(lattice)
histogram(~x, dfr, scales = list(x = list(log = TRUE))) hist(dfr$x) hist log hist(dfr$x, log = "y") par(xlog = TRUE)
hist(dfr$x) hist(log10(dfr$x))
-------------------------------------------------------------------------------------------------------
x <- c(rexp(1000,0.5)+0.5,rexp(100,0.5)*100)

breaks<- c(0,0.1,0.2,0.5,1,2,5,10,20,50,100,200,500,1000,10000)
major <- c(0.1,1,10,100,1000,10000)


H <- hist(log10(x),plot=F)


plot(H$mids,H$counts,type="n",
      xaxt="n",
      xlab="X",ylab="Counts",
      main="Histogram of X",
      bg="lightgrey"
)
abline(v=log10(breaks),col="lightgrey",lty=2)
abline(v=log10(major),col="lightgrey")
abline(h=pretty(H$counts),col="lightgrey")
plot(H,add=T,freq=T,col="blue")
#Position of ticks
at <- log10(breaks)

#Creation X axis
axis(1,at=at,labels=10^at) ?par
-------------------------------------------------------------------------------------------------------
d<-rgamma(100,5,1.5) # sample
z<-hist(d,plot=FALSE) # make histogram, i.e., divide into bins and count up
co<-z$counts # original counts of each bin
z$counts<-z$counts*z$mids # scaled by mids of the bin

plot(z, xlim=c(0,10),ylim=c(0,max(z$counts))) # plot scaled histogram
par(new=T)
plot(z$mids,co,col=2,  xlim=c(0,10),ylim=c(0,max(z$counts))) # overplot original counts d<-rgamma(100,5,1.5)
z<-hist(d,plot=FALSE)
co<-z$counts # original counts of each bin
z$counts<-aggregate(d,list(cut(d,z$breaks)),sum)$x # sum up the value of data in each bin

plot(z, xlim=c(0,10),ylim=c(0,max(z$counts))) # plot scaled histogram
par(new=T)
plot(z$mids,co,col=2,  xlim=c(0,10),ylim=c(0,max(z$counts))) # overplot original counts
-------------------------------------------------------------------------------------------------------
# Generate some dummy data
datapoints <- runif(10000, 0, 100)

par (mfrow = c(2,2))

# We will plot 4 histograms, with different bin size
binsize <- c(1, 5, 10, 20)

for (bs in binsize)
    {
    # Plot the histogram. Hide the axes by setting axes=FALSE
    h <- hist(datapoints, seq(0, 100, bs), col="black", axes=FALSE, 
        xlab="", ylab="", main=paste("Bin size: ", bs))
    # Plot the x axis without modifying it
    axis(1)
    # This will NOT plot the axis (lty=0, labels=FALSE), but it will return the tick values
    yax <- axis(2, lty=0, labels=FALSE)
    # Plot the axis by appropriately scaling the tick values
    axis(2, at=yax, labels=yax/bs)
    }
-------------------------------------------------------------------------------------------------------
hist(test.csv[test.csv$c_pct > 20 | test.csv$c < 200, "a_pct"]) | ||
-------------------------------------------------------------------------------------------------------
with( test.csv, hist( a_pct[ c_pct > 20 ] ) )
-------------------------------------------------------------------------------------------------------
hist(subset(test.csv, c_pct > 20 | c < 200, select=a_pct))
-------------------------------------------------------------------------------------------------------
ggplot2 data <- as.data.frame(data)
d1 <- density(data$gest[which(data$season==1)], na.rm=TRUE)
d2 <- density(data$gest[which(data$season==2)], na.rm=TRUE)
plot(d1, ylim=c(0, max(d1$y,d2$y)), xlim=range(c(d1$x, d2$x)),
  main="Length of gestation", xlab="Length (days)", col="blue", lwd=2)
polygon(d1$x, d1$y, col=rgb(0, 0, 1, 0.5), lty=0)
points(d2, t="l", col="red", lwd=2)
polygon(d2$x, d2$y, col=rgb(1, 0, 0, 0.5), lty=0) densityplot lattice hist(data$gest[which(data$season==1)], main="Length of gestation", 
    xlab="Length (days)", col=rgb(0, 0, 1, 0.5))
# Note the add=TRUE parameter to superimpose the histograms
hist(data$gest[which(data$season==2)], col=rgb(1, 0, 0, 0.5), add=TRUE)
-------------------------------------------------------------------------------------------------------
hist(a, breaks=c(0, 1, 2, 3), freq=FALSE, right=FALSE)
-------------------------------------------------------------------------------------------------------
help(par) mar oma par(mar=c(5,3,1,1))   # extra large bottom margin
hist(vector, axes = FALSE, breaks = chartBreaks)
axis(1, at = tickMarks, labels = eventTypes, las = 2, tick = FALSE)
-------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------
set.seed(123)    
png("Test.png")
ht=hist(rpois(20,1), plot=FALSE, breaks=0:10-0.1)  
# better to offset to include discrete counts that would otherwise be at boundaries
 plot(round(ht$breaks),  dpois( round(ht$breaks),   # plot a Poisson density
         mean(ht$counts*round(ht$breaks[-length(ht$breaks)]))), 
         ylim=c(0, max(ht$density)+.1) , type="l")
 plot(ht, freq=FALSE, add=TRUE)   # plot the histogram
 dev.off()
-------------------------------------------------------------------------------------------------------
hist lines duration <- rpois(500, 10) # For duration data I assume Poisson distributed
hist(duration,probability = TRUE,breaks = "FD",col = "darkslategray4", border = "seashell3")
lines(density(duration - 0.5),   # Add the kernel density estimate (-.5 fix for the bins)
   col = "firebrick2", lwd = 3) density > density(duration)

Call:
        density.default(x = duration)

Data: duration (500 obs.);      Bandwidth 'bw' = 0.7752

       x                 y            
 Min.   : 0.6745   Min.   :1.160e-05  
 1st Qu.: 7.0872   1st Qu.:1.038e-03  
 Median :13.5000   Median :1.932e-02  
 Mean   :13.5000   Mean   :3.895e-02  
 3rd Qu.:19.9128   3rd Qu.:7.521e-02  
 Max.   :26.3255   Max.   :1.164e-01 ?bw.nrd
-------------------------------------------------------------------------------------------------------
curve(insert_function_here)
boundsc=par("usr")
ht=hist(A[,1],20,plot=FALSE)
par(usr=c(boundsc[1:2],0,max(boundsc[4],max(ht$counts))))
plot(ht,add=TRUE)
-------------------------------------------------------------------------------------------------------
set.seed(1001)
tmpf <- function() {
  duration <- rpois(500, 10) # For duration data I assume Poisson distributed
  hist(duration,probability = TRUE,breaks = "FD",col = "darkslategray4", border = "seashell3",main="",ann=FALSE,axes=FALSE,xlim=c(0,25),ylim=c(0,0.15))
  box()
  lines(density(duration),   # Add the kernel density estimate
        col = "firebrick2", lwd = 3)
  par(new=TRUE)
  plot(table(factor(duration,levels=0:25))/length(duration),
       xlim=c(0,25),ylim=c(0,0.15),col=4,ann=FALSE,axes=FALSE)
}

par(mfrow=c(3,3),mar=rep(0,4))
replicate(9,tmpf())
-------------------------------------------------------------------------------------------------------
N <- 1e+4
out <- replicate(N, mean(2^rgeom(1000, .5))) hist(out) hist(log(out))
-------------------------------------------------------------------------------------------------------
import random 
import networkx as nx
z=[int(random.gammavariate(alpha=9.0,beta=2.0)) for i in range(100)]
G=nx.configuration_model(z) Notes
-----
As described by Newman [1]_.

A non-graphical degree sequence (not realizable by some simple
graph) is allowed since this function returns graphs with self
loops and parallel edges.  An exception is raised if the degree
sequence does not have an even sum.

This configuration model construction process can lead to
duplicate edges and loops.  You can remove the self-loops and
parallel edges (see below) which will likely result in a graph
that doesn't have the exact degree sequence specified.  This
"finite-size effect" decreases as the size of the graph increases.

References
----------
.. [1] M.E.J. Newman, "The structure and function
       of complex networks", SIAM REVIEW 45-2, pp 167-256, 2003.

Examples
--------
>>> from networkx.utils import powerlaw_sequence
>>> z=nx.create_degree_sequence(100,powerlaw_sequence)
>>> G=nx.configuration_model(z)

To remove parallel edges:

>>> G=nx.Graph(G)

To remove self loops:

>>> G.remove_edges_from(G.selfloop_edges()) #!/usr/bin/env python
import random
import matplotlib.pyplot as plt
import networkx as nx

def seq(n):
    return [random.gammavariate(alpha=2.0,beta=1.0) for i in range(100)]    
z=nx.create_degree_sequence(100,seq)
nx.is_valid_degree_sequence(z)
G=nx.configuration_model(z)  # configuration model

degree_sequence=sorted(nx.degree(G).values(),reverse=True) # degree sequence
print "Degree sequence", degree_sequence
dmax=max(degree_sequence)

plt.hist(degree_sequence,bins=dmax)
plt.title("Degree histogram")
plt.ylabel("count")
plt.xlabel("degree")

# draw graph in inset 
plt.axes([0.45,0.45,0.45,0.45])
Gcc=nx.connected_component_subgraphs(G)[0]
pos=nx.spring_layout(Gcc)
plt.axis('off')
nx.draw_networkx_nodes(Gcc,pos,node_size=20)
nx.draw_networkx_edges(Gcc,pos,alpha=0.4)

plt.savefig("degree_histogram.png")
plt.show()
-------------------------------------------------------------------------------------------------------
sm require(sm)
foo <- data.frame(Return=rpois(100,5))
foo$density <- sm.density(foo$Return,eval.points=foo$Return)$estimate
# the plot
id <- order(foo$Return)
hist(foo$Return,freq=F)
lines(foo$Return[id],foo$density[id],col="red") foo$counts <- ave(foo$Return,foo$Return,FUN=length) plot(density(foo$Return)) freq=F hist(foo$Return,freq=F)
lines(density(foo$Return),col="red")
-------------------------------------------------------------------------------------------------------
density: the density of shading lines, in lines per inch.  The default
          value of ‘NULL’ means that no shading lines are drawn.
          Non-positive values of ‘density’ also inhibit the drawing of
          shading lines.

pie(c(1,2,3),density=c(1,2,20))

hist(runif(200),density=c(10,20,30))
-------------------------------------------------------------------------------------------------------
hist( rlnorm(1000, log(130) ), breaks=seq(0, 3000, by=200), xlim=c(0,2100) , axes=FALSE)
axis(1, at=seq(0 , 2000, by=200) axis(1, at=seq(0 , 2000, by=200) , las=2)
-------------------------------------------------------------------------------------------------------
set.seed(2); x <- rlnorm(1000, log(130))
hist(x, breaks=seq(0, 3000, by=200), xlim=c(0,2100), xaxt="n")

axis(1, at=c(0,2100), labels=c("",""), lwd.ticks=0)
axis(1, at=seq(0 , 2000, by=200), lwd=0, lwd.ticks=1)
-------------------------------------------------------------------------------------------------------
hist( measurements$social ) stand = scale( measurements$l.hand - measurements$r.hand )
m <- lm( measurements$social ~ stand )
m
summary(m)
anova(m) plot(m)
-------------------------------------------------------------------------------------------------------
rsn sn rsn(n=100, location=1.256269, scale=1.605681, shape=5) n hist(rsn(n=10000, location=1.256269, scale=1.605681, shape=5))
-------------------------------------------------------------------------------------------------------
require(SuppDists)

## make a weird dist with Kurtosis and Skew
a <- rnorm( 5000, 0, 2 )
b <- rnorm( 1000, -2, 4 )
c <- rnorm( 3000,  4, 4 )
babyGotKurtosis <- c( a, b, c )
hist( babyGotKurtosis , freq=FALSE)

## Fit a Johnson distribution to the data
## TODO: Insert Johnson joke here
parms<-JohnsonFit(babyGotKurtosis, moment="find")

## Print out the parameters 
sJohnson(parms)

## add the Johnson function to the histogram
plot(function(x)dJohnson(x,parms), -20, 20, add=TRUE, col="red") moment="quant" parms<-JohnsonFit(babyGotKurtosis, moment="quant")
plot(function(x)dJohnson(x,parms), -20, 20, add=TRUE, col="red")
-------------------------------------------------------------------------------------------------------
TkBuildDist <- function(  x=seq(min+(max-min)/nbin/2,
                                max-(max-min)/nbin/2,
                                length.out=nbin),
                          min=0, max=10, nbin=10, logspline=TRUE,
                          intervals=FALSE) {

    if(logspline) logspline <- require(logspline)
    require(tkrplot)

    xxx <- x

    brks <- seq(min, max, length.out=nbin+1)
    nx <- seq( min(brks), max(brks), length.out=250 )

    lx <- ux <- 0
    first <- TRUE

    replot <- if(logspline) {
        if(intervals) {
            function() {
                hist(xxx, breaks=brks, probability=TRUE,xlab='', main='')
                xx <- cut(xxx, brks, labels=FALSE)
                fit <- oldlogspline( interval = cbind(brks[xx], brks[xx+1]) )
                lines( nx, doldlogspline(nx,fit), lwd=3 )
                if(first) {
                    first <<- FALSE
                    lx <<- grconvertX(min, to='ndc')
                    ux <<- grconvertX(max, to='ndc')
                }
            }
        } else {
            function() {
                hist(xxx, breaks=brks, probability=TRUE,xlab='', main='')
                fit <- logspline( xxx )
                lines( nx, dlogspline(nx,fit), lwd=3 )
                if(first) {
                    first <<- FALSE
                    lx <<- grconvertX(min, to='ndc')
                    ux <<- grconvertX(max, to='ndc')
                }
            }
        }
    } else {
        function() {
            hist(xxx, breaks=brks, probability=TRUE,xlab='',main='')
            if(first) {
                first <<- FALSE
                lx <<- grconvertX(min, to='ndc')
                ux <<- grconvertX(max, to='ndc')
            }
        }
    }

    tt <- tktoplevel()
    tkwm.title(tt, "Distribution Builder")

    img <- tkrplot(tt, replot, vscale=1.5, hscale=1.5)
    tkpack(img, side='top')

    tkpack( tkbutton(tt, text='Quit', command=function() tkdestroy(tt)),
           side='right')

    iw <- as.numeric(tcl('image','width',tkcget(img,'-image')))

    mouse1.down <- function(x,y) {
        tx <- (as.numeric(x)-1)/iw
        ux <- (tx-lx)/(ux-lx)*(max-min)+min
        xxx <<- c(xxx,ux)
        tkrreplot(img)
    }

    mouse2.down <- function(x,y) {
        if(length(xxx)) {
            tx <- (as.numeric(x)-1)/iw
            ux <- (tx-lx)/(ux-lx)*(max-min)+min
            w <- which.min( abs(xxx-ux) )
            xxx <<- xxx[-w]
            tkrreplot(img)
        }
    }

    tkbind(img, '<ButtonPress-1>', mouse1.down)
    tkbind(img, '<ButtonPress-2>', mouse2.down)
    tkbind(img, '<ButtonPress-3>', mouse2.down)

    tkwait.window(tt)

    out <- list(x=xxx)
    if(logspline) {
        if( intervals ) {
            xx <- cut(xxx, brks, labels=FALSE)
            out$logspline <- oldlogspline( interval = cbind(brks[xx], brks[xx+1]) )
        } else {
            out$logspline <- logspline(xxx)
        }
    }

    if(intervals) {
        out$intervals <- table(cut(xxx, brks))
    }

    out$breaks <- brks

    return(out)
} TkBuildDist2 <- function( min=0, max=1, nbin=10, logspline=TRUE) {
    if(logspline) logspline <- require(logspline)
    require(tkrplot)

    xxx <- rep( 1/nbin, nbin )

    brks <- seq(min, max, length.out=nbin+1)
    nx <- seq( min, max, length.out=250 )

    lx <- ux <- ly <- uy <- 0
    first <- TRUE

    replot <- if(logspline) {
        function() {
            barplot(xxx, width=diff(brks), xlim=c(min,max), space=0,
                    ylim=c(0,0.5), col=NA)
            axis(1,at=brks)
            xx <- rep( 1:nbin, round(xxx*100) )
            capture.output(fit <- oldlogspline( interval = cbind(brks[xx], brks[xx+1]) ))
            lines( nx, doldlogspline(nx,fit)*(max-min)/nbin, lwd=3 )

            if(first) {
                first <<- FALSE
                lx <<- grconvertX(min, to='ndc')
                ly <<- grconvertY(0,   to='ndc')
                ux <<- grconvertX(max, to='ndc')
                uy <<- grconvertY(0.5, to='ndc')
            }
        }
    } else {
        function() {
            barplot(xxx, width=diff(brks), xlim=range(brks), space=0,
                    ylim=c(0,0.5), col=NA)
            axis(at=brks)
            if(first) {
                first <<- FALSE
                lx <<- grconvertX(min, to='ndc')
                ly <<- grconvertY(0,   to='ndc')
                ux <<- grconvertX(max, to='ndc')
                uy <<- grconvertY(0.5, to='ndc')
            }
        }
    }

    tt <- tktoplevel()
    tkwm.title(tt, "Distribution Builder")

    img <- tkrplot(tt, replot, vscale=1.5, hscale=1.5)
    tkpack(img, side='top')

    tkpack( tkbutton(tt, text='Quit', command=function() tkdestroy(tt)),
           side='right')

    iw <- as.numeric(tcl('image','width',tkcget(img,'-image')))
    ih <- as.numeric(tcl('image','height',tkcget(img,'-image')))



    md <- FALSE

    mouse.move <- function(x,y) {
        if(md) {
            tx <- (as.numeric(x)-1)/iw
            ty <- 1-(as.numeric(y)-1)/ih

            w <- findInterval(tx, seq(lx,ux, length=nbin+1))

            if( w > 0 && w <= nbin && ty >= ly && ty <= uy ) {
                 xxx[w] <<- 0.5*(ty-ly)/(uy-ly)
                xxx[-w] <<- (1-xxx[w])*xxx[-w]/sum(xxx[-w])

                tkrreplot(img)
            }
        }
    }

    mouse.down <- function(x,y) {
        md <<- TRUE
        mouse.move(x,y)
    }

    mouse.up <- function(x,y) {
        md <<- FALSE
    }

    tkbind(img, '<Motion>', mouse.move)
    tkbind(img, '<ButtonPress-1>', mouse.down)
    tkbind(img, '<ButtonRelease-1>', mouse.up)

    tkwait.window(tt)

    out <- list(breaks=brks, probs=xxx)
    if(logspline) {
        xx <- rep( 1:nbin, round(xxx*100) )
        out$logspline <- oldlogspline( interval = cbind(brks[xx], brks[xx+1]) )
    }

    return(out)
}
-------------------------------------------------------------------------------------------------------
set.seed(1)
randomData <- c(rnorm(100, 5, 3), rnorm(100, 20, 3) )
hist(randomData, freq=FALSE)
lines(density(randomData), col="red") bw <- density(randomData)$bw
resample <- sample( randomData, 10000, replace=TRUE) noise <- rnorm(10000, 0, bw)
hist(resample + noise, freq=FALSE)
lines(density(randomData), col="red")
-------------------------------------------------------------------------------------------------------
melt reshape2 cast as.POSIXlt(your.unix.timestamps, origin="1970-01-01", tz="GMT") format # original data
data.timestamps = c(1297977452, 1297977452, 1297977453, 1297977454, 1297977454, 1297977454, 1297977455, 1297977455)
data.unique.timestamps = unique(data.timestamps)

# get the labels
data.labels = format(as.POSIXlt(data.unique.timestamps, origin="1970-01-01", tz="GMT"), "%H:%M:%S")

# plot the histogram without axes
hist(data.timestamps, axes=F)

# add axes manually
axis(2)
axis(1, at=unique(data.timestamps), labels=data.labels)
-------------------------------------------------------------------------------------------------------
a <- list.files("F:.../4hrs", pattern='.csv') list.files a .csv pltList <- list()
i=1

for (x in a) {


 myfiles <- read.csv(a, header=TRUE, as.is=TRUE, nrows=2500) a x a x read.csv(x,... for (i in 1:length(a)) a[i] h <- hist(data, plot=F) data h # perform analysis, ect.

    pltName <- paste('a', formatC(i, width=2, flag='0'), sep='')
    pltList[[ pltName ]] <- plot(h)
    i <- i+1
  } myfiles h
-------------------------------------------------------------------------------------------------------
library(lattice)
histogram(~x2|equal.count(x1),data=frame) shingle equal.count par(mfrow=c(2,1))
hist(x2)
boxplot(x2) layout()
-------------------------------------------------------------------------------------------------------
> claim <- c(15000000, rexp(99999, rate = 1/400)^1.76) 
> summary(claim)
    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. 
       0     4261    20080    61730    67790 15000000 
> 
> hs    <- 100000     # highest value to show on histogram
> br    <- 10         # number of bars to show on histogram
> 
> hist(claim, xlim = c(0,hs), freq = FALSE, breaks = br*max(claim)/hs, col='red')
> 
> length(claim[claim<hs]) / length(claim) #proportion of claims shown
[1] 0.82267
> sum(claim[claim<hs])    / sum(claim)    #proportion of value shown
[1] 0.3057994 hist
-------------------------------------------------------------------------------------------------------
hist(test$adj_unl_claim[test$adj_unl_claim < 100000]) hist(log(test$adj_unl_claim))
-------------------------------------------------------------------------------------------------------
k<-hist(gb2_agg$adj_unl_claim,prob=TRUE,breaks=100000)
k$counts<-k$counts/sum(k$counts)
plot(k,ylim=c(0,.02),xlim-c(0,50000),col='blue')
-------------------------------------------------------------------------------------------------------
library(rimage)
x <- read.jpeg(system.file("data", "cat.jpg", package="rimage"))
par(mfrow=c(1,3))
hist(x[,,1])
hist(x[,,2])
hist(x[,,3])
-------------------------------------------------------------------------------------------------------
nbins library(ggplot2) #using version 0.8.8
x1 <- c(rnorm(100,8,4), rnorm(100, 2,2), rnorm(100,0,10))
x2 <- c(rlnorm(1000),rnorm(1000,1,10), rep(1,500), rep(5,500))
ggplot() + 
  geom_step(aes(x1, y =..density..),
            stat = 'bin',breaks = dhist(x1, nbins =20),
            position = "dodge", color = 'red') +
  geom_step(aes(x2, y =..density..),
            stat = 'bin',breaks = dhist(x2,nbins=20),
            position = "dodge", color = 'blue')
-------------------------------------------------------------------------------------------------------
dat[!is.na(dat$test_score),]
hist(dat$test_score[dat$Teachers=='Jones']) # Create artificial dataset
dat <- data.frame('test_score'=rnorm(500), 'Teachers'=sample(c('Jones', 'Smith', 'Clark'), 500, replace=TRUE))   

# Introduce some random missingness
dat$test_score[sample(1:500, 50)] <- NA  

# Keep if test_score is valid                                                                      
dat.nomissing <- dat[!is.na(dat$test_score),]   

# Plot subset of data                                          
 hist(dat$test_score[dat$Teachers=='Jones'])
-------------------------------------------------------------------------------------------------------
hist buckets <- c(0,1,2,3,4,5,25)
mydata_hist <- hist(mydata$V3, breaks=buckets, plot=FALSE)
bp <- barplot(mydata_hist$count, log="y", col="white", names.arg=buckets)
text(bp, mydata_hist$counts, labels=mydata_hist$counts, pos=1) main xlab ylab
-------------------------------------------------------------------------------------------------------
hist(dat, breaks="hours", freq=TRUE, col = "red", axes = FALSE)
axis.POSIXct(side = 1, dat)
axis(2)
-------------------------------------------------------------------------------------------------------
hist(Data, breaks="hours", freq=T, xlab="Time", col="red",main="Sat  Volume",axes=F)
Axis(Data,col="black",side=1)
axis(2,col="black") Axis() axis() DateTime hist()
-------------------------------------------------------------------------------------------------------
set.seed(100)

x = rnorm(100, mean = 5, sd = 2)

res = hist(x)

res$mids[which.max(res$counts)]

[1] 4.5
-------------------------------------------------------------------------------------------------------
matplotlib hist()
-------------------------------------------------------------------------------------------------------
hist(data)
-------------------------------------------------------------------------------------------------------
set.seed(1)
dat2 <- data.frame(fac = factor(sample(LETTERS, 100, replace = TRUE)))
hist(table(dat2), xlab = "Frequency of Level Occurrence", main = "") hist() table(dat) table(dat) hist() dat <- data.frame(fac = rep(LETTERS[1:4], times = c(3,3,1,5))) "table" layout(matrix(1:4, ncol = 2))
plot(table(dat), main = "plot method for class \"table\"")
barplot(table(dat), main = "barplot")
tab <- as.numeric(table(dat))
names(tab) <- names(table(dat))
dotchart(tab, main = "dotchart or dotplot")
## or just this
## dotchart(table(dat))
## and ignore the warning
layout(1) factor table(factor) table(dat) table(dat$fac) lattice require(lattice)
with(dat, dotplot(fac, horizontal = FALSE)) ggplot2 require(ggplot2)
p <- ggplot(data.frame(Freq = tab, fac = names(tab)), aes(fac, Freq)) + 
    geom_point()
p
-------------------------------------------------------------------------------------------------------
list_histo <- hist(list, breaks=length(list), freq=TRUE) list_histo $breaks
[1] 0.40 0.42 0.44 0.46 0.48 0.50 0.52 0.54 0.56 0.58 0.60 0.62 0.64 0.66 0.68
[16] 0.70 0.72 0.74 0.76

$counts
[1]      1     15    112    878   4734  17995  51094 110146 178855 216454
[11] 194536 130591  64218  23017   6117   1070    144     23

$intensities
[1]  0.00005  0.00075  0.00560  0.04390  0.23670  0.89975  2.55470  5.50730
[9]  8.94275 10.82270  9.72680  6.52955  3.21090  1.15085  0.30585  0.05350
[17]  0.00720  0.00115

$density
[1]  0.00005  0.00075  0.00560  0.04390  0.23670  0.89975  2.55470  5.50730
[9]  8.94275 10.82270  9.72680  6.52955  3.21090  1.15085  0.30585  0.05350
[17]  0.00720  0.00115

$mids
[1] 0.41 0.43 0.45 0.47 0.49 0.51 0.53 0.55 0.57 0.59 0.61 0.63 0.65 0.67 0.69
[16] 0.71 0.73 0.75

$xname
[1] "list_histo"

$equidist
[1] TRUE

attr(,"class")
[1] "histogram" max(list_histo$counts)
-------------------------------------------------------------------------------------------------------
quantile runif obs <- c(125,110,115,100,150)             # original observations
sim <- quantile(obs, runif(10000))        # simulations
hist(sim, freq=FALSE)
-------------------------------------------------------------------------------------------------------
vectordata <- vectordatamax <- vectordatamin <- vectordev <- numeric(length(my_asc))
for (i in seq_along(my_asc)) {
  r <- readGDAL(my_asc[i])
  ## as.matrix is not necessary, as the band values are accessible directly
  ##z <- as.matrix(r)
  z <- r[[1]]
  vectordata[i] <- mean(z, na.rm=TRUE) 
  vectordatamax[i] <- max(z) 
  vectordatamin[i] <- min(z) 
  vectordev[i] <- sd(z, na.rm=TRUE) 
  png(filename=paste("hist", i, ".png", sep=""))
  hist(z)
  dev.off()
}
-------------------------------------------------------------------------------------------------------
x <- rpois(1000, 10)
tbl <- table(x)
plot(seq_along(tbl), unclass(tbl)) hist hist(x)
-------------------------------------------------------------------------------------------------------
x <- rnorm(1000)
y <- hist(x)
plot(y$breaks,
      c(y$counts,0)
   ,type="s",col="blue")
-------------------------------------------------------------------------------------------------------
set.seed(5)
d <- data.frame(x=c(rnorm(1000)+3, rnorm(1000)),
                g=rep(1:2, each=1000) ) x1 <- d$x[d$g==1]
x2 <- d$x[d$g==2]
y1 <- hist(x1, plot=FALSE)
y2 <- hist(x2, plot=FALSE)
plot(y1$breaks, c(y1$counts,0), type="s",col="blue",
     xlim=range(c(y1$breaks, y2$breaks)), ylim=range(c(0,y1$counts, y2$counts)))
points(y2$breaks, c(y2$counts,0), type="s", col="red") col <- c("blue", "red")
ds <- split(d$x, d$g)
hs <- lapply(ds, hist, plot=FALSE)
plot(0,0,type="n",
     ylim=range(c(0,unlist(lapply(hs, function(x) x$counts)))),
     xlim=range(unlist(lapply(hs, function(x) x$breaks))) )
for(i in seq_along(hs)) {
  points(hs[[i]]$breaks, c(hs[[i]]$counts,0), type="s", col=col[i])
} library(lattice)
densityplot(~x, group=g, data=d)
-------------------------------------------------------------------------------------------------------
# make data
wells <- c("LC","HC","BC")
Data <- data.frame(
    welltype=rep(wells,each=100),
    value=c(rnorm(100),rnorm(100,2),rnorm(100,3))
)

ggplot(Data,aes(value,fill=welltype)) + geom_density(alpha=0.2) # make hists dataframe
hists <- tapply(Data$value,Data$welltype,
            function(i){
              tmp <- hist(i)
              data.frame(br=tmp$breaks,co=c(tmp$counts,0))
            })
ll <- sapply(hists,nrow)
hists <- do.call(rbind,hists)
hists$fac <- rep(wells,ll)

# make plot
require(ggplot2)
qplot(br,co,data=hists,geom="step",colour=fac)
-------------------------------------------------------------------------------------------------------
spline() spline() List of 2
 $ x: num [1:93] -3.3 -3.23 -3.17 -3.1 -3.04 ...
 $ y: num [1:93] 1 0.1421 -0.1642 -0.0228 0.4294 ... h <- hist( d, breaks="FD", plot=F )
zz <- spline( h$mids, h$counts )
qplot(x, y, data = data.frame(x = zz$x, y = zz$y), geom = "line")
-------------------------------------------------------------------------------------------------------
ddply ddply <- = media.dia<- ddply(obs, .(day),summarise, daily.mean = mean(pp)) hist hist(media.dia$daily.mean,main=c("hist per day of month",codigo)) hist daily.mean
-------------------------------------------------------------------------------------------------------
b.true1 <- c(-1, 1, .8)
X1 <- cbind(rnorm(n, 1.5, 2), rnorm(n, -1, 1.3)) hist(predict(prob2,type="response"))
-------------------------------------------------------------------------------------------------------
ghyp gtools gdata numDeriv gplots Error: could not find function "fit.NIGuv" bitops fit.NIGuv() library(ghyp)
data(smi.stocks)
nig.fit <- fit.NIGuv(smi.stocks[,"SMI"], opt.pars = c(alpha.bar = FALSE),
                     alpha.bar = 1, control = list(abs.tol = 1e-8))
nig.fit
summary(nig.fit)
hist(nig.fit) Asymmetric Normal Inverse Gaussian Distribution:

Parameters:
    alpha.bar            mu         sigma         gamma 
 1.0000000000  0.0008370731  0.0112098776 -0.0007205143 

log-likelihood:
5495.705
-------------------------------------------------------------------------------------------------------
library(RGtk2)
library(cairoDevice)
w = gtkWindow()
da <- gtkDrawingArea()
asCairoDevice(da)
w <- gtkWindow(show=FALSE)
w$add(da)
w$show()
hist(rnorm(100))
w$resize(500, 500)
w$move(200,200)
-------------------------------------------------------------------------------------------------------
library(RGtk2)
library(cairoDevice)

da <- gtkDrawingArea()
asCairoDevice(da)
da$AddEvents(GdkEventMask["all-events-mask"])

w <- gtkWindow(show=FALSE)
w$add(da)
w$show()

hist(rnorm(100))

gSignalConnect(da, "motion-notify-event", function(w, e) {
  print(c(e$x, e$y))
  invisible(TRUE)
})
-------------------------------------------------------------------------------------------------------
#Generate the data
x <- c(rep(1, 200), rep(2, 30), rep(3, 50))

#Since the midpoints of each bucket will be used and the desired bucket width
#is 1, start the bucket breaks at -0.5
buc <- seq(-0.5, 5, 1)

#Get a histogram using the above bucket breaks
res <- hist(x, breaks=buc)

#Build a data frame with the results
df <- data.frame(mids=res$mids, counts=res$counts)
df

  mids counts
1    0      0
2    1    200
3    2     30
4    3     50
5    4      0 names hist names(res)

[1] "breaks"      "counts"      "intensities" "density"     "mids"        "xname"       "equidist"
-------------------------------------------------------------------------------------------------------
h<-hist(yourdata)
plot(h$mids,100*h$counts/sum(h$counts),type="h")
-------------------------------------------------------------------------------------------------------
hist(data)
abline(v=mean(data),col="blue")
-------------------------------------------------------------------------------------------------------
x <- rnorm(100)
mx <- mean(x)
hist(x)
abline(v = mx, col = "blue", lwd = 2) x <- rnorm(100, mean = 10)
mx <- mean(x)
hist(x)
lines( c(mx,mx), c(0,15), col = "red", lwd = 2)
lines(c(10, 11.5), c(0, 10), col = "steelblue", lwd = 3, lty = 22)
text(mx, 18 , round(mx, 2))
text(mx, 12 , "big", cex = 5)
-------------------------------------------------------------------------------------------------------
data <- c(1.22,-0.86,-1.35,-1.46,0.67,2.77,-0.50,0.34,-0.57,-0.05)
mean(data)
var(data)
plot(data)
plot(sort(data))
hist(data)
-------------------------------------------------------------------------------------------------------
weekdays(dat) ## days of the week
days <- c('Sun','Mon','Tues','Wed','Thurs','Fri','Sat')

## sample with replacement to generate data for this example
samples <- sample(days,100,replace=TRUE)

## convert to factor
## specify levels to specify the order
samples <- factor(samples,levels=days)

hist(unclass(samples),xaxt="n")
axis(1,at=1:nlevels(samples),lab=levels(samples))
box()
-------------------------------------------------------------------------------------------------------
dat <- as.Date( c("2010-04-02", "2010-04-06", "2010-04-09", "2010-04-10", "2010-04-14", 
       "2010-04-15", "2010-04-19",   "2010-04-21", "2010-04-22", "2010-04-23","2010-04-24", 
        "2010-04-25", "2010-04-26", "2010-04-28", "2010-04-29", "2010-04-30"))
 dwka <- format(dat , "%a")
 dwka
# [1] "Fri" "Tue" "Fri" "Sat" "Wed" "Thu" "Mon"
#  [8] "Wed" "Thu" "Fri" "Sat" "Sun" "Mon" "Wed"
# [15] "Thu" "Fri"
dwkn <- as.numeric( format(dat , "%w") ) # numeric version
hist( dwkn , breaks= -.5+0:7, labels= unique(dwka[order(dwkn)]))
-------------------------------------------------------------------------------------------------------
axis() graphics graphics > data <- log(rnorm(10000, 100, 10))  #simulate some data that looks like yours
> hist(data) # view a normal histogram of the data with log values on the x-axis
> tick_locations = c(4.2, 4.4, 4.6, 4.8, 5.0)  # copy the tick locations from the normal plot
> tick_labels = exp(tick_locations) # reverse the log transformation; you can also create this manually
> hist(data, xaxt = "n")  # plot without the x-axis
> axis(1, at = tick_locations, labels = tick_labels) # add the x-axis with the de-transformed values
-------------------------------------------------------------------------------------------------------
h<-hist(edat$energy,freq=F)
  h$counts <- h$counts/sum(h$counts)
  plot(h, ylab="Density")
-------------------------------------------------------------------------------------------------------
x <- runif(100)
quantile(x,probs=c(.025,.975)) qts <- quantile(x,probs=c(.05,.95))
hist(x)
abline(v=qts[1],col="red")
abline(v=qts[2],col="red")
-------------------------------------------------------------------------------------------------------
density() energy <- rnorm(100)
dens <- density(energy)
sum(dens$y)*diff(dens$x[1:2])
[1] 1.000952 density() probability=TRUE hist density() hist(energy,probability=TRUE)
lines(density(energy),col="red") x <- sample(letters[1:4],1000,replace=TRUE)
 prop.table(table(x))
x
    a     b     c     d 
0.244 0.262 0.275 0.219 count(x)/sum(count(x)) dnorm() x <- sort(rnorm(100,0,0.5))
h <- hist(x,plot=FALSE)
dens1 <-  h$counts/sum(h$counts)
dens2 <- dnorm(x,0,0.5)

hist(x,probability=TRUE,breaks="fd",ylim=c(0,1))
lines(h$mids,dens1,col="red")
lines(x,dens2,col="darkgreen") cdf <- cumsum(dens$y * diff(dens$x[1:2]))
cdf <- cdf / max(cdf) # to correct for the rounding errors
plot(dens$x,cdf,type="l")
-------------------------------------------------------------------------------------------------------
trial.group <- unique(AB[,c("trial","cond")])
hists <- dlply(AB, .(trial), function(x) {hist(x$spiketime, breaks=10, plot=FALSE)})
hists.avg <- ddply(trial.group, .(cond), function(x) {
  hist.group <- ldply(hists[x$trial], function(y) {
    data.frame(mids=y$mids, counts=y$counts)
  })
  ddply(hist.group, .(mids), summarise, counts=mean(counts))
})

ggplot(data=hists.avg, aes(x=mids, y=counts, colour=cond)) + geom_line() hist tmp <- as.data.frame(table(unique(AB[,c("trial","cond")])["cond"]))
names(tmp) <- c("cond","ntrial")
AB <- merge(AB, tmp)

ggplot(AB, aes(spiketime, ntrial=ntrial, colour=cond)) + 
  stat_bin(aes(y=..count../ntrial*1000/100), binwidth=100, geom="line", position="identity") +
  xlim(0,1000) + 
  labs(x='Milliseconds', y="Firing rate [times/s]")
-------------------------------------------------------------------------------------------------------
data("faithful", package = "datasets") 
x <- faithful$waiting 
opar <- par(mfcol= c(2,2))
for (bw in c(3,6,12,18) ) {
  hist(x, xlab = "Waiting interval", ylab = "Eruption Freq",probability = TRUE, main = "Density plot", border = "gray", sub= bquote("Bandwidth = "*.(bw) ) ) 
  lines(density(x, width = bw, window = "triangular"), lty=3, col="red")
  }
par(opar)
-------------------------------------------------------------------------------------------------------
set.seed(2)
dat <- rnorm(100, mean = 3, sd = 3) sdat <- summary(dat) paste() collapse summStr <- paste(names(sdat), format(sdat, digits = 2), collapse = "; ") format() title() op <- par(mar = c(7,4,4,2) + 0.1)
hist(dat)
title(sub = summStr, line = 5.5)
par(op) line
-------------------------------------------------------------------------------------------------------
hist tmp <- hist(...) tmp$counts tmp$counts / 2 mean(tmp$counts)
-------------------------------------------------------------------------------------------------------
hist( myMatrix[myMatrix > 0 & myMatrix < 1] )
-------------------------------------------------------------------------------------------------------
cut() > set.seed(42)
> cut(runif(50), 6)
 [1] (0.825,0.99]    (0.825,0.99]    (0.167,0.332]   (0.825,0.99]   
 [5] (0.496,0.661]   (0.496,0.661]   (0.661,0.825]   (0.00296,0.167]
 [9] (0.496,0.661]   (0.661,0.825]   (0.332,0.496]   (0.661,0.825]  
[13] (0.825,0.99]    (0.167,0.332]   (0.332,0.496]   (0.825,0.99]   
[17] (0.825,0.99]    (0.00296,0.167] (0.332,0.496]   (0.496,0.661]  
[21] (0.825,0.99]    (0.00296,0.167] (0.825,0.99]    (0.825,0.99]   
[25] (0.00296,0.167] (0.496,0.661]   (0.332,0.496]   (0.825,0.99]   
[29] (0.332,0.496]   (0.825,0.99]    (0.661,0.825]   (0.661,0.825]  
[33] (0.332,0.496]   (0.661,0.825]   (0.00296,0.167] (0.825,0.99]   
[37] (0.00296,0.167] (0.167,0.332]   (0.825,0.99]    (0.496,0.661]  
[41] (0.332,0.496]   (0.332,0.496]   (0.00296,0.167] (0.825,0.99]   
[45] (0.332,0.496]   (0.825,0.99]    (0.825,0.99]    (0.496,0.661]  
[49] (0.825,0.99]    (0.496,0.661]  
6 Levels: (0.00296,0.167] (0.167,0.332] (0.332,0.496] ... (0.825,0.99] cut() ?cut hist() > foo <- hist(runif(50), breaks = 6, plot = FALSE)
> str(foo)
List of 7
 $ breaks     : num [1:6] 0 0.2 0.4 0.6 0.8 1
 $ counts     : int [1:5] 12 13 7 13 5
 $ intensities: num [1:5] 1.2 1.3 0.7 1.3 0.5
 $ density    : num [1:5] 1.2 1.3 0.7 1.3 0.5
 $ mids       : num [1:5] 0.1 0.3 0.5 0.7 0.9
 $ xname      : chr "runif(50)"
 $ equidist   : logi TRUE
 - attr(*, "class")= chr "histogram" hist() cut() hist() > set.seed(42)
> x <- runif(50)
> brks <- pretty(range(x), n = 6, min.n = 1)
> cut(x, breaks = brks)
 [1] (0.8,1]   (0.8,1]   (0.2,0.4] (0.8,1]   (0.6,0.8] (0.4,0.6] (0.6,0.8]
 [8] (0,0.2]   (0.6,0.8] (0.6,0.8] (0.4,0.6] (0.6,0.8] (0.8,1]   (0.2,0.4]
[15] (0.4,0.6] (0.8,1]   (0.8,1]   (0,0.2]   (0.4,0.6] (0.4,0.6] (0.8,1]  
[22] (0,0.2]   (0.8,1]   (0.8,1]   (0,0.2]   (0.4,0.6] (0.2,0.4] (0.8,1]  
[29] (0.4,0.6] (0.8,1]   (0.6,0.8] (0.8,1]   (0.2,0.4] (0.6,0.8] (0,0.2]  
[36] (0.8,1]   (0,0.2]   (0.2,0.4] (0.8,1]   (0.6,0.8] (0.2,0.4] (0.4,0.6]
[43] (0,0.2]   (0.8,1]   (0.4,0.6] (0.8,1]   (0.8,1]   (0.6,0.8] (0.8,1]  
[50] (0.6,0.8]
Levels: (0,0.2] (0.2,0.4] (0.4,0.6] (0.6,0.8] (0.8,1]
-------------------------------------------------------------------------------------------------------
,freq=FALSE d <- rnorm(100)
hist(d,freq=FALSE)
-------------------------------------------------------------------------------------------------------
> many <- rnorm(1000)
> few <- rnorm(100)
> mh <- hist(many, plot=FALSE)
> fh <- hist(few, breaks=mh$breaks, plot=FALSE)
> ph <- fh
> ph$density <- fh$counts/(mh$counts+0.001) #you have to deal with a 0 denominator
> plot(ph,freq=FALSE)
-------------------------------------------------------------------------------------------------------
x = rnorm(1000)
hist(x, breaks = 30, freq = FALSE)
lines(density(x), col = "red")
-------------------------------------------------------------------------------------------------------
layout(matrix(c(1,2,5,6,3,4,7,8,9,10,13,14,11,12,15,16), 4, 4, byrow=TRUE))
replicate(16, hist(rnorm(100)))
par(xpd=NA)
rect( grconvertX(0.005, from='ndc'), grconvertY(0.505, from='ndc'),
     grconvertX(0.495, from='ndc'), grconvertY(0.995, from='ndc'))
rect( grconvertX(0.005, from='ndc'), grconvertY(0.005, from='ndc'),
     grconvertX(0.495, from='ndc'), grconvertY(0.495, from='ndc'))
rect( grconvertX(0.505, from='ndc'), grconvertY(0.505, from='ndc'),
     grconvertX(0.995, from='ndc'), grconvertY(0.995, from='ndc'))
rect( grconvertX(0.505, from='ndc'), grconvertY(0.005, from='ndc'),
     grconvertX(0.995, from='ndc'), grconvertY(0.495, from='ndc'))
-------------------------------------------------------------------------------------------------------
set.seed(123)
xpois <- trunc(rpois(100, 4))
hist(xpois)
lines(seq(0,10), 100*dpois(seq(0,10), 4))
-------------------------------------------------------------------------------------------------------
b<-seq(range(t1)[1],range(t1)[2],length.out=15) b<-seq(range(t1)[1],range(t1)[2],length.out=15)-10
h1<-hist(t1, breaks=b)
-------------------------------------------------------------------------------------------------------
h1 <- hist(t1,breaks=15)
plot(h1,xlim=c(0,200),col="red") h1 <- hist(t1,breaks=15)
plot(h1,xlim=c(-10,190),col="red")
-------------------------------------------------------------------------------------------------------
freq FALSE hist(rnorm(1000, 100, 50), freq="FALSE")
-------------------------------------------------------------------------------------------------------
hist( c(c(rs, rs+60*60*24, rs+2*60*60*24), breaks= 24*3 )
require(logspline)
?logspline
fit <- logspline(c(rs), lbound=0, ubound=60*60*24)
plot(fit)
-------------------------------------------------------------------------------------------------------
hist freq=FALSE > data_delay <- read.csv("PATH_TO_DATA_FILE")
> h <- hist(data_delay$delay, plot=F)
> h
$breaks
 [1] 0.000 0.005 0.010 0.015 0.020 0.025 0.030 0.035 0.040 0.045 0.050 0.055
[13] 0.060 0.065 0.070

[SNIP]

$density
 [1] 112.47892074  13.36706015   3.91231029   5.98088814  10.35413153
 [6]  11.21978640  11.80438449   6.55424396  14.14277684   2.63069140
[11]   5.53119730   1.31534570   0.69702080   0.01124227

[SNIP] > sum(h$density * 0.005)
[1] 1
-------------------------------------------------------------------------------------------------------
?hist breaks density histrv<-hist(x)
histrv$breaks
histrv$density
-------------------------------------------------------------------------------------------------------
hist histogram R> res <- hist(rnorm(100))
R> res
$breaks
[1] -4 -3 -2 -1  0  1  2  3  4

$counts
[1]  1  2 17 27 34 16  2  1

$intensities
[1] 0.01 0.02 0.17 0.27 0.34 0.16 0.02 0.01

$density
[1] 0.01 0.02 0.17 0.27 0.34 0.16 0.02 0.01

$mids
[1] -3.5 -2.5 -1.5 -0.5  0.5  1.5  2.5  3.5

$xname
[1] "rnorm(100)"

$equidist
[1] TRUE

attr(,"class")
[1] "histogram"
-------------------------------------------------------------------------------------------------------
tapply dat avgdata=tapply(dat$data,dat$user,FUN=mean)
hist(avgdata)
-------------------------------------------------------------------------------------------------------
user_mean = tapply(data, user, mean)
hist(user_mean, breaks = 30)
-------------------------------------------------------------------------------------------------------
set.seed(12345)
x = rnorm(1000)

hist.data = hist(x, plot=F)
hist.data$counts = log10(hist.data$counts)

dev.new(width=4, height=4)
hist(x)

dev.new(width=4, height=4)
plot(hist.data, ylab='log10(Frequency)')
-------------------------------------------------------------------------------------------------------
h <- hist(hplot$V1, plot=FALSE) h$counts <- h$counts/1e6 plot(h) hist(hplot$V1, freq=FALSE)
-------------------------------------------------------------------------------------------------------
#EXAMPLE
x<-rnorm(1000)
histogram <- hist(scale(x), breaks=20 , plot=FALSE)
plot(histogram, col=ifelse(abs(histogram$breaks) < 2, "red", "green"))
-------------------------------------------------------------------------------------------------------
data_sub <- subset(data, data$V1 == "Yes") #only samples that have V1 as "yes" in my dataset #are added to the subset

hist(data$HL)
hist(data_sub$HL, col="red", add=T)
-------------------------------------------------------------------------------------------------------
glm summary summary.glm abc abc abc:::summary.abc
abc:::plot.abc
abc:::hist.abc example(abc) abc lin2 abc str(lin2) lin2 lin2$adj.values
-------------------------------------------------------------------------------------------------------
# Simulate some data
set.seed(12345)
n.var = 400
n.obs = 200
data  = matrix(rnorm(n.var*n.obs), nrow=n.obs)

# Summarize data
breaks = seq(min(data), max(data), length.out=51)
histdata = apply(data, 2, function(x) hist(x, plot=F, breaks=breaks)$counts)

# Plot
dev.new(width=4, height=4)
image(1:n.var, breaks, t(histdata), xlab='Variable Index', ylab='Histogram Bin') hclust heatmap
-------------------------------------------------------------------------------------------------------
% ---------------------------------- 
\documentclass{article} %
\usepackage{Sweave} 
\SweaveOpts{echo=FALSE}

\newcommand\bloodp[3]{
  \subsection{Patient #1} For patient #1, the mean value of systolic pressure was #2~mmHg, the diastolic pressure was #3~mmHg. 
  \begin{figure}[!htb]% 
    \begin{center}% 
      \includegraphics{histo#1}%
      \caption{Histogram of systolic blood pressure for patient #1.}% 
      \label{fig:histo#1}% 
    \end{center}% 
  \end{figure}% 
  \clearpage % Better use FloatBarrier here 
}

\begin{document} 
\section{Blood Pressure}

<<results=tex>>= 
n=100 
dt = data.frame(
   subj=sample(1:3,n,TRUE), 
   syst=round(rnorm(n,120,10)),
   dia=round(rnorm(n,80,10))
   )
# could also use tapply here 
for (i in 1:3) { 
  dt1 = dt[dt$subj==i,] 
  cat("\\bloodp{",i,"}{", 
     round(mean(dt1$syst)),"}{", 
     round(mean(dt1$dia)),"}\n",sep="") 
   pdf(paste("histo",i,".pdf",sep="")) 
   hist(dt1$syst,main="",xlab="Blood pressure") 
   dev.off() } 
@

\end{document}
-------------------------------------------------------------------------------------------------------
# Simulate data
n.row = 100
n.col = 10

set.seed(12345)
group = factor(sample(2, n.row, replace=T))
data  = data.frame(matrix(rnorm(n.row*n.col), nrow=n.row)) # Re-calculate columnwise test statisitics many times while permuting class labels
perms = replicate(500, apply(data[sample(nrow(data)), ], 2, function(x) wilcox.test(x[group==1], x[group==2], exact=F, alternative="two.sided", correct=T)$stat)) # For each permuted replication, calculate the max test statistic across the multiple comparisons
perms.max = apply(perms, 2, max) # Identify critical value 
crit = sort(perms.max)[round((1-0.05)*length(perms.max))] # Plot 
dev.new(width=4, height=4)
hist(perms.max)
abline(v=crit, col='red') > length(which(perms.max>1600))/length(perms.max)
[1] 0.074
-------------------------------------------------------------------------------------------------------
degree.distribution degree.distribution graph.strength.distribution <- function (graph, cumulative = FALSE, ...)
{
  if (!is.igraph(graph)) {
    stop("Not a graph object")
  }
  # graph.strength() instead of degree()
  cs <- graph.strength(graph, ...)
  hi <- hist(cs, -1:max(cs), plot = FALSE)$density
  if (!cumulative) {
    res <- hi
  }
  else {
    res <- rev(cumsum(rev(hi)))
  }
  res
}
-------------------------------------------------------------------------------------------------------
hist(x) myhist(x) myhist(mydata$V3, breaks=c(0,1,2,3,4,5,25), log="xy") myhist <- function(x, ..., breaks="Sturges",
                   main = paste("Histogram of", xname),
                   xlab = xname,
                   ylab = "Frequency") {
  xname = paste(deparse(substitute(x), 500), collapse="\n")
  h = hist(x, breaks=breaks, plot=FALSE)
  plot(h$breaks, c(NA,h$counts), type='S', main=main,
       xlab=xlab, ylab=ylab, axes=FALSE, ...)
  axis(1)
  axis(2)
  lines(h$breaks, c(h$counts,NA), type='s')
  lines(h$breaks, c(NA,h$counts), type='h')
  lines(h$breaks, c(h$counts,NA), type='h')
  lines(h$breaks, rep(0,length(h$breaks)), type='S')
  invisible(h)
}
-------------------------------------------------------------------------------------------------------
plot(1:10,1:10,type = "n")
grid(10,10)
hist(rnorm(100,5,1),add = TRUE) type = "n" plot add = TRUE add plot.histogram hist ...
-------------------------------------------------------------------------------------------------------
h <- hist(y, plot = FALSE) plot(h$mids, h$counts, ylim = c(0, max(h$counts)), xlim = range(h$mids)*1.1, 
    type = 'n', bty = 'n', xlab = 'y', ylab = 'Counts', main = 'Histogram of y') grid() hist(y, add = TRUE) hist(y)
grid()
hist(y, add = TRUE, col = 'white')
-------------------------------------------------------------------------------------------------------
panel.first plot.default hist ?plot.default hist(WindSpeed, breaks=c(0:31), freq=TRUE, col="blue", xaxt="n", yaxt="n", 
     xlab="Wind Speed (m/s)", main="Foo", 
     cex.main=1.5, cex.axis=1, cex.lab=1, tck=1, font.lab=2,
     panel.first={
        axis(1, tck=1, col.ticks="light gray")
        axis(1, tck=-0.015, col.ticks="black")
        axis(2, tck=1, col.ticks="light gray", lwd.ticks="1")
        axis(2, tck=-0.015)
        minor.tick(nx=5, ny=2, tick.ratio=0.5)
        box()
 })
-------------------------------------------------------------------------------------------------------
?axis dat <- sample(100, 1000, replace=TRUE)
hist(dat, xaxt='n')
axis(side=1, at=seq(0,100, 10), labels=seq(0,1000,100))
-------------------------------------------------------------------------------------------------------
#df being the dataframe
  df$timestamp <- strptime(df$timestamp, format="%H:%M:%S")
  df$hours <-  as.numeric(format(df$timestamp, format="%H"))
  hist(df$hours) ggplot2 #install.packages("ggplot2")
  require(ggplot2)
  ggplot(data=df) + geom_histogram(aes(x=hours), bin=1) +  facet_wrap(~ server)
  # or use a color instead
  ggplot(data=df) + geom_histogram(aes(x=hours, fill=server), bin=1) require(plotrix)
 l <- split(df$hours, f=df$server)
 multhist(l) ggplot2
-------------------------------------------------------------------------------------------------------
11  12  13  14  15  16  17  18  19 1st bin: [10, 12)
2nd bin: [12, 14)
3rd bin: [14, 16)
4th bin: [16, 18)
5th bin: [18, 20) 1st bin: 10 ≤ x < 12
2nd bin: 12 ≤ x < 14
3rd bin: 14 ≤ x < 16
4th bin: 16 ≤ x < 18
5th bin: 18 ≤ x < 20 (1, 4) --> 1 < x < 4    left-open, right-open
[3, 7) --> 3 ≤ x < 7    left-closed, right-open
(2, 9] --> 2 < x ≤ 9    left-open, right-closed
[5, 6] --> 5 ≤ x ≤ 6    left-closed, right-closed (-∞, ∞)   -->   -∞ < x < ∞ 
(-∞, 20]  -->   -∞ < x ≤ 20 
[20, ∞)   -->   20 ≤ x < ∞
(1000, ∞) --> 1000 < x < ∞
(-∞, ∞]   -->   Invalid
(41, ∞]   -->   Invalid 1st bin: (10, 12] i.e. 10 < x ≤ 12
2nd bin: (12, 14]      12 < x ≤ 14
3rd bin: (14, 16]      14 < x ≤ 16
4th bin: (16, 18]      16 < x ≤ 18
5th bin: (18, 20]      18 < x ≤ 20 [a, b) (a, b] hist()
-------------------------------------------------------------------------------------------------------
data$a data hist(table(data$a[data$b > 10]))
-------------------------------------------------------------------------------------------------------
d <- structure(list(V1 = c("foo", "foo", "foo", "foo", "bar", "bar", 
"bar", "bar"), V2 = c(5L, 10L, 15L, 20L, 5L, 10L, 15L, 20L), 
    V3 = c(5L, 8L, 6L, 8L, 7L, 4L, 9L, 10L)), .Names = c("V1", 
"V2", "V3"), class = "data.frame", row.names = c(NA, -8L))


hist(as.numeric(unlist(apply(d,1,function(x){rep(x[2],time=x[3])}))))
-------------------------------------------------------------------------------------------------------
*apply levels(factor) unique(factor) for(i in levels(df$factor))
{
    lf <- paste("test_", i, ".png", sep="")
    png(file=lf, bg="transparent",
        with(subset(df, factor == i), hist(x, ....)
    dev.off()
}
-------------------------------------------------------------------------------------------------------
split split_df <- split(df, df$factor) paste lfile <- paste("test_", names(split_df), ".png", sep = "") draw_and_save_histogram <- function(data, file)
{
  png(file)
  with(data, hist(x))
  dev.off()  
} *apply mapply for(i in seq_along(split_df))
{
  draw_and_save_histogram(split_df[[i]], lfile[i])
}

mapply(
  draw_and_save_histogram,
  split_df,      
  lfile      
) lattice ggplot2 library(lattice)
histogram(~ x | factor, df)

library(ggplot2)
ggplot(df, aes(x)) + geom_histogram() + facet_wrap(~ factor)
-------------------------------------------------------------------------------------------------------
hist findInterval > tmp <- hist(iris$Petal.Width)
> findInterval(iris$Petal.Width, tmp$breaks)
  [1]  2  2  2  2  2  3  2  2  2  1  2  2  1  1  2  3  3  2  2  2  2  3  2  3  2
 [26]  2  3  2  2  2  2  3  1  2  2  2  2  1  2  2  2  2  2  4  3  2  2  2  2  2
 [51]  7  8  8  7  8  7  9  6  7  7  6  8  6  7  7  7  8  6  8  6 10  7  8  7  7
 [76]  7  7  9  8  6  6  6  7  9  8  9  8  7  7  7  7  7  7  6  7  7  7  7  6  7
[101] 13 10 11 10 12 11  9 10 10 13 11 10 11 11 13 12 10 12 12  8 12 11 11 10 11
[126] 10 10 10 11  9 10 11 12  8  7 12 13 10 10 11 13 12 10 12 13 12 10 11 12 10
> tmp2 <- .Last.value
> cbind( value=iris$Petal.Width, lower=tmp$breaks[tmp2], upper=tmp$breaks[tmp2+1])
       value lower upper
  [1,]   0.2   0.2   0.4
  [2,]   0.2   0.2   0.4
  [3,]   0.2   0.2   0.4
  [4,]   0.2   0.2   0.4
  [5,]   0.2   0.2   0.4
  [6,]   0.4   0.4   0.6
  [7,]   0.3   0.2   0.4
  [8,]   0.2   0.2   0.4
  [9,]   0.2   0.2   0.4
 [10,]   0.1   0.0   0.2
-------------------------------------------------------------------------------------------------------
prob=TRUE hist hist(samples, prob=TRUE)
curve(dfun,add=TRUE)
-------------------------------------------------------------------------------------------------------
#+BABEL #+PROPERTY \includegraphics{} #+TITLE:    tester.org
#+PROPERTY: session *R*
#+PROPERTY: results output

* Headline here

Here is some text.

#+begin_src R :exports both :results graphics :file img.pdf
hist(rnorm(100))
#+end_src #+PROPERTY: results output
-------------------------------------------------------------------------------------------------------
names(df)[i] par(mfrow=c(3,3),mar=c(2,1,1,1)) #my example has 9 columns

dfplot <- function(data.frame)
{
  df <- data.frame
  ln <- length(names(data.frame))
  for(i in 1:ln){
    mname <- substitute(df[,i])
      if(is.factor(df[,i])){
        plot(df[,i],main=names(df)[i])}
        else{hist(df[,i],main=names(df)[i])}
  }
}
-------------------------------------------------------------------------------------------------------
x <- rnorm(100)
par(mfrow = c(1, 2))
hist(x, freq = FALSE, axes = FALSE)
axis(2, at = seq(0, 0.4, 0.1), labels = paste(0:4, "%", sep = ""))
hist(x, freq = FALSE)
-------------------------------------------------------------------------------------------------------
hist axis h <- hist(rnorm(100))
plot(h, freq=FALSE, yaxt="n")
axis(2, pretty(h$density), sprintf("%0.0f%%", pretty(h$density)*100)) hist(rnorm(100, s=0.1))
-------------------------------------------------------------------------------------------------------
import math
import random

#generate 10k lognormal samples with mean=0 and stddev=1
samples = [random.lognormvariate(0,1) for r in xrange(10000)]

#demonstrate the mean and stddev are close to the target
#compute the mean of the samples
log_samples = [math.log(sample) for sample in samples]
mu = sum(log_samples)/len(samples)
#compute the variance and standard deviation
variance = sum([(val-mu)**2 for val in log_samples])/(len(log_samples)-1)
stddev = var**0.5

print('Mean: %.4f' % mu)
print('StdDev: %.4f' % stddev)

#Plot a histogram if matplotlib is installed
try:
    import pylab
    hist = pylab.hist(samples,bins=100)
    pylab.show()

except:
    print('pylab is not available') import rpy2.robjects as robjects

#reference the rlnorm R function
rlnorm = robjects.r.rlnorm

#generate the samples in R
samples = rlnorm(n=10000, meanlog=1, sdlog=1)
-------------------------------------------------------------------------------------------------------
dnorm curve w<-rnorm(1000) 
hist(w,col="red",freq=F,xlim=c(-5,5))
curve(dnorm,-5,5,add=T,col="blue") hist curve w<-rnorm(1000, mean=10, sd=2) 
hist(w, col="red", freq=F, xlim=10+c(-5,5))
curve( dnorm(x, mean=10,sd=2), 5, 15, add=T, col="blue")
-------------------------------------------------------------------------------------------------------
hist() hist() histPercent <- function(x, ...) {
   H <- hist(x, plot = FALSE)
   H$density <- with(H, 100 * density* diff(breaks)[1])
   plot(H, freq = FALSE, ...)
}

histPercent(rnorm(10000), col="dodgerblue", las=1,
            xlab="Echs-axis", ylab="Why-axis")
-------------------------------------------------------------------------------------------------------
oldlogspline logspline mymat <- cbind( c(0,1,5.5,10.5, 15.5), c(1,5.5,10.5, 15.5, Inf) )[rep(1:5, c(7,45,84,104,249)),]

library(logspline)

fit <- oldlogspline(interval=mymat[mymat[,2] < 100,],
    right=mymat[ mymat[,2]>100, 1], lbound=0)
fit2 <- oldlogspline.to.logspline(fit)

hist( mymat[,1]+0.5, breaks=c(0,1,5.5,10.5,15.5,60), main='', xlab='Years')
plot(fit2, add=TRUE, col='blue') survreg survival library(survival)

mymat2 <- mymat
mymat2[ mymat2>100 ] <- NA

fit3 <- survreg( Surv(mymat2[,1], mymat2[,2], ,type='interval2') ~ 1, 
    dist='gaussian', control=survreg.control(maxiter=100) )
curve( dnorm(x, coef(fit3), fit3$scale), from=0, to=60, col='green', add=TRUE) fit4 <- survreg( Surv(mymat2[,1]+.01, mymat2[,2], ,type='interval2') ~ 1,
    dist='weibull', control=survreg.control(maxiter=100) )
curve( dweibull(x, scale=exp(coef(fit4)), shape=1/fit4$scale), 
    from=0, to=60, col='red', add=TRUE) fitdistr MASS library(MASS)
tmpfun <- function(x, size, prob) {
    ifelse(x==0, dnbinom(0,size,prob),
    ifelse(x < 5, pnbinom(5,size,prob)-pnbinom(0,size,prob),
    ifelse(x < 10, pnbinom(10,size,prob)-pnbinom(5,size,prob),
    ifelse(x < 15, pnbinom(15,size,prob)-pnbinom(10,size,prob),
        pnbinom(15,size,prob, lower.tail=FALSE)))))
}

fit5 <- fitdistr( mymat[,1], tmpfun, start=list(size=6, prob=0.28) )
lines(0:60, dnbinom(0:60, fit5$estimate[1], fit5$estimate[2]), 
    type='h', col='orange')
-------------------------------------------------------------------------------------------------------
freq=F h = hist(x)
h$density = h$counts/sum(h$counts)
plot(h,freq=F)
-------------------------------------------------------------------------------------------------------
rep n <- 10
dat <- data.frame(
    x = sort(sample(1:50, n)),
    f = sample(1:100, n))
dat

expdat <- dat[rep(1:n, times=dat$f), "x", drop=FALSE] expdat hist par(mfcol=c(1, 2))
hist(expdat$x, breaks=50, col="blue", main="50 bins")
hist(expdat$x, breaks=5, col="blue", main="5 bins")
par(mfcol=c(1, 1))
-------------------------------------------------------------------------------------------------------
Zmat cor() q Zmat # Simulate data
nZ <- 200000
nq <- 30
Z <- rnorm(nZ)
q <- seq_len(nq)

# From Z, construct a 30 by 199971 matrix, in which each column is a
# "time series segment". Column 1 contains observations 1:30, column 2
# contains observations 2:31, and so on through the end of the series.
Zmat <- sapply(seq_len(nZ - nq + 1),  
               FUN = function(X) Z[seq(from = X, length.out = nq)])

# Calculate the correlation of q with every column/"time series segment.
Cors <- cor(q, Zmat)

# Extract the starting position of the 300 most highly correlated segments    
ids <- order(Cors, decreasing=TRUE)[1:300]

# Maybe try something like the following to confirm that you have
# selected the most highly correlated segments.
hist(Cors, breaks=100)
hist(Cors[ids], col="red", add=TRUE)
-------------------------------------------------------------------------------------------------------
sim.factor <- function(levels, contr, beta, perCell, errorVar){
  # Build design matrix X
  X <- cbind(rep(1,levels*perCell), kronecker(contr, rep(1,perCell)))
  # Generate y
  y <- X %*% beta + rnorm(levels*perCell, sd=sqrt(errorVar))
  # Build and return data frame
  dat <- cbind.data.frame(y, X[,-1])
  names(dat)[-1] <- colnames(contr)
  return(dat)
} ws.var <- function(levels, contr, beta, perCell, dc){
  # Build design matrix X
  X <- cbind(rep(1,levels), contr)
  # Generate the expected means
  means <- X %*% beta
  # Find the sum of squares due to each contrast 
  var <- (t(means) %*% contr)^2 / apply(contr^2 / perCell, 2, sum)
  # Calculate the within-conditions sum of squares
  wvar <- var[1] / dc - sum(var)
  # Convert the sum of squares to variance
  errorVar <- wvar / (3 * (perCell - 1))
  return(errorVar)
} contr <- contr.helmert(3)
colnames(contr) <- c("c1","c2")
beta <- c(0, 1, 0)
perCell <- 50
levels = 3
dc <- .08
N <- 1000

# Calculate the error variance
errorVar <- ws.var(levels, contr, beta, perCell, dc)

# To store delta R^2 values
d1 <- vector("numeric", length = N)

# Use the functions
for(i in 1:N)
{
   d <- sim.factor(levels=3,
                   contr=contr,
                   beta=beta,
                   perCell=perCell,
                   errorVar=errorVar)
   d1[i] <- lm.sumSquares(lm(y ~ c1 + c2, data = d))[1, 2] # From the lmSupport package
}

m <- round(mean(d1), digits = 3)

bmp("Testing simulation functions.bmp")
hist(d1, xlab = "Percentage of variance due to c1", main = "")
text(.18, 180, labels = paste("Mean =", m))
dev.off()
-------------------------------------------------------------------------------------------------------
myhist <- hist(x,prob=FALSE,col="gray",xlim=c(0,100))
    dens <- density(x)
    axis(side=1, at=seq(0,100, 20), labels=seq(0,100,20))
    lines(dens$x,dens$y*(1/sum(myhist$density))*length(x)) 1/sum(myhist$density) density(x)$x sum(density(x)$y) sum(density(x)$y)/(1/diff(density(x)$x)[1]) hist() length(x) xlim xlim ylim type = "n"
-------------------------------------------------------------------------------------------------------
# set the number of simulations
nsim <- 10000

# Create a matrix, with nsim columns, and fill it with something. 
#  The something with which you'll populate it is a random sample, 
#  with replacement, of month names (held in a built-in vector called
#  'month.abb'). We're telling the sample function that it should take 
#  13*nsim samples, and these will be used to fill the matrix, which 
#  has nsim columns (and hence 13 rows). We've chosen to take samples 
#  of length 13, because as your textbook states, 13 is the maximum
#  number of month names necessary for a month name to be duplicated.
mat <- matrix(sample(month.abb, 13*nsim, replace=TRUE), ncol=nsim)

# If you like, take a look at the first 10 columns
mat[, 1:10]

# We want to find the position of the first duplicated value for each column. 
#  Here's one way to do this, but it might be a bit confusing if you're just 
#  starting out. The 'apply' family of functions is very useful for
#  repeatedly applying a function to columns/rows/elements of an object.
#  Here, 'apply(mat, 2, foo)' means that for each column (2 represents columns,
#  1 would apply to rows, and 1:2 would apply to every cell), do 'foo' to that
#  column. Our function below extends this a little with a custom function. It
#  says: for each column of mat in turn, call that column 'x' and perform 
#  'match(1, duplicated(x))'. This match function will return the position
#  of the first '1' in the vector 'duplicated(x)'. The vector 'duplicated(x)'
#  is a logical (boolean) vector that indicates, for each element of x,
#  whether that element has already occurred earlier in the vector (i.e. if 
#  the month name has already occurred earlier in x, the corresponding element
#  of duplicated(x) will be TRUE (which equals 1), else it will be false (0).
#  So the match function returns the position of the first duplicated month 
#  name (well, actually the second instance of that month name). e.g. if 
#  x consists of 'Jan', 'Feb', 'Jan', 'Mar', then duplicated(x) will be 
#  FALSE, FALSE, TRUE, FALSE, and match(1, duplicated(x)) will return 3. 
#  Referring back to your textbook problem, this is x, a realisation of the 
#  random variable X.
# Because we've used the apply function, the object 'res' will end up with
#  nsim realisations of X, and these can be plotted as a histogram.
res <- apply(mat, 2, function(x) match(1, duplicated(x)))
hist(res, breaks=seq(0.5, 13.5, 1))
-------------------------------------------------------------------------------------------------------
labels=TRUE hist() hist(islands, col="gray", labels = TRUE, ylim=c(0, 45)) hist() histPercent <- function(x, ...) {
   H <- hist(x, plot = FALSE)
   H$density <- with(H, 100 * density* diff(breaks)[1])
   labs <- paste(round(H$density), "%", sep="")
   plot(H, freq = FALSE, labels = labs, ylim=c(0, 1.08*max(H$density)),...)
}

histPercent(islands, col="gray")
-------------------------------------------------------------------------------------------------------
par(mfrow=c(2,2))
plot(first plot)
plot(second plot)
hist(third histogram)
boxplot(fourth boxplot)
-------------------------------------------------------------------------------------------------------
hist(logIntensityVector, main='Intensity per feature histogram', xlab='logged intensity', ylab='frequencies of features', br=6)
-------------------------------------------------------------------------------------------------------
lapply summary_text <- function(d) {
  do.call(rbind, lapply( d, function(u)
    data.frame(
      Type    = class(u)[1],
      Min     = if(is.numeric(u)) min(   u, na.rm=TRUE) else NA,
      Mean    = if(is.numeric(u)) mean(  u, na.rm=TRUE) else NA,
      Median  = if(is.numeric(u)) median(u, na.rm=TRUE) else NA,
      Max     = if(is.numeric(u)) max(   u, na.rm=TRUE) else NA,
      Missing = sum(is.na(u))
    )    
  ) )
}
summary_text(iris) summary_plot <- function(d, aspect=1) {
  # Split the screen: find the optimal number of columns 
  # and rows to be as close as possible from the desired aspect ratio.
  n <- ncol(d)
  dx <- par()$din[1]
  dy <- par()$din[2]
  f <- function(u,v) {
    if( u*v >= n && (u-1)*v < n && u*(v-1) < n ) {
      abs(log((dx/u)/(dy/v)) - log(aspect))
    } else { 
      NA 
    }
  }
  f <- Vectorize(f)
  r <- outer( 1:n, 1:n, f )
  r <- which( r == min(r,na.rm=TRUE), arr.ind=TRUE )
  r <- r[1,2:1]

  op <- par(mfrow=c(1,1),mar=c(2,2,2,2))
  plot.new()
  if( is.null( names(d) ) ) { names(d) <- 1:ncol(d) }
  ij <- matrix(seq_len(prod(r)), nr=r[1], nc=r[2], byrow=TRUE)
  for(k in seq_len(ncol(d))) {
    i <- which(ij==k, arr.ind=TRUE)[1]
    j <- which(ij==k, arr.ind=TRUE)[2]
    i <- r[1] - i + 1
    f <- c(j-1,j,i-1,i) / c(r[2], r[2], r[1], r[1] )
    par(fig=f, new=TRUE)
    if(is.numeric(d[,k])) { 
      hist(d[,k], las=1, col="grey", main=names(d)[k], xlab="", ylab="")
      o <- par(fig=c(
          f[1]*.4  + f[2]*.6,
          f[1]*.15 + f[2]*.85,
          f[3]*.4  + f[4]*.6,
          f[3]*.15 + f[4]*.85
        ), 
        new=TRUE,
        mar=c(0,0,0,0)
      )
      qqnorm(d[,k],axes=FALSE,xlab="",ylab="",main="")
      qqline(d[,k])
      box()
      par(o)
    } else {
      o <- par(mar=c(2,5,2,2))
      barplot(table(d[,k]), horiz=TRUE, las=1, main=names(d)[k])
      par(o)
    }
  }
  par(op)
}
summary_plot(iris)
-------------------------------------------------------------------------------------------------------
multhist(l, col=c("red","green","blue"))
-------------------------------------------------------------------------------------------------------
multhist(l, col=c("red","green","blue"),
  breaks=seq(0,5,by=0.2),names.arg=rep("",25))
box(bty="l")  ## add box around bottom and left edges multhist barplot
-------------------------------------------------------------------------------------------------------
hist hist(c[ c >= seq( min(c), max(c), by= diff(range(c))/10 )[2], 9 ] )
-------------------------------------------------------------------------------------------------------
require(plyr)
min.brea <- round_any(min(df$x), diff(range(df$x))/30, floor)
max.brea <- round_any(max(df$x), diff(range(df$x))/30, ceiling)
breaks <- seq(min.brea, max.brea, diff(range(df$x/30)))
histdata <- hist(df$x, breaks=breaks, plot=FALSE, right=FALSE)
max.value <- max(histdata$counts)
-------------------------------------------------------------------------------------------------------
par(mfrow = c(1,3),xpd = NA)

for (i in 1:3){
    x <- rnorm(200,i)
    hist(x)
    if (i == 1) segments(par("usr")[1],10,30,10)
}
-------------------------------------------------------------------------------------------------------
x <- your data
nbreaks <- 50 # how many points do you want in your scatter plot
breaks <- exp(seq(log(min(x)), log(max(x)), len=nbreaks))
hh <- hist(x, breaks, plot=FALSE)
plot(hh$mids, hh$density, log="xy")
-------------------------------------------------------------------------------------------------------
V2 / sum(V2) dat <- data.frame(V1 = 1:6, V2 = c(11613, 6517, 2442, 687, 159, 29)) > with(dat, V2 / sum(V2))
[1] 0.541474332 0.303865342 0.113862079 0.032032452 0.007413624 0.001352170 dat2 <- unlist(apply(dat, 1, function(x) rep(x[1], x[2]))) hist() dens <- hist(dat2, breaks = c(0:6), plot = FALSE) > str(dens)
List of 7
 $ breaks     : int [1:7] 0 1 2 3 4 5 6
 $ counts     : int [1:6] 11613 6517 2442 687 159 29
 $ intensities: num [1:6] 0.54147 0.30387 0.11386 0.03203 0.00741 ...
 $ density    : num [1:6] 0.54147 0.30387 0.11386 0.03203 0.00741 ...
     $ mids       : num [1:6] 0.5 1.5 2.5 3.5 4.5 5.5
 $ xname      : chr "dat2"
 $ equidist   : logi TRUE
 - attr(*, "class")= chr "histogram" density > dens$density
[1] 0.541474332 0.303865342 0.113862079 0.032032452 0.007413624 0.001352170 dat <- transform(dat, density = V2 / sum(V2))
plot(density ~ V1, data = dat, type = "n")
lines(density ~ V1, data = dat, col = "red") plot(density ~ V1, data = dat, type = "n", ylim = c(0,1))
lines(density ~ V1, data = dat, col = "red")
-------------------------------------------------------------------------------------------------------
x<-rnorm(100000,mean=10, sd=2)
hist(x,breaks=150,xlim=c(0,20),freq=FALSE)
abline(v=10, lwd=5)
abline(v=c(4,6,8,12,14,16), lwd=3,lty=3)
-------------------------------------------------------------------------------------------------------
y x ##@  3.1  @##

## Function to compute predictions from the posterior
## distribution of the salmon regression model
predict_eggmass<-function(pars,length)
{
    a <- pars[, 1]      #intercept
    b <- pars[, 2]      #slope
    sigma <- pars[, 3]  #error    
    pred_mass <- a + b * length 
    pred_mass <- rnorm(length(a), pred_mass, sigma)
    return(pred_mass)
}

###  --  ###
##@  3.2  @##

## generate prediction
pred_length <- 80     # predict for an 80cm individual
pred <- predict_eggmass(mcmc_salmon$trace, length=pred_length)
## Plot prediction distribution
hist(pred, breaks=30, main='', probability=TRUE)

## What is the 95% BCI of the prediction?
pred_BCI <- quantile(pred, p=c(0.025, 0.975))
    2.5%    97.5% 
33.61029 43.16795 pred pred_BCI
-------------------------------------------------------------------------------------------------------
n sample_data sample() sample_data ecdf(sample_data) # Create some example data
sample_data <- runif(100)

n <- 10
X <- replicate(1000, sum(sample(sample_data, size=n, replace=TRUE)))

# Plot the estimated distribution of the sum of n variates.
hist(X, breaks=40, col="grey", main=expression(sum(x[i], i==1, n)))
box(bty="l")

# Plot the ecdf of the sum
plot(ecdf(X))
-------------------------------------------------------------------------------------------------------
xlim ylim hist ?hist hist(x, xlim = c(-100, 100), ylim = c(0, 500))
-------------------------------------------------------------------------------------------------------
line loc <- hist(x, xaxt="n",bty="l")
axis(1, at=loc$breaks,line=-.75)
-------------------------------------------------------------------------------------------------------
box plot.histogram par x<-rnorm(2000, 0, 30)
hist(x)
box(bty = "l") par bty
-------------------------------------------------------------------------------------------------------
op <- options(digits.secs=10)
z <- strptime("3+23:12:11.931139", "%d+%H:%M:%OS")
vec_z <- z + rnorm(100000)
hist(vec_z, breaks=20) z strptime
-------------------------------------------------------------------------------------------------------
newSparkHist library(sparkTable)
data(alcohol)
hvals <- hist(alcohol$value,plot=FALSE)$counts
b <- newSparkBar(values=hvals,barCol=c("gray","gray","black"))
plotSparks(b, outputType="png", filename="testBar1")
-------------------------------------------------------------------------------------------------------
ce hist(ce$Weight) hist(ce[1])
-------------------------------------------------------------------------------------------------------
x <- rnorm(100)
hist(x,col="gray")
abline(h=seq(5,40,5),col="white")
-------------------------------------------------------------------------------------------------------
tkBrush TeachingDemos rechist <- function(x,...){
         tmp <- hist(x,plot=F)
         br <- tmp$breaks
         w <- as.numeric(cut(x,br,include.lowest=TRUE))
         sy <- unlist(lapply(tmp$counts,function(x)seq(length=x)))
         my <- max(sy)
         sy <- sy/my
         my <- 1/my
         sy <- sy[order(order(x))]
        plot.new()
        plot.window(xlim=range(br), ylim=c(0,1))
         rect(br[w], sy-my, br[w+1], sy, 
            border=TRUE, col='grey')
         rect(br[-length(br)], 0, br[-1], tmp$counts*my)
        axis(1)
     }

rechist( iris$Petal.Length )
-------------------------------------------------------------------------------------------------------
cex.lab=1.5, cex.axis=1.5, cex.main=1.5, cex.sub=1.5 x <- rnorm(100) hist(x, xlim=range(x),
     xlab= "Variable Lable", ylab="density", main="Title of plot", prob=TRUE)

hist(x, xlim=range(x),
     xlab= "Variable Lable", ylab="density", main="Title of plot", prob=TRUE, 
     cex=1.5) hist(x, xlim=range(x),
     xlab= "Variable Lable", ylab="density", main="Title of plot", prob=TRUE, 
     cex.lab=1.5, cex.axis=1.5, cex.main=1.5, cex.sub=1.5)
-------------------------------------------------------------------------------------------------------
dat <- data.frame(V4=c(runif(10000, 1,5000), 149999))
hist(dat$V4, breaks=c(seq(0,5000,100), 150000) ) hist(dat$V4[dat$V4 <5000], breaks=c(seq(0,5000,100)) )
-------------------------------------------------------------------------------------------------------
## My initial idea (and commenter Anders Gustafsson's):
## Sample 3 random numbers from [0,1], sum them, and normalize
jobFun <- function(n) {
    m <- matrix(runif(3*n,0,1), ncol=3)
    m<- sweep(m, 1, rowSums(m), FUN="/")
    m
}

## Andrie's solution. Sample 1 number from [0,1], then break upper 
## interval in two. (aka "Broken stick" distribution).
andFun <- function(n){
  x1 <- runif(n)
  x2 <- runif(n)*(1-x1)
  matrix(c(x1, x2, 1-(x1+x2)), ncol=3)
}

## ddzialak's solution (vectorized by me)
ddzFun <- function(n) {
    a <- runif(n, 0, 1)
    b <- runif(n, 0, 1)
    rand1 = pmin(a, b)
    rand2 = abs(a - b)
    rand3 = 1 - pmax(a, b)
    cbind(rand1, rand2, rand3)
}

## Simulate 10k triplets using each of the functions above
JOB <- jobFun(10000)
AND <- andFun(10000)
DDZ <- ddzFun(10000)

## Plot the distributions of values
par(mfcol=c(2,2))
hist(JOB, main="JOB")
hist(AND, main="AND")
hist(DDZ, main="DDZ")
-------------------------------------------------------------------------------------------------------
hist() rect() vals <- rnorm(10)
    A <- hist(vals)
    A
    $breaks
    [1] -1.5 -1.0 -0.5  0.0  0.5  1.0  1.5

    $counts
    [1] 1 3 3 1 1 1

    $intensities
    [1] 0.2 0.6 0.6 0.2 0.2 0.2

    $density
    [1] 0.2 0.6 0.6 0.2 0.2 0.2

    $mids
    [1] -1.25 -0.75 -0.25  0.25  0.75  1.25

    $xname
    [1] "vals"

    $equidist
    [1] TRUE

    attr(,"class")
    [1] "histogram" plot(NULL, type = "n", ylim = c(0,max(A$counts)), xlim = c(range(A$breaks)))
    rect(A$breaks[1:(length(A$breaks) - 1)], 0, A$breaks[2:length(A$breaks)], A$counts) plot(NULL, type = "n", xlim = c(0, max(A$counts)), ylim = c(range(A$breaks)))
    rect(0, A$breaks[1:(length(A$breaks) - 1)], A$counts, A$breaks[2:length(A$breaks)]) density()
-------------------------------------------------------------------------------------------------------
Time <- c("Jun 5, 2012 10:58 AM",
"Jun 5, 2012 10:58 AM",
"Jun 5, 2012 11:59 AM",
"Jun 5, 2012 12:25 PM",
"Jun 5, 2012 1:07 PM",
"Jun 5, 2012 1:07 PM",
"Jun 5, 2012 1:17 PM")
library(chron)
Time2 <- as.chron(Time, format = "%b %d, %Y %I:%M %p")
library(lubridate)
x <- hours(Time2) + minutes(Time2) / 60
hist(x)
-------------------------------------------------------------------------------------------------------

scatterBarNorm <- function(x, dcol="blue", lhist=20, num.dnorm=5*lhist, ...){
    ## check input
    stopifnot(ncol(x)==2)
    ## set up layout and graphical parameters
    layMat <- matrix(c(2,0,1,3), ncol=2, byrow=TRUE)
    layout(layMat, widths=c(5/7, 2/7), heights=c(2/7, 5/7))
    ospc <- 0.5 # outer space
    pext <- 4 # par extension down and to the left
    bspc <- 1 # space between scatter plot and bar plots
    par. <- par(mar=c(pext, pext, bspc, bspc),
                oma=rep(ospc, 4)) # plot parameters
    ## scatter plot
    plot(x, xlim=range(x[,1]), ylim=range(x[,2]), ...)
    ## 3) determine barplot and height parameter
    ## histogram (for barplot-ting the density)
    xhist <- hist(x[,1], plot=FALSE, breaks=seq(from=min(x[,1]), to=max(x[,1]),length.out=lhist))
    yhist <- hist(x[,2], plot=FALSE, breaks=seq(from=min(x[,2]), to=max(x[,2]),length.out=lhist)) # note: this uses probability=TRUE
    ## determine the plot range and all the things needed for the barplots and lines
    xx <- seq(min(x[,1]), max(x[,1]), length.out=num.dnorm) # evaluation points for the overlaid density
    xy <- dnorm(xx, mean=mean(x[,1]), sd=sd(x[,1])) # density points
    yx <- seq(min(x[,2]), max(x[,2]), length.out=num.dnorm)
    yy <- dnorm(yx, mean=mean(x[,2]), sd=sd(x[,2]))
    ## barplot and line for x (top)
    par(mar=c(0, pext, 0, 0))
    barplot(xhist$density, axes=FALSE, ylim=c(0, max(xhist$density, xy)),
            space=0) # barplot
    lines(seq(from=0, to=lhist-1, length.out=num.dnorm), xy, col=dcol) # line
    ## barplot and line for y (right)
    par(mar=c(pext, 0, 0, 0))
    barplot(yhist$density, axes=FALSE, xlim=c(0, max(yhist$density, yy)),
            space=0, horiz=TRUE) # barplot
    lines(yy, seq(from=0, to=lhist-1, length.out=num.dnorm), col=dcol) # line
    ## restore parameters
    par(par.)
}

require(mvtnorm)
X <- rmvnorm(1000, c(0,0), matrix(c(1, 0.8, 0.8, 1), 2, 2))
scatterBarNorm(X, xlab=expression(italic(X[1])), ylab=expression(italic(X[2])))
-------------------------------------------------------------------------------------------------------
data1 data2 bins <- seq(0, 100, 5) # Change this to whatever range your data encopasses
h1 <- hist(data1, bins, plot=0)
h2 <- hist(data2, bins, plot=0)

ratio <- h1$counts/h2$counts
# Remove NaNs and Infs due to 0 counts
ratio[is.na(ratio)] <- 0
ratio[is.inf(ratio)] <- 0
barplot(ratio) h3 <- h1
h3$counts <- ratio
plot(h3, col="black")
-------------------------------------------------------------------------------------------------------
barplot() beside=TRUE ## Example data
d1 <- rnorm(1000)
d2 <- rnorm(1000, mean=1)

## Prepare data for input to barplot
breaks <- pretty(range(c(d1, d2)), n=20)
D1 <- hist(d1, breaks=breaks, plot=FALSE)$counts
D2 <- hist(d2, breaks=breaks, plot=FALSE)$counts
dat <- rbind(D1, D2)
colnames(dat) <- paste(breaks[-length(breaks)], breaks[-1], sep="-")

## Plot it
barplot(dat, beside=TRUE, space=c(0, 0.1), las=2)
-------------------------------------------------------------------------------------------------------
layout m <- matrix(c(1,2,3,3,4,5,6,6),ncol = 2,byrow = TRUE)
layout(m,widths = c(0.5,0.5),heights = c(0.45,0.05,0.45,0.05))

par(mar = c(2,4,4,2) + 0.1)
hist(x1, xlab="", main="Group A")
hist(x2, xlab="", main="Group B")

par(mar = c(0,0,0,0)) 
plot(1,1,type = "n",frame.plot = FALSE,axes = FALSE)
u <- par("usr")
text(1,u[4],labels = "Here",col = "red",pos = 1)

par(mar = c(2,4,2,2) + 0.1)
hist(x3, xlab="", main="")
hist(x4, xlab="", main="")

par(mar = c(0,0,0,0)) 
plot(1,1,type = "n",frame.plot = FALSE,axes = FALSE)
u <- par("usr")
text(1,u[4],labels = "Here",col = "red",pos = 1)
-------------------------------------------------------------------------------------------------------
hist.data.frame() library(plyr)
library(psych)
multi.hist(mpg) #error, not numeric
multi.hist(mpg[,sapply(mpg, is.numeric)]) multhist plotrix melt library(reshape2)
mpgid <- mutate(mpg, id=as.numeric(rownames(mpg)))
mpgstack <- melt(mpgid, id="id")
pp <- qplot(value, data=mpgstack) + facet_wrap(~variable, scales="free")
# pp + stat_bin(geom="text", aes(label=..count.., vjust=-1))
ggsave("mpg-histograms.pdf", pp, scale=2)
-------------------------------------------------------------------------------------------------------
mu.a=33
 mu.b=32
 mu.c=13
 sigma.a=22
 sigma.b=22
 sigma.c=222

n= a.large.number=10^5
a=rnorm(n,mu.a,sigma.a)
b=rnorm(n,mu.b,sigma.b)
c=rnorm(n,mu.c,sigma.c)
y=a+b+c
plot(density(y))
mean(y)
sd(y) y a b c mysimfun=function(n,mu,sigma,stat.you.want='mean') 
   #  mu is length 3 and sigma is too.

{
n= a.large.number=10^5
    a=rnorm(n,mu[1],sigma[1])
    b=rnorm(n,mu[2],sigma[2])
    c=rnorm(n,mu[3],sigma[3])
    y=a+b+c
    plot(density(y))


return(ifelse(stat.you.want=='mean',mean(y),sd(y))
}


mu=c(mu.a,my.b,mu.c)
sigma=c(sigma.a,sigma.b,sigma.c)
mi=rep(NA,100) for(i in 1:100) {mi[i]=mysimfun(10,mu,sigma,stat.you.want='mean') }

par(mfrow=c(2,1)
hist(mi)
plot(density(mi))

mean(mi)
sd(mi)
-------------------------------------------------------------------------------------------------------
bg_col <- matrix("white",nrow(deciles),ncol(deciles))
bg_col[11,] <- "grey"

# create a plot
hist(foo, freq=F, xlim=c(0,xmax), breaks=50, col="blue")
top <- max(axis(2))
rect(xleft=(.69*xmax), xright=(1.04*xmax), ybottom=(.615*top), ytop=(.665*top), col="gray91", border=NA)
addtable2plot(x=(1.04*xmax), y=(top), xjust=1, yjust=0, table=deciles, cex=0.82,
          title="Title", hlines=TRUE, vlines=TRUE, bty="o", lwd=1.5, bg= bg_col) rect ?addtable2plot
-------------------------------------------------------------------------------------------------------
d <- as.data.frame(fromJSON(paste(readLines(url))))
d$sample.time <- 0
d$sample.time[2:nrow(d)] <- d$time[2:nrow(d)]-d$time[1:(nrow(d)-1)] hist(rep(x=d$cadence, times=d$sample.time),
     main="Histogram of Cadence", xlab="Cadence (RPM)",
     ylab="Time (presumably seconds)") new.d <- aggregate(sample.time~cadence, data=d, FUN=sum)
-------------------------------------------------------------------------------------------------------
x <- rnorm(50)

# create a histogram
.hist <- hist(x)

# look at the structure to see what is created when calling hist
str(.hist)

## List of 7
## $ breaks     : num [1:10] -2.5 -2 -1.5 -1 -0.5 0 0.5 1 1.5 2
## $ counts     : int [1:9] 1 2 5 6 8 10 10 5 3
## $ intensities: num [1:9] 0.04 0.08 0.2 0.24 0.32 0.4 0.4 0.2 0.12
## $ density    : num [1:9] 0.04 0.08 0.2 0.24 0.32 0.4 0.4 0.2 0.12
## $ mids       : num [1:9] -2.25 -1.75 -1.25 -0.75 -0.25 0.25 0.75 1.25 1.75
## $ xname      : chr "x"
## $ equidist   : logi TRUE
## - attr(*, "class")= chr "histogram"

# we could plot the mids (midpoints) against the counts
with(.hist, plot(mids, counts)) density plot(density(x))
-------------------------------------------------------------------------------------------------------
x xlim hist(d,xlim=c(-10,10))
-------------------------------------------------------------------------------------------------------
hist axis set.seed(123)
d <- rnorm(1000)
hist(d,axes = FALSE)
axis(1,at = seq(-3,3,1),labels = TRUE,pos = 0)
axis(2,pos = -3)
-------------------------------------------------------------------------------------------------------
#See if this is sufficient:
hist(...)
box()

#If not, try custom axes:
hist(..., xlim = c(-.5, .5), axes = F)
box()
axis(1, seq(-.5, .5, length = 6))
axis(2, seq(0, 30, by = 5))
-------------------------------------------------------------------------------------------------------
data.frame hist() numeric numeric hist(as.numeric(data[j,]))
-------------------------------------------------------------------------------------------------------
AnalyzeNumericData <- function(x,GroupVar=NA) {
    VarList <- names(x)
    NumVars <- length(VarList)

    for (i in 1) {
        if (is.numeric(x[,VarList[i]])) {
            par(mfrow=c(2,2))
            hist(x[,VarList[i]],main=paste("Histogram of ",VarList[i]),xlab=NA)
            boxplot(x[,VarList[i]],main=paste("Boxplot of ",VarList[i]))
            if (!is.na(GroupVar)) {
                boxplot(x[,VarList[i]]~x[,GroupVar],main=paste("Boxplot of ",VarList[i]," by ", GroupVar))
            }
            plot(NA,NA,axes=F,xlim=c(0,10),ylim=c(0,10),xlab="",ylab="")
            text(5,5,labels="MyText")
        }
    }
}

AnalyzeNumericData(mtcars,"cyl") x y text(x,y,labels="MyText") xlim ylim
-------------------------------------------------------------------------------------------------------
library(rmutil)  ## for rpareto
set.seed(101)
hh2 <- data.frame(V1=rpareto(1000, m=1, s=1.5)) pp <- hist(hh2$V1,plot=FALSE) gamma ghistfun <- function(x) {
    n <- length(x)
    scalepar <- var(x)/mean(x)
    shapepar <- mean(x)^2/var(x)
    y <- rgamma(n,shape=shapepar,scale=scalepar)
    xx <- hist(y,plot=FALSE)
    lines(log(xx$mids),log(xx$density),col="red")
    curve(dgamma(exp(x),shape=shapepar,scale=scalepar,log=TRUE),
        add=TRUE,col="blue")

    shapepar
} n curve(dgamma(x,...)) x log(x) plot(log(pp$mids),log(pp$density))
ghistfun(hh2$V1)
-------------------------------------------------------------------------------------------------------
library(TeachingDemos)
x <- pmin(3, pmax(-3, stats::rnorm(50)))
y <- pmin(3, pmax(-3, stats::rnorm(50)))
xhist <- hist(x, breaks=seq(-3,3,0.5), plot=FALSE)
yhist <- hist(y, breaks=seq(-3,3,0.5), plot=FALSE)
top <- max(c(xhist$density, yhist$density))
xrange <- c(-3,3)
yrange <- c(-3,3)
nf <- layout(matrix(c(2,0,1,3),2,2,byrow=TRUE), c(3,1), c(1,3), TRUE)
layout.show(nf)

par(mar=c(3,3,1,1))
plot(x, y, xlim=xrange, ylim=yrange, xlab="", ylab="")
par(mar=c(0,3,1,1))
bx.out <- barplot(xhist$density, axes=FALSE, ylim=c(0, top), space=0)
updateusr( bx.out[1:2], 0:1, xhist$mids[1:2], 0:1 )
xdens <- density(x)
lines(xdens$x, xdens$y, col='blue')
par(mar=c(3,0,1,1))
by.out <- barplot(yhist$density, axes=FALSE, xlim=c(0, top), space=0, horiz=TRUE)
updateusr( 0:1, by.out[1:2], 0:1, yhist$mids[1:2] )
ydens <- density(y)
lines(ydens$y, ydens$x, col='blue') counts density updateusr updateusr width xlim barplot
-------------------------------------------------------------------------------------------------------
horiz.hist <- function(Data, breaks="Sturges", col="transparent", las=1, 
ylim=range(HBreaks), labelat=pretty(ylim), labels=labelat, border=par("fg"), ... )
  {a <- hist(Data, plot=FALSE, breaks=breaks)
  HBreaks <- a$breaks
  HBreak1 <- a$breaks[1]
  hpos <<- function(Pos) (Pos-HBreak1)*(length(HBreaks)-1)/ diff(range(HBreaks))
  barplot(a$counts, space=0, horiz=T, ylim=hpos(ylim), col=col, border=border,...)      
  axis(2, at=hpos(labelat), labels=labels, las=las, ...) 
  print("use hpos() to address y-coordinates") } # Data and basic concept
set.seed(8); ExampleData <- rnorm(50,8,5)+5
hist(ExampleData)
horiz.hist(ExampleData, xlab="absolute frequency") 
# Caution: the labels at the y-axis are not the real coordinates!
# abline(h=2) will draw above the second bar, not at the label value 2. Use hpos:
abline(h=hpos(11), col=2)

# Further arguments
horiz.hist(ExampleData, xlim=c(-8,20)) 
horiz.hist(ExampleData, main="the ... argument worked!", col.axis=3) 
hist(ExampleData, xlim=c(-10,40)) # with xlim
horiz.hist(ExampleData, ylim=c(-10,40), border="red") # with ylim
horiz.hist(ExampleData, breaks=20, col="orange")
axis(2, hpos(0:10), labels=F, col=2) # another use of hpos()
-------------------------------------------------------------------------------------------------------
dat dat ## fake a list of data frames, here, 4, each with two columns
dat <- list(file1 = data.frame(X = runif(20), Y = rnorm(20)),
            file2 = data.frame(X = runif(20), Y = runif(20)),
            file3 = data.frame(X = runif(20),
                               Y = rnorm(20) + rnorm(20, mean = 2, sd = 2)),
            file4 = data.frame(X = runif(20), Y = rnorm(20, mean = 4)))

## extract the second column from each
## (this is the same as your code extracting the 14 column)
tmp <- lapply(dat, `[[`, 2) R> str(tmp)
List of 4
 $ file1: num [1:20] -1.0225 -0.0302 -0.0987 1.977 0.2579 ...
 $ file2: num [1:20] 0.84583 0.49525 0.12287 0.43929 0.00132 ...
 $ file3: num [1:20] 2.03 5.27 1.57 2.72 1.12 ...
 $ file4: num [1:20] 4.54 4.08 4.28 4.48 6.36 ... tmp hist(tmp[[1]]) layout(matrix(1:4, ncol = 2))
for(p in seq_along(tmp)) {
    hist(tmp[[p]])
}
layout(1) lapply() layout(matrix(1:4, ncol = 2))
lapply(tmp, function(x) {hist(x); invisible()})
layout(1)
-------------------------------------------------------------------------------------------------------
freq=FALSE curve x a <- 5
b <- 2
hist( rnorm(100, a, b), freq=FALSE )
curve( dnorm(x,a,b), add=TRUE ) freq=TRUE curve out <- hist( rnorm(100, a, b) )
curve( dnorm(x,a,b)*100*diff(out$breaks[1:2]), add=TRUE )
-------------------------------------------------------------------------------------------------------
h<-hist(data, breaks="FD", col="red", xlab="xTitle", main="Normal pdf and     histogram")
xfit<-seq(min(data),max(data),length=100)
x.norm<-rnorm(n=100000, mean=a, sd=b)
yfit<-dnorm(xfit,mean=mean(x.norm),sd=sd(x.norm))
yfit <- yfit*diff(h$mids[1:2])*length(loose_All)
lines(xfit, yfit, col="blue", lwd=2)
-------------------------------------------------------------------------------------------------------
```{r setup-reusable, echo=TRUE, message=FALSE, warning=FALSE, error=FALSE, results='hide'}
# Prepare knitr.
knit_child( "child-chunks.Rmd" )
```

```{r}
# Prepare R
library(brew)
library(iterators)
data(mtcars)

brewed.chunks <- tempfile( tmpdir=getwd(), pattern='brewed-chunks', fileext='.Rmd')
```

```{r create-chunk-labels, results='markup'}
# Prepare label data.
engine.cyl <- rep( sort( unique( mtcars$cyl ) ), each=2 )
reusable.chunk.label <- c('mpg-histogram', 'weight-histogram')

generated.chunk.label <- paste( engine.cyl, 'cyl', sep='' )
generated.chunk.label <- paste( reusable.chunk.label, generated.chunk.label, sep='-' )

label.data <- data.frame( engine.cyl, reusable.chunk.label, generated.chunk.label, stringsAsFactors=FALSE)
```

```{r create-iterator}
# Prepare iterator
cyl.i <- iter( unique( engine.cyl ) )
```

```{r brew-report-chunks, tidy=FALSE}
for( i in seq( 1, length( engine.cyl ), by=2 ) ) {
  capture.output( 
    brew( text= quote("```{r '<%=label.data$generated.chunk.label[i]%>'}\n\
                run_chunk('iterate')\n\
                run_chunk('<%=label.data$reusable.chunk.label[i]%>')\n```\n") ),
    file=brewed.chunks, append=TRUE )

  capture.output( 
    brew( text= quote("```{r '<%=label.data$generated.chunk.label[i+1]%>'}\n\
                run_chunk('<%=label.data$reusable.chunk.label[i+1]%>')\n```\n") ),
    file=brewed.chunks, append=TRUE )
}
```

```{r generate-reports, child=brewed.chunks, echo=TRUE }
``` run_chunk child generate-report # My report

```{r setup-reusable, include=FALSE, error=FALSE, message=FALSE, results='hide'}
knit_child( "child-chunks.Rmd" )
````

```{r}
library(iterators)
data(mtcars)
```

```{r create-iterator}
cyl.i <- iter( sort( unique(mtcars$cyl) ) )
```

```{r "Cyl4-report"}
run_chunk('generate-report')
```

```{r "Cyl6-report"}
run_chunk('generate-report')
```

```{r "Cyl8-report"}
run_chunk('generate-report')
``` ```{r iterate}
cur.cyl <- nextElem(cyl.i)
cat("###", cur.cyl)
```

```{r mpg-histogram}
hist(mtcars$mpg[mtcars$cyl == cur.cyl], main = paste(cur.cyl, "cylinders"))
```

```{r weight-histogram}
hist(mtcars$wt[mtcars$cyl == cur.cyl], main = paste(cur.cyl, "cylinders"))
```

```{r generate-report}
run_chunk('iterate')
run_chunk('mpg-histogram')
run_chunk('weight-histogram')
````
-------------------------------------------------------------------------------------------------------
hist set.seed(123)
dfrm <- data.frame(transtype = c("c","p")[sample(1:2, 20, rep=TRUE)], 
                   trans_date_time = as.POSIXct( Sys.Date() - 20) + 
                                         rnorm(100, 24*60*60, 3*24*60*60) , 
                   volume = 100*rpois(100, 5) )
str(dfrm)
dailycallvol <- with( subset( dfrm, transtype == "c"), 
                    aggregate( volume,
                      by = list( day= format(trans_date_time, format="%Y-%m-%d")),
                      FUN=sum) )
hist( dailycallvol[[2]] )
-------------------------------------------------------------------------------------------------------
dat <- c(0.000012, 0.000234, 1.078229, 3.246678)
hist(log(dat))
-------------------------------------------------------------------------------------------------------
[ iris x <- hist(iris$Sepal.Length)

str(x)
List of 7
 $ breaks     : num [1:9] 4 4.5 5 5.5 6 6.5 7 7.5 8
 $ counts     : int [1:8] 5 27 27 30 31 18 6 6
 $ intensities: num [1:8] 0.0667 0.36 0.36 0.4 0.4133 ...
 $ density    : num [1:8] 0.0667 0.36 0.36 0.4 0.4133 ...
 $ mids       : num [1:8] 4.25 4.75 5.25 5.75 6.25 6.75 7.25 7.75
 $ xname      : chr "iris$Sepal.Length"
 $ equidist   : logi TRUE
 - attr(*, "class")= chr "histogram" x$breaks[2:3]
[1] 4.5 5.0

x$intensities[2]
[1] 0.36 x$intensities[x$breaks == 4.5]
[1] 0.36
-------------------------------------------------------------------------------------------------------
hist() R> x <- rep(1:9, each=10)
R> hh <- hist(x, breaks=0:9)       # also creates chart
R> str(hh)
List of 7
 $ breaks     : int [1:10] 0 1 2 3 4 5 6 7 8 9
 $ counts     : int [1:9] 10 10 10 10 10 10 10 10 10
 $ intensities: num [1:9] 0.111 0.111 0.111 0.111 0.111 ...
 $ density    : num [1:9] 0.111 0.111 0.111 0.111 0.111 ...
 $ mids       : num [1:9] 0.5 1.5 2.5 3.5 4.5 5.5 6.5 7.5 8.5
 $ xname      : chr "x"
 $ equidist   : logi TRUE
 - attr(*, "class")= chr "histogram"
R>
-------------------------------------------------------------------------------------------------------
axis plot.histogram labels <- sample(1:9, 1000, replace = T)
.h <- hist(labels)
# if you save the histogram, then you can refer to the components
axis(1, at = .h$breaks))
-------------------------------------------------------------------------------------------------------
```{r example_pairs, include = F, fig.keep = 'none'}
example(pairs)
```

```{r test}
exists('panel.cor')
``` ## [1] TRUE panel.cor give.lines .ex <- example(pairs, give.lines = T)
# find the code in question (look for assignment / scope delimiters)
which(grepl(.ex, pattern = "(panel.hist <-)|(panel.cor <-)|[{}]"))
##[1] 18 19 26 33 34 42

cat(.ex[c(18:26, 33:42)], sep = "\n")
panel.hist <- function(x, ...)
{
    usr <- par("usr"); on.exit(par(usr))
    par(usr = c(usr[1:2], 0, 1.5) )
    h <- hist(x, plot = FALSE)
    breaks <- h$breaks; nB <- length(breaks)
    y <- h$counts; y <- y/max(y)
    rect(breaks[-nB], 0, breaks[-1], y, col="cyan", ...)
}
panel.cor <- function(x, y, digits=2, prefix="", cex.cor, ...)
{
    usr <- par("usr"); on.exit(par(usr))
    par(usr = c(0, 1, 0, 1))
    r <- abs(cor(x, y))
    txt <- format(c(r, 0.123456789), digits=digits)[1]
    txt <- paste(prefix, txt, sep="")
    if(missing(cex.cor)) cex.cor <- 0.8/strwidth(txt)
    text(0.5, 0.5, txt, cex = cex.cor * r)
}
-------------------------------------------------------------------------------------------------------
box() hist(...., axes = FALSE) ## .... is where your other args go
axis(side = 2)
axis(side = 1, at = seq(1730, 1830, by = 20)) axis(side = 1, at = seq(1725, 1835, by = 20))
-------------------------------------------------------------------------------------------------------
library(date)
hist(dat.geo$Date_of_Onset[(dat.geo$suburb=="x")], "weeks", 
 format = "%d %b %y", freq=T, col=rgb(0,0,0,1), axes=F, main="")
hist(dat.geo$Date_of_Onset[(dat.geo$suburb=="y")], "weeks", 
 format = "%d %b %y", freq=T, main="", col=rgb(1,1,1,.6), add=T, axes=F)
axis.Date(1, at=seq(as.Date("2011-10-10"), as.Date("2012-03-19"), by="2 weeks"),
 format="%d %b %y")
axis.Date(1, at=seq(as.Date("2011-10-10"), as.Date("2012-03-19"), by="weeks"), 
 labels=F, tcl= -0.5) library(scales)
library(ggplot2)
ggplot(dat.geo,aes(x=Date_of_Onset, group=suburb, fill=suburb))+
 stat_bin(colour="black", binwidth=1, alpha=0.5,
 position="identity") + theme_bw()+
 xlab("Date of onset of symptoms")+
 ylab("Number of cases")+
 scale_x_date(breaks=date_breaks("1 month"), labels=date_format("%b %y"))
-------------------------------------------------------------------------------------------------------
sapply(names(myDF), function(nm) hist(myDF[[nm]], main=nm)) mapply Map Map(function(name, values) hist(values, main=name),
    names(myDF), myDF) deparse substitute
-------------------------------------------------------------------------------------------------------
par(oma=c(3,3,0,0)) par(mar=...) scatterhist = function(x, y, xlab="", ylab=""){
    zones=matrix(c(2,0,1,3), ncol=2, byrow=TRUE)
    layout(zones, widths=c(4/5,1/5), heights=c(1/5,4/5))
    par(oma=c(3,3,0,0))

    xhist = hist(x, plot=F, breaks=10)
    yhist = hist(y, plot=F, breaks=10)
    top = max(c(xhist$counts, yhist$counts))

    par(mar=c(3,3,1,1))
    plot(x, y)

    par(mar=c(0,3,1,1))
    barplot(xhist$counts, axes=FALSE, ylim=c(0, top), space=0)

    par(mar=c(3,0,1,1))
    barplot(yhist$counts, axes=FALSE, xlim=c(0, top), space=0, horiz=TRUE)

    mtext(xlab, side=1, line=1, outer=TRUE, adj=0, 
        at=.8 * (mean(x)-min(x))/(max(x)-min(x)))
    mtext(ylab, side=2, line=1, outer=TRUE, adj=0, 
        at=.8 * (mean(y)-min(y))/(max(y)-min(y)))
    }
-------------------------------------------------------------------------------------------------------
names(data) for(i in names(data)){
  png(paste(i,'.png',sep=""))
  hist(data[,which(names(data)==i)],
       main=paste(i,"some other stuff"),
       xlab=paste(i,"some more stuff") 
      )
  dev.off()
}
-------------------------------------------------------------------------------------------------------
by(x, x$Variable2, function(x) hist(x$Value, main=unique(x$Variable2) ) ) Condition1 Condition2
-------------------------------------------------------------------------------------------------------
by() split() lapply() temp <- split(x$Value, list(x$Variable2, x$Variable1))
lapply(names(temp), function(x) hist(temp[[x]], main = x, xlab = "Value"))
-------------------------------------------------------------------------------------------------------
value=c(1,2,3,4,5,6,7,8,9,10)
weight<-c(8976,10857,10770,14075,18075,20757,24770,14556,11235,8042)
dat = rep(value,weight)
# plot result
histres = hist(dat)
-------------------------------------------------------------------------------------------------------
onefile = TRUE pdf() file pdf() "Combined_Graphs.pdf" pdf(file = "foo.pdf", onefile = TRUE, width = 8.5, height = 11)
hist(rnorm(100))
hist(rnorm(100, 10, 2), col = "red")
pdf(file = "bar.pdf", width =11, height = 8.5)
hist(rnorm(100, 10, 2), col = "blue")
dev.off()
dev.off()
-------------------------------------------------------------------------------------------------------
hist(rnorm(1000))
dev.off() tiff() "file.tiff" identify Image: file.tiff
  Format: TIFF (Tagged Image File Format)
  Class: DirectClass
  Geometry: 2049x2049+0+0
  Resolution: 300x300
  Print size: 6.83x6.83
[...]
  Compression: LZW
[...]
  Filesize: 70KB
[...]
-------------------------------------------------------------------------------------------------------
newXa <- sapply(xa, as.numeric)
hist(newXa) str(x) hist( x[['a']] ) str(x) hist( as.numeric(as.character(x[['a']]))  )
-------------------------------------------------------------------------------------------------------
hist(index$LogNR, breaks = 100, prob=T)
mean_DJ = mean(index$LogNR, na.rm=T);
sd_DJ = sd(index$LogNR, na.rm=T);
#For the normal curve
curve(dnorm(x, mean_DJ, sd_DJ), add=T, col = "grey", lwd = 2)
#For kernel density
lines(density(index$LogNR, na.rm=T), col = "blue", lwd = 2) index <- read.table(text="      Date  Close        LogNR
1  9/24/2012 690.79 -0.013373028
2  9/21/2012 700.09  0.001987433
3  9/20/2012 698.70 -0.004854378
4  9/19/2012 702.10  0.000270653
5  9/18/2012 701.91  0.003039191
6  9/17/2012 699.78  0.012221048
7  9/14/2012 691.28  0.012079375
8  9/13/2012 682.98  0.019501346
9  9/12/2012 669.79  0.013830855
10 9/11/2012 660.59 -0.003249381
11 9/10/2012 662.74 -0.026356891
12  9/7/2012 680.44  0.006147243
13  9/6/2012 676.27  0.008971468
14  9/5/2012 670.23 -0.007047308
15  9/4/2012 674.97  0.014520368
16 8/31/2012 665.24  0.002061531
17 8/30/2012 663.87 -0.014357104
18 8/29/2012 673.47 -0.001972899
19 8/28/2012 674.80 -0.001303241
20 8/27/2012 675.68  0.018612831
21 8/24/2012 663.22  0.000889995
22 8/23/2012 662.63 -0.009372956
23 8/22/2012 668.87  0.019337473
24 8/21/2012 656.06 -0.013760331
25 8/20/2012 665.15  0.025952144
26 8/17/2012 648.11  0.018327423
27 8/16/2012 636.34  0.008696599
28 8/15/2012 630.83 -0.001362355
29 8/14/2012 631.69  0.002678948
30 8/13/2012 630.00  0.013262158
", header=TRUE)
-------------------------------------------------------------------------------------------------------
?hist freq: logical; if ‘TRUE’, the histogram graphic is a representation
      of frequencies, the ‘counts’ component of the result; if
      ‘FALSE’, probability densities, component ‘density’, are
      plotted (so that the histogram has a total area of one).
      Defaults to ‘TRUE’ _if and only if_ ‘breaks’ are equidistant
      (and ‘probability’ is not specified). hist(dates, breaks = 7, freq = TRUE)
-------------------------------------------------------------------------------------------------------
par(mfrow=c(1,2))
d1 = rnorm(100);d2 = rnorm(100);
hist(d1);hist(d2) plot(density(d1))
lines(density(d2), col=2) hist(d1, freq=FALSE)
lines(density(d2), col=2)
-------------------------------------------------------------------------------------------------------
hist( dataset$column1), main = "title") paste("dataset$column" +i ) for (i in 1:4) {
    hist(dataset[,i]  , main ="title") 
 } for (i in 1:4) {
    hist(dataset[[paste0("column",i)]]  , main ="title") 
 }
-------------------------------------------------------------------------------------------------------
apply set.seed(001)
DF <- data.frame(column1=rnorm(100), 
                 column2=rnorm(100),
                 column3=rnorm(100),
                 column4=rnorm(100))

apply(DF, 2, hist)  # It produces one hist for each column for for(i in 1:ncol(DF)){
  hist(DF[, paste('column', i, sep='')],
       main=paste('Histogram', i))

}
-------------------------------------------------------------------------------------------------------
for + [[ $ for (i in 1:4) {
  hist( dataset[[ paste0("column", i ) ]]  , main ="title") 
}
-------------------------------------------------------------------------------------------------------
lapply() gsub() set.seed(001)
DF <- data.frame(Funky.Name.1 = rnorm(100),
                 Funky.Name.2 = rnorm(100),
                 Whoo.Whoo = rnorm(100),
                 Yee.Haw = rnorm(100))
lapply(names(DF), 
       function(x) hist(DF[, x], main = gsub("\\.", " ", x), xlab="Value")) par(mfrow = c(2, 2)) # par(mfrow = c(2, 2)) # 2x2 layout of all four Histograms
# lapply(names(DF), 
#        function(x) hist(DF[, x], main = gsub("\\.", " ", x), xlab="Value"))
# When you're done: dev.off()
-------------------------------------------------------------------------------------------------------
hist.default color_hist <- function(x, cats, xlab = xname, main = paste("Histogram of", xname), ...){
  xname <- paste(deparse(substitute(x), 500), collapse = "\n")
  hist <- hist(x, plot=FALSE, ...)
  cuts <- cut(x, breaks=hist$breaks)

  color = apply(table(cuts, cats), 1, which.max)

  hist(x, col=color, xlab = xlab, main = main, ...)
}

color_hist(iris[,4], iris[,5])
-------------------------------------------------------------------------------------------------------
sprintf main a <- "foo"
b <- "bar"
title <- sprintf("This combines %s and %s", a, b)
hist(rnorm(10), main = title) title <- sprintf("%s, (x-bar = %s)", death.cause[[i]], mean(outcome[, deathratecols[i]])
-------------------------------------------------------------------------------------------------------
hist density hist(x, prob=TRUE)
lines(density(x))
-------------------------------------------------------------------------------------------------------
x <- rnorm(1e6)  ## data forming your empirical distribution
ll <- -1.96      ## lower bound of interval of interest
ul <- 1.96       ## upper bound of interval of interest

sum(x > ll & x < ul)/length(x)
# [1] 0.949735 h <- hist(x, breaks=100, plot=FALSE)       # Calculate but don't plot histogram
maxct <- max(h$counts)                     # Extract height of the tallest bar
## Or, if you want the height of the tallest bar within the interval
# start <- findInterval(ll, h$breaks)
# end   <- findInterval(ul, h$breaks)
# maxct <- max(h$counts[start:end])

plot(h, ylim=c(0, 1.05*maxct), col="blue") # Plot, leaving a bit of space up top

rect(xleft = ll, ybottom = -0.02*maxct,    # Add box extending a bit above
     xright = ul, ytop = 1.02*maxct,       # and a bit below the bars
     border = "red", lwd = 2)
-------------------------------------------------------------------------------------------------------
set.seed(42) 
x <- rlnorm(5000) #some data
hist(x) #histogram
rect(7,-50,10,100,border="red") #red rectangle
table(cut(x,breaks=c(0,7,10,Inf)))/length(x) #fraction of values in intervals
#(0,7]    (7,10]   (10,Inf] 
#0.9754   0.0136   0.0110 Cut table length(x)
-------------------------------------------------------------------------------------------------------
# Exact
data.set <- c(7,7,8,8,7,8,9)
samps <- combn(data.set, 2)
xbars <- colMeans(samps)
table(xbars)
prop.table(table(xbars))
barplot(table(xbars))

# Simulated
data.set <- c(7,7,8,8,7,8,9)
out <- replicate( 10000, mean( sample(data.set, 2) ) )
prop.table(table(out))
hist(out)
-------------------------------------------------------------------------------------------------------
hist d <- read.csv('https://dl.dropbox.com/u/22681355/diff.csv', header=TRUE, row.names=1)
with(d, hist(a, breaks=seq(min(a), max(a), length.out=100)))
-------------------------------------------------------------------------------------------------------
plot.stacked plot.stacked <- function(x,y, ylab="", xlab="", ncol=1, xlim=range(x, na.rm=T), ylim=c(0, 1.2*max(rowSums(y), na.rm=T)), border = NULL, col=rainbow(length(y[1,]))){

    plot(x,y[,1], ylab=ylab, xlab=xlab, ylim=ylim, xaxs="i", yaxs="i", xlim=xlim, t="n")
    bottom=0*y[,1]
    for(i in 1:length(y[1,])){
        top=rowSums(as.matrix(y[,1:i]))
        polygon(c(x, rev(x)), c(top, rev(bottom)), border=border, col=col[i])
        bottom=top
    }
    abline(h=seq(0,200000, 10000), lty=3, col="grey")
    legend("topleft", rev(colnames(y)), ncol=ncol, inset = 0, fill=rev(col), bty="0", bg="white", cex=0.8, col=col)
    box()
} set.seed(1)
m <- 500
n <- 15
x <- seq(m)
y <- matrix(0, nrow=m, ncol=n)
colnames(y) <- seq(n)
for(i in seq(ncol(y))){
    mu <- runif(1, min=0.25*m, max=0.75*m)
    SD <- runif(1, min=5, max=30)
    TMP <- rnorm(1000, mean=mu, sd=SD)
    HIST <- hist(TMP, breaks=c(0,x), plot=FALSE)
    fit <- smooth.spline(HIST$counts ~ HIST$mids)
    y[,i] <- fit$y
}

    plot.stacked(x,y) plot.stream library(devtools)
source_url('https://gist.github.com/menugget/7864454/raw/f698da873766347d837865eecfa726cdf52a6c40/plot.stream.4.R')

set.seed(1)
m <- 500
n <- 50
x <- seq(m)
y <- matrix(0, nrow=m, ncol=n)
colnames(y) <- seq(n)
for(i in seq(ncol(y))){
    mu <- runif(1, min=0.25*m, max=0.75*m)
    SD <- runif(1, min=5, max=30)
    TMP <- rnorm(1000, mean=mu, sd=SD)
    HIST <- hist(TMP, breaks=c(0,x), plot=FALSE)
    fit <- smooth.spline(HIST$counts ~ HIST$mids)
    y[,i] <- fit$y
}
y <- replace(y, y<0.01, 0)

#order by when 1st value occurs
ord <- order(apply(y, 2, function(r) min(which(r>0))))
y2 <- y[, ord]
COLS <- rainbow(ncol(y2))

png("stream.png", res=400, units="in", width=12, height=4)
par(mar=c(0,0,0,0), bty="n")
plot.stream(x,y2, axes=FALSE, xlim=c(100, 400), xaxs="i", center=TRUE, spar=0.2, frac.rand=0.1, col=COLS, border=1, lwd=0.1)
dev.off() #plot.stream makes a "stream plot" where each y series is plotted 
#as stacked filled polygons on alternating sides of a baseline.
#
#Arguments include:
#'x' - a vector of values
#'y' - a matrix of data series (columns) corresponding to x
#'order.method' = c("as.is", "max", "first") 
#  "as.is" - plot in order of y column
#  "max" - plot in order of when each y series reaches maximum value
#  "first" - plot in order of when each y series first value > 0
#'center' - if TRUE, the stacked polygons will be centered so that the middle,
#i.e. baseline ("g0"), of the stream is approximately equal to zero. 
#Centering is done before the addition of random wiggle to the baseline. 
#'frac.rand' - fraction of the overall data "stream" range used to define the range of
#random wiggle (uniform distrubution) to be added to the baseline 'g0'
#'spar' - setting for smooth.spline function to make a smoothed version of baseline "g0"
#'col' - fill colors for polygons corresponding to y columns (will recycle)
#'border' - border colors for polygons corresponding to y columns (will recycle) (see ?polygon for details)
#'lwd' - border line width for polygons corresponding to y columns (will recycle)
#'...' - other plot arguments
plot.stream <- function(
    x, y, 
    order.method = "as.is", frac.rand=0.1, spar=0.2,
    center=TRUE,
    ylab="", xlab="",  
    border = NULL, lwd=1, 
    col=rainbow(length(y[1,])),
    ylim=NULL, 
    ...
){

if(sum(y < 0) > 0) error("y cannot contain negative numbers")

if(is.null(border)) border <- par("fg")
border <- as.vector(matrix(border, nrow=ncol(y), ncol=1))
col <- as.vector(matrix(col, nrow=ncol(y), ncol=1))
lwd <- as.vector(matrix(lwd, nrow=ncol(y), ncol=1))

if(order.method == "max") {
    ord <- order(apply(y, 2, which.max))
    y <- y[, ord]
    col <- col[ord]
    border <- border[ord]
}

if(order.method == "first") {
    ord <- order(apply(y, 2, function(x) min(which(r>0))))
    y <- y[, ord]
    col <- col[ord]
    border <- border[ord]
}

bottom.old <- x*0
top.old <- x*0
polys <- vector(mode="list", ncol(y))
for(i in seq(polys)){
    if(i %% 2 == 1){ #if odd
        top.new <- top.old + y[,i]
        polys[[i]] <- list(x=c(x, rev(x)), y=c(top.old, rev(top.new)))
        top.old <- top.new
    }
    if(i %% 2 == 0){ #if even
        bottom.new <- bottom.old - y[,i]
        polys[[i]] <- list(x=c(x, rev(x)), y=c(bottom.old, rev(bottom.new)))
        bottom.old <- bottom.new
    }
}

ylim.tmp <- range(sapply(polys, function(x) range(x$y, na.rm=TRUE)), na.rm=TRUE)
outer.lims <- sapply(polys, function(r) rev(r$y[(length(r$y)/2+1):length(r$y)]))
mid <- apply(outer.lims, 1, function(r) mean(c(max(r, na.rm=TRUE), min(r, na.rm=TRUE)), na.rm=TRUE))

#center and wiggle
if(center) {
    g0 <- -mid + runif(length(x), min=frac.rand*ylim.tmp[1], max=frac.rand*ylim.tmp[2])
} else {
    g0 <- runif(length(x), min=frac.rand*ylim.tmp[1], max=frac.rand*ylim.tmp[2])
}

fit <- smooth.spline(g0 ~ x, spar=spar)

for(i in seq(polys)){
    polys[[i]]$y <- polys[[i]]$y + c(fit$y, rev(fit$y))
}

if(is.null(ylim)) ylim <- range(sapply(polys, function(x) range(x$y, na.rm=TRUE)), na.rm=TRUE)
plot(x,y[,1], ylab=ylab, xlab=xlab, ylim=ylim, t="n", ...)
for(i in seq(polys)){
    polygon(polys[[i]], border=border[i], col=col[i], lwd=lwd[i])
}

}
-------------------------------------------------------------------------------------------------------
df <- read.table(text="Year Jan Feb Mar Apr May June July Aug Sept Oct Nov Dec     
2011 4.5 5.6 5.0 5.4 5.0 5.0  5.2  5.3 4.8  5.4 5.4 3.8     
2010 4.6 5.0 5.8 5.0 5.2 4.5  4.4  4.3 4.9  5.2 5.2 4.6     
2009 4.5 5.3 4.3 3.9 4.7 5.0  4.8  4.7 4.9  5.6 4.9 4.1     
2008 3.8 1.9 5.6 4.7 4.7 4.3  5.9  4.9 4.9  5.6 5.2 4.4     
2007 4.6 4.6 4.6 5.6 4.2 3.6  2.5  2.5 2.5  3.3 5.6 1.5     
2006 4.3 4.8 5.0 5.2 4.7 4.6  3.2  3.4 3.6  3.9 5.9 4.4     
2005 2.7 4.3 5.7 4.7 4.6 5.0  5.6  5.0 4.9  5.9 5.6 1.8",header=TRUE)
#look at ?read.csv to learn how to read your data from a CSV file

#transform data.frame into long format
library(reshape2)
df <- melt(df,id="Year",variable.name = "Month",value.name = "Speed")

#plot boxplots per month
plot(Speed~Month,data=df) #histogram for January
hist(df$Speed[df$Month=="Jan"],main="Max wind speed in January",xlab="Speed") #histogram for 2011
hist(df$Speed[df$Year==2011],main="Max wind speed in 2011",xlab="Speed") #create actual dates
df$Month2 <- factor(df$Month)
levels(df$Month2) <- 1:12
df <- transform(df,Time = as.Date(paste(Year,Month2,"15",sep="-"),'%Y-%m-%d'))
#plot Speed vs Time
plot(Speed~Time,data=df[order(df$Time),],type="l")
-------------------------------------------------------------------------------------------------------
a <- rnorm(1000)
h <- hist(a)
barplot(h$counts, names=h$mids) barplot(df$Count, names=df$Year)
-------------------------------------------------------------------------------------------------------
data <- c(rnorm(100,mean=20),rnorm(100,mean=12))

peakfinder <- function(d){
  dh <- hist(d,plot=FALSE)
  ins <- dh[["intensities"]]
  nbins <- length(ins)
  ss <- which(rank(ins)%in%seq(from=nbins-2,to=nbins)) ## pick the top 3 intensities
  dh[["mids"]][ss]
}

peaks <- peakfinder(data)

hist(data)
sapply(peaks,function(x) abline(v=x,col="red"))
-------------------------------------------------------------------------------------------------------
breaks min(x) max(x) x <- read.table(textConnection("
0.0707526823
0.4859753978
0.0084166789
0.0694709558
0.0156410467
0.3783259831
0.8977261856
0.7981824881
0.2079852045
0.9498437264
0.9264972044
0.1878358734
0.0020816686
0.0024611297
0.4250464895
0.0725748666
0.0407962054
0.8282363221
0.8408343333
0.7129760016
0.2772250135
0.3677588953
0.4723908637
0.9452814318"))
#extract vector of numeric from current data frame
x <- x$V1
#create breaks for frequency
#need to add a padding factor to make things equally spaced
step <- .1
pad <- step - ((max(x) - min(x)) %% step)/2
breaks <- seq(min(x) - pad, max(x) + pad,by=.1)
#alternative (only good for exact decimal increments):
#use floor and ceiling
breaks <- floor(min(x)*10):ceiling(max(x)*10)/10
#create histogram
#equally spaced breaks create frequency chart automatically
hist(x,breaks)
-------------------------------------------------------------------------------------------------------
hist sample table table(d)
#    1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16 
# 1003  967  938  958  989  969  988  956  983  990  921 1001  982 1016 1013  959 
#   17   18   19   20   21   22   23   24   25   26   27   28   29   30   31 
#  907  918  918  991  931  945  998 1017 1029  980  959  886  947  987  954 hist hist(d, breaks = 0:31)
-------------------------------------------------------------------------------------------------------
dat <- c(15562,15562,15562,15562,15563,15564,15564,15564,15566,15566,15566,15566)
table(table(dat))
#1 3 4 
#1 1 2

#example with more data
set.seed(42)
dat <- sample(1:500,50000,TRUE)
hist(table(table(dat)),breaks=20)
-------------------------------------------------------------------------------------------------------
x <- c(170,295,200,165,140,190,195,142,138,148,110,140,103,
       176,125,126,204,196,98,123,124,152,177,168,175,186,140,
       147,174,155,195) 

hist(x) c() hist()
-------------------------------------------------------------------------------------------------------
c() dat <- c(170,295,200,165,140,190,195,142,138,148,110,140,103,176,125,126,204,
         196,98,123,124,152,177,168,175,186,140,147,174,155,195)
hist(dat)
-------------------------------------------------------------------------------------------------------
colors = rainbow(length(unique(data)));
 hist(data, col=colors[data])
-------------------------------------------------------------------------------------------------------
hist() graphics add plot( my.df$x, my.df$cdf * 100, type= "l" )
hist( my.df$x, add= T )
-------------------------------------------------------------------------------------------------------
m <- mtcars[1:20, ];
m$br <- cut(m$mpg,hist(m$mpg,5,plot=F)$breaks);
mean.wt <- tapply(m$wt,m$br,mean);
m2 <- data.frame(mpg.bin=names(mean.wt),mean.wt);
ggplot(m2,aes(x=mpg.bin,y=mean.wt)) + geom_bar();
-------------------------------------------------------------------------------------------------------
freq = FALSE points lines hist(expRandom, freq = FALSE)
points(x,y) y curve hist(expRandom, freq = FALSE)
curve(dexp, from = 0, to  = 10, add = TRUE)
-------------------------------------------------------------------------------------------------------
par family ?par old.params <- par(family = "mono")

plot(cars)
hist(islands) par(old.params)
-------------------------------------------------------------------------------------------------------
hist() mids sample_avg <- sample(size=10000,x=seq(1,6),replace=TRUE)
foo <- hist(sample_avg, breaks =7, ylim=c(0,2000), 
    main = 'Histogram of Sample Average for 1 Coin Flip', xlab= 'Sample Average',
    xaxt="n")
axis(side=1,at=foo$mids,labels=seq(1,5))
-------------------------------------------------------------------------------------------------------
mix2normal1 require(VGAM)
set.seed(12345)

# Create a binormal distribution with means 10 and 20
data <- c(rnorm(100, 10, 1.5), rnorm(200, 20, 3))

# Initial parameters for minimization algorithm
# You may want to create some logic to estimate this a priori... not always easy but possible
# m, m2: Means - s, s2: SDs - w: relative weight of the first distribution (the second is 1-w)
init.params <- list(m=5, m2=8, s=1, s2=1, w=0.5)

fit <<- vglm(data ~ 1, mix2normal1(equalsd=FALSE), 
                iphi=init.params$w, imu=init.params$m, imu2=init.params$m2, 
                isd1=init.params$s, isd2=init.params$s2)

# Calculated parameters
pars = as.vector(coef(fit))
w = logit(pars[1], inverse=TRUE)
m1 = pars[2]
sd1 = exp(pars[3])
m2 = pars[4]
sd2 = exp(pars[5])

# Plot an histogram of the data
hist(data, 30, col="black", freq=F)
# Superimpose the fitted distribution
x <- seq(0, 30, 0.1)
points(x, w*dnorm(x, m1, sd1)+(1-w)*dnorm(x,m2,sd2), "l", col="red", lwd=2) > m1
[1] 10.49236
> m2
[1] 20.06296
> sd1
[1] 1.792519
> sd2
[1] 2.877999
-------------------------------------------------------------------------------------------------------
probability=T probability=TRUE T TRUE x <- rgamma(327, 5, 3)

tmp <- hist(x, yaxt='n',ylab='Percent')
tmp2 <- pretty( tmp$counts/sum(tmp$counts)*100 )
axis(2, at=tmp2*sum(tmp$counts)/100, labels=tmp2)
-------------------------------------------------------------------------------------------------------
a<-c(1,1,2,3,3,3,3,4,54,56,2,23,1,3,23)
par(mfrow=c(1,2)) 
hist(a) 

graphics::legend(x=10,y=10,c(">0%",">20%",">40%",">60%",">80%"), 
                 x.intersp=1,y.intersp=1,cex=c(1),bty="n",
                 fill=c("black","gray50","gray70","gray85","white"),
             #    pch=c(24,22,21,23,25),
                 pt.cex = c(2,2,2,2,5), 
                 lwd=1.5,title='Histo fill option') 

hist(a) 

graphics::legend(x=10,y=10,c(">0%",">20%",">40%",">60%",">80%"), 
       x.intersp=1,y.intersp=1,cex=c(1),bty="n",
       pch=c(24,22,21,23,25),
       pt.cex = c(1,2,3,3,4), 
       lwd=1.5, title = 'Histo whithout fill ')
-------------------------------------------------------------------------------------------------------
legend box.cex y.intersp source("http://www.math.mcmaster.ca/bolker/R/misc/legendx.R")
a<-c(1,1,2,3,3,3,3,4,54,56,2,23,1,3,23)
cex <- 1
hist(a)
legend("topright",c(">0%",">20%",">40%",">60%",">80%"),
       bty="n",
       fill=c("black","gray50","gray70","gray85","white"),
       box.cex=c(3,3),
       y.intersp=2.8)
-------------------------------------------------------------------------------------------------------
rasterImage rasterImage par('usr') grconvertX grconvertY rasterImage add=TRUE tmp <- rnorm(100)
hist(tmp)
image <- as.raster(matrix(0:1, ncol=5, nrow=3))
tmp2 <- par('usr')
rasterImage(image, tmp2[1], tmp2[3], tmp2[2], tmp2[4])
hist(tmp, add=TRUE, border='red', lwd=3)
-------------------------------------------------------------------------------------------------------
library(Rcpp)
cppFunction('
  std::vector<int> bin3(NumericVector x, double width, double origin = 0) {
    int bin, nmissing = 0;
    std::vector<int> out;

    NumericVector::iterator x_it = x.begin(), x_end;
    for(; x_it != x.end(); ++x_it) {
      double val = *x_it;
      if (ISNAN(val)) {
        ++nmissing;
      } else {
        bin = (val - origin) / width;
        if (bin < 0) continue;

        // Make sure there\'s enough space
        if (bin >= out.size()) {
          out.resize(bin + 1);
        }
        ++out[bin];
      }
    }

    // Put missing values in the last position
    out.push_back(nmissing);
    return out;
  }
')

x8 <- runif(1e8)
system.time(bin3(x8, 1/100))
#   user  system elapsed 
#  1.373   0.000   1.373 hist system.time(hist(x8, breaks = 100, plot = F))
#   user  system elapsed 
#  7.281   1.362   8.669 bin3 # First we create some sample data, and bin each column

library(reshape2)
library(ggplot2)

df <- as.data.frame(replicate(5, runif(1e6)))
bins <- vapply(df, bin3, 1/100, FUN.VALUE = integer(100 + 1))

# Next we match up the bins with the breaks
binsdf <- data.frame(
  breaks = c(seq(0, 1, length = 100), NA),
  bins)

# Then melt and plot
binsm <- subset(melt(binsdf, id = "breaks"), !is.na(breaks))
qplot(breaks, value, data = binsm, geom = "line", colour = variable) bin3
-------------------------------------------------------------------------------------------------------
library(iplots)
data(Cars93)
iplot(Cars93$Horsepower, Cars93$MPG.city)
ihist(Cars93$Horsepower)
-------------------------------------------------------------------------------------------------------
knitr <<boring-plots, fig.width=4, fig.height=4, out.width='.4\\linewidth'>>=
## two plots side by side (option fig.show='hold')
par(mar=c(4,4,.1,.1),cex.lab=.95,cex.axis=.9,mgp=c(2,.7,0),tcl=-.3,las=1)
boxplot(x)
hist(x,main='')
@ \begin{r}

\end{r}
-------------------------------------------------------------------------------------------------------
xlab=""
ylab=""
log =""
xy <- xy.coords(x, y, xlab, ylab, log)
xlim1 <- range(xy$x[is.finite(xy$x)])
ylim1 <- range(xy$y[is.finite(xy$y)]) dd <- density(c(-20,rep(0,98),20))
plot(dd,xlim=xlim1,ylim=ylim1)
x <- rchisq(100, df = 4)
hist(x,xlim=xlim1,ylim=xlim1,prob=TRUE,add=TRUE)
-------------------------------------------------------------------------------------------------------
myPlot <- plot(density(m[,1])), main="", xlab="", ylab="", xlim =c(xmin, xmax), ylim = c(ymin, ymax)

par(new=TRUE)

hist(m[,3],xlim=c(min, max),ylim=c(min, max),prob=TRUE)
-------------------------------------------------------------------------------------------------------
A <- 1:13
B <- 1:26
C <- 1:26
D <- c(1:13, 27:40)

mymat <- expand.grid(A, B, C, D)
names(mymat) <- c("A", "B", "C", "D")
mymat <- as.matrix(mymat)
mymeans <- rowSums(mymat)/4 B <- 1:266
C <- 1:266
D <- c(1:133, 267:400)

for(A in 1:133) {
    mymat <- expand.grid(A, B, C, D)
    names(mymat) <- c("A", "B", "C", "D")
    mymat <- as.matrix(mymat)
    mymeans <- rowSums(mymat)/4
    write.table(mymat, file = paste("matrix", A, "txt", sep = "."))
    write.table(mymeans, file = paste("means", A, "txt", sep = "."))
    rm(mymat, mymeans)
} D n <- 1e7
A <- sample(133, size = n, replace= TRUE)
B <- sample(266, size = n, replace= TRUE)
C <- sample(266, size = n, replace= TRUE)
D <- sample(x = c(1:133, 267:400), size = n, replace= TRUE)
mymeans <- (A+B+C+D)/4 hist(mymeans)
-------------------------------------------------------------------------------------------------------
#this is how to create vectors of sequential integers integers in R
a <- c(1:33)
b <- c(1:33)
c <- c(1:33)
d <- c(1:33,267:300)

#this is how to create an empty vector
means <- rep(NA,length(a)*length(b)*length(c)*length(d))
#set up for a loop
i <- 1

#how you run a loop to perform this operation
for(j in 1:length(a)){
    for(k in 1:length(b)){
        for(l in 1:length(c)){
            for(m in 1:length(d)){
                y <- c(a[j],b[k],c[l],d[m])
                means[i] <- mean(y)
                i <- i+1
            }
        }
    }
}

#and to graph your output
hist(means, col='brown')
#lets put a mean line through the histogram
abline(v=mean(means), col='white', lwd=2)
-------------------------------------------------------------------------------------------------------
hist str(hist(dfrm$values))   #  same list as you find in the Values section of ?hist

> dfrm$grp <- cut(dfrm$value, breaks=hist(dfrm$value)$breaks)

> dfrm
  value     grp
1    21 (20,30]
2    53 (50,60]
3     1  (0,10]
4    43 (40,50]
5    56 (50,60]
-------------------------------------------------------------------------------------------------------
hist plot(hist(..)) pdf add=T plot = FALSE hist plot() set.seed(42)
p1 <- hist(rnorm(500,4), plot=  FALSE)                     # centered at 4
p2 <- hist(rnorm(500,6), plot = FALSE)    
                                             # centered at 6
pdf('foo.pdf')
plot( p1, col=rgb(0,0,1,1/4), xlim=c(0,10))  # first histogram
plot( p2, col=rgb(1,0,0,1/4), xlim=c(0,10), add=T)

dev.off()
-------------------------------------------------------------------------------------------------------
## Make some sample data
x <- sample(0:30, 200, replace=T, prob=15 - abs(15 - 0:30))
## Calculate and plot the two histograms
hcum <- h <- hist(x, plot=FALSE)
hcum$counts <- cumsum(hcum$counts)
plot(hcum, main="")
plot(h, add=T, col="grey")

## Plot the density and cumulative density
d <- density(x)
lines(x = d$x, y = d$y * length(x) * diff(h$breaks)[1], lwd = 2)
lines(x = d$x, y = cumsum(d$y)/max(cumsum(d$y)) * length(x), lwd = 2)
-------------------------------------------------------------------------------------------------------
Data <- c(rnorm(1000,5,10),sample(-10000:10000,10))
> summary(Data)
     Min.   1st Qu.    Median      Mean   3rd Qu.      Max. 
-9669.000    -2.119     5.332    85.430    12.460  9870.000 
hist(Data,xlim=c(-30,30),breaks=c(min(Data),seq(-30,30,by=5),max(Data))main="Center of Data") axis.break() plotrix require(plotrix)
 # rearrange data
 plotdata <- Data
 id <- plotdata < -30 | plotdata > 30
 plotdata[id] <- sign(plotdata[id])*35
 # plot histogram
 hist(plotdata,xlim=c(-40,40),breaks=c(-40,seq(-30,30,by=5),40),main="Untailed Data",xaxt='n')
 # Construct the X axis
 axis(1,
      at=c(-40,seq(-30,30,by=10),40),
      labels=c(min(Data),seq(-30,30,by=10),max(Data))
 )
 # add axis breaks
 axis.break(axis=1,breakpos=-35)
 axis.break(axis=1,breakpos=35) freq=TRUE hist()
-------------------------------------------------------------------------------------------------------
x <- c(1,1,2,1,2,3,3,3,4,4)
myhist <- hist(x)
myhistX <- myhist$mids
myhistY <- myhist$density plot(myhistY~myhistX)
-------------------------------------------------------------------------------------------------------
x <- qnorm( runif(50000, pnorm(-3), pnorm(3)) )
range(x)
hist(x)
-------------------------------------------------------------------------------------------------------
?grid par(las=1,bty="l")
h <- 
hist(bulkdata$discovered,breaks=bins,col='gray',ylab="Discovered",xlab="Year",main="",ylim=c(0,100),axes=FALSE)
yrs <- 1989:2012
yvals <- seq(0,100,by=10)
axis(1, at=yrs)
axis(2, at=yvals)
abline(h=yvals,v=yrs,col="gray",lty=3)
hist(bulkdata$discovered,breaks=bins,col='gray',ylab="Discovered",xlab="Year",main="", add=TRUE)
-------------------------------------------------------------------------------------------------------
//using STATCONNECTORCLNTLib; 
StatConnector test1 = new StatConnectorClass(); 
test1.Init("R"); 
test1.Evaluate("x <- rnorm(20)"); 
test1.EvaluateNoReturn("hist(x)");
-------------------------------------------------------------------------------------------------------
set.seed(42)
x <- rnorm(1000)
hist(x,breaks="FD")

library(ggplot2)
breaks <- pretty(range(x), n = nclass.FD(x), min.n = 1)
bwidth <- breaks[2]-breaks[1]
df <- data.frame(x)
ggplot(df,aes(x))+geom_histogram(binwidth=bwidth,fill="white",colour="black")
-------------------------------------------------------------------------------------------------------
matplotlibrc xtick.direction : out ytick.direction : out import numpy as np
import matplotlib
import matplotlib.pyplot as plt
# Data to be represented
X = np.random.randn(256)

# Actual plotting
fig = plt.figure(figsize=(8,6), dpi=72, facecolor="white")
axes = plt.subplot(111)
heights, positions, patches = axes.hist(X, color='white')

axes.spines['right'].set_color('none')
axes.spines['top'].set_color('none')
axes.xaxis.set_ticks_position('bottom')

# was: axes.spines['bottom'].set_position(('data',1.1*X.min()))
axes.spines['bottom'].set_position(('axes', -0.05))
axes.yaxis.set_ticks_position('left')
axes.spines['left'].set_position(('axes', -0.05))

axes.set_xlim([np.floor(positions.min()), np.ceil(positions.max())])
axes.set_ylim([0,70])
axes.xaxis.grid(False)
axes.yaxis.grid(False)
fig.tight_layout()
plt.show() axes.spines['bottom'].set_position?

-------------------------------------------------------------------------------------------------------
breaks hist(dataset,breaks=rep(1:7,each=2)+c(-.4,.4))
 rep(1:7,each=2) c(-.49,.49) c(-.3,.3) c(-.5,.5) breaks > rep(1:7,each=2)
 [1] 1 1 2 2 3 3 4 4 5 5 6 6 7 7 > c(-.4,.4)
 [1] -0.4  0.4 1-0.4  1+0.4  2-0.4  2+0.4  3-0.4  3+0.4 [etc.]
=   0.6    1.4    1.6    2.4    2.6    3.4 [etc.]
-------------------------------------------------------------------------------------------------------
hist(dataset, breaks=seq(min(dataset)-0.5, max(dataset)+0.5, by=1)  ) require(lattice) 
barchart(table(dataset), horizontal=FALSE) barplot(table(dataset))
-------------------------------------------------------------------------------------------------------
identify() iplots identify() plot() data(cars)
plot(cars)
interesting <- identify(cars) cars[interesting,]
#    speed dist
# 19    13   46
# 23    14   80
# 44    22   66 iplots library(iplots)
data(iris)
iplot(iris$Sepal.Length,iris$Petal.Length)
ihist(iris$Sepal.Width) iset.selected() iris[iset.selected(),]
#     Sepal.Length Sepal.Width Petal.Length Petal.Width    Species
# 85           5.4         3.0          4.5         1.5 versicolor
# 91           5.5         2.6          4.4         1.2 versicolor
# 54           5.5         2.3          4.0         1.3 versicolor
# etc iplot() identify()
-------------------------------------------------------------------------------------------------------
?hist all(diff(breaks) == 1) hist(c(1,1,3,3 -3.5,-3.5, msum2),breaks=bins, freq= FALSE, right=FALSE) hist(msum2,breaks=bins, freq= FALSE, right=FALSE, xaxt="n")
axis(1,at=bins,labels=bins) x <- seq(-4, 4, length=100) `lines(x,dnorm(x))`
-------------------------------------------------------------------------------------------------------
set.seed(1)
x <- rnorm(1000)
hist(x, las=1)

par(new=TRUE)   
plot(density(x), col=2, yaxt="n", xaxt="n",
     bty='n', xlab="", ylab="", main='')
axis(4, las=1)
-------------------------------------------------------------------------------------------------------
x <- rnorm(1000)
hist(x)
curve(dnorm, col = 2, add = TRUE)
-------------------------------------------------------------------------------------------------------
population_mean <- 0
population_sd <- 1
n <- 1000
x <- rnorm(n, population_mean, population_sd) x qnorm population_x <- seq(
  qnorm(0.001, population_mean, population_sd), 
  qnorm(0.999, population_mean, population_sd), 
  length.out = 1000
) binwidth <- 0.5
breaks <- seq(floor(min(x)), ceiling(max(x)), binwidth) hist(x, breaks) lines(
  population_x, 
  n * dnorm(population_x, population_mean, population_sd) * binwidth, 
  col = "red"
) sample_mean <- mean(x)
sample_sd <- sd(x)
sample_x <- seq(
  qnorm(0.001, sample_mean, sample_sd), 
  qnorm(0.999, sample_mean, sample_sd), 
  length.out = 1000
)
lines(
  population_x, 
  n * dnorm(sample_x, sample_mean, sample_sd) * binwidth, 
  col = "blue"
)
-------------------------------------------------------------------------------------------------------
hist plot=FALSE hist h h$counts breaks > x
 [1] 10.10 46.65 53.60 38.50 45.95 12.25 59.60 23.30 11.05 58.35 40.20 11.05 10.45 26.45 13.25 21.15 35.00 29.05 25.40 47.20
[21] 42.45 57.30 55.65 56.50 26.95 59.65 32.10 29.00 34.75 21.65
> h <- hist(x, plot=FALSE, breaks = c(10,20,30,40,50,60))
> h
$breaks
[1] 10 20 30 40 50 60

$counts
[1] 6 8 4 5 7

$intensities
[1] 0.02000000 0.02666667 0.01333333 0.01666667 0.02333333

$density
[1] 0.02000000 0.02666667 0.01333333 0.01666667 0.02333333

$mids
[1] 15 25 35 45 55

$xname
[1] "x"

$equidist
[1] TRUE

attr(,"class")
[1] "histogram"
> h$counts 
[1] 6 8 4 5 7 hist plot=FALSE > h2 <- hist(x, plot=FALSE)
> h2$breaks
[1] 10 20 30 40 50 60
> h2$counts
[1] 6 8 4 5 7
-------------------------------------------------------------------------------------------------------
correct_Hist <- hist(data[correct==1, 1], breaks=seq(5, 800, by=10), plot=FALSE) incorrect_Hist <- 
hist(data[correct==0, 1], breaks=seq(5, 800, by=10), plot=FALSE) correct_Bar_Values <- correct_Hist$counts / (correct_Hist$counts + incorrect_Hist$counts)
incorrect_Bar_Values <- incorrect_Hist$counts / (correct_Hist$counts + incorrect_Hist$counts) # The percentage of answers that were not correct
qplot(incorrect_Hist$mids,y=incorrect_Bar_Values, geom="bar", stat="identity", ylim=c(0,1))

# The percentage of answers that were correct
qplot(correct_Hist$mids,y=correct_Bar_Values, geom="bar", stat="identity", ylim=c(0,1))
-------------------------------------------------------------------------------------------------------
hist freq=FALSE breaks set.seed(1)
f1 <- rnorm(100, mean=0, sd=1)
f2 <- rnorm(100, mean=3, sd=3)
f3 <- rnorm(100, mean=4, sd=1)
f4 <- rnorm(100, mean=7, sd=3)

breaks <- pretty(c(f1, f2, f3, f4), n=20)
x11(width=4, height=8)
op <- par(mfcol=c(4,1))
hist(f1, freq=FALSE, breaks=breaks)
hist(f2, freq=FALSE, breaks=breaks)
hist(f3, freq=FALSE, breaks=breaks)
hist(f4, freq=FALSE, breaks=breaks)
par(op) t set.seed(1)

N <- 100
M <- 7
MEAN <- c(1:M)
SD <- MEAN*0.2+1
RES <- list()

for(i in seq(M)){
    RES[[i]] <- rnorm(N, mean=MEAN[[i]], sd=SD[[i]])
}


breaks <- pretty(unlist(RES), n=20)
x11(width=4, height=10)
op <- par(mfcol=c(M,1), mar=c(1,3,0,0), oma=c(3,2,1,1))
for(i in seq(M)){
    h1 <- hist(RES[[i]], breaks=breaks, plot=FALSE)
    plot(h1$mids, h1$densit, t="n", xlab="", ylab="", xaxt="n")
    grid()
    lines(h1$mids, h1$densit, t="S")
    text(par()$usr[1], par()$usr[3]+(par()$usr[4]-par()$usr[3])*0.9, labels=paste("t", i), pos=4)
    if(i == M){
        axis(1)
    } else {
        axis(1, labels=FALSE)
    }
}
mtext("Density", outer=TRUE, side=2, line=0)
par(op)
-------------------------------------------------------------------------------------------------------
hist(X[abs(X)<1])
hist(X[abs(X)<5])
hist(X[abs(X)<50])
hist(X) plot(ecdf(X)) boxplot(X)
-------------------------------------------------------------------------------------------------------
normal distribution mean=2 sd=2 # 1000 samples from normal(2,2)
x1 <- rnorm(1000, mean=2, sd=2) percentile rank cum.p <- c(1, 7, 12, 23, 41, 62, 73, 80, 92, 99)/100 scores # generating values similar to your x.
x <- c(t(quantile(x1, cum.p)))
> x
 [1] -2.1870396 -1.4707273 -1.1535935 -0.8265444 -0.2888791  
         0.2781699  0.5893503  0.8396868  1.4222489  2.1519328 x cum.p PercRank x1 diff prob <- c( cum.p[1], diff(cum.p), .01)
> prob
# [1] 0.01 0.06 0.05 0.11 0.18 0.21 0.11 0.07 0.12 0.07 0.01 (x[1]:x[2], x[2]:x[3] ...) freq <- 10000 # final output size that we want

# Extreme values beyond x (to sample)
init <- -(abs(min(x)) + 5) 
fin  <- abs(max(x)) + 5

ival <- c(init, x, fin) # generate the sequence to take pairs from
len <- 100 # sequence of each pair

s <- sapply(2:length(ival), function(i) {
    seq(ival[i-1], ival[i], length.out=len)
})
# sample from s, total of 10000 values with probabilities calculated above
out <- sample(s, freq, prob=rep(prob, each=len), replace = T) > hist(out) > c(mean(out), sd(out))
# [1] 1.954834 2.170683 mean = 1.95 sd = 2.17 (~ 2) @Dwin's x = 1:10 cum.p <- c(1, 7, 12, 23, 41, 62, 73, 80, 92, 99)/100
prob <- c( cum.p[1], diff(cum.p), .01)
x <- 1:10

freq <- 10000 # final output size that we want

# Extreme values beyond x (to sample)
init <- -(abs(min(x)) + 1) 
fin  <- abs(max(x)) + 1

ival <- c(init, x, fin) # generate the sequence to take pairs from
len <- 100 # sequence of each pair

s <- sapply(2:length(ival), function(i) {
    seq(ival[i-1], ival[i], length.out=len)
})
# sample from s, total of 10000 values with probabilities calculated above
out <- sample(s, freq, prob=rep(prob, each=len), replace = T)

> quantile(out, cum.p) # ~ => x = 1:10
# 1%     7%    12%    23%    41%    62%    73%    80%    92%    99% 
# 0.878  1.989  2.989  4.020  5.010  6.030  7.030  8.020  9.050 10.010 

> hist(out)
-------------------------------------------------------------------------------------------------------
x r <- runif(1000, min=500, max=700) idx <- sample(10000, 1000) x[ idx ] <- r hist(x)
-------------------------------------------------------------------------------------------------------
max(hist(data$myo_activity, breaks=seq(range_Min, range_Max, by=bin_Width), plot=FALSE)$counts) range_Min range_Max bin_Width
-------------------------------------------------------------------------------------------------------
mtcars mtcars <%=
evalsOptions('width', width)
evalsOptions('height', height)
%>

# Histogram

<%=
set.caption(paste('Histogram of', var.name))
hist(var, breaks=seq(min(var), max(var), diff(range(var))/round(binwidth)), main = paste('Histogram of', var.name), xlab = '')
%>

## Parameters

Provided parameters were:

  * variable: <%=var.name%> (<%=var.label%>)
  * bin-width of histogram: <%=binwidth%>
  * height of generated images: <%=height%>
  * width of generated images: <%=width%>

# Kernel density plot

<%=
set.caption('A kernel density plot')
plot(density(var), main = '', xlab = '')
%> <%=hist(var, breaks=seq(min(var), max(var), diff(range(var))/round(binwidth)))%> numeric number binwidth
-------------------------------------------------------------------------------------------------------
countfun <- function(x,...) {
  res <- hist(x,plot=FALSE,...)
  data.frame(counts=res$counts,
             break1=res$breaks[-length(res$breaks)],
             break2=res$breaks[-1])
}

library(plyr)
plot.dat <- ddply(my.data,.(Visibility),function(df){
  res <- ddply(df,.(correct),function(df2) {countfun(df2$RT,breaks=seq(100, 600, by=10))})
  res$freq2 <- res$counts/nrow(df)
  res
}) parse eval as.formula hist
-------------------------------------------------------------------------------------------------------
tkexamp library(TeachingDemos)

myhist <- function(x, s.width, e.width, ...) {
    if( missing(e.width) || is.null(e.width) || is.na(e.width) ) {
        e.width<- s.width
    }
    b <- seq( min(x)-e.width/2, max(x)+e.width, by=e.width )
    hist(x, b, ...)
}

mylist <- list( s.width=list('slider', init=1, from=1, to=10, resolution=1),
    e.width=list('numentry', init='', width=7)
)

sampdata <- rnorm(100, 50, 5)
tkexamp(myhist(sampdata), mylist) mylist tkrplot mytkhist <- function(x, ...) {

    width <- tclVar()
    tclvalue(width) <- 1

    replot <- function(...) {
        width <- as.numeric(tclvalue(width))
        b <- seq( min(x) - width/2, max(x)+width, by=width )
        hist(x,b,...)
    }

    tt <- tktoplevel()
    img <- tkrplot(tt, replot)
    tkpack(img, side='top')

    tkpack( tkscale(tt, variable=width, from=1, to=10,
        command=function(...) tkrreplot(img),
        orient='horizontal'), side='top' )
    tkpack( e <- tkentry(tt, textvariable=width), side='top' )
    tkbind(e, "<KeyRelease>", function(...) tkrreplot(img))
}

mytkhist(sampdata) assign command tkscale tkbind
-------------------------------------------------------------------------------------------------------
add hist ?hist ?plot.histogram hist(rnorm(1000, mean=0.2, sd=0.1), col='blue', xlim=c(0, 1))
hist(rnorm(1000, mean=0.8, sd=0.1), col='red', add=T) add ?hist ... plot.histogram add ?plot.histogram ?hist add
-------------------------------------------------------------------------------------------------------
RelativeHistRT <- function (df, breaks = seq(5,800,10)) 
{
  distrib.correct   = hist(df$RT[df$correct==1], breaks, right=FALSE, plot=FALSE)
  distrib.incorrect = hist(df$RT[df$correct==0], breaks, right=FALSE, plot=FALSE)

  n.total = sum(distrib.correct$counts) + sum(distrib.incorrect$counts)

  data.frame(bin_mids  = distrib.correct$mids,
         correct   = distrib.correct$counts / n.total,
         incorrect = distrib.incorrect$counts / n.total)
} myhistRTcounts <- ddply(my.data, .(subjectname,Visibility), RelativeHistRT)
-------------------------------------------------------------------------------------------------------
counts r<-sample(1:25000,1000)
hist.ob <- hist(r)
str(hist.ob)
List of 7
 $ breaks     : num [1:14] 0 2000 4000 6000 8000 10000 12000 14000 16000 18000 ...
 $ counts     : int [1:13] 75 46 72 91 71 91 74 87 86 82 ...
 $ intensities: num [1:13] 3.75e-05 2.30e-05 3.60e-05 4.55e-05 3.55e-05 4.55e-05 3.70e-05 4.35e-05 4.30e-05 4.10e-05 ...
 $ density    : num [1:13] 3.75e-05 2.30e-05 3.60e-05 4.55e-05 3.55e-05 4.55e-05 3.70e-05 4.35e-05 4.30e-05 4.10e-05 ...
 $ mids       : num [1:13] 1000 3000 5000 7000 9000 11000 13000 15000 17000 19000 ...
 $ xname      : chr "r"
 $ equidist   : logi TRUE
 - attr(*, "class")= chr "histogram" counts plot() hist.ob$counts<-hist.ob$counts/sum(hist.ob$counts)
plot(hist.ob)
-------------------------------------------------------------------------------------------------------
layout() matrix() plot.new() text() x<-1:10
par(mar=c(2.5,2.5,1,1))
layout(matrix(c(1,2,3,4,1,5,3,6),ncol=2),heights=c(1,3,1,3))
plot.new()
text(0.5,0.5,"First title",cex=2,font=2)
plot(x)
plot.new()
text(0.5,0.5,"Second title",cex=2,font=2)
hist(x)
boxplot(x)
barplot(x)
-------------------------------------------------------------------------------------------------------
hist f <- hist(r, breaks=30)
dat <- data.frame(counts= f$counts,breaks = f$mids)
ggplot(dat, aes(x = breaks, y = counts)) + 
  geom_bar(stat = "identity",fill='blue',alpha = 0.8)+
  xlab("Pearson correlation")+ ylab("Frequency")+
  scale_x_continuous(breaks = seq(-1,1,0.25),  ## without this you will get the same scale
                   labels = seq(-1,1,0.25))    ## as hist (question picture) scale_x_discrete ggplot(dat, aes(x = breaks, y = counts, fill =counts)) + ## Note the new aes fill here
  geom_bar(stat = "identity",alpha = 0.8)+
  xlab("Pearson correlation")+ ylab("Frequency")+
  scale_x_continuous(breaks = seq(-1,1,0.25),
                   labels = seq(-1,1,0.25))+
  scale_fill_gradient(low="blue", high="red")            ## to play with colors limits
-------------------------------------------------------------------------------------------------------
knitr R knitr \documentclass{report}
\begin{document}

<<results='asis', echo=FALSE>>=
for (tmp in 1:A) {
  cat(tmp)
}
@

<<results='asis', echo=FALSE>>=
for (tmp in 1:A) {
  cat(sprintf('\\includegraphics{%d.PNG}', tmp))
}
@
\end{document} \documentclass{report}
\begin{document}
\Sexpr{paste(1:A, collapse = '')}
\Sexpr{paste(sprintf('\\includegraphics{%d.PNG}', 1:A), collapse = '')}
\end{document} \includegraphics{} \documentclass{report}
\begin{document}
<<>>=
for (i in 1:5) {
  hist(mtcars[, i])
}
@
\end{document}
-------------------------------------------------------------------------------------------------------
test <- read.table(textConnection("age popperc
0-5 8
5-14 18
14-18 8
18-21 5
21-25 6
25-35 12
35-45 11
45-55 11
55-65 9
65-75 6
75-85 4"),header=TRUE,stringsAsFactors=FALSE)

midval <- sapply(strsplit(test$age,"-"),function(x) mean(as.numeric(x)))
breakval <- strsplit(test$age,"-")
breakval <- as.numeric(c(sapply(breakval,head,1),tail(unlist(breakval),1)))
hist(rep(midval,test$popperc),breaks=breakval) class plot # define the histogram object and plot it
histres <- list(
breaks=breakval,
counts=test$popperc,
mids=midval,
xname="ages",
equidist = TRUE
)
class(histres) <- "histogram"
plot(histres)
-------------------------------------------------------------------------------------------------------
hist( cumsum( mydata$BALANCE) )
-------------------------------------------------------------------------------------------------------
plot = FALSE hist set.seed(1)
x <- sample(300, 30)
x
#  [1]  80 112 171 270  60 266 278 194 184  18 296  52 198 111 221 142
# [17] 204 281 108 219 262 290 182  35  74 107   4 105 237  93
temp <- hist(x, plot = FALSE)$breaks
temp
# [1]   0  50 100 150 200 250 300
rowMeans(cbind(head(temp, -1),
               tail(temp, -1)))
# [1]  25  75 125 175 225 275 myVec <- c("735-739", "715-719", "690-694", "695-699", "695-699",
           "670-674", "720-724", "705-709", "685-689")
myVec
# [1] "735-739" "715-719" "690-694" "695-699" "695-699" "670-674"
# [7] "720-724" "705-709" "685-689"
sapply(strsplit(myVec, "-"), function(x) mean(as.numeric(x)))
# [1] 737 717 692 697 697 672 722 707 687
-------------------------------------------------------------------------------------------------------
x = rnorm(1000)
plot(density(x))
hist(x, freq=F, add=T)
-------------------------------------------------------------------------------------------------------
test <- rnorm(1000)
plot(density(test))
par(new=T)
hist(test, freq=F, xaxt="n", xlab="", ylab="", main="")
-------------------------------------------------------------------------------------------------------
data = rnorm(1000,0,1)
r <- hist(log(data))
plot(r$breaks[-1],log(r$counts)) r <- hist(data)
plot(r$breaks[-1], r$counts, log='xy', type='h')
# or alternatively:
barplot(r$counts, log="y", col="white", names.arg=r$breaks[-1])
-------------------------------------------------------------------------------------------------------
x <- c(4.399449e-02,  2.161474e-02, -1.515223e-05,  1.298059e+01,
      3.163949e-01, -1.785220e+00,  1.041053e+01,  6.327219e-01, -5.778590e-03)

hist(x,col="grey",freq=FALSE, breaks=10) 
d<-density(x)
lines(d,col="red") x <- rgamma(100,1,1)
-------------------------------------------------------------------------------------------------------
op <- par(mfrow=c(2, 2))
hist(islands,main=NULL)
title("Histogram of islands",adj=1)
utils::str(hist(islands, col="gray", labels = TRUE,main=NULL))
title("Histogram of islands",adj=1)
-------------------------------------------------------------------------------------------------------
ggplot2 reshape2 df <- data.frame(male=c(0,0,1,0,1),
                 female=c(1,1,0,0,0),
                 unknown=c(0,0,0,1,0))

df.m <- melt(df)
str(df.m)
hist(df.m$value ~ df.m$variable)
ggplot(df.m, aes(value)) + geom_histogram(aes(fill=variable)) +
  facet_wrap(~variable) #This depends on how you want your different variables split up. ggplot(df.m, aes(value)) + geom_histogram(aes(fill=variable), position="dodge")
-------------------------------------------------------------------------------------------------------
halfnormal <- function(n){
        vector <- rep(0,n)
        for(i in 1:n){
            uni_random <- runif(2) 
            y <- -log(uni_random)
            while(y[2] < (y[1]-1)^2/2){
                uni_random <- runif(2)
                y <- -log(uni_random)
            }
            vector[i] <- sample(c(-1,1),size=1)*y[1] #randomly select the tail
        }
        vector
    }

    output <- halfnormal(1000)
    hist(output)
-------------------------------------------------------------------------------------------------------
pushViewport(viewport(x=0, y=1, xscale=c(1, 10), yscale=c(0, 100), width=0.25, height=0.25, default.units="npc", just=c("left","bottom"), clip="off")) library(grid)

# Specify general chart options.
chart_Fill = "lemonchiffon"
chart_Col = "snow3"
space_Background = "white"
title_CEX = 0.8
axis_CEX = 0.6
chart_Width <- 3/3
chart_Height <- 2/5

# Function to initialize a plotting area.
init_Plot <- function(
    .df,
    .x_Loc, 
    .y_Loc, 
    .justify, 
    .width, 
    .height
    ){

    # Initialize plotting area to fit data.
    # We have to turn off clipping to make it
    # easy to plot the labels around the plot.
    pushViewport(viewport(xscale=c(min(.df[,1]), max(.df[,1])), yscale=c(min(0,min(.df[,-1])), max(.df[,-1])), x=.x_Loc, y=.y_Loc, width=.width, height=.height, just=.justify, clip="off", default.units="native"))

    # Color behind text.
    grid.rect(x=0, y=0, width=unit(axis_CEX, "lines"), height=1, default.units="npc", just=c("right", "bottom"), gp=gpar(fill=space_Background, col=space_Background))
    grid.rect(x=0, y=1, width=1, height=unit(title_CEX, "lines"), default.units="npc", just=c("left", "bottom"), gp=gpar(fill=space_Background, col=space_Background))

    # Color in the space.
    grid.rect(gp=gpar(fill=chart_Fill, col=chart_Col))
}

# Function to finalize and label a plotting area.
finalize_Plot <- function(
    .df, 
    .plot_Title
    ){

    # Label plot using the internal reference
    # system, instead of the parent window, so
    # we always have perfect placement.
    grid.text(.plot_Title, x=0.5, y=1.05, just=c("center","bottom"), rot=0, default.units="npc", gp=gpar(cex=title_CEX))
    grid.text(paste(names(.df)[-1], collapse=" & "), x=-0.05, y=0.5, just=c("center","bottom"), rot=90, default.units="npc", gp=gpar(cex=axis_CEX))
    grid.text(names(.df)[1], x=0.5, y=-0.05, just=c("center","top"), rot=0, default.units="npc", gp=gpar(cex=axis_CEX))

    # Finalize plotting area.
    popViewport()
}

# Function to plot a filled line chart of
# the data in a data frame.  The first column
# of the data frame is assumed to be the
# plotting index, with each column being a
# set of y-data to plot.  All data is assumed
# to be numeric.
plot_Line_Chart <- function(
    .df,
    .x_Loc,
    .y_Loc,
    .justify,
    .width,
    .height,
    .colors,
    .plot_Title
    ){

    # Initialize plot.
    init_Plot(.df, .x_Loc, .y_Loc, .justify, .width, .height)

    # Calculate what value to use as the
    # return for the polygons.
    y_Axis_Min <- min(0, min(.df[,-1]))

    # Plot each set of data as a polygon,
    # so we can fill it in with color to
    # make it easier to read.
    for (i in 2:ncol(.df)){
        grid.polygon(x=c(min(.df[,1]),.df[,1], max(.df[,1])), y=c(y_Axis_Min,.df[,i], y_Axis_Min), default.units="native", gp=gpar(fill=.colors[i-1], col=.colors[i-1], alpha=1/ncol(.df)))
    }

    # Draw plot axes.
    grid.lines(x=0, y=c(0,1), default.units="npc")
    grid.lines(x=c(0,1), y=0, default.units="npc")

    # Finalize plot.
    finalize_Plot(.df, .plot_Title)

}

# Function to plot a scatterplot of
# the data in a data frame.  The
# assumptions are the same as 'plot_Line_Chart'.
plot_Scatterplot <- function(
    .df,
    .x_Loc,
    .y_Loc,
    .justify,
    .width,
    .height,
    .colors,
    .plot_Title
    ){

    # Initialize plot.
    init_Plot(.df, .x_Loc, .y_Loc, .justify, .width, .height)

    # Plot each set of data as colored points.
    for (i in 2:ncol(.df)){
        grid.points(x=.df[,1], y=.df[,i], pch=19, size=unit(1, "native"), default.units="native", gp=gpar(col=.colors[i-1], alpha=1/ncol(.df)))
    }

    # Draw plot axes.
    grid.lines(x=0, y=c(0,1), default.units="npc")
    grid.lines(x=c(0,1), y=0, default.units="npc")

    # Finalize plot.
    finalize_Plot(.df, .plot_Title)

}

# Function to plot a histogram of
# all the columns in a data frame,
# except the first, which is assumed to
# be an index.
plot_Histogram <- function(
    .df,
    .x_Loc,
    .y_Loc,
    .justify,
    .width,
    .height,
    .colors,
    .plot_Title,
    ...
    ){

    # Create a list containing the histogram
    # data for each data column and calculate
    # data ranges.  Any extra parameters
    # specified will pass to the 'hist' function.
    hist_Data <- list()
    hist_Count_Range <- c(0,NA)
    hist_Breaks_Range <- c(NA,NA)
    for (i in 2:ncol(.df)){
        hist_Data[[i]] <- hist(.df[,i], plot=FALSE, ...)
        hist_Count_Range[2] <- max(max(hist_Data[[i]]$counts), hist_Count_Range[2], na.rm=TRUE)
        hist_Breaks_Range <- c(min(min(hist_Data[[i]]$breaks), hist_Breaks_Range[1], na.rm=TRUE), max(max(hist_Data[[i]]$breaks), hist_Breaks_Range[2], na.rm=TRUE))
    }


    # Initialize plotting area to fit data.
    # We are doing this in a custom way to
    # allow more flexibility than built into
    # the 'init_Plot' function.
    # We have to turn off clipping to make it
    # easy to plot the labels around the plot.
    pushViewport(viewport(xscale=hist_Breaks_Range, yscale=hist_Count_Range, x=.x_Loc, y=.y_Loc, width=.width, height=.height, just=.justify, clip="off", default.units="native"))

    # Color behind text.
    grid.rect(x=0, y=0, width=unit(axis_CEX, "lines"), height=1, default.units="npc", just=c("right", "bottom"), gp=gpar(fill=space_Background, col=space_Background))
    grid.rect(x=0, y=1, width=1, height=unit(title_CEX, "lines"), default.units="npc", just=c("left", "bottom"), gp=gpar(fill=space_Background, col=space_Background))

    # Color in the space.
    grid.rect(gp=gpar(fill=chart_Fill, col=chart_Col))


    # Draw x axis.
    grid.lines(x=c(0,1), y=0, default.units="npc")

    # Plot each set of data as a histogram.
    for (i in 2:ncol(.df)){
        grid.rect(x=hist_Data[[i]]$mids, y=0, width=diff(hist_Data[[i]]$mids[1:2]), height=hist_Data[[i]]$counts, default.units="native", just=c("center","bottom"), gp=gpar(fill=.colors[i-1], col=.colors[i-1], alpha=1/ncol(.df)))
    }

    # Label plot using the internal reference
    # system, instead of the parent window, so
    # we always have perfect placement.
    grid.text(.plot_Title, x=0.5, y=1.05, just=c("center","bottom"), rot=0, default.units="npc", gp=gpar(cex=title_CEX))
    grid.text(paste(names(.df)[-1], collapse=" & "), x=-0.05, y=0.5, just=c("center","bottom"), rot=90, default.units="npc", gp=gpar(cex=axis_CEX))

    # Finalize plotting area.
    popViewport()
}

draw_Sample_Box <- function(
    .x_Loc,
    .y_Loc,
    .x_Scale,
    .y_Scale,
    .justify,
    .width,
    .height,
    .colors,
    .box_X,
    .box_Y,
    .plot_Title
    ){

    pushViewport(viewport(xscale=.x_Scale, yscale=.y_Scale, x=.x_Loc, y=.y_Loc, width=chart_Width, height=chart_Height, just=.justify, clip="off", default.units="native"))

    # Color behind text.
    grid.rect(x=0, y=1, width=1, height=unit(title_CEX, "lines"), default.units="npc", just=c("left", "bottom"), gp=gpar(fill=space_Background, col=space_Background))

    # Color in the space.
    grid.rect(gp=gpar(fill=chart_Fill, col=chart_Col))

    # Label plot.
    grid.text(.plot_Title, x=0.5, y=1.05, just=c("center","bottom"), rot=0, default.units="npc", gp=gpar(cex=title_CEX))

    # Draw box and label points.
    grid.polygon(x=.box_X, y=.box_Y, default.units="native", gp=gpar(fill=.colors[1], col=.colors[2]))
    grid.text(paste(.plot_Title, 1, sep=""), x=min(.box_X), y=min(.box_Y), default.units="native", just=c("right","top"), gp=gpar(cex=0.5))
    grid.text(paste(.plot_Title, 2, sep=""), x=max(.box_X), y=min(.box_Y), default.units="native", just=c("left","top"), gp=gpar(cex=0.5))

    # Finalize plot.
    popViewport()
} # Draw twelve independent charts as
# a demo and connect with lines similar
# to a heiritage chart.
grid.newpage()

# Initialize a viewport to make our locations
# easier to map.
pushViewport(viewport(x=0, y=0, width=1, height=1, just=c("left","bottom"), xscale=c(0,10), yscale=c(0,4)))

# Color background of overall plot.
grid.rect(gp=gpar(fill=space_Background, col=space_Background))

# Store plot locations for convenience.
plot_Loc <- data.frame(x=c(2,4,6,8,1,3,7,9,2,4,6,8), y=c(3,3,3,3,2,2,2,2,1,1,1,1))

# Draw connecting lines.
connections <- data.frame(a=c(1, 3, 5, 6, 7, 1, 3, 5, 7, 6), b=c(2, 4, 6, 7, 8, 2, 4, 6, 8, 7), c=c(NA, NA, NA, NA, NA, 6, 7, 9, 12, 10), d=c(NA, NA, NA, NA, NA, NA, NA, NA, NA, 11))
for (i in 1:nrow(connections)){
    if (is.na(connections$c[i])){
        grid.lines(x=plot_Loc$x[unlist(connections[i,1:2])], y=plot_Loc$y[unlist(connections[i,1:2])], default.units="native")
    } else if (is.na(connections$d[i])) {
        grid.lines(x=median(plot_Loc$x[unlist(connections[i,1:2])]), y=plot_Loc$y[unlist(connections[i,2:3])], default.units="native")
    } else {
        grid.lines(x=median(plot_Loc$x[unlist(connections[i,1:2])]), y=c(plot_Loc$y[connections[i,2]], median(plot_Loc$y[unlist(connections[i,2:3])])), default.units="native")
        grid.lines(x=plot_Loc$x[unlist(connections[i,3:4])], y=median(plot_Loc$y[unlist(connections[i,2:3])]), default.units="native")
        grid.lines(x=plot_Loc$x[connections[i,3]], y=c(median(plot_Loc$y[unlist(connections[i,2:3])]), plot_Loc$y[connections[i,3]]), default.units="native")
        grid.lines(x=plot_Loc$x[connections[i,4]], y=c(median(plot_Loc$y[unlist(connections[i,2:3])]), plot_Loc$y[connections[i,4]]), default.units="native")
    }
}


# Draw four independent line charts.
p <- 1
plot_Line_Chart(data.frame(time=1:1860, EuStockMarkets)[1:3], .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("dodgerblue", "deeppink"), "EU Stocks")
p <- 2
plot_Line_Chart(data.frame(time=1:1860, EuStockMarkets)[c(1,4,5)], .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("green", "purple"), "EU Stocks")
p <- 3
plot_Line_Chart(data.frame(time=1:(12*20), sunspots=sunspot.month[(171*12+1):(171*12+12*20)]), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("darkgoldenrod"), "Sunspots")
p <- 4
plot_Line_Chart(data.frame(time=1:(12*20), temp=nottem), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("red"), "Nottem")

# Draw four independent scatterplots.
p <- 5
plot_Scatterplot(data.frame(time=1:(1860 + 1 - 1000), DAX=rowMeans(embed(EuStockMarkets[,1], 1000)), FTSE=rowMeans(embed(EuStockMarkets[,4], 1000))), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("deeppink", "purple"), "Smooth")
p <- 6
plot_Scatterplot(data.frame(time=1:1860, EuStockMarkets)[c(1,2,5)], .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("deeppink", "purple"), "EU Stocks")
p <- 9
plot_Scatterplot(data.frame(time=1:(1860 + 1 - 20), DAX=rowMeans(embed(EuStockMarkets[,1], 20)), FTSE=rowMeans(embed(EuStockMarkets[,4], 20))), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("deeppink", "purple"), "Smooth*20")
p <- 10
plot_Scatterplot(data.frame(time=1:(1860 + 1 - 100), DAX=rowMeans(embed(EuStockMarkets[,1], 100)), FTSE=rowMeans(embed(EuStockMarkets[,4], 100))), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("deeppink", "purple"), "Smooth*100")


# Draw two independent histograms.
p <- 7
plot_Histogram(data.frame(time=1:(12*20), sunspots=sunspot.month[(171*12+1):(171*12+12*20)]), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("darkgoldenrod"), "Sunspots", breaks=6)
p <- 8
plot_Histogram(data.frame(time=1:(12*20), temp=nottem), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("red"), "Nottem", breaks=6)

# Draw sample objects in two charts spaces.
p <- 11
draw_Sample_Box(.x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .x_Scale=c(0,10), .y_Scale=c(-10,0), .justify=c("center","center"), .width=chart_Width, .height=chart_Height, .colors=c("dodgerblue","blue"), .box_X=c(4,6,6,4), .box_Y=c(-4,-4,-5,-5), .plot_Title="K")
p <- 12
draw_Sample_Box(.x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .x_Scale=c(-1,1), .y_Scale=c(0,1), .justify=c("center","center"), .width=chart_Width, .height=chart_Height, .colors=c("dodgerblue","blue"), .box_X=c(-0.5,0,0,-0.5), .box_Y=c(0.8,0.8,0.7,0.7), .plot_Title="L")
-------------------------------------------------------------------------------------------------------
(X1,...,Xn) X1+...+Xn=s 1 0 0 ... 0 1
0 1 0 ... 0 1
0 0 1 ... 0 1
...
0 0 0 ... 1 1
1 1 1 ... 1 n. s <- 1  # Desired sum
n <- 10
mu1 <- rep(0,n)
mu2 <- 0
V11 <- diag(n)
V12 <- as.matrix(rep(1,n))
V21 <- t(V12)
V22 <- as.matrix(n)
mu <- mu1 + V12 %*% solve(V22, s - mu2)
V  <- V11 - V12 %*% solve(V22,V21)
library(mvtnorm)
# Random vectors (in each row)
x <- rmvnorm( 100, mu, V )
# Check the sum and the distribution
apply(x, 1, sum)
hist(x[,1])
qqnorm(x[,1]) x <- rexp(n)
x <- x / sum(x)  # Sums to 1, and each coordinate is uniform in [0,1] sum(pnorm(x)) sum(x) X pnorm(X) n <- 10
s <- 1  # Desired sum
p <- rexp(n)
p <- p / sum(p) * s  # Uniform, sums to s
x <- qnorm(p)        # Gaussian, the p-values sum to s
-------------------------------------------------------------------------------------------------------
plot() ## Function that reports actual call to itself (i.e. 'myPlot()') in plot title.
myPlot <- function(x,...) {
    cl <- deparse(sys.call())
    plot(x, main=cl, ...)
}

## Function that 'lies' and says that plot() (rather than myPlot2()) called it.
myPlot2 <- function(x,...) {
    cl <- sys.call()
    cl[[1]] <- as.symbol("plot")
    cl <- deparse(cl)
    plot(x, main=cl, ...)
}

## Try them out
x <- 1:10
y <- 1:10
par(mfcol=c(1,2))
myPlot(x,y)
myPlot2(y~x) plotCaller <- function(plotCall, ...) {
    main <- deparse(substitute(plotCall))
    main <- paste(main, collapse="\n")
    eval(as.call(c(as.list(substitute(plotCall)), main=main, ...)))
}

## Try _it_ out

plotCaller(hist(rnorm(9999), breaks=100, col="red"))

library(lattice)
plotCaller(xyplot(rnorm(10)~1:10, pch=16))

## plotCaller will also pass through additional arguments, so they take effect
## without being displayed
plotCaller(xyplot(rnorm(10)~1:10), pch=16) main <- paste(main, collapse='\n') \n plotCaller(hist(rnorm(9999), breaks=100, col="red", xlab="a rather long label",
    ylab="yet another long label"))
-------------------------------------------------------------------------------------------------------
par(fig=..., new=TRUE) x <- rnorm(100)
hist( x, col = "light blue" )
par( fig = c(.7, .95, .7, .95), mar=.1+c(0,0,0,0), new = TRUE )
qqnorm(x, axes=FALSE, xlab="", ylab="", main="")
qqline(x, col="blue", lwd=2)
box()
-------------------------------------------------------------------------------------------------------
par(mfrow=c(2,1)) bins <- seq(2, 4, by=0.1)

hist(results1, breaks=bins, xlim=c(2,4))
hist(results2, breaks=bins, xlim=c(2,4))
-------------------------------------------------------------------------------------------------------
apply AgeFn() sample y <- 1980       ## MedianYr
d <- 0.1        ## Rate of NA responses
agemin <- 14
agemax <- 90

# The stats guy in me thinks that you might have some
# methodological problems here with how the ages are assigned
# But I'm just going to stick with it for now
EduByAge <- function (Age, d) {
    ifelse(Age < 17, sample(c("Some High School",NA), size=1,prob=c((1-d),d)),
           ifelse(Age > 16 & Age < 19, sample(c("Some High School", "High School Grad",NA), size=1, prob=c(0.085, 0.604,d)),
                  ifelse(Age > 18 & Age < 21, sample(c("Some High School", "High School Grad", "Associates",NA), size=1,prob=c(0.085, 0.25, 0.354,d)),
                         ifelse(20 > Age & Age < 23, sample(c("Some High School", "High School Grad", "Associates", "Bachelors",NA), size=1,prob=c(0.085, 0.25, 0.075, 0.279,d)),
                                ifelse(Age > 22, sample(c("Some High School", "High School Grad", "Associates", "Bachelors", "Masters", "Professional", "Doctorate",NA),size=1,prob=c(0.085, 0.25, 0.075, 0.176, 0.072, 0.019, 0.012,d)), NA)))))
}

NewUserGen <- function(n,s) {

    set.seed(s)

    ## Start by creating a data frame with IDs
    fakedata <- data.frame(ID=1:n)

    # Rather than a function, here I just used the built-in sample function
    # I am sampling for n ages lying between agemin and agemax
    # Using dnorm(), I assume a normal distribution of the ages, with
    # mean age equal to today's year minus the "MedianYr" you were using above
    # I assume that the mean and the SD are equal, you don't have to do that

    # I put in a few extra carriage returns here to make things not quite so
    # tight together - figured it would be easier to read.
    fakedata$Age <- sample(x=agemin:agemax,size=n,replace=TRUE,
                           prob=
                           dnorm(agemin:agemax,
                           mean=abs(y-as.numeric(format.Date(Sys.Date(),"%Y"))),
                           sd=abs(y-as.numeric(format.Date(Sys.Date(),"%Y")))))

    # I'm sure you know this, but you have some issues here
    # namely that you have a probability vector that totals to more than 1.
    # You might be getting no NAs as a result.
    fakedata$Gender <- sample(c("Male","Female","Trans", NA), 
                              n, replace=TRUE, prob=c(0.49, 0.5, 0.01, d))

    # Here is the actually sapply()
    fakedata$Edu <- sapply(fakedata$Age,FUN=EduByAge,d=0.1)

    return(fakedata)
}

outdata <- NewUserGen(300,10201) outdata$Edu <- factor(outdata$Edu,levels=c("Some High School",
                                           "High School Grad",
                                           "Associates",
                                           "Bachelors",
                                           "Masters",
                                           "Doctorate"),ordered=TRUE)

hist(outdata$Age)
barplot(table((outdata$Gender)))
par(mai=c(3,1,1,1))
barplot(table((outdata$Edu)),las=2)
-------------------------------------------------------------------------------------------------------
Y x sample(2, 1, ...) 1 X Youtcomes <- sapply(1:100, function(x) {
    X <- sample(1:6, 1, replace=TRUE, rep(1,6)/6)
    Y <- sample(c("H", "T"), X, replace=TRUE, rep(1,2)/2)
    sum(Y == "T")
}) head tail X sum(Y == "T") Youtcomes Y == Tail hist(Youtcomes) # always assign the variable you'll index inside for-loop
# else the object will keep growing every time and a copy of 
# entire object is made for every i, which makes it extremely 
# slow/inefficient.
Youtcomes <- rep(0, 100)
for (i in 1:100) {
    X <- sample(1:6, 1, replace=TRUE, rep(1,6)/6)
    Y <- sample(c("H", "T"), X, replace=TRUE, rep(1,2)/2)
    # assign output inside the loop with [i] indexing
    Youtcomes[i] <- sum(Y == "T")
    # since Youtcomes is assigned a 100 values of 0's before
    # the values will replace 0' at each i. Thus the object 
    # is not copied every time. This is faster/efficient.
}
-------------------------------------------------------------------------------------------------------
X <- sample(6,100,replace=TRUE,c(1,1,1,1,1,1)/6)
Y <- lapply(X , function(x){ res <- sample( c( "H" , "T" ) , x , replace=TRUE , c(1,1)/2 ) ; table( res ) } ) res <- unlist(Y)
hist( res[names( res )=="T"] )
-------------------------------------------------------------------------------------------------------
pairs() panel.cor() panel.cor <- function(x, y, digits=2, cex.cor)
{
  usr <- par("usr"); on.exit(par(usr))
  par(usr = c(0, 1, 0, 1))
  r <- abs(cor(x, y))
  txt <- format(c(r, 0.123456789), digits=digits)[1]
  test <- cor.test(x,y)
  Signif <- ifelse(round(test$p.value,3)<0.001,"p<0.001",paste("p=",round(test$p.value,3)))  
  text(0.5, 0.25, paste("r=",txt))
  text(.5, .75, Signif)
} panel.smooth() cex= col= pch= panel.smooth<-function (x, y, col = "blue", bg = NA, pch = 18, 
                        cex = 0.8, col.smooth = "red", span = 2/3, iter = 3, ...) 
{
  points(x, y, pch = pch, col = col, bg = bg, cex = cex)
  ok <- is.finite(x) & is.finite(y)
  if (any(ok)) 
    lines(stats::lowess(x[ok], y[ok], f = span, iter = iter), 
          col = col.smooth, ...)
} panel.hist() pairs() panel.hist <- function(x, ...)
{
  usr <- par("usr"); on.exit(par(usr))
  par(usr = c(usr[1:2], 0, 1.5) )
  h <- hist(x, plot = FALSE)
  breaks <- h$breaks; nB <- length(breaks)
  y <- h$counts; y <- y/max(y)
  rect(breaks[-nB], 0, breaks[-1], y, col="cyan", ...)
} pairs(USJudgeRatings[,c(2:3,6,1,7)],
          lower.panel=panel.smooth, upper.panel=panel.cor,diag.panel=panel.hist)
-------------------------------------------------------------------------------------------------------
how can I determine how many clusters are appropriate for a kmeans analysis of my data? n = 100
g = 6 
set.seed(g)
d <- data.frame(x = unlist(lapply(1:g, function(i) rnorm(n/g, runif(1)*i^2))), 
                y = unlist(lapply(1:g, function(i) rnorm(n/g, runif(1)*i^2))))
plot(d) mydata <- d
wss <- (nrow(mydata)-1)*sum(apply(mydata,2,var))
  for (i in 2:15) wss[i] <- sum(kmeans(mydata,
                                       centers=i)$withinss)
plot(1:15, wss, type="b", xlab="Number of Clusters",
     ylab="Within groups sum of squares") pamk library(fpc)
pamk.best <- pamk(d)
cat("number of clusters estimated by optimum average silhouette width:", pamk.best$nc, "\n")
plot(pam(d, pamk.best$nc)) # we could also do:
library(fpc)
asw <- numeric(20)
for (k in 2:20)
  asw[[k]] <- pam(d, k) $ silinfo $ avg.width
k.best <- which.max(asw)
cat("silhouette-optimal number of clusters:", k.best, "\n")
# still 4 require(vegan)
fit <- cascadeKM(scale(d, center = TRUE,  scale = TRUE), 1, 10, iter = 1000)
plot(fit, sortg = TRUE, grpmts.plot = TRUE)
calinski.best <- as.numeric(which.max(fit$results[2,]))
cat("Calinski criterion optimal number of clusters:", calinski.best, "\n")
# 5 clusters! # See http://www.jstatsoft.org/v18/i06/paper
# http://www.stat.washington.edu/fraley/mclust/tr504.pdf
#
library(mclust)
# Run the function to see how many clusters
# it finds to be optimal, set it to search for
# at least 1 model and up 20.
d_clust <- Mclust(as.matrix(d), G=1:20)
m.best <- dim(d_clust$z)[2]
cat("model-based optimal number of clusters:", m.best, "\n")
# 4 clusters
plot(d_clust) library(apcluster)
d.apclus <- apcluster(negDistMat(r=2), d)
cat("affinity propogation optimal number of clusters:", length(d.apclus@clusters), "\n")
# 4
heatmap(d.apclus); plot(d.apclus, d) library(cluster)
clusGap(d, kmeans, 10, B = 100, verbose = interactive())

Clustering k = 1,2,..., K.max (= 10): .. done
Bootstrapping, b = 1,2,..., B (= 100)  [one "." per sample]:
.................................................. 50 
.................................................. 100 
Clustering Gap statistic ["clusGap"].
B=100 simulated reference sets, k = 1..10
 --> Number of clusters (method 'firstSEmax', SE.factor=1): 4
          logW   E.logW        gap     SE.sim
 [1,] 5.991701 5.970454 -0.0212471 0.04388506
 [2,] 5.152666 5.367256  0.2145907 0.04057451
 [3,] 4.557779 5.069601  0.5118225 0.03215540
 [4,] 3.928959 4.880453  0.9514943 0.04630399
 [5,] 3.789319 4.766903  0.9775842 0.04826191
 [6,] 3.747539 4.670100  0.9225607 0.03898850
 [7,] 3.582373 4.590136  1.0077628 0.04892236
 [8,] 3.528791 4.509247  0.9804556 0.04701930
 [9,] 3.442481 4.433200  0.9907197 0.04935647
[10,] 3.445291 4.369232  0.9239414 0.05055486 library(NbClust)
nb <- NbClust(d, diss="NULL", distance = "euclidean", 
        min.nc=2, max.nc=15, method = "kmeans", 
        index = "alllong", alphaBeale = 0.1)
hist(nb$Best.nc[1,], breaks = max(na.omit(nb$Best.nc[1,])))
# Looks like 3 is the most frequently determined number of clusters
# and curiously, four clusters is not in the output at all! how can I produce a dendrogram to visualize the results of my cluster analysis d_dist <- dist(as.matrix(d))   # find distance matrix 
plot(hclust(d_dist))           # apply hirarchical clustering and plot # a Bayesian clustering method, good for high-dimension data, more details:
# http://vahid.probstat.ca/paper/2012-bclust.pdf
install.packages("bclust")
library(bclust)
x <- as.matrix(d)
d.bclus <- bclust(x, transformed.par = c(0, -50, log(16), 0, 0, 0))
viplot(imp(d.bclus)$var); plot(d.bclus); ditplot(d.bclus)
dptplot(d.bclus, scale = 20, horizbar.plot = TRUE,varimp = imp(d.bclus)$var, horizbar.distance = 0, dendrogram.lwd = 2)
# I just include the dendrogram here pvclust library(pvclust)
library(MASS)
data(Boston)
boston.pv <- pvclust(Boston)
plot(boston.pv)
-------------------------------------------------------------------------------------------------------
R obs = sort([10 11 12 13 13 13 13 14 15 50]); % have to make sure they are sorted...
uo = unique(obs);
hh = hist(obs, uo); % find frequencies of each value
cpdf = cumsum(obs);
cpdfn = cpdf / max(cpdf); % normalized cumulative pdf
r = rand(1, 100); % 100 random numbers from 0 to 1
rv = round(interp1(cpdfn, uo, r)); % randomly pick values in the cpdfn; find corresponding "observation"
hr = hist(rv, 1:50);
hrc = cumsum(hr);
figure
plot(uo, cpdfn);
hold all;
plot(1:50, hhc/max(hhc))

figure; hist(rv, 1:50);
-------------------------------------------------------------------------------------------------------
cors<-round(cor(samples),2) #correlations

# make layout for plot layout
laymat<-diag(1:5) #histograms
laymat[upper.tri(laymat)]<-6:15 #correlations
laymat[lower.tri(laymat)]<-16:25 #heatmaps

layout(laymat) #define layout using laymat

par(mar=c(2,2,2,2)) #define marginals etc.

# Draw histograms, tweak arguments of hist to make nicer figures
for(i in 1:5) 
  hist(samples[,i],main=names(samples)[i])

# Write correlations to upper diagonal part of the graph
# Again, tweak accordingly
for(i in 1:4)
  for(j in (i+1):5){
    plot(-1:1,-1:1, type = "n",xlab="",ylab="",xaxt="n",yaxt="n")
    text(x=0,y=0,labels=paste(cors[i,j]),cex=2)
    }

# Plot heatmaps, here I use kde2d function for density estimation
# image function for generating heatmaps
library(MASS)
for(i in 2:5)
  for(j in 1:(i-1)){
     k <- kde2d(samples[,i],samples[,j])
     image(k,col=heat.colors(1000))
    }
-------------------------------------------------------------------------------------------------------
\documentclass{article}

\begin{document}

<<prepare-src, include=FALSE>>=
s = names(iris)[-5]
# construct the source document
src = sprintf('<<sample-%s>>=
hist(iris[,"%s"], col="gray", border="white")
@', s, s)
@

% evaluate the source
\Sexpr{knit(text = src)}

\end{document} s
-------------------------------------------------------------------------------------------------------
hist( a[ !a==0 ]) table(is.na(c))
FALSE  TRUE 
 443    57 

length(a[!a==0])
[1] 443
-------------------------------------------------------------------------------------------------------
rnormgammamix <- function(n,shape,rate,mean,sd,prob) {
    ifelse(runif(n)<prob,
           rgamma(n,shape,rate),
           rnorm(n,mean,sd))
} dnormgammamix <- function(x,shape,rate,mean,sd,prob,log=FALSE) {
    r <- prob*dgamma(x,shape,rate)+(1-prob)*dnorm(x,mean,sd)
    if (log) log(r) else r
} set.seed(101)
r <- rnormgammamix(1000,1.5,2,3,2,0.5)
d <- data.frame(r) bbmle library("bbmle")
m1 <- mle2(r~dnormgammamix(exp(logshape),exp(lograte),mean,exp(logsd),
                     plogis(logitprob)),
     data=d,
     start=list(logshape=0,lograte=0,mean=0,logsd=0,logitprob=0))
cc <- coef(m1)

png("normgam.png")
par(bty="l",las=1)
hist(r,breaks=100,col="gray",freq=FALSE)
rvec <- seq(-2,8,length=101)
pred <- with(as.list(cc),
             dnormgammamix(rvec,exp(logshape),exp(lograte),mean,
                           exp(logsd),plogis(logitprob)))
lines(rvec,pred,col=2,lwd=2)
true <- dnormgammamix(rvec,1.5,2,3,2,0.5)
lines(rvec,true,col=4,lwd=2)
dev.off() tcc <- with(as.list(cc),
            c(shape=exp(logshape),
              rate=exp(lograte),
              mean=mean,
              sd=exp(logsd),
              prob=plogis(logitprob)))
cbind(tcc,c(1.5,2,3,2,0.5)) library("MASS")
ff <- fitdistr(r,dnormgammamix,
     start=list(shape=1,rate=1,mean=0,sd=1,prob=0.5))

cbind(tcc,ff$estimate,c(1.5,2,3,2,0.5)) fitdistr mle2 ff2 <- fitdistr(r,dnormgammamix,
     start=list(shape=1.5,rate=2,mean=3,sd=2,prob=0.5))
-logLik(ff2)  ## 1725.994
-logLik(ff)   ## 1755.458
-------------------------------------------------------------------------------------------------------
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Call R Through OpenCPU</title> 
  <script type="text/javascript" src="http://code.jquery.com/jquery-latest.js">       </script>
  <script>

      //When Document is Ready
      $(function () {

          //Go R button Click Event Handler
          $("#cmdGoR").click(function () {
              var resultsUrlPrefix = "http://public.opencpu.org/R/tmp/";
              var url = "http://public.opencpu.org/R/call/base/identity/save";
              var rCommands = $("#txtRCommands").val();
              $.post(url,
              {
                  x: rCommands
              },
              function (data) {
                  var obj = $.parseJSON(data);

                  //Add statistical (textual) results to results div
                  $('#results').append("<br/>");
                  $('<div/>', {
                      id: 'statResults'
                  }).appendTo('#results');
                  var statResultsLink = resultsUrlPrefix + obj.object + "/print";
                  $("#statResults").load(statResultsLink);

                  //Add charts results to results div
                  var charts = obj.graphs;
                  if (charts.length > 0) {
                      for (var i = 0; i < charts.length; i++) {
                          var chartLink = resultsUrlPrefix + charts[i] + "/png";
                          $('#results').append("<br/>");
                          $('<img/>', {
                              id: 'chartResults' + (i + 1),
                              src: chartLink
                          }).appendTo('#results');
                      }
                  }

              })
              .error(function (jqXHR, status, error) {
                  alert(jqXHR.responseText);
              });
          });

      });

  </script>
</head>
<body>

<h3>Set of R Commands</h3>
<textarea rows="8" cols="80" id="txtRCommands">

x <- rnorm(1000); 
print(hist(x));

</textarea> 
<br />
<input type="button" value="Run code" id="cmdGoR" />

<div id="results">
</div>

</body>
</html>
-------------------------------------------------------------------------------------------------------
ylim=c(0,20) hist() axis() hist(y,breaks=c(0,60,70,80,90,100),freq=TRUE,ylim=c(0,20))
axis(2,at=seq(0,20,length.out=5),labels=c(0,5,10,15,20))
-------------------------------------------------------------------------------------------------------
tmp <- tapply( iris$Petal.Length, iris$Species, function(x) hist(x, plot=FALSE) )

plot.new()
tmp.r <- do.call( range, lapply(tmp, `[[`, 'breaks') )
plot.window(xlim=c(1/2,length(tmp)+1/2), ylim=tmp.r)
abline(v=seq_along(tmp))

for( i in seq_along(tmp) ) {
    h <- tmp[[i]]
    rf <- h$counts/sum(h$counts)
    rect( i-rf/2, head(h$breaks, -1), i+rf/2, tail(h$breaks, -1) )
}

axis(1, at=seq_along(tmp), labels=names(tmp))
axis(2)
box()
-------------------------------------------------------------------------------------------------------
C:\Program Files\R\R-2.15.2\bin\RScript -e hist(runif(1000))
-------------------------------------------------------------------------------------------------------
hist breaks histogram panel.hanoi bwplot(crime.v ~ bias, data=df30, panel=panel.hanoi) bwplot(crime.v ~ bias, data=df, ylim=c(-1,1), pch="|", coef=0, panel=function(...){panel.hanoi(col="pink", breaks=cv.ints, ...); panel.bwplot(...)}) ylim pch coef cv.ints <- c(-1.000000000, -0.960000012, -0.822307704, -0.684615396, -0.546923088, -0.409230781, -0.271538473, -0.133846165, 0.003846142, 0.141538450, 0.279230758, 0.416923065, 0.554615373, 0.692307681, 0.829999988, 0.967692296, 1.000000000) panel.hanoi <- function(x, y, horizontal, breaks="Sturges", ...) {  # "Sturges" is hist()'s default

  if (horizontal) {
    condvar <- y # conditioning ("independent") variable
    datavar <- x # data ("dependent") variable
  } else {
    condvar <- x
    datavar <- y
  }

  conds <- sort(unique(condvar))

  # loop through the possible values of the conditioning variable
  for (i in seq_along(conds)) {

      h <- hist(datavar[condvar == conds[i]], plot=F, breaks) # use base hist(ogram) function to extract some information

    # strip outer counts == 0, and corresponding bins
    brks.cnts <- stripOuterZeros(h$breaks, h$counts)
    brks <- brks.cnts[[1]]
    cnts <- brks.cnts[[2]]

    halfrelfs <- (cnts/sum(cnts))/2  # i.e. half of the relative frequency
    center <- i

    # All of the variables passed to panel.rec will usually be vectors, and panel.rect will therefore make multiple rectangles.
    if (horizontal) {
      panel.rect(head(brks, -1), center - halfrelfs, tail(brks, -1), center + halfrelfs, ...)
    } else {
      panel.rect(center - halfrelfs, head(brks, -1), center + halfrelfs, tail(brks, -1), ...)
    }
  }
}

# function to strip counts that are all zero on ends of data, along with the corresponding breaks
stripOuterZeros <- function(brks, cnts) { do.call("stripLeftZeros", stripRightZeros(brks, cnts)) }

stripLeftZeros <- function(brks, cnts) {
  if (cnts[1] == 0) {
    stripLeftZeros(brks[-1], cnts[-1])
  } else {
    list(brks, cnts)
  }
}

stripRightZeros <- function(brks, cnts) {
  len <- length(cnts)
  if (cnts[len] ==0) {
    stripRightZeros(brks[-(len+1)], cnts[-len])
  } else {
    list(brks, cnts)
  }
}
-------------------------------------------------------------------------------------------------------
atop hist(d, main=bquote(atop(Title,mu==.(mean(d)))))
-------------------------------------------------------------------------------------------------------
library(MASS)
a <- c(26,73,84,115,123,132,159,207,240,241,254,268,272,282,300,302,329,346,359,367,375,378, 384,452,475,495,503,531,543,563,594,609,671,687,691,716,757,821,829,885,893,968,1053,1081,1083,1150,1205,1262,1270,1351,1385,1498,1546,1565,1635,1671,1706,1820,1829,1855,1873,1914,2030,2066,2240,2413,2421,2521,2586,2727,2797,2850,2989,3110,3166,3383,3443,3512,3515,3531,4068,4527,5006,5065,5481,6046,7003,7245,7477,8738,9197,16370,17605,25318,58524)
## Ooops, rater wide
plot(hist(a))
fitdistr(a/10000,"gamma") # gives warnings
# No warnings
fitted.gamma <- fitdistr(a/10000, dgamma,  start=list(shape = 1, rate = 0.1),lower=0.001)
-------------------------------------------------------------------------------------------------------
mycomplicatedPlot <- function(x, ...){
    hist(x,...)
    abline(v=mean(x))
    abline(v=quantile(x, probs=c(0.025, 0.975)), lty=2, col="red")
}

pdf(file="test.all.pdf",width=7,height=10,pointsize=12,bg="white",paper="letter",pagecentre=T)
    par(mfrow=c(3,2))

    for(i in 1:12){
      temp <- rnorm(500,i,1)
      pdf(paste0("test_",i,".pdf"))
          mycomplicatedPlot(temp, main=i)
      dev.off()
    mycomplicatedPlot(temp, main=i)
    }
dev.off()
-------------------------------------------------------------------------------------------------------
C L L^T x Lx C import numpy as np
import matplotlib.pyplot as plt
linalg = np.linalg
np.random.seed(1)

num_samples = 1000
num_variables = 2
cov = [[0.3, 0.2], [0.2, 0.2]]

L = linalg.cholesky(cov)
# print(L.shape)
# (2, 2)
uncorrelated = np.random.standard_normal((num_variables, num_samples))
mean = [1, 1]
correlated = np.dot(L, uncorrelated) + np.array(mean).reshape(2, 1)
# print(correlated.shape)
# (2, 1000)
plt.scatter(correlated[0, :], correlated[1, :], c='green')
plt.show() X Y rho = cov(X,Y) / sqrt(var(X)*var(Y)) cov = [[1, 0.2],
       [0.2, 1]] cov(X,Y) = 0.2 var(X) var(Y) rho X Y import numpy as np
import matplotlib.pyplot as plt
import scipy.stats as stats
linalg = np.linalg
np.random.seed(1)

num_samples = 1000
num_variables = 2
cov = [[1.0, 0.2], [0.2, 1.0]]

L = linalg.cholesky(cov)

rhos = []
for i in range(1000):
    uncorrelated = np.random.standard_normal((num_variables, num_samples))
    correlated = np.dot(L, uncorrelated)
    X, Y = correlated
    rho, pval = stats.pearsonr(X, Y)
    rhos.append(rho)

plt.hist(rhos)
plt.show()
-------------------------------------------------------------------------------------------------------
vignette("distr") library(distr)

## Construct the distribution object.
## Here, it's a split normal distribution with mode=0, and lower- and
## upper-half standard deviations of 1 and 2, respectively.
splitNorm <- UnivarMixingDistribution(Truncate(Norm(0,2), upper=0), 
                                      Truncate(Norm(0,1), lower=0), 
                                      mixCoeff=c(0.5, 0.5))
## Construct its density function ...
dsplitNorm <- d(splitNorm)
## ... and a function for sampling random variates from it
rsplitNorm <- r(splitNorm)

## Compare the density it returns to that from rnorm()
dsplitNorm(-1)
# [1] 0.1760327    
dnorm(-1, sd=2)
# [1] 0.1760327    

## Sample and plot a million random variates from the distribution
x <- rsplitNorm(1e6)         
hist(x, breaks=100, col="grey")

## Plot the distribution's continuous density
plot(splitNorm, to.draw.arg="d")
-------------------------------------------------------------------------------------------------------
... central.simul <- function(N, ns,type = c("runif", "rnorm", "rbinom"),...){
        type <- match.arg(type)
        msample <- rep(NA,N)  ## EDIT here: intialisation
        for(i in 1:N){
          sam <- switch(type,
                        runif = runif(ns)*10,
                        rnorm = rnorm(ns)*10,
                        rbinom = rbinom(ns,...))
          msample[i] <- mean(sam) # save mean of sample
          add.hist <- i > 1
          h <- hist(msample, breaks=seq(0,10, len=50), # histogram of all means
                    xlim=c(0,10), col=grey(.9),
                    xlab="", main="Central Limit Theorem", border="blue", las=1,add=add.hist)
          points(sam, rep(max(h$count), length(sam)),
                 pch=16, col=grey(.2)) # add sampled values
          points(msample[i], max(h$count), # add sample mean value
                 col="red", pch=15)
          text(10, max(h$count), paste0("sample no ", i))
          hist(msample[i], breaks=seq(0,10, len=50), # ovelay sample mean 
               xlim=c(0,10), col="red", add=T, # in histogram
               xlab="", border="white", las=1)
          Sys.sleep(.1)
        }
    } central.simul(10,3,'runif')
central.simul(10,3,'rbinom',size=2,prob=0.5)
-------------------------------------------------------------------------------------------------------
ylim= boxplot() xlim= hist() set.seed(123)
data <- rnorm(1000)
nf <- layout(mat = matrix(c(1,2),2,1, byrow=TRUE),  height = c(1,3))
par(mar=c(5.1, 4.1, 1.1, 2.1))
boxplot(data, horizontal=TRUE,  outline=FALSE,ylim=c(-4,4))
hist(data,xlim=c(-4,4))
-------------------------------------------------------------------------------------------------------
tab <- as.table(path.length.hist(g)$res)
names(tab) <- 1:length(tab)
barplot(tab)
-------------------------------------------------------------------------------------------------------
beta alpha beta 0.5 rb <- rbeta(1000, 0.5, 0.5)
hist(rb) (0,1)
-------------------------------------------------------------------------------------------------------
cdweibull <- function(x, shape, scale, log = FALSE){
  dd <- dweibull(x, shape= shape, scale = scale, log = log)
  dd <- cumsum(dd) * c(0, diff(x))
  return(dd)
} dweibull require(MASS)

h = c(31.194, 31.424, 31.253, 25.349, 24.535, 25.562, 29.486, 25.680,
      26.079, 30.556, 30.552, 30.412, 29.344, 26.072, 28.777, 30.204, 
      29.677, 29.853, 29.718, 27.860, 28.919, 30.226, 25.937, 30.594, 
      30.614, 29.106, 15.208, 30.993, 32.075, 31.097, 32.073, 29.600, 
      29.031, 31.033, 30.412, 30.839, 31.121, 24.802, 29.181, 30.136, 
      25.464, 28.302, 26.018, 26.263, 25.603, 30.857, 25.693, 31.504, 
      30.378, 31.403, 28.684, 30.655,  5.933, 31.099, 29.417, 29.444, 
      19.785, 29.416, 5.682, 28.707, 28.450,  28.961, 26.694, 26.625, 
      30.568, 28.910, 25.170, 25.816, 25.820)

weib = fitdistr(na.omit(h),densfun=dweibull,start=list(scale=1,shape=5))

hist(h, prob=TRUE, main = "", xlab = "x", ylab = "y", xlim = c(0,40), breaks = seq(0,40,5), ylim = c(0,1))

curve(cdweibull(x, scale=weib$estimate[1], shape=weib$estimate[2]),
  from=0, to=40, add=TRUE)
-------------------------------------------------------------------------------------------------------
rkde positive y <- rkde(
  fhat = kde(x=x, h=hpi(x)), 
  n    = 100, 
  positive = TRUE
) x2 <- log(x)
y2 <- rkde(fhat=kde(x=x2, h=hpi(x2)), n=100)
y <- exp(y2)
hist(y, col="green", freq=F)
-------------------------------------------------------------------------------------------------------
set.seed(1)
x<-rlnorm(100)
hist(x, prob=TRUE)

lines(density(x), col='red')

library(ks)
tmp <- kde(x, hpi(x))
lines(tmp$eval.points, tmp$estimate, col='green')

library(logspline)
lsfit <- logspline(x, lbound=0)
curve( dlogspline(x,lsfit), add=TRUE, col='blue' )

curve( dlnorm, add=TRUE, col='orange' ) rlogspline plogspline qlogspline
-------------------------------------------------------------------------------------------------------
f <- function(x) (25 * 200.7341^25 / x^26 * exp(-(200.7341/x)^25))
g <- function(x) dnorm(x, mean = 200.7341, sd = 40)
M <- 5
curve(f, 0, 500)
curve(M * g(x), 0, 500, add = TRUE, lty = "dashed") k <- 1
count <- 0
res <- vector(mode = "numeric", length = 1000)
while(k < 1001) {
          z <- rnorm(n = 1, mean = 200.7341, sd = 40)
          R <- f(z) / M * g(z)
          if (R > runif(1)) {
              res[k] <- z
              k  <- k + 1
          }
          count <- count + 1
    }

(accept_rate <- (k / count) * 100)
## [1] 0.20773

require(MASS) ## for truehist
truehist(res)
curve(f, 0, 250, add = TRUE)
-------------------------------------------------------------------------------------------------------
graphics.off() dev.copy dev.off() graphics.off() dev.off() ggsave print last_plot ggplot p ggsave('filname.png') for (i in 1:2){
  if (1){
    hist(rnorm(100))
    dev.copy(file="MyHist.png",device=png, bg="white",  width=640, height=352) 
    graphics.off()

    p <- ggplot(bin.ts.avg, aes(x, tt)) + geom_point() +geom_line() + facet_grid(.~depday)
    p <- p + ggtitle("10 minute averages")+ xlab("Hour") + ylab("Values")    
    p <- p + scale_x_continuous(breaks=c(min(bin.ts.avg$x), max(bin.ts.avg$x)), labels=c("7", "10"))
   # no need to print p
   ggsave(filename="MyGGPlot.png")
   # note specifying p is redundant but explicit.
   # ggsave(filename = 'MyGGplot.png', plot = p)
  }
}
-------------------------------------------------------------------------------------------------------
par(mfrow=c(4,3))

for (i in seq_along(out)){
  hist(out[[i]][,3],xlab="I(t)", main=paste("Run ", i))
}
-------------------------------------------------------------------------------------------------------
set.seed(1002)
lymax <- c(0,2)
lhalf <- 0
x <- runif(200)
g <- factor(rep(c("a","b"),each=100))
y <- rnbinom(200,mu=exp(lymax[g])/(1+x/exp(lhalf)),size=2)
dat <- data.frame(y,g,x)

fit3 <- mle2(y~dnbinom(mu=exp(lymax)/(1+x/exp(lhalf)),size=exp(logk)),
    parameters=list(lymax~g),
    start=list(lymax=0,lhalf=0,logk=0),
    data=dat)


par(mfrow=c(2,2))
hist(residuals(fit3))
qqnorm(residuals(fit3))
hist(residuals(fit3, type="response"))
qqnorm(residuals(fit3, type="response"))
-------------------------------------------------------------------------------------------------------
plotrix multihist #install.packages("plotrix")
require(plotrix)

l <- list(rnorm(50),rnorm(50,sd=2),rnorm(50,mean=3))
multhist(l)
-------------------------------------------------------------------------------------------------------
z <- rnorm(100,.3,.2)
hist(z, xlab="", ylab="", main="", yaxt="n")
par(new=TRUE)
plot(density(z), xlab="", ylab="", main="", xaxt="n", yaxt="n")
axis(2, ...) # plug in the relevant values for `at` and `labels`
axis(4, ...) # plug in the relevant values for `at` and `labels`
-------------------------------------------------------------------------------------------------------
# look at the full example iris data set (it's pre-loaded in your R)
iris

# first six records
head( iris )

# convert the `Species` column to numeric, so you get 1, 2, 3
as.numeric( iris$Species )

# now actually store that result back on the data frame
iris$SpeciesCat <- as.numeric( iris$Species )

# plot your results
hist( iris$SpeciesCat )
-------------------------------------------------------------------------------------------------------
set.seed(1984)

U <- 10
products <- c('A','B')
owned_by <- c(1,2) 
df <- data.frame(products, owned_by)
p = rep(0, nrow(df)+1)
num.runs = 1000

for(n in 1:num.runs)
{
  x=c()  ## list of people who own a product
  for (i in 1:nrow(df))
    x = c(x, sample(1:U, df$owned_by[i]))

  ## get the number of people who own 0, 1, 2...products
  p[1] = p[1] + (sum(hist(x,breaks=0:U,plot=F)$counts == 0) / U)
  for(i in 1:nrow(df))
    p[i+1] = p[i+1] + (sum(hist(x,breaks=0:U,plot=F)$counts >= i) / U)
}

p = p / num.runs ## average over all runs
p

## 0.7197 0.2803 0.0197
-------------------------------------------------------------------------------------------------------
approx() df library(lubridate)
# date/time as class POSIXct
df$DT2 <- ymd_hm(df$DT)

# create a new data frame, everyhour, with every hour between the first and the last in df
everyhour <- data.frame(DT2=seq(ceiling_date(min(df$DT2), "hour"), floor_date(max(df$DT2), "hour"), 3600), FORHIST=TRUE)

# merge the observed data with the everyhour data
df2 <- merge(df, everyhour, all=TRUE)
# set missing FORHIST to FALSE
df2$FORHIST[is.na(df2$FORHIST)] <- FALSE
# define year
df2$YEAR <- year(df2$DT2)
# estimate speed for everyhour
df2$estSPEED <- approx(x=df2$DT2, y=df2$SPEED, xout=df2$DT2, method="linear")$y

# plot annual histograms of hourly speeds
suy <- sort(unique(df2$YEAR))
par(mfrow=n2mfrow(length(suy)), mar=c(3, 3, 2, 1), oma=c(2, 2, 0, 0))
for(i in seq(suy)) {
    sel <- df2$YEAR==suy[i] & df2$FORHIST==TRUE
    hist(df2$estSPEED[sel], xlab="", ylab="", main=suy[i])
    }
mtext("Speed", side=1, outer=TRUE)
mtext("Frequency", side=2, outer=TRUE)
-------------------------------------------------------------------------------------------------------
pdf("test.pdf")
plot(1:10,1:10)
hist(rnorm(1000))
dev.off() png("%003d.png", h=768, w=1024)
plot(1:10,1:10)
hist(rnorm(1000))
dev.off()
-------------------------------------------------------------------------------------------------------
hist1 <- hist(A,breaks=30)
hist2 <- hist(B,freq=F,breaks=30) freq=F plot(hist1, col="red",lty=0, xlim=c(-4,4),freq=F)
plot(hist2, col="blue", lty=0, xlim=c(-4,4), add=TRUE, main="Example",freq=F)
-------------------------------------------------------------------------------------------------------
set.seed(42)
DF1 <- as.data.frame(matrix(rnorm(1500),150))
DF2 <- as.data.frame(matrix(runif(1500),150))

#transform to matrices for better performance
m1 <- as.matrix(DF1)
m2 <- as.matrix(DF2)

#use outer to get all combinations of row numbers and apply a function to them
#22500 combinations is small enough to fit into RAM
cors <- outer(seq_len(nrow(DF1)),seq_len(nrow(DF2)),
     #you need a vectorized function
     #Vectorize takes care of that, but is just a hidden loop (slow for huge row numbers)
     FUN=Vectorize(function(i,j) cor(m1[i,],m2[j,])))
hist(cors)
-------------------------------------------------------------------------------------------------------
pdf("test.pdf")
par(mfrow=c(3,2))
plot(1:10, 21:30)
plot(1:10, 21:30, pch=20)
hist(rnorm(1000))
barplot(VADeaths)
...
dev.off()
-------------------------------------------------------------------------------------------------------
dput h <- hist(ts, breaks=7*24, plot=FALSE)
plot(x=h$mids, y=h$density, type="l", xaxt="n")
axis(1,at=ts,labels=format(ts,"%b-%d"))
-------------------------------------------------------------------------------------------------------
scales comma library(scales) q<-quantile(y,prob=seq(0,1,.1));hist(y,breaks=q,labels=comma(q)) lattice q<-quantile(y,prob=seq(0,1,.1));histogram(~y,breaks=q,scales=list(at=q,labels=comma(q)))
-------------------------------------------------------------------------------------------------------
axis y <- seq(10000, 100000, 10000) 
hist(y, xaxt="n")
axis(side=1, at=axTicks(1), 
     labels=formatC(axTicks(1), format="d", big.mark=',')) axTicks formatC
-------------------------------------------------------------------------------------------------------
csvSizeEst <- function(obj, frac=0.01) {
    tf <- tempfile()
    on.exit(unlink(tf))
    n <- ceiling(nrow(obj) * frac)
    write.csv(obj[seq_len(n),], file=tf)
    1/frac * file.info(tf)$size
}

x <- data.frame(replicate(5, rnorm(500)))

## Estimated file size, based on a 1% sample (the default sample size)
csvSizeEst(x)
# [1] 50700

## Set fraction of file to 1 to get actual file size
csvSizeEst(x, frac=1)
# [1] 48904 object.size oo <- ls("package:datasets")
dfs <- oo[sapply(oo, function(X) is.data.frame(get(X)))]
r <- sapply(dfs, function(X) {
         X <- get(X)
         csvSizeEst(X,1)/object.size(X)
     })
hist(r, breaks=20, col="lightgrey", xlim=c(0,1.5),
     main="Ratio of size-on-disk to object.size in R")
-------------------------------------------------------------------------------------------------------
par()              # view current settings
opar <- par()      # make a copy of current settings
par(col.lab="red") # red x and y labels 
hist(mtcars$mpg)   # create a plot with these new settings 
par(opar)          # restore original settings
-------------------------------------------------------------------------------------------------------
f(input) = Asym/(1+exp((xmid-input)/scal)) # as in ?SSlogis # Just for loading the data, we will use lme4 for model fitting, not nlme
library(nlme)
library(lme4)
# Careful when loading both nlme and lme4 as they have overlap, strange behaviour may occur

# A more generalized form could be taken e.g. from http://en.wikipedia.org/wiki/Generalised_logistic_curve
# A custom model structure:
Model <- function(age, Asym, Asym2, xmid, scal, Gender) 
{
    # Taken from ?SSlogis, standard form:
    #Asym/(1+exp((xmid-input)/scal))
    # Add gender-specific term to Asym2
    (Asym+Asym2*Gender)/(1+exp((xmid-age)/scal))
    # Evaluation of above form is returned by this function
}

# Model gradient, notice that we include all 
# estimated fixed effects like 'Asym', 'Asym2', 'xmid' and 'scal' here,
# but not covariates from the data: 'age' and 'Gender'
ModelGradient <- deriv(
    body(Model)[[2]], 
    namevec = c("Asym", "Asym2", "xmid", "scal"), 
    function.arg=Model
) # Binary coding for the gender
Orthodont2 <- data.frame(Orthodont, Gender = as.numeric(Orthodont[,"Sex"])-1)
#> table(Orthodont2[,"Gender"])
# 0  1 
#64 44 
# Ordering data based on factor levels so they don't mix up paneling in lattice later on
Orthodont2 <- Orthodont2[order(Orthodont2[,"Subject"]),] # Fit the non-linear mixed effects model
fit <- nlmer(
    # Response
    distance ~ 
    # Fixed effects
    ModelGradient(age = age, Asym, Asym2, xmid, scal, Gender = Gender) ~ 
    # replaces: SSlogis(age,Asym, xmid, scal) ~ 
    # Random effects
    (Asym | Subject) + (xmid | Subject), 
    # Data
    data = Orthodont2, 
    start = c(Asym = 25, Asym2 = 15, xmid = 11, scal = 3)) (Asym+Asym2*0)/(1+exp((xmid-age)/scal)) = (Asym)/(1+exp((xmid-age)/scal)) (Asym+Asym2)/(1+exp((xmid-age)/scal)) > summary(fit)
Nonlinear mixed model fit by the Laplace approximation 
Formula: distance ~ ModelGradient(age = age, Asym, Asym2, xmid, scal,      Gender = Gender) ~ (Asym | Subject) + (xmid | Subject) 
   Data: Orthodont2 
   AIC   BIC logLik deviance
 268.7 287.5 -127.4    254.7
Random effects:
 Groups   Name Variance Std.Dev.
 Subject  Asym 7.0499   2.6552  
 Subject  xmid 4.4285   2.1044  
 Residual      1.5354   1.2391  
Number of obs: 108, groups: Subject, 27

Fixed effects:
      Estimate Std. Error t value
Asym    29.882      1.947  15.350
Asym2   -3.493      1.222  -2.859
xmid     1.240      1.068   1.161
scal     5.532      1.782   3.104

Correlation of Fixed Effects:
      Asym   Asym2  xmid  
Asym2 -0.471              
xmid  -0.584  0.167       
scal   0.901 -0.239 -0.773 # Extracting fixed effects components by calling the model function, a bit messy but it works
# I like to do this for visualizing the model fit
fixefmat <- matrix(rep(fixef(fit), times=dim(Orthodont2)[1]), ncol=length(fixef(fit)), byrow=TRUE)
colnames(fixefmat) <- names(fixef(fit))
Orthtemp <- data.frame(fixefmat, Orthodont2)
attach(Orthtemp)
# see str(Orthtemp)
# Evaluate the function for rows of the attached data.frame to extract fixed effects corresponding to observations
fix = as.vector(as.formula(body(Model)[[2]]))
detach(Orthtemp)

nobs <- 4 # 4 observations per subject
legend = list(text=list(c("y", "Xb + Zu", "Xb")), lines = list(col=c("blue", "red", "black"), pch=c(1,1,1), lwd=c(1,1,1), type=c("b","b","b")))
require(lattice)
xyplot(
    distance ~ age | Subject, 
    data = Orthodont2,
    panel = function(x, y, ...){
        panel.points(x, y, type='b', col='blue')
        panel.points(x, fix[(1+nobs*(panel.number()-1)):(nobs*(panel.number()))], type='b', col='black')
        panel.points(x, fitted(fit)[(1+nobs*(panel.number()-1)):(nobs*(panel.number()))], type='b', col='red')
    },
    key = legend
)

# Residuals
plot(Orthodont2[,"distance"], resid(fit), xlab="y", ylab="e")

# Distribution of random effects
par(mfrow=c(1,2))
hist(ranef(fit)[[1]][,1], xlab="Random 'Asym'", main="")
hist(ranef(fit)[[1]][,2], xlab="Random 'xmid'", main="")
# Random 'xmid' seems a bit skewed to the right and may violate normal distribution assumption
# This is due to M13 having a bit abnormal growth curve (random effects):
#           Asym       xmid
#M13  3.07301310  3.9077583
-------------------------------------------------------------------------------------------------------
hist(data, breaks=seq(0,80,l=6),
       freq=FALSE,col="orange",main="Histogram",
       xlab="x",ylab="f(x)",yaxs="i",xaxs="i")
-------------------------------------------------------------------------------------------------------
cut # set the seed to get a reproducible example
set.seed(12345)

min.val <- 0
max.val <- 5000
num.val <- 10000
# Generate some random values
values <- sample(min.val:max.val, num.val, replace=T)

interval <- 1000
num.split <- ceiling((max.val - min.val)/interval)+1

# Use cut to split the data. 
# You can set labels=FALSE if you want the group number 
# rather than the interval
groups <- cut(values, seq(min.val, max.val, length.out=num.split))

# Count the elements in each group
res <- table(groups) res groups
    (0,1e+03] (1e+03,2e+03] (2e+03,3e+03] (3e+03,4e+03] (4e+03,5e+03] 
         1987          1974          2054          2000          1984 hist h <- hist(values, 10) # 10 bins h <- hist(values, seq(min.val, max.val, length.out=num.split)) h$counts plot=NULL
-------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------
d <- rlnorm(1000, 3)
d.cut <- cut(d, c(seq(0, 120, 10), Inf))
hist(as.numeric(d.cut), breaks=0:13, xaxt='n', xlab='', 
     col=1, border=0, main='', cex.axis=0.8, las=1)
axis(1, at=0:13, labels=c(seq(0, 120, 10), '>120'), cex.axis=0.8)
box()
-------------------------------------------------------------------------------------------------------
grades <- mydata$Exam1
hist(grades, prob=TRUE)
curve(dnorm(x, mean=mean(grades), sd=sd(grades)), add=TRUE)
-------------------------------------------------------------------------------------------------------
hist(*, freq=FALSE) freq=TRUE
-------------------------------------------------------------------------------------------------------
my.graph <- reactive({
  head(
    subset(
      offerwallData, 
      platform == formulaTextPlatform() & 
      source == formulaTextSource() &
      type == formulaTextType() &
      price == formulaTextPrice() &
      country == formulaTextCountry()), 100)
})

output$plot <- renderPlot({
  hist(my.graph())
})
-------------------------------------------------------------------------------------------------------
some.table <- cbind(c(434,8012,1254,39,4322,595,12984,5597),c(359,8217,1360,112,4199,2737,13112,4287))
hist(apply(some.table,1,min),breaks=10)
-------------------------------------------------------------------------------------------------------
?pmin hist(pmin(x[,1], x[,2]))
-------------------------------------------------------------------------------------------------------
> vec <- rnorm(6000000)
> 
> h <- hist(vec, breaks = 800, freq = FALSE)
> sum(h$density)
[1] 100
> unique(zapsmall(diff(h$breaks)))
[1] 0.01 > sessionInfo()
R version 3.0.1 RC (2013-05-11 r62732)
Platform: x86_64-unknown-linux-gnu (64-bit)

locale:
 [1] LC_CTYPE=en_GB.UTF-8       LC_NUMERIC=C              
 [3] LC_TIME=en_GB.UTF-8        LC_COLLATE=en_GB.UTF-8    
 [5] LC_MONETARY=en_GB.UTF-8    LC_MESSAGES=en_GB.UTF-8   
 [7] LC_PAPER=C                 LC_NAME=C                 
 [9] LC_ADDRESS=C               LC_TELEPHONE=C            
[11] LC_MEASUREMENT=en_GB.UTF-8 LC_IDENTIFICATION=C       

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

loaded via a namespace (and not attached):
[1] tools_3.0.1
-------------------------------------------------------------------------------------------------------
log2(N) xlim h <- hist(data[,1], freq=FALSE, breaks=800)
sum(h$density * diff(h$breaks))
-------------------------------------------------------------------------------------------------------
h <- hist(vec, breaks = 100, plot=FALSE)
h$counts=h$counts/sum(h$counts)
plot(h)
-------------------------------------------------------------------------------------------------------
x <- list(c(1,5),c(1,3),c(3,4))
hist(unlist(lapply(x,function(z) seq(z[1],z[2]))))          # hist
plot(density(unlist(lapply(x,function(z) seq(z[1],z[2]))))) # density
-------------------------------------------------------------------------------------------------------
histo <- tkrplot(tt, function()hist(data)
tkgrid(histo)
-------------------------------------------------------------------------------------------------------
library(mixtools)
wait = faithful$waiting
mixmdl = normalmixEM(wait)

plot(mixmdl, which = 2, xlim = c(25, 110), ylim = c(0, .5), nclass=20)
#Error in hist.default(x, prob = TRUE, main = main2, xlab = xlab2, ylim = c(0,  : 
#  formal argument "ylim" matched by multiple actual arguments traceback()

# 4: hist.default(x, prob = TRUE, main = main2, xlab = xlab2, ylim = c(0,  maxy), ...)

-------------------------------------------------------------------------------------------------------
plot(1:10, rnorm(10), ylim=c(0,1), ylim=c(-1,100))
Error in plot.default(1:10, rnorm(10), ylim = c(0, 1), ylim = c(-1, 100)) : 
  formal argument "ylim" matched by multiple actual arguments hist(x, prob = TRUE, main = main2, xlab = xlab2, ylim = c(0, maxy), ...) maxy <- max(max(a$density), 0.3989 * mix.object$lambda/mix.object$sigma) library(mixtools)
wait = faithful$waiting
mixmdl = normalmixEM(wait)
plot.new()
plot.window(xlim=c(25,110), ylim=c(0,0.5))
plot(mixmdl, which = 2, nclass=20, add = TRUE)
lines(density(wait), lty = 2, lwd = 2)
box(); axis(1); axis(2); title(xlab="Data", ylab="Density")
-------------------------------------------------------------------------------------------------------
x.gen <- rexp(1000, rate = 3)
hist(x.gen, prob = TRUE)

library(MASS)
x.est <- fitdistr(x.gen, "exponential")$estimate

curve(dexp(x, rate = x.est), add = TRUE, col = "red", lwd = 2)
-------------------------------------------------------------------------------------------------------
hist.data = hist(my.data, plot=F)
hist.data$counts = log(hist.data$counts, 2)
plot(hist.data)
-------------------------------------------------------------------------------------------------------
ggplot2 par lambda=seq(0,1,length.out=100)
b1=lambda^2
b2=lambda^2+1 
b=cbind(b1,b2)
perc=rnorm(100)
par(mfrow = c(2,1))
matplot(lambda,b)
hist(perc) matplot hist par(mfrow = c(1,2)) matplot(lambda,b)
par(new = TRUE)
hist(perc)
-------------------------------------------------------------------------------------------------------
counts hist ?hist counts <- hist(samp, breaks = 3, col="lightblue", border="pink")$counts
-------------------------------------------------------------------------------------------------------
DF <- read.table(text="A   B   C   D   E   F   G   H   I   J      
1    4   6   3   5   9   9   9   3   4   4
2    5   7   5   5   8   8   8   7   4   5
3    7   5   4   4   7   9   7   4   4   5
4    6   6   6   6   8   9   8   6   3   6
5    4   5   5   5   8   8   7   4   3   7
6    7   9   7   6   7   8   8   5   7   6
7    5   6   6   5   8   8   7   3   3   5
8    6   7   4   5   8   9   8   4   6   5
9    6   8   8   6   7   7   7   7   6   6", header=TRUE)

m <- as.matrix(DF)

apply(m,1,function(x) hist(x,breaks = 3)$count)
# $`1`
# [1] 5 2 0 3
# 
# $`2`
# [1] 5 0 2 3
# 
# $`3`
# [1] 6 3 1
# 
# $`4`
# [1] 1 6 2 1
# 
# $`5`
# [1] 3 3 4
# 
# $`6`
# [1] 3 4 2 1
# 
# $`7`
# [1] 2 5 3
# 
# $`8`
# [1] 6 3 1
# 
# $`9`
# [1] 4 4 0 2 hist breaks <- 1:5*2
t(apply(m,1,function(x) table(cut(x,breaks,include.lowest = TRUE))))
#   [2,4] (4,6] (6,8] (8,10]
# 1     5     2     0      3
# 2     1     4     5      0
# 3     4     2     3      1
# 4     1     6     2      1
# 5     3     3     4      0
# 6     0     3     6      1
# 7     2     5     3      0
# 8     2     4     3      1
# 9     0     4     6      0
-------------------------------------------------------------------------------------------------------
aa <- a$value[a$value > 0] require(mixtools)
g3 <- gammamixEM(aa) d3 <- function(x) g3$lambda[1]*dgamma(x, g3$gamma.pars[1], 1/g3$gamma.pars[2]) + g3$lambda[2]*dgamma(x, g3$gamma.pars[3], 1/g3$gamma.pars[4]) gammamixEM x <- seq(min(aa), max(aa), 0.001)
plot(x, d3(x), "l")
hist(aa, col="pink", add=T, freq=F, breaks=10)
-------------------------------------------------------------------------------------------------------
plot() hist.a$count a axis() labels= hist.a$mids set.seed(5555)
a <- rlnorm(1000)
hist.a <- hist(a, plot = FALSE)

hist.a
  $breaks
  [1]  0  5 10 15 20 25 30 35 40

  $counts
  [1] 955  34   6   2   2   0   0   1

  $density
  [1] 0.1910 0.0068 0.0012 0.0004 0.0004 0.0000 0.0000 0.0002

  $mids
  [1]  2.5  7.5 12.5 17.5 22.5 27.5 32.5 37.5

  $xname
  [1] "a"

  $equidist
  [1] TRUE

  attr(,"class")
  [1] "histogram"

plot(hist.a$count, log = "xy",xaxt="n",type="h",lwd=10,lend=2)
axis(1,at=1:length(hist.a$mids),labels=hist.a$mids)
-------------------------------------------------------------------------------------------------------
barplot multhist(year, xlab="Count", ylab="Frequency", main="", 
         cex.axis=1, col=c("dark gray", "light gray"), 
         breaks=seq(0,1600, by=200),
         space=c(0,0), beside=TRUE) theme_bw library(ggplot2)

ggplot(df, aes(x=count,group=year,fill=as.factor(year))) + 
  geom_histogram(position="identity", alpha=0.5, breaks=seq(0,1600, by=200),right=TRUE) +
  scale_fill_discrete(name="Year") +
  theme_bw(base_size=20) +
  xlab("values") multhist ggplot(df, aes(x=count,group=year,fill=as.factor(year))) + 
  geom_histogram(position="dodge", breaks=seq(0,1600, by=200),right=TRUE) +
  scale_fill_discrete(name="Year") +
  theme_bw(base_size=20) +
  xlab("values") +
  scale_x_continuous(breaks=seq(100,1500, by=200))
-------------------------------------------------------------------------------------------------------
data<-runif(1000)
myLab<-diff(unlist(lapply(seq(0,1,0.2), function(y){sum(data<y)})))*100/length(data)
hist(data,breaks=seq(0,1,0.2), labels =paste0(myLab,"%"), col ="yellow")
-------------------------------------------------------------------------------------------------------
> x  <- rnorm(1000)
> h  <- hist(x)
> h
$breaks
 [1] -3.5 -3.0 -2.5 -2.0 -1.5 -1.0 -0.5  0.0  0.5  1.0  1.5  2.0  2.5  3.0  3.5  4.0

$counts
 [1]   1   5  23  38 104 154 208 191 130  85  39  17   4   0   1

$density
 [1] 0.002 0.010 0.046 0.076 0.208 0.308 0.416 0.382 0.260 0.170 0.078 0.034 0.008 0.000 0.002

$mids
[1] -3.25 -2.75 -2.25 -1.75 -1.25 -0.75 -0.25  0.25  0.75  1.25  1.75  2.25  2.75  3.25  3.75

$xname
[1] "x"

$equidist
[1] TRUE

attr(,"class")
[1] "histogram"
> out  <- data.frame(mid = h$mids, counts = h$counts)
> write.table(out, file = "export.csv", row.names = FALSE, sep = ",")
-------------------------------------------------------------------------------------------------------
\documentclass{article}
\usepackage{pdfpages}
\begin{document}
\includepdf{test.pdf} % your other document
<<echo=FALSE>>=
x <- rnorm(100)
hist(x)
# or whatever you need to do to get your plot
@
\end{document} pdf onefile=TRUE x <- rnorm(100)
y <- rnorm(100)
pdf("test.pdf")
hist(x)
hist(y)
dev.off()
-------------------------------------------------------------------------------------------------------
d apply rowMeans rowMeans(apply(A,2,function(a) hist(a,bins,plot=FALSE)$counts))
#[1] 0.50 0.75 1.00 0.50 0.50 lapply sapply > lapply(mylist,function(X)
      rowMeans(apply(X,2,function(a) hist(a,bins,plot=FALSE)$counts)))
[[1]]
[1] 0.50 0.75 1.00 0.50 0.50

[[2]]
[1] 0.50 0.75 1.00 0.50 0.50

[[3]]
[1] 0.50 0.75 1.00 0.50 0.50
-------------------------------------------------------------------------------------------------------
textOutput() mainPanel NULL library(shiny)
    shinyUI(pageWithSidebar(

headerPanel("Shiny Example"),

    sidebarPanel(


        wellPanel(

        selectInput(    inputId = "variable1",label = "Select First Variable:", 
                choices = c("Binary Variable 1" = "binary1",
                "Binary Variable 2" = "binary2", 
                "Continuous Variable 1" = "cont1",
                "Continuous Variable 2" = "cont2"),
                selected = "Binary Variable 1"
        )
        ),


        wellPanel(

            checkboxInput("bivariate", "Proceed to Bivariate Analysis", FALSE),
        conditionalPanel(
        condition="input.bivariate==true",
        selectInput(inputId = "variable2", 
        label = "Select Second Variable:",
        choices = c("Binary Variable 1" = "binary1",
        "Binary Variable 2" = "binary2", 
        "Continuous Variable 1" = "cont1",
        "Continuous Variable 2" = "cont2"),
        selected = "Binary Variable 2"
    )
    )
    )
    ),
    mainPanel(

    h5("Item Response Rate"),
    verbatimTextOutput("nitem"),

    h5(textOutput("caption2")),
    verbatimTextOutput("out2"),

    h5(textOutput("caption3")),
    verbatimTextOutput("out3"),

    h5(textOutput("caption4")),
    verbatimTextOutput("out4"),

    h5(textOutput("caption5")),
    plotOutput("out5")
    )
    )) binary1 <- rbinom(100,1,0.5)
    binary2 <- rbinom(100,1,0.5)
    cont1   <- rnorm(100)
    cont2   <- rnorm(100)

    dat <- as.data.frame(cbind(binary1, binary2, cont1, cont2))

    dat$binary1 <- as.factor(dat$binary1)
    dat$binary2 <- as.factor(dat$binary2)
    dat$cont1 <- as.numeric(dat$cont1)
    dat$cont2 <- as.numeric(dat$cont2)

    library(shiny)

    shinyServer(function(input, output) {

    inputVar1 <- reactive({
    parse(text=sub(" ","",paste("dat$", input$variable1)))
    })

    inputVar2 <- reactive({
    parse(text=sub(" ","",paste("dat$", input$variable2)))
    })

    output$nitem <- renderPrint({


    if ( (input$bivariate==FALSE) & (is.factor(eval(inputVar1()))==TRUE) ) {
    n <- sum(table(eval(inputVar1())))
    p <- n/100
    out <- cat(paste(n,gsub(" ","",paste("(",round(as.numeric(p)*100,2),"%",")"))),"\n")
    } else {

    if ( (input$bivariate==FALSE) & (is.numeric(eval(inputVar1()))==TRUE) ) {
    n <- sum(table(eval(inputVar1())))
    p <- n/100
    out <- cat(paste(n,gsub(" ","",paste("(",round(as.numeric(p)*100,2),"%",")"))),"\n")
    } else {

    if ( (input$bivariate==TRUE) & (is.factor(eval(inputVar1()))==TRUE) & (is.factor(eval(inputVar2()))==TRUE) ) {
    n <- sum(table(eval(inputVar1()),eval(inputVar2())))
    p <- n/100
    out <- cat(paste(n,gsub(" ","",paste("(",round(as.numeric(p)*100,2),"%",")"))),"\n")
    } else {

    if ( (input$bivariate==TRUE) & (is.numeric(eval(inputVar1()))==TRUE) & (is.numeric(eval(inputVar2()))==TRUE) ) {
    n <- sum(table(eval(inputVar1()),eval(inputVar2())))
    p <- n/100
    out <- cat(paste(n,gsub(" ","",paste("(",round(as.numeric(p)*100,2),"%",")"))),"\n")
    } else {

    if ( (input$bivariate==TRUE) & (is.factor(eval(inputVar1()))==TRUE) & (is.numeric(eval(inputVar2()))==TRUE) ) {
    n <- sum(table(eval(inputVar1()),eval(inputVar2())))
    p <- n/100
    out <- cat(paste(n,gsub(" ","",paste("(",round(as.numeric(p)*100,2),"%",")"))),"\n")
    } else { 

    if ( (input$bivariate==TRUE) & (is.numeric(eval(inputVar1()))==TRUE) & (is.factor(eval(inputVar2()))==TRUE) ) {
    n <- sum(table(eval(inputVar1()),eval(inputVar2())))
    p <- n/100
    out <- cat(paste(n,gsub(" ","",paste("(",round(as.numeric(p)*100,2),"%",")"))),"\n")
    }
    }
    }
    }
    }
    }

    })

    output$caption2 <- renderText({

    if ( (input$bivariate==FALSE) & (is.factor(eval(inputVar1()))==TRUE) ) {
    caption2 <- "Univariate Table"
    } else {

    if ( (input$bivariate==FALSE) & (is.numeric(eval(inputVar1()))==TRUE) ) {
    caption2 <- "Univariate Summary"
    } else {

    if ( (input$bivariate==TRUE) & (is.factor(eval(inputVar1()))==TRUE) & (is.factor(eval(inputVar2()))==TRUE) ) {
    captions2 <- "Bivariate Table"
    } else {

    if ( (input$bivariate==TRUE) & (is.numeric(eval(inputVar1()))==TRUE) & (is.numeric(eval(inputVar2()))==TRUE) ) {
    caption2 <- "Numeric Summary First Variable"
    } else {

    if ( (input$bivariate==TRUE) & (is.factor(eval(inputVar1()))==TRUE) & (is.numeric(eval(inputVar2()))==TRUE) ) {
    caption2 <- "Numeric Summary By Factor"
    } else { 

    if ( (input$bivariate==TRUE) & (is.numeric(eval(inputVar1()))==TRUE) & (is.factor(eval(inputVar2()))==TRUE) ) {
    caption2 <- "Numeric Summary By Factor"
    }
    }
    }
    }
    }
    }

    })

    output$out2 <- renderPrint({

    if ( (input$bivariate==FALSE) & (is.factor(eval(inputVar1()))==TRUE) ) {
    table(eval(inputVar1()))
    } else {

    if ( (input$bivariate==FALSE) & (is.numeric(eval(inputVar1()))==TRUE) ) {
    summary(eval(inputVar1()))
    } else {

    if ( (input$bivariate==TRUE) & (is.factor(eval(inputVar1()))==TRUE) & (is.factor(eval(inputVar2()))==TRUE) ) {
    table(eval(inputVar1()), eval(inputVar2()))
    } else {

    if ( (input$bivariate==TRUE) & (is.numeric(eval(inputVar1()))==TRUE) & (is.numeric(eval(inputVar2()))==TRUE) ) {
    summary(eval(inputVar1()))
    } else {

    if ( (input$bivariate==TRUE) & (is.factor(eval(inputVar1()))==TRUE) & (is.numeric(eval(inputVar2()))==TRUE) ) {
    by(eval(inputVar2()), eval(inputVar1()), summary)
    } else { 

    if ( (input$bivariate==TRUE) & (is.numeric(eval(inputVar1()))==TRUE) & (is.factor(eval(inputVar2()))==TRUE) ) {
    by(eval(inputVar1()), eval(inputVar2()), summary)
    }
    }
    }
    }
    }
    }

    })

    output$caption3 <- renderText({

    if ( (input$bivariate==FALSE) & (is.factor(eval(inputVar1()))==TRUE) ) {
    caption3 <- "Univariate Table of Proportions"
    } else {

    if ( (input$bivariate==FALSE) & (is.numeric(eval(inputVar1()))==TRUE) ) {
    caption3 <- ""
    } else {

    if ( (input$bivariate==TRUE) & (is.factor(eval(inputVar1()))==TRUE) & (is.factor(eval(inputVar2()))==TRUE) ) {
    captions3 <- "Bivariate Table of Row Proportions"
    } else {

    if ( (input$bivariate==TRUE) & (is.numeric(eval(inputVar1()))==TRUE) & (is.numeric(eval(inputVar2()))==TRUE) ) {
    caption3 <- "Numeric Summary Second Variable"
    } else {

    if ( (input$bivariate==TRUE) & (is.factor(eval(inputVar1()))==TRUE) & (is.numeric(eval(inputVar2()))==TRUE) ) {
    caption3 <- "Kruskal Wallis Test"
    } else { 

    if ( (input$bivariate==TRUE) & (is.numeric(eval(inputVar1()))==TRUE) & (is.factor(eval(inputVar2()))==TRUE) ) {
    caption3 <- "Kruskal Wallis Test"
    }
    }
    }
    }
    }
    }

    })


    output$out3 <- renderPrint({

    if ( (input$bivariate==FALSE) & (is.factor(eval(inputVar1()))==TRUE) ) {
    prop.table(table(eval(inputVar1())))
    } else {

    if ( (input$bivariate==FALSE) & (is.numeric(eval(inputVar1()))==TRUE) ) {
    NULL
    } else {

    if ( (input$bivariate==TRUE) & (is.factor(eval(inputVar1()))==TRUE) & (is.factor(eval(inputVar2()))==TRUE) ) {
    prop.table(table(eval(inputVar1()), eval(inputVar2())), margin=1)
    } else {

    if ( (input$bivariate==TRUE) & (is.numeric(eval(inputVar1()))==TRUE) & (is.numeric(eval(inputVar2()))==TRUE) ) {
    summary(eval(inputVar2()))
    } else {

    if ( (input$bivariate==TRUE) & (is.factor(eval(inputVar1()))==TRUE) & (is.numeric(eval(inputVar2()))==TRUE) ) {
    kruskal.test(eval(inputVar2()) ~ eval(inputVar1()))
    } else { 

    if ( (input$bivariate==TRUE) & (is.numeric(eval(inputVar1()))==TRUE) & (is.factor(eval(inputVar2()))==TRUE) ) {
    kruskal.test(eval(inputVar1()) ~ eval(inputVar2()))
    }
    }
    }
    }
    }
    }

    })

    output$caption4 <- renderText({

    if ( (input$bivariate==FALSE) & (is.factor(eval(inputVar1()))==TRUE) ) {
    caption4 <- ""
    } else {

    if ( (input$bivariate==FALSE) & (is.numeric(eval(inputVar1()))==TRUE) ) {
    caption4 <- ""
    } else {

    if ( (input$bivariate==TRUE) & (is.factor(eval(inputVar1()))==TRUE) & (is.factor(eval(inputVar2()))==TRUE) ) {
    captions4 <- "Pearsons Chi-Squared Test"
    } else {

    if ( (input$bivariate==TRUE) & (is.numeric(eval(inputVar1()))==TRUE) & (is.numeric(eval(inputVar2()))==TRUE) ) {
    caption4 <- "Spearmans Correlation Coefficient"
    } else {

    if ( (input$bivariate==TRUE) & (is.factor(eval(inputVar1()))==TRUE) & (is.numeric(eval(inputVar2()))==TRUE) ) {
    caption4 <- ""
    } else { 

    if ( (input$bivariate==TRUE) & (is.numeric(eval(inputVar1()))==TRUE) & (is.factor(eval(inputVar2()))==TRUE) ) {
    caption4 <- ""
    }
    }
    }
    }
    }
    }

    })

    output$out4 <- renderPrint({

    if ( (input$bivariate==FALSE) & (is.factor(eval(inputVar1()))==TRUE) ) {
    NULL
    } else {

    if ( (input$bivariate==FALSE) & (is.numeric(eval(inputVar1()))==TRUE) ) {
    NULL
    } else {

    if ( (input$bivariate==TRUE) & (is.factor(eval(inputVar1()))==TRUE) & (is.factor(eval(inputVar2()))==TRUE) ) {
    chisq.test(table(eval(inputVar1()), eval(inputVar2())))
    } else {

    if ( (input$bivariate==TRUE) & (is.numeric(eval(inputVar1()))==TRUE) & (is.numeric(eval(inputVar2()))==TRUE) ) {
    cor(eval(inputVar1()), eval(inputVar2()), method="spearman", use="pairwise.complete.obs")
    } else {

    if ( (input$bivariate==TRUE) & (is.factor(eval(inputVar1()))==TRUE) & (is.numeric(eval(inputVar2()))==TRUE) ) {
    NULL
    } else { 

    if ( (input$bivariate==TRUE) & (is.numeric(eval(inputVar1()))==TRUE) & (is.factor(eval(inputVar2()))==TRUE) ) {
    NULL
    }
    }
    }
    }
    }
    }

    })

    output$caption5 <- renderText({

    if ( (input$bivariate==FALSE) & (is.factor(eval(inputVar1()))==TRUE) ) {
    caption5 <- "Univariate Barplot"
    } else {

    if ( (input$bivariate==FALSE) & (is.numeric(eval(inputVar1()))==TRUE) ) {
    caption5 <- "Univariate Histogram"
    } else {

    if ( (input$bivariate==TRUE) & (is.factor(eval(inputVar1()))==TRUE) & (is.factor(eval(inputVar2()))==TRUE) ) {
    captions5 <- "Bivariate Barplot"
    } else {

    if ( (input$bivariate==TRUE) & (is.numeric(eval(inputVar1()))==TRUE) & (is.numeric(eval(inputVar2()))==TRUE) ) {
    caption5 <- "Bivariate Scatter Graph"
    } else {

    if ( (input$bivariate==TRUE) & (is.factor(eval(inputVar1()))==TRUE) & (is.numeric(eval(inputVar2()))==TRUE) ) {
    caption5 <- "Bivariate Boxplot"
    } else { 

    if ( (input$bivariate==TRUE) & (is.numeric(eval(inputVar1()))==TRUE) & (is.factor(eval(inputVar2()))==TRUE) ) {
    caption5 <- "Bivariate Boxplot"
    }
    }
    }
    }
    }
    }

    })

    output$out5 <- renderPlot({

    if ( (input$bivariate==FALSE) & (is.factor(eval(inputVar1()))==TRUE) ) {
    barplot(table(eval(inputVar1())))
    } else {

    if ( (input$bivariate==FALSE) & (is.numeric(eval(inputVar1()))==TRUE) ) {
    hist(eval(inputVar1()),main="")
    } else {

    if ( (input$bivariate==TRUE) & (is.factor(eval(inputVar1()))==TRUE) & (is.factor(eval(inputVar2()))==TRUE) ) {
    barplot(table(eval(inputVar1()), eval(inputVar2())), beside=TRUE)
    } else {

    if ( (input$bivariate==TRUE) & (is.numeric(eval(inputVar1()))==TRUE) & (is.numeric(eval(inputVar2()))==TRUE) ) {
    plot(eval(inputVar1()), eval(inputVar2()), main="")
    } else {

    if ( (input$bivariate==TRUE) & (is.factor(eval(inputVar1()))==TRUE) & (is.numeric(eval(inputVar2()))==TRUE) ) {
    boxplot(eval(inputVar2()) ~ eval(inputVar1()))
    } else { 

    if ( (input$bivariate==TRUE) & (is.numeric(eval(inputVar1()))==TRUE) & (is.factor(eval(inputVar2()))==TRUE) ) {
    boxplot(eval(inputVar1()) ~ eval(inputVar2()))
    }
    }
    }
    }
    }
    }

    })

    })
-------------------------------------------------------------------------------------------------------
table(cut(...)) get.bin.counts = function(x, name.x = "x", start.pt, end.pt, bin.width){
  br.pts = seq(start.pt, end.pt, bin.width)
  x = x[(x >= start.pt)&(x <= end.pt)]
  counts = hist(x, breaks = br.pts, plot = FALSE)$counts
  dfm = data.frame(br.pts[-length(br.pts)], counts)
  names(dfm) = c(name.x, "freq")
  return(dfm)
} counts = hist(... hist FALSE # First define x, a large vector of times:    
start.time = as.POSIXct("2012-11-01 00:00:00")
x = start.time + runif(50000, min = 0, max = 365*24*3600)
x = x[order(x)]
# Apply the function, keeping track of running time:
t1 = Sys.time()
dfm = get.bin.counts(x, name.x = "time", 
                     start.pt = as.POSIXct("2012-11-01 00:00:00"),
                     end.pt = as.POSIXct("2013-07-01 00:00:00"), 
                     bin.width = 60)
as.numeric(Sys.time()-t1) #prints elapsed time table(cut(...)) cut table(cut(x, br)) hist(x, br, plot = FALSE)
-------------------------------------------------------------------------------------------------------
sweave/knitr \documentclass{article}
\usepackage{pdfpages}
\begin{document}
 this my plot 1:    % write some texts here
\includepdf{1.pdf} 
 this my plot 2:
\includepdf{2.pdf} 
 this my plot 3:
\includepdf{3.pdf} 
 this my plot 4:
\includepdf{4.pdf} 
 a new plot:
<<echo=FALSE>>=         % chunk for new plots
x <- rnorm(100)
hist(x)
@
\end{document}
-------------------------------------------------------------------------------------------------------
hist() Axes facecolor='none' def Rify(axes):
    '''
    Produce R-style Axes properties
    '''
    xticks = axes.get_xticks() 
    yticks = axes.get_yticks()

    #remove right and upper spines
    axes.spines['right'].set_color('none') 
    axes.spines['top'].set_color('none')

    #make the background transparent
    axes.set_axis_bgcolor('none')

    #allow space between bottom and left spines and Axes
    axes.spines['bottom'].set_position(('axes', -0.05))
    axes.spines['left'].set_position(('axes', -0.05))

    #allow plot to extend beyond spines
    axes.spines['bottom'].set_bounds(xticks[0], xticks[-2])
    axes.spines['left'].set_bounds(yticks[0], yticks[-2])

    #set tick parameters to be more R-like
    axes.tick_params(direction='out', top=False, right=False, length=10, pad=12, width=1, labelsize='medium')

    #set x and y ticks to include all but the last tick
    axes.set_xticks(xticks[:-1])
    axes.set_yticks(yticks[:-1])

    return axes
-------------------------------------------------------------------------------------------------------
histo<-hist(yourvariable)
barplot(histo$counts/n,col="white",space=0)->bp   # n=length(yourvariable)
axis(1,at=c(bp),labels=histo$mids)
title(ylab="Relative Frequency",xlab="Your Variable Name")
-------------------------------------------------------------------------------------------------------
try try(hist(data1, col="blue")) tryCatch tryCatch(hist(data1, col="blue"), error=function(e) plot.new())
-------------------------------------------------------------------------------------------------------
paste paste ?plotmath atop expression(atop("Histogram of "*hat(mu), Bootstrap~samples*','~Allianz)) pdf("test.pdf") ;  par(mar=c(10,10,10,10))
 hist(1:10,cex.main=2,cex.axis=1.2,cex.lab=1.2,main=expression(atop("Histz)))
 dev.off() # don't need to restore;  this 'par' only applies to pdf()
-------------------------------------------------------------------------------------------------------
mtext bquote alpha = rnorm(1e3)
hist(alpha,cex.main=2,cex.axis=1.2,cex.lab=1.2,main=NULL )

title <- list( bquote( paste( "Histogram of " , hat(mu) ) ) ,
               bquote( paste( "Bootstrap samples, Allianz" ) ) )


mtext(do.call(expression, title ),side=3, line = c(1,-1) , cex = 2 ) title title <- as.list(expression(paste("Histogram of " , hat(mu)), "Bootstrap samples, Allianz"))
-------------------------------------------------------------------------------------------------------
library(shiny)

runApp(list(
  ui = pageWithSidebar(    

  headerPanel("Hello Shiny!"),

  sidebarPanel(
    sliderInput("obs", 
                "Number of observations:", 
                min = 1,
                max = 1000, 
                value = 500)
  ),

  mainPanel(
    plotOutput("distPlot")
  )
),
  server =function(input, output, session) {
    autoInvalidate <- reactiveTimer(5000, session)
    output$distPlot <- renderPlot({
    autoInvalidate()
    # generate an rnorm distribution and plot it
    dist <- rnorm(input$obs)
    hist(dist)
  })

}
))
-------------------------------------------------------------------------------------------------------
plot(NORM, TEE, ylim = c(-4, 5), main = "NORM and TEE plot") points(NORM[NORM^2 -1> TEE], TEE[ TEE + 1< NORM^2], col = "blue")
legend(legend = c("TEE > NORM^2 - 1 ", "TEE < NORM^2 - 1" ), col = c(1, 4), x = "topright", pch = 1) par(mfrow = c(1, 2))
plot(NORM, TEE, ylim = c(-4, 5), main = "NORM and TEE plot")
plot(NORM, TEE, ylim = c(-4, 5), main = "NORM and TEE plot")
points(NORM[NORM^2 -1> TEE], TEE[ TEE + 1< NORM^2], col = "blue") screen.split(2,2)
#[1] 1 2 3 4
screen(1) # what follows goes in slot (1,1)
hist(RandomNormal, seq(-3.2, 3.2, .2), prob = TRUE)
curve(dnorm(x), add = TRUE, col = "red");
screen(2) # what follows goes in slot (1,2);
boxplot(DATA.oner);
screen(3) # similarly for (2,1);
plot(NORM, TEE, ylim = c(-4, 5), main = "NORM and TEE plot");
screen(4) # similarly for (2,2);
plot(NORM, TEE, ylim = c(-4, 5), main = "NORM and TEE plot");
points(NORM[NORM^2 - 1 > TEE], TEE[TEE + 1 < NORM^2], col = "blue"); screen(1) # Watch the screen (1,1) go blank
boxplot(DATA.oner, main = "Box Plots of DATA.oner")

screen(2) # again for slot (1,2)
hist(RandomNormal, seq(-3.2, 3.2, .2), prob = TRUE)
curve(dnorm(x), add = TRUE, col = "red") split.screen(c(2,1)) # The screen is now split in two
# [1] 1 2
split.screen(c(1,2), screen = 2) # splits the second into 2
# [1] 3 4
screen(1) # note screen 2 is now refered to as 3 and 4
hist(RandomNormal, seq(-3.2, 3.2, .2), prob = TRUE)
curve(dnorm(x), add = TRUE, col = "red")
legend(legend = c("Theoretical N(0, 1)"), col = c(2, 3), x = "topright", lty = 1)

screen(3) # We call on screen 3 and 4, not 2
boxplot(DATA.oner, main = "Box Plot of DATA.oner")

screen(4)
plot(NORM, TEE, ylim = c(-4, 5), main = "NORM and TEE plot")
-------------------------------------------------------------------------------------------------------
#  Repeat experiment 10,000 times
res <- replicate( 10000 , shuffle(stimulus) )
out <- do.call( rbind , res )

#  Plot
par( mfrow = c( 3 , 2 ) )
for( i in 1:ncol(out)){
  hist( out[,i] , main = paste0("Values at position: " , i ) )
} sample
-------------------------------------------------------------------------------------------------------
jpeg(your_path_here, ...) files = list.files()

for(file in files){
  dir = paste("H:\\test\\sub\\", file, ".jpg", sep = "")
  jpeg(dir)
  hist(data)
  dev.off()
}
-------------------------------------------------------------------------------------------------------
######################
### ---Clean Up--- ###
######################

rm(list = ls())
gc()

######################
### ---Packages--- ###
#####################

require(parallel) 
require(data.table)
require(rbenchmark)
require(inline)


#######################
### ---Functions--- ###
#######################

# Competitor functions by Breyal
Breyal.using_datatable <- function(x) {DT <- data.table(x = x, weight = 1, key = "x"); DT[, length(weight), by = x]}
Breyal.using_lapply_1c_eq <- function(x = sort(x)) { lapply(unique(x), function(u) sum(x == u)) } # 1 core
Breyal.using_mclapply_8c_eq <- function(x = sort(x)) { mclapply(unique(x), function(u) sum(x == u), mc.cores = 8L) } # 8 cores

# Competitor functions by tennenrishin
tennenrishin.using_table <- function(x) as.data.frame(table(x))
tennenrishin.using_hist <- function(x) hist(x,breaks=min(x):(max(x)+1),plot=FALSE,right=FALSE)
tennenrishin.using_sort <- function(x) {cdf<-cbind(sort(x),seq_along(x)); cdf<-cdf[!duplicated(cdf[,1]),2]; c(cdf[-1],length(x)+1)-cdf}
tennenrishin.using_ecdf <- function(x) {i<-min(x):max(x); cdf<-ecdf(x)(i)*length(x); cdf-c(0,cdf[-length(i)])}
tennenrishin.using_counting_loop <- function(x) {h<-rep(0,max(x)+1);for(i in seq_along(x)){h[x[i]]<-h[x[i]]+1}; h}

# Competitor function by Ulrich
Ulrich.using_tabulate <- function(x) {
  adj <- 1L - min(x)
  y <- setNames(tabulate(x+adj), sort(unique(x)))
  return(y)
}

# I couldn't get the Joe's C++ version to work (my laptop won't install inline) butI suspect that would be the fastest solution

##################
### ---Data--- ###
##################

# Set seed so results are reproducable
set.seed(21)

# Data vector
x <- floor(runif(1000000)*1000)


#####################
### ---Timings--- ###
#####################

# Benchmarks using Ubuntu 13.04 x64 with 8GB RAM and i7-2600K CPU @ 3.40GHz
benchmark(replications = 5,
          tennenrishin.using_table(x),
          tennenrishin.using_hist(x),
          tennenrishin.using_sort(x),
          tennenrishin.using_ecdf(x),
          tennenrishin.using_counting_loop(x),
          Ulrich.using_tabulate(x),
          Breyal.using_datatable(x),
          Breyal.using_lapply_1c_eq(x),
          Breyal.using_mclapply_8c_eq(x),
          order = "relative") test replications elapsed relative user.self sys.self user.child sys.child
6            Ulrich.using_tabulate(x)            5   0.176    1.000     0.176    0.000       0.00     0.000
2          tennenrishin.using_hist(x)            5   0.468    2.659     0.468    0.000       0.00     0.000
3          tennenrishin.using_sort(x)            5   0.687    3.903     0.688    0.000       0.00     0.000
4          tennenrishin.using_ecdf(x)            5   0.749    4.256     0.748    0.000       0.00     0.000
7           Breyal.using_datatable(x)            5   2.960   16.818     2.960    0.000       0.00     0.000
1         tennenrishin.using_table(x)            5   4.651   26.426     4.596    0.052       0.00     0.000
9      Breyal.using_mclapply_8c_eq(x)            5  10.817   61.460     0.140    1.196      54.62     7.112
5 tennenrishin.using_counting_loop(x)            5  10.922   62.057    10.912    0.000       0.00     0.000
8        Breyal.using_lapply_1c_eq(x)            5  36.807  209.131    36.768    0.000       0.00     0.000
-------------------------------------------------------------------------------------------------------
par(mfrow = c(8,2))
for(i = 1:8){
  hist(dataframe[,i])
  boxplot(dataframe[,i])
}
-------------------------------------------------------------------------------------------------------
hist(dataframe) hist x ?hist boxplot hist df par(mfrow = ?par histBxp sfsmisc library(sfsmisc)

# Some dummy data
df <- data.frame(matrix(rnorm(200), ncol = 8))

# arrange plots in two rows and four columns
par(mfrow = c(2,4)) 

# create a palette to pick colours from (see `palette`), e.g:
mycols <- rainbow(n = 8)

# 'loop' over columns in df using lapply, and make a "histBxp" for each column.
lapply(1:8, function(i) histBxp(df[ , i], main = "", xlab = i,
                            col = mycols[i],
                            boxcol = mycols[i],
                            medcol = 1))
-------------------------------------------------------------------------------------------------------
par(mfrow=c(2,1))
jpeg("hist_gpa_sat.jpg") jpeg("hist_gpa_sat.jpg")
  par(mfrow=c(2,1))
  hist(gpa)
  hist(sat)
dev.off()
-------------------------------------------------------------------------------------------------------
layout x <- rnorm(1000)
jpeg("normdist.jpg")
layout(mat=matrix(c(1,1,2,3,4,4),nrow=3,ncol=2,byrow=T))
boxplot(x, horizontal=T)
hist(x)
plot(density(x))
plot(x)
dev.off() ?layout layout
-------------------------------------------------------------------------------------------------------
hist else if(updateTracker() <= 5) {
        # generate an rnorm distribution and plot it
        dist <- rnorm(input$obs)
        hist(dist, main = paste("Histogram count =" , updateTracker()))
        }
        else {
            updates <<- 0
            hist(dist, main = paste("Last Histogram count =", as.numeric(updater()), "with secPause =", as.numeric(autoControl())))
                } if
-------------------------------------------------------------------------------------------------------
hist(...) ?hist
-------------------------------------------------------------------------------------------------------
sample.txt $ R > d = read.table('sample.txt',col.name=c("col1","col2","col3")) d dim > dim(d)
[1] 21  3 col3 > hist(d$col3) .r hist.r d = read.table('sample.txt',col.name=c("col1","col2","col3"))
dim(d)
hist(d$col3) Rscript $ Rscript hist.r
[1] 21  3 $ ls -l
total 24
-rw-rw-r-- 1 saml saml    80 Sep 11 02:35 hist.r
-rw-rw-r-- 1 saml saml 12840 Sep 11 02:37 Rplots.pdf
-rw-rw-r-- 1 saml saml   302 Sep 11 02:19 sample.txt
-------------------------------------------------------------------------------------------------------
c(10,20,30) par(mfrow=c(2,1))
mybreaks <- seq(from=0, to=100, by=5)
hist(rnorm(100, 20, 4), breaks = mybreaks)
hist(rnorm(100, 50, 4), breaks = mybreaks)
-------------------------------------------------------------------------------------------------------
lcor rmat <- function(n=49,nhcor=40,hcor=0.8,lcor=0) {
    m <- matrix(lcor,n,n)  ## fill matrix with 'lcor'
    ## select high-cor variables
    hcorpos <- sample(n,size=nhcor,replace=FALSE)
    ## make all of these highly correlated
    m[hcorpos,hcorpos] <- hcor                
    ## compute min real part of eigenvalues
    min(Re(eigen(m,only.values=TRUE)$values))
}
set.seed(101)
r <- replicate(1000,rmat())
## NEVER pos definite
max(r)
## [1] -1.069413e-15
par(las=1,bty="l")
png("eighist.png")
hist(log10(abs(r)),breaks=50,col="gray",main="")
dev.off()
-------------------------------------------------------------------------------------------------------
> corperm = function(A,B,1000) {
Error: unexpected numeric constant in "corperm = function(A,B,1000" > corperm <- function(A, B, n=1000) {
# etc obs = abs(cor(A,B))
tmp = sapply(1:n,function(z) {abs(cor(sample(A,replace=TRUE),B))})
return(1-sum(obs>tmp)/n) corperm <- function(x, y, N=1000, plot=FALSE){
    reps <- replicate(N, cor(sample(x), y))
    obs <- cor(x,y)
    p <- mean(obs > reps) # shortcut for sum(obs>reps)/N
    if(plot){
        hist(reps)
        abline(v=obs, col="red")
        }
     p
     } corperm(A[,1], B[,1]) for mapply for mapply res <- matrix(NA, nrow=NCOL(A), ncol=NCOL(B))
for(iii in 1:3) for(jjj in 1:3) res[iii,jjj] <- corperm(A[,iii], B[,jjj], plot=FALSE)
rownames(res)<-names(A)
colnames(res) <- names(B)
print(res)
-------------------------------------------------------------------------------------------------------
hist(B[,2], prob=TRUE) curve( dt(x, df=15), add=TRUE, col='blue' ) df
-------------------------------------------------------------------------------------------------------
mydata <- read.table(file="elemapi.csv", header=TRUE, sep=",", na.strings=".")

lapply(X=c("avg_ed", "api00", "api99"), FUN=function(s)
  hist(mydata[, s], main=paste("Histogram of", s)))
-------------------------------------------------------------------------------------------------------
hist $density barplot foo<-hist(dfram)  #although you probably wanted hist(dfram$y) or some such)
barplot(foo$density)
-------------------------------------------------------------------------------------------------------
clusterEvalQ replicate parReplicate <- function(cl, n, expr, simplify=TRUE, USE.NAMES=TRUE)
  parSapply(cl, integer(n), function(i, ex) eval(ex, envir=.GlobalEnv),
            substitute(expr), simplify=simplify, USE.NAMES=USE.NAMES) simplify USE.NAMES sapply replicate parSapply replicate library(parallel)
cl <- makePSOCKcluster(3)
hist(parReplicate(cl, 100, mean(rexp(10))))
-------------------------------------------------------------------------------------------------------
g.grouped <- split(residQ_grouped, interaction(residQ_grouped[, 2:4]) )
 # For testing I created an expanded dataset
 residQ_grouped <- cbind(residQ_grouped , tau=rnorm(27*10)) layout pdf("quant_output.pdf", onefile=TRUE)
   lapply(names(g.grouped), function(x){ 
hist(g.grouped[[x]]$tau, main=bquote(Histgram~of~.(x)), breaks=5, freq=T, border=F, col="lightblue", xlim=c(-3,3) ) } )
 dev.off() g.quans <- lapply( lapply(g.grouped, "[[", "tau") , # first extract the columns
                    quantile, 0.05)                # then calculate the quantiles
-------------------------------------------------------------------------------------------------------
PlotRelativeFrequency() x<-runif(100)
h<-hist(x, plot=F)
h$counts <- h$counts / sum(h$counts)
plot(h, freq=TRUE, ylab="Relative Frequency") install.packages("HistogramTools", repos="http://R-Forge.R-project.org")
library(HistogramTools)
PlotRelativeFrequency(hist(x, plot=F))
-------------------------------------------------------------------------------------------------------
MergeBuckets install.packages("HistogramTools")
library(HistogramTools)
h <- hist(rexp(1000), breaks=60)
plot(MergeBuckets(h, adj.buckets=3))
-------------------------------------------------------------------------------------------------------
x <- rexp(1000)
hist(x)
plot(ecdf(x))
-------------------------------------------------------------------------------------------------------
?axis ?par xaxt set.seed(1)
x <- rnorm(100)
## using xaxt="n" to avoid showing the x-axis
hist(x, xlim=c(-4, 4), xaxt="n")
## draw the x-axis with user-defined tick-marks
axis(side=1, at=c(-4, 0, 4))
-------------------------------------------------------------------------------------------------------
par(mfrow = c(3, 1))
xrange <- range( c(outcome[, 11],outcome[, 17],outcome[, 23]) )
hist(outcome[, 11], main = "Heart Attack", xlim = xrange,xaxt="n", xlab = "30-day Death Rate")
axis(1, at=seq(10,30,by=10), labels=seq(10,30,by=10) )
hist(outcome[, 17], main = "Heart failure", xlim = xrange,xaxt="n",  xlab = "30-day Death Rate")
axis(1, at=seq(10,30,by=10), labels=seq(10,30,by=10) )
hist(outcome[, 23], main = "Pneumonia", xlim = xrange, xaxt="n", xlab = "30-day Death Rate")
axis(1, at=seq(10,30,by=10), labels=seq(10,30,by=10) )
-------------------------------------------------------------------------------------------------------
bquote() plotmath symbols a <- rnorm(100)
hist(a, main="A")
mean.a <- round(mean(a))
sd.a <- round(sd(a))
mtext(bquote(mu== ~.(mean.a) ~ sigma== ~.(sd.a))) plotmath Lines <- list(bquote(mu== ~.(mean.a)),
              bquote(sigma== ~.(sd.a)))
mtext(do.call(expression, Lines),side=3,line=0.5:-0.5)
-------------------------------------------------------------------------------------------------------
y = data[, "colname"] y = data[["colname"]] backtick quotes col.name = "colname"
y = data[`col.name`] filename = readline()
data = read.csv(filename)
colname = readline()

hist(data[, colname])
-------------------------------------------------------------------------------------------------------
> cdf<-function(x) integrate(df,-20,x)$value
> qdf<-function(x) optimize(function(z)(cdf(z)-x)^2,c(-20,20))$minimum
> rdf<-function(n) sapply(runif(n),qdf)
> x<-rdf(2000)
> hist(x,freq=F)
> xseq<-seq(-8,8,len=1000)
> lines(xseq,sapply(xseq,df))
-------------------------------------------------------------------------------------------------------
library(shiny)

# Define server logic required to generate and plot a random distribution
shinyServer(function(input, output) {

  dist <- reactive(rnorm(input$obs))

  output$distPlot <- renderPlot({

    # generate an rnorm distribution and plot it
    dist <- dist()
    hist(dist)
  })

  output$summary <- renderTable({
    dist <- dist()
    summary <- table(data.frame(cut(dist, 10)))
  })
})
-------------------------------------------------------------------------------------------------------
X <- data.frame(colA = sample(c("London", "Manchester", "Chelsea"), 50, T), 
                colB = sample(8:11, 50, T), 
                colE = sample(1:5, 50, T))

#> X[X$colA =="London" & X$colB == 10,]
#     colA colB colE
#3  London   10    3
#7  London   10    1
#35 London   10    3
#36 London   10    3
#42 London   10    5

hist(X[X$colA =="London" & X$colB == 10,]$colE)
-------------------------------------------------------------------------------------------------------
df = read.csv('file.csv')
df = df[df$pval < 0.05,]
hist(df$value) df
-------------------------------------------------------------------------------------------------------
readline prompt print p b b p<=0.05 hist( mydataframe$b[ mydataframe$p <= 0.05 ] ) with( mydataframe, hist(b[p<=0.05]) )
-------------------------------------------------------------------------------------------------------
# Prompt a message on the Terminal
filename <- readline("Enter the file name that have p-value and slopes (include .csv)")
# Read the filename from the terminal
file     <- read.csv(filename, header = TRUE)

# Prompt a message again on the Terminal and read the acceptance from user
pval_filter <- readline("Only include trials with p-value < .05? (enter yes or no)")    

if (to-lower(pval_filter) == "yes"){
   # Create a filtered file that contain only rows with the p-val less than that of siginificatn p-val 0.05
   file.filtered <- file[file$pval < 0.05, ]    

   # Get the title of the Histogram to be drawn for the slopes (filtered)
   hist.title <- readline("State the title of the histogram")
   # Draw histogram for the slopes with the title
   #     las = 2 parameter in the histogram below makes the slopes to be written in parpendicular to the X-axis
   #     so that, the labels will not be overlapped, easily readable. 
   hist(file.filtered$slope, main = hist.title, xlab = Slope, ylab = frequency, las = 2)
}
-------------------------------------------------------------------------------------------------------
POSIXlt par(mar=c(6,4,1,1))
Hour <- as.POSIXlt(test.DF$start)$hour
hist(Hour, breaks=seq(0, 23), main="Start time (hour)") fun <- function(start.time, end.time){
    seq.POSIXt(
        as.POSIXlt(
            paste0("2000-01-01 ", as.POSIXlt(start.time)$hour, ":", as.POSIXlt(start.time)$min)
        ),
        as.POSIXlt(
            paste0("2000-01-01 ", as.POSIXlt(end.time)$hour, ":", as.POSIXlt(end.time)$min)
        ),
        by="min"
    )
}


HM <- vector(mode="list", dim(test.DF)[1])
for(i in seq(HM)){
    HM[[i]] <- fun(test.DF$start[i], test.DF$end[i])
}

HM2 <- as.POSIXlt(unlist(HM), origin="1970-01-01")

Hour <- HM2$hour 
hist(Hour, breaks=seq(0, 23))

HourMinute <- HM2$hour + HM2$min/60
hist(HourMinute, breaks=seq(0, 23, by=1/60))
-------------------------------------------------------------------------------------------------------
set.seed(1)
x<-rnorm(1:100)
y <- hist(x, plot=FALSE)
plot(y, ylim=c(0, max(y$counts)+5))
text(y$mids, y$counts+3, y$counts, cex=0.75)
-------------------------------------------------------------------------------------------------------
z2<-hist(d,plot=FALSE,breaks=100)
z2$counts[z2$counts >0] <-aggregate(d,list(cut(d,z2$breaks)),sum)$x
plot(z2, ylab="Totals")
-------------------------------------------------------------------------------------------------------
bins = seq(min(data), max(data), by=range) hist(data, freq=TRUE, breaks=bins)
-------------------------------------------------------------------------------------------------------
brkvec <- c (2.5 , 5.0 , 7.5, 10.0, 12.5, 15.0, 20.0, 25.0, 35.0, 50.0, 
             Inf )
dat <- c (6.6 ,12.5 ,15.2 ,16.6 ,15.8 ,11.0 ,13.1 ,4.6 ,3.0 ,1.1 ,0.5 )

hist (dat , breaks=brkvec )
## Error in hist.default(dat, breaks = brkvec) : 
##     some 'x' not counted; maybe 'breaks' do not span range of 'x' brkvec <- c(0,brkvec)
hist(dat, brkvec) ## Error in plot.window(xlim, ylim, "") : need finite 'xlim' values brkvec2 <- brkvec
brkvec2[brkvec2==Inf] <- max(brkvec2[is.finite(brkvec2)])+1
hist(dat,breaks=brkvec2,col="gray",freq=FALSE,axes=FALSE)
par(las=1,bty="l") ## cosmetic
axis(side=2)
axis(side=1,at=brkvec2,labels=brkvec) tt <- table(cut(dat,brkvec))
barplot(tt,names=names(tt)) (50,Inf]
-------------------------------------------------------------------------------------------------------
empl_count <- sample(1:500000,50)
yourbreaks <- seq(0,500000,by=50000)
x <- hist(empl_count,breaks=yourbreaks,plot=F)
x
plot(x, freq=T, axes=F,xlab="Number of employees in thousands", ylab="Frequency",main="50 largest companies")
axis(1,at=yourbreaks,labels=yourbreaks/1000,las=2)
axis(2,at=x$counts,labels=x$counts,las=1)
-------------------------------------------------------------------------------------------------------
setwd("path/to/csv/file")
myvalues <- read.csv("filename.csv")
hist(myvalues, 100) # Example: 100 breaks, but you can specify them at will ?read.table ?read.csv ?hist
-------------------------------------------------------------------------------------------------------
x=rnorm(n=10000,mean=0,sd=1)
y=rnorm(n=10000,mean=0,sd=3)
z=append(x,y)
x=subset(x,abs(x)<=10)
y=subset(y,abs(y)<=10)
z=subset(z,abs(z)<=10)
hx=hist(x,prob=T,breaks=b)
hy=hist(y,prob=T,breaks=b)
hz=hist(z,prob=T,breaks=b)
-------------------------------------------------------------------------------------------------------
ysize<-sum(t$Sum_of_OHR.s)*1.1
cbreaks<-seq(0,1,by=0.05)
histr<-hist(t$Sum_of_OHR.s,breaks=cbreaks,ylim=c(0,ysize))
-------------------------------------------------------------------------------------------------------
base grid.table library(gridExtra)

layout(matrix(c(1,0,2,0), 2))
hist(iris$Sepal.Length, col="lightblue")
hist(iris$Sepal.Width, col="lightblue")

pushViewport(viewport(y=.25,height=.5))
grid.table(head(iris), h.even.alpha=1, h.odd.alpha=1,
           v.even.alpha=0.5, v.odd.alpha=1) viewport grid.rect()
-------------------------------------------------------------------------------------------------------
plotrix weighted.hist w<-seq(1,1000)
v<-sort(runif(1000))
weighted.hist(v, w)
-------------------------------------------------------------------------------------------------------
hist(data$V1, xlim=c(0,200000), breaks=100) data <- read.table("sample.txt", header=FALSE)
    data.hist <- hist(data$V1, breaks=length(data$V1), xlim=c(0,4000000))
    plot(data.hist$counts, type='h')
-------------------------------------------------------------------------------------------------------
hist(x, main=bquote(Average~bar(X)==.(average) ) bquote hist(x, main=bquote( Average ~ bar(X) == .( average ) ) ~~~ bquote
-------------------------------------------------------------------------------------------------------
* substitute hist(x, main = substitute("Average "*bar(x)*" = "*average, list(average=average)))
-------------------------------------------------------------------------------------------------------
sampnorm01 <- function(n) qnorm(runif(n,min=pnorm(0),max=pnorm(1))) mysamp <- sampnorm01(1e5)
hist(mysamp)
-------------------------------------------------------------------------------------------------------
# # d1 <- read.table(text = "
emp   received   negotiated   gender   year
#325  12.5         TRUE         F      2013
#318  5.2          FALSE        F      2013
#217  9.8          FALSE        M      2013
#223  6.8          TRUE         M      2013
#218  2.1          TRUE         F      2006
#601  13.9         FALSE        M      2006
#225  7.8          TRUE         M      2006
#281  8.5          FALSE        F      2006", 
    header = TRUE) str(d1)
'data.frame':   0 obs. of  5 variables:
 $ emp       : logi 
 $ received  : logi 
 $ negotiated: logi 
 $ gender    : logi 
 $ year      : logi # d2 <- read.table(text = "
emp   received   negotiated   gender   year
325  12.5         TRUE         F      2013
318  5.2          FALSE        F      2013
217  9.8          FALSE        M      2013
223  6.8          TRUE         M      2013
218  2.1          TRUE         F      2006
601  13.9         FALSE        M      2006
225  7.8          TRUE         M      2006
281  8.5          FALSE        F      2006", 
    header = TRUE) str(d2)
'data.frame':   8 obs. of  5 variables:
 $ emp       : int  325 318 217 223 218 601 225 281
 $ received  : num  12.5 5.2 9.8 6.8 2.1 13.9 7.8 8.5
 $ negotiated: logi  TRUE FALSE FALSE TRUE TRUE FALSE ...
 $ gender    : Factor w/ 2 levels "F","M": 1 1 2 2 1 2 2 1
 $ year      : int  2013 2013 2013 2013 2006 2006 2006 2006 hist(d$received[d$negotiated == TRUE])
hist(d$received[d$negotiated == FALSE])

-------------------------------------------------------------------------------------------------------
```{r} ---

```{r}
list(5, 6, 7)
```


    ```{r}`r ''`
    hist(rnorm(100))
    5 + 6
    ```

---
-------------------------------------------------------------------------------------------------------
data.table # Make a data set of random sequences
rows = 46482
cols = 56
binsize = 20
founder.cols = 1:8
sample.cols = setdiff(1:cols,founder.cols)
data = as.data.frame( matrix( sample( c("A","C","T","G"), 
                                      rows * cols, replace=TRUE ), 
                              ncol=cols ) )

# Split the data into bins
binlevels = gl(n=ceiling(rows/binsize),k=20,length=rows)
databins = split(data,binlevels)

# A function for making a similarity matrix
compare_cols = function(i,j,mat) mean(mat[,i] == mat[,j])
compare_group_cols = function(mat, group1.cols, group2.cols) {
  outer( X=group1.cols, Y=group2.cols, 
        Vectorize( function(X,Y) compare_cols(X,Y,mat) ) )
}

# Apply the function to each bin
mats = lapply( databins, compare_group_cols, sample.cols, founder.cols )

# And just to check. Random sequences should match 25% of the time. Right?
hist( vapply(mats,mean,1), n=30 ) # looks like this is the case
-------------------------------------------------------------------------------------------------------
hist rep hist with(df, hist(rep(x = Bin, times = Number)))
-------------------------------------------------------------------------------------------------------
from rpy2 import robjects as ro
import numpy
data = numpy.random.random(1000) vecstr = "c({})".format(",".join(map(str, data)))
cmd = 'hist({},xlab="val", ylab="count", main="")'.format(vecstr)
ro.r(cmd) len(cmd)>15000 subprocessing ro.r.hist(ro.FloatVector(data), xlab="val", ylab="count", main="") In [29]: data1 = numpy.random.random(1000)

In [30]: data2 = numpy.random.random(1000)

In [31]: %%timeit
   ....: ro.r.cor(ro.FloatVector(data1), ro.FloatVector(data2))[0]
   ....: 
1000 loops, best of 3: 1.01 ms per loop

In [32]: %%timeit
   ....: vec1str = "c({})".format(",".join(map(str, data1)))
   ....: vec2str = "c({})".format(",".join(map(str, data2)))
   ....: ro.r("cor({},{})".format(vec1str, vec2str))
   ....: 
100 loops, best of 3: 5.86 ms per loop
-------------------------------------------------------------------------------------------------------
B <- rlnorm(10000)
H <- hist(log10(B), freq = FALSE, col="blue", xaxt="n", xlab="B") 
at <- H$mids
axis(1,at=at,labels=round(10^at,2))
curve(dnorm(x, mean=mean(log10(B)), sd=sd(log10(B))), add=TRUE)
-------------------------------------------------------------------------------------------------------
path.length.hist which.max(path.length.hist(g)$res)
-------------------------------------------------------------------------------------------------------
as.POSIXct time as.POSIXlt hist(as.POSIXlt(as.POSIXct(time),tz="Australia/Sydney"),"hours")
-------------------------------------------------------------------------------------------------------
hist(rpois(100, 5))
-------------------------------------------------------------------------------------------------------
0.05 * 3036 = 151.8 NA library(matrixStats)

# To extract your values...
myfun <- function(k, q){x[k, x[k,] > q]}
x <- matrix(sample(1:100, 60*3036, replace=TRUE), ncol=3036)
xx <- mapply(myfun, seq(along=x[,1]), rowQuantiles(x, probs=.95))
# xx is a list, xx[[1]] contains the values of x[1,] > quantile(x[1, ], .95)

# The number of selected values depends on their distribution - with NORM should be stable
x11() ; par(mfrow=c(2,1))
hist(sample(1:100, 60*3036, replace=TRUE)) # UNIF DISTRIB
n.val <- sapply(xx, length)
hist(n.val, xlab="n.val > q_95%")
abline(v=152, col="red", lwd=5)

# Assuming you want the same number of value for each row
n <- min(n.val)
myfun <- function(x){sample(x, n)} # Representative sample - Ordering is possible but introduce bias. Depends on your goals
xx <- t(sapply(xx, myfun))
dim(xx) # 60 n
-------------------------------------------------------------------------------------------------------
h<-hist(g, breaks=10, density=10, col="lightgray", xlab="Accuracy", main="Overall") 
    xfit<-seq(min(g),max(g),length=40) 
    yfit<-dnorm(xfit,mean=mean(g),sd=sd(g)) 
    yfit <- yfit*diff(h$mids[1:2])*length(g) 
    lines(xfit, yfit, col="black", lwd=2)
-------------------------------------------------------------------------------------------------------
x.vals <- c(mean(g)-(1:3*sd(g)), mean(g), mean(g)+(1:3*sd(g)))
y.vals <- dnorm(x.vals, mean=mean(g),sd=sd(g))*diff(h$mids[1:2])*length(g)
segments(x0=x.vals, y0=0, x1=x.vals, y1=y.vals) xlim=c(-3,13) hist() xfit
-------------------------------------------------------------------------------------------------------
hist myhist <- hist(mtcars$mpg)
multiplier <- myhist$counts / myhist$density
mydensity <- density(mtcars$mpg)
mydensity$y <- mydensity$y * multiplier[1]

plot(myhist)
lines(mydensity) myhist <- hist(mtcars$mpg)
multiplier <- myhist$counts / myhist$density
mydensity <- density(mtcars$mpg)
mydensity$y <- mydensity$y * multiplier[1]

plot(myhist)
lines(mydensity)

myx <- seq(min(mtcars$mpg), max(mtcars$mpg), length.out= 100)
mymean <- mean(mtcars$mpg)
mysd <- sd(mtcars$mpg)

normal <- dnorm(x = myx, mean = mymean, sd = mysd)
lines(myx, normal * multiplier[1], col = "blue", lwd = 2)

sd_x <- seq(mymean - 3 * mysd, mymean + 3 * mysd, by = mysd)
sd_y <- dnorm(x = sd_x, mean = mymean, sd = mysd) * multiplier[1]

segments(x0 = sd_x, y0= 0, x1 = sd_x, y1 = sd_y, col = "firebrick4", lwd = 2)
-------------------------------------------------------------------------------------------------------
d<-read.csv(text="terms,count
1,10
5,17
3,28
9,30")

hist(d)   # No error ... but not the plot you wanted. data.csv file:data.csv barchart barplot require(lattice)
# dividing by total "counts" to get the fractional values
 barchart(count/sum(d$count)~factor(terms), data=d)
-------------------------------------------------------------------------------------------------------
hist() > df <- data.frame(obj = c(1,2,3,4,5), count = c(2,3,5,4,2))

> hist(df)
Error in hist.default(df) : 'x' must be numeric

> hist(rep(df$obj, df$count), breaks=0:5)
[img]

> rep(df$obj, df$count)
 [1] 1 1 2 2 2 3 3 3 3 3 4 4 4 4 5 5 rep(a,n) a n hist()
-------------------------------------------------------------------------------------------------------
hist breaks x = rnorm(100, 500, 400)
range(x) hist(x, breaks = c(min(x), 500, 750, 1000, 1250,  1500, max(x)), freq = FALSE)
-------------------------------------------------------------------------------------------------------
hist hist(cancerchi) cancerchi cancerchi hist hist(as.data.frame(unlist(cancerchi))) cancerchi hist # i.e
class(cancerchi)
hist(cancerchi) # will still give you an error (class(cancerchi2 <- unlist(cancerchi)))
(class(cancerchi3 <- as.data.frame(unlist(cancerchi))))

# using the ldply function in the plyr package
library(plyr)
(class(cancerchi4 <- ldply(cancerchi))) hist hist(cancerchi2)
hist(cancerchi3[,1]) # specify column because cancerchi3 is a data frame, not a vector
hist(cancerchi4[,1]) # specify column because cancerchi4 is a data frame, not a vector str attributes
-------------------------------------------------------------------------------------------------------
HES2<-c("6472685" ,"6472960" ,"6473183" ,"6473556" ,"6473721" ,"6473880" ,"6474011", "6474016" ,"6474021","6474026" ,"6474031" ,"6474036" ,"6474595", "6475487", "6475525" ,"6475625", "6475843", "6475847","6475851", "6476040" ,"6476416", "6477257", "6477498", "6477543" ,"6478033" ,"6478181" ,"6480077","6481025" ,"6481370", "6481426" ,"6483450" ,"6483762" ,"6483892", "6484023" ,"6484664")

HES2<-as.numeric(HES2)
bin_w<-100
h=hist(x=HES2,breaks=bin_w,plot=FALSE)
counts<-data.frame(from=h$breaks,to=h$breaks+bin_w,count=c(h$count,0))
counts[which(counts$count>0),]

      from      to count
1  6472600 6472700     1
4  6472900 6473000     1
6  6473100 6473200     1
10 6473500 6473600     1
12 6473700 6473800     1
13 6473800 6473900     1
-------------------------------------------------------------------------------------------------------
table > tab <- table(values)
values
1 2 3 4 5 6 7 
1 2 2 1 1 2 1 > as.data.frame(tab)
  values Freq
1      1    1
2      2    2
3      3    2
4      4    1
5      5    1
6      6    2
7      7    1 hist(values)  # histogram of `values`
plot(tab)     # plot of `tab`, table of frequencies
barplot(tab)  # plot of `tab`, table of frequencies
-------------------------------------------------------------------------------------------------------
hist(rbeta(10000,5,2))
hist(rbeta(10000,2,5))
hist(rbeta(10000,5,5))
-------------------------------------------------------------------------------------------------------
N <- 10000
 x <- rnbinom(N, 10, .5)
 hist(x, xlim=c(min(x),max(x)), probability=T, nclass=max(x)-min(x)+1, col='lightblue', xlab=' ', ylab=' ', axes=F,main='Positive Skewed')
lines(density(x,bw=1), col='red', lwd=3) curve(dbeta(x,8,4),xlim=c(0,1))
title(main="posterior distrobution of p")
-------------------------------------------------------------------------------------------------------
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
arDates = pd.Series(pd.DatetimeIndex([u'2013-11-27T02:02:50',  u'2013-11-25T00:00:00', u'2013-11-25T00:00:00',
    u'2013-11-25T00:00:00']).dayofyear)
arDates.hist()
plt.show()
print np.histogram(arDates) (array([3, 0, 0, 0, 0, 0, 0, 0, 0, 1]), array([ 329. ,  329.2,  329.4,  329.6,  329.8,  330. ,  330.2,  330.4,
        330.6,  330.8,  331. ]))
-------------------------------------------------------------------------------------------------------
hist(dat$StartDate, breaks = "days") hist(dat$StartTime, breaks = "mins")
-------------------------------------------------------------------------------------------------------
for replicate set.seed(1)
X <- replicate(1000, rnorm(25,mean=37,sd=45)) 
X_bar <- colMeans(X)
hist(X_bar) # this is how the distribution of X_bar looks like
-------------------------------------------------------------------------------------------------------
xbar=c()
            for(i in 1:1000){
              x=rnorm(25,mean=37,sd=45)
              xbar=c(xbar,mean(x)) #save every time the value of xbar

            }
            hist(xbar) #plot the hist of xbar
            #compute the probability to b    e bigger thant 43.1
            prob=which(xbar>43.1)/length(xbar)
-------------------------------------------------------------------------------------------------------
runApp(list(
  ui = bootstrapPage(
    HTML("<h1>Hello World</h1>")
  ),
  server = function(input, output) {
    output$plot <- renderPlot({ hist(runif(input$n)) })
  }
))
-------------------------------------------------------------------------------------------------------
N[mu, sd/sqrt(n)] mu sd n data N[37,45] means sd(mean) ~ sd(data)/sqrt(25) data  <- data.frame(sample=rep(1:100,each=25),x = rnorm(2500,mean=37,sd=45))
means <- aggregate(data$x,by=list(data$sample),mean)
#plot histoggrams
par(mfrow=c(1,2))
hist(data$x,main="",sub="Histogram of Underlying Data",xlim=c(-150,200))
hist(means$x,main="",sub="Histogram of Means", xlim=c(-150,200))
mtext("Underlying Data ~ N[37,45]",outer=T,line=-3)
c(sd.data=sd(data$x), sd.means=sd(means$x))
sd.data  sd.means 
43.548570  7.184518 sd(mean) ~ sd(data)/sqrt(25) data  <- data.frame(sample=rep(1:100,each=25),x = runif(2500,min=-150, max=200))
means <- aggregate(data$x,by=list(data$sample),mean)
#plot histoggrams
par(mfrow=c(1,2))
hist(data$x,main="",sub="Histogram of Underlying Data",xlim=c(-150,200))
hist(means$x,main="",sub="Histogram of Means", xlim=c(-150,200))
mtext("Underlying Data ~ U[-150,200]",outer=T,line=-3)
c(sd.data=sd(data$x), sd.means=sd(means$x))
sd.data sd.means 
99.7800  18.8176
-------------------------------------------------------------------------------------------------------
x <- rnorm(100) # example data

hist(x, freq = FALSE) # you need to specify freq = FALSE
lines(density(x))
-------------------------------------------------------------------------------------------------------
hist tapply ## get all files in directory split1
res <- sapply(list.files("split1",full.names=TRUE), 
             function(x){
              dat <- read.csv(x)
              ## EDIT :remove data outside the range
              dat <- dat[dat$Value <=200,]
              counts <- hist(dat$Value,breaks=seq(200),plot=FALSE)
              rm(dat)
              }
     )

## aggregate all counts and create a single data.frame
dat <- data.frame(Value=rowSums(res),
                breaks = seq(200))

## plot the histogram
ggplot(dat) + 
    geom_bar(aes(x=breaks,y=Value),stat='identity')
-------------------------------------------------------------------------------------------------------
res <- sapply(list.files("split1/", pattern = "*.csv",  full.names=TRUE), 
          function(x){
            dat <- read.csv(x)
            dat.clean <- dat$Value[which(dat$Value > 0 & dat$Value< 200)]
            dat.counts <- hist(dat.clean, breaks = seq(0, 200, by = 1), plot = FALSE)
            rm(dat, dat.clean)
            # return the $counts field from hist to avoid complicating the list res
            dat.counts$counts
          })

## aggregate all counts and create a single data.frame
dat <- data.frame(Value= rowSums(res),
              breaks = seq(200))

## plot the histogram
ggplot(dat) + 
  geom_bar(aes(x=breaks,y=Value),stat='identity')
-------------------------------------------------------------------------------------------------------
v<- function()
 {
  v <- rnorm(input$Vector)#take vector as input
} as.numeric(...) output$plotVector <- renderPlot({  hist(as.numeric(v))}) shinyUI(...) input output input select selectInput(...) "Vector" input$Vector Vector output$mainplot <- ... output$main_plot ui.R ... plotOutput("main_plot")... library(shiny)
shinyUI(pageWithSidebar(
  headerPanel("Hello Shiny!"),
  sidebarPanel(selectInput("Vector", "Select Mean of Distribution", c(0,1,2,3,4), selected = 0, multiple = TRUE)),
  mainPanel( plotOutput("main_plot"))
)) library(shiny)
shinyServer(function(input, output) {
  v<- function() {
    return(rnorm(100,mean=as.numeric(input$Vector)))  
  }
  output$main_plot <- 
    renderPlot( 
      hist(v(), breaks=10, xlab="",
           main="Histogram of 100 Samples\n taken from: N[mean, sd=1]")) 
})
-------------------------------------------------------------------------------------------------------
library(shiny)
shinyServer(function(input, output) {

v<- function()
 {
  v <- rnorm(input$Vector)#take vector as input
}

  output$plotVector <- renderPlot({  
data <- v()
hist(data)
    }) 

})
-------------------------------------------------------------------------------------------------------
x <- get(varchoice, myData) hist(x, col="blue") library(gWidgets2)
options(guiToolkit="tcltk")

myData <- mtcars
w <- gwindow("Make a histogram", visible=FALSE)
lyt <- glayout(cont=w)
lyt[1,1] <- "Variables"
lyt[2,1] <- "Choose one"
lyt[2,2:4] <- (tbl <- gtable(names(myData), cont=lyt))
size(tbl) <- c(200, 100)
lyt[3,1] <- (btn <- gbutton("ok", cont=lyt))

addHandlerClicked(btn, handler=function(h,...) {
  x <- get(svalue(tbl), myData)
  hist(x, col="blue")
})
visible(w) <- TRUE
-------------------------------------------------------------------------------------------------------
breaks xaxp # this just gives me your data:
my.data <- "
0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0
 1 1 0 0 0 0 1 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0
 0 0 1 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 1 0 0 0 0 0 0 1
 1 1 0 0 1 1 1 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 1 0 0 1 0 0 0
 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 1 0 1 1 0 0 0 0 1 0 0 0
 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 1 0 1 0 1 0 0 0 0 0
 0 0 0 0 0 1 0 1 0 0 0 0 0 0 1 0 0 0 0 1 1 0 1 0 1 0 1 1 0 0 0 0 0 0 0 0 1
 1 0 0 0 0 0 0 1 1 1 1 0 0 0 1 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 1 0 1 0 0 0
 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 1 1 0 0 0 0 0 1 1 1 0 0 0 0 1
 0 0 0 0 1 0 0 0 0 0 0 1 1 0 0 0 1 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 1 0 0 0 0
 0 0 0 0 0 0 0 0 0 0 0 0"
my.data <- unlist(strsplit(my.data, " "))
my.data <- gsub("\\n", "", my.data)
my.data <- as.numeric(my.data)

hist(my.data, breaks=c(-.5, .5, 1.5), xaxp=c(0,1,1)) breaks xaxp xaxp > table(my.data)
my.data
  0   1 
296  86
-------------------------------------------------------------------------------------------------------
replicate x <- replicate(1000, {
  mm <- runif(10)
  mean(mm)
  })
hist(x)
-------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------
f(x) U[0,1] f f(x)     = your density function, 
F(x)     = cdf of f(x), and 
F.inv(y) = inverse cdf of f(x). f <- function(x) {((x-1)^2) * exp(-(x^3/3-2*x^2/2+x))}
F <- function(x) {integrate(f,0,x)$value}
F <- Vectorize(F)

F.inv <- function(y){uniroot(function(x){F(x)-y},interval=c(0,10))$root}
F.inv <- Vectorize(F.inv)

x <- seq(0,5,length.out=1000)
y <- seq(0,1,length.out=1000)

par(mfrow=c(1,3))
plot(x,f(x),type="l",main="f(x)")
plot(x,F(x),type="l",main="CDF of f(x)")
plot(y,F.inv(y),type="l",main="Inverse CDF of f(x)") f(x) [0,Inf] F(x) f(x) uniroot(...) F-y Vectorize(...) integrate(...) uniroot(...) X U[0,1] Z = F.inv(X) X <- runif(1000,0,1)   # random sample from U[0,1]
Z <- F.inv(X) Z f(x) par(mfrow=c(1,2))
plot(x,f(x),type="l",main="Density function")
hist(Z, breaks=20, xlim=c(0,5))
-------------------------------------------------------------------------------------------------------
library(ape)

heatmap.phylo <- function(x, Rowp, Colp, breaks, col, denscol="cyan", respect=F, ...){
    # x numeric matrix
    # Rowp: phylogenetic tree (class phylo) to be used in rows
    # Colp: phylogenetic tree (class phylo) to be used in columns
    # ... additional arguments to be passed to image function

    scale01 <- function(x, low = min(x), high = max(x)) {
        x <- (x - low)/(high - low)
        x
    }

    col.tip <- Colp$tip
    n.col <- 1
    if (is.null(col.tip)) {
        n.col <- length(Colp)
        col.tip <- unlist(lapply(Colp, function(t) t$tip))
        col.lengths <- unlist(lapply(Colp, function(t) length(t$tip)))
        col.fraction <- col.lengths / sum(col.lengths)
        col.heights <- unlist(lapply(Colp, function(t) max(node.depth.edgelength(t))))
        col.max_height <- max(col.heights)
    }

    row.tip <- Rowp$tip
    n.row <- 1
    if (is.null(row.tip)) {
        n.row <- length(Rowp)
        row.tip <- unlist(lapply(Rowp, function(t) t$tip))
        row.lengths <- unlist(lapply(Rowp, function(t) length(t$tip)))
        row.fraction <- row.lengths / sum(row.lengths)
        row.heights <- unlist(lapply(Rowp, function(t) max(node.depth.edgelength(t))))
        row.max_height <- max(row.heights)
    }

    cexRow <- min(1, 0.2 + 1/log10(n.row))
    cexCol <- min(1, 0.2 + 1/log10(n.col))

    x <- x[row.tip, col.tip]
    xl <- c(0.5, ncol(x)+0.5)
    yl <- c(0.5, nrow(x)+0.5)

    screen_matrix <- matrix( c(
        0,1,4,5,
        1,4,4,5,
        0,1,1,4,
        1,4,1,4,
        1,4,0,1,
        4,5,1,4
    ) / 5, byrow=T, ncol=4 )

    if (respect) {
        r <- grconvertX(1, from = "inches", to = "ndc") / grconvertY(1, from = "inches", to = "ndc")
        if (r < 1) {
            screen_matrix <- screen_matrix * matrix( c(r,r,1,1), nrow=6, ncol=4, byrow=T)
        } else {
            screen_matrix <- screen_matrix * matrix( c(1,1,1/r,1/r), nrow=6, ncol=4, byrow=T)
        }
    }


    split.screen( screen_matrix )

    screen(2)
    par(mar=rep(0,4))

    if (n.col == 1) {
        plot(Colp, direction="downwards", show.tip.label=FALSE,xaxs="i", x.lim=xl)
    } else {
        screens <- split.screen( as.matrix(data.frame( left=cumsum(col.fraction)-col.fraction, right=cumsum(col.fraction), bottom=0, top=1)))
        for (i in 1:n.col) {
            screen(screens[i])
            plot(Colp[[i]], direction="downwards", show.tip.label=FALSE,xaxs="i", x.lim=c(0.5,0.5+col.lengths[i]), y.lim=-col.max_height+col.heights[i]+c(0,col.max_height))
        }
    }

    screen(3)
    par(mar=rep(0,4))

    if (n.col == 1) {
        plot(Rowp, direction="rightwards", show.tip.label=FALSE,yaxs="i", y.lim=yl)
    } else {
        screens <- split.screen( as.matrix(data.frame( left=0, right=1, bottom=cumsum(row.fraction)-row.fraction, top=cumsum(row.fraction))) )
        for (i in 1:n.col) {
            screen(screens[i])
            plot(Rowp[[i]], direction="rightwards", show.tip.label=FALSE,yaxs="i", x.lim=c(0,row.max_height), y.lim=c(0.5,0.5+row.lengths[i]))
        }
    }


    screen(4)
    par(mar=rep(0,4), xpd=TRUE)
    image((1:nrow(x))-0.5, (1:ncol(x))-0.5, x, xaxs="i", yaxs="i", axes=FALSE, xlab="",ylab="", breaks=breaks, col=col, ...)

    screen(6)
    par(mar=rep(0,4))
    plot(NA, axes=FALSE, ylab="", xlab="", yaxs="i", xlim=c(0,2), ylim=yl)
    text(rep(0,nrow(x)),1:nrow(x),row.tip, pos=4, cex=cexCol)

    screen(5)
    par(mar=rep(0,4))
    plot(NA, axes=FALSE, ylab="", xlab="", xaxs="i", ylim=c(0,2), xlim=xl)
    text(1:ncol(x),rep(2,ncol(x)),col.tip, srt=90, adj=c(1,0.5), cex=cexRow)

    screen(1)
    par(mar = c(2, 2, 1, 1), cex = 0.75)

    symkey <- T
    tmpbreaks <- breaks
    if (symkey) {
        max.raw <- max(abs(c(x, breaks)), na.rm = TRUE)
        min.raw <- -max.raw
        tmpbreaks[1] <- -max(abs(x), na.rm = TRUE)
        tmpbreaks[length(tmpbreaks)] <- max(abs(x), na.rm = TRUE)
    } else {
        min.raw <- min(x, na.rm = TRUE)
        max.raw <- max(x, na.rm = TRUE)
    }
    z <- seq(min.raw, max.raw, length = length(col))

    image(z = matrix(z, ncol = 1), col = col, breaks = tmpbreaks, 
          xaxt = "n", yaxt = "n")
    par(usr = c(0, 1, 0, 1))
    lv <- pretty(breaks)
    xv <- scale01(as.numeric(lv), min.raw, max.raw)
    axis(1, at = xv, labels = lv)

    h <- hist(x, plot = FALSE, breaks = breaks)
    hx <- scale01(breaks, min.raw, max.raw)
    hy <- c(h$counts, h$counts[length(h$counts)])
    lines(hx, hy/max(hy) * 0.95, lwd = 1, type = "s", 
          col = denscol)
    axis(2, at = pretty(hy)/max(hy) * 0.95, pretty(hy))
    par(cex = 0.5)
    mtext(side = 2, "Count", line = 2)

    close.screen(all.screens = T)

}

tree <- read.tree(text = "(A:1,B:1);((C:1,D:2):2,E:1);((F:1,G:1,H:2):5,((I:1,J:2):2,K:1):1);", comment.char="")
N <- sum(unlist(lapply(tree, function(t) length(t$tip))))

set.seed(42)
m <- cor(matrix(rnorm(N*N), nrow=N))
rownames(m) <- colnames(m) <- LETTERS[1:N]
heatmap.phylo(m, tree, tree, col=bluered(10), breaks=seq(-1,1,length.out=11), respect=T)
-------------------------------------------------------------------------------------------------------
cex hist() cex.axis cex.lab cex axis() cex.axis hist() mtext() cex cex=2/3 pointsize pdf()
-------------------------------------------------------------------------------------------------------
j list DT[, list( hist(V2,breaks = 2) ) , by = V1 ]
-------------------------------------------------------------------------------------------------------
>x = pmin(exp(rnorm(20)), 20)
>y = pmin(exp(rnorm(20)), 20)
>write.csv(data.frame(x,y),"/Users/foo/temp/randcsv.csv", row.names=FALSE)


>sumhists = function(file, cols=1:2, brk){
>   dat = read.csv(file, stringsAsFactors=FALSE)
>   nbins = length(brk)-1
>   nvars = length(cols)
>   newdat = matrix(NA, nrow=nbins, ncol=nvars+1)
>    newdat[,1] = brk[1:nbins]
>   for (col in cols) {
>    h=hist(dat[,col], plot=FALSE, breaks=brk)
>     newdat[,col+1] = h$counts
>    }
>    outdat = data.frame(newdat)
>    names(outdat) = c("breaks", names(dat)[cols])
>    outdat$total = rowSums(outdat[,-1])
>    return(outdat)
>   }

>#add countsd   
>sumhists("/Users/foo/temp/randcsv.csv", cols=1:2, brk=seq(0,20, by=1))
-------------------------------------------------------------------------------------------------------
dataA=rnorm(50)
dataB=rnorm(50)
A=hist(dataA,breaks=(seq(-6,6,by=1)))$counts
B=hist(dataB,breaks=(seq(-6,6,by=1)))$counts
avedata=mean(A+B)
avedata for apply avedata=NULL
datamatrix=matrix(NA,length("breaks"),"number of cols")
for(i in 1:"number of cols"){datamatrix[,i]=hist(yourdata[,i],breaks= (seq(-6,6,by=1))$counts)}
for(i in 1:length("breaks")){avedata[i]=datamatrix[i,]}
avedata
-------------------------------------------------------------------------------------------------------
ylim x <- rnorm(100)
h <- hist(x, plot = FALSE)  # Data that would be plotted
ylim <- range( h$counts )   # Default values
ylim[1] <- -5               # Change only one value
plot( h, ylim = ylim )      # or: hist( x, ylim = ylim )
-------------------------------------------------------------------------------------------------------
par(mfcol=c(12,12), oma=c(1,1,0,0), mar=c(1,1,1,0), tcl=-0.1, mgp=c(0,0,0))

for(m in 1:141 ){
  x <- rnorm(100)
  hist(x[x != 0],30, xlab=NA, ylab=NA, main=paste('data: ',m), 
        cex.axis=0.5, font.main=1, cex.main=0.8)
}
-------------------------------------------------------------------------------------------------------
lines() mids x lwd= lend="butt" set.seed(123)
x<-rnorm(100)
zz<-hist(x)

plot(x=c(-2.5,2.5),y=c(0,1),type="n")
lines(zz$mids, zz$density, type="h",lwd=50,lend="butt") plot(x=c(-2.5,2.5),y=c(0,1),type="n")
lines(zz$mids, zz$density, type="h",lwd=50,lend="butt")
lines(zz$mids, zz$density-0.005, type="h",lwd=48,lend="butt",col="white")
-------------------------------------------------------------------------------------------------------
lines hist h <- hist(..., plot=FALSE)
# Other plotting functions go here.
lines(h) # will now plot the histogram in the plotting window.
-------------------------------------------------------------------------------------------------------
hist() add = TRUE freq = FALSE set.seed(123)
x<-rnorm(100)

plot(x, exp(x)/(1+exp(x)), col = "green") # some plot
hist(x, freq = FALSE, add = TRUE) hist rect() plot.histogram h <- hist(x, plot = FALSE) # computation
rect(h$breaks[-length(h$breaks)], 0, h$breaks[-1], h$intensities) # plotting
-------------------------------------------------------------------------------------------------------
par( mfrow=c(1,2) ) 
invisible(lapply(1:ncol(Data), function(i){
  x <- Data[,i]
  hist(x, col=c("red","blue"),
       main = paste0("Histogram of ", names(Data)[i]),
       xlab="X-Axis", ylab="Y-Axis", 
       cex.lab= 1, col.lab="blue",
       prob=TRUE)

  curve(dnorm(x, mean=mean(x), sd=sd(x)), 
        add=TRUE, col="blue", lwd=2)

}))

par( mfrow=c(1,1))
-------------------------------------------------------------------------------------------------------
Data <- structure(list(data1 = c(155, 195, 21, 15, 190, 2, 182, 115, 
                                 170, 17), data2 = c(130, 10, 26, 210, 15, 205, 50, 55, 1, 56)), .Names = c("data1", 
                                                                                                            "data2"), row.names = c(NA, -10L), class = "data.frame")
par( mfrow=c(1,2) ) 
invisible(lapply(1:ncol(Data), function(i){
  x <- Data[,i]
  h <- hist(x, col=c("red","blue"),
            main = paste0("Histogram of ", names(Data)[i]),
            xlab="X-Axis", ylab="Y-Axis", breaks=5,
            cex.lab= 1, col.lab="blue")
  xfit<-seq(min(x),ceiling(210/50)*50,length=40) 
  yfit<-dnorm(xfit,mean=mean(x),sd=sd(x)) 
  yfit <- yfit*diff(h$mids[1:2])*length(x) 
  lines(xfit, yfit, col="green", lwd=2)
}))
-------------------------------------------------------------------------------------------------------
subplot subplot grconvertX grconvertY library(TeachingDemos)
plot(1:10)
subplot(hist(1:10), grconvertX(c(.1, .4), "npc"), grconvertY(c(.7, .9), "npc"))
-------------------------------------------------------------------------------------------------------
m <- matrix(c(1,1,1,
              2,3,4,
              5,6,7), ncol=3, by=T)
l <- layout(m)
layout.show(l)  # show layout to doublecheck

# layout cells are filled in the order of the numbers
# set par, e.g. mar each time if required

for (i in 1:7) {
  par(mar=c(i,i,i,i))
  hist(rnorm(100), col=i)
}
-------------------------------------------------------------------------------------------------------
freq = FALSE hist set.seed(1)
Y1 <- rgamma(100, 10, 3)

hist(Y1, breaks = 30, freq = FALSE)
dens <- density(Y1)
lines(dens)
-------------------------------------------------------------------------------------------------------
x <- c("18.12.2003", "06.04.2005", "06.04.2005", "07.04.2005", "27.05.2005", 
  "16.06.2009", "16.06.2009", "21.12.2009", "22.12.2009", "09.06.2011", 
  "14.06.2011", "20.12.2011", "20.12.2011", "04.02.2008", "27.03.2009", 
  "01.04.2009", "15.12.2009", "23.09.2005", "19.06.2005", "20.06.2005", 
  "20.06.2005", "20.06.2005", "21.06.2005", "31.05.2005", "24.01.2007", 
  "24.01.2007", "24.01.2007", "15.05.2007", "16.05.2007", "16.05.2007", 
  "18.05.2007", "21.05.2007", "21.05.2007", "22.05.2007", "22.05.2007"
)

hist(as.Date(x, '%d.%m.%Y'), breaks="days", freq=TRUE)
-------------------------------------------------------------------------------------------------------
x.pois Y1 Y1 <- 100
set.seed(101) ## for reproducibility
x.pois<-rpois(Y1, 20)
hist(x.pois, breaks=100,freq=FALSE)
lines(density(x.pois, bw=0.8), col="red")
library(MASS)
(my.mle<-fitdistr(x.pois, densfun="poisson"))
##      lambda  
##   20.6700000 
##  ( 0.4546427)
BIC(my.mle)
## [1] 572.7861 Y1 rpois() Y1 x.pois
-------------------------------------------------------------------------------------------------------
sapply(names(mydata_x)[-1], function(name){
  # Histogram
  h.name <- paste0("hist_mydata_x_", name)
  png(paste0(h.name,".jpg"))
  hist(mydata_x[,name], main=h.name, xlab=name)
  dev.off()
  # Boxplot
  b.name <- paste0("boxplot_mydata_x_", name)
  png(paste0(b.name, ".jpg"))
  boxplot(mydata_x[,name], main=b.name, xlab=name)
  dev.off()
  # Density
  d.name <- paste0("density_mydata_x_", name)
  png(paste0(d.name, ".jpg"))
  plot(density(mydata_x[,name]), main=d.name)
  dev.off()
}) mydata_x sapply(names(mydata_x)[-1], function(name){...}) mydata_x sex png() hist_mydata_x_height_chad1.jpg
-------------------------------------------------------------------------------------------------------
ylab ylab = expression(bold(Density)) hist(faithful$waiting, ylab = expression(bold(Density))) font.lab hist(faithful$waiting, ylab = "")
title(ylab = "Density", font.lab = 2) ylab hist(faithful$waiting, ylab = "Density", font.lab = 2)
-------------------------------------------------------------------------------------------------------
barplot hist hist(subset(infert, case==0)$age, freq=FALSE) age barplot table dat <- infert[infert$case==0, "education"]
barplot(table(dat)/length(dat))
-------------------------------------------------------------------------------------------------------
hist freq=FALSE prob=TRUE h <- hist(test,plot=FALSE)
 h$counts <- h$counts/length(test)
 plot(h) hist(test,freq=FALSE,breaks=0:10) plot(table(test)/length(test)) plot(table(test)/length(test),lwd=10,lend="butt")
-------------------------------------------------------------------------------------------------------
X11() hist() x11() quartz() ?x11() ?quartz()
-------------------------------------------------------------------------------------------------------
