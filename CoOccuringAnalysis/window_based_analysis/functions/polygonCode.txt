vd <- venndia(A=LETTERS[1:15], B=LETTERS[5:20], getdata=TRUE) venndia(A=LETTERS[1:15], B=LETTERS[5:20]) circle <- function(x, y, r, ...) {
    ang <- seq(0, 2*pi, length = 100)
    xx <- x + r * cos(ang)
    yy <- y + r * sin(ang)
    polygon(xx, yy, ...)
}

venndia <- function(A, B, C, getdata=FALSE, ...){
    cMissing <- missing(C)
    if(cMissing){ C <- c() }

    unionAB <- union(A, B)
    unionAC <- union(A, C)
    unionBC <- union(B, C)
    uniqueA <- setdiff(A, unionBC)
    uniqueB <- setdiff(B, unionAC)
    uniqueC <- setdiff(C, unionAB)
    intersAB <- setdiff(intersect(A, B), C)
    intersAC <- setdiff(intersect(A, C), B)
    intersBC <- setdiff(intersect(B, C), A)
    intersABC <- intersect(intersect(A, B), intersect(B, C))

    nA <- length(uniqueA) 
    nB <- length(uniqueB)
    nC <- length(uniqueC)

    nAB <- length(intersAB)
    nAC <- length(intersAC)
    nBC <- length(intersBC)

    nABC <- length(intersABC) 

    par(mar=c(2, 2, 0, 0))
    plot(-10, -10, ylim=c(0, 9), xlim=c(0, 9), axes=FALSE, ...)
    circle(x=3, y=6, r=3, col=rgb(1,0,0,.5), border=NA)
    circle(x=6, y=6, r=3, col=rgb(0,.5,.1,.5), border=NA)
    circle(x=4.5, y=3, r=3, col=rgb(0,0,1,.5), border=NA)

    text( x=c(1.2, 7.7, 4.5), y=c(7.8, 7.8, 0.8), c("A", "B", "C"), cex=3, col="gray90" )

    text(
     x=c(2, 7, 4.5, 4.5, 3, 6, 4.5), 
     y=c(7, 7, 2  , 7  , 4, 4, 5), 
     c(nA, nB, nC, nAB, nAC, nBC, nABC), 
     cex=2
    )

    if(getdata){
     list(A=uniqueA, B=uniqueB, C=uniqueC, 
      AB=intersAB , AC=intersAC , BC=intersBC , 
      ABC=intersABC
     )
    }
}
-------------------------------------------------------------------------------------------------------
polygon x <- seq(as.POSIXct("1949-01-01", tz="GMT"), length=36, by="months")
y <- rnorm(length(x))
plot(x, y, type="n", ylim=c(-1,1)*max(abs(y)))
polygon(c(x, rev(x)), c(y, -rev(y)), col="cornflowerblue", border=NA) panel.polygon lattice library("lattice")
library("RColorBrewer")

df <- data.frame(x=rep(x,3),
                 y=rnorm(3*length(x)),
                 variable=gl(3, length(x)))

p <- xyplot(y~x|variable, data=df,
            ylim=c(-1,1)*max(abs(y)),
            layout=c(1,3),
            fill=brewer.pal(3, "Pastel2"),
            panel=function(...) {
              args <- list(...)
              print(args)
              panel.polygon(c(args$x, rev(args$x)),
                            c(args$y, -rev(args$y)),
                            fill=args$fill[panel.number()],
                            border=NA)
            })
print(p)
-------------------------------------------------------------------------------------------------------
rawData <- read.csv("solar.csv", na.strings="-")
data <- ts(t(as.matrix(rawData[,2:13])), names=rawData[,1], start=1996)

inkblot <- function(series, col=NULL, min.height=40, col.value=24, col.category=17, ...) {  
  # assumes non-negative values  
  # assumes that series is multivariate series  
  # assumes that series names are set, i.e. colnames(series) != NULL  

  x <- as.vector(time(series))  
  if(length(col)==0){  
    col <- rainbow(dim(series)[2])  
  }  

  ytotal <- 0  
  for(category in colnames(series)) {  
    y <- series[, category]
    y <- y[!is.na(y)]
    ytotal <- ytotal + max(y, min.height)  
  }  

  oldpar = par(no.readonly = TRUE)   
  par(mar=c(2,3,0,10)+0.1, cex=0.7)  

  plot(x, 1:length(x), type="n", ylim=c(0,1)*ytotal, yaxt="n", xaxt="n", bty="n", ylab="", xlab="", ...) 
  axis(side=1, at=x)  

  catNumber <- 1  
  offset <- 0  
  for(category in rev(colnames(series))) {  
    print(paste("working on: ", category))
    y <- 0.5 * as.vector(series[,category])  
    offset <- offset + max(max(abs(y[!is.na(y)])), 0.5*min.height)  
    print(paste("offset= ", str(offset)))
    polygon(c(x, rev(x)), c(offset+y, offset-rev(y)), col=col[catNumber], border=NA)  
    mtext(text=y[1], side=2, at=offset, las=2, cex=0.7, col=col.value)  
    mtext(text=y[length(y)], side=4, line=-1, at=offset, las=2, cex=0.7, col=col.value)  
    mtext(text=category, side=4, line=2, at=offset, las=2, cex=0.7, col=col.category)  
    offset <- offset + max(max(abs(y[!is.na(y)])), 0.5*min.height)  
    catNumber <- catNumber + 1   
  }  
}  


inkblot(data)
-------------------------------------------------------------------------------------------------------
stackedPlot = function(data, time=NULL, col=1:length(data), ...) {

  if (is.null(time))
    time = 1:length(data[[1]]);

  plot(0,0
       , xlim = range(time)
       , ylim = c(0,max(rowSums(data)))
       , t="n" 
       , ...
       );

  for (i in length(data):1) {

    # Die Summe bis zu aktuellen Spalte
    prep.data = rowSums(data[1:i]);

    # Das Polygon muss seinen ersten und letzten Punkt auf der Nulllinie haben
    prep.y = c(0
                , prep.data
                , 0
                )

    prep.x = c(time[1]
                , time
                , time[length(time)]
                )

    polygon(prep.x, prep.y, col=col[i], border = NA);
  }
} wide = reshape(data, idvar="ThingAge", timevar="VisitWeek", direction="wide");
stackedPlot(wide);
-------------------------------------------------------------------------------------------------------
help(polygon) example(polygon) demo(graphics) ## An example showing how to fill between curves.

par(bg="white")
n <- 100
x <- c(0,cumsum(rnorm(n)))
y <- c(0,cumsum(rnorm(n)))
xx <- c(0:n, n:0)
yy <- c(x, rev(y))
plot(xx, yy, type="n", xlab="Time", ylab="Distance")
polygon(xx, yy, col="gray")
title("Distance Between Brownian Motions")
-------------------------------------------------------------------------------------------------------
n <- 20
x <- rnorm(n)
y <- rnorm(n)
o <- order(x)
x <- x[o]
y <- y[o]
m <- loess(y~x, span = 1) #ggplot seems to smooth more than default
f <- predict(m, se = TRUE)
ci <- f$se * qt(0.975, f$df)
cih <- f$fit + ci
cil <- f$fit - ci
plot(x,y, ylim = c(min(cil,y), max(cih,y)))
lines(x, f$fit, lwd = 2)
xx <- c(x, rev(x))
yy <- c(cil, rev(cih))
polygon(xx, yy, col="#A9A9A930", border = NA)
-------------------------------------------------------------------------------------------------------
#loess and error curves almost just like ggplot2
op <- par(las=1, mar = c(3,3,1,1))
n <- 30
x <- sort(rnorm(n)) #(varying density in predictor)
x <- x + abs(min(x))
x <- x/max(x)*2*pi 
y <- sin(x)+rnorm(n) #(curvy)
m <- loess(y~x)
xx <- seq(min(x), max(x), (max(x)-min(x))/1000) #increase density of values to predict over to increase quality of curve
f <- predict(m, xx, se = TRUE)
ci <- f$se * qt(0.975, f$df)
cih <- f$fit + ci
cil <- f$fit - ci
plot(x,y, ylim = c(min(cil,y), max(cih,y)), cex.axis = 0.85, xlab = '', ylab = '', type = 'n')
title(xlab = 'x', ylab = 'y',line = 2)
grid(col = 'gray')
points(x,y, pch = 19, cex = 0.65)
lines(xx, f$fit, col = 'blue', lwd = 1.2)
xx <- c(xx, rev(xx))
yy <- c(cil, rev(cih))
polygon(xx, yy, col=rgb(0.1,0.1,0.1,0.25), border = NA)
par(op)

#qplot(x,y, geom = 'point') + stat_smooth()
-------------------------------------------------------------------------------------------------------
library(maps)
    p <- matrix(c(50, 50, 80, 100, 70, 40, 25, 60), ncol=2)     
    plot(p, pch = 16, col = "red", cex = 3, xlim = range(p[,1]) + c(-10,10), ylim = range(p[,2]) + c(-5, 5))
    map(add = TRUE)
    #click until happy, right-click "stop" to finish
    p <- locator(type = "l")
    map()
    polygon(cbind(p$x, p$y), col = "blue")
-------------------------------------------------------------------------------------------------------
bezier Hmisc ## make some points
p <- matrix(c(50, 50, 80, 100, 70, 40, 25, 60), ncol=2)
## add the starting point to the end
p2 <- cbind(1:5,p[c(1:4,1),])
## linear interpolation between these points                            
t.coarse <- seq(1,5,0.05)
x.coarse <- approx(p2[,1],p2[,2],xout=t.coarse)$y
y.coarse <- approx(p2[,1],p2[,3],xout=t.coarse)$y
## create a Bezier curve                                           
library(Hmisc)
bz <- bezier(x.coarse,y.coarse)
library(maps)
map('world')
map.axes()
polygon(bz$x,bz$y, col=rgb(0,0,1,0.5),border=NA)
-------------------------------------------------------------------------------------------------------
polygon() (x,y) x1 <- min(which(dens$x >= q75))  
x2 <- max(which(dens$x <  q95))
with(dens, polygon(x=c(x[c(x1,x1:x2,x2)]), y= c(0, y[x1:x2], 0), col="gray"))
-------------------------------------------------------------------------------------------------------
carrots <- rnorm(100000,5,2)
cukes <- rnorm(50000,7,2.5) ## calculate the density - don't plot yet
densCarrot <- density(carrots)
densCuke <- density(cukes)
## calculate the range of the graph
xlim <- range(densCuke$x,densCarrot$x)
ylim <- range(0,densCuke$y, densCarrot$y)
#pick the colours
carrotCol <- rgb(1,0,0,0.2)
cukeCol <- rgb(0,0,1,0.2)
## plot the carrots and set up most of the plot parameters
plot(densCarrot, xlim = xlim, ylim = ylim, xlab = 'Lengths',
     main = 'Distribution of carrots and cucumbers', 
     panel.first = grid())
#put our density plots in
polygon(densCarrot, density = -1, col = carrotCol)
polygon(densCuke, density = -1, col = cukeCol)
## add a legend in the corner
legend('topleft',c('Carrots','Cucumbers'),
       fill = c(carrotCol, cukeCol), bty = 'n',
       border = NA)
-------------------------------------------------------------------------------------------------------
tmp <- with(mtcars, data.frame(x=c(0, 0, max(wt)*35), y=c(0, max(wt), max(wt))))
ggplot(mtcars, aes(hp, wt)) + 
  geom_polygon(data=tmp, aes(x, y), fill="#d8161688") + 
  geom_point()
-------------------------------------------------------------------------------------------------------
chull splancs areapl cha<-function(x,y){
chull(x,y)->i
return(areapl(cbind(x[i],y[i])))
} library(splancs);
x<-rnorm(20);rnorm(20)->y;
#Some visualization
i<-chull(x,y);plot(x,y);polygon(x[i],y[i]);
#The area
cha(x,y);
-------------------------------------------------------------------------------------------------------
p <- ggplot(datapoly, aes(x=x, y=y)) + geom_polygon(aes(fill=factor(value), group=id),colour="black")
p <- p + facet_wrap(~ variable)
p id variable        value   x    y f
1  1.1     val1   0.09838607 2.0 -0.5 0.09-0.13
2  1.1     val1   0.09838607 1.0  0.0 0.09-0.13
3  1.1     val1   0.09838607 1.1  1.0 0.09-0.13
4  1.1     val1   0.09838607 2.2  0.5 0.09-0.13
25 2.1     val1   0.13121347 1.0  0.0 0.13-0.20 p <- ggplot(datapoly, aes(x=x, y=y)) + geom_polygon(aes(fill=f, group=id),colour="black")
p <- p + facet_wrap(~ variable)
p
-------------------------------------------------------------------------------------------------------
align.plots <- function(..., vertical=TRUE){
#http://ggextra.googlecode.com/svn/trunk/R/align.r
  dots <- list(...)
  dots <- lapply(dots, ggplotGrob)
  ytitles <- lapply(dots, function(.g) editGrob(getGrob(.g,"axis.title.y.text",grep=TRUE), vp=NULL))
  ylabels <- lapply(dots, function(.g) editGrob(getGrob(.g,"axis.text.y.text",grep=TRUE), vp=NULL))
  legends <- lapply(dots, function(.g) if(!is.null(.g$children$legends))
                    editGrob(.g$children$legends, vp=NULL) else ggplot2:::.zeroGrob)

  gl <- grid.layout(nrow=length(dots))
  vp <- viewport(layout=gl)
  pushViewport(vp)
  widths.left <- mapply(`+`, e1=lapply(ytitles, grobWidth),
                        e2= lapply(ylabels, grobWidth), SIMPLIFY=F)
  widths.right <- lapply(legends, function(g) grobWidth(g) + if(is.zero(g)) unit(0, "lines") else unit(0.5, "lines")) # safe margin recently added to ggplot2
  widths.left.max <- max(do.call(unit.c, widths.left))
  widths.right.max <- max(do.call(unit.c, widths.right))

  for(ii in seq_along(dots)){
    pushViewport(viewport(layout.pos.row=ii))
    pushViewport(viewport(x=unit(0, "npc") + widths.left.max - widths.left[[ii]],
                          width=unit(1, "npc") - widths.left.max + widths.left[[ii]] -
                                                 widths.right.max + widths.right[[ii]],
                          just="left"))
    grid.draw(dots[[ii]])
  upViewport(2)
  }
}



p <- ggplot(datapoly[datapoly$variable=="val1",], aes(x=x, y=y)) + geom_polygon(aes(fill=value, group=id),colour="black")
p1 <- ggplot(datapoly[datapoly$variable=="val2",], aes(x=x, y=y)) + geom_polygon(aes(fill=value, group=id),colour="black")
align.plots( p,p1)
-------------------------------------------------------------------------------------------------------
maps map("state")
points(longitute,latitude) segments() map_data() geom_polygon() geom_point() geom_segment() maptools mapproj mapdata
-------------------------------------------------------------------------------------------------------
ggplot2 data <- as.data.frame(data)
d1 <- density(data$gest[which(data$season==1)], na.rm=TRUE)
d2 <- density(data$gest[which(data$season==2)], na.rm=TRUE)
plot(d1, ylim=c(0, max(d1$y,d2$y)), xlim=range(c(d1$x, d2$x)),
  main="Length of gestation", xlab="Length (days)", col="blue", lwd=2)
polygon(d1$x, d1$y, col=rgb(0, 0, 1, 0.5), lty=0)
points(d2, t="l", col="red", lwd=2)
polygon(d2$x, d2$y, col=rgb(1, 0, 0, 0.5), lty=0) densityplot lattice hist(data$gest[which(data$season==1)], main="Length of gestation", 
    xlab="Length (days)", col=rgb(0, 0, 1, 0.5))
# Note the add=TRUE parameter to superimpose the histograms
hist(data$gest[which(data$season==2)], col=rgb(1, 0, 0, 0.5), add=TRUE)
-------------------------------------------------------------------------------------------------------
x <- seq(0,pi,length.out=100)
y <- sin(x)

plot(x,y,type="l")
polygon(x,y,col="grey")
-------------------------------------------------------------------------------------------------------
plot(), lines(), abline(), points(), polygon(), segments(), rect(), box(), arrows(), ... set.seed(100)
x <- 1:10
y <- x^2
y2 <- x^3
yse <- abs(runif(10,2,4))

plot(x,y, type = "n")  # type="n" only plots the pane, no curves or points.

# plots the area between both curves
polygon(c(x,sort(x,decreasing=T)),c(y,sort(y2,decreasing=T)),col="grey")
# plot both curves
lines(x,y,col="purple")
lines(x, y2, col = "red")
# add the points to the first curve
points(x, y, col = "black")
# adds some lines indicating the standard error
segments(x,y,x,y+yse,col="blue")
# adds some flags indicating the standard error
arrows(x,y,x,y-yse,angle=90,length=0.1,col="darkgreen")
-------------------------------------------------------------------------------------------------------
# sample data
x <- rnorm(50,0,2)
y <- x+rnorm(50,0,2)

# construct polygons
div <- quantile(y-x,c(0.25,0.75))
x1 <- min(c(x,y))
x2 <- max(c(x,y))


plot(x,y,type="n")
polygon(x=c(x1,x1,x2,x2),y=c(x1+div,(x2+div)[c(2,1)]),col="grey")
abline(0,1)
points(x,y) qplot(x,y,geom="point") + stat_smooth(method="lm") sd(y-x) sd(residuals(lm(y~x)))
-------------------------------------------------------------------------------------------------------
x <- c(left = 0.25, right = 0.75)
y <- c(bottom = 0.1, mid = 0.6, top = 0.9)

grid.newpage()
grid.polygon(x =  rep(x[c("left", "right", "right", "left")], 2),
             y =  y[rep(c("bottom", "top", "bottom", "mid"), each = 2)],
             id = rep(1:2, each = 4),
             gp = gpar(fill = c(NA, "blue")))
-------------------------------------------------------------------------------------------------------
A = 1/2 nR^2 * sin((2pi)/n) R = sqrt((2*A)/(n*sin((2pi)/n)) 2pi/n regular.poly <- function(nSides, area)
    {
    # Find the radius of the circumscribed circle
    radius <- sqrt((2*area)/(nSides*sin((2*pi)/nSides)))

    # I assume the center is at (0;0) and the first point lies at (0; radius)
    points <- list(x=NULL, y=NULL)
    angles <- (2*pi)/nSides * 1:nSides

    points$x <- cos(angles) * radius
    points$y <- sin(angles) * radius

    return (points);
    }


# Some examples
par(mfrow=c(3,3))

for (i in 3:11)
    {
    p <- regular.poly(i, 100)
    plot(0, 0, "n", xlim=c(-10, 10), ylim=c(-10, 10), xlab="", ylab="", main=paste("n=", i))
    polygon(p)
    } A = 1/2 * [(x1*y2 + x2*y3 + ... + xn*y1) - (y1*x2 + y2*x3 + ... + yn*x1)] convex.poly <- function(nSides, area)
    {
    # Find the radius of the circumscribed circle, and the angle of each point if this was a regular polygon
    radius <- sqrt((2*area)/(nSides*sin((2*pi)/nSides)))
    angle <- (2*pi)/nSides

    # Randomize the radii/angles
    radii <- rnorm(nSides, radius, radius/10)
    angles <- rnorm(nSides, angle, angle/10) * 1:nSides
    angles <- sort(angles)

    points <- list(x=NULL, y=NULL)
    points$x <- cos(angles) * radii
    points$y <- sin(angles) * radii

    # Find the area of the polygon
    m <- matrix(unlist(points), ncol=2)
    m <- rbind(m, m[1,])
    current.area <- 0.5 * (sum(m[1:nSides,1]*m[2:(nSides+1),2]) - sum(m[1:nSides,2]*m[2:(nSides+1),1]))

    points$x <- points$x * sqrt(area/current.area)
    points$y <- points$y * sqrt(area/current.area)

    return (points)
    }
-------------------------------------------------------------------------------------------------------
plotfun <- function(x) {
    plot( c(-0.5,-0.5,0.5,0.5), c(0,1,1,0), col='blue', xlim=c(-2,2),
         type='l', xlab='', ylab='' )
    if( x > -1 && x < 0 ) {
        polygon( c(-0.5, -0.5, x+0.5, x+0.5), c(0,1,1,0), col='yellow', border=NA )
        lines( c(-0.5, -0.5, 0.5, 0.5), c(0,1,1,0), col='blue' )
        lines( c(-1,x), c(0,x+1) )
    } else if( x >= 0 && x < 1 ) {
        polygon( c(x-0.5, x-0.5, 0.5, 0.5), c(0,1,1,0), col='yellow', border=NA )
        lines( c(-0.5, -0.5, 0.5, 0.5), c(0,1,1,0), col='blue' )
        lines( c(-1,0,x), c(0,1,1-x) )
    } else if (x >= 1) {
        lines( c(-1,0,1), c(0,1,0) )
    }
    abline(v=x, lty=3)
    lines( c(x-0.5,x-0.5,x+0.5,x+0.5), c(0,1,1,0), col='red' )
}

dev.new(height=3, width=6)

for(i in seq(-2.5, 2.5, 0.05) ) {
    plotfun(i)
    Sys.sleep(0.1)
} library(TeachingDemos)

tkexamp( plotfun, list(x=list('slider', from=-2.5, to=2.5, resolution=0.01)),
    vscale=1)
-------------------------------------------------------------------------------------------------------
geom_polygon() geom_text() ellipsoidhull() cluster library(ggplot2)
library(cluster)

mirror <- function(poly){
    m <- poly
    m$x <- -m$x
    m
}

poly_br <- data.frame(
        x=c(0, 4, 3, 0),
        y=c(0, 0, 1, 1),
        fill=rep("A", 4)
)


poly_mr <- data.frame(
        x=c(0, 3, 2, 0),
        y=c(1, 1, 2, 2),
        fill=rep("B", 4)
)

poly_tr <- data.frame(
        x=c(0.5, 2, 1, 0.5),
        y=c(2, 2, 3, 3),
        fill=rep("C", 4)
)

poly_tm <- data.frame(
        x=c(-0.5, 0.5, 0.5, -0.5),
        y=c(2, 2, 3, 3),
        fill=rep("D", 4)
        )

poly_bl <- mirror(poly_br)
poly_ml <- mirror(poly_mr)
poly_tl <- mirror(poly_tr)


get_ellipse <- function(data, fill){
    edata <- as.matrix(data)
    ehull <- ellipsoidhull(edata)
    phull <- as.data.frame(predict(ehull))
    data.frame(
            x=phull$V1, 
            y=phull$y, 
            fill=rep(fill, nrow(phull))
    )
}

ellipse <- get_ellipse(
        data.frame(
                x=c(0, 2, 0, -2),
                y=c(3, 3.5, 4, 3.5)
    ), fill="E"
)

text <- data.frame(
        x=c(2, -2, 1.5, -1.5, 1.25, -1.25, 0, 0),
        y=c(0.5, 0.5, 1.5, 1.5, 2.5, 2.5, 2.5, 3.5),
        text=c("br", "bl", "mr", "ml", "tr", "tl", "tm", "ellipse"))


poly <- rbind(poly_br, poly_bl, poly_mr, poly_ml, poly_tr, poly_tm, poly_tl, ellipse)


p <- ggplot() + 
        geom_polygon(data=poly, aes(x=x, y=y, fill=fill), colour="black") +
        geom_text(data=text, aes(x=x, y=y, label=text))
print(p)
-------------------------------------------------------------------------------------------------------
geom_text geom_polygon df <- structure(list(x = 15:20, y = 5:10), .Names = c("x", "y"), row.names = c(NA, -6L), class = "data.frame") point <- df[4,]
ptext <- "Look over here!" arrow <- data.frame(
    x = c(point$x-0.1, point$x-0.3, point$x-0.3, point$x-2, point$x-2, point$x-0.3, point$x-0.3, point$x-0.1),
    y = c(point$y, point$y+0.3, point$y+0.2, point$y+0.2, point$y-0.2, point$y-0.2, point$y-0.3, point$y)
) ptext <- data.frame(label=ptext, x=point$x-1, y=point$y) ggplot(df, aes(x,y)) + geom_point() + geom_polygon(aes(x,y), data=arrow, fill="green") + geom_text(aes(x, y, label=label), ptext) + theme_bw() textGrob
-------------------------------------------------------------------------------------------------------
mgcv sp::overlay in.out() library(mgcv)
data(columb.polys)
bnd <- columb.polys[[2]]
plot(bnd,type="n")
polygon(bnd)
x <- seq(7.9,8.7,length=20)
y <- seq(13.7,14.3,length=20)
gr <- as.matrix(expand.grid(x,y))
inside <- in.out(bnd,gr)
points(gr,pch=as.numeric(inside)+1)
-------------------------------------------------------------------------------------------------------
# load libraries
library(XML);
library(ggplot2);
library(maps);

# read the data from the bls website with correct column formats
unemp = readHTMLTable('http://www.bls.gov/web/laus/laumstrk.htm',
  colClasses = c('character', 'character', 'numeric'))[[2]];

# rename columns and convert region to lowercase
names(unemp) = c('rank', 'region', 'rate');
unemp$region  = tolower(unemp$region);

# get us state map data and merge with unemp
us_state_map = map_data('state');
map_data = merge(unemp, us_state_map, by = 'region'); 

# keep data sorted by polygon order
map_data = arrange(map_data, order);

# plot map using ggplot2

p0 = ggplot(map_data, aes(x = long, y = lat, group = group)) +
     geom_polygon(aes(fill = cut_number(rate, 5))) +
     geom_path(colour = 'gray', linestyle = 2) +
     scale_fill_brewer('Unemployment Rate (Jan 2011)', pal = 'PuRd') +
     coord_map();
-------------------------------------------------------------------------------------------------------
set.seed(1)
draws <- rnorm(100)^2
dens <- density(draws)
plot(dens)

q2     <- 2
q65    <- 6.5
qn08   <- -0.8
qn02   <- -0.2

x1 <- min(which(dens$x >= q2))  
x2 <- max(which(dens$x <  q65))
x3 <- min(which(dens$x >= qn08))  
x4 <- max(which(dens$x <  qn02))

with(dens, polygon(x=c(x[c(x1,x1:x2,x2)]), y= c(0, y[x1:x2], 0), col="gray"))
with(dens, polygon(x=c(x[c(x3,x3:x4,x4)]), y= c(0, y[x3:x4], 0), col="gray"))
-------------------------------------------------------------------------------------------------------
# create palette
greyScale <- colorRampPalette(c("black","white"))

# function to draw shape
plotHeart <- function(r, col){
  t <- seq(0,2*pi,length.out=100)
  x <- r*sin(t)^3
  y <- (13*r/16)*cos(t) - (5*r/16)*cos(2*t) - (2*r/16)*cos(3*t) - (r/16)*cos(4*t)
  polygon(x,y,col=col,border=NA)
}



# create new plot canvas
plot.new()
# limits are approximate here
plot.window(xlim=c(-16,16),ylim=c(-16,13))

# use mapply to loop
mapply(plotHeart,seq(16,0,length.out=100),greyScale(100))
-------------------------------------------------------------------------------------------------------
polygon(x,pmin(y1,y2),col="gray") x pmin(y1,y2) pmin curve() fun1 <- curve(dnorm(x,mean=0,sd=1),type="l",lwd=2,col="red")
fun2 <- curve(dnorm(x,mean=3,sd=2),type="l",lwd=2,col="blue",add=TRUE)
polygon(fun1$x,pmin(fun1$y,fun2$y),col="gray")
-------------------------------------------------------------------------------------------------------
shade_under_curve <- function(fun, xmin, xmax, length=100){
  xvals <- seq(xmin, xmax, length=length)
  dvals <- match.fun(fun)(xvals)
  polygon(c(xvals,rev(xvals)),c(rep(0,length),rev(dvals)),col="gray")
}


y1 <- function(x)sapply(x, function(xt)dnorm(xt,mean=0,sd=1))
y2 <- function(x)sapply(x, function(xt)dnorm(xt,mean=3,sd=2))

my.fun <- function(x){sapply(x, function(xt)min(y1(xt), y2(xt)))} plot(y1, -10, 10, col="red")
curve(y2, add=TRUE, col="blue")
shade_under_curve(my.fun, -10, 10, length=1000)
-------------------------------------------------------------------------------------------------------
df <- data.frame(x=1, y=1)
df_poly <- data.frame(
    x=c(-Inf, Inf, -Inf),
    y=c(-Inf, Inf, Inf)
)

ggplot(df, aes(x, y)) + 
    geom_blank() + 
    geom_abline(slope=1, intercept=0) + 
    geom_polygon(data=df_poly, aes(x, y), fill="blue", alpha=0.2) +
-------------------------------------------------------------------------------------------------------
ggplot Inf -Inf ggplot ggplot ggplot buildPoly <- function(xr, yr, slope = 1, intercept = 0, above = TRUE){
    #Assumes ggplot default of expand = c(0.05,0)
    xrTru <- xr + 0.05*diff(xr)*c(-1,1)
    yrTru <- yr + 0.05*diff(yr)*c(-1,1)

    #Find where the line crosses the plot edges
    yCross <- (yrTru - intercept) / slope
    xCross <- (slope * xrTru) + intercept

    #Build polygon by cases
    if (above & (slope >= 0)){
        rs <- data.frame(x=-Inf,y=Inf)
        if (xCross[1] < yrTru[1]){
            rs <- rbind(rs,c(-Inf,-Inf),c(yCross[1],-Inf))
        }
        else{
            rs <- rbind(rs,c(-Inf,xCross[1]))
        }
        if (xCross[2] < yrTru[2]){
            rs <- rbind(rs,c(Inf,xCross[2]),c(Inf,Inf))
        }
        else{
            rs <- rbind(rs,c(yCross[2],Inf))
        }
    }
    if (!above & (slope >= 0)){
        rs <- data.frame(x= Inf,y= -Inf)
        if (xCross[1] > yrTru[1]){
            rs <- rbind(rs,c(-Inf,-Inf),c(-Inf,xCross[1]))
        }
        else{
            rs <- rbind(rs,c(yCross[1],-Inf))
        }
        if (xCross[2] > yrTru[2]){
            rs <- rbind(rs,c(yCross[2],Inf),c(Inf,Inf))
        }
        else{
            rs <- rbind(rs,c(Inf,xCross[2]))
        }
    }
    if (above & (slope < 0)){
        rs <- data.frame(x=Inf,y=Inf)
        if (xCross[1] < yrTru[2]){
            rs <- rbind(rs,c(-Inf,Inf),c(-Inf,xCross[1]))
        }
        else{
            rs <- rbind(rs,c(yCross[2],Inf))
        }
        if (xCross[2] < yrTru[1]){
            rs <- rbind(rs,c(yCross[1],-Inf),c(Inf,-Inf))
        }
        else{
            rs <- rbind(rs,c(Inf,xCross[2]))
        }
    }
    if (!above & (slope < 0)){
        rs <- data.frame(x= -Inf,y= -Inf)
        if (xCross[1] > yrTru[2]){
            rs <- rbind(rs,c(-Inf,Inf),c(yCross[2],Inf))
        }
        else{
            rs <- rbind(rs,c(-Inf,xCross[1]))
        }
        if (xCross[2] > yrTru[1]){
            rs <- rbind(rs,c(Inf,xCross[2]),c(Inf,-Inf))
        }
        else{
            rs <- rbind(rs,c(yCross[1],-Inf))
        }
    }

    return(rs)
} range() #Generate some data
dat <- data.frame(x=runif(10),y=runif(10))

#Select two of the points to define the line
pts <- dat[sample(1:nrow(dat),size=2,replace=FALSE),]

#Slope and intercept of line through those points
sl <- diff(pts$y) / diff(pts$x)
int <- pts$y[1] - (sl*pts$x[1])

#Build the polygon
datPoly <- buildPoly(range(dat$x),range(dat$y),
            slope=sl,intercept=int,above=FALSE)

#Make the plot
p <- ggplot(dat,aes(x=x,y=y)) + 
        geom_point() + 
        geom_abline(slope=sl,intercept = int) +
        geom_polygon(data=datPoly,aes(x=x,y=y),alpha=0.2,fill="blue")
print(p) set.seed(1)
dat <- data.frame(x=runif(6,-2,2),y=runif(6,-2,2),
        var1=rep(c("A","B"),3),var2=rep(c("C","D"),3))
#Create polygon data frame
df_poly <- buildPoly(range(dat$x),range(dat$y))

ggplot(data=dat,aes(x,y)) + 
    facet_wrap(~var2) +
    geom_abline(slope=1,intercept=0,lwd=0.5)+
    geom_point(aes(colour=var1),size=3) + 
    scale_color_manual(values=c("red","blue"))+
    geom_polygon(data=df_poly,aes(x,y),fill="blue",alpha=0.2)
-------------------------------------------------------------------------------------------------------
stars stars2 stars2 col.lines = NULL polygon(s.x[i, ], s.y[i, ], lwd = lwd, lty = lty, col = col.stars[i]) polygon(s.x[i, ], s.y[i, ], lwd = lwd, lty = lty, border = col.lines[i], col = col.stars[i]) stars2 stars2(mtcars[, 1:7], locations = c(0,0), radius = FALSE,key.loc=c(0,0), 
       main="Motor Trend Cars", lty = 2,col.lines = 1:nrow(mtcars))
-------------------------------------------------------------------------------------------------------
lattice #Set up the data
set.seed(1)
draws <- rnorm(100)^2
dens <- density(draws)

#Put in a simple data frame   
d <- data.frame(x = dens$x, y = dens$y)

#Define a custom panel function;
# Options like color don't need to be hard coded    
shadePanel <- function(x,y,shadeLims){
    panel.lines(x,y)
    m1 <- min(which(x >= shadeLims[1]))
    m2 <- max(which(x <= shadeLims[2]))
    tmp <- data.frame(x1 = x[c(m1,m1:m2,m2)], y1 = c(0,y[m1:m2],0))
    panel.polygon(tmp$x1,tmp$y1,col = "blue")
}

#Plot
xyplot(y~x,data = d, panel = shadePanel, shadeLims = c(1,3))
-------------------------------------------------------------------------------------------------------
dnorm() zmax <- 4
curve(dnorm, -zmax, zmax, xaxt = 'n', bty = 'n')
axis(1, -zmax:zmax, pos = 0) dnorm zscore <- 1.65
segments(zscore, 0, zscore, dnorm(zscore)) x <- seq(zscore, zmax, 0.01)
y <- c(0, dnorm(x)[1:(length(x)-2)],0)
polygon(x,y, density = 20) segments text
-------------------------------------------------------------------------------------------------------
par(fig) Rgames: plot(1:2,1:2) Rgames: par(mar=c(.1,6,.1,.1),new=T,fig=c(0,.25,.5,.75)) Rgames: plot(1:2,1:2) Rgames: polygon(c(1,2,2,1),c(1,1,2,2),col='red')
-------------------------------------------------------------------------------------------------------
geom_polygon ggplot(data=dat, aes(x=x)) + 
    geom_polygon(aes(y=norm), fill="red", alpha=0.6) + 
    geom_polygon(data = rbind(c(NA,0,1000),dat,c(NA,0,2000)),aes(y=logistic), fill="blue", alpha=0.6) + xlab("") + ylab("") +   
    opts(title="Logistic and Normal Distributions")+ 
    scale_x_continuous(expand = c(0, 0)) + 
    scale_y_continuous(expand = c(0, 0)) rbind geom_polygon x=seq(700,2300,length=200)  
dat2 <- data.frame(x=x)
dat2$value <- dnorm(x,mean=1500,sd=200)
dat2$type <- "Normal"

dat1 <- data.frame(x=x)
dat1$value <- dlogis(x,location=1500,scale=200)       
dat1$type <- "Logistic"

#Append extra points at the top/bottom to 
# complete the polygon
dat1 <- rbind(data.frame(x=700,value=0,type = "Logistic"),dat1,
                data.frame(x=2300,value=0,type = "Logistic"))

dat <- rbind(dat1, dat2)

ggplot(data=dat, aes(x=x, y=value, colour=type, fill=type)) + 
       geom_polygon(alpha=0.6) + 
       scale_y_continuous(expand = c(0, 0)) coord_cartesian
-------------------------------------------------------------------------------------------------------
x=seq(-2,2,length=200)  
dat <- data.frame(
  norm = dnorm(x,mean=0,sd=0.2), 
  logistic = dlogis(x,location=0,scale=0.2), x = x
)
p <- ggplot(data=dat, aes(x=x)) + 
  geom_polygon(aes(y=norm), fill="red", alpha=0.6) + 
  geom_polygon(aes(y=logistic), fill="blue", alpha=0.6) + 
  xlab("z") + ylab("") + 
  scale_x_continuous(expand = c(0, 0)) + 
  scale_y_continuous(expand = c(0, 0)) +  
  opts(title="Logistic and Normal Distributions") 

print(p)
-------------------------------------------------------------------------------------------------------
draw_ellipse = function (mean_x, mean_y, sd_x, sd_y)
{
    ellipse <- function (x) { sin(acos(x)) }
    t = seq(-1, 1, length.out = 100)
    el_y = sd_y*ellipse(t)
    newx = mean_x + sd_x * t
    polygon(c(newx, rev(newx)), c(mean_y + el_y, rev(mean_y - el_y)), col = "grey", border = NA)
} apply() x = runif(10)
y = runif(10)
sd_x = abs(rnorm(10, 0.1, 0.02))
sd_y = abs(rnorm(10, 0.05, 0.01))
plot(x, y)
df = data.frame(x, y, sd_x, sd_y)
apply(df, 1, function (x) { draw_ellipse(x[1], x[2], x[3], x[4]) })
points(x, y, pch = 3) draw_ellipse = function (mean_x, mean_y, sd_x, sd_y, colidx)
{
    ellipse <- function (x) { sin(acos(x)) }
    t = seq(-1, 1, length.out = 100)
    el_y = sd_y*ellipse(t)
    newx = mean_x + sd_x * t
    polygon(c(newx, rev(newx)), c(mean_y + el_y, rev(mean_y - el_y)), col = as.character(colors[colidx]), border = NA)
}

x = runif(10)
y = runif(10)
sd_x = abs(rnorm(10, 0.1, 0.02))
sd_y = abs(rnorm(10, 0.05, 0.01))
plot(x, y)
colors = rainbow(length(x))
df = data.frame(x, y, sd_x, sd_y, colidx = 1:length(x))
apply(df, 1, function (x) { draw_ellipse(x[1], x[2], x[3], x["sd_y"], x["colidx"]) })
points(x, y, pch = 3)
-------------------------------------------------------------------------------------------------------
dens <- density(myd)
polygon(c(3, dens$x[dens$x>3 & dens$x < 5], 5), c(0, dens$y[dens$x>=3 & dens$x <= 5], 0),col="tan") dens <- density(myd)
plot(dens, xlim = c(0, 5), xaxt = 'n', bty = 'n')
axis(1, pos = 0)
polygon(c(3, dens$x[dens$x>3 & dens$x < 6], 6), c(0, dens$y[dens$x>=3 & dens$x <= 6], 0),col="tan")
-------------------------------------------------------------------------------------------------------
line draw.cont.line persp.lm <- 
function (x, form, at, bounds, zlim, zlab, xlabs, col = "white", xlab=xlab,
    contours = NULL, hook, atpos = 3, theta = -25, phi = 20, 
    r = 4, border = NULL, box = TRUE, ticktype = "detailed", ylab,
    ... ) 
{
    draw.cont.line = function(line) {
        if (cont.varycol) {
            cont.col = col
            if (length(col) > 1) 
                cont.col = col[cut(c(line$level, dat$zlim), length(col))][1]
        }
        polygon(trans3d(line$x, line$y, cont.z, transf), col = cont.col, 
            lwd = cont.lwd)
    }
    plot.data = contour.lm(x, form, at, bounds, zlim, xlabs, 
        atpos = atpos, plot.it = FALSE)
    transf = list()
    if (missing(zlab)) 
        zlab = ""
    facet.col = col
    cont = !is.null(contours)
    if (mode(contours) == "logical") 
        cont = contours
    cont.first = cont
    cont.z = cz = plot.data[[1]]$zlim[1]
    cont.col = 1
    cont.varycol = FALSE
    cont.lwd = 1
    if (is.character(contours)) {
        idx = charmatch(contours, c("top", "bottom", "colors"), 
            0)
        if (idx == 1) {
            cont.first = FALSE
            cont.z = plot.data[[1]]$zlim[2]
        }
        else if (idx == 2) {
        }
        else if (idx == 3) {
            cont.varycol = TRUE
            if (length(col) < 2) 
                col = rainbow(40)
        }
        else cont.col = contours
    }
    else if (is.list(contours)) {
        if (!is.null(contours$z)) 
            cz = contours$z
        if (is.numeric(cz)) 
            cont.z = cz
        else if (cz == "top") {
            cont.first = FALSE
            cont.z = plot.data[[1]]$zlim[2]
        }
        if (!is.null(contours$col)) 
            cont.col = contours$col
        if (!is.null(contours$lwd)) 
            cont.lwd = contours$lwd
        if (charmatch(cont.col, "colors", 0) == 1) {
            cont.varycol = TRUE
            if (length(col) < 2) 
                col = rainbow(40)
        }
    }
    for (i in 1:length(plot.data)) {
        dat = plot.data[[i]]
        cont.lines = NULL
        if (!missing(hook)) 
            if (!is.null(hook$pre.plot)) 
                hook$pre.plot(dat$labs)
        if (cont) 
            cont.lines = contourLines(dat$x, dat$y, dat$z)
        if (cont && cont.first) {
            transf = persp(dat$x, dat$y, dat$z, zlim = dat$zlim, xlab=ylab,
                theta = theta, phi = phi, r = r, col = NA, border = NA, 
                box = FALSE)
            lapply(cont.lines, draw.cont.line)
            par(new = TRUE)
        }
        if (length(col) > 1) {
            nrz = nrow(dat$z)
            ncz = ncol(dat$z)
            zfacet = dat$z[-1, -1] + dat$z[-1, -ncz] + dat$z[-nrz, 
                -1] + dat$z[-nrz, -ncz]
            zfacet = c(zfacet/4, dat$zlim)
            facet.col = cut(zfacet, length(col))
            facet.col = col[facet.col]
        }
        transf = persp(dat$x, dat$y, dat$z, xlab = xlab, 
             zlab = zlab, zlim = dat$zlim, ylab=ylab,
            col = facet.col, border = border, box = box, theta = theta, 
            phi = phi, r = r, ticktype = ticktype)
        if (atpos == 3) 
            title(sub = dat$labs[5])
        if (cont && !cont.first) 
            lapply(cont.lines, draw.cont.line)
        if (!missing(hook)) 
            if (!is.null(hook$post.plot)) 
                hook$post.plot(dat$labs)
        plot.data[[i]]$transf = transf
    }
    invisible(plot.data)
}

persp(ct.rsm, Conc ~ kGy, col=rainbow(50), theta=60, xlab="Something",
    phi=0, r = 3, d=1, border = NULL, ltheta = -135, lphi = 0
    , shade = 0.75, zlab="CT",ylab="Concentration %", col.axis=37, font.lab=2,col.lab=33,
    contour=("colors"))
-------------------------------------------------------------------------------------------------------
dat<- data.frame(t=seq(0, 2*pi, by=0.1) )
 xhrt <- function(t) 16*sin(t)^3
 yhrt <- function(t) 13*cos(t)-5*cos(2*t)-2*cos(3*t)-cos(4*t)
 dat$y=yhrt(dat$t)
 dat$x=xhrt(dat$t)
 with(dat, plot(x,y, type="l")) with(dat, polygon(x,y, col="hotpink")) help(points) TestChars points(c(10,-10, -15, 15), c(-10, -10, 10, 10), pch=169, font=5) library(Cairo)

clubs <- expression(symbol('\247'))
hearts <- expression(symbol('\251'))
diamonds <- expression(symbol('\250'))
spades <- expression(symbol('\252'))
csymbols <- c(clubs, hearts, diamonds, spades)

plot( 0, xlim=c(0,5), ylim=c(0,2), type="n" )
clr <- c("black", "red", "red", "black") 
for (i in 1:4) {
  hline <- function( yloc, ... ) 
         for (i in 1:length(yloc)) 
             lines( c(-1,6), c(yloc[i],yloc[i]), col="gray")  
              hline(0.9); 
                hline(1.0);
                hline(1.1);
                hline(1.2)  
 text( i, 1, csymbols[i], col=clr[i], cex=5 )  
 text( i, 0.5, csymbols[i], col=clr[i] ) }

# Also try this
plot(1,1)
text(x=1+0.2*cos(seq(0, 2*pi, by=.5)), 
     y=1+0.2*sin(seq(0, 2*pi, by=.5)), 
                  expression(symbol('\251') ) )
-------------------------------------------------------------------------------------------------------
thong<-function(h = 9){ 
     # set up plot  
    xrange=c(-15,15)  
    yrange=c(0,16)  
    plot(0,xlim=xrange,ylim=yrange,type='n')  

     # draw outer envelope  
    yr=seq(yrange[1],yrange[2],len=50)  
    offsetFn=function(y){2*sin(0+y/3)}  
    offset=offsetFn(yr)  
    leftE = function(y){-10-offsetFn(y)}  
    rightE = function(y){10+offsetFn(y)}  

    xp=c(leftE(yr),rev(rightE(yr))) 
    yp=c(yr,rev(yr))  
    polygon(xp,yp,col="#ffeecc",border=NA) 

    # feasible region upper limit: 
    # left and right defined by triple-log function:  
    xt=seq(0,rightE(h),len=100)   
    yt=log(1+log(1+log(xt+1)))   
    yt=yt-min(yt)  
    yt=h*yt/max(yt)  
    x=c(leftE(h),rightE(h),rev(xt),-xt) 
    y=c(h,h,rev(yt),yt) 
    polygon(x,y,col="red",border=NA)  
}
-------------------------------------------------------------------------------------------------------
quantile() xf <- rnorm(40000, 50, 10)
plot(density(xf),xlim=c(0,100), main = paste(names(xf), "distribution"))
dens <- density(xf)
x1 <- min(which(dens$x >= quantile(xf, .90))) # quantile() ftw!

x2 <- max(which(dens$x <  max(dens$x)))
with(dens, polygon(x=c(x[c(x1,x1:x2,x2)]), y= c(0, y[x1:x2], 0), col="green"))
-------------------------------------------------------------------------------------------------------
pch my.symbols() require(TeachingDemos)

bwDiamond <- function() {
    plot.new()
    polygon(c(0, 0.5, 1, 0.5, 0), c(0.5, 0, 0.5, 1, 0.5), lty=1)
    polygon(c(0.25, 0.5, 1, 0.75, 0.25), c(0.25, 0, 0.5, 0.75, 0.25), col=1)
}

data <- c(1,2,3)

dev.new(width=4, height=4)
plot(data, type='n')
points(data[1:2], pch=c(23,18), cex=c(2.5,3))
my.symbols(data[3], data[3], symb=bwDiamond, symb.plots=TRUE, inches=0.22)
-------------------------------------------------------------------------------------------------------
names(w) <- c('date1','x1','y1','max1','min1','v1')
kk <- merge(z,w, by.x='date', by.y='date1', all.x=TRUE)

plot(kk$date,kk$x,type='n')
polygon(c(kk$date,kk$date[nrow(kk):1]),c(kk$x,kk$y[nrow(kk):1])
        ,col='skyblue',border=NA)
polygon(c(kk$date,kk$date[nrow(kk):1]), c(kk$x1,kk$y1[nrow(kk):1])
        ,col='salmon',border=NA)
-------------------------------------------------------------------------------------------------------
NA library(reshape2)
library(ggplot2)

z <- data.frame(
    date=date,
    min=pmin(x, y),
    max=pmax(x, y),
    series=ifelse(x>y, 1, 2)
)

# Helper function to create closed polygon, optionally adding NA line at bottom
rdata <- function(dat, addNA=FALSE){
  rdat <- dat[nrow(dat):1, ]
  ret <- rbind(
      data.frame(x= dat$date, y= dat$max, series= dat$series), 
      data.frame(x=rdat$date, y=rdat$min, series=rdat$series)
  )
  if(addNA) ret <- rbind(ret, c(NA, NA, NA))
  ret
}

# Closed polygon 1
rz <- rdata(z)

#Closed polygon 2
z2 <- z
rlez <- rle(z$series)$lengths
z2$chunk <- rep(seq_along(rlez), times=rlez)
rz2 <- ddply(z2, .(chunk), rdata, addNA=TRUE)
rz2 <- rz2[rz2$series!=1, ] ggplot(rz, aes(x, y, fill="Less than")) + geom_polygon() + 
    geom_polygon(data=rz2, aes(x, y, fill="Greater than")) +
    scale_fill_discrete("Legend") +
    xlab("Date") +
    ylab("Value") geom_linerange ggplot(z, aes(x=date, ymin=min, ymax=max, colour=factor(series))) + 
    geom_linerange(size=5)
-------------------------------------------------------------------------------------------------------
layer trellis.focus(...) panel.polygon() trellis.focus("panel", 1, 1)
do.call("panel.polygon", list(x =c(5,15,15,5,5), y=c(60,60,90,90,60) ) )
trellis.unfocus()
-------------------------------------------------------------------------------------------------------
ggplot2 ?polygon() x <- c(1:9,8:1)
y <- c(1,2*(5:3),2,-1,17,9,8,2:9)

ggplot(NULL, aes(1:10, 1:10)) + geom_point() +
  geom_polygon(aes(x, y), fill = "orange", colour = "skyblue", alpha = 0.5)
-------------------------------------------------------------------------------------------------------
r <- 3*runif(10)
degs <- 360*runif(10)

# First you want to convert the degrees to radians

theta <- 2*pi*degs/360

# Plot your points by converting to cartesian

plot(r*sin(theta),r*cos(theta),xlim=c(-max(r),max(r)),ylim=c(-max(r),max(r)))

# Add a circle around the points

polygon(max(r)*sin(seq(0,2*pi,length.out=100)),max(r)*cos(seq(0,2*pi,length.out=100))) max(r) 1.1*max(r)
-------------------------------------------------------------------------------------------------------
require(quantmod) 
getSymbols("SPY") 
chart_Series(SPY, subset="2011-08::", type = "candlesticks" ) 
text(9, 112.00, "SOME TEXT", adj=0); 
segments(9, 111.5, 12, 111.5) ; text(x,y,"message")
-------------------------------------------------------------------------------------------------------
ggplot(df) +
  aes(long, lat, group=group) +
  coord_equal() +
  geom_polygon(aes(fill = as.factor(community))) +
  facet_grid(facets= id ~.)
-------------------------------------------------------------------------------------------------------
map.poly() as.polygon=FALSE lines() map.poly() as.polygon=TRUE polygon() border=FALSE map map("state","tennessee",fill=T,col="white",names=T,plot=T)
coords = map.poly("county",region=c("tennessee,williamson","tennessee,davidson","tennessee,wilson","tennessee,cheatham"), boundary=T, interior=F, fill=F, as.polygon=T)
polygon(coords, col='red', border=F)
map("county",region=c("tennessee,williamson","tennessee,davidson","tennessee,wilson","tennessee,cheatham"),fill=F,interior=F,add=T) ?map map(..., interior=F, fill=T, col='red')
-------------------------------------------------------------------------------------------------------
x <- c(0,1,1,0)
y <- c(x[1:2]/2, x[3:4]/4)
polygon(x,y, col = 'green', border = NA) curve(x^2, from=0 , to =1, col="darkblue")
curve(x^4, from=0 , to =1, add=T, col="darkred")
x <- c(seq(0, 1, 0.01), seq(1, 0, -0.01))
y <- c(x[1:101]^2, x[102:202]^4)
polygon(x,y, col = 'green', border = NA)
-------------------------------------------------------------------------------------------------------
n <- 40
d <- data.frame(
  x = rnorm(n),
  y = rnorm(n)
)
# We want the "extreme" points in the following plot
par(mar=c(1,1,1,1))
plot(d, axes=FALSE, xlab="", ylab="")
for(i in 1:n) {
  polygon( c(-10,d$x[i],d$x[i],-10), c(-10,-10,d$y[i],d$y[i]), 
  col=rgb(.9,.9,.9,.2))
} d <- d[ order(d$x, decreasing=TRUE), ]
result <- d[1,]
for(i in seq_len(nrow(d))[-1] ) {
  if( d$y[i] > result$y[nrow(result)] ) {
    result <- rbind(result, d[i,])  # inefficient
  } 
}
points(result, cex=3, pch=15)
-------------------------------------------------------------------------------------------------------
rnorm x <- seq(-5,5,length=100)
plot(x, pnorm(1 - 0.5*x), ty='n', lwd=2, bty='n', xlab='x', ylab="Pr(y=1)", 
     xaxs = 'i', ylim=c(0, 1))

params <- processres(npb.par)
sims <- 100000
sim.mat <- matrix(NA, ncol=length(x), nrow=sims)
for (i in 1:sims) {
  alpha <- rnorm(1, params[1, 1], params[1, 3])
  beta <- rnorm(1, params[2, 1], params[2, 3])
  sim.mat[i, ] <- pnorm(alpha - beta*x)
}

CI <- apply(sim.mat, 2, function(x) quantile(x, c(0.05, 0.95)))
polygon(c(x, rev(x)), c(CI[1, ], rev(CI[2, ])), col='gray', border=NA)
lines(x, pnorm(params[1, 1] - params[2, 1]*x), lwd=2)
rug(dat100$x)
box()
-------------------------------------------------------------------------------------------------------
rm(list = ls())
install.packages("ggplot2")
library(ggplot2)
install.packages("maps")
library(maps)
install.packages("mapproj")
library(mapproj)
install.packages("spatstat")
library(spatstat)

theme_set(theme_bw(base_size = 8))
options(scipen = 20)

MyPalette <- colorRampPalette(c(hsv(0, 1, 1), hsv(7/12, 1, 1)))

### Map ###
StateMapData <- map_data("state")
head(StateMapData)

### Some Invented Data ###

IndependentVariable1 <- c("Low Income", "Mid Income", "High Income")
IndependentVariable2 <- c("18-29", "30-44", "45-64", "65+")

# Here is one way to "stack" lots of copies of the shapefile dataframe on top of each other:
# This needs to be done, because (as far as I know) ggplot2 needs to have the state names and polygon coordinates
# for each level of the faceting variables.

TallData <- expand.grid(1:nrow(StateMapData), IndependentVariable1, IndependentVariable2)
TallData <- data.frame(StateMapData[TallData[, 1], ], TallData)
colnames(TallData)[8:9] <- c("IndependentVariable1", "IndependentVariable2")

# Some random dependent variable we want to plot in color:
TallData$State_IV1_IV2 <- paste(TallData$region, TallData$IndependentVariable1, TallData$IndependentVariable2)
RandomVariable <- runif(length(unique(TallData$State_IV1_IV2)))
TallData$DependentVariable <- by(RandomVariable, unique(TallData$State_IV1_IV2), mean)[TallData$State_IV1_IV2]

### Plot ###

MapPlot <- ggplot(TallData,
 aes(x = long, y = lat, group = group, fill = DependentVariable))
MapPlot <- MapPlot + geom_polygon()
MapPlot <- MapPlot + coord_map(project="albers", at0 = 45.5, lat1 = 29.5)  # Changes the projection to something other than Mercator.
  MapPlot <- MapPlot + scale_x_continuous(breaks = NA, expand.grid = c(0, 0)) +
    scale_y_continuous(breaks = NA) +
    opts(
      panel.grid.major = theme_blank(),
      panel.grid.minor = theme_blank(),
      panel.background = theme_blank(),
      panel.border = theme_blank(),
      expand.grid = c(0, 0),
      axis.ticks = theme_blank(),
      legend.position = "none",
      legend.box = "horizontal",
      title = "Here is my title",
  legend.key.size = unit(2/3, "lines"))
MapPlot <- MapPlot + xlab(NULL) + ylab(NULL)
MapPlot <- MapPlot + geom_path(fill = "transparent", colour = "BLACK", alpha = I(2/3), lwd = I(1/10))
MapPlot <- MapPlot + scale_fill_gradientn("Some/nRandom/nVariable", legend = FALSE,
 colours = MyPalette(100))

# This does the "faceting":
MapPlot <- MapPlot + facet_grid(IndependentVariable2 ~ IndependentVariable1)

# print(MapPlot)

ggsave(plot = MapPlot, "YOUR DIRECTORY HERE.png", h = 8.5, w = 11)
-------------------------------------------------------------------------------------------------------
?panel.levelplot contourplot col.regions lpolygon library(gstat)

# create structure
xy <- expand.grid(1:360, 1:180)
names(xy) <- c('x','y')

# define the gstat object (spatial model)
g.dummy <- gstat(formula=z~1, locations=~x+y, dummy=T, beta=1,    
  model=vgm(psill=0.025,model='Exp',range=5), nmax=20)

# make a simulations based on the gstat object
yy <- predict(g.dummy, newdata=xy, nsim=1)
gridded(yy) = ~x+y

# scale to range [-1, 1]
z <- matrix(yy@data[, 1], ncol=180)
z.scalefac <- (max(z) - min(z)) / 2
z <- -1 + (z - min(z)) / z.scalefac library(lattice)
library(maps)

lon_sst <- seq(-179.5, 179.5, 1)
lat_sst <- seq(-89.5, 89.5, 1)

colramp <- colorRampPalette(c('red', 'yellow', 'white', 'green', 'blue'))

contourplot(z, xlim=c(100, 160), ylim=c(-80, -50), 
  at=seq(-1, 1, 0.2), region=TRUE, col.regions=colramp,
  row.values=lon_sst, column.values=lat_sst, labels=FALSE, 
  xlab='longitude', ylab='latitude',
  panel = function(at, region, ...) {
    panel.contourplot(at=at, region=TRUE,  ...)
    panel.contourplot(at=c(-0.2, 0.2), lwd=2, region=FALSE, ...)
    mp <- map("world", "antarctica", plot = FALSE, fill=TRUE)
    lpolygon(mp$x, mp$y, fill=TRUE, col='gray')
})
-------------------------------------------------------------------------------------------------------
scale_fill_brewer lev = levels(rate_d)  # used (2, 4] as test case
 lev2 <- gsub("\\,", "% to ", lev)
 lev3 <- gsub("\\]$", "%", lev2)
 lev3
[1] "(2% to 4%"
lev4 <- gsub("\\(|\\)", "", lev3)
 lev4
[1] "2% to 4%"

ggplot(choropleth, aes(long, lat, group = group)) +
  geom_polygon(aes(fill = rate_d), colour = alpha("white", 1/2), size = 0.2) + 
  geom_polygon(data = state_df, colour = "white", fill = NA) +
  scale_fill_brewer(pal = "PuRd", labels = lev4, , breaks=seq(0, 10, by = 2) )
-------------------------------------------------------------------------------------------------------
# Split the plot area in two
layout(matrix(c(1,1,2),nc=1))
# First plot
plot( pos, value, type="l", las=1 )
# Reduce the margins for the second plot
m <- par()$mar
m[1] <- m[3] <- 0
par(mar=m)
# Set the limits of the second plot
plot( pos, pos-pos, type="n", axes=FALSE, xlab="", ylab="" )
# Add the rectangle, the segments and the text.
polygon( 
  c(0,max(mydf2$pos),max(mydf2$pos),0), 
  .2*c(-1,-1,1,1),
  col=rgb(.1,.5,.3)
)
segments( mydf$position, -.5, mydf$position, .5 )
text(mydf$position, -.7, mydf$label)
text(mydf$position,  .7, mydf$position)
-------------------------------------------------------------------------------------------------------
data.frame library(ggplot2)
z <- data.frame(
  x = c(1,2,3,4,1,2,3,4),
  y = c(2,4,5,6,9,4,2,10),
  f = c(rep('a',4),rep('b',4))
)

z1 <- data.frame(
  x = c(2,2.5,3.1,2.8,3.4,3.5),
  y = c(1,1.2,1,2,3,2),
  f = c(rep('a',3),rep('b',3))
) ggplot layer geoms ggplot() +
    geom_line(data=z, aes(x,y)) +
    geom_polygon(data=z1, aes(x,y), color="blue") +
    facet_grid(f ~ .)
-------------------------------------------------------------------------------------------------------
library(maps)
library(ggplot2)
world<-map_data('world')
sf<-data.frame(long=-122.26,lat=37.47)
p <- ggplot(legend=FALSE) +
geom_polygon( data=world, aes(x=long, y=lat,group=group)) +
opts(panel.background = theme_blank()) +
opts(panel.grid.major = theme_blank()) +
opts(panel.grid.minor = theme_blank()) +
opts(axis.text.x = theme_blank(),axis.text.y = theme_blank()) +
opts(axis.ticks = theme_blank()) +
xlab("") + ylab("")
# add a single point

p <- p + geom_point(data=sf,aes(long,lat),colour="green",size=4)
p opts theme opts(panel.background = theme_blank()) theme(panel.background = element_blank())
-------------------------------------------------------------------------------------------------------
ggplot(ny, aes(long, lat)) +  
    geom_polygon(aes(group=group), colour='black', fill=NA) +
    geom_text(data=cnames, aes(long, lat, label = subregion), size=2) long lat aes(long, lat) aes(group=group) aes range cnames <- aggregate(cbind(long, lat) ~ subregion, data=ny, 
                    FUN=function(x)mean(range(x)))

ggplot(ny, aes(long, lat)) +  
    geom_polygon(aes(group=group), colour='black', fill=NA) +
    geom_text(data=cnames, aes(long, lat, label = subregion), size=2) +
    coord_map()
-------------------------------------------------------------------------------------------------------
R> plot(X, B, type="l", col="blue", xlim=c(0, 25), ylim=c(0, 15))
R> par(new=TRUE)
R> plot(X, C, type="l", col="red", xlim=c(0, 25), ylim=c(0, 15))
R> polygon(c(1:6, 6:1), c(B[1:6], C[6:1]), col="purple")
-------------------------------------------------------------------------------------------------------
cnames <- aggregate(cbind(long, lat) ~ subregion, data=ny, 
                    FUN=function(x)mean(range(x))) #Andrie's code

cnames[52, 2:3] <- c(-73, 40.855)  #adjust the long and lat of poorly centered names
cnames$angle <- rep(0, nrow(cnames)) #create an angle column
cnames[22, 4] <- -90    #adjust the angle of atypically shaped

ggplot(ny, aes(long, lat)) +  
    geom_polygon(aes(group=group), colour='black', fill=NA) +
    geom_text(data=cnames, aes(long, lat, label = subregion, colour=col, 
    angle=angle), size=3) + coord_map()
-------------------------------------------------------------------------------------------------------
X <- 1:20
B <- c(1,4,6,3,1, 4, 5,8,8,6,3,2,1, 1,5,7,8,6,4,2)
C <- B + 4
A <- rep (0, length(B))
myd <- data.frame (X, B, C, A)

plot(X, B, type="l", col="blue", xlim=c(0, 25), ylim=c(0, 15))

# 1 to 6

par(new=TRUE)
plot(X, C, type="l", col="red", xlim=c(0, 25), ylim=c(0, 15))
polygon(c(1:6, 6:1), c(B[1:6], C[6:1]), col="green1")

par(new=TRUE)
plot(X, B, type="l", col="red", xlim=c(0, 25), ylim=c(0, 15))
polygon(c(1:6, 6:1), c(B[1:6], A[6:1]), col="green4")


# 6 to 16
par(new=TRUE)
plot(X, C, type="l", col="red", xlim=c(0, 25), ylim=c(0, 15))
polygon(c(6:16, 16:6), c(B[6:16], C[16:6]), col="blue1")

par(new=TRUE)
plot(X, B, type="l", col="red", xlim=c(0, 25), ylim=c(0, 15))
polygon(c(6:16, 16:6), c(B[6:16], A[16:6]), col="blue4")

# 16 to 20
par(new=TRUE)
plot(X, C, type="l", col="red", xlim=c(0, 25), ylim=c(0, 15))
polygon(c(16:20, 20:16), c(B[16:20], C[20:16]), col="purple1")

par(new=TRUE)
plot(X, B, type="l", col="red", xlim=c(0, 25), ylim=c(0, 15))
polygon(c(16:20, 20:16), c(B[16:20], A[20:16]), col="purple4")
-------------------------------------------------------------------------------------------------------
require(maps)
require(grid)
NY <- ggplot(ny, aes(long, lat, group=group)) +  geom_polygon(colour='black', fill=NA)
 grid.locator("npc")
# clicked in middle of NY State:

#$x
#[1] 0.493649231346082npc
#
#$y
#[1] 0.556430446194226npc
 range(NY$data$long)
#[1] -79.76718 -71.87756
 range(NY$data$lat)
#[1] 40.48520 45.01157
 locatedX <- min(NY$data$long) + 0.493649231346082*diff(range(NY$data$long))
 locatedX
#[1] -75.87247
locatedY <- min(NY$data$lat) +  0.556430446194226*diff(range(NY$data$lat))
locatedY
#[1] 43.00381
-------------------------------------------------------------------------------------------------------
require(maps); require(ggplot2); require(grid)

ny <- map_data('county', 'new york')

NY1 <- ggplot(ny, aes(long, lat)) +  
          geom_polygon(aes(group=group), colour='black', fill=NA) +
          coord_map() + geom_point(aes(c(-78, -73), c(41, 40.855), 
          colour=c("blue", "red"))) + opts(legend.position = "none") 

NY <- NY1 + scale_x_continuous(expand=c(0,0)) + 
          scale_y_continuous(expand=c(0,0))
          #the scale x and y have to be added to the plot

NY 

ggmap.loc <- function(object){
    x <- grid.ls()[[1]][grep("panel-", grid.ls()[[1]])] #locate the panel
    seekViewport(x)
    y <-  as.numeric(grid.locator("npc"))
    locatedX <- min(object$data$long) + y[1]*diff(range(object$data$long))
    locatedy <- min(object$data$lat) + y[2]*diff(range(object$data$lat))
    return(c(locatedX, locatedy))
}

ggmap.loc(NY)
-------------------------------------------------------------------------------------------------------
gglocator <- function(n = 1, object = last_plot(), 
    message = FALSE, xexpand = c(.05,0), yexpand = c(.05, 0)){ 

  #compliments of David Kahle
  if(n > 1){
    df <- NULL
    for(k in 1:n){
      df <- rbind(df, gglocator(object = object, message = message, 
        xexpand = xexpand, yexpand = yexpand))
    }
    return(df)
  }

  x <- grid.ls(print = message)[[1]]
  x <- x[ grep("panel-", grid.ls(print=message)[[1]]) ] #locate the panel
  seekViewport(x)
  loc <-  as.numeric(grid.locator("npc"))

  xrng <- with(object, range(data[,deparse(mapping$x)]))
  yrng <- with(object, range(data[,deparse(mapping$y)]))    

  xrng <- expand_range(range = xrng, mul = xexpand[1], add = xexpand[2])
  yrng <- expand_range(range = yrng, mul = yexpand[1], add = yexpand[2])    

  point <- data.frame(xrng[1] + loc[1]*diff(xrng), yrng[1] + loc[2]*diff(yrng))
  names(point) <- with(object, c(deparse(mapping$x), deparse(mapping$y)))
  point
}

#Example 1
require(maps); library(ggplot2); require(grid)
county_df <- map_data('county')  #mappings of counties by state
ny <- subset(county_df, region=="new york")   #subset just for NYS
ny$county <- ny$subregion


NY <- ggplot(ny, aes(long, lat)) +  
          geom_polygon(aes(group=group), colour='black', fill=NA) +
          coord_map() + geom_point(aes(c(-78, -73), c(41, 40.855), 
          colour=c("blue", "red"))) + opts(legend.position = "none") 


NY 
gglocator(2)

#Example 2
df <- data.frame(xvar = 2:10, yvar = 2:10)
ggplot(df, aes(xvar, yvar)) + geom_point() + geom_point(aes(x = 3, y = 6))
gglocator() gglocator
-------------------------------------------------------------------------------------------------------
interaction <- merge(propdata, relation, by.x="name", by.y="name1")
interaction <- cbind(interaction, 
               merge(propdata, relation, by.x="name", by.y="name2")[, c("X", "Y")])
names(interaction)[8:9] <- c("Xend", "Yend")
interaction

  name diameter X Y colr name2 score Xend Yend
1    A      4.3 1 1   10     B   1.1    2    3
2    A      4.3 1 1   10     C   2.2    3    3
3    A      4.3 1 1   10     D   5.4    3    3
4    B      8.3 2 3   20     C   3.1    4    4
5    B      8.3 2 3   20     D   2.0    4    4 ggplot2 geom_polygon circle <- function(x, y, d, color, scale=1){
  d <- d * scale
  angle <- seq(-pi, pi, length = 50) 
  data.frame(
    x = x + d/2*sin(angle), 
    y = y + d/2*cos(angle),
    color=color)
}

circles <- ddply(propdata, .(name), 
                 function(x)with(x, circle(X, Y, diameter, colr, scale=0.2))) ggplot() + 
  geom_polygon(data=circles, aes(group=name, x=x, y=y, fill=color)) +
  geom_text(data=propdata, aes(x=X, y=Y, label=name), hjust=0, vjust=0) +
  geom_segment(data=interaction, aes(x=X, y=Y, xend=Xend, yend=Yend, size=score)) + 
  scale_size("Inter", to=c(0, 5)) +
  coord_equal()
-------------------------------------------------------------------------------------------------------
library(ggplot2)

OT1 <- read.csv('OT1.csv')

OTz<-OT1[OT1$TSUM==0,]#selecting only my zeros
OTc<-OT1[OT1$TSUM!=0,]

# plotting data with ggplot2
library(scales)
v <- ggplot(OTc, aes(longitude, latitude, size=TSUM)) +
  geom_point(colour="red", alpha=0.1) + facet_wrap(~month, ncol=2)
v + geom_point(data = OTz,size = 1,colour = "black", alpha=0.2) +
  opts(title="Otter trawl 1996-2011")


library(rgdal)
library(sp)
library(maptools)
gpclibPermit()

div0A <- readOGR(dsn=".", layer="Projections")

names(div0A)
dim(div0A)

library(gpclib)
# add the 'id' variable to the shapefile and use it to merge both files
div0A@data$id = rownames(div0A@data)
div0A.df <- as.data.frame(div0A)# convert shapefile to dataframe
div0A_fort <- fortify(div0A, region="id")# fortify to plot with ggplot2 
head(div0A_fort)

# Merge shapefile and the as.dataframe shapefile
library(plyr)
div0A_merged <- join(div0A_fort, div0A.df, by="id")
head(div0A_merged)

# Get all the months used in OTc
monthdf <- data.frame(month = unique(OTc$month))

# Merge with div0A_merged 
# (replicate each row in div0A_merged for each month)
div0A_merged_month <- merge(div0A_merged, monthdf)

# Graph with the shapefile
ggplot(div0A_merged_month, aes(long, lat, group=group)) +
  geom_polygon() +
  geom_path(color="white") +
  geom_point(data=OTc, aes(x=longitude, y=latitude, size=TSUM),
             colour="red", alpha=0.2, inherit.aes=FALSE) +
  theme_bw() +
  facet_wrap(~ month, ncol=2)
-------------------------------------------------------------------------------------------------------
png() library(maps)
library(ggplot2)
#specify size here
png("world.png",height=600,width=800)

#here is a way to create very simple data frame from you coordinates
data <- read.table(textConnection("
lat long 
59.5624775 -139.7410994 
42.38748056 -94.61803333"),header=TRUE,as.is=TRUE)
long=data$long
lat=data$lat
world <- map_data('usa')
sf<-data.frame(long=long,lat=lat)
ggplot() +
geom_polygon(data=world, aes(x=long, y=lat,group=group)) + 
geom_point(data=sf,aes(long,lat),colour="white",size=1)

#this saves png in your current directory
dev.off()
-------------------------------------------------------------------------------------------------------
geom_path geom_polygon ggplot(va, aes(long, lat)) + coord_map() + geom_polygon(aes(group=group)) + 
   geom_polygon(data=subset(va, subregion %in% c("patrick", "henry", "franklin",
   "pittsylvania")), aes(group=group), size=1, color="white",fill="white")
-------------------------------------------------------------------------------------------------------
d <- subset(va, subregion %in% c("patrick", "henry", "franklin", "pittsylvania"))
duplicates <- duplicated(d[, c("long","lat")]) |
              duplicated(d[, c("long","lat")], fromLast=TRUE)

d2 <- d[duplicates, ]
d3 <- d[!duplicates, ]
d3 <- arrange(d3, order , region, group )
ggplot(d, aes(long, lat)) + geom_polygon(aes(fill=subregion), col=NA) +
  geom_point(colour="black") +
  geom_point(data=d2, colour="red") +
  geom_path(data=d3, fill=NA, colour="blue", size=1.2)
-------------------------------------------------------------------------------------------------------
index coredata # Sample data
library(quantmod)
getSymbols("^GSPC")
x <- Vo(GSPC)
n <- length(x)

# Plot
plot(index(x), coredata(x), type="n", las=1, ylim=range(0,x))
polygon( 
  index(x)[c(1,1:n,n)], 
  c(0,coredata(x),0), 
  col="grey" 
)
box()
-------------------------------------------------------------------------------------------------------
ggplot2 geom_point alpha ggplot2 dat = data.frame(x = runif(1000), y = runif(1000), cat = rep(c("A","B"), each = 500))
ggplot(aes(x = x, y = y, color = cat), data = dat) + geom_point(alpha = 0.3) library(automap)
library(ggplot2)
library(plyr)
loadMeuse()
theme_set(theme_bw())

meuse = as.data.frame(meuse)
chull_per_soil = ddply(meuse, .(soil), 
           function(sub) sub[chull(sub$x, sub$y),c("x","y")])

ggplot(aes(x = x, y = y), data = meuse) +
  geom_point(aes(size = log(zinc), color = ffreq)) +
  geom_polygon(aes(color = soil), data = chull_per_soil, fill = NA) +
  coord_equal()
-------------------------------------------------------------------------------------------------------
ppi = 300
tiff("mygraph.tiff", width=6.75*ppi, height=6*ppi, res=ppi)
plot(c(2,2,4,4), c(2,4,2,4),xlim=c(0,5), ylim=c(0,10), 
      xlab="Text xlab", ylab="Test ylab", 
      pch=16, cex=1.5)
polygon(c(2,2,4,4),c(2,4,4,2), col="darkblue")
text(1,8,"Test")
dev.off()
-------------------------------------------------------------------------------------------------------
circle <- function(x, y, rad = 1, nvert = 500, ...){
    rads <- seq(0,2*pi,length.out = nvert)
    xcoords <- cos(rads) * rad + x
    ycoords <- sin(rads) * rad + y
    polygon(xcoords, ycoords, ...)
}

# asp = 1 due to Hans' comment below- wouldn't let me leave a comment just saying 'thanks'
plot(-5:5, type="n", xlim = c(-5,5), ylim = c(-5,5), asp = 1)
circle(0,0,4)
circle(-1.5,1.5,.5)
circle(1.5,1.5,.5)
circle(0,0,1)
segments(-2,-2,2,-2)
-------------------------------------------------------------------------------------------------------
ggplot(aes(x = x, y = y), data = pointset1) +
  geom_point() +
  geom_polygon(aes(fill = z), data = polyset1) +
  etc
-------------------------------------------------------------------------------------------------------
ggplot() group group centroids geom_text groups=NULL geom_text ggplot(map.data2, aes(long, lat, group=group)) +  
   geom_polygon(aes(fill=level), colour=alpha('white', 1/2), size=0.2) +
   geom_polygon(data=ny, colour='black', fill=NA) + 
   scale_fill_brewer(palette='RdYlBu', guide = guide_legend(title = 
         "Percent Passing"))+
   facet_grid(.~Subject)+
   geom_text(data=centroids, aes(x=long, y=lat, 
     label=subregion, angle=angle, group=NULL), size=3) +   # THIS HAS CHANGED!
   opts(title = " 
     New York State Counties Passing Rate \non Elementary ELA Assessments") +
   opts(axis.text.x = theme_blank(), axis.text.y = theme_blank(), 
       axis.ticks = theme_blank())+
   opts(legend.background = theme_rect()) +
   scale_x_continuous('') + scale_y_continuous('') + 
   labs(title = "legend title") + theme_bw()+
    opts(axis.line=theme_blank(),axis.text.x=theme_blank(),
      axis.text.y=theme_blank(),axis.ticks=theme_blank(),
      axis.title.x=theme_blank(), legend.position="bottom",
      axis.title.y=theme_blank(),
      panel.background=theme_blank(),panel.grid.major=theme_blank(),
      panel.grid.minor=theme_blank(),plot.background=theme_blank())
-------------------------------------------------------------------------------------------------------
XXXX data x y maps ggplot(subset(df, as.character(variable) == "value"), aes(map_id = id)) +
  geom_map(aes(fill = pct), colour = "black", map = ggmap) +
  geom_polygon(data=XXXX, aes(x=XXXX, y=XXXX), colour='black', fill=NA) +
  expand_limits(x = ggmap$long, y = ggmap$lat) +
  scale_fill_gradient(low = "antiquewhite", high = "darkred") +
  opts(title = "Title", panel.background = theme_rect(fill = "grey90"))
-------------------------------------------------------------------------------------------------------
read.shp fastshp ggplot2 library(fastshp)
library(ggplot2)

setwd(system.file("shapes", package="maptools"))

shp <- read.shp("columbus.shp", format="polygon")
shp.list <- sapply(shp, FUN = function(x) do.call(cbind, x[c("id","x","y")]))
shp.df <- as.data.frame(do.call(rbind, shp.list))
shp.gg <- ggplot(shp.df, aes(x = x, y=y, group = id))+geom_polygon() shp.list <- sapply(shp, FUN = function(x) Polygon(cbind(lon = x$x, lat = x$y)))
shp.poly <- Polygons(shp.list, "area")
shp.df <- fortify(shp.poly, region = "area")
shp.gg <- ggplot(shp.df, aes(x = long, y=lat, group = piece, order = hole))+geom_polygon()
-------------------------------------------------------------------------------------------------------
ggplot plot plot.as.stack= function(mapdata1, mbar.col = "blue"){
    # mapdata1 <- mapdata[mapdata$chr == chr,]
    m <- par()$mar
    m[1] <- m[3] <- 0
    par(mar=m)
    # Set the limits of the  plot
    plot(mapdata1$position,mapdata1$position-mapdata1$position, type="n",
       axes=FALSE, 
    xlab="", ylab="Chromsome", yaxt="n" )

    polygon(
      c(0,max(mapdata1$position + 0.08 * max(mapdata1$position)),max(mapdata1$position)+
         0.08 * max(mapdata1$position),0),
      .2*c(-0.3,-0.3,0.3,0.3),
      col= mbar.col
    )
    segments(mapdata1$position, -.3, mapdata1$position, .3 )
    text(mapdata1$position, -.7, mapdata1$snpname, srt = 90, cex.lab = chr.lab)
    text(mapdata1$position,  .7, mapdata1$position,cex.lab = chr.lab )
    text(0, labels = paste("Chr",unique(mapdata1$chr)))
}

# Example Run.
par(mfrow=c(length(unique(mapdata$chr)),1))
x=by(mapdata,factor(mapdata$chr),plot.as.stack) # Assigned to x to prevent output
par(mfrow=c(1,1)) by chr plot.as.stack = function(chr){
    mapdata1 <- mapdata[mapdata$chr == chr,]
    ...
} par(mfrow=c(5,1))
sapply(1:5,plot.as.stack)
par(mfrow=c(1,1))
-------------------------------------------------------------------------------------------------------
ggplot dat <- read.table(text="
ISO3V10   Country   'No of Documents'    Lat  Lon
ARG     Argentina   41          -64 -34
AUS     Australia   224         133 -27
CAN     Canada      426         -95 60
IRL     Ireland 68           -8 53
ITA     Italy             583           12.8333 42.8333
NLD     Netherlands 327          5.75   52.5
NZL     'New Zealand' 26           174    -41
ESP     Spain             325            -4  40
GBR     'United Kingdom'  2849             -2 54
USA     'United States'   3162            -97 38
", header=TRUE) library(ggplot2)
library(maps)

mdat <- map_data('world')

str(mdat)
ggplot() + 
  geom_polygon(dat=mdat, aes(long, lat, group=group), fill="grey50") +
  geom_point(data=dat, 
             aes(x=Lat, y=Lon, map_id=Country, size=`No.of.Documents`), col="red")
-------------------------------------------------------------------------------------------------------
PolarImageInterpolate <- function(x, y, z, outer.radius = 1, 
            breaks, col, nlevels = 20, contours = TRUE, legend = TRUE, 
            axes = TRUE, circle.rads = pretty(c(0,outer.radius))){

        minitics <- seq(-outer.radius, outer.radius, length.out = 1000)
        # interpolate the data
        Interp <- akima:::interp(x = x, y = y, z = z, 
                extrap = TRUE, 
                xo = minitics, 
                yo = minitics, 
                linear = FALSE)
        Mat <- Interp[[3]]

        # mark cells outside circle as NA
        markNA <- matrix(minitics, ncol = 1000, nrow = 1000) 
        Mat[!sqrt(markNA ^ 2 + t(markNA) ^ 2) < outer.radius] <- NA 

        # sort out colors and breaks:
        if (!missing(breaks) & !missing(col)){
            if (length(breaks) - length(col) != 1){
                stop("breaks must be 1 element longer than cols")
            }
        }
        if (missing(breaks) & !missing(col)){
            breaks <- seq(min(Mat,na.rm = TRUE), max(Mat, na.rm = TRUE), length = length(col) + 1)
            nlevels <- length(breaks) - 1
        }
        if (missing(col) & !missing(breaks)){
            col <- rev(heat.colors(length(breaks) - 1))
            nlevels <- length(breaks) - 1
        }
        if (missing(breaks) & missing(col)){
            breaks <- seq(min(Mat,na.rm = TRUE), max(Mat, na.rm = TRUE), length = nlevels + 1)
            col <- rev(heat.colors(nlevels))
        }

        # if legend desired, it goes on the right and some space is needed
        if (legend) {
            par(mai = c(1,1,1.5,1.5))
        }

        # begin plot
        image(x = minitics, y = minitics, t(Mat), useRaster = TRUE, asp = 1, 
            axes = FALSE, xlab = "", ylab = "", col = col, breaks = breaks)

        # add contours if desired
        if (contours){
            CL <- contourLines(x = minitics, y = minitics, t(Mat), levels = breaks)
            A <- lapply(CL, function(xy){
                        lines(xy$x, xy$y, col = gray(.2), lwd = .5)
                    })
        }

        # add radial axes if desired
        if (axes){ 
            # internals for axis markup
            RMat <- function(radians){
                matrix(c(cos(radians), sin(radians), -sin(radians), cos(radians)), ncol = 2)
            }    

            circle <- function(x, y, rad = 1, nvert = 500){
                rads <- seq(0,2*pi,length.out = nvert)
                xcoords <- cos(rads) * rad + x
                ycoords <- sin(rads) * rad + y
                cbind(xcoords, ycoords)
            }

            # draw circles
            if (missing(circle.rads)){
                circle.rads <- pretty(c(0,outer.radius))
            }

            for (i in circle.rads){
                lines(circle(0, 0, i), col = "#66666650")
            }

            # put on radial spoke axes:
            axis.rads <- c(0, pi / 6, pi / 3, pi / 2, 2 * pi / 3, 5 * pi / 6)
            r.labs <- c(90, 60, 30, 0, 330, 300)
            l.labs <- c(270, 240, 210, 180, 150, 120)

            for (i in 1:length(axis.rads)){ 
                endpoints <- zapsmall(c(RMat(axis.rads[i]) %*% matrix(c(1, 0, -1, 0) * outer.radius,ncol = 2)))
                segments(endpoints[1], endpoints[2], endpoints[3], endpoints[4], col = "#66666650")
                endpoints <- c(RMat(axis.rads[i]) %*% matrix(c(1.1, 0, -1.1, 0) * outer.radius, ncol = 2))
                lab1 <- bquote(.(r.labs[i]) * degree)
                lab2 <- bquote(.(l.labs[i]) * degree)
                text(endpoints[1], endpoints[2], lab1, xpd = TRUE)
                text(endpoints[3], endpoints[4], lab2, xpd = TRUE)
            }
            axis(2, pos = -1.2 * outer.radius, at = sort(union(circle.rads,-circle.rads)), labels = NA)
            text( -1.21 * outer.radius, sort(union(circle.rads, -circle.rads)),sort(union(circle.rads, -circle.rads)), xpd = TRUE, pos = 2)
        }

        # add legend if desired
        # this could be sloppy if there are lots of breaks, and that's why it's optional.
        # another option would be to use fields:::image.plot(), using only the legend. 
        # There's an example for how to do so in its documentation
        if (legend){
            ylevs <- seq(-outer.radius, outer.radius, length = nlevels + 1)
            rect(1.2 * outer.radius, ylevs[1:(length(ylevs) - 1)], 1.3 * outer.radius, ylevs[2:length(ylevs)], col = col, border = NA, xpd = TRUE)
            rect(1.2 * outer.radius, min(ylevs), 1.3 * outer.radius, max(ylevs), border = "#66666650", xpd = TRUE)
            text(1.3 * outer.radius, ylevs,round(breaks, 1), pos = 4, xpd = TRUE)
        }
    }

    # Example
    set.seed(10)
    x <- rnorm(20)
    y <- rnorm(20)
    z <- rnorm(20)
    PolarImageInterpolate(x,y,z, breaks = seq(-2,8,by = 1)) image() # arguments:

    # Mat, a matrix of z values as follows:
    # leftmost edge of first column = 0 degrees, rightmost edge of last column = 360 degrees
    # columns are distributed in cells equally over the range 0 to 360 degrees, like a grid prior to transform
    # first row is innermost circle, last row is outermost circle

    # outer.radius, By default everything scaled to unit circle 
    # ppa: points per cell per arc. If your matrix is little, make it larger for a nice curve
    # cols: color vector. default = rev(heat.colors(length(breaks)-1))
    # breaks: manual breaks for colors. defaults to seq(min(Mat),max(Mat),length=nbreaks)
    # nbreaks: how many color levels are desired?
    # axes: should circular and radial axes be drawn? radial axes are drawn at 30 degree intervals only- this could be made more flexible.
    # circle.rads: at which radii should circles be drawn? defaults to pretty(((0:ncol(Mat)) / ncol(Mat)) * outer.radius)

    # TODO: add color strip legend.

    PolarImagePlot <- function(Mat, outer.radius = 1, ppa = 5, cols, breaks, nbreaks = 51, axes = TRUE, circle.rads){

        # the image prep
        Mat      <- Mat[, ncol(Mat):1]
        radii    <- ((0:ncol(Mat)) / ncol(Mat)) * outer.radius

        # 5 points per arc will usually do
        Npts     <- ppa
        # all the angles for which a vertex is needed
        radians  <- 2 * pi * (0:(nrow(Mat) * Npts)) / (nrow(Mat) * Npts) + pi / 2
        # matrix where each row is the arc corresponding to a cell
        rad.mat  <- matrix(radians[-length(radians)], ncol = Npts, byrow = TRUE)[1:nrow(Mat), ]
        rad.mat  <- cbind(rad.mat, rad.mat[c(2:nrow(rad.mat), 1), 1])

        # the x and y coords assuming radius of 1
        y0 <- sin(rad.mat)
        x0 <- cos(rad.mat)

        # dimension markers
        nc <- ncol(x0)
        nr <- nrow(x0)
        nl <- length(radii)

        # make a copy for each radii, redimension in sick ways
        x1 <- aperm( x0 %o% radii, c(1, 3, 2))
        # the same, but coming back the other direction to close the polygon
        x2 <- x1[, , nc:1]
        #now stick together
        x.array <- abind:::abind(x1[, 1:(nl - 1), ], x2[, 2:nl, ], matrix(NA, ncol = (nl - 1), nrow = nr), along = 3)
        # final product, xcoords, is a single vector, in order, 
        # where all the x coordinates for a cell are arranged
        # clockwise. cells are separated by NAs- allows a single call to polygon()
        xcoords <- aperm(x.array, c(3, 1, 2))
        dim(xcoords) <- c(NULL)
        # repeat for y coordinates
        y1 <- aperm( y0 %o% radii,c(1, 3, 2))
        y2 <- y1[, , nc:1]
        y.array <- abind:::abind(y1[, 1:(length(radii) - 1), ], y2[, 2:length(radii), ], matrix(NA, ncol = (length(radii) - 1), nrow = nr), along = 3)
        ycoords <- aperm(y.array, c(3, 1, 2))
        dim(ycoords) <- c(NULL)

        # sort out colors and breaks:
        if (!missing(breaks) & !missing(cols)){
            if (length(breaks) - length(cols) != 1){
                stop("breaks must be 1 element longer than cols")
            }
        }
        if (missing(breaks) & !missing(cols)){
            breaks <- seq(min(Mat,na.rm = TRUE), max(Mat, na.rm = TRUE), length = length(cols) + 1)
        }
        if (missing(cols) & !missing(breaks)){
            cols <- rev(heat.colors(length(breaks) - 1))
        }
        if (missing(breaks) & missing(cols)){
            breaks <- seq(min(Mat,na.rm = TRUE), max(Mat, na.rm = TRUE), length = nbreaks)
            cols <- rev(heat.colors(length(breaks) - 1))
        }

        # get a color for each cell. Ugly, but it gets them in the right order
        cell.cols <- as.character(cut(as.vector(Mat[nrow(Mat):1,ncol(Mat):1]), breaks = breaks, labels = cols))

        # start empty plot
        plot(NULL, type = "n", ylim = c(-1, 1) * outer.radius, xlim = c(-1, 1) * outer.radius, asp = 1, axes = FALSE, xlab = "", ylab = "")
        # draw polygons with no borders:
        polygon(xcoords, ycoords, col = cell.cols, border = NA)

        if (axes){

            # a couple internals for axis markup.

            RMat <- function(radians){
                matrix(c(cos(radians), sin(radians), -sin(radians), cos(radians)), ncol = 2)
            }

            circle <- function(x, y, rad = 1, nvert = 500){
                rads <- seq(0,2*pi,length.out = nvert)
                xcoords <- cos(rads) * rad + x
                ycoords <- sin(rads) * rad + y
                cbind(xcoords, ycoords)
            }
            # draw circles
            if (missing(circle.rads)){
                circle.rads <- pretty(radii)
            }
            for (i in circle.rads){
                lines(circle(0, 0, i), col = "#66666650")
            }

            # put on radial spoke axes:
            axis.rads <- c(0, pi / 6, pi / 3, pi / 2, 2 * pi / 3, 5 * pi / 6)
            r.labs <- c(90, 60, 30, 0, 330, 300)
            l.labs <- c(270, 240, 210, 180, 150, 120)

            for (i in 1:length(axis.rads)){ 
                endpoints <- zapsmall(c(RMat(axis.rads[i]) %*% matrix(c(1, 0, -1, 0) * outer.radius,ncol = 2)))
                segments(endpoints[1], endpoints[2], endpoints[3], endpoints[4], col = "#66666650")
                endpoints <- c(RMat(axis.rads[i]) %*% matrix(c(1.1, 0, -1.1, 0) * outer.radius, ncol = 2))
                lab1 <- bquote(.(r.labs[i]) * degree)
                lab2 <- bquote(.(l.labs[i]) * degree)
                text(endpoints[1], endpoints[2], lab1, xpd = TRUE)
                text(endpoints[3], endpoints[4], lab2, xpd = TRUE)
            }
            axis(2, pos = -1.2 * outer.radius, at = sort(union(circle.rads,-circle.rads)))
        }
        invisible(list(breaks = breaks, col = cols))
    } image() set.seed(1)
    x <- runif(20, min = 0, max = 360)
    y <- runif(20, min = 0, max = 40)
    z <- rnorm(20)

    Interp <- akima:::interp(x = x, y = y, z = z, 
            extrap = TRUE, 
            xo = seq(0, 360, length.out = 300), 
            yo = seq(0, 40, length.out = 100), 
            linear = FALSE)
    Mat <- Interp[[3]]

    PolarImagePlot(Mat)
-------------------------------------------------------------------------------------------------------
library(grid)

png("mask.png")
grid.polygon(c(-0.06, 0.06, 0.06, 0.15, 0, -0.15, -0.06),
             c(-5, -5, 2.5, 2, 5, 2, 2.5), gp=gpar(fill="black"),
             def="native",
             vp=viewport(xs=c(-0.15, 0.15), ys=c(-5, 5)))
dev.off()

library(png)
m <- readPNG("mask.png", native=FALSE)
mask <- matrix(rgb(m[,,1],m[,,2],m[,,3]),
               nrow=nrow(m))

rmat <- matrix(rgb(colorRamp(c("blue","white","red"))(seq(0,1,length=nrow(m))), maxColorValue=255),
               nrow=nrow(m), ncol=ncol(m))
rmat[mask == "#FFFFFF"] <- NA
grid.newpage()
grid.raster(rmat) library(ggplot2)
ggplot(iris) + geom_path(aes(Sepal.Length, Petal.Length, colour = Petal.Width)) +
  guides(colour = guide_colourbar()) +
  annotation_custom(rasterGrob(rmat, width=unit(1,"npc"), height=unit(1, "npc")),
                    x = 6, xmax=6.2, y=2.5, ymax=4)
-------------------------------------------------------------------------------------------------------
ggplot2 rm(list = ls(all = TRUE)) #clear workspace

library(maptools)
library(gpclib)
library(ggplot2)

shape<-readShapeSpatial("./fao/World_Fao_Zones.shp") 
shape@data$id <- rownames(shape@data)
shape.fort <- fortify(shape, region='id') 
shape.fort<-shape.fort[order(shape.fort$order), ] 
ggplot(data=shape.fort, aes(long, lat, group=group)) + 
    geom_polygon(colour='black',
                 fill='white') +
    theme_bw() > sessionInfo()
R version 2.15.0 (2012-03-30)
Platform: x86_64-apple-darwin9.8.0/x86_64 (64-bit)

locale:
    [1] C/en_US.UTF-8/C/C/C/C

attached base packages:
    [1] grid      stats     graphics  grDevices utils    
[6] datasets  methods   base     

other attached packages:
    [1] mapproj_1.1-8.3 gpclib_1.5-1    maptools_0.8-14
[4] lattice_0.20-6  foreign_0.8-49  rgeos_0.2-5    
[7] stringr_0.6     sp_0.9-99       gridExtra_0.9  
[10] mapdata_2.2-1   ggplot2_0.9.0   maps_2.2-5     

loaded via a namespace (and not attached):
    [1] MASS_7.3-17        RColorBrewer_1.0-5 colorspace_1.1-1  
[4] dichromat_1.2-4    digest_0.5.2       memoise_0.1       
[7] munsell_0.3        plyr_1.7.1         proto_0.3-9.2     
[10] reshape2_1.2.1     scales_0.2.0       tools_2.15.0
-------------------------------------------------------------------------------------------------------
data.frame geom_vline a <- c(-2.27685371,0.01661155,0.33598194,1.92426022)
vlines <- data.frame(xint = c(a,mean(a)),grp = letters[1:5]) grp colour aes qplot(x, tvalues) + 
  geom_polygon(fill = "purple", colour = "purple", alpha = 0.5) + 
  geom_point(fill = "purple", colour = "purple", alpha = 0.2, pch = 21) +
  geom_vline(data = vlines,aes(xintercept = xint,colour = grp), linetype = "dashed") + 
  theme_bw() + 
  xlab(bquote(bold('Average Tensile Strength (lb/in'^'2'*')'))) +
  ylab(expression(bold(P(x)))) +
  opts(title = expression(bold("Student t Distribution")), 
       plot.title = theme_text(size = 20, colour = "darkblue"),
       panel.border = theme_rect(size = 2, colour = "red")) qplot ggplot()
-------------------------------------------------------------------------------------------------------
spplot image ggplot2 geom_raster geom_tile ggplot(aes(x = x, y = y, fill = value), data = dat_grid) + geom_tile() + 
  geom_path(data = ant_ggplot) ggplot2 mapproj coord_map YOUR_DATA library(ggplot2)
library(maps)
us_states <- map_data("state")
(ggplot(aes(x=x,y=y,fill=z),data=YOUR_DATA) + geom_tile())+geom_polygon(data=us_states,aes(x=long, y=lat, group=group), colour="black", fill="white", alpha=0)
-------------------------------------------------------------------------------------------------------
map geocode() geom_polygon library(maps)
library(plyr)
library(ggplot2)
library(sp)
library(ggmap)

# Get some points to plot - CRAN Mirrors
Mirrors = getCRANmirrors(all = FALSE, local.only = FALSE)

Mirrors$Place = paste(Mirrors$City, ", ", Mirrors$Country, sep = "")    # Be patient
tmp = geocode(Mirrors$Place)
Mirrors = cbind(Mirrors, tmp)

###################################################################################################
# Recentre worldmap (and Mirrors coordinates) on longitude 160
### Code by Claudia Engel  March 19, 2012, www.stanford.edu/~cengel/blog

### Recenter ####
center <- 160 # positive values only

# shift coordinates to recenter CRAN Mirrors
Mirrors$long.recenter <- ifelse(Mirrors$lon < center - 180 , Mirrors$lon + 360, Mirrors$lon)

# shift coordinates to recenter worldmap
worldmap <- map_data ("world")
worldmap$long.recenter <- ifelse(worldmap$long < center - 180 , worldmap$long + 360, worldmap$long)

### Function to regroup split lines and polygons
# Takes dataframe, column with long and unique group variable, returns df with added column named group.regroup
RegroupElements <- function(df, longcol, idcol){
  g <- rep(1, length(df[,longcol]))
  if (diff(range(df[,longcol])) > 300) { # check if longitude within group differs more than 300 deg, ie if element was split
    d <- df[,longcol] > mean(range(df[,longcol])) # we use the mean to help us separate the extreme values
    g[!d] <- 1 # some marker for parts that stay in place (we cheat here a little, as we do not take into account concave polygons)
    g[d] <- 2 # parts that are moved
  }
  g <- paste(df[, idcol], g, sep=".") # attach to id to create unique group variable for the dataset
  df$group.regroup <- g
  df
}

### Function to close regrouped polygons
# Takes dataframe, checks if 1st and last longitude value are the same, if not, inserts first as last and reassigns order variable
ClosePolygons <- function(df, longcol, ordercol){
  if (df[1,longcol] != df[nrow(df),longcol]) {
    tmp <- df[1,]
    df <- rbind(df,tmp)
  }
  o <- c(1: nrow(df)) # rassign the order variable
  df[,ordercol] <- o
  df
}

# now regroup
worldmap.rg <- ddply(worldmap, .(group), RegroupElements, "long.recenter", "group")

# close polys
worldmap.cp <- ddply(worldmap.rg, .(group.regroup), ClosePolygons, "long.recenter", "order") # use the new grouping var
#############################################################################

# Plot worldmap using data from worldmap.cp
windows(9.2, 4)
worldmap = ggplot(aes(x = long.recenter, y = lat), data = worldmap.cp) + 
  geom_polygon(aes(group = group.regroup), fill="#f9f9f9", colour = "grey65") + 
  scale_y_continuous(limits = c(-60, 85)) + 
  coord_equal() +  theme_bw() + 
  theme(legend.position = "none",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    #axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks = element_blank(), 
    panel.border = element_rect(colour = "black"))

# Plot the CRAN Mirrors
worldmap = worldmap + geom_point(data = Mirrors, aes(long.recenter, lat),
   colour = "red", pch = 19, size = 3, alpha = .4)

# Colour New Zealand
# Take care of variable names in worldmap.cp
head(worldmap.cp)
worldmap + geom_polygon(data = subset(worldmap.cp, region == "New Zealand", select = c(long.recenter, lat, group.regroup)), 
          aes(x = long.recenter, y = lat, group = group.regroup), fill = "blue")
-------------------------------------------------------------------------------------------------------
ggplot2 lattice lattice ggplot2 gridBase grid.pdf viewports.pdf rotated.pdf file.path(.Library, "grid", "doc") vignette("gridBase", package="gridBase") ## Load required packages
library(lattice); library(grid); library(gridBase)

## Construct example dataset
set.seed (123)
myd <- data.frame ( matrix(sample (c(1, 0, -1), 500, replace = "T"), 50))
mmat <-  cor(myd)
diag(mmat) <- NA
mmat[upper.tri (mmat)] <- NA

## Reformat data for input to `lattice::levelplot()`
grid <- data.frame(expand.grid(x = rownames(mmat), y = colnames(mmat)), 
                   z = as.vector(mmat))

## Open a plotting device    
plot.new()     

## Push viewport that will contain the levelplot; plot it; up viewport.
pushViewport(viewport(y = 0.6, height = 0.8, width = 0.8, angle=135))
    lp <- levelplot(z~y*x, grid, colorkey=FALSE, 
                    col.regions=heat.colors(100), aspect=1,
                    scales = list(draw=FALSE), xlab="", ylab="", 
                    par.settings=list(axis.line=list(col="white")))
    plot(lp, newpage=FALSE)
upViewport()

## Push viewport that will contain the green bar; plot it; up viewport.
pushViewport(viewport(y = 0.7, height=0.2))
    # Use the gridBase::gridOMI to determine the location within the plot.
    # occupied by the current viewport, then set that location via par() call
    par(omi = gridOMI(), new=TRUE, mar = c(0,0,0,0))
    plot(0:1, 0:1,type = "n", axes = FALSE, xlab = "", ylab = "", yaxt = "n")
    polygon(x=c(0,0,1,1,0), y = c(.4,.6,.6,.4,.4), col = "green4")
upViewport()
-------------------------------------------------------------------------------------------------------
convertToColors() "#FFFFFF heat.colors() NA library(grid)

## Data: heatmap
set.seed (123)
myd <- data.frame ( matrix(sample (c(1, 0, -1), 500, replace = "T"), 50))
mmat <-  cor(myd)
diag(mmat) <- NA
mmat[upper.tri (mmat)] <- NA
## Data: Positions
vard <- c(1, 10, 15, 18, 20, 23, 24, 30, 35, 40)

## Construct a function to convert a numeric matrix to a matrix of color names.
## The lowest value in the matrix maps to red, the highest to white,
## and the NAs to "transparent".
convertToColors <- function(mat) {
    # Produce 'normalized' version of matrix, with values ranging from 0 to 1
    rng <- range(mat, na.rm = TRUE)
    m <- (mat - rng[1])/diff(rng)
    # Convert to a matrix of sRGB color strings
    m2 <- m; class(m2) <- "character"
    m2[!is.na(m2)] <- rgb(colorRamp(heat.colors(10))(m[!is.na(m)]), max = 255)
    m2[is.na(m2)] <- "transparent"
    return(m2)
}

## Initialize plot and prepare two viewports
grid.newpage()
heatmapViewport <- viewport(height=1/sqrt(2), width=1/sqrt(2), angle = -135) 
annotationViewport <- viewport(y = 0.7, height = 0.4)

## Plot heat map
pushViewport(heatmapViewport)
    grid.raster(t(convertToColors(mmat)), interpolate = FALSE)
upViewport()

## Precompute x-locations of text and segment elements
n <- nrow(mmat)
v_x <- vard/max(vard)
X_x <- seq(0, 1, len=n)

## Plot the annotated green bar and line segments
pushViewport(annotationViewport)
    ## Green rectangle
    grid.polygon(x = c(0,0,1,1,0), y = c(.45,.55,.55,.45,.45),
                 gp = gpar(fill = "green4"))
    pushViewport(viewport(width = (n-1)/n))
        ## Segments and text marking vard values
        grid.segments(x0 = v_x, x1 = v_x, y0 = 0.3, y1 = 0.7)
        grid.text(label = vard, x = v_x, y = 0.75, rot = 90)
        ## Text marking heatmap column names (X1-X10)
        grid.text(paste0("X", seq_along(X_x)), x = X_x, y=0.05,
                  gp = gpar(fontface="bold"))
        ## Angled lines
        grid.segments(x0 = v_x, x1 = X_x, y0 = 0.29, y1 = 0.09)
    upViewport()
upViewport()
-------------------------------------------------------------------------------------------------------
chull dlply chull x <- dlply(df, .(id), function(piece)piece[chull(piece$X, piece$Y), -3])

plot(Y~X, df)
lapply(x, polygon) ggplot ddply x <- ddply(df, .(id), function(piece)piece[chull(piece$X, piece$Y), ])
ggplot(x, aes(X, Y, group=id)) + geom_polygon(fill="cyan", colour="blue") + geom_line()
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(grid)

set.seed (123)
xvar <- c(rnorm (100, 50, 30), rnorm (100, 40, 10), rnorm (100, 70, 10))
yvar <-   xvar + rnorm (length (xvar), 0, 20)
myd <- data.frame (xvar, yvar)

p1 <- ggplot(myd,aes(x=xvar,y=yvar))+
  stat_density2d(aes(fill=..level..), geom="polygon") +
  coord_cartesian(c(0, 150), c(0, 150)) +
  opts(legend.position = "none")

p2 <- ggplot(myd, aes(x = xvar)) + stat_density() +
  coord_cartesian(c(0, 150))
p3 <- ggplot(myd, aes(x = yvar)) + stat_density() + 
  coord_flip(c(0, 150))

gt <- ggplot_gtable(ggplot_build(p1))
gt2 <- ggplot_gtable(ggplot_build(p2))
gt3 <- ggplot_gtable(ggplot_build(p3))

gt1 <- ggplot2:::gtable_add_cols(gt, unit(0.3, "null"), pos = -1)
gt1 <- ggplot2:::gtable_add_rows(gt1, unit(0.3, "null"), pos = 0)

gt1 <- ggplot2:::gtable_add_grob(gt1, gt2$grobs[[which(gt2$layout$name == "panel")]],
                                  1, 4, 1, 4)
gt1 <- ggplot2:::gtable_add_grob(gt1, gt2$grobs[[which(gt2$layout$name == "axis-l")]],
                                 1, 3, 1, 3, clip = "off")

gt1 <- ggplot2:::gtable_add_grob(gt1, gt3$grobs[[which(gt3$layout$name == "panel")]],
                                 4, 6, 4, 6)
gt1 <- ggplot2:::gtable_add_grob(gt1, gt3$grobs[[which(gt3$layout$name == "axis-b")]],
                                 5, 6, 5, 6, clip = "off")
grid.newpage()
grid.draw(gt1) library(ggplot2)
library(grid)

set.seed (123)
xvar <- c(rnorm (100, 50, 30), rnorm (100, 40, 10), rnorm (100, 70, 10))
yvar <-   xvar + rnorm (length (xvar), 0, 20)
myd <- data.frame (xvar, yvar)

p1 <- ggplot(myd,aes(x=xvar,y=yvar))+
  stat_density2d(aes(fill=..level..), geom="polygon") +
  geom_polygon(aes(x, y), 
               data.frame(x = c(-Inf, -Inf, 30, 30), y = c(-Inf, 30, 30, -Inf)),
               alpha = 0.5, colour = NA, fill = "red") +
  geom_polygon(aes(x, y), 
               data.frame(x = c(Inf, Inf, 80, 80), y = c(Inf, 80, 80, Inf)),
               alpha = 0.5, colour = NA, fill = "green") +
  coord_cartesian(c(0, 120), c(0, 120)) +
  opts(legend.position = "none")

xd <- data.frame(density(myd$xvar)[c("x", "y")])
p2 <- ggplot(xd, aes(x, y)) + 
  geom_area(data = subset(xd, x < 30), fill = "red") +
  geom_area(data = subset(xd, x > 80), fill = "green") +
  geom_line() +
  coord_cartesian(c(0, 120))

yd <- data.frame(density(myd$yvar)[c("x", "y")])
p3 <- ggplot(yd, aes(x, y)) + 
  geom_area(data = subset(yd, x < 30), fill = "red") +
  geom_area(data = subset(yd, x > 80), fill = "green") +
  geom_line() +
  coord_flip(c(0, 120))

gt <- ggplot_gtable(ggplot_build(p1))
gt2 <- ggplot_gtable(ggplot_build(p2))
gt3 <- ggplot_gtable(ggplot_build(p3))

gt1 <- ggplot2:::gtable_add_cols(gt, unit(0.3, "null"), pos = -1)
gt1 <- ggplot2:::gtable_add_rows(gt1, unit(0.3, "null"), pos = 0)

gt1 <- ggplot2:::gtable_add_grob(gt1, gt2$grobs[[which(gt2$layout$name == "panel")]],
                                  1, 4, 1, 4)
gt1 <- ggplot2:::gtable_add_grob(gt1, gt2$grobs[[which(gt2$layout$name == "axis-l")]],
                                 1, 3, 1, 3, clip = "off")

gt1 <- ggplot2:::gtable_add_grob(gt1, gt3$grobs[[which(gt3$layout$name == "panel")]],
                                 4, 6, 4, 6)
gt1 <- ggplot2:::gtable_add_grob(gt1, gt3$grobs[[which(gt3$layout$name == "axis-b")]],
                                 5, 6, 5, 6, clip = "off")
grid.newpage()
grid.draw(gt1)
-------------------------------------------------------------------------------------------------------
twitterMap("#rstats",10,"10mi") twitterMap <- function(searchtext,locations,radius){
require(ggplot2)
require(maps)
require(twitteR)
#radius from randomly chosen location
radius=radius
lat<-runif(n=locations,min=24.446667, max=49.384472)
long<-runif(n=locations,min=-124.733056, max=-66.949778)
#generate data fram with random longitude, latitude and chosen radius
coordinates<-as.data.frame(cbind(lat,long,radius))
coordinates$lat<-lat
coordinates$long<-long
#create a string of the lat, long, and radius for entry into searchTwitter()
for(i in 1:length(coordinates$lat)){
coordinates$search.twitter.entry[i]<-toString(c(coordinates$lat[i],
coordinates$long[i],radius))
}
# take out spaces in the string
coordinates$search.twitter.entry<-gsub(" ","", coordinates$search.twitter.entry ,
fixed=TRUE)

#Search twitter at each location, check how many tweets and put into dataframe
for(i in 1:length(coordinates$lat)){
coordinates$number.of.tweets[i]<-
 length(searchTwitter(searchString=searchtext,n=1000,geocode=coordinates$search.twitter.entry[i]))
}
#making the US map
all_states <- map_data("state")
#plot all points on the map
p <- ggplot()
p <- p + geom_polygon( data=all_states, aes(x=long, y=lat, group = group),colour="grey",     fill=NA )

p<-p + geom_point( data=coordinates, aes(x=long, y=lat,color=number.of.tweets
                                     )) + scale_size(name="# of tweets")
p
}
# Example
searchTwitter("dolphin",15,"10mi") 420 error enhance your calm Error in function (type, msg, asError = TRUE) : transfer closed with 43756 bytes remaining to read
-------------------------------------------------------------------------------------------------------
triplot #First draw the empty ternary diagram:
plot(NA,NA,xlim=c(0,1),ylim=c(0,sqrt(3)/2),asp=1,bty="n",axes=F,xlab="",ylab="")
segments(0,0,0.5,sqrt(3)/2)
segments(0.5,sqrt(3)/2,1,0)
segments(1,0,0,0)

text(0,0,labels="1, 2 or 3",pos=1)
text(1,0,labels="6",pos=1)
text(0.5,sqrt(3)/2,labels="4 or 5",pos=3)

#The following function is for transforming ternary coordinates into cartesian coordinates:
tern2cart <- function(coord){
    coord[1]->x
    coord[2]->y
    coord[3]->z
    x+y+z->tot
    x/tot -> x
    y/tot -> y
    z/tot -> z
    (2*y + z)/(2*(x+y+z)) -> x1
    sqrt(3)*z/(2*(x+y+z)) -> y1
    return(c(x1,y1))
    }

#Here are your zones:
green.zone<-matrix(c(0,0,100,40,0,60,0,40,60,0,0,100),nrow=4,byrow=TRUE)
blue.zone<-matrix(c(30,10,60,30,40,30,0,70,30,0,40,60,30,10,60),nrow=5,byrow=TRUE)
purple.zone<-matrix(c(90,0,10,100,0,0,30,70,0,30,40,30,50,40,10,90,0,10),nrow=6,byrow=TRUE)
red.zone<-matrix(c(30,40,30,30,70,0,0,100,0,0,70,30,30,40,30),nrow=5,byrow=TRUE)
yellow.zone<-matrix(c(90,0,10,40,0,60,30,10,60,30,40,30,50,40,10,90,0,10),nrow=6,byrow=TRUE)

#Then transformed into cartesian coordinates:
t(apply(green.zone,1,tern2cart))->green
t(apply(blue.zone,1,tern2cart))->blue
t(apply(purple.zone,1,tern2cart))->purple
t(apply(red.zone,1,tern2cart))->red
t(apply(yellow.zone,1,tern2cart))->yellow

#And plotted:
polygon(green,col="green",border=NULL)
polygon(blue,col="blue",border=NULL)
polygon(purple,col="purple",border=NULL)
polygon(red,col="red",border=NULL)
polygon(yellow,col="yellow",border=NULL)

#And finally the grid:
a<-seq(0.9,0.1, by=-0.1)
b<-rep(0,9)
c<-seq(0.1,0.9,by=0.1)
grid<-data.frame(x=c(a, b, c, a, c, b),y=c(b, c, a, c, b, a),z=c(c, a, b, b, a, c))
t(apply(grid,1,tern2cart)) -> grid.tern
cbind(grid.tern[1:27,],grid.tern[28:54,])->grid
apply(grid,1,function(x){segments(x0=x[1],y0=x[2],x1=x[3],y1=x[4],lty=2,col="grey80")}) paste(seq(10,90,by=10),"%")->lab
text(grid.tern[9:1,],paste(lab,"\n(1, 2 or 3)"),col="grey80",cex=0.7, pos=2)
text(grid.tern[18:10,],paste(lab,"\n(4 or 5)"),col="grey80",cex=0.7, pos=4)
text(grid.tern[27:19,],paste(lab,"\n(6)"),col="grey80",cex=0.7, pos=1) df<-data.frame('1, 2 or 3'=c(10,33.3,50,100), '6'=c(0,33.3,50,0), '4 or 5'=c(90,33.3,0,0))
df
  X1..2.or.3   X6 X4.or.5
1       10.0  0.0    90.0
2       33.3 33.3    33.3
3       50.0 50.0     0.0
4      100.0  0.0     0.0

t(apply(df, 1, tern2cart)) -> df.tern
points(df.tern, pch="*", cex=3)
-------------------------------------------------------------------------------------------------------
#required function from www.menugget.blogspot.com
matrix.poly <- function(x, y, z=mat, n=NULL){
 if(missing(z)) stop("Must define matrix 'z'")
 if(missing(n)) stop("Must define at least 1 grid location 'n'")
 if(missing(x)) x <- seq(0,1,,dim(z)[1])
 if(missing(y)) y <- seq(0,1,,dim(z)[2])
 poly <- vector(mode="list", length(n))
 for(i in seq(n)){
  ROW <- ((n[i]-1) %% dim(z)[1]) +1
  COL <- ((n[i]-1) %/% dim(z)[1]) +1

  dist.left <- (x[ROW]-x[ROW-1])/2
  dist.right <- (x[ROW+1]-x[ROW])/2
  if(ROW==1) dist.left <- dist.right
  if(ROW==dim(z)[1]) dist.right <- dist.left

  dist.down <- (y[COL]-y[COL-1])/2
  dist.up <- (y[COL+1]-y[COL])/2
  if(COL==1) dist.down <- dist.up
  if(COL==dim(z)[2]) dist.up <- dist.down

  xs <- c(x[ROW]-dist.left, x[ROW]-dist.left, x[ROW]+dist.right, x[ROW]+dist.right)
  ys <- c(y[COL]-dist.down, y[COL]+dist.up, y[COL]+dist.up, y[COL]-dist.down)
  poly[[i]] <- data.frame(x=xs, y=ys)
 }
 return(poly)
}

#make vector of grids for hatching
incl <- which(over==1)

#make polygons for each grid for hatching
polys <- matrix.poly(1:12, 1:6, z=over, n=incl)

    #plot
png("hatched_image.png")
image(1:12, 1:6, data)
for(i in seq(polys)){
    polygon(polys[[i]], density=10, angle=45, border=NA)
    polygon(polys[[i]], density=10, angle=-45, border=NA)
}
box()
dev.off() png("hatched_image2.png")
image(1:12, 1:6, data)
for(i in seq(polys)){
    xran <- range(polys[[i]]$x)
    yran <- range(polys[[i]]$y)
    xs <- seq(xran[1], xran[2],,5)
    ys <- seq(yran[1], yran[2],,5)
    grd <- expand.grid(xs,ys)
    points(grd, pch=19, cex=0.5)
}
box()
dev.off()
-------------------------------------------------------------------------------------------------------
pds <- fortify(sf_map, region = "ID") pds$OBJECTID <- as.integer(pds$OBJECTID) long lon geom_polygon geom_map library(maptools)
library(ggplot2)

## 'fortify' needs 'library(gpclib)' locally available
gpclibPermit()

## Import the shapefile
sf_map <- readShapeSpatial("sfzipcodes", ID = "ID")

## Import the data
my_data <- read.csv("my_data.csv")
my_data <- unique(my_data)

## Merge the data
sf_df <- fortify(sf_map, region='ID')
sf_df <- merge(sf_df, my_data, by.x="id", by.y="zip", all=FALSE)
sf_df <- sf_df[order(sf_df$group, sf_df$order), ]

## Make the map
p2 <- ggplot(sf_df, aes(x=long, y=lat, group=group, fill=vol))
p2 <- p2 + geom_polygon() + coord_equal()
p2 <- p2 + xlab("Basic Map with Default Elements")
p2
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(plyr)

test.data<-data.frame(factor=rep(c("small", "big"), each=9),
                      x=c(c(1,2,3,3,3,2,1,1,1), 2*c(1,2,3,3,3,2,1,1,1)),
                      y=c(c(1,1,1,2,3,3,3,2,1), 2*c(1,1,1,2,3,3,3,2,1)))

subset.test<-ddply(.data=test.data,
                   .variables="factor",
                   function(data){
                     data[c(2,3,4,5,6,2),]})

qplot(data=test.data,
      x=x,
      y=y,
      geom="polygon",
      facets=~factor)+
        geom_polygon(data=subset.test,
                     fill=I("red"))
-------------------------------------------------------------------------------------------------------
polygon(c(0,x1, xpos, x2), c(0, y1, ypos, y2), border="red", col="black", lwd=4) segments segments(c(0,0,x1,x2), c(0, 0, y1, y2), c(x1,x2,xpos,xpos), c(y1,y2,ypos,ypos))
-------------------------------------------------------------------------------------------------------
ordiellipse() xy ordiellipse2 <- 
function (ord, groups, display = "sites", kind = c("sd", "se"),
        conf, draw = c("lines", "polygon", "none"),
        w = weights(ord, display), col = NULL, alpha = 127,
        show.groups, label = FALSE,  ...)
{
    weights.default <- function(object, ...) NULL
    kind <- match.arg(kind)
    draw <- match.arg(draw)
    pts <- scores(ord, display = display, ...)
    ## ordiellipse only works with 2D data (2 columns)
    pts <- as.matrix(pts)
    if (ncol(pts) > 2)
        pts <- pts[ , 1:2, drop = FALSE]
    if (ncol(pts) < 2)
        stop("ordiellipse needs two dimensions")
    w <- eval(w)
    if (length(w) == 1)
        w <- rep(1, nrow(pts))
    if (is.null(w))
        w <- rep(1, nrow(pts))
    ## make semitransparent fill
    if (draw == "polygon" && !is.null(col))
        col <- rgb(t(col2rgb(col)), alpha = alpha, maxColorValue = 255)
    if (!missing(show.groups)) {
        take <- groups %in% show.groups
        pts <- pts[take, , drop = FALSE]
        groups <- groups[take]
        w <- w[take]
    }
    out <- seq(along = groups)
    inds <- names(table(groups))
    res <- list()
    if (label)
        cntrs <- names <- NULL
    ## Remove NA scores
    kk <- complete.cases(pts)
    for (is in inds) {
        gr <- out[groups == is & kk]
        if (length(gr) > 2) {
            X <- pts[gr, ]
            W <- w[gr]
            mat <- cov.wt(X, W)
            if (kind == "se")
                mat$cov <- mat$cov/mat$n.obs
            if (missing(conf))
                t <- 1
            else t <- sqrt(qchisq(conf, 2))
            xy <- vegan:::veganCovEllipse(mat$cov, mat$center, t)
            if (draw == "lines")
                vegan:::ordiArgAbsorber(xy, FUN = lines,
                        col = if(is.null(col)) par("fg") else col,
                        ...)

            else if (draw == "polygon") 
                vegan:::ordiArgAbsorber(xy[, 1], xy[, 2], col = col, FUN = polygon,
                        ...)

            if (label && draw != "none") {
                cntrs <- rbind(cntrs, mat$center)
                names <- c(names, is)
            }
            mat$scale <- t
            mat$xy <- xy   # this is the only substantive change I made
            res[[is]] <- mat
        }
    }
    if (label && draw != "none") {
        if (draw == "lines")
            vegan:::ordiArgAbsorber(cntrs[,1], cntrs[,2], labels=names, col = col,  
                    FUN = text, ...)
    else 
        vegan:::ordiArgAbsorber(cntrs, labels = names, col = NULL,
                FUN = ordilabel, ...)
    }
    class(res) <- "ordiellipse"
    invisible(res)
} stats draw = "none", because you'll want to play with stats<-with(dat.fac, ordiellipse2(ord, Site_TP, kind = "se", conf = 0.95, draw = "none")) xy names(stats[[1]])
[1] "cov"    "center" "n.obs"  "wt"     "scale"  "xy" polygon() xy matrix data.frame polygon() col lwd xy lapply() data.frame NA xy.mat <- t(as.data.frame(lapply(stats, function(x){
            t(rbind(x$xy, NA))
        }))) plot(ord, display = "sites", type = "n")
polygon(xy.mat[, 1], xy.mat[, 2], col = c(rep("#0000ff20", 5), rep("#ff000030", 5)), border = c(rep("blue", 5), rep("red", 5))) polygon()
-------------------------------------------------------------------------------------------------------
library(ggplot2)

ids <- letters[1:2]

# IDs and values to use for fill colour
values <- data.frame(
  id = ids,
  value = c(4,5)
)

# Polygon position
positions <- data.frame(
  id = rep(ids, each = 10),
  #     shape      hole         shape        hole
  x = c(1,4,4,1,1, 2,2,3,3,2,   5,10,10,5,5, 6,6,9,9,6),
  y = c(1,1,4,4,1, 2,3,3,2,2,   5,5,10,10,5, 6,9,9,6,6)
)

# Merge positions and values
datapoly <- merge(values, positions, by=c("id"))

ggplot(datapoly, aes(x=x, y=y)) + 
  geom_polygon(aes(group=id, fill=factor(value))) +
  scale_fill_discrete("Key")
-------------------------------------------------------------------------------------------------------
radarchart require(fmsb)
x = c(rep(4.5,7),rep(0,7), 
      3.34, 3.28, 1.37, 1.12, 3.52, 4.07, 3.66)
a = as.data.frame(matrix(x,nrow=3, ncol=7,byrow=T))
radarchart(a, axistype = 4, seg = 3, cglty = 3, 
           pty = 32, cglcol = 1, plwd = 3, pcol = 1, axislabcol = 1,
           labels = seq(from = min(x), to = max(x), length = 4)) radarchart = function (df, axistype = 0, seg = 4, pty = 16, pcol = 1:8, plty = 1:6, 
          plwd = 1, cglty = 3, cglwd = 1, cglcol = "navy", axislabcol = "blue", 
          title = "", maxmin = TRUE, na.itp = TRUE, labels = NULL, ...) 
{
  if (!is.data.frame(df)) {
    cat("The data must be given as dataframe.\n")
    return()
  }
  if ((n <- length(df)) < 3) 
    return()
  if (maxmin == FALSE) {
    dfmax <- apply(df, 2, max)
    dfmin <- apply(df, 2, min)
    df <- rbind(dfmax, dfmin, df)
  }
  plot(c(-1.2, 1.2), c(-1.2, 1.2), type = "n", frame.plot = FALSE, 
       axes = FALSE, xlab = "", ylab = "", main = title, asp = 1, 
       ...)
  theta <- seq(90, 450, length = n + 1) * pi/180
  theta <- theta[1:n]
  xx <- cos(theta)
  yy <- sin(theta)
  for (i in 0:seg) {
    polygon(xx * (i + 1)/(seg + 1), yy * (i + 1)/(seg + 1), lty = cglty, lwd = cglwd, border = cglcol)
    if (axistype == 1 | axistype == 3) 
     ## Changes by me  
     if(is.null(labels)) labels = paste(i/seg * 100, 
                                         "(%)")
      text(-0.05, (i + 1)/(seg + 1), labels[i+1], col = axislabcol)
    if (axistype == 4 | axistype == 5) 
      ## Changes by me
      if(is.null(labels)) labels = sprintf("%3.2f", i/seg)
      text(-0.05, (i + 1)/(seg + 1), labels[i+1], 
           col = axislabcol)
  }
  arrows(xx/(seg + 1), yy/(seg + 1), xx * 1, yy * 1, lwd = cglwd, 
         lty = cglty, length = 0, col = cglcol)
  if (axistype == 2 | axistype == 3 | axistype == 5) {
    text(xx[1:n], yy[1:n], df[1, 1:n], col = axislabcol)
  }
  text(xx * 1.2, yy * 1.2, colnames(df))
  series <- length(df[[1]])
  if (length(pty) < (series - 2)) {
    ptys <- rep(pty, series - 2)
    pcols <- rep(pcol, series - 2)
    pltys <- rep(plty, series - 2)
    plwds <- rep(plwd, series - 2)
  }
  else {
    ptys <- pty
    pcols <- pcol
    pltys <- plty
    plwds <- plwd
  }
  for (i in 3:series) {
    xxs <- xx
    yys <- yy
    scale <- 1/(seg + 1) + (df[i, ] - df[2, ])/(df[1, ] - 
      df[2, ]) * seg/(seg + 1)
    if (sum(!is.na(df[i, ])) < 3) {
      cat(sprintf("[DATA NOT ENOUGH] at %d\n%g\n", i, df[i, 
                                                         ]))
    }
    else {
      for (j in 1:n) {
        if (is.na(df[i, j])) {
          if (na.itp) {
            left <- ifelse(j > 1, j - 1, n)
            while (is.na(df[i, left])) {
              left <- ifelse(left > 1, left - 1, n)
            }
            right <- ifelse(j < n, j + 1, 1)
            while (is.na(df[i, right])) {
              right <- ifelse(right < n, right + 1, 1)
            }
            xxleft <- xx[left] * (1/(seg + 1) + (df[i, 
                                                    left] - df[2, left])/(df[1, left] - df[2, 
                                                                                           left]) * seg/(seg + 1))
            yyleft <- yy[left] * (1/(seg + 1) + (df[i, 
                                                    left] - df[2, left])/(df[1, left] - df[2, 
                                                                                           left]) * seg/(seg + 1))
            xxright <- xx[right] * (1/(seg + 1) + (df[i, 
                                                      right] - df[2, right])/(df[1, right] - 
                                                        df[2, right]) * seg/(seg + 1))
            yyright <- yy[right] * (1/(seg + 1) + (df[i, 
                                                      right] - df[2, right])/(df[1, right] - 
                                                        df[2, right]) * seg/(seg + 1))
            if (xxleft > xxright) {
              xxtmp <- xxleft
              yytmp <- yyleft
              xxleft <- xxright
              yyleft <- yyright
              xxright <- xxtmp
              yyright <- yytmp
            }
            xxs[j] <- xx[j] * (yyleft * xxright - yyright * 
              xxleft)/(yy[j] * (xxright - xxleft) - xx[j] * 
              (yyright - yyleft))
            yys[j] <- (yy[j]/xx[j]) * xxs[j]
          }
          else {
            xxs[j] <- 0
            yys[j] <- 0
          }
        }
        else {
          xxs[j] <- xx[j] * (1/(seg + 1) + (df[i, j] - 
            df[2, j])/(df[1, j] - df[2, j]) * seg/(seg + 
            1))
          yys[j] <- yy[j] * (1/(seg + 1) + (df[i, j] - 
            df[2, j])/(df[1, j] - df[2, j]) * seg/(seg + 
            1))
        }
      }
      polygon(xxs, yys, lty = pltys[i - 2], lwd = plwds[i - 2], border = pcols[i - 2])
      points(xx * scale, yy * scale, pch = ptys[i - 2], 
             col = pcols[i - 2])
    }
  }
}
-------------------------------------------------------------------------------------------------------
ggplot(datapoly, aes(x=x, y=y)) +
  geom_polygon(aes(group=id, fill=factor(value))) +
  scale_fill_discrete("Key")
-------------------------------------------------------------------------------------------------------
library(plyr2)
map.shp2 <- ddply(map.shp, .(piece), function(x)rbind(x, map.shp[1, ]))
ggplot(data=map.shp2) + geom_polygon(aes(x=long,y=lat))
-------------------------------------------------------------------------------------------------------
p <- p + geom_polygon(data = eq.df, aes(long, lat, group=group, fill=MAXVALUE)) for (i in seq(9, 1, -1)) {
    p <- p + geom_polygon(data = eq.df[eq.df$MAXVALUE==sprintf("%d", i),], aes(long, lat, group=group, fill=MAXVALUE))
}
-------------------------------------------------------------------------------------------------------
if (require("maps")) { 
world <- map_data("world") 
mid_range <- function(x) mean(range(x)) 
library(plyr) 
ggplot(world, aes(long, lat)) + 
   geom_polygon( aes(group = group), fill = "green", colour = "red")+
   ylim(c(-2, 1 )) + xlim( c(-93,-88) ) }
-------------------------------------------------------------------------------------------------------
library(grid)
pushViewport(
  viewport( x=unit(0.1,'npc'), y=unit(0.1,'npc'), width=unit(0.2,'npc'),
    height=unit(0.2,'npc'))
)

d2 <- ggplot(measurements, aes(long, lat)) +
  geom_polygon(data = allworld, xlim = c(-50, 100), aes(x = long, y = lat, group = group), colour = "grey70", fill = "grey70") +
 geom_point(size = 0.7, shape = 8) + ylim(c(-2, 1 )) + xlim( c(-93,-88) )

print(d2, newpage=FALSE)
-------------------------------------------------------------------------------------------------------
library(ggplot2)
states <- map_data("state")
var <- data.frame(table(states$region))
states$variable <- var$Freq[match(states$region,var$Var1)]
map <- ggplot(states, aes(x=long, y=lat,fill=variable,group=group)) + geom_polygon()
map + scale_fill_gradient(low='white', high='grey20') gs.pal <- colorRampPalette(c("#FFFFFF","#000000"),bias=.1,space="rgb") x <- rnorm(100)
dat <- data.frame(cbind(x))
dat$fac <- as.factor(sort(rep(1:5,20)))
dat$y <- x * as.numeric(dat$fac) scale_* _manual scale_colour_manual scale_fill_manual ggplot(dat,aes(x=x,y=y,colour=fac))+geom_point()+scale_colour_manual(values=gs.pal(5))
-------------------------------------------------------------------------------------------------------
UScensus2010cdp UScensus2000cpd fortify.SpatialPolygonsDataFrame row.names ggplot2:::fortify.SpatialPolygonsDataFrame 

function (model, data, region = NULL, ...) 
{
    attr <- as.data.frame(model)
    if (is.null(region)) {
        region <- names(attr)[1]
        message("Using ", region, " to define regions.")
    }
    polys <- split(as.numeric(row.names(attr)), addNA(attr[, 
        region], TRUE))
    cp <- polygons(model)
    try_require(c("gpclib", "maptools"))
    unioned <- unionSpatialPolygons(cp, invert(polys))
    coords <- fortify(unioned)
    coords$order <- 1:nrow(coords)
    coords
} row.names(sf@data)
## [1] "california_586" "california_590" "california_616" place state name # as.character used to coerce from factor
lapply(lapply(sf@data[,c('place','state','name')], unique), as.character)
## $place
## [1] "67000"
## 
## $state
## [1] "06"
## 
## $name
## [1] "San Francisco" NA as.numeric(rownames(sf@data))
## [1] NA NA NA
## Warning message:
## NAs introduced by coercion NULL 1:nrow(sf@data) # rownames
sf@data[['place_id']] <- rownames(sf@data)
row.names(sf@data) <- NULL

# fortify
sf_ggplot <- fortify(sf, region = 'place_id')
# merge to add the original data
sf_ggplot_all <- merge(sf_ggplot, sf@data, by.x = 'id', by.y = 'place_id')
# very basic and uninteresting plot
ggplot(sf_ggplot_all,aes(x=long,y=lat, group = group)) + 
  geom_polygon(aes(fill =pop2000)) + 
  coord_map()
-------------------------------------------------------------------------------------------------------
#First subst the data and add the coordinates to make it shade to y = 0
shade <- rbind(c(0.12,0), subset(MyDF, x > 0.12), c(MyDF[nrow(MyDF), "X"], 0))

#Then use this new data.frame with geom_polygon
 p + geom_segment(aes(x=0.12,y=0,xend=0.12,yend=ytop)) +
     geom_polygon(data = shade, aes(x, y))
-------------------------------------------------------------------------------------------------------
plot(den2 <-density(absy2), type="l", axes=FALSE, xlab = "", ylab = "", main="", col="red")
lines(den1 <-density(absy1), col="blue") with( den1, polygon(x=c(0, x[x < 1],   rev(x[x<1]), 0), 
                    y=c(0, 0*x[x < 1], rev(y[x<1]), 0), col="red") )
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(cshapes)
world <- cshp(date=as.Date("2008-1-1"))
world.points <- fortify(world, region='COWCODE')
p <- ggplot(world.points, aes(long,lat,group=group)) + geom_polygon()
p
-------------------------------------------------------------------------------------------------------
polygon y98 = aggregate(gcdata$Pause.s. ~ hours, data=gcdata, FUN=q98)
y02 = aggregate(gcdata$Pause.s. ~ hours, data=gcdata, FUN=q02)
ymax = aggregate(gcdata$Pause.s. ~ hours, data=gcdata, FUN=max)
ymin = aggregate(gcdata$Pause.s. ~ hours, data=gcdata, FUN=min)
ymean = aggregate(gcdata$Pause.s. ~ hours, data=gcdata, FUN=mean)

x = ymean[,1]
y1 = cbind(y02[,2], ymean[,2], y98[,2])
y2 = cbind(ymin[,2], ymean[,2], ymax[,2])

plotAreaCI(x,y2, ylim=c(0,2), xlab="time", ylab="variable")
plotAreaCI(x,y1, ylim=c(0,2), poly.col="blue", add=TRUE) plotAreaCI(x,y2, ylim=c(0,2), xlab="time", ylab="variable", nice.x = TRUE)
plotAreaCI(x,y1, ylim=c(0,2), mean.lwd=2, poly.col="blue", add=TRUE) plotAreaCI plotAreaCI = function(x, y, add=FALSE, nice.x = FALSE,
                          xlim=NULL, ylim=NULL,
                          mean.col="black", mean.lwd=1.5,
                          poly.col="gray", poly.lty=3,
                          xlab=NULL, ylab=NULL, main="",
                          ...) {
      isFactorX = isClass("factor", x)
      if(isFactorX) {
        x.label = x
        x = as.numeric(x)
      }
      if(is.null(xlim)) xlim=range(x, na.rm=TRUE)
      if(is.null(ylim)) ylim=range(y, na.rm=TRUE)
      x.pol = c(x, rev(x), x[1])
      y.pol = c(y[,1], rev(y[,3]), y[,1][3])
      if(!add) {
        plot.new()
        plot.window(xlim=xlim, ylim=ylim, ...)
        if(!nice.x & isFactorX) {
          axis(1, at=x, labels=x.label)
        } else {
          xticks = axTicks(1)
          if(isFactorX) {
            xticks = xticks[xticks>=1]
            axis(1, at=xticks, labels=x.label[xticks])
          } else {
            axis(1)
          }
        }
            axis(2, las=1)
        box()
        title(xlab=xlab, ylab=ylab, main=main)
      }
      polygon(x.pol, y.pol, col=poly.col, lty=poly.lty)
      lines(x, y[,2], col=mean.col, lwd=mean.lwd)
      return(invisible())
    }
-------------------------------------------------------------------------------------------------------
plotAreaCorridor = function(x, y, col.poly1="lightgray", col.poly2="gray",...) {
   x.pol = c(x, rev(x), x[1])
   y.pol = c(y[,1], rev(y[,5]),y[,1][1])
   plot(x, y[,6]+1, type="n", ...) # ugly since type="n" does not work for factor
   polygon(x.pol, y.pol, col=col.poly1, lty=0)

   x.pol = c(x, rev(x), x[1])
   y.pol = c(y[,2], rev(y[,4]), y[,1][1])
   polygon(x.pol, y.pol, col=col.poly2, lty=0)

   lines(x, y[,3], col="blue") # median
   lines(x, y[,6], col="red")  # max

   return(invisible())
}
pause = gcdata$Pause.s.
hours = droplevels(cut(gcdata$date, breaks="hours")) # can I have 2 hours?
agg = aggregate(pause ~ hours, FUN=quantile, probs=c(5,20,50,80,95,100)/100)
x = agg$hours
ys = agg$pause
q99 <- function(x, ...) {  x <- quantile(x,probs=c(0.99)) }  
v99 = q99(gcdata$Pause.s.)
vmed = median(gcdata$Pause.s.)
plotAreaCorridor(x, ys,ylim=c(0,v99*1.5))
abline(h=vmed, col="lightblue")
abline(h=v99, col="grey")
label=paste("99%=",round(v99,digits=3),"s n=", length(gcdata$date),sep="")
text(x=30, y=v99, label, col="grey", pos=3)
title("NewPar Collection Activity")
-------------------------------------------------------------------------------------------------------
period.apply() endpoints() library(zoo)                                # for zoo objects
library(xts)                                # for period.apply

gcdata <- read.table("http://bernd.eckenfels.net/view/gc1001.ygc.csv",
                     header=TRUE, sep=",", dec=".")
timestamps <- gcdata$Timestamp + 
              as.POSIXct(strptime("2012-01-01 00:00:00", 
                         format="%Y-%m-%d %H:%M:%S"))
gcdatazoo <- zoo(gcdata[-1], order.by=timestamps)    # as zoo object zoo plotAreaCorridor <- function(x, y, col.poly1="lightgray", col.poly2="gray",...) {
    x.pol <- c(x, rev(x), x[1])
    y.pol <- c(y[,1], rev(y[,5]),y[,1][1])
    plot(x, y[,6]+1, type="n", ...) 
    polygon(x.pol, y.pol, col=col.poly1, lty=0)

    x.pol <- c(x, rev(x), x[1])
    y.pol <- c(y[,2], rev(y[,4]), y[,1][1])
    polygon(x.pol, y.pol, col=col.poly2, lty=0)

    lines(x, y[,3], col="blue") # median
    lines(x, y[,6], col="red")  # max

    invisible(NULL)
} agg <- period.apply(gcdatazoo[,"Pause.s."],               # to which data
                    INDEX=endpoints(gcdatazoo, "hours", k=2), # every 2 hours
                    FUN=function(x) quantile(x,               # what fun.
                                             probs=c(5,20,50,80,95,100)/100)) 

#v99 = q99(gcdata$Pause.s.)        # what is q99 ?
v99 <- mean(agg[,5])                  # mean of 95-th percentile?
plotAreaCorridor(index(agg),          # use time index as x axis
                 coredata(agg),       # and matrix part of zoo object as data
                 ylim=c(0,max(agg[,5])*1.5),
                 ylab="Quantiles of GC events",
                 main="NewPar Collection Activity")
abline(h=median(gcdatazoo[,"Pause.s."]), col="lightblue")
abline(h=v99, col="grey")
labeltxt <- paste("99%=",round(v99,digits=3),"s n=", nrow(gcdatazoo),sep="")
text(x=index(agg)[20], y=1.5*v99, labeltxt, col="grey", pos=3)  # or legend()
-------------------------------------------------------------------------------------------------------
0.5*pi 1.5*pi geom_polygon geom_path circleFun <- function(center=c(0,0), diameter=1, npoints=100, start=0, end=2){
  tt <- seq(start*pi, end*pi, length.out=npoints)
  data.frame(
    x = center[1] + diameter / 2 * cos(tt),
    y = center[2] + diameter / 2 * sin(tt)
  )
}

dat <- circleFun(c(1,-1), 2.3, start=0.5, end=1.5)
ggplot(dat,aes(x,y)) + 
  geom_polygon(color="black") + 
  ggtitle("half circle") +
  coord_equal()
-------------------------------------------------------------------------------------------------------
# Define the circle; add a point at the center if the 'pie slice' if the shape is to be filled
circleFun <- function(center=c(0,0), diameter=1, npoints=100, start=0, end=2, filled=TRUE){
  tt <- seq(start*pi, end*pi, length.out=npoints)
  df <- data.frame(
    x = center[1] + diameter / 2 * cos(tt),
    y = center[2] + diameter / 2 * sin(tt)
  )
  if(filled==TRUE) { #add a point at the center so the whole 'pie slice' is filled
    df <- rbind(df, center)
  }
  return(df)
}

#Define separate data frames for the filled and unfilled circle
quarterCircle <- circleFun(c(1,-1), diameter = 2.3, start=0., end=0.5, filled=TRUE)
fullCircle <- circleFun(c(1, -1), 2.3, start=0, end=2, filled=FALSE)

ggplot() + 
  geom_polygon(data=quarterCircle, aes(x,y), color="black", fill="black") + 
  geom_path(data=fullCircle, aes(x, y), color="black") +
  coord_equal()
-------------------------------------------------------------------------------------------------------
sales D = merge(all_states, state_data, by = "region")
D = D[with(D,order(D$group,D$order)),] 
D$sales= as.numeric(D$sales) # this is the important bit...

p = ggplot(data=D) + 
     geom_polygon(aes(x=long, y=lat, 
                      group = group, fill=sales), 
                  colour = "white" ) + # Do not use D$, by use the column name
     xlab("") + ylab("") + labs(title = "sales") + theme(legend.position="bottom")
p p + scale_fill_gradient2(midpoint = 20) D$sales sales p = p + ... +
-------------------------------------------------------------------------------------------------------
grid.polygon() grid.circle() "npc" "snpc" "npc" "snpc" ?unit vignette("grid") library(grid)

filledSemiCircle <- function(x_origin, y_origin, radius, fillcolor, top=TRUE) {
    theta <- seq(0, pi, length = 100)
    if(!top) theta <- theta + pi     ## To fill the bottom instead
    x <- unit(x_origin, "npc") + unit(cos(theta) * radius, "snpc")
    y <- unit(y_origin, "npc") + unit(sin(theta) * radius, "snpc")
    grid.polygon(x, y, gp = gpar(fill = fillcolor))
}

filledSemiCircle(0.5, 0.5, 0.25, "dodgerblue")
filledSemiCircle(0.5, 0.5, 0.25, "gold", top=FALSE)
grid.circle(x = .5, y=.5, r=.25,gp=gpar(lwd=10))
-------------------------------------------------------------------------------------------------------
filledArc <- function(x_origin, y_origin, radius, fillcolor, top=TRUE) {
    theta <- seq(0, pi/2, length = 100)
    if(!top) theta <- theta + pi     ## To fill the bottom instead
    x <- unit(x_origin, "npc") + unit(c(0, cos(theta) * radius, 0), "snpc")
    y <- unit(y_origin, "npc") + unit(c(0, sin(theta) * radius, 0), "snpc")
    grid.polygon(x, y, gp = gpar(fill = fillcolor))
}

filledArc(0.5, 0.5, 0.25, "lightgoldenrod")
filledArc(0.5, 0.5, 0.25, "blue", top=FALSE)
grid.circle(x = .5, y=.5, r=.25,gp=gpar(lwd=10)) filledArc2 <- function(x_origin, y_origin, radius, fillcolor, angle0, angle1) {
    theta.range <- seq(angle0, angle1, length = 100)
    x <- unit(x_origin, "npc") + unit(c(0, cos(theta.range) * radius, 0), "snpc")
    y <- unit(y_origin, "npc") + unit(c(0, sin(theta.range) * radius, 0), "snpc")
    grid.polygon(x, y, gp = gpar(fill = fillcolor))
}

filledArc2(0.5, 0.5, 0.25, "lightgoldenrod", 0,      pi/4)
filledArc2(0.5, 0.5, 0.25, "blue",           pi/4,   pi*(3/2) )
grid.circle(x = .5, y=.5, r=.25,gp=gpar(lwd=10))
-------------------------------------------------------------------------------------------------------
polygon() polygon(c(myd$xvar[20:40], myd$xvar[40:20]),c(myd$yvarL[20:40],
 myd$yvarU[40:20]), col="gray") points(myd$xvar,myd$yvar,pch=19,cex=.75,col="blue")
points(myd$xvar,myd$yvarL,col="gray", pch=19,cex=.5)
points(myd$xvar,myd$yvarU,col="gray", pch=19,cex=.5) index <- which(myd$xvar>=200 & myd$xvar<=400) polygon(c(myd$xvar[index], myd$xvar[rev(index)]),c(myd$yvarL[index], 
 myd$yvarU[rev(index)]), col="gray") lines(myd$xvar[index],myd$yvar[index],pch=19,cex=.75,col="blue",type="o")
points(myd$xvar,myd$yvarL,col="gray", pch=19,cex=.5)
points(myd$xvar,myd$yvarU,col="gray", pch=19,cex=.5)
-------------------------------------------------------------------------------------------------------
plot(myd$xvar,myd$yvar,pch=19,cex=.75,col="blue")
points(myd$xvar,myd$yvarL,col="gray", pch=19,cex=.5)
points(myd$xvar,myd$yvarU,col="gray", pch=19,cex=.5)
polygon(c(smyd$xvar[1:nrow(smyd)], smyd$xvar[nrow(smyd):1]), 
 c(smyd$yvarL[1:nrow(smyd)], smyd$yvarU[nrow(smyd):1]), col="gray", border = NA)
points(smyd$xvar,smyd$yvar,col="red", pch=19,cex=1.5)
lines (smyd$xvar,smyd$yvar,col="red", pch=19,cex=1.5)

polygon(c(smyd1$xvar[1:nrow(smyd1)], smyd1$xvar[nrow(smyd1):1]),
c(smyd1$yvarL[1:nrow(smyd1)], smyd1$yvarU[nrow(smyd1):1]), col="yellow", border = NA)
points(smyd1$xvar,smyd1$yvar,col="green4", pch=19,cex=1.5)
lines (smyd1$xvar,smyd1$yvar,col="green4", pch=19,cex=1.5)
-------------------------------------------------------------------------------------------------------
plot.stacked plot.stacked <- function(x,y, ylab="", xlab="", ncol=1, xlim=range(x, na.rm=T), ylim=c(0, 1.2*max(rowSums(y), na.rm=T)), border = NULL, col=rainbow(length(y[1,]))){

    plot(x,y[,1], ylab=ylab, xlab=xlab, ylim=ylim, xaxs="i", yaxs="i", xlim=xlim, t="n")
    bottom=0*y[,1]
    for(i in 1:length(y[1,])){
        top=rowSums(as.matrix(y[,1:i]))
        polygon(c(x, rev(x)), c(top, rev(bottom)), border=border, col=col[i])
        bottom=top
    }
    abline(h=seq(0,200000, 10000), lty=3, col="grey")
    legend("topleft", rev(colnames(y)), ncol=ncol, inset = 0, fill=rev(col), bty="0", bg="white", cex=0.8, col=col)
    box()
} set.seed(1)
m <- 500
n <- 15
x <- seq(m)
y <- matrix(0, nrow=m, ncol=n)
colnames(y) <- seq(n)
for(i in seq(ncol(y))){
    mu <- runif(1, min=0.25*m, max=0.75*m)
    SD <- runif(1, min=5, max=30)
    TMP <- rnorm(1000, mean=mu, sd=SD)
    HIST <- hist(TMP, breaks=c(0,x), plot=FALSE)
    fit <- smooth.spline(HIST$counts ~ HIST$mids)
    y[,i] <- fit$y
}

    plot.stacked(x,y) plot.stream library(devtools)
source_url('https://gist.github.com/menugget/7864454/raw/f698da873766347d837865eecfa726cdf52a6c40/plot.stream.4.R')

set.seed(1)
m <- 500
n <- 50
x <- seq(m)
y <- matrix(0, nrow=m, ncol=n)
colnames(y) <- seq(n)
for(i in seq(ncol(y))){
    mu <- runif(1, min=0.25*m, max=0.75*m)
    SD <- runif(1, min=5, max=30)
    TMP <- rnorm(1000, mean=mu, sd=SD)
    HIST <- hist(TMP, breaks=c(0,x), plot=FALSE)
    fit <- smooth.spline(HIST$counts ~ HIST$mids)
    y[,i] <- fit$y
}
y <- replace(y, y<0.01, 0)

#order by when 1st value occurs
ord <- order(apply(y, 2, function(r) min(which(r>0))))
y2 <- y[, ord]
COLS <- rainbow(ncol(y2))

png("stream.png", res=400, units="in", width=12, height=4)
par(mar=c(0,0,0,0), bty="n")
plot.stream(x,y2, axes=FALSE, xlim=c(100, 400), xaxs="i", center=TRUE, spar=0.2, frac.rand=0.1, col=COLS, border=1, lwd=0.1)
dev.off() #plot.stream makes a "stream plot" where each y series is plotted 
#as stacked filled polygons on alternating sides of a baseline.
#
#Arguments include:
#'x' - a vector of values
#'y' - a matrix of data series (columns) corresponding to x
#'order.method' = c("as.is", "max", "first") 
#  "as.is" - plot in order of y column
#  "max" - plot in order of when each y series reaches maximum value
#  "first" - plot in order of when each y series first value > 0
#'center' - if TRUE, the stacked polygons will be centered so that the middle,
#i.e. baseline ("g0"), of the stream is approximately equal to zero. 
#Centering is done before the addition of random wiggle to the baseline. 
#'frac.rand' - fraction of the overall data "stream" range used to define the range of
#random wiggle (uniform distrubution) to be added to the baseline 'g0'
#'spar' - setting for smooth.spline function to make a smoothed version of baseline "g0"
#'col' - fill colors for polygons corresponding to y columns (will recycle)
#'border' - border colors for polygons corresponding to y columns (will recycle) (see ?polygon for details)
#'lwd' - border line width for polygons corresponding to y columns (will recycle)
#'...' - other plot arguments
plot.stream <- function(
    x, y, 
    order.method = "as.is", frac.rand=0.1, spar=0.2,
    center=TRUE,
    ylab="", xlab="",  
    border = NULL, lwd=1, 
    col=rainbow(length(y[1,])),
    ylim=NULL, 
    ...
){

if(sum(y < 0) > 0) error("y cannot contain negative numbers")

if(is.null(border)) border <- par("fg")
border <- as.vector(matrix(border, nrow=ncol(y), ncol=1))
col <- as.vector(matrix(col, nrow=ncol(y), ncol=1))
lwd <- as.vector(matrix(lwd, nrow=ncol(y), ncol=1))

if(order.method == "max") {
    ord <- order(apply(y, 2, which.max))
    y <- y[, ord]
    col <- col[ord]
    border <- border[ord]
}

if(order.method == "first") {
    ord <- order(apply(y, 2, function(x) min(which(r>0))))
    y <- y[, ord]
    col <- col[ord]
    border <- border[ord]
}

bottom.old <- x*0
top.old <- x*0
polys <- vector(mode="list", ncol(y))
for(i in seq(polys)){
    if(i %% 2 == 1){ #if odd
        top.new <- top.old + y[,i]
        polys[[i]] <- list(x=c(x, rev(x)), y=c(top.old, rev(top.new)))
        top.old <- top.new
    }
    if(i %% 2 == 0){ #if even
        bottom.new <- bottom.old - y[,i]
        polys[[i]] <- list(x=c(x, rev(x)), y=c(bottom.old, rev(bottom.new)))
        bottom.old <- bottom.new
    }
}

ylim.tmp <- range(sapply(polys, function(x) range(x$y, na.rm=TRUE)), na.rm=TRUE)
outer.lims <- sapply(polys, function(r) rev(r$y[(length(r$y)/2+1):length(r$y)]))
mid <- apply(outer.lims, 1, function(r) mean(c(max(r, na.rm=TRUE), min(r, na.rm=TRUE)), na.rm=TRUE))

#center and wiggle
if(center) {
    g0 <- -mid + runif(length(x), min=frac.rand*ylim.tmp[1], max=frac.rand*ylim.tmp[2])
} else {
    g0 <- runif(length(x), min=frac.rand*ylim.tmp[1], max=frac.rand*ylim.tmp[2])
}

fit <- smooth.spline(g0 ~ x, spar=spar)

for(i in seq(polys)){
    polys[[i]]$y <- polys[[i]]$y + c(fit$y, rev(fit$y))
}

if(is.null(ylim)) ylim <- range(sapply(polys, function(x) range(x$y, na.rm=TRUE)), na.rm=TRUE)
plot(x,y[,1], ylab=ylab, xlab=xlab, ylim=ylim, t="n", ...)
for(i in seq(polys)){
    polygon(polys[[i]], border=border[i], col=col[i], lwd=lwd[i])
}

}
-------------------------------------------------------------------------------------------------------
library(ggplot2) # using version 0.9.2.1
library(maps)

# load us map data
all_states <- map_data("state")

# start a ggplot. it won't plot til we type p
p <- ggplot()  

# add U.S. states outlines to ggplot
p <- p + geom_polygon(data=all_states, aes(x=long, y=lat, group = group),
     colour="grey", fill="white" )

# add total Population
p <- p + geom_point(data=df1, aes(x=longitude, y=latitude, size = totalPop), 
     colour="#b5e521")

# add sub Population as separate layer with smaller points at same long,lat
p <- p + geom_point(data=df1, aes(x=longitude, y=latitude, size = subPop), 
     colour="#00a3e8")

# change name of legend to generic word "Population"
p <- p + guides(size=guide_legend(title="Population"))

# display plot
p get_map() ggmap require(ggmap)
require(mapproj)
map <- get_map(location = 'united states', zoom = 3, maptype = "terrain", 
       source = "google")
p <- ggmap(map)
-------------------------------------------------------------------------------------------------------
ggmap s12 <- get_map(maptype = "satellite", zoom = 12) 
ggmap(s12, base_layer=ggplot(aes(x=lon,y=lat), data=zips),
      extent = "normal", maprange=FALSE) +
    geom_polygon(aes(x = lon, y = lat, group = plotOrder),
                 data = zips, colour = NA, fill = "red", alpha = .5) +
    geom_path(aes(x = lon, y = lat, group = plotOrder),
              data = zips, colour = "white", alpha = .7, size = .4) +
    coord_map(projection="mercator", 
              xlim=c(attr(s12, "bb")$ll.lon, attr(s12, "bb")$ur.lon),
              ylim=c(attr(s12, "bb")$ll.lat, attr(s12, "bb")$ur.lat)) +
    theme_nothing()
-------------------------------------------------------------------------------------------------------
ld polygon par()$cin par()$ps par()$usr ld plot(1)
legendLabel<-c("t\nu ","tu","wh","trr\nni")
ld <- legend("top",legend=legendLabel,horiz=TRUE,fill=c("red","blue","gray","black"), bty="n")

CIN <- par()$cin
PS <- par()$ps
USR <- par()$usr
CIN.USR <- c((CIN[1]/72*PS)/(USR[2]-USR[1]), (CIN[2]/72*PS)/(USR[4]-USR[3]))

xs <- c(ld$text$x[1], ld$text$x[1], ld$text$x[length(ld$text$x)], ld$text$x[length(ld$text$x)])
ys <- c(ld$text$y[1], ld$text$y[1], ld$text$y[length(ld$text$x)], ld$text$y[length(ld$text$x)])

polygon(
x = xs + c(-3*CIN.USR[1], -3*CIN.USR[1], 2*CIN.USR[1], 2*CIN.USR[1]), 
y = ys+c(-1*CIN.USR[2], 1*CIN.USR[2], 1*CIN.USR[2], -1*CIN.USR[2])
)
-------------------------------------------------------------------------------------------------------
bty="n" ld<-legend("top",legend=legendLabel, cex=0.65, fill=colorNames, horiz=TRUE,bty="n")
  height<-(ld$rect$top-ld$text$y[1])*2
  xs <- c(ld$rect$left, ld$rect$left, ld$rect$left+ld$rect$w, ld$rect$left+ld$rect$w)
  ys <- c(ld$rect$top, ld$rect$top-height, ld$rect$top-height, ld$rect$top)
  polygon(x = xs , y = ys)
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(plyr)
library(Hmisc)



df <- data.frame(x = rnorm(20), y = rnorm(20),z = sample(letters[1:5], 20, rep = T))
ggplot(df, aes(x, y, colour = z)) + geom_point()

find_hull <- function(df) {
    res.ch <- df[chull(df$x, df$y), ]
    res <- bezier(res.ch)
    res <- data.frame(x=res$x,y=res$y)
    res$z <- res$z
    res
  }
hulls <- ddply(df, "z", find_hull)
ggplot(df, aes(x, y, colour = z,fill = z)) +
  geom_point() + geom_polygon(data = hulls,alpha = 0.4)
-------------------------------------------------------------------------------------------------------
spline.poly testpts <- 
structure(list(x = c(4.9, 4.2, 4, 4.1, 4.4, 5.8, 5.8, 5.8, 5.8, 
5.5, 4.9, 3.2, 3.2, 3.3, 5.4, 5.4, 5.7, 6.4, 6.7, 6.7, 6, 4.8, 
3.6, 2.8, 3.5, 4.4, 5.1, 4, 3.7, 4.5, 4.9, 5.7), y = c(6.9, 6.2, 
5.3, 4.1, 3.1, 2.9, 2.9, 3.5, 4.2, 4.9, 5.1, 4.9, 4.9, 5.2, 6.9, 
6.9, 5.3, 3.8, 4.2, 5.6, 6.9, 5.8, 1.2, 2.5, 5.3, 6.4, 6.8, 7.6, 
6.9, 5.4, 4.8, 4.4)), .Names = c("x", "y")) plot(NA,xlim=c(0,10),ylim=c(0,10))
points(testpts,pch=19)
chuld <- lapply(testpts,"[",chull(testpts))
polygon(chuld,lty=2,border="gray")
polygon(spline.poly(as.matrix(as.data.frame(chuld)),100),border="red",lwd=2) alphahull # load the required library
library(alphahull)

plot(NA,xlim=c(0,10),ylim=c(0,10))
points(testpts,pch=19)
# remove duplicate points so the ahull function doesn't error out
testptsnodup <- lapply(testpts,"[",which(!duplicated(as.matrix(as.data.frame(testpts))))) ahull.obj <- ahull(testptsnodup,alpha=2)
plot(ahull.obj,add=TRUE,col="red",wpoints=FALSE)
-------------------------------------------------------------------------------------------------------
stackplot = function(data, ylim=NA, main=NA, colors=NA, xlab=NA, ylab=NA) {
  # stacked line plot
  if (is.na(ylim)) {
    ylim=c(0, max(rowSums(data, na.rm=T)))
  }
  if (is.na(colors)) {
    colors = c("green","red","lightgray","blue","orange","purple", "yellow")
  }
  xval = as.numeric(row.names(data))
  summary = rep(0, nrow(data))
  recent = summary

  # Create empty plot
  plot(c(-100), c(-100), xlim=c(min(xval, na.rm=T), max(xval, na.rm=T)), ylim=ylim, main=main, xlab=xlab, ylab=ylab)

  # One polygon per column
  cols = names(data)
  for (c in 1:length(cols)) {
    current = data[[cols[[c]]]]
    summary = summary + current
    polygon(
      x=c(xval, rev(xval)),
      y=c(summary, rev(recent)),
      col=colors[[c]]
    )
    recent = summary
  }
}
-------------------------------------------------------------------------------------------------------
fill geom_point Tot437 library(ggplot2)
library(rgdal)

africa <- readOGR("c:/test", layer = "Africa")
africa.map = fortify(africa, region="COUNTRY")

africa.points = read.table("c:/test/SPM-437-22Nov12.txt", header = TRUE, sep = ",")
names(africa.points)[which(names(africa.points) == 'Longitude')] <- 'long' # rename lat and long for consistency with shp file
names(africa.points)[which(names(africa.points) == 'Latitude')] <- 'lat'

ggplot(africa.map, aes(x = long, y = lat, group = group)) +
    geom_polygon(colour = "black", size = 1, fill = "white", aes(group = group)) +
    geom_point(data = africa.points, aes(x = long, y = lat, fill = Tot437, group = NULL), size = 4, shape = 21, colour = "black", size = 3) africa.map <- africa.map[africa.map$id == 'Madagascar', ]
africa.points <- africa.points[africa.points$Country == 'Madagascar', ]
ggplot(africa.map, aes(x = long, y = lat, group = group)) +
    geom_polygon(colour = "black", size = 1, fill = "white", aes(group = group)) +
    geom_point(data = africa.points, aes(x = long, y = lat, fill = Tot437, group = NULL), size = 2, shape = 21, colour = "black", size = 2)
-------------------------------------------------------------------------------------------------------
library(maptools)
library(rgdal)
library(ggplot2)
library(plyr)

fn='nhs_pct.kml'
nhs <- read.csv("nhs_dent_stat_pct.csv")

kml <- readOGR(fn, layer="Fusiontables folder") slot(kml, "polygons") <- lapply(slot(kml, "polygons"), checkPolygonsHoles)

## The rest more or less follows Hadley's tutorial 
kml.points = fortify(kml, region="Name")
kml.df = merge(kml.points, kml@data, by.x="id",by.y="Name",sort=FALSE)
kml.df <- merge(kml.df,nhs,by.x="id",by.y="PCT.ONS.CODE",sort=FALSE,all.x=T,all.y=F)

## Order matters for geom_path!
kml.df <- kml.df[order(kml.df$order),]

nhs.plot <- ggplot(kml.df, aes(long,lat,group=group,fill=A.30.Sep.2012)) + 
  geom_polygon() +
  geom_path(color="gray") +
  coord_equal() +
  scale_fill_gradient("The outcome") + 
    scale_x_continuous("") + scale_y_continuous("") +   theme_bw()
-------------------------------------------------------------------------------------------------------
panel.violin grid.polygon require(lattice) require(grid) panel.violin require(grid)
panel.violin2  <-  
    # snipped all the arguments and processing

       grid.polygon(x = c(dx.list[[i]] ), 
   # Notice I removed: ... ,rev(dx.list[[i]]) 
               y = c(2*dy.list[[i]]    ), default.units = "native", 
   # Removed: ...  , -rev(dy.list[[i]])
               name = trellis.grobname(identifier, type = "panel", 
                 group = group), gp = gpar(fill = col, col = border, 
                 lty = lty, lwd = lwd, alpha = alpha)) bwplot(voice.part ~ height, singer,
       panel = function(..., box.ratio) {
           panel.violin2(..., col = "transparent",
                        varwidth = FALSE, box.ratio = box.ratio)
           panel.bwplot(..., fill = NULL, box.ratio = .1)
       } ) rev(dx.list[[i]]) -rev(dy.list[[i]])
-------------------------------------------------------------------------------------------------------
library(grid)

## Set up plotting area with reasonable x-y limits
## and a "native" scale related to the scale of the data.
x <- -1:1
y <-  extendrange(c(myd$myears, myd2$myears))
dvp <- dataViewport(x, y, name = "figure")

grid.newpage()
pushViewport(dvp)

## Plot the central timeline
grid.lines(unit(0, "native"), unit(c(0,245), "native"),
           gp = gpar(col="dodgerblue"))

## Annotate LHS
grid.segments(x0=0.5, x1=0.47,
              y0=unit(c(0, myd$myears), "native"),
              y1=unit(c(0, myd$myears), "native"),
              gp=gpar(col="dodgerblue"))
grid.text(label=c(0, myd$myears), x=0.44, y=unit(c(0, myd$myears), "native"))
grid.text(label=myd$period, x=0.3, y=unit(myd$label, "native"),
          just=0, gp=gpar(col="dodgerblue", fontface="italic"))

## Annotate RHS
## Create a function that plots a pointer to the specified coordinate
pointer <- function(x, y, width=1) {
    grid.polygon(x = x + unit(width*(c(0, .1, .1)), "npc"),
                 y = y + unit(width*(c(0, .03, -.03)), "npc"), 
                 gp = gpar(fill="dodgerblue", col="blue", lwd=2))
}
## Call it once for each milestone
for(y in myd2$myears) {
    pointer(unit(.5, "npc"), y=unit(y, "native"), width=0.3)
}
## Or, if you just want blue line segments instead of those gaudy pointers:
## grid.segments(x0=0.5, x1=0.53,
##           y0=unit(c(myd2$myears), "native"),
##           y1=unit(c(myd2$myears), "native"), gp=gpar(col="dodgerblue"))

grid.text(label=myd2$event, x=0.55, y=unit(myd2$myears, "native"),
          just=0)
-------------------------------------------------------------------------------------------------------
my1 <- data.frame (company = rep(c("A", "B", "C"), each = 7), skillsDg = rep(c("Basic", "HighSc", "Undgd", "MAST", "PHD", "EXPD", "EXECT"), 3), number = c(200, 100, 40, 30, 10, 0, 0, 220, 110, 35, 10, 0, 4, 1, 140, 80, 120, 50, 52, 52, 3) )

my2 <- split(my1,my1$company) #split your dataframe into a list where each element is a company
# The next line create the layout
layout(matrix(1:(length(my2)+1), nrow=1), width=c(1,rep(4,length(my2))))
# Then we draw the x-axis:
par(mar=c(3,0,3,0))
plot(NA,axes=F, xlim=c(0,1),ylim=c(1,nlevels(my1$skillsDg)))
axis(side=4,tick=F,labels=unique(my1$skillsDg),
     at=seq_along(unique(my1$skillsDg)), las=2, line=-4)
# Then we apply a graphing function to each company:
lapply(my2,function(x){
    par(mar=c(3,0,3,0))
    plot(NA, xlim=c(-max(my1$number),max(my1$number)), 
             ylim=c(1,nlevels(my1$skillsDg)),axes=F)
    title(sub=x$company[1],line=1)
    abline(h=seq_along(x$skillsDg), col="grey80")
    polygon(x=c(x$number,rev(-1*x$number)), 
            y=c(seq_along(x$skillsDg),rev(seq_along(x$skillsDg))), 
            col=as.numeric(x$company))
    }) lapply layout(matrix(1:(length(my2)+1), nrow=1), width=c(1,rep(4,length(my2))))
par(mar=c(3,0,3,0))
plot(NA,axes=F, xlim=c(0,1),ylim=c(1,nlevels(my1$skillsDg)))
axis(side=4,tick=F,labels=unique(my1$skillsDg),
    at=seq_along(unique(my1$skillsDg)), las=2, line=-4)
lapply(my2,function(x){
    par(mar=c(3,0,3,0))
    plot(NA, xlim=c(-max(my1$number)-50,max(my1$number)+50), 
        ylim=c(1,nlevels(my1$skillsDg)),axes=F)
    title(sub=x$company[1],line=1)
    abline(h=seq_along(x$skillsDg), col="grey80")
    text(x=x$number+5, y=seq_along(x$skillsDg)+.1, label=x$number, pos=4)
    polygon(x=c(x$number,rev(-1*x$number)), 
        y=c(seq_along(x$skillsDg),rev(seq_along(x$skillsDg))), 
        col=as.numeric(x$company))
    })
-------------------------------------------------------------------------------------------------------
mylabd <- data.frame (company = rep(c("A", "B", "C"), each = 7),
                      skillsDg = rep(c("Basic", "HighSc", "Undgd", "MAST", "PHD", "EXPD", "EXECT"), 3),
                      number = c(200, 100, 40, 30, 10, 0, 0,
                                 220, 110, 35, 10, 0, 4, 1,
                                 140, 80, 120, 50, 52, 52, 3)
)



## to comapre we need o have the same scales for all organizations
nskills <- nlevels(mylabd$skillsDg)
ncompany <- nlevels(mylabd$company)
barYscale <- c(0,  nskills) * 1.05
barXscale <- c(0, max(mylabd$number) )* 1.05
## the global scene
vp <- plotViewport(c(5, 4, 4, 1),
                   yscale = barYscale,
                   layout = grid.layout(nrow=1,ncol=nbars))

pushViewport(vp)
grid.rect()
grid.yaxis(at=c(1:nlevels(mylabd$skillsDg)),label=unique(mylabd$skillsDg))
grid.grill()

## split data by companya
data.splitted <- split(mylabd,f=mylabd$company)
lapply(1:3,function(company){

  x <- data.splitted[[company]]
  vv <- x$number
  companyName <- unique(x$company)

  pushViewport(viewport(layout.pos.col=company,    
                        xscale = barXscale,
                        yscale = barYscale))
  grid.rect()
 # grid.xaxis(at= mean(x$number),label = companyName)
  grid.xaxis()
  grid.polygon(x  = unit.c(unit(0.5,'npc')-unit(vv/2,'native'),
                           unit(0.5,'npc')+unit(rev(vv)/2,'native')),
               y  = unit.c(unit(1:nmeasures,'native'),
                           unit(rev(1:nmeasures),'native')),
               gp=gpar(fill = rainbow(nmeasures)[company]))
  grid.polygon(x  = unit.c(unit(0.5,'npc')-unit(vv/2,'native'),
                           unit(0.5,'npc')+unit(rev(vv)/2,'native')),
               y  = unit.c(unit(1:nmeasures,'native'),
                           unit(rev(1:nmeasures),'native')),
               id = c(1:nmeasures,rev(1:nmeasures)),
               gp=gpar(fill = NA))

  grid.text( x = unit(0.5,'npc'),
             y = unit(0.5,'native'),
             label = unique(x$company))

  popViewport()

})

popViewport()
-------------------------------------------------------------------------------------------------------
set.seed(0815)
x <- 1:10
F <- runif(10,1,2) 
L <- runif(10,0,1)
U <- runif(10,2,3)

require(plotrix)
plotCI(x, F, ui=U, li=L) set.seed(0815)
df <- data.frame(x =1:10,
                 F =runif(10,1,2),
                 L =runif(10,0,1),
                 U =runif(10,2,3))

require(ggplot2)
ggplot(df, aes(x = x, y = F)) +
  geom_point(size = 4) +
  geom_errorbar(aes(ymax = U, ymin = L)) set.seed(1234)
x <- rnorm(20)
df <- data.frame(x = x,
                 y = x + rnorm(20))

plot(y ~ x, data = df)

# model
mod <- lm(y ~ x, data = df)

# predicts + interval
newx <- seq(min(df$x), max(df$x), length.out=100)
preds <- predict(mod, newdata = data.frame(x=newx), 
                 interval = 'confidence')

# plot
plot(y ~ x, data = df, type = 'n')
# add fill
polygon(c(rev(newx), newx), c(rev(preds[ ,3]), preds[ ,2]), col = 'grey80', border = NA)
# model
abline(mod)
# intervals
lines(newx, preds[ ,3], lty = 'dashed', col = 'red')
lines(newx, preds[ ,2], lty = 'dashed', col = 'red')
-------------------------------------------------------------------------------------------------------
plot() polygon() lines() set.seed(1234)
 df <- data.frame(x =1:10,
                 F =runif(10,1,2),
                 L =runif(10,0,1),
                 U =runif(10,2,3))


 plot(df$x, df$F, ylim = c(0,4), type = "l")
 #make polygon where coordinates start with lower limit and 
 # then upper limit in reverse order
 polygon(c(df$x,rev(df$x)),c(df$L,rev(df$U)),col = "grey75", border = FALSE)
 lines(df$x, df$F, lwd = 2)
 #add red lines on borders of polygon
 lines(df$x, df$U, col="red",lty=2)
 lines(df$x, df$L, col="red",lty=2) Lower <- c(0.418116841, 0.391011834, 0.393297710,
        0.366144073,0.569956636,0.224775521,0.599166016,0.512269587,
        0.531378573, 0.311448219, 0.392045751,0.153614913, 0.366684097,
        0.161100849,0.700274810,0.629714150, 0.661641288, 0.533404093,
        0.412427559, 0.432905333, 0.525306427,0.224292061,
        0.28893064,0.099543648, 0.342995605,0.086973739,0.289030388,
        0.081230826,0.164505624, -0.031290586,0.148383474,0.070517523,0.009686605,
        -0.052703529,0.475924192,0.253382210, 0.354011010,0.130295355,0.102253218,
        0.446598823,0.548330752,0.393985810,0.481691632,0.111811248,0.339626541,
        0.267831909,0.133460254,0.347996621,0.412472322,0.133671128,0.178969601,0.484070587,
        0.335833224,0.037258467, 0.141312363,0.361392799,0.129791998,
        0.283759439,0.333893418,0.569533076,0.385258093,0.356201955,0.481816148,
        0.531282473,0.273126565,0.267815691,0.138127486,0.008865700,0.018118398,0.080143484,
        0.117861634,0.073697418,0.230002398,0.105855042,0.262367348,0.217799352,0.289108011,
        0.161271889,0.219663224,0.306117717,0.538088622,0.320711912,0.264395149,0.396061543,
        0.397350946,0.151726970,0.048650180,0.131914718,0.076629840,0.425849394,
        0.068692279,0.155144797,0.137939059,0.301912657,-0.071415593,-0.030141781,0.119450922,
        0.312927614,0.231345972)

 Upper.limit <- c(0.6446223,0.6177311, 0.6034427, 0.5726503,
      0.7644718, 0.4585430, 0.8205418, 0.7154043,0.7370033,
      0.5285199, 0.5973728, 0.3764209, 0.5818298,
      0.3960867,0.8972357, 0.8370151, 0.8359921, 0.7449118,
      0.6152879, 0.6200704, 0.7041068, 0.4541011, 0.5222653,
      0.3472364, 0.5956551, 0.3068065, 0.5112895, 0.3081448,
      0.3745473, 0.1931089, 0.3890704, 0.3031025, 0.2472591,
      0.1976092, 0.6906118, 0.4736644, 0.5770463, 0.3528607,
      0.3307651, 0.6681629, 0.7476231, 0.5959025, 0.7128883,
      0.3451623, 0.5609742, 0.4739216, 0.3694883, 0.5609220,
      0.6343219, 0.3647751, 0.4247147, 0.6996334, 0.5562876,
      0.2586490, 0.3750040, 0.5922248, 0.3626322, 0.5243285,
      0.5548211, 0.7409648, 0.5820070, 0.5530232, 0.6863703,
      0.7206998, 0.4952387, 0.4993264, 0.3527727, 0.2203694,
      0.2583149, 0.3035342, 0.3462009, 0.3003602, 0.4506054,
      0.3359478, 0.4834151, 0.4391330, 0.5273411, 0.3947622,
      0.4133769, 0.5288060, 0.7492071, 0.5381701, 0.4825456,
      0.6121942, 0.6192227, 0.3784870, 0.2574025, 0.3704140,
      0.2945623, 0.6532694, 0.2697202, 0.3652230, 0.3696383,
      0.5268808, 0.1545602, 0.2221450, 0.3553377, 0.5204076,
      0.3550094)

  Fitted.values<- c(0.53136955, 0.50437146, 0.49837019,
  0.46939721, 0.66721423, 0.34165926, 0.70985388, 0.61383696,
  0.63419092, 0.41998407, 0.49470927, 0.26501789, 0.47425695,
  0.27859380, 0.79875525, 0.73336461, 0.74881668, 0.63915795,
  0.51385774, 0.52648789, 0.61470661, 0.33919656, 0.40559797,
  0.22339000, 0.46932536, 0.19689011, 0.40015996, 0.19468781,
  0.26952645, 0.08090917, 0.26872696, 0.18680999, 0.12847285,
  0.07245286, 0.58326799, 0.36352329, 0.46552867, 0.24157804,
  0.21650915, 0.55738088, 0.64797691, 0.49494416, 0.59728999,
  0.22848680, 0.45030036, 0.37087676, 0.25147426, 0.45445930,
  0.52339711, 0.24922310, 0.30184215, 0.59185198, 0.44606040,
  0.14795374, 0.25815819, 0.47680880, 0.24621212, 0.40404398,
  0.44435727, 0.65524894, 0.48363255, 0.45461258, 0.58409323,
  0.62599114, 0.38418264, 0.38357103, 0.24545011, 0.11461756,
  0.13821664, 0.19183886, 0.23203127, 0.18702881, 0.34030391,
  0.22090140, 0.37289121, 0.32846615, 0.40822456, 0.27801706,
  0.31652008, 0.41746184, 0.64364785, 0.42944100, 0.37347037,
  0.50412786, 0.50828681, 0.26510696, 0.15302635, 0.25116438,
  0.18559609, 0.53955941, 0.16920626, 0.26018389, 0.25378867,
  0.41439675, 0.04157232, 0.09600163, 0.23739430, 0.41666762,
  0.29317767) df2 <- data.frame(x=seq(length(Fitted.values)),
                    fit=Fitted.values,lwr=Lower,upr=Upper.limit)
 plot(fit~x,data=df2,ylim=range(c(df2$lwr,df2$upr)))
 #make polygon where coordinates start with lower limit and then upper limit in reverse order
 with(df2,polygon(c(x,rev(x)),c(lwr,rev(upr)),col = "grey75", border = FALSE))
 matlines(df2[,1],df2[,-1],
          lwd=c(2,1,1),
          lty=1,
          col=c("black","red","red"))
-------------------------------------------------------------------------------------------------------
plot(dnorm,-4,4,xlab="x",ylab="pdf")
xvals <- seq(-2,1,length=50)
dvals <- dnorm(xvals)
polygon(c(xvals,rev(xvals)),c(rep(0,50),rev(dvals)),col="gray")
-------------------------------------------------------------------------------------------------------
rgb() xx <- c(1:50)
 yy <- rnorm(50)
 n <- 50
 hline <- 0
plot (yy ~ xx, type="n", axes=FALSE, ann=FALSE)
text(x=xx,y=min(yy)+max(yy),labels='a')
polygon(c(xx[1], xx, xx[n]), c(min(yy), yy, min(yy)),    
        col=rgb(1, 0, 0,0.5), border=NA)
-------------------------------------------------------------------------------------------------------
image rasterImage locator type updateusr
-------------------------------------------------------------------------------------------------------
n<-50
x<-sample(40:70,n,rep=T)
y<-.7*x+rnorm(n,sd=5)
plot(x,y,xlim=c(20,90),ylim=c(0,80))
mylm<-lm(y~x)
abline(mylm,col="red")
newx<-seq(20,90)
prd<-predict(mylm,newdata=data.frame(x=newx),interval = c("confidence"), 
level = 0.90,type="response")
lines(newx,prd[,2],col="red",lty=2)
lines(newx,prd[,3],col="red",lty=2) x <- rnorm(15)
y <- x + rnorm(15)
new <- data.frame(x = seq(-3, 3, 0.5))

pred.w.clim <- predict(lm(y ~ x), new, interval="confidence")


# Just create a blank plot region with axes first. We'll add to this
plot(range(new$x), range(pred.w.clim), type = "n", ann = FALSE)


# For convenience
CI.U <- pred.w.clim[, "upr"]
CI.L <- pred.w.clim[, "lwr"]

# Create a 'loop' around the x values. Add values to 'close' the loop
X.Vec <- c(new$x, tail(new$x, 1), rev(new$x), new$x[1])

# Same for y values
Y.Vec <- c(CI.L, tail(CI.U, 1), rev(CI.U), CI.L[1])

# Use polygon() to create the enclosed shading area
# We are 'tracing' around the perimeter as created above
polygon(X.Vec, Y.Vec, col = "grey", border = NA)


# Use matlines() to plot the fitted line and CI's
# Add after the polygon above so the lines are visible
matlines(new$x, pred.w.clim, lty = c(1, 2, 2), type = "l", col =  
c("black", "red", "red"))
-------------------------------------------------------------------------------------------------------
lines() polygon() # sorry for my lame fake data
TotalPop <- 2000
m <- table(sample(0:12, TotalPop*.52, replace = TRUE))
f <- table(sample(0:12, TotalPop*.48, replace = TRUE))

# scale to make it density
m <- m / TotalPop
f <- f / TotalPop
# find appropriate x limits
xlim <- max(abs(pretty(c(m,f), n = 20))) * c(-1,1)
# open empty plot
plot(NULL, type = "n", xlim = xlim, ylim = c(0,13))

# females
polygon(c(0,rep(f, each = 2), 0), c(rep(0:13, each = 2)))
# males (negative to be on left)
polygon(c(0,rep(-m, each = 2), 0), c(rep(0:13, each = 2)))
-------------------------------------------------------------------------------------------------------
set.seed (123)
xvar <- round (rnorm (100, 54, 10), 0)
xyvar <- round (rnorm (100, 54, 10), 0)
myd <- data.frame (xvar, xyvar)
valut <- as.numeric (cut(c(myd$xvar,myd$xyvar), 12))
myd$xwt <- valut[1:100]
myd$xywt <- valut[101:200]
xy.pop <- data.frame (table (myd$xywt))
xx.pop <- data.frame (table (myd$xwt))


stickBoy <- function() {
  grid.circle(x=.5, y=.8, r=.1, gp=gpar(fill="red"))
  grid.lines(c(.5,.5), c(.7,.2)) # vertical line for body
  grid.lines(c(.5,.6), c(.6,.7)) # right arm
  grid.lines(c(.5,.4), c(.6,.7)) # left arm
  grid.lines(c(.5,.65), c(.2,0)) # right leg
  grid.lines(c(.5,.35), c(.2,0)) # left leg
  grid.lines(c(.5,.5), c(.7,.2)) # vertical line for body
  grid.text(x=.5,y=-0.3,label ='Male',
            gp =gpar(col='white',fontface=2,fontsize=32)) # vertical line for body
}

stickGirl <- function() {
  grid.circle(x=.5, y=.8, r=.1, gp=gpar(fill="blue"))
  grid.lines(c(.5,.5), c(.7,.2)) # vertical line for body
  grid.lines(c(.5,.6), c(.6,.7)) # right arm
  grid.lines(c(.5,.4), c(.6,.7)) # left arm
  grid.lines(c(.5,.65), c(.2,0)) # right leg
  grid.lines(c(.5,.35), c(.2,0)) # left leg
  grid.lines(c(.35,.65), c(0,0)) # horizontal  line for body
  grid.text(x=.5,y=-0.3,label ='Female',
            gp =gpar(col='white',fontface=2,fontsize=32)) # vertical line for body
}

xscale <- c(0, max(c(xx.pop$Freq,xy.pop$Freq)))* 5
levels <- nlevels(xy.pop$Var1)
barYscale<- xy.pop$Var1
vp <- plotViewport(c(5, 4, 4, 1),
                   yscale = range(0:levels)*1.05,
                   xscale =xscale)


pushViewport(vp)

grid.yaxis(at=c(1:levels))
pushViewport(viewport(width = unit(0.5, "npc"),just='right', 
                      xscale =rev(xscale)))
grid.xaxis()
popViewport()

pushViewport(viewport(width = unit(0.5, "npc"),just='left',
                      xscale = xscale))
grid.xaxis()
popViewport()

grid.grill(gp=gpar(fill=NA,col='white',lwd=3),
           h = unit(seq(0,levels), "native"))
grid.rect(gp=gpar(fill=rgb(0,0.2,1,0.5)),
          width = unit(0.5, "npc"),just='right')

grid.rect(gp=gpar(fill=rgb(1,0.2,0.3,0.5)),
          width = unit(0.5, "npc"),just=c('left'))

vv.xy <- xy.pop$Freq
vv.xx <- c(xx.pop$Freq,0)

grid.polygon(x  = unit.c(unit(0.5,'npc')-unit(vv.xy,'native'),
                         unit(0.5,'npc')+unit(rev(vv.xx),'native')),
             y  = unit.c(unit(1:levels,'native'),
                         unit(rev(1:levels),'native')),
             gp=gpar(fill=rgb(1,1,1,0.8),col='white'))

grid.grill(gp=gpar(fill=NA,col='white',lwd=3,alpha=0.8),
           h = unit(seq(0,levels), "native"))
popViewport()

## some fun here 
vp1 <- viewport(x=0.2, y=0.75, width=0.2, height=0.2,gp=gpar(lwd=2,col='white'),angle=30)
pushViewport(vp1)
stickBoy()
popViewport()
vp1 <- viewport(x=0.9, y=0.75, width=0.2, height=0.2,,gp=gpar(lwd=2,col='white'),angle=330)
pushViewport(vp1)
stickGirl()
popViewport()
-------------------------------------------------------------------------------------------------------
base scales library(scales)
xy.poly <- data.frame(Freq=c(xy.pop$Freq, rep(0,nrow(xy.pop))), 
                      Var1=c(xy.pop$Var1, rev(xy.pop$Var1)))
xx.poly <- data.frame(Freq=c(xx.pop$Freq, rep(0,nrow(xx.pop))), 
                      Var1=c(xx.pop$Var1, rev(xx.pop$Var1)))
xrange <- range(c(xy.poly$Freq, xx.poly$Freq))
yrange <- range(c(xy.poly$Var1, xx.poly$Var1))

par(mfcol=c(1,2))
par(mar=c(5,4,4,0))
plot(xy.poly,type="n", main="Men", xlab="", ylab="", xaxs="i", 
     xlim=rev(xrange), ylim=yrange, axes=FALSE)
rect(-1,0,100,100, col="blue")
abline(h=0:15, col="white", lty=3)
polygon(xy.poly, col=alpha("grey",0.6))
axis(1, at=seq(0,20,by=5))
axis(2, las=2)
box()

par(mar=c(5,0,4,4))
plot(xx.poly,type="n", main="Women", xaxs="i", xlab="", ylab="",
     xlim=xrange, ylim=yrange, axes=FALSE)
rect(-1,0,100,100, col="red")
abline(h=0:15, col="white", lty=3)
axis(1, at=seq(5,20,by=5))
axis(4, las=2)
polygon(xx.poly, col=alpha("grey",0.6))
box()
-------------------------------------------------------------------------------------------------------
require(fortunes)
 fortune("every question")

Lastly, by what we could call the 'Liaw-Baron principle', every question that can be 
asked has in fact  already been asked.
   -- Dirk Eddelbuettel (citing Andy Liaw's and Jonathan Baron's opinion on unique 
            questions on R-help)
      R-help (January 2006)

polygon(x= c(X[order(X)],    rev(X[order(X)]) ), # both x and y  go "out" in order; 
          y=c(L[order(X)], rev(U[order(X)])),  # and then come "back in reverse order
             col=rgb(1,0,0,0.3) )    # transparent pink.

> plot(X,Y, pch="+")
> abline(reg, col="red")
> polygon(x= c(X\[order(X)\], rev(X\[order(X)\]) ), y=c(L\[order(X)\],rev(U\[order(X)\])), col=rgb(1,0,0,0.3) )
-------------------------------------------------------------------------------------------------------
fortify str(lon.shape) region > str(lon.shape)
Formal class 'SpatialPolygonsDataFrame' [package "sp"] with 5 slots
  ..@ data       :'data.frame': 1 obs. of  7 variables:
  .. ..$ ons_label: chr "00AA"
  .. ..$ name     : chr "City of London"
  .. ..$ label    : chr "02AA"
  .. ..$ X_max    : num 533843
  .. ..$ y_max    : num 182198
  .. ..$ X_min    : num 0
  .. ..$ y_min    : num 0
  ..@ polygons   :List of 1
  .. ..$ :Formal class 'Polygons' [package "sp"] with 5 slots
  .. .. .. ..@ Polygons :List of 1
  .. .. .. .. ..$ :Formal class 'Polygon' [package "sp"] with 5 slots
  .. .. .. .. .. .. ..@ labpt  : num [1:2] 532464 181220
  .. .. .. .. .. .. ..@ area   : num 3151465
  .. .. .. .. .. .. ..@ hole   : logi FALSE
  .. .. .. .. .. .. ..@ ringDir: int 1
  .. .. .. .. .. .. ..@ coords : num [1:771, 1:2] 531027 531029 531036 531074 531107 ...
  .. .. .. ..@ plotOrder: int 1
  .. .. .. ..@ labpt    : num [1:2] 532464 181220
  .. .. .. ..@ ID       : chr "0"
  .. .. .. ..@ area     : num 3151465
  ..@ plotOrder  : int 1
  ..@ bbox       : num [1:2, 1:2] 530967 180404 533843 182198
  .. ..- attr(*, "dimnames")=List of 2
  .. .. ..$ : chr [1:2] "x" "y"
  .. .. ..$ : chr [1:2] "min" "max"
  ..@ proj4string:Formal class 'CRS' [package "sp"] with 1 slots
  .. .. ..@ projargs: chr "+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +units=m +no_defs" name lon.df <- fortify(lon.shape, region = "name") > head(lon.df)
      long      lat order  hole piece            group             id
1 531026.9 181611.1     1 FALSE     1 City of London.1 City of London
2 531028.5 181611.2     2 FALSE     1 City of London.1 City of London
3 531036.1 181611.5     3 FALSE     1 City of London.1 City of London
4 531074.0 181610.3     4 FALSE     1 City of London.1 City of London
5 531107.0 181609.3     5 FALSE     1 City of London.1 City of London
6 531117.1 181608.9     6 FALSE     1 City of London.1 City of London library(rgdal)
library(ggplot2)
library(rgeos)

shape.dir <- "c:/test/london" # use your directory name here

lon.shape <- readOGR(shape.dir, layer = "lond_city")
lon.df <- fortify(lon.shape, region = "name")

ggplot(lon.df, aes(x = long, y = lat, group = group)) +
    geom_polygon(colour = "black", fill = "grey80", size = 1) +
    theme()
-------------------------------------------------------------------------------------------------------
group map <- function(){
  geom_polygon(data=lon.df,aes(x=long,y=lat,group=piece),colour="black",fill="grey80",size=1)
}

points <- function(){
  geom_point(data=age2100,aes(x=x,y=y),size=0.1)
}

density <- function(){
  geom_density2d(data=age2100,aes(x=x,y=y),colour="red")
}

ggplot()+map() +points() +density()
-------------------------------------------------------------------------------------------------------
cut labels=F pdata <- transform(pdata,varc =cut(pdata$Var,10,labels=F))
p<-ggplot(subset(pdata,variable!='Mean'), aes(Var,value,col=varc))
p+geom_point(aes(shape = variable),alpha=0.7)+
 geom_line(data=subset(pdata,variable =='Mean'),size=2) last_plot()+ geom_polygon(aes(fill=varc, group=variable),alpha=0.3,linetype=3)
-------------------------------------------------------------------------------------------------------
geom_polygon data.frame VLarge <- VFinal[which(VFinal$Value > 25000),]
VLarge <- VLarge[order(-VLarge$Variable, VLarge$Group),]
VSmall <- VFinal[which(VFinal$Value <= 25000),]
VSmall <- VSmall[order(VSmall$Variable, VSmall$Group),]
VFinal <- rbind(VSmall, VLarge)
ggplot(VFinal, aes(Variable, Value, colour = Group)) + geom_point() + 
    geom_polygon(aes(fill = Group), alpha = 0.3)
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(reshape)
library(car)

G1 <- 1:10
G2 <- 11:20
G3 <- 21:30
G4 <- 31:35
G5 <- 36:41

sdata <- read.csv("http://dl.dropbox.com/u/58164604/sdata.csv", stringsAsFactors = FALSE)
pdata<-melt(sdata, id.vars="Var")
jdata <-pdata

pdata$group <- recode(pdata$Var, "G1 = 'A'; G2 = 'B'; G3 = 'C'; G4 = 'D'; G5 = 'E'")

VarArea <- data.frame(unique(pdata$Var))
VarFinalArea <-c()
for (g in 1:max(VarArea))
{
VarNum<-pdata[which(pdata$Var==g),1:c(ncol(pdata))]
VarMin <- min(VarNum$value)
VarMax <- max(VarNum$value)
VarMinMax <- cbind(VarMin, VarMax)
VarFinalArea <- rbind(VarFinalArea,VarMinMax)
}
VarFinal <- data.frame(cbind(VarArea,VarFinalArea))
colnames(VarFinal)<-c("Variable", "Min", "Max")
VarFinal$group <- recode(VarFinal$Variable, "G1 = 'A'; G2 = 'B'; G3 = 'C'; G4 = 'D'; G5 = 'E'")

VarArea <- data.frame(unique(jdata$Var))
NumV <- max(VarArea)
VarFinalMin <-c()
for (g in 1:NumV)
{
VarNum<-jdata[which(jdata$Var==g),1:c(ncol(jdata))]
VarN <- g
VarMin <- min(VarNum$value)
VarMinN <- cbind(VarN, VarMin)
VarFinalMin <- rbind(VarFinalMin,VarMinN)
}
VFinalMin <- data.frame(VarFinalMin)
colnames(VFinalMin)<-c("Variable", "Value")
VFinalMin_Max<-max(VFinalMin$Value)

VarFinalMax <-c()
for (g in 1:NumV)
{
VarNum<-jdata[which(jdata$Var==g),1:c(ncol(jdata))]
VarN <- g
VarMax <- max(VarNum$value)
VarMaxN <- cbind(VarN, VarMax)
VarFinalMax <- rbind(VarFinalMax,VarMaxN)
}
VFinalMax <- data.frame(VarFinalMax)
colnames(VFinalMax)<-c("Variable", "Value")
VFinalMax_Min<-min(VFinalMax$Value)

VFinal<-rbind(VFinalMin, VFinalMax)
VFinal$Group <- recode(VFinal$Variable, "G1 = 'A'; G2 = 'B'; G3 = 'C'; G4 = 'D'; G5 = 'E'")

VLarge <- VFinal[which(VFinal$Value >= VFinalMax_Min),]
VLarge <- VLarge[order(-VLarge$Variable, VLarge$Group),]
VSmall <- VFinal[which(VFinal$Value <= VFinalMin_Max),]
VSmall <- VSmall[order(VSmall$Variable, VSmall$Group),]
VFinal <- rbind(VSmall, VLarge)

AMin <-min(jdata$value)
AMax <-max(jdata$value)

AMinValue<-round_any(AMin,1000, f =floor)
AMaxValue<-round_any(AMax,1000, f =ceiling)

ggplot(VFinal, aes(Variable, Value, colour = Group)) + geom_polygon(colour=NA, aes(fill=Group), alpha=0.5) +scale_x_discrete(name="Missing Variable Number", limits=c(1:NumV)) + theme(axis.text.x=element_text(angle=270, vjust=0.5, hjust=0.0))+ scale_y_continuous(name="Within Cluster Sum of Squares", limits=c(AMinValue, AMaxValue), breaks = seq(AMinValue, AMaxValue, 1000)) + guides(fill=guide_legend(title="Variable Groups"))+ scale_fill_manual("Variable Groups", values = c("A" = "red", "B" = "blue", "C" = "purple", "D" = "salmon", "E" = "orange"))

last_plot()+geom_line(data=subset(pdata,variable =='Mean'), alpha=0.5, aes(Var, value, size= ''), colour="black", inherit.aes = FALSE)+ guides (size = guide_legend(title = "Mean", override.aes = list(size = 1.5, colour = "black")))

last_plot()+geom_line(data=subset(pdata,variable!='Mean'),size=0.5, alpha=0.5, aes(Var, value, shape=variable), colour='black', inherit.aes = FALSE) 

last_plot()+geom_point(data=subset(pdata,variable!='Mean'), aes(Var, value, shape = variable, col=group),alpha=1.0, inherit.aes = FALSE) + labs (shape = "Number of Clusters") + guides(scale_alpha(guide='none')) + guides(colour = "none") + scale_colour_manual("Variable Groups", values = c("A" = "red", "B" = "blue", "C" = "purple", "D" = "salmon", "E" = "orange"))

last_plot()+ ggtitle("Clusters with Missing Variables") + theme(plot.title = element_text(size = 14, colour = "black", face = "bold"))
-------------------------------------------------------------------------------------------------------
polygon library(maps)
map("state")     
tempplot <- map("state", add = TRUE, region = c("texas"),plot=FALSE)

# fix the border with new mexico to draw it in the correct order
tempplot$x[829:861] <- tempplot$x[861:829]
tempplot$y[829:861] <- tempplot$y[861:829]

polygon(
  na.omit(tempplot$x),
  na.omit(tempplot$y),
  border=1,
  density=10
)

map("state", add = TRUE, region = c("california"), fill=TRUE, col="black")
-------------------------------------------------------------------------------------------------------
grep e.w.shp <- uk.shp[uk.shp$NAME_1 == "England" | uk.shp$NAME_1 == "Wales", ] > str(e.w.shp)
Formal class 'SpatialPolygonsDataFrame' [package "sp"] with 5 slots
  ..@ data       :'data.frame': 134 obs. of  11 variables:
  .. ..$ ID_0     : int [1:134] 239 239 239 239 239 239 239 239 239 239 ...
  .. ..$ ISO      : chr [1:134] "GBR" "GBR" "GBR" "GBR" ...
  .. ..$ NAME_0   : chr [1:134] "United Kingdom" "United Kingdom" "United Kingdom" "United Kingdom" ...
  .. ..$ ID_1     : int [1:134] 1 1 1 1 1 1 1 1 1 1 ...
  .. ..$ NAME_1   : chr [1:134] "England" "England" "England" "England" ...
  .. ..$ ID_2     : int [1:134] 1 2 3 4 5 6 7 8 9 10 ...
  .. ..$ NAME_2   : chr [1:134] "Barking and Dagenham" "Bath and North East Somerset" "Bedfordshire" "Berkshire" ...
  .. ..$ NL_NAME_2: chr [1:134] NA NA NA NA ...
  .. ..$ VARNAME_2: chr [1:134] NA NA NA NA ...
  .. ..$ TYPE_2   : chr [1:134] "London Borough" "Unitary Authority" "Administrative County" "County" ...
  .. ..$ ENGTYPE_2: chr [1:134] "London Borough" "Unitary Authority" "Administrative County" "County" ...
  ..@ polygons   :List of 134 ggplot2 library(rgdal)
library(ggplot2)
library(rgeos)

shape.dir <- "your_directory_name" # use your directory name here
uk.shp <- readOGR(shape.dir, layer = "GBR_adm2")
e.w.shp <- uk.shp[uk.shp$NAME_1 == "England" | uk.shp$NAME_1 == "Wales", ]
e.w.df <- fortify(e.w.shp, region = "ID_2") # convert to data frame for ggplot

ggplot(e.w.df, aes(x = long, y = lat, group = group)) +
    geom_polygon(colour = "black", fill = "grey80", size = 0.5) +
    theme()
-------------------------------------------------------------------------------------------------------
widths = c(0.5, 0.5, 1/3,1/4,1/5, 3.5, 0.5)
heights = c(25, 10, 5,4.5,4,2,0.5) barplot ##Also specify colours
barplot(heights, widths, space=0, 
        col = colours()[1:6]) axis(1, 0:6) grid ##Look at ?grid to for more control over the grid lines
grid() arrows(1, 10, 1.2, 12, code=1)
text(1.2, 13, "A country") polygon polygon(c(4,4,5,5), c(20, 25, 25, 20), col="antiquewhite1")
text(4.3, 22.5, "Hi there", cex=0.6) par(mar=c(3,3,2,1), 
    mgp=c(2,0.4,0), tck=-.01,
    cex.axis=0.9, las=1)
-------------------------------------------------------------------------------------------------------
# Return a line in the Poincare disk, i.e.,
# a circle arc, perpendicular to the unit circle, through two given points.
poincare_segment <- function(u1, u2, v1, v2) {
    # Check that the points are sufficiently different
    if( abs(u1-v1) < 1e-6 && abs(u2-v2) < 1e-6 )
        return( list(x=c(u1,v1), y=c(u2,v2)) )
    # Check that we are in the circle
    stopifnot( u1^2 + u2^2 - 1 <= 1e-6 )
    stopifnot( v1^2 + v2^2 - 1 <= 1e-6 )
    # Check it is not a diameter
    if( abs( u1*v2 - u2*v1 ) < 1e-6 )
        return( list(x=c(u1,v1), y=c(u2,v2)) )
    # Equation of the line: x^2 + y^2 + ax + by + 1 = 0 (circles orthogonal to the unit circle)
    a <- ( u2 * (v1^2+v2^2) - v2 * (u1^2+u2^2) + u2 - v2 ) / ( u1*v2 - u2*v1 )
    b <- ( u1 * (v1^2+v2^2) - v1 * (u1^2+u2^2) + u1 - v1 ) / ( u2*v1 - u1*v2 ) # Swap 1's and 2's
    # Center and radius of the circle
    cx <- -a/2
    cy <- -b/2
    radius <- sqrt( (a^2+b^2)/4 - 1 )
    # Which portion of the circle should we draw?
    theta1 <- atan2( u2-cy, u1-cx )
    theta2 <- atan2( v2-cy, v1-cx )
    if( theta2 - theta1 > pi )
        theta2 <- theta2 - 2 * pi
    else if( theta2 - theta1 < - pi )
        theta2 <- theta2 + 2 * pi
    theta <- seq( theta1, theta2, length=100 )
    x <- cx + radius * cos( theta )
    y <- cy + radius * sin( theta )
    list( x=x, y=y )
}

# Sample data
n <- 10
m <- 7
segment_weight <- abs(rnorm(n))
segment_weight <- segment_weight / sum(segment_weight)
d <- matrix(abs(rnorm(n*n)),nr=n, nc=n)
diag(d) <- 0 # No loops allowed
# The weighted graph comes from two quantitative variables
d[1:m,1:m] <- 0
d[(m+1):n,(m+1):n] <- 0
ribbon_weight <- t(d) / apply(d,2,sum) # The sum of each row is 1; use as ribbon_weight[from,to]
ribbon_order <- t(apply(d,2,function(...)sample(1:n))) # Each row contains sample(1:n); use as ribbon_order[from,i]
segment_colour <- rainbow(n)
segment_colour <- brewer.pal(n,"Set3")
transparent_segment_colour <- rgb(t(col2rgb(segment_colour)/255),alpha=.5)
ribbon_colour <- matrix(rainbow(n*n), nr=n, nc=n) # Not used, actually...
ribbon_colour[1:m,(m+1):n] <- transparent_segment_colour[1:m]
ribbon_colour[(m+1):n,1:m] <- t(ribbon_colour[1:m,(m+1):n])

# Plot
gap <- .01
x <- c( segment_weight[1:m], gap, segment_weight[(m+1):n], gap )
x <- x / sum(x)
x <- cumsum(x)
segment_start <- c(0,x[1:m-1],x[(m+1):n])
segment_end   <- c(x[1:m],x[(m+2):(n+1)])
start1 <- start2 <- end1 <- end2 <- ifelse(is.na(ribbon_weight),NA,NA)
x <- 0
for (from in 1:n) {
  x <- segment_start[from]
  for (i in 1:n) {
    to <- ribbon_order[from,i]
    y <- x + ribbon_weight[from,to] * ( segment_end[from] - segment_start[from] )
    if( from < to ) {
      start1[from,to] <- x
      start2[from,to] <- y
    } else if( from > to ) {
      end1[to,from] <- x
      end2[to,from] <- y
    } else {
      # no loops allowed
    }
    x <- y
  }
}

par(mar=c(1,1,2,1))
plot(
  0,0, 
  xlim=c(-1,1),ylim=c(-1,1), type="n", axes=FALSE, 
  main="Two qualitative variables in polar coordinates", xlab="", ylab="")
for(from in 1:n) {
  for(to in 1:n) {
    if(from<to) {
      u <- start1[from,to]
      v <- start2[from,to]
      x <- end1  [from,to]
      y <- end2  [from,to]
      if(!is.na(u*v*x*y)) {
            r1 <- poincare_segment( cos(2*pi*v), sin(2*pi*v), cos(2*pi*x), sin(2*pi*x) )
            r2 <- poincare_segment( cos(2*pi*y), sin(2*pi*y), cos(2*pi*u), sin(2*pi*u) )
            th1 <- 2*pi*seq(u,v,length=20)
            th2 <- 2*pi*seq(x,y,length=20)
            polygon(
                c( cos(th1), r1$x, rev(cos(th2)), r2$x ),
                c( sin(th1), r1$y, rev(sin(th2)), r2$y ),
                col=transparent_segment_colour[from], border=NA
            )
      }
    }
  }
}
for(i in 1:n) {
  theta <- 2*pi*seq(segment_start[i], segment_end[i], length=100)
  r1 <- 1
  r2 <- 1.05
  polygon( 
    c( r1*cos(theta), rev(r2*cos(theta)) ),
    c( r1*sin(theta), rev(r2*sin(theta)) ),
    col=segment_colour[i], border="black"
  )
}
-------------------------------------------------------------------------------------------------------
ggplot str(countyData)
'data.frame':   39 obs. of  2 variables:
 $ id   : chr  "adams" "asotin" "benton" "chelan" ...
 $ value: num  1.995 0.711 0.185 -0.282 0.109 ... str(pointData)
'data.frame':   3 obs. of  2 variables:
 $ xx: num  -120 -123 -122
 $ yy: num  48.1 46.7 48 ggplot geom_polygon geom_map colnames(pointData) <- c('long','lat') # makes consistent with county_map
pointData$group <- 1 # ggplot needs a group to work with
county_map$value <- sapply(1:nrow(county_map),
                           function(x) round(runif(1, 1, 8), 0)) # for colours

ggplot(county_map, aes(x = long, y = lat, group = group)) +
    geom_polygon(aes(fill = value)) +
    coord_map() +
    geom_point(data = pointData, aes(x = long, y = lat), shape = 21, fill = "red") geom_map geom_polygon
-------------------------------------------------------------------------------------------------------
geom_polygon fill NA ggplot(datapoly, aes(x=x, y=y)) + 
  geom_polygon(aes(fill=value, group=id)) +
  geom_polygon(aes(group=id), alpha=1,colour="red", fill=NA, size=1.1) geom_polygon ggplot(datapoly, aes(x=x, y=y)) + 
  geom_polygon(aes(fill=value, group=id), colour="red", size=1.1)
-------------------------------------------------------------------------------------------------------
plot.deldir add=TRUE d<-structure(list(V1 = c(-0.5561835, -2.3985544, -3.8833659, 3.1025836, 0.7438354, 
                  7.0787294, -1.6633598, -0.675193, 1.4633841, -3.2118758), V2 = 
                  c(1.49947588, 3.07130217, -4.29331711, 5.4535916, -2.80116065, 
                  -2.78121213, -1.17898157, 0.03466162, 0.50173157, 0.49390863)), .Names =        
                  c("V1","V2"), class = "data.frame", row.names = c(NA, -10L))

library(MASS)
library(deldir)
dd <- deldir(d[,1], d[,2])
plot(dd, wlines="tess") plot.deldir dd$dirsgs ddd <- as.matrix(dd$dirsgs[dd$dirsgs$ind2==1,1:4])
d1poly <- rbind(ddd[1,1:2],ddd[1,3:4])
for( i in 2:nrow(ddd)){
    x <- ddd[ddd[,1]==d1poly[i,1], 3:4]
    d1poly <- rbind(d1poly, x)
    }
d1poly
         x2       y2
  -2.096990 1.559118
   0.303986 4.373353
x  1.550185 3.220238
x  0.301414 0.692558
x -1.834581 0.866098
x -2.096990 1.559118 splancs library(splancs)
rd <- csr(as.matrix(d1poly),10) # For 10 random points in the polygon containing point 1
rd
              xc        yc
 [1,] -1.6904093 1.9281052
 [2,] -1.1321334 1.7363064
 [3,]  0.2264649 1.3986126
 [4,] -1.1883844 2.5996515
 [5,] -0.6929208 0.8745020
 [6,] -0.8348241 2.3318222
 [7,]  0.9101748 1.9439797
 [8,]  0.1665160 1.8754703
 [9,] -1.1100710 1.3517257
[10,] -1.5691826 0.8782223

rdd <- deldir(c(rd[,1],d[1,1]),c(rd[,2],d[1,2])) 
# don't forget to add the coordinates of your point 1 so it s part of the sub-tessellation
plot(dd, wlines="tess")
plot(rdd, add=TRUE, wlines="tess") plot(dd, wlines="tess", col="white", wpoints="none")
plot(rdd, wlines="tess", add=TRUE)

plotlim <- cbind(par()$usr[c(1,2,2,1)],par()$usr[c(3,3,4,4)])
extpoly <- rbind(plotlim, d1poly) 
#Here the first point of d1poly is oriented toward the upper left corner: if it is oriented otherwise the order of plotlim has to be changed accordingly

polygon(extpoly, border=NA, col="white")

plot(dd, wlines="tess", add=TRUE)
-------------------------------------------------------------------------------------------------------
clockplot<-function(x, y, h, m, r, border="black", col="lightblue", 
                    col.hour="darkblue", col.min="red"){
#x and y are the coordinates of the clock
#h and m the hour (base 12) and minutes
# r the radius of the clock
    t<-seq(0,2*pi,by=0.01)
    x.c<-r*cos(t)+x
    y.c<-r*sin(t)+y

    t.h<-pi/2 - 2*pi*(h-m/60)/12
    x.h<-0.5*r*cos(t.h)+x
    y.h<-0.5*r*sin(t.h)+y

    t.m<-pi/2 - 2*pi*m/60
    x.m<-r*cos(t.m)+x
    y.m<-r*sin(t.m)+y

    polygon(x.c,y.c,col=col, border=border)
    segments(x,y,x.h,y.h,col=col.hour)
    segments(x,y,x.m,y.m,col=col.min)
    }

myd <- data.frame (X = 1:5, Y = c(0.8, 0.6, 0.7, 0.75,  0.1), 
                   clockd = c(12.05, 12.25, 12.45, 1.30, 2.1))
myd$hour<-myd$clockd%/%1
myd$min<-myd$clockd%%1 *100

plot(myd$X, myd$Y, type="l", asp=1)
apply(myd,1,function(x)clockplot(x[1],x[2],x[4],x[5], r=0.25))
-------------------------------------------------------------------------------------------------------
tile.list secr::pointsInPolygon # Sample data
x <- matrix( rnorm(20), nc = 2 )
y <- matrix( rnorm(1000), nc=2 )

# Tessellation
library(deldir)
d <- deldir(x[,1], x[,2])
plot(d, wlines="tess")

# Pick a cell at random 
cell <- sample( tile.list(d), 1 )[[1]]
points( cell$pt[1], cell$pt[2], pch=16 )
polygon( cell$x, cell$y, lwd=3 )

# Select the points inside that cell
library(secr)
i <- pointsInPolygon(
  y, 
  cbind( 
    c(cell$x,cell$x[1]), 
    c(cell$y,cell$y[1])
  )
)
points(y[!i,], pch=".")
points(y[i,], pch="+")

# Compute a tessellation of those points
dd <- deldir(y[i,1], y[i,2])
plot(dd, wlines="tess", add=TRUE) distance_to_segment <- function(M, A, B) {
  norm <- function(u) sqrt(sum(u^2))
  lambda <- sum( (B-A) * (M-A) ) / norm(B-A)^2
  if( lambda <= 0 ) {
    norm(M-A)
  } else if( lambda >= 1 ) {
    norm(M-B)
  } else {
    N <- A + lambda * (B-A)
    norm(M-N)
  }
}
A <- c(-.5,0)
B <- c(.5,.5)
x <- seq(-1,1,length=100)
y <- seq(-1,1,length=100)
z <- apply(
  expand.grid(x,y), 
  1, 
  function(u) distance_to_segment( u, A, B )
)
par(las=1)
image(x, y, matrix(z,nr=length(x)))
box()
segments(A[1],A[2],B[1],B[2],lwd=3)

library(secr)
distance_to_polygon <- function(x, poly) {
  closed_polygon <- rbind(poly, poly[1,])
  if( pointsInPolygon( t(x), closed_polygon ) )
    return(0)
  d <- rep(Inf, nrow(poly))
  for(i in 1:nrow(poly)) {
    A <- closed_polygon[i,]
    B <- closed_polygon[i+1,]
    d[i] <- distance_to_segment(x,A,B)
  }
  min(d)
}
x <- matrix(rnorm(20),nc=2)
poly <- x[chull(x),]
x <- seq(-5,5,length=100)
y <- seq(-5,5,length=100)
z <- apply(
  expand.grid(x,y), 
  1, 
  function(u) distance_to_polygon( u, poly )
)
par(las=1)
image(x, y, matrix(z,nr=length(x)))
box()
polygon(poly, lwd=3) x --> lambda * x + a
y --> lambda * y + b # Sample data 
x <- matrix(rnorm(20),nc=2)
x <- x[chull(x),]
y <- matrix( c(1,2) + 5*rnorm(20), nc=2 )
plot(y, axes=FALSE, xlab="", ylab="")
polygon(x)

# Function to minimize:
# either the sum of the squares of the distances to the polygon, 
# if at least one point is outside, 
# or minus the square of the scaling factor.
# It is not continuous, but (surprisingly) that does not seem to be a problem.
f <- function( p ) {
  lambda <- log( 1 + exp(p[1]) )
  a <- p[2:3]
  y0 <- colMeans(y)
  transformed_points <- t( lambda * (t(y)-y0) + a )
  distances <- apply(
    transformed_points, 
    1, 
    function(u) distance_to_polygon(u, x)
  )
  if( all(distances == 0) ) - lambda^2
  else                      sum( distances^2 )
}
# Minimize this function
p <- optim(c(1,0,0), f)$par
# Compute the optimal parameters
lambda <- log( 1 + exp(p[1]) )
a <- p[2:3]
y0 <- colMeans(y)
# Compute the new coordinates
transformed_points <- t( lambda * (t(y)-y0) + a )
# Plot them
segments( y[,1], y[,2], transformed_points[,1], transformed_points[,2], lty=3 )
points( transformed_points, pch=3 )
library(deldir)
plot( 
  deldir( transformed_points[,1], transformed_points[,2] ), 
  wlines="tess", add=TRUE 
)
-------------------------------------------------------------------------------------------------------
install.packages("fastshp",,"http://rforge.net")
 library(fastshp)
 s <- read.shp("zip5.shp", format="polygon") s x y plot(s[[1]]$x, s[[1]]$y, asp=1.25)
 polygon(s[[1]]$x, s[[1]]$y, col="#eeeeee") read.dbf foreign library(foreign)
 d <- read.dbf("zip5.dbf", as.is=TRUE)
 names(s) <- d$ZIP5 ?read.shp NA
-------------------------------------------------------------------------------------------------------
circleFun arrow grid ggplot2 ggplot2 # Load packages
library(package=ggplot2)  # You should update ggplot2
library(package=plyr)     # To proccess each class separately


# Your data generating code
points <- data.frame(x=runif(10), y=runif(10),class=1:10,
                     size=runif(10,min=1000,max=100000) )
trans <- data.frame(from=rep(1:10,times=10), to=rep(1:10,each=10),
                    amount=runif(100)^3 )
trans <- merge(trans, points, by.x="from", by.y="class" )
trans <- merge(trans, points, by.x="to", by.y="class", suffixes=c(".to",".from") )


# Generate a set of points in a circumference
# Originally posted by @joran in
# http://stackoverflow.com/questions/6862742/draw-a-circle-with-ggplot2
circleFun <- function(center = c(0,0), diameter = 1, npoints = 100){
    r = diameter / 2
    tt <- seq(0,2*pi,length.out = npoints)
    xx <- center[1] + r * cos(tt)
    yy <- center[2] + r * sin(tt)
    return(data.frame(x = xx, y = yy))
}


# Get max and min sizes and min distances to estimate circle scales
min_size <- min(points$size, na.rm=TRUE)
max_size <- max(points$size, na.rm=TRUE)
xs <- apply(X=combn(x=points$x, m=2), MARGIN=2, diff, na.rm=TRUE)
ys <- apply(X=combn(x=points$y, m=2), MARGIN=2, diff, na.rm=TRUE)
min_dist <- min(abs(c(xs, ys)))  # Seems too small
mean_dist <- mean(abs(c(xs, ys)))

# Adjust sizes
points$fit_size <- points$size * (mean_dist/max_size)


# Generate the circles based on the points
circles <- ddply(.data=points, .variables='class',
                 .fun=function(class){
                    with(class,
                    circleFun(center = c(x, y), diameter=fit_size))
                 })
circles <- merge(circles, points[, c('class', 'size', 'fit_size')])


# Plot
ggplot(data=circles, aes(x=x, y=y)) +
    geom_polygon(aes(group=factor(class), fill=size)) + 
    geom_segment(data=trans,
                 aes(x=x.from, y=y.from, xend=x.to, yend=y.to, size=amount),
                 alpha=0.6, lineend="round", arrow=grid::arrow()) +
    coord_equal()
-------------------------------------------------------------------------------------------------------
set.seed(1)
dd = data.frame(x = 1:5, eps_x = rnorm(5, 0, 0.1), y = rnorm(5), eps_y = rnorm(5, 0, 0.1))

##Save space later    
dd$xmin = dd$x - dd$eps_x
dd$xmax = dd$x + dd$eps_x
dd$ymin = dd$y - dd$eps_y
dd$ymax = dd$y + dd$eps_y library(ggplot2)
ggplot(dd) + 
     geom_rect(aes( xmax = xmax, xmin=xmin, ymin=ymin, ymax = ymax)) plot(0, 0, xlim=c(0.5, 5.5), ylim=c(-1, 1), type="n")
for(i in 1:nrow(dd)){
    d = dd[i,]
    polygon(c(d$xmin, d$xmax, d$xmax, d$xmin), c(d$ymin, d$ymin, d$ymax,d$ymax), col="grey80")
}
-------------------------------------------------------------------------------------------------------
H = 1.3 + D^2/(a+b*D+c*D^2) 1/(H-1.3) = a/D^2+b/D+c H 1/(H-1.3) data(trees)
df <- transform(trees,
            h=Height * 0.3048,   #transform to metric system
            dbh=Girth * 0.3048 / pi   #transform tree girth to diameter
            )
lm(1/(h-1.3) ~ poly(I(1/dbh),2,raw=TRUE),data=df)

## Coefficients:
##                    (Intercept)  poly(I(1/dbh), 2, raw = TRUE)1  
##                       0.043502                       -0.006136  
## poly(I(1/dbh), 2, raw = TRUE)2  
##                       0.010792 nls glm (fit2 <- glm(h-1.3 ~ poly(I(1/dbh),2,raw=TRUE),
             family=gaussian(link="inverse"),data=df))

## Coefficients:
##                    (Intercept)  poly(I(1/dbh), 2, raw = TRUE)1  
##                       0.041795                       -0.002119  
## poly(I(1/dbh), 2, raw = TRUE)2  
##                       0.008175  
## 
## Degrees of Freedom: 30 Total (i.e. Null);  28 Residual
## Null Deviance:       113.2 
## Residual Deviance: 80.05     AIC: 125.4 
## pframe <- data.frame(dbh=seq(0.8,2,length=51)) predict pframe$h <- predict(fit2,newdata=pframe,type="response")+1.3
p2 <- predict(fit2,newdata=pframe,se.fit=TRUE) ## predict on link scale
pframe$h_lwr <- with(p2,1/(fit+1.96*se.fit))+1.3
pframe$h_upr <- with(p2,1/(fit-1.96*se.fit))+1.3
png("dbh_tmp1.png",height=4,width=6,units="in",res=150)
par(las=1,bty="l")
plot(h~dbh,data=df)
with(pframe,lines(dbh,h,col=2))
with(pframe,polygon(c(dbh,rev(dbh)),c(h_lwr,rev(h_upr)),
      border=NA,col=adjustcolor("black",alpha=0.3)))
dev.off() 1/H - 1.3 = a/D^2 + ... ggplot geom_smooth library("ggplot2")
ggplot(df,aes(dbh,h))+geom_point()+theme_bw()+
   geom_line(data=pframe,colour="red")+
   geom_ribbon(data=pframe,colour=NA,alpha=0.3,
             aes(ymin=h_lwr,ymax=h_upr))

ggsave("dbh_tmp2.png",height=4,width=6)
-------------------------------------------------------------------------------------------------------
ggplot2 library(ggplot2)
# Convert the SpatialPolygons object to a data.frame, which ggplot2 needs
poly_data_frame = fortify(poly_spatialpolygon)
ggplot(poly_data_frame, aes(x = x, y = y)) + geom_polygon(fill = "transparent")
ggsave("poly_plot.png")
-------------------------------------------------------------------------------------------------------
pushViewport(viewport(x=0, y=1, xscale=c(1, 10), yscale=c(0, 100), width=0.25, height=0.25, default.units="npc", just=c("left","bottom"), clip="off")) library(grid)

# Specify general chart options.
chart_Fill = "lemonchiffon"
chart_Col = "snow3"
space_Background = "white"
title_CEX = 0.8
axis_CEX = 0.6
chart_Width <- 3/3
chart_Height <- 2/5

# Function to initialize a plotting area.
init_Plot <- function(
    .df,
    .x_Loc, 
    .y_Loc, 
    .justify, 
    .width, 
    .height
    ){

    # Initialize plotting area to fit data.
    # We have to turn off clipping to make it
    # easy to plot the labels around the plot.
    pushViewport(viewport(xscale=c(min(.df[,1]), max(.df[,1])), yscale=c(min(0,min(.df[,-1])), max(.df[,-1])), x=.x_Loc, y=.y_Loc, width=.width, height=.height, just=.justify, clip="off", default.units="native"))

    # Color behind text.
    grid.rect(x=0, y=0, width=unit(axis_CEX, "lines"), height=1, default.units="npc", just=c("right", "bottom"), gp=gpar(fill=space_Background, col=space_Background))
    grid.rect(x=0, y=1, width=1, height=unit(title_CEX, "lines"), default.units="npc", just=c("left", "bottom"), gp=gpar(fill=space_Background, col=space_Background))

    # Color in the space.
    grid.rect(gp=gpar(fill=chart_Fill, col=chart_Col))
}

# Function to finalize and label a plotting area.
finalize_Plot <- function(
    .df, 
    .plot_Title
    ){

    # Label plot using the internal reference
    # system, instead of the parent window, so
    # we always have perfect placement.
    grid.text(.plot_Title, x=0.5, y=1.05, just=c("center","bottom"), rot=0, default.units="npc", gp=gpar(cex=title_CEX))
    grid.text(paste(names(.df)[-1], collapse=" & "), x=-0.05, y=0.5, just=c("center","bottom"), rot=90, default.units="npc", gp=gpar(cex=axis_CEX))
    grid.text(names(.df)[1], x=0.5, y=-0.05, just=c("center","top"), rot=0, default.units="npc", gp=gpar(cex=axis_CEX))

    # Finalize plotting area.
    popViewport()
}

# Function to plot a filled line chart of
# the data in a data frame.  The first column
# of the data frame is assumed to be the
# plotting index, with each column being a
# set of y-data to plot.  All data is assumed
# to be numeric.
plot_Line_Chart <- function(
    .df,
    .x_Loc,
    .y_Loc,
    .justify,
    .width,
    .height,
    .colors,
    .plot_Title
    ){

    # Initialize plot.
    init_Plot(.df, .x_Loc, .y_Loc, .justify, .width, .height)

    # Calculate what value to use as the
    # return for the polygons.
    y_Axis_Min <- min(0, min(.df[,-1]))

    # Plot each set of data as a polygon,
    # so we can fill it in with color to
    # make it easier to read.
    for (i in 2:ncol(.df)){
        grid.polygon(x=c(min(.df[,1]),.df[,1], max(.df[,1])), y=c(y_Axis_Min,.df[,i], y_Axis_Min), default.units="native", gp=gpar(fill=.colors[i-1], col=.colors[i-1], alpha=1/ncol(.df)))
    }

    # Draw plot axes.
    grid.lines(x=0, y=c(0,1), default.units="npc")
    grid.lines(x=c(0,1), y=0, default.units="npc")

    # Finalize plot.
    finalize_Plot(.df, .plot_Title)

}

# Function to plot a scatterplot of
# the data in a data frame.  The
# assumptions are the same as 'plot_Line_Chart'.
plot_Scatterplot <- function(
    .df,
    .x_Loc,
    .y_Loc,
    .justify,
    .width,
    .height,
    .colors,
    .plot_Title
    ){

    # Initialize plot.
    init_Plot(.df, .x_Loc, .y_Loc, .justify, .width, .height)

    # Plot each set of data as colored points.
    for (i in 2:ncol(.df)){
        grid.points(x=.df[,1], y=.df[,i], pch=19, size=unit(1, "native"), default.units="native", gp=gpar(col=.colors[i-1], alpha=1/ncol(.df)))
    }

    # Draw plot axes.
    grid.lines(x=0, y=c(0,1), default.units="npc")
    grid.lines(x=c(0,1), y=0, default.units="npc")

    # Finalize plot.
    finalize_Plot(.df, .plot_Title)

}

# Function to plot a histogram of
# all the columns in a data frame,
# except the first, which is assumed to
# be an index.
plot_Histogram <- function(
    .df,
    .x_Loc,
    .y_Loc,
    .justify,
    .width,
    .height,
    .colors,
    .plot_Title,
    ...
    ){

    # Create a list containing the histogram
    # data for each data column and calculate
    # data ranges.  Any extra parameters
    # specified will pass to the 'hist' function.
    hist_Data <- list()
    hist_Count_Range <- c(0,NA)
    hist_Breaks_Range <- c(NA,NA)
    for (i in 2:ncol(.df)){
        hist_Data[[i]] <- hist(.df[,i], plot=FALSE, ...)
        hist_Count_Range[2] <- max(max(hist_Data[[i]]$counts), hist_Count_Range[2], na.rm=TRUE)
        hist_Breaks_Range <- c(min(min(hist_Data[[i]]$breaks), hist_Breaks_Range[1], na.rm=TRUE), max(max(hist_Data[[i]]$breaks), hist_Breaks_Range[2], na.rm=TRUE))
    }


    # Initialize plotting area to fit data.
    # We are doing this in a custom way to
    # allow more flexibility than built into
    # the 'init_Plot' function.
    # We have to turn off clipping to make it
    # easy to plot the labels around the plot.
    pushViewport(viewport(xscale=hist_Breaks_Range, yscale=hist_Count_Range, x=.x_Loc, y=.y_Loc, width=.width, height=.height, just=.justify, clip="off", default.units="native"))

    # Color behind text.
    grid.rect(x=0, y=0, width=unit(axis_CEX, "lines"), height=1, default.units="npc", just=c("right", "bottom"), gp=gpar(fill=space_Background, col=space_Background))
    grid.rect(x=0, y=1, width=1, height=unit(title_CEX, "lines"), default.units="npc", just=c("left", "bottom"), gp=gpar(fill=space_Background, col=space_Background))

    # Color in the space.
    grid.rect(gp=gpar(fill=chart_Fill, col=chart_Col))


    # Draw x axis.
    grid.lines(x=c(0,1), y=0, default.units="npc")

    # Plot each set of data as a histogram.
    for (i in 2:ncol(.df)){
        grid.rect(x=hist_Data[[i]]$mids, y=0, width=diff(hist_Data[[i]]$mids[1:2]), height=hist_Data[[i]]$counts, default.units="native", just=c("center","bottom"), gp=gpar(fill=.colors[i-1], col=.colors[i-1], alpha=1/ncol(.df)))
    }

    # Label plot using the internal reference
    # system, instead of the parent window, so
    # we always have perfect placement.
    grid.text(.plot_Title, x=0.5, y=1.05, just=c("center","bottom"), rot=0, default.units="npc", gp=gpar(cex=title_CEX))
    grid.text(paste(names(.df)[-1], collapse=" & "), x=-0.05, y=0.5, just=c("center","bottom"), rot=90, default.units="npc", gp=gpar(cex=axis_CEX))

    # Finalize plotting area.
    popViewport()
}

draw_Sample_Box <- function(
    .x_Loc,
    .y_Loc,
    .x_Scale,
    .y_Scale,
    .justify,
    .width,
    .height,
    .colors,
    .box_X,
    .box_Y,
    .plot_Title
    ){

    pushViewport(viewport(xscale=.x_Scale, yscale=.y_Scale, x=.x_Loc, y=.y_Loc, width=chart_Width, height=chart_Height, just=.justify, clip="off", default.units="native"))

    # Color behind text.
    grid.rect(x=0, y=1, width=1, height=unit(title_CEX, "lines"), default.units="npc", just=c("left", "bottom"), gp=gpar(fill=space_Background, col=space_Background))

    # Color in the space.
    grid.rect(gp=gpar(fill=chart_Fill, col=chart_Col))

    # Label plot.
    grid.text(.plot_Title, x=0.5, y=1.05, just=c("center","bottom"), rot=0, default.units="npc", gp=gpar(cex=title_CEX))

    # Draw box and label points.
    grid.polygon(x=.box_X, y=.box_Y, default.units="native", gp=gpar(fill=.colors[1], col=.colors[2]))
    grid.text(paste(.plot_Title, 1, sep=""), x=min(.box_X), y=min(.box_Y), default.units="native", just=c("right","top"), gp=gpar(cex=0.5))
    grid.text(paste(.plot_Title, 2, sep=""), x=max(.box_X), y=min(.box_Y), default.units="native", just=c("left","top"), gp=gpar(cex=0.5))

    # Finalize plot.
    popViewport()
} # Draw twelve independent charts as
# a demo and connect with lines similar
# to a heiritage chart.
grid.newpage()

# Initialize a viewport to make our locations
# easier to map.
pushViewport(viewport(x=0, y=0, width=1, height=1, just=c("left","bottom"), xscale=c(0,10), yscale=c(0,4)))

# Color background of overall plot.
grid.rect(gp=gpar(fill=space_Background, col=space_Background))

# Store plot locations for convenience.
plot_Loc <- data.frame(x=c(2,4,6,8,1,3,7,9,2,4,6,8), y=c(3,3,3,3,2,2,2,2,1,1,1,1))

# Draw connecting lines.
connections <- data.frame(a=c(1, 3, 5, 6, 7, 1, 3, 5, 7, 6), b=c(2, 4, 6, 7, 8, 2, 4, 6, 8, 7), c=c(NA, NA, NA, NA, NA, 6, 7, 9, 12, 10), d=c(NA, NA, NA, NA, NA, NA, NA, NA, NA, 11))
for (i in 1:nrow(connections)){
    if (is.na(connections$c[i])){
        grid.lines(x=plot_Loc$x[unlist(connections[i,1:2])], y=plot_Loc$y[unlist(connections[i,1:2])], default.units="native")
    } else if (is.na(connections$d[i])) {
        grid.lines(x=median(plot_Loc$x[unlist(connections[i,1:2])]), y=plot_Loc$y[unlist(connections[i,2:3])], default.units="native")
    } else {
        grid.lines(x=median(plot_Loc$x[unlist(connections[i,1:2])]), y=c(plot_Loc$y[connections[i,2]], median(plot_Loc$y[unlist(connections[i,2:3])])), default.units="native")
        grid.lines(x=plot_Loc$x[unlist(connections[i,3:4])], y=median(plot_Loc$y[unlist(connections[i,2:3])]), default.units="native")
        grid.lines(x=plot_Loc$x[connections[i,3]], y=c(median(plot_Loc$y[unlist(connections[i,2:3])]), plot_Loc$y[connections[i,3]]), default.units="native")
        grid.lines(x=plot_Loc$x[connections[i,4]], y=c(median(plot_Loc$y[unlist(connections[i,2:3])]), plot_Loc$y[connections[i,4]]), default.units="native")
    }
}


# Draw four independent line charts.
p <- 1
plot_Line_Chart(data.frame(time=1:1860, EuStockMarkets)[1:3], .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("dodgerblue", "deeppink"), "EU Stocks")
p <- 2
plot_Line_Chart(data.frame(time=1:1860, EuStockMarkets)[c(1,4,5)], .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("green", "purple"), "EU Stocks")
p <- 3
plot_Line_Chart(data.frame(time=1:(12*20), sunspots=sunspot.month[(171*12+1):(171*12+12*20)]), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("darkgoldenrod"), "Sunspots")
p <- 4
plot_Line_Chart(data.frame(time=1:(12*20), temp=nottem), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("red"), "Nottem")

# Draw four independent scatterplots.
p <- 5
plot_Scatterplot(data.frame(time=1:(1860 + 1 - 1000), DAX=rowMeans(embed(EuStockMarkets[,1], 1000)), FTSE=rowMeans(embed(EuStockMarkets[,4], 1000))), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("deeppink", "purple"), "Smooth")
p <- 6
plot_Scatterplot(data.frame(time=1:1860, EuStockMarkets)[c(1,2,5)], .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("deeppink", "purple"), "EU Stocks")
p <- 9
plot_Scatterplot(data.frame(time=1:(1860 + 1 - 20), DAX=rowMeans(embed(EuStockMarkets[,1], 20)), FTSE=rowMeans(embed(EuStockMarkets[,4], 20))), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("deeppink", "purple"), "Smooth*20")
p <- 10
plot_Scatterplot(data.frame(time=1:(1860 + 1 - 100), DAX=rowMeans(embed(EuStockMarkets[,1], 100)), FTSE=rowMeans(embed(EuStockMarkets[,4], 100))), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("deeppink", "purple"), "Smooth*100")


# Draw two independent histograms.
p <- 7
plot_Histogram(data.frame(time=1:(12*20), sunspots=sunspot.month[(171*12+1):(171*12+12*20)]), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("darkgoldenrod"), "Sunspots", breaks=6)
p <- 8
plot_Histogram(data.frame(time=1:(12*20), temp=nottem), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("red"), "Nottem", breaks=6)

# Draw sample objects in two charts spaces.
p <- 11
draw_Sample_Box(.x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .x_Scale=c(0,10), .y_Scale=c(-10,0), .justify=c("center","center"), .width=chart_Width, .height=chart_Height, .colors=c("dodgerblue","blue"), .box_X=c(4,6,6,4), .box_Y=c(-4,-4,-5,-5), .plot_Title="K")
p <- 12
draw_Sample_Box(.x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .x_Scale=c(-1,1), .y_Scale=c(0,1), .justify=c("center","center"), .width=chart_Width, .height=chart_Height, .colors=c("dodgerblue","blue"), .box_X=c(-0.5,0,0,-0.5), .box_Y=c(0.8,0.8,0.7,0.7), .plot_Title="L")
-------------------------------------------------------------------------------------------------------
# Function to initialize a plotting area.
init_Plot <- function(
    .df,
    .x_Loc, 
    .y_Loc, 
    .justify, 
    .width, 
    .height
    ){

    # Initialize plotting area to fit data.
    # We have to turn off clipping to make it
    # easy to plot the labels around the plot.
    pushViewport(viewport(xscale=c(min(.df[,1]), max(.df[,1])), yscale=c(min(0,min(.df[,-1])), max(.df[,-1])), x=.x_Loc, y=.y_Loc, width=.width, height=.height, just=.justify, clip="off", default.units="npc"))

    # Color behind text.
    grid.rect(x=0, y=0, width=unit(axis_CEX, "lines"), height=1, default.units="npc", just=c("right", "bottom"), gp=gpar(fill=space_Background, col=space_Background))
    grid.rect(x=0, y=1, width=1, height=unit(title_CEX, "lines"), default.units="npc", just=c("left", "bottom"), gp=gpar(fill=space_Background, col=space_Background))

    # Color in the space.
    grid.rect(gp=gpar(fill=chart_Fill, col=chart_Col))
}

# Function to finalize and label a plotting area.
finalize_Plot <- function(
    .df, 
    .plot_Title
    ){

    # Label plot using the internal reference
    # system, instead of the parent window, so
    # we always have perfect placement.
    grid.text(.plot_Title, x=0.5, y=1.05, just=c("center","bottom"), rot=0, default.units="npc", gp=gpar(cex=title_CEX))
    grid.text(paste(names(.df)[-1], collapse=" & "), x=-0.05, y=0.5, just=c("center","bottom"), rot=90, default.units="npc", gp=gpar(cex=axis_CEX))
    grid.text(names(.df)[1], x=0.5, y=-0.05, just=c("center","top"), rot=0, default.units="npc", gp=gpar(cex=axis_CEX))

    # Finalize plotting area.
    popViewport()
}

# Function to plot a filled line chart of
# the data in a data frame.  The first column
# of the data frame is assumed to be the
# plotting index, with each column being a
# set of y-data to plot.  All data is assumed
# to be numeric.
plot_Line_Chart <- function(
    .df,
    .x_Loc,
    .y_Loc,
    .justify,
    .width,
    .height,
    .colors,
    .plot_Title
    ){

    # Initialize plot.
    init_Plot(.df, .x_Loc, .y_Loc, .justify, .width, .height)

    # Calculate what value to use as the
    # return for the polygons.
    y_Axis_Min <- min(0, min(.df[,-1]))

    # Plot each set of data as a polygon,
    # so we can fill it in with color to
    # make it easier to read.
    for (i in 2:ncol(.df)){
        grid.polygon(x=c(min(.df[,1]),.df[,1], max(.df[,1])), y=c(y_Axis_Min,.df[,i], y_Axis_Min), default.units="native", gp=gpar(fill=.colors[i-1], col=.colors[i-1], alpha=1/ncol(.df)))
    }

    # Draw plot axes.
    grid.lines(x=0, y=c(0,1), default.units="npc")
    grid.lines(x=c(0,1), y=0, default.units="npc")

    # Finalize plot.
    finalize_Plot(.df, .plot_Title)

} grid.newpage()

# Specify main chart options.
chart_Fill = "lemonchiffon"
chart_Col = "snow3"
space_Background = "white"
title_CEX = 1.4
axis_CEX = 1

plot_Line_Chart(data.frame(time=1:1860, EuStockMarkets)[1:5], .x_Loc=1, .y_Loc=0, .just=c("right","bottom"), .width=0.9, .height=0.9, c("dodgerblue", "deeppink", "green", "red"), "EU Stocks")

# Specify sub-chart options.
chart_Fill = "lemonchiffon"
chart_Col = "snow3"
space_Background = "lemonchiffon"
title_CEX = 0.8
axis_CEX = 0.7

for (i in 1:4){
    plot_Line_Chart(data.frame(time=1:1860, EuStockMarkets)[c(1,i + 1)], .x_Loc=0.15*i, .y_Loc=0.8, .just=c("left","top"), .width=0.1, .height=0.1, c("dodgerblue", "deeppink", "green", "red")[i], "EU Stocks")
}
-------------------------------------------------------------------------------------------------------
pie polygon polygon(c(P$x, 0), c(P$y, 0), density = density[i], angle = angle[i], 
        border = border[i], col = col[i], lty = lty[i]) lwd ... pie2 <- 
   function (x, labels = names(x), edges = 200, radius = 0.8, clockwise = FALSE, 
             init.angle = if (clockwise) 90 else 0, density = NULL, angle = 45, 
             col = NULL, border = NULL, lty = NULL, main = NULL,  lwd=1,...) 

    {
       ................
     polygon(c(P$x, 0), c(P$y, 0), density = density[i], angle = angle[i], 
           border = border[i], col = col[i], lty = lty[i], lwd=lwd )
       .................

       }
  pie2(x1$V1, labels=lbls1, col=tail(brewer.pal(3, 'PuBu'), n=2), 
              main=paste('My 3.1415'), cex=1.1, lwd=5)
-------------------------------------------------------------------------------------------------------
polygon lines pie ... lwd ...
polygon(c(P$x, 0), c(P$y, 0), density = density[i], angle = angle[i], 
        border = border[i], col = col[i], lty = lty[i])
    P <- t2xy(mean(x[i + 0:1]))
    lab <- as.character(labels[i])
    if (!is.na(lab) && nzchar(lab)) {
        lines(c(1, 1.05) * P$x, c(1, 1.05) * P$y)
.... par(lwd = 2) pie # save original settings
opar <- par(no.readonly = TRUE)
par(lwd = 2)
pie(x1$V1, labels=lbls1, col=tail(brewer.pal(3, 'PuBu'), n=2), 
  main=paste('My 3.1415'), cex=1.1) par(lwd = 3) # reset to original
par(opar)
-------------------------------------------------------------------------------------------------------
scale_{which_scale}_{scale_type} which_scale aes() fill size scale_type fill scale_fill_continuous scale_fill_gradient scale_fill_gradient2 m2 <- m1 + geom_polygon(aes(x=long, y=lat, group=group, fill=rendapc))
m2 + scale_fill_gradient(low = "blue", high = "red")
-------------------------------------------------------------------------------------------------------
require(ggplot2)
require(maptools)
require(sp)

# Your shape file has some topology errors meaning it can't be used by 'over()'
# Use open source shapefiles from www.naturalearth.com - v. good quality
oldwd <- getwd(); tmp <- tempdir(); setwd(tmp)
url <- "http://www.naturalearthdata.com/http//www.naturalearthdata.com/download/10m/cultural/ne_10m_admin_1_states_provinces_shp.zip"
dest <- paste(tmp,"\\tmp.zip",sep="")
download.file( url , dest )
unzip(dest)


#   Projection information for geographic data (but in decimal degrees)
projgeo <- CRS("+proj=latlong +datum=WGS84 +ellps=WGS84")


# Read in world shapefile
wld <- readShapePoly("ne_10m_admin_1_states_provinces_shp" , proj4string = projgeo)
# Subset to Russia
map <- wld[wld$admin == "Russia" , ]


# City and metro data
r.city <- world.cities[ world.cities$country.etc=="Russia" , ]
metro_outlets <- read.csv(file="e:\\r\\retail\\metro.csv",head=TRUE,sep=";")


# Assign metro outlets to city and make spatial point data frame
met <- subset( metro_outlets , select = c( "SL" , "CITY_ENGLISH" ) )
met$SL <- as.numeric( met$SL )
match <- match( met$CITY_ENGLISH , r.city$name )
coordinates( met ) <- r.city[ match , c( "long" , "lat" ) ]
proj4string( met ) <- proj4string( map )


# Assign metro outlet attribute "SL" to each region of map
# Find the average SL for each region using 'over()'
df <- over( map , met[ , "SL" ] , fn = mean , na.rm = TRUE )
map$SL <- as.numeric( df$SL )


# Convert th map into format for plotting with ggplot
map@data$id <- rownames( map@data )
map.df <- as.data.frame( map )
map.fort <- fortify( map , region = "id" )
map.gg <- join( map.fort , map.df , by = "id" )


# Plot  
p1 <-   ggplot( NULL ) + 
    geom_polygon( mapping = aes( long , lat , group = group , fill  = factor( SL ) ) , colour = "white" , data = map.gg , map = map.gg )+
    scale_x_continuous( limits = c( 20 , 180 ) )
print(p1)
-------------------------------------------------------------------------------------------------------
ggplot2 lattice plot(c(1, 9), 1:2, type = "n")
polygon(1:9, c(2,1,2,1,NA,2,1,2,1),
         density = c(10, 20), angle = c(-45, 45)) gridBase library(gridBase)
vps <- baseViewports()
pushViewport(vps$figure,vps$plot)
with(as.list(c(a,b,d)),{
  grid.polygon(x = xA, y = yA,gp =gpar(fill='red',lty=1,alpha=0.2))
  grid.polygon(x = xB, y = yB,gp =gpar(fill='green',lty=2,alpha=0.2))
  grid.polygon(x = xD, y = yD,gp =gpar(fill='blue',lty=3,alpha=0.2))
}
)
upViewport(2)
-------------------------------------------------------------------------------------------------------
plot(NA,xlim=c(0,1),ylim=c(0,1), xaxs="i",yaxs="i") # Empty plot
a <- curve(x^2, add = TRUE) # First curve
b <- curve(2*x^2-0.2, add = TRUE) # Second curve
names(a) <- c('xA','yA')
names(b) <- c('xB','yB')
with(as.list(c(b,a)),{
    id <- yB<=yA
    # b<a area
    polygon(x = c(xB[id], rev(xA[id])),
            y = c(yB[id], rev(yA[id])), 
            density=10, angle=0, border=NULL)
    # a>b area
    polygon(x = c(xB[!id], rev(xA[!id])),
            y = c(yB[!id], rev(yA[!id])), 
            density=10, angle=90, border=NULL)
    }) plot(NA,xlim=c(0,1),ylim=c(0,1), xaxs="i",yaxs="i") # Empty plot
a <- curve(x^2, add = TRUE) # First curve
b <- curve(2*x^2-0.2, add = TRUE) # Second curve
d <- curve(0.5*x^2+0.2, add = TRUE) # Third curve

names(a) <- c('xA','yA')
names(b) <- c('xB','yB')
names(d) <- c('xD','yD')

with(as.list(c(a,b,d)),{
    # Basically you have three conditions: 
    # curve a is below curve b, curve b is below curve d and curve d is above curve a
    # assign to each curve coordinates the two conditions that concerns it.

    idA <- yA<=yD & yA<=yB
    idB <- yB>=yA & yB<=yD
    idD <- yD<=yB & yD>=yA
    polygon(x = c(xB[idB], xD[idD], rev(xA[idA])),
            y = c(yB[idB], yD[idD], rev(yA[idA])), 
            density=10, angle=0, border=NULL)
    })
-------------------------------------------------------------------------------------------------------
ggplot2 ggplot() +
  geom_polygon(data=world,aes(x=long, y=lat, group=group), fill=NA,colour="black") +
  geom_point(data=d, aes(x=longitude, y=latitude, size=value), color="red") +
  coord_map("mollweide") coord_map ggplot() +
  geom_point(data=d, aes(x=longitude, y=latitude, size=value), color="red") +
  coord_map("mollweide")
-------------------------------------------------------------------------------------------------------
makeNiceNumber = function(num, num.pretty = 1) {
   # Rounding provided by code from Maarten Plieger
   return((round(num/10^(round(log10(num))-1))*(10^(round(log10(num))-1))))
}

createBoxPolygon = function(llcorner, width, height) {
   relativeCoords = data.frame(c(0, 0, width, width, 0), c(0, height, height, 0, 0))
   names(relativeCoords) = names(llcorner)
   return(t(apply(relativeCoords, 1, function(x) llcorner + x)))
} addScaleBar = function(ggplot_obj, spatial_obj, attribute, addParams = 
list()) {
   addParamsDefaults = list(noBins = 5, xname = "x", yname = "y", unit = "m", 
        placement = "bottomright", sbLengthPct = 0.3, sbHeightvsWidth = 1/14)
   addParams = modifyList(addParamsDefaults, addParams)

   range_x = max(spatial_obj[[addParams[["xname"]]]]) - min(spatial_obj[[addParams[["xname"]]]])
   range_y = max(spatial_obj[[addParams[["yname"]]]]) -  min(spatial_obj[[addParams[["yname"]]]])
   lengthScalebar = addParams[["sbLengthPct"]] * range_x
   ## OPTION: use pretty() instead
   widthBin = makeNiceNumber(lengthScalebar / addParams[["noBins"]])
   heightBin = lengthScalebar * addParams[["sbHeightvsWidth"]]
   lowerLeftCornerScaleBar = c(x = max(spatial_obj[[addParams[["xname"]]]]) - (widthBin * addParams[["noBins"]]), y = min(spatial_obj[[addParams[["yname"]]]]))
   scaleBarPolygon = do.call("rbind", lapply(0:(addParams[["noBins"]] - 1), function(n) {
     dum = data.frame(createBoxPolygon(lowerLeftCornerScaleBar + c((n * widthBin), 0), widthBin, heightBin))
     if(!(n + 1) %% 2 == 0) dum$cat = "odd" else dum$cat = "even"
     return(dum)
   }))
   scaleBarPolygon[[attribute]] = min(spatial_obj[[attribute]])
   textScaleBar = data.frame(x = lowerLeftCornerScaleBar[[addParams[["xname"]]]] + (c(0:(addParams[["noBins"]])) * widthBin), y = lowerLeftCornerScaleBar[[addParams[["yname"]]]],
                             label = as.character(0:(addParams[["noBins"]]) * widthBin))
   textScaleBar[[attribute]] = min(spatial_obj[[attribute]])

   return(ggplot_obj +
     geom_polygon(data = subset(scaleBarPolygon, cat == "odd"), fill = "black", color = "black", legend = FALSE) +
     geom_polygon(data = subset(scaleBarPolygon, cat == "even"), fill = "white", color = "black", legend = FALSE) +
     geom_text(aes(label = label), color = "black", size = 6, data = textScaleBar, hjust = 0.5, vjust = 1.2, legend = FALSE))
} library(ggplot2)
library(sp)

data(meuse)
data(meuse.grid)
ggobj = ggplot(aes(x = x, y = y, color = zinc), data = meuse) + geom_point()
# Make sure to increase the graphic device a bit
addScaleBar(ggobj, meuse, "zinc", addParams = list(noBins = 5))
-------------------------------------------------------------------------------------------------------
grid.polygon grid lattice xyplot(0~0) plot(0) library(lattice)
library(grid)
xyplot(0~0, xlim=c(min(x),max(x)), ylim=c(min(y),max(y)),
       panel=function(...)
       {
         grid.polygon(x  = as.vector(t(x)),
                      y  = as.vector(t(y)),
                      id = rep(1:n,each=3),
                      gp=gpar(fill=cols),
                      def='native')         
       })
-------------------------------------------------------------------------------------------------------
polygon NA cuts <- function(x)
{
    n <- length(x) %/% 3

    map <- rep(c(TRUE,TRUE,TRUE,FALSE), n)

    result <- rep(NA, n*4)

    result[map] <- x

    result
}


set.seed(1234)

n <- 10000
x <- matrix(runif(3*n), n)
y <- matrix(runif(3*n), n)
cols <- heat.colors(n)[order(x[,1])]
plot(0, xlim=c(min(x),max(x)), ylim=c(min(y),max(y)))
polygon(x=cuts(t(x)), y=cuts(t(y)), col=cols)
-------------------------------------------------------------------------------------------------------
border= legend() legend() legend() density= fill= plot(1:4, 1:4, type="n", xaxt="n", xlab="", yaxt="n", ylab="")
polygon(c(2,4,2), c(1,3,3), col="gray")
polygon(c(3,3,1), c(1,3,2), col="red", density=10)
legend("topleft", legend=c("A", "B", "AB"), fill=c("gray", "red", "gray"),
       density=c(NA, 10, NA), bty="n",border=c("black", "red", "black")) 
legend("topleft", legend=c("A", "B", "AB"), fill=c("gray", "red", "red"),
       density=c(NA, 10, 10), bty="n",border=c("black", "red", "black"))
-------------------------------------------------------------------------------------------------------
rect poylygon cuts <- function(x)
{
  n <- length(x) %/% 4
  map <- rep(c(rep(TRUE,4),FALSE), n)
  result <- rep(NA, n*5)
  result[map] <- x
  result
}


n <- 2000

xbottom <- runif(n)
ybottom <- runif(n)
xtop <- xbottom+runif(n)
ytop <- ybottom+runif(n)

x <- cbind(xbottom,xbottom,xtop,xtop)
y <- cbind(ybottom,ytop,ytop,ybottom)
cols <- heat.colors(n)[order(x[,1])]
plot(0, xlim=c(min(x),max(x)), ylim=c(min(y),max(y)))
polygon(x=cuts(t(x)), y=cuts(t(y)), col=cols)
-------------------------------------------------------------------------------------------------------
col=factor(ctsubset$brgroupnum) colors() cores <- function() {

 par(mar=c(0,0,0,0),mgp=c(0,0,0))
 plot(c(0:24),type='n') 
 c <- 0

 mouse <- function(b, x, y) {
  x <- as.integer(x*26)
  y <- as.integer(y*26)
  print(colors()[(x+26*y) %% 657 + 1])
  return()
 } 
 k <- colours()[(1:26^2 - 1) %% 657 + 1]
 for (i in 1:26) {
  for (j in 1:26) {
   c <- c+1
   polygon(c(j,j,j-1,j-1),c(i,i-1,i-1,i)-1,col=k[(c-1) %% 657 + 1])
  }
 }
 getGraphicsEvent('Click on a colour!',onMouseDown=mouse)

}
cores() rainbow(11)
-------------------------------------------------------------------------------------------------------
wp <- structure(list(M.1990 = c(325814, 295272, 269351, 265163, 249651, 220027, 196523, 178295, 141789, 115097, 106579, 91763, 77150, 56845, 38053, 25716, 19442), M.2000 = c(319675, 317296, 317072, 290827, 262992, 256378, 241401, 212924, 188905, 169133, 131813, 103162, 90921, 72231, 53449, 32707, 25868), M.2010 = c(328759, 315119, 311456, 312831, 311077, 284258, 255596, 248575, 232217, 202633, 176241, 153494, 114194, 83129, 65266, 43761, 39223), F.1990 = c(308121, 281322, 257432, 254065, 238856, 211943, 188433, 170937, 138358, 112931, 106510, 93425, 82667, 67057, 47679, 37435, 36724), F.2000 = c(298455, 297012, 299757, 277706, 252924, 248127, 233583, 207518, 183646, 165444, 132307, 105429, 96681, 80227, 64956, 45832, 46413), F.2010 = c(307079, 293664, 290598, 293313, 295739, 273379, 247383, 241938, 226914, 201142, 176440, 156283, 121200, 92071, 77990, 56895, 66029)), .Names = c("M.1990", "M.2000", "M.2010", "F.1990", "F.2000", "F.2010"), row.names = c("0-4", "5-9", "10-14", "15-19", "20-24", "25-29", "30-34", "35-39", "40-44", "45-49", "50-54", "55-59", "60-64", "65-69", "70-74", "75-79", "80+"), class = "data.frame")

wp
      M.1990 M.2000 M.2010 F.1990 F.2000 F.2010
0-4   325814 319675 328759 308121 298455 307079
5-9   295272 317296 315119 281322 297012 293664
10-14 269351 317072 311456 257432 299757 290598
15-19 265163 290827 312831 254065 277706 293313
20-24 249651 262992 311077 238856 252924 295739
25-29 220027 256378 284258 211943 248127 273379
30-34 196523 241401 255596 188433 233583 247383
35-39 178295 212924 248575 170937 207518 241938
40-44 141789 188905 232217 138358 183646 226914
45-49 115097 169133 202633 112931 165444 201142
50-54 106579 131813 176241 106510 132307 176440
55-59  91763 103162 153494  93425 105429 156283
60-64  77150  90921 114194  82667  96681 121200
65-69  56845  72231  83129  67057  80227  92071
70-74  38053  53449  65266  47679  64956  77990
75-79  25716  32707  43761  37435  45832  56895
80+    19442  25868  39223  36724  46413  66029

xrange <- range(c(0,wp))
yrange <- range(c(0,nrow(wp))) par(mfcol=c(1,2))
par(mar=c(5,4,4,0))
plot(NA,type="n", main="Men", xlab="", ylab="", xaxs="i", 
     xlim=rev(xrange), ylim=yrange, axes=FALSE, yaxs="i")
rect(xrange[1],yrange[1],xrange[2],yrange[2], col="cadetblue")
abline(v=seq(0,xrange[2],by=1e5), col="white")
# All years with bars you want to represent filled 
# should be entered in reverse order
polygon(c(0,rep(wp$M.2000,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)),
        col="lightblue",border="lightblue")
polygon(c(0,rep(wp$M.1990,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)), 
        col="darkblue",border="darkblue")
# And those you want with just a border, afterwards:
polygon(c(0,rep(wp$M.2010,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)), 
        col=NA,border="darkred",lwd=2)
axis(1, at=c(0,1e5,2e5,3e5), labels=format(c(0,1e5,2e5,3e5),scientific=FALSE))
axis(2, at=1:nrow(wp)-0.5,labels=row.names(wp),las=2)
box()

par(mar=c(5,0,4,4))
plot(NA,type="n", main="Women", xlab="", ylab="", xaxs="i", 
     xlim=xrange, ylim=yrange, axes=FALSE, yaxs="i")
rect(xrange[1],yrange[1],xrange[2],yrange[2], col="cadetblue")
abline(v=seq(0,xrange[2],by=1e5), col="white")
polygon(c(0,rep(wp$F.2000,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)),
        col="lightblue",border="lightblue")
polygon(c(0,rep(wp$F.1990,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)), 
        col="darkblue",border="darkblue")
polygon(c(0,rep(wp$F.2010,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)), 
        col=NA,border="darkred",lwd=2)
axis(1, at=c(0,1e5,2e5,3e5), labels=format(c(0,1e5,2e5,3e5),scientific=FALSE))
axis(4, at=1:nrow(wp)-0.5,labels=row.names(wp),las=2)
box() library(scales)
[...]
polygon(c(0,rep(wp$M.1990,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)), 
        col=alpha("darkblue",0.4),border="darkblue")
[...]
polygon(c(0,rep(wp$F.1990,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)), 
        col=alpha("darkblue",0.4),border="darkblue")
[...]
-------------------------------------------------------------------------------------------------------
# fix the data because we're going to use it twice:
d=sample(data)
# plot it with X and Y coords known (note 1 larger than dimension)
image(1:51,1:3,matrix(d,nrow=50, ncol=2),las=1)
# add diagonal shading
polygon(x=c(1,51,51,1),y=c(1,1,3,3),density=3,col="red")
# replot. The NA's show through:
image(1:51,1:3,matrix(d,nrow=50, ncol=2),las=1,add=TRUE)
# outline the cells.
abline(h=1:3)
abline(v=1:51) x0=c(1:50,1:50)
x1=x0+1
y0=c(rep(1,50),rep(2,50))
y1=y0+1
image(1:51,1:3,matrix(d,nrow=50, ncol=2),las=1)
segments(x0,y0,x1,y1,col="red",lwd=2)
image(1:51,1:3,matrix(d,nrow=50, ncol=2),las=1,add=TRUE)
abline(v=1:51);abline(h=1:3)
-------------------------------------------------------------------------------------------------------
(0, 0) -- (0, 1) -- (1, 1) polygon(c(0, 0, 1), c(0, 1, 1), col='pink')
-------------------------------------------------------------------------------------------------------
x <- seq(0, 1, by=0.2)
plot(  x, x,   type="l" )
lines( x, x^2, col="red" )
xx1 <- c(0,x[x<1  & x>0 ],1,x[x<1  & x>0 ],0)
yy1 <- c(0,x[x<1  & x>0 ],1,x[x<1  & x>0 ]^2,0)
polygon(xx1, yy1, lwd=3, col="wheat")
points(xx1, yy1) xx1 plot(  x, x,   type="l" )
lines( x, x^2, col="red" )
xx1 <- c(x, rev(x))
yy1 <- c(x, rev(x)^2)
polygon(xx1, yy1, lwd=3, col="wheat")
-------------------------------------------------------------------------------------------------------
contour contourLines polygon plot(datax[,1], datax[,2],axes=FALSE,ann=FALSE, type="n")
box()
cL <- contourLines(xp, yp, zM,nlevels = 1)
lapply(cL,function(x)polygon(x$x,x$y,col="red"))
points(datax[,1], datax[,2],pch = datay+1) library(splancs)
ord <- sapply(lapply(cL,function(x)datay[inout(datax,cbind(x$x,x$y))]),
              median) #Check what values are present in the polygon and 
                      #take the most common one
plot(datax[,1], datax[,2],axes=FALSE,ann=FALSE, type="n")
box()
lapply(cL[ord==1],function(x)polygon(x$x,x$y,col="blue"))
lapply(cL[ord==0],function(x)polygon(x$x,x$y,col="white"))
points(datax[,1], datax[,2],pch = datay+1) image image(xp, yp, zM, col=c("transparent","blue"))
points(datax[,1], datax[,2],pch = datay+1)
-------------------------------------------------------------------------------------------------------
draw.circle plotrix > draw.circle
function (x, y, radius, nv = 100, border = NULL, col = NA, lty = 1, 
    lwd = 1) 
{
    xylim <- par("usr")
    plotdim <- par("pin")
    ymult <- (xylim[4] - xylim[3])/(xylim[2] - xylim[1]) * plotdim[1]/plotdim[2]
    angle.inc <- 2 * pi/nv
    angles <- seq(0, 2 * pi - angle.inc, by = angle.inc)
    if (length(col) < length(radius)) 
        col <- rep(col, length.out = length(radius))
    for (circle in 1:length(radius)) {
        xv <- cos(angles) * radius[circle] + x
        yv <- sin(angles) * radius[circle] * ymult + y
        polygon(xv, yv, border = border, col = col[circle], lty = lty, lwd = lwd)
    }
    invisible(list(x = xv, y = yv))
}
<environment: namespace:plotrix> nv draw.circle radius polygon border col lty lwd + x * x y for x x y
-------------------------------------------------------------------------------------------------------
plotrix::draw.circle() ## <- library("plotrix")

draw.circle.loglog <- 
function (x, y, radius, nv = 100, border = NULL, col = NA, lty = 1,
    lwd = 1)
{
    xylim <- par("usr")
    plotdim <- par("pin")
    ymult <- (xylim[4] - xylim[3])/(xylim[2] - xylim[1]) * plotdim[1]/plotdim[2]
    angle.inc <- 2 * pi/nv
    angles <- seq(0, 2 * pi - angle.inc, by = angle.inc)
    if (length(col) < length(radius))
        col <- rep(col, length.out = length(radius))
    for (circle in 1:length(radius)) {
        xv <- exp(cos(angles) * log(radius[circle])) * x[circle]         ## <-
        yv <- exp(sin(angles) * ymult * log(radius[circle])) * y[circle] ## <-
        polygon(xv, yv, border = border, col = col[circle], lty = lty,lwd = lwd)
    }
    invisible(list(x = xv, y = yv))
}

# Try it out 
x = 10^(-1 * c(5:0))
y = x ^-1.5

plot (x, y, log="xy", type="o")
draw.circle.loglog(x = c(1e-2, 1e-3, 1e-4), y = c(1e2, 1e6, 1e2),
                   radius = c(2,4,8), col = 1:3)
-------------------------------------------------------------------------------------------------------
coord_map ggplot(new_data, aes(x=long, y=lat, group=group)) + geom_polygon() +
         coord_map(proj="azequalarea") Settings > Project Properties... WGS 84
-------------------------------------------------------------------------------------------------------
ggsubplot library(ggsubplot)
library(ggplot2)
library(maps)
library(plyr)

#Get world map info
world_map <- map_data("world")

#Create a base plot
p <- ggplot()  + geom_polygon(data=world_map,aes(x=long, y=lat,group=group))

# Calculate the mean longitude and latitude per region, these will be the coördinates where the plots will be placed, so you can tweak them where needed.
# Create simulation data of the age distribution per region and merge the two.

centres <- ddply(world_map,.(region),summarize,long=mean(long),lat=mean(lat))
mycat <- cut(runif(1000), c(0, 0.1, 0.3, 0.6, 1), labels=FALSE) 
mycat <- as.factor(mycat)
age <- factor(mycat,labels=c("<15","15-30","20-60",">60"))
simdat <- merge(centres ,age)
colnames(simdat) <- c( "region","long","lat","Age" )

# Select the countries where you want a subplot for and plot
simdat2 <- subset(simdat, region %in% c("USA","China","USSR","Brazil", "Australia"))
(testplot <- p+geom_subplot2d(aes(long, lat, subplot = geom_bar(aes(Age, ..count.., fill = Age))), bins = c(15,12), ref = NULL, width = rel(0.8), data = simdat2))
-------------------------------------------------------------------------------------------------------
joinPolys PBSmapping library(PBSmapping)
p1 <- data.frame(PID=rep(1, 4), POS=1:4, X=c(1,1,6,6), Y=c(1,3,3,1))
p2 <- data.frame(PID=rep(2, 5), POS=1:5, X=c(4,4,8,8,6), Y=c(2,4,4,2,1))
p3 <- joinPolys(p1,p2)
x11()
par(mar=c(3,3,1,1))
plot(1,1,ylim=c(0,5),xlim=c(0,9), t="n", xlab="", ylab="")
polygon(p1$X, p1$Y, border=2)
polygon(p2$X, p2$Y)
polygon(p3$X, p3$Y, col=rgb(0,0,1,0.2))
-------------------------------------------------------------------------------------------------------
png mean=100; sd=15
lb=80; ub=120

x <- seq(-4,4,length=100)*sd + mean
hx <- dnorm(x,mean,sd)

# load package and an image
library(png)
ima <- readPNG("Red_Hot_Sun.PNG")

# plot an empty plot with your labels, etc.
plot(1,xlim=c(min(x),max(x)), type="n", xlab="IQ Values", ylab="Density",
  main="Normal Distribution", axes=FALSE)
# put in the image
lim <- par()
rasterImage(ima, lim$usr[1], lim$usr[3], lim$usr[2], lim$usr[4])

# add your plot
par(new=TRUE)
plot(x, hx, xlim=c(min(x),max(x)), type="l", xlab="", ylab="", axes=FALSE)
i <- x >= lb & x <= ub
lines(x, hx)
# add a polygon to cover the background above plot
polygon(c(x,180,180,20,20), c(hx,0,1,1,0), col="white")
# add polygons to cover the areas under the plot you don't want visible
polygon(c(-20,-20,x[x<=lb],lb), c(-10,min(hx),hx[x<=lb],-10), col="white")
polygon(c(ub,x[x>=ub],200,200), c(-1,hx[x>=ub],min(hx),-1), col="white")

# add your extra text
area <- pnorm(ub, mean, sd) - pnorm(lb, mean, sd)
result <- paste("P(",lb,"< IQ <",ub,") =",
   signif(area, digits=3))
mtext(result,2)
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(data.table)
# You have to set the seed _before_ you generate random data, not after
set.seed(1) 
dt <- data.table(xdata=runif(15), ydata=runif(15), level=rep(c("a","b","c"), each=5),
  key="level") hulls <- dt[, .SD[chull(xdata, ydata)], by = level] ggplot(dt,aes(x=xdata,y=ydata,color=level)) +
    geom_point() +
    geom_polygon(data = hulls,aes(fill=level,alpha = 0.5)) chull .SD[...] data.table level
-------------------------------------------------------------------------------------------------------
by length x x sigma <- 1
mu    <- 0

lower.x <- -0.0
upper.x <-  2.1

x  <- seq(-4, 4, by = 0.1)
y  <- ( 1/(sigma * sqrt(2*pi)) ) * ( exp(1)^( (-1 * ((x - mu)^2)) / (2*(sigma^2)) ) )
plot(x,y,type="l", lwd=2, col="blue")

x=seq(lower.x, upper.x, by = 0.1)
y  <- ( 1/(sigma * sqrt(2*pi)) ) * ( exp(1)^( (-1 * ((x - mu)^2)) / (2*(sigma^2)) ) )
polygon(c(lower.x,x,upper.x), c(0,y,0), col="gray")
lines(x, y, col="blue", lwd=2)
-------------------------------------------------------------------------------------------------------
lower.x <- 0
upper.x <- 2.1
step <- (upper.x - lower.x) / 100
sigma <- 1
mu <- 0
bounds <- c(mu-3*sigma, mu+3*sigma)
cord.x <- c(lower.x,seq(lower.x,upper.x,step),upper.x)
cord.y <- c(0,dnorm(seq(lower.x,upper.x,step),mu,sigma),0)
curve(dnorm(x,mu,sigma),xlim=bounds) 
polygon(cord.x,cord.y,col='skyblue')
-------------------------------------------------------------------------------------------------------
data aes ggplot geom_* ggplot() +
  geom_polygon(data=world.points,aes(long,lat,group=group)) +
  geom_point(data=world.points,aes(long,lat,group=group)) +

  # Separately, I'm not sure what the intended outcome is for this histogram, but it doesn't appear to be of a correct form 
  geom_histogram(data=tmp,aes(Lon3,Lat3),alpha=0.01,size=1) +
  coord_map() + 
  ylim(-90,90) ggplot(.) data geom_* mapping geom_point(data=myDataFrame, .) # You can always check the arguments by using the `args(.)` function

> args(ggplot)
function (data = NULL, ...) 
NULL

> args(geom_polygon)
function (mapping = NULL, data = NULL, stat = "identity", position = "identity", ...) 
NULL

> args(geom_histogram)
function (mapping = NULL, data = NULL, stat = "bin", position = "stack", ...) 
NULL
-------------------------------------------------------------------------------------------------------
geom xx.sub1.df geom geom_point p <- ggplot(xx.sub2.df) + 
  aes(long, lat, fill = (SID79/BIR79)*1000, group = group) + 
  geom_polygon() + geom_path(color="grey80") +
  coord_equal() + 
  scale_fill_gradientn(colours = brewer.pal(7, "YlOrBr")) +
  geom_polygon(data = xx.sub1.df, fill = "grey50") + 
  geom_path(data = xx.sub1.df, color="grey80") +
  labs(fill = "Mapped value", title = "Title")

#Now we add geom_point() setting shape as NA, but the colour as "grey50", so the 
#legend will be displaying the right colour

p2 <- p + geom_point(data = xx.sub1.df, aes(size="xx.sub1", shape = NA), colour = "grey50") p2 + guides(size=guide_legend("Source", override.aes=list(shape=15, size = 10)))
-------------------------------------------------------------------------------------------------------
geom_path ggplot( wip_map, aes( x = long , y = lat , group=group ) ) +
        geom_polygon( colour = "grey" , aes( fill = factor( CATEGORY ) ) ) +
        scale_fill_manual( values = pal ) +
        expand_limits( x = wip_map$long, y = wip_map$lat ) +
        coord_map( "polyconic" ) + 
        labs(fill="Number Per\nCounty") + 
        theme_clean( ) +
        geom_path( data = state_map , colour = "red")
-------------------------------------------------------------------------------------------------------
readOGR rgdal require(rgdal)

in.dir <- "your_directory_name"

sh <- readOGR(in.dir, layer = "highdist_n83")
sh@proj4string # note projection details
sh2 <- spTransform(sh, CRS("+proj=longlat +datum=WGS84"))
sh2@proj4string # and after transforming
plot(sh2) > sh@proj4string # note projection details
CRS arguments:
 +proj=utm +zone=4 +datum=NAD83 +units=m +no_defs +ellps=GRS80
+towgs84=0,0,0 > sh2@proj4string # and after transforming
CRS arguments:
 +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 ggplot2 # Plotting with ggplot - first transform shapefile to data frame
sh2.df <- fortify(sh2)

# Fake address data taken from Google maps
add <- data.frame(name = c("University of Hawaii", "Mokuleia Beach Park"),
                      lat = c(21.298971, 21.580508),
                      long = c(-157.817722, -158.191017))

# And plot
ggplot(data = sh2.df, aes(x = long, y = lat, group = group)) +
     geom_polygon(colour = "grey20", fill = "white", size = 0.8) +
     geom_point(data = add, size = 3, aes(x = long, y = lat, group = NULL), pch = 21, fill = "red") +
     coord_equal() +
     theme()
-------------------------------------------------------------------------------------------------------
geom_polygon data.frame geom_polygon RColorBrewer brewer.pal require(RColorBrewer)
shape2@data$id <- rownames(shape2@data)
sh.df <- as.data.frame(shape2)
sh.fort <- fortify(shape2 , region = "id" )
sh.line<- join(sh.fort, sh.df , by = "id" )


mapdf <- merge( sh.line , data.2 , by.x= "NAME", by.y="NAME" , all=TRUE)
mapdf <- mapdf[ order( mapdf$order ) , ]

ggplot( mapdf , aes( long , lat ) )+
  geom_polygon( aes( fill = cans , group = id ) , colour = "black" )+
  scale_fill_gradientn( colours = brewer.pal( 9 , "Reds" ) )+
  coord_equal()
-------------------------------------------------------------------------------------------------------
ll <- lapply(LETTERS[1:4],function(let){
  dat.let <- dat[,grepl(let,colnames(dat))]
  dd <- reshape(dat.let,direction ='long',
                v.names=c('TimeVariable','Variable'),
                varying=1:6)
  dd$time <- factor(dd$time)
  dd$Type <- let
  dd
}
) head(ll[[1]])
 time TimeVariable Variable id Type
1.1    1            0        0  1    A
2.1    1            0        5  2    A
3.1    1            8      110  3    A
4.1    1           16        0  4    A
5.1    1           NA       NA  5    A
6.1    1           NA       NA  6    A layout(matrix(1:4, 2, 2, byrow = TRUE))
lapply(ll,function(data){
  label1=c(0,100,200,300)
  Type <- unique(dat$Type)
  dat <- subset(data,time==2)
  x.mm <- max(dat$Variable,na.rm=TRUE)
  plot(dat$TimeVariable,dat$Variable,axes=FALSE,ylab="",xlab="",xlim=c(0,x.mm),
       ylim=c(0,2.4),xaxs="i",yaxs="i",pch=19)
  dat <- subset(data,time==2)
  lines(dat$TimeVariable,dat$Variable)
  axis(2,tick=T,at=seq(0.0,2.4,by=0.6),label= seq(0.0,2.4,by=0.6))
  axis(1,tick=T,at=seq(0,x.mm,by=6),label=seq(0,x.mm,by=6))
  mtext(Type,side=1,outer=F,line=-10,adj=0.8)
  minor.tick(nx=5,ny=5)
  par(new=TRUE)
  dat <- subset(data,time==1)
  plot(dat$TimeVariable,dat$Variable,axes=FALSE,xlab="",ylab="",type="l",
       ylim=c(800,0),xaxs="i",yaxs="i")
  axis(3,xlim=c(0,24),tick=TRUE,at= seq(0,24,by=6),label=seq(0,24,by=6),col.axis="violetred4",col="violetred4")
  axis(4,tick=TRUE,at= label1,label=label1,col.axis="violetred4",col="violetred4")
  polygon(dat$TimeVariable,dat$Variable,col='violetred4',border=NA)
}) `ggplot2 facet_wrap ## transform your data to a data.frame
 dat.l <- do.call(rbind,ll)
 library(ggplot2)
 ggplot(subset(dat.l,time !=1)) +
  geom_line(aes(x=TimeVariable,y=Variable,group=time,color=time))+
  geom_polygon(data=subset(dat.l,time ==1),
              aes(x=TimeVariable,y=60-Variable/10,fill=Type))+
  geom_line(data=subset(dat.l,time ==1),
               aes(x=TimeVariable,y=Variable,fill=Type))+
  facet_wrap(~Type,scales='free')
-------------------------------------------------------------------------------------------------------
data <- read.csv("stackfig1_2.csv")
library(Hmisc)

label1=c(0,100,200,300)
plot(data$TimeVariable2C,data$Variable2C,axes=FALSE,ylab="",xlab="",xlim=c(0,24),
     ylim=c(0,2.4),xaxs="i",yaxs="i",pch=19)
lines(data$TimeVariable3C,data$Variable3C)
axis(2,tick=T,at=seq(0.0,2.4,by=0.6),label= seq(0.0,2.4,by=0.6))
axis(1,tick=T,at=seq(0,24,by=6),label=seq(0,24,by=6))
mtext("(C)",side=1,outer=F,line=-10,adj=0.8)
minor.tick(nx=5,ny=5)

par(new=TRUE)
plot(data$TimeVariable1C,data$Variable1C,axes=FALSE,xlab="",ylab="",type="l",
     ylim=c(800,0),xaxs="i",yaxs="i")
axis(3,xlim=c(0,24),tick=TRUE,at= seq(0,24,by=6),label=seq(0,24,by=6),col.axis="violetred4",col="violetred4")
axis(4,tick=TRUE,at= label1,label=label1,col.axis="violetred4",col="violetred4")
polygon(data$TimeVariable1C,data$Variable1C,col='violetred4',border=NA)


legend("top", legend = c("Variable A","Variable B","Variable C"), col = c("black","violetred4","black"),
       ncol = 2, lwd =c("","",2),pch=c(19,15,NA),cex=1) cex
-------------------------------------------------------------------------------------------------------
doubleYScale latticeExtra doubleYScale library(latticeExtra)
obj1 <- xyplot(Variable~TimeVariable|Type,type='l',
               groups=time,               scales=list(x=list(relation='free'),
                                                      y=list(relation='free')),
               auto.key=list(columns = 3,lines = TRUE,points=FALSE) ,

       data = subset(dat.l,time !=1))
obj2 <- xyplot(Variable~TimeVariable|Type,
               data = subset(dat.l,time ==1),type='l',
               scales=list(x=list(alternating=2),
                           auto.key=list(columns = 3,lines = TRUE,points=FALSE),
                           y=list(relation='free')),
               panel=function(x,y,...){
         panel.xyplot(x,y,...)
         panel.polygon(x,y,col='violetred4',border=NA,alpha=0.3)
               })


doubleYScale(obj1, obj2, add.axis = TRUE,style1 = 0, style2 = 1)
-------------------------------------------------------------------------------------------------------
x <- seq_along(y)
y2 <- rep(y, each=2)
y2 <- y2[-length(y2)]
x2 <- rep(x, each=2)[-1]
x3 <- c(min(x2), x2, max(x2))
y3 <- c(0, y2, 0)

# because polygon() is dumb and wants a pre-existing plot
plot(x, y, ylim=c(0, max(y)), type="n")

polygon(x3, y3, border=NA, col="grey")
lines(x2, y2)
-------------------------------------------------------------------------------------------------------
Lattice set.seed(1)
xx <- c(1:10)
yy <- abs(rnorm(10))

library(lattice)
xyplot(yy~xx,type='s',
       panel=function(x,y,...){
         panel.xyplot(x,y,...)
         y2 <- rep(y, each=2)
         y2 <- y2[-length(y2)]
         x2 <- rep(x, each=2)[-1]
         x3 <- c(min(x2), x2, max(x2))
         y3 <- c(0, y2, 0)
         panel.polygon(x3, y3,col=rgb(1, 0, 0,0.5), border=NA)

       })
-------------------------------------------------------------------------------------------------------
plot(c(1,20), c(0,3), type="n")
xx <- c(0,1,1,0)
thelabels <- paste(1:20, " ", LETTERS[1:20], LETTERS[1:20], sep="")
for (i in 1:20){
  polygon(xx, c(0,0,1,1))
  text(mean(xx), 0.5, i)
  xx <- xx + 1
}
legend("topleft", "groups", 
       legend = thelabels, pch="",
       ncol=4)
-------------------------------------------------------------------------------------------------------
ggplot2 boxplot bxp xypolygon my.bxp <- function (all.bxp.argument,angle,density, ...) {
    .....#### bxp code
    xypolygon(xx, yy, lty = boxlty[i], lwd = boxlwd[i], 
    border = boxcol[i],angle[i],density[i])  
    .......## bxp code after
    xypolygon(xx, yy, lty = "blank", col = boxfill[i],angle[i],density[i])      
    ......

} require(stats)
set.seed(753)
(bx.p <- boxplot(split(rt(100, 4), gl(5, 20))))
layout(matrix(c(1,2),nrow=1),
       width=c(4,1)) 
angles=c(60,30,40,50,60)
densities=c(50,30,40,50,30)
par(mar=c(5,4,4,0)) #Get rid of the margin on the right side
my.bxp(bx.p,angle=angles,density=densities)
par(mar=c(5,0,4,2)) #No margin on the left side
plot(c(0,1),type="n", axes=F, xlab="", ylab="")
legend("top", paste("region", 1:5),
       angle=angles,density=densities)
-------------------------------------------------------------------------------------------------------
boxplot.stats polygon boxpattern <- 
function(y, xcenter, boxwidth, angle=NULL, angle.density=10, ...) {
    # draw an individual box
    bstats <- boxplot.stats(y)
    bxmin <- bstats$stats[1]
    bxq2 <- bstats$stats[2]
    bxmedian <- bstats$stats[3]
    bxq4 <- bstats$stats[4]
    bxmax <- bstats$stats[5]
    bleft <- xcenter-(boxwidth/2)
    bright <- xcenter+(boxwidth/2)
    # boxplot
    polygon(c(bleft,bright,bright,bleft,bleft),
        c(bxq2,bxq2,bxq4,bxq4,bxq2), angle=angle[1], density=angle.density)
    polygon(c(bleft,bright,bright,bleft,bleft),
        c(bxq2,bxq2,bxq4,bxq4,bxq2), angle=angle[2], density=angle.density)
    # lines
    segments(bleft,bxmedian,bright,bxmedian,lwd=3) # median
    segments(bleft,bxmin,bright,bxmin,lwd=1) # min
    segments(xcenter,bxmin,xcenter,bxq2,lwd=1)
    segments(bleft,bxmax,bright,bxmax,lwd=1) # max
    segments(xcenter,bxq4,xcenter,bxmax,lwd=1)
    # outliers
    if(length(bstats$out)>0){
        for(i in 1:length(bstats$out))
            points(xcenter,bstats$out[i])
    }
}

drawboxplots <- function(y, x, boxwidth=1, angle=NULL, ...){
    # figure out all the boxes and start the plot
    groups <- split(y,as.factor(x))
    len <- length(groups)
    bxylim <- c((min(y)-0.04*abs(min(y))),(max(y)+0.04*max(y)))
    xcenters <- seq(1,max(2,(len*(1.4))),length.out=len)
    if(is.null(angle)){
        angle <- seq(-90,75,length.out=len)
        angle <- lapply(angle,function(x) c(x,x))
    }
    else if(!length(angle)==len)
        stop("angle must be a vector or list of two-element vectors")
    else if(!is.list(angle))
        angle <- lapply(angle,function(x) c(x,x))
    # draw plot area
    plot(0, xlim=c(.97*(min(xcenters)-1), 1.04*(max(xcenters)+1)),
        ylim=bxylim, 
        xlab="", xaxt="n",
        ylab=names(y), 
        col="white", las=1)

    axis(1, at=xcenters, labels=names(groups))
    # draw boxplots
    plots <- mapply(boxpattern, y=groups, xcenter=xcenters,
        boxwidth=boxwidth, angle=angle, ...)
} mydat <- data.frame(y=c(rnorm(200,1,4),rnorm(200,2,2)),
                    x=sort(rep(1:2,200)))
drawboxplots(mydat$y, mydat$x) mydat <- data.frame(y=c(rnorm(200,1,4),rnorm(200,2,2),
                        rnorm(200,3,3),rnorm(400,-2,8)),
                    x=sort(rep(1:5,200)))
drawboxplots(mydat$y, mydat$x) drawboxplots(mydat$y, mydat$x, boxwidth=.5, angle.density=30) drawboxplots(mydat$y, mydat$x, # specify list of two-element angle parameters
             angle=list(c(0,0),c(90,90),c(45,45),c(45,-45),c(0,90))) x <- rep(1:10,10)
y <- sort(x)
plot(y~x, xlim=c(0,11), ylim=c(0,11), pch=20)
outerbox.x <- c(2.5,0.5,10.5,10.5,0.5,0.5,2.5,7.5,7.5,2.5)
outerbox.y <- c(2.5,0.5,0.5,10.5,10.5,0.5,2.5,2.5,7.5,7.5)
polygon(outerbox.x,outerbox.y, col="white", border="white") # donut
polygon(c(2.5,2.5,7.5,7.5,2.5),c(2.5,2.5,2.5,7.5,7.5)) # inner box
-------------------------------------------------------------------------------------------------------
ggplot fill_brewer <- function(fill, palette) {
  require(RColorBrewer)
  n <- brewer.pal.info$maxcolors[palette == rownames(brewer.pal.info)]
  discrete.fill <- call("quantcut", match.call()$fill, q=seq(0, 1, length.out=n))
  list(
    do.call(aes, list(fill=discrete.fill)),
    scale_fill_brewer(palette=palette)
  )
} ggplot(mydata) + aes(long,lat,group=group) + geom_polygon() +
  fill_brewer(fill=fill_continuous, palette="PuOr")
-------------------------------------------------------------------------------------------------------
grid.arrange(arrangeGrob(dataleg, pvalleg, nrow=1, ncol=2, widths=c(unit(1, "npc"), unit(5, "cm"))), stat, nrow=2, heights=c(unit(.2, "npc"), unit(.8, "npc"))) h <- ggplot(data.frame(a=rnorm(10), b=rnorm(10), c=factor(rbinom(10, 1,.5), labels=c("Gene segments", "Model")), d=factor("")), 
        aes(x=a, y=b)) +
   geom_line(aes(color=c), size=1.3) + geom_polygon(aes(fill=d)) +
   scale_color_manual(values=c("blue", "red"), name="Data type") + 
   scale_fill_manual(values="gray", name="P-value") 
 g_legend<-function(a.gplot){
   tmp <- ggplot_gtable(ggplot_build(a.gplot))
   leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
   legend <- tmp$grobs[[leg]]
   return(legend)
 }
 legend <- g_legend(h)

 grid.arrange(stat, legend, nrow=1, ncol=2, widths=c(unit(.8, "npc"), unit(.2, "npc")))
 grid.arrange(legend, stat, nrow=2, ncol=1, heights=c(unit(.2, "npc"), unit(.8, "npc")))
-------------------------------------------------------------------------------------------------------
env <- environment()   

        print(ggmap(map, base_layer = ggplot(data = poa, aes(x = LON, y = LAT), environment=env), extent = "normal", maprange = FALSE, environment=environment()) +
                  geom_polygon(data = poa, aes(x = LON, y = LAT), alpha = .5, colour = "black", fill = NA, environment=env) +   
                  coord_map(projection = "mercator", 
                            xlim = c(attr(map, "bb")$ll.lon, attr(map, "bb")$ur.lon),
                            ylim = c(attr(map, "bb")$ll.lat, attr(map, "bb")$ur.lat))) group = order poa env poa geom_polygon ggplot environment=env ggmap environment=environment() env
-------------------------------------------------------------------------------------------------------
polygon workingtime$s <- as.numeric( gsub( ":.*", "", workingtime$TIME_START ) ) + as.numeric( gsub( ".*:", "", workingtime$TIME_START ) ) / 60
workingtime$e <- as.numeric( gsub( ":.*", "", workingtime$TIME_END ) ) + as.numeric( gsub( ".*:", "", workingtime$TIME_END ) ) / 60
plot( NULL, xlim= c( 0.5, 7.5 ), ylim= c( 24, 0 ), xaxt= "n", xlab= "Week", ylab= "Hour" )
axis( 1, at=seq( 0.5, 7.5 ), labels= rep( "", 8 ) )
workingtime$day <- as.numeric( factor( workingtime$DATE ) )
for( i in 1:nrow( workingtime ) ) { 
  x <- c( -0.5, 0.5, 0.5, -0.5 ) + workingtime[i, "day"]
  y <- rep( c( workingtime[i,"s"], workingtime[i,"e"] ), each= 2 )
  polygon( x, y, col= workingtime[i,"SHIFT"]  ) 
} strptime strftime as.Date
-------------------------------------------------------------------------------------------------------
inpip splancs library(splancs)

set.seed(123)
my.shape <- matrix(runif(10), 5)
my.points <- data.frame(x=runif(500), y=runif(500))
my.points$in.shape <- 1:500 %in% inpip(my.points, my.shape)

plot(my.points[1:2], col=1 + my.points$in.shape)
polygon(my.shape) lapply set.seed(127)
multi.shapes <- lapply(1:3, function(...) matrix(runif(6), 3))
my.points$in.multi.shapes <- 1:500 %in%
    unlist(lapply(multi.shapes, function(p) inpip(my.points, p)))
plot(my.points[1:2], col=1 + my.points$in.multi.shapes)
for(p in multi.shapes) polygon(p)
-------------------------------------------------------------------------------------------------------
panel.polygon library(maptools)
a <- matrix(rnorm(360*180),nrow=360,ncol=180) #Some random data (=your airtemp)
b <- readShapeSpatial("110-m_land.shp") #I used here a world map from Natural Earth. lb <- as(b, "SpatialPolygons")
llb <- slot(lb, "polygons")
B <- lapply(llb, slot, "Polygons") #At this point we have a list of SpatialPolygons
coords <- matrix(nrow=0, ncol=2)
for (i in seq_along(B)){
    for (j in seq_along(B[[i]])) {
        crds <- rbind(slot(B[[i]][[j]], "coords"), c(NA, NA)) #the NAs are used to separate the lines
        coords <- rbind(coords, crds)
        }
    }
coords[,1] <- coords[,1]+180 # Because here your levelplot will be ranging from 0 to 360°
coords[,2] <- coords[,2]+90 # and 0 to 180° instead of -180 to 180 and -90 to 90 levelplot(a, panel=function(...){
                        panel.levelplot(...)
                        panel.polygon(coords)}) panel ?xyplot levelplot base image(seq(-180,180,by=1),seq(-90,90,by=1),a)
plot(b, add=TRUE)
-------------------------------------------------------------------------------------------------------
lattice panel function xyplot geom_point panel.abline geom_abline grid.polygon geom_polygon panel.loess stat_smooth panel.arrows geom_errobar panel.arrows(x.bar, ybar.hat$fit + ybar.hat$se.fit * 
      t.quant, x.bar, ybar.hat$fit - ybar.hat$se.fit * 
      t.quant, col = "darkgrey", length = 0.05, angle = 90, 
      code = 3) dat.arrow <- data.frame(x=x.bar, ymax= ybar.hat$fit + ybar.hat$se.fit * 
             t.quant, ymin= ybar.hat$fit - ybar.hat$se.fit * 
             t.quant)
 pl <- pl +  geom_errorbar(data=dat.arrow, aes(x,ymin=ymin,ymax=ymax),
              col = "darkgrey", width = 0.10) equivalence.ggplot equivalence.xyplot equivalence.ggplot <- function(x,y, alpha, b0.ii, b1.ii,
                               b0.absolute = FALSE,add.smooth=FALSE){
  x.bar <- mean(x, na.rm = TRUE)
  min.x <- min(x, na.rm = TRUE)
  max.x <- max(x, na.rm = TRUE)
  the.model <- lm(y ~ x)

  if (b0.absolute) 
    y.poly <- x.bar + b0.ii * c(-1, 1, 1, -1)
  else y.poly <- x.bar * (1 + b0.ii * c(-1, 1, 1, -1))
  dat.poly <- data.frame(x = c(min.x, min.x, max.x, max.x), 
                         y = y.poly)
  dat <- data.frame(x,y)
  p <- function(dat,dat.poly){
    h <- ggplot(dat) +
    geom_polygon(data=dat.poly,aes(x,y),col = "light gray", fill = gray(0.9)) +
    geom_point(aes(x,y)) +
    stat_smooth(data=dat,col='black',
                  aes(x=x,y=y),method="lm", se=FALSE,
                  fullrange =TRUE)+

    theme_bw()
    if (add.smooth) 
      h <- h +  geom_smooth(aes(x,y),method='loess')
    h
  }
  pl <- p(dat,dat.poly)

  n <- sum(complete.cases(cbind(x, y)))
  ybar.hat <- predict(the.model, newdata = data.frame(x = x.bar), 
                      se = TRUE)
  t.quant <- qt(1 - alpha/2, df.residual(the.model))
  dat.arrow <- data.frame(x=x.bar, ymax= ybar.hat$fit + ybar.hat$se.fit * 
                 t.quant, ymin= ybar.hat$fit - ybar.hat$se.fit * 
                 t.quant)
  pl <- pl + 
    geom_errorbar(data=dat.arrow, aes(x,ymin=ymin,ymax=ymax),
                  col = "darkgrey", width = 0.10)
  pl

  se.slope <- coef(summary(the.model))[2, 2]
  dat.arrow1 <- data.frame(x=x.bar, ymax=  ybar.hat$fit + se.slope * t.quant * 
                             x.bar, ymin=ybar.hat$fit - se.slope * t.quant * 
                             x.bar)

  pl <- pl + 
    geom_errorbar(data=dat.arrow1, aes(x,ymin=ymin,ymax=ymax),
                  col = "black", width = 0.10)
  addLines <- function(pl,the.model){
  pl <- pl + geom_abline(intercept = coef(summary(the.model))[1, 1], slope = 1 - 
                 b1.ii, col = "darkgrey", lty = 2) + 
    geom_abline(intercept = coef(summary(the.model))[1, 1], slope = 1 + 
                 b1.ii, col = "darkgrey", lty = 2)  
  }
  pl <- addLines(pl,the.model)
  pl

} library(gridExtra)
p.gg  <- equivalence.ggplot(mydata$x,mydata$y,alpha=0.05, b0.ii=0.25, b1.ii=0.25)
p.lat <- equivalence.xyplot(mydata$y~mydata$x,alpha=0.05, b0.ii=0.25, b1.ii=0.25)
grid.arrange(p.gg,p.lat)
-------------------------------------------------------------------------------------------------------
coord_map scale_x_continuous scale_y_continuous ggplot(data=ggmap, aes(x=long, y=lat)) +
    geom_polygon(data=ggmap, fill="grey80", aes(group=group)) +
    geom_path(color="white",aes(group=group)) +
    geom_point(data=df, aes(x=long, y=lat), colour="red", alpha=30/100) +
    coord_map(xlim=-c(59, 58), ylim=-c(35,34))
-------------------------------------------------------------------------------------------------------
ggplot(data = cuernavaca.map) + 
geom_polygon(mapping = aes(x = long, y = lat, group = group, colour = NA, fill = pobtot)) +
coord_equal() + 
facet_wrap(~nombre_municipio, scales = "free") + 
scale_fill_gradient2(low = "blue", high = "red", midpoint = mean(cuernavaca.map$pobtot, na.rm = TRUE)) +
-------------------------------------------------------------------------------------------------------
ggplot2 geom_polygon grid.dd <- read.table(text="SN X1 Y1 X2...",header=TRUE) eelv.d <- read.table(text="SN XC YC ELEV...",header=TRUE) ## add new id to identifiy polygon, each row is a polygon
grid.dd$id <- rownames(grid.dd)
## put the data in the long format since geom_polygon 
## needs aes(x,y,group) using reshape
dd.long <- reshape(grid.dd, dir='long', varying=list(c(1,3,5,7),
                                      c(2,4,6,8)), v.names=c('X', 'Y'),times =1:4)
## attempt to use merge but this gives a strange result
## dat <- merge(dd.long,eelv.d,by.x='id',by.y='SN')

library(ggplot2)
ggplot(dd.long, aes(x=X, y=Y)) + 
  geom_polygon(aes( group=factor(id)),fill='transparent',col='black')+
  geom_point(data=eelv.d,aes(x=XC,y=YC,col=ELEV),size=10)+
  scale_color_gradientn(colours = rainbow(10))+
  theme_bw()
-------------------------------------------------------------------------------------------------------
forestareamap <- forestareamap[order(forestareamap$order),] 
ggplot(forestareamap)+aes(long,lat,group=group,fill=prop)+geom_polygon()
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(rgdal) # Data from the Global Administrative Areas
# 1) Read in administrative area level 2 data

load("/Users/jmuirhead/Downloads/PAK_adm2.RData")
pakistan.adm2.spdf <- get("gadm") pakistan.adm2.spdf <- readOGR("/Users/jmuirhead/Downloads/PAK_adm", "PAK_adm2", 
 verbose = TRUE, stringsAsFactors = FALSE) pakistan.adm2.df <- fortify(pakistan.adm2.spdf, region = "NAME_2")

# Sample dataframe of unemployment info
unemployment.df <- data.frame(id= unique(pakistan.adm2.df[,'id']),
  unemployment = runif(n = length(unique(pakistan.adm2.df[,'id'])), min = 0, max = 25))

pakistan.adm2.df <- merge(pakistan.adm2.df, unemployment.df, by.y = 'id', all.x = TRUE) # Get centroids of spatialPolygonDataFrame and convert to dataframe
# for use in plotting  area names. 

pakistan.adm2.centroids.df <- data.frame(long = coordinates(pakistan.adm2.spdf)[, 1], 
   lat = coordinates(pakistan.adm2.spdf)[, 2]) 

# Get names and id numbers corresponding to administrative areas
pakistan.adm2.centroids.df[, 'ID_2'] <- pakistan.adm2.spdf@data[,'ID_2']
pakistan.adm2.centroids.df[, 'NAME_2'] <- pakistan.adm2.spdf@data[,'NAME_2'] p <- ggplot(pakistan.adm2.df, aes(x = long, y = lat, group = group)) + geom_polygon(aes(fill = cut(unemployment,5))) +
geom_text(data = pakistan.adm2.centroids.df, aes(label = NAME_2, x = long, y = lat, group = NAME_2), size = 3) + 
labs(x=" ", y=" ") + 
theme_bw() + scale_fill_brewer('Unemployment Rate (Jan 2011)', palette  = 'PuRd') + 
coord_map() + 
theme(panel.grid.minor=element_blank(), panel.grid.major=element_blank()) + 
theme(axis.ticks = element_blank(), axis.text.x = element_blank(), axis.text.y = element_blank()) + 
theme(panel.border = element_blank())

print(p)
-------------------------------------------------------------------------------------------------------
plot.spei plot.spei <- 
function (x, ...) 
{
    ## label <- ifelse(as.character(x$call)[1] == "spei", "SPEI", 
    ##     "SPI")

    ser <- ts(as.matrix(x$fitted[-c(1:x$scale), ]), end = end(x$fitted), 
        frequency = frequency(x$fitted))
    ser[is.nan(ser - ser)] <- 0
    se <- ifelse(ser == 0, ser, NA)
    tit <- dimnames(x$coefficients)[2][[1]]
    if (start(ser)[2] == 1) {
        ns <- c(start(ser)[1] - 1, 12)
    }
    else {
        ns <- c(start(ser)[1], start(ser)[2] - 1)
    }
    if (end(ser)[2] == 12) {
        ne <- c(end(ser)[1] + 1, 1)
    }
    else {
        ne <- c(end(ser)[1], end(ser)[2] + 1)
    }
    n <- ncol(ser)
    if (is.null(n)) 
        n <- 1
    par(mar = c(4, 4, 2, 1) + 0.1)
    if (n > 1 & n < 5) 
        par(mfrow = c(n, 1))
    if (n > 1 & n >= 5) 
        par(mfrow = c({
            n + 1
        }%/%2, 2))
    for (i in 1:n) {
        datt <- ts(c(0, ser[, i], 0), frequency = frequency(ser), 
            start = ns, end = ne)
        datt.pos <- ifelse(datt > 0, datt, 0)
        datt.neg <- ifelse(datt <= 0, datt, 0)
        plot(datt, type = "n", xlab = "", main = tit[i], ...)
        if (!is.null(x$ref.period)) {
            k <- ts(5, start = x$ref.period[1, ], end = x$ref.period[2, 
                ], frequency = 12)
            k[1] <- k[length(k)] <- -5
            polygon(k, col = "light grey", border = NA, density = 20)
            abline(v = x$ref.period[1, 1] + (x$ref.period[1, 
                2] - 1)/12, col = "grey")
            abline(v = x$ref.period[2, 1] + (x$ref.period[2, 
                2] - 1)/12, col = "grey")
        }
        grid(col = "black")
        polygon(datt.pos, col = "blue", border = NA)
        polygon(datt.neg, col = "red", border = NA)
        lines(datt, col = "dark grey")
        abline(h = 0)
        points(se, pch = 21, col = "white", bg = "black")
    }
} ylab plot(spi1, ylab = "SPI") ts par(mfrow = c(3, 4))
listofmonths <- split(fitted(spi1), cycle(fitted(spi1)))
names(listofmonths) <- month.abb

require(plyr)
l_ply(seq_along(listofmonths), function(x) {
       plot(x = seq_along(listofmonths[[x]]), y = listofmonths[[x]],
            type = "l", xlab = "", ylab = "SPI")
       title(names(listofmonths)[x])
   }) monthplot(fitted(spi1), labels = month.abb, cex.axis = 0.8)
boxplot(fitted(spi1) ~ cycle(fitted(spi1)), names = month.abb, cex.axis = 0.8)
-------------------------------------------------------------------------------------------------------
dev.new(width=0.3,height=0.3)
par(mar=c(0.01,0.01,0.01,0.01))

set.seed(13)
x <- 1:10
y <- runif(10)

plot(x,y,type="n",xaxs="i",yaxs="i",ylim=c(0,1))
polygon( c(1,x,max(x),0), c(0,y,0,0), col="lightblue", border=NA)
lines(x,y,lwd=1)

box(lwd=1)
-------------------------------------------------------------------------------------------------------
png dev.new(width=1.3,height=0.3)
# repeat from here onwards only for png call below
par(mar=c(0,0,0,0))
set.seed(13)
x <- 1:10
y <- runif(10)
plot(x,y,type="n",xaxs="i",yaxs="i",ylim=c(0,1),bty="n")
polygon( c(1,x,max(x),0), c(0,y,0,0), col="lightblue", border=NA)
lines(x,y,lwd=1)
box(lwd=1) png png("textbox_direct.png",width=116,height=27)
# take code block from above
dev.off()
-------------------------------------------------------------------------------------------------------
facet_grid() theme(aspect.ratio=1) # Create a new factor column for faceting.
newfactor = ifelse(all_states$weco, "weco", 
                           ifelse(all_states$west, "west", "east"))

# Manually specify sort order of factor levels.
newfactor = factor(as.character(newfactor), levels=c("weco", "west", "east"))

all_states$region = newfactor

plot_1 = ggplot(all_states, aes(x=long, y=lat, group=group)) + 
         geom_polygon(colour="white", fill="grey") + 
         facet_grid(. ~ region, space="free", scales="free") + 
         theme(aspect.ratio=1)

ggsave("plot_1.png", plot=plot_1, height=4, width=8, dpi=150)
-------------------------------------------------------------------------------------------------------
plot ggplot2 # UK shapefile found via http://www.gadm.org/download
uk.url <- "http://www.filefactory.com/file/s3dz3jt3vr/n/GBR_adm_zip"

# replace following with your working directory - no trailing slash
work.dir <- "C:/Temp/r.temp/gb_map"

# the full file path for storing file
file.loc <- paste0(work.dir, "/uk.zip")

download.file (uk.url, destfile = file.loc, mode = "wb")
unzip(file.loc, exdir = work.dir)

# open the shapefile
require(rgdal)
require(ggplot2)
uk <- readOGR(work.dir, layer = "GBR_adm2")

# use the NAME_2 field (representing counties) to create data frame
uk.map <- fortify(uk, region = "NAME_2")

# create fake count data...
uk.map$count <- round(runif(nrow(uk.map), 0, 2500), 0)

# quick visual check
ggplot(uk.map, aes(x = long, y = lat, group = group, fill = count)) +
    geom_polygon(colour = "black", size = 0.5, aes(group = group)) +
    theme() ggplot uk.map cut uk.map > str(uk.map)
'data.frame':   427339 obs. of  8 variables:
 $ long : num  -2.05 -2.05 -2.05 -2.05 -2.05 ...
 $ lat  : num  57.2 57.2 57.2 57.2 57.2 ...
 $ order: int  1 2 3 4 5 6 7 8 9 10 ...
 $ hole : logi  FALSE FALSE FALSE FALSE FALSE FALSE ...
 $ piece: Factor w/ 234 levels "1","2","3","4",..: 1 1 1 1 1 1 1 1 1 1 ...
 $ group: Factor w/ 1136 levels "Aberdeen.1","Aberdeenshire.1",..: 1 1 1 1 1 1 1 1 1 1 ...
 $ id   : chr  "Aberdeen" "Aberdeen" "Aberdeen" "Aberdeen" ...
 $ count: num  1549 1375 433 427 1282 ...
>
-------------------------------------------------------------------------------------------------------
library(ggmap)
library(maptools)
shapefile <- readShapeSpatial('MunicipalBoundaries_polys.shp', proj4string = CRS("+proj=lcc +lat_1=34.33333333333334 +lat_2=36.16666666666666 +lat_0=33.75 +lon_0=-79 +x_0=609601.2199999997 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=us-ft +no_defs"))
shp <- spTransform(shapefile, CRS("+proj=longlat +datum=WGS84"))
data <- fortify(shp)

nc <- get_map("North Carolina", zoom = 6, maptype = 'terrain')
ncmap <- ggmap(nc,  extent = "device")
ncmap +
  geom_polygon(aes(x = long, y = lat, group = group), data = data,
               colour = 'grey', fill = 'black', alpha = .4, size = .1)
-------------------------------------------------------------------------------------------------------
work.dir <- "directory_name_no_trailing slash"

# open the shapefile
require(rgdal)
require(rgeos)
require(ggplot2)
ch <- readOGR(work.dir, layer = "PLZO_PLZ")

# convert to data frame for plotting with ggplot - takes a while
ch.df <- fortify(ch)

# generate fake data and add to data frame
ch.df$count <- round(runif(nrow(ch.df), 0, 100), 0)

# plot with ggplot
ggplot(ch.df, aes(x = long, y = lat, group = group, fill = count)) +
    geom_polygon(colour = "black", size = 0.3, aes(group = group)) +
    theme()

# or you could use base R plot
ch@data$count <- round(runif(nrow(ch@data), 0, 100), 0)
plot(ch, col = ch@data$count) ggplot plot ggplot # plot just a subset of NPAs using ggplot
my.sub <- ch.df[ch.df$id %in% c(4,6), ]
ggplot(my.sub, aes(x = long, y = lat, group = group, fill = count)) +
    geom_polygon(colour = "black", size = 0.3, aes(group = group)) +
    theme()
-------------------------------------------------------------------------------------------------------
dataEllipse point.in.polygon sp ell = dataEllipse(rate1, rate2, levels=c(0.05, 0.95)) 
point.in.polygon(rate1, rate2, ell$`0.95`[,1], ell$`0.95`[,2]) library(MASS)
set.seed(1234)
x1<-NULL
x2<-NULL
k<-1
Sigma2 <- matrix(c(.72,.57,.57,.46),2,2)
Sigma2
rho <- Sigma2[1,2]/sqrt(Sigma2[1,1]*Sigma2[2,2])
eta<-replicate(300,mvrnorm(k, mu=c(-2.503,-1.632), Sigma2))
p1<-exp(eta)/(1+exp(eta))
n<-60
x1<-replicate(300,rbinom(k,n,p1[,1]))
x2<-replicate(300,rbinom(k,n,p1[,2]))
rate1<-x1/60
rate2<-x2/60
library(car)
ell = dataEllipse(rate1, rate2, levels=c(0.05, 0.95))
library(sp)
point.in.polygon(rate1, rate2, ell$`0.95`[,1], ell$`0.95`[,2]) [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1
 [56] 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
[111] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
[166] 1 1 1 1 1 1 1 0 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1
[221] 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
[276] 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
-------------------------------------------------------------------------------------------------------
group ID ggplot(wards.fort, aes(x = long, y = lat, group = ID)) + 
   geom_polygon(colour='black', fill='white')
-------------------------------------------------------------------------------------------------------
draw.rect <- function(x1=0.9,y1=0.1,x2=0.8,y2=0.3,width=0.05){
  ang <- atan((y2-y1)/(x2-x1))
  xshift <- width*sin(ang)
  yshift <- width*cos(ang)
  polygon(x=c(x1,x2,x2-xshift,x1-xshift),y=c(y1,y2,y2+yshift,y1+yshift),col="pink")
}
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(maps)

mytext <- "GEOGRAPHY_ID GEO_CENTROID_LAT    GEO_CENTROID_LON    prediction
90012003024 41.364744   -73.373055  90.1
90012052001 41.488312   -73.381211  97.5
90012452002 41.300794   -73.467077  70.8
90012452003 41.319154   -73.479132  95.7
90012453001 41.293613   -73.456416  94.9
90012453003 41.284093   -73.493029  84.6
90012454001 41.263554   -73.462508  133.7
90010716002 41.181796   -73.196349  264.1
90010714003 41.183947   -73.198804  157.9
90010714004 41.185397   -73.200341  133.1
90010716001 41.184585   -73.195373  245.4
90010719001 41.195616   -73.203213  241.3
90010719002 41.191719   -73.20067   201.4
90010810001 41.222401   -73.155751  99.8
90012053002 41.437178   -73.396647  88.9
90012053003 41.451281   -73.413168  87.2
90012101001 41.400968   -73.458019  95.8
90012101002 41.394998   -73.449385  94.9
90012455002 41.270781   -73.52177   130
90012456001 41.360282   -73.530252  76
90012456002 41.288121   -73.507822  72.7
90012456003 41.313295   -73.528298  99.5
90010720002 41.187461   -73.206022  183.8
90010721001 41.189995   -73.216666  122.1
90010721003 41.180815   -73.216566  146.6
90010812001 41.233187   -73.117965  104.3
90012102003 41.393535   -73.440432  157.3
90012456004 41.296988   -73.522458  79.8
90012571001 41.613474   -73.503408  100.3
90012572001 41.203247   -73.202377  137.5
90012572002 41.194794   -73.192015  140
90010722002 41.195945   -73.210519  151.4
90010722003 41.193973   -73.214259  136.6
90010723001 41.203358   -73.20714   143.9
90010723002 41.198932   -73.206447  142.4
90010723003 41.203037   -73.212283  186.3
90010724001 41.208966   -73.201209  165.8
90010813001 41.246832   -73.131348  72.6
90010813003 41.246515   -73.111748  155.4
90012103003 41.402606   -73.440486  167.3
90012104002 41.390956   -73.434375  94.8
90012104004 41.381899   -73.431034  102.2
90012105001 41.369942   -73.437917  123.2
90012572003 41.195887   -73.197341  173.9
90012572004 41.198997   -73.199825  162.1
90010724002 41.209585   -73.20547   148.2
90010725001 41.212546   -73.215288  91.6
90010725002 41.208281   -73.212059  98.6
90010901002 41.287263   -73.250588  102.3
90010902003 41.266822   -73.23491   92
90012105002 41.353974   -73.458436  99
90012106001 41.383904   -73.465779  73.8
90012106002 41.382667   -73.457351  83.2
90012106003 41.387105   -73.458921  189.7
90010603003 41.211193   -73.280762  90.6
90010604001 41.1995 -73.306179  92.5
90010604002 41.181699   -73.295321  88.5
90010604003 41.171775   -73.283657  74.7
90010726004 41.222752   -73.235936  95.1
90010726005 41.211959   -73.228826  161.5
90010727001 41.225968   -73.207215  131.2
90010727002 41.214759   -73.208042  132.3
90012106004 41.390604   -73.45726   162.3
90012107012 41.399524   -73.464468  133.7
90012107013 41.396556   -73.471967  99.7
90012107021 41.386497   -73.468571  79
90010604004 41.167694   -73.309524  84.1
90010604005 41.195134   -73.325438  83.8
90010605001 41.155009   -73.2852    84.2
90010606001 41.139112   -73.283955  110.6
90010607002 41.147077   -73.261239  94.2
90010728001 41.224439   -73.198242  99.1
90010728002 41.217875   -73.197045  202.6
90010728003 41.210812   -73.195182  190.9
90010729001 41.216106   -73.185495  102.2
90010729002 41.221654   -73.19115   120.5
90010904004 41.228466   -73.191144  129.8
90010905001 41.245708   -73.153402  94.4
90012107022 41.390499   -73.47572   122
90012108003 41.395869   -73.494013  169
90010607004 41.162216   -73.266692  108.4
90010729003 41.208007   -73.192118  119.6
90010731002 41.209897   -73.173502  200.1
90010732001 41.199521   -73.157307  104
90010907002 41.292969   -73.213286  97.2
90012109002 41.422006   -73.509898  130.3
90012109003 41.408571   -73.469713  96.7
90012110002 41.427622   -73.478071  71
90010732002 41.199779   -73.15968   129.9
90010733001 41.194838   -73.161245  220.4
90010733002 41.196553   -73.167201  223.9
90010734001 41.200568   -73.177405  167.6
90010734003 41.202783   -73.185394  132.6
90011002001 41.320343   -73.199107  84.5
90011002002 41.3086 -73.220255  88
90011002004 41.331716   -73.221468  78.4
90012113001 41.445838   -73.445831  79.8
90010612001 41.179606   -73.224896  81.8
90010612002 41.181751   -73.232609  87.5
90010613001 41.175294   -73.231124  101
90010613002 41.173877   -73.239615  81.5
90010735001 41.196816   -73.182355  201
90010735002 41.193029   -73.183216  175.8
90010735003 41.19529    -73.184959  231.1
90010736001 41.194455   -73.177717  198.3
90011003002 41.341963   -73.192365  77.7
90011051001 41.233168   -73.263024  123.6
90011052002 41.285673   -73.287781  111.5
90012113003 41.441636   -73.436266  116.9
90012114001 41.430746   -73.428211  78.7
90012114002 41.447087   -73.427341  108.3
90012114003 41.422319   -73.420856  65.4
90010614002 41.167362   -73.237612  95.1
90010615001 41.154024   -73.24035   146
90010616001 41.137264   -73.264706  72.9
90010737003 41.190196   -73.163451  174.4
90010737004 41.191454   -73.168643  136.9
90010737005 41.188779   -73.168872  125.4
90010738001 41.190175   -73.175898  149.3
90010738002 41.188112   -73.176438  104.1
90011102011 41.30204    -73.07854   93.2
90011102021 41.292759   -73.089266  221.6
90011102022 41.277148   -73.094239  209
90012201003 41.450671   -73.524399  95.3
90012201004 41.464062   -73.509055  91.4
90012202001 41.494752   -73.495944  71.2
90010616002 41.131092   -73.255091  114.8
90010616003 41.126782   -73.269031  116.1
90010701001 41.155218   -73.22345   222
90010701003 41.1547 -73.228366  121.2
90010701004 41.158021   -73.229301  119.4
90010738003 41.189804   -73.178993  120.1
90010739001 41.190496   -73.1826    120
90010739002 41.187738   -73.18267   173.6
90010739003 41.186232   -73.18633   218.8
90010739004 41.190055   -73.185757  115.7
90010740001 41.182438   -73.180944  187.2
90010740002 41.181587   -73.17741   145.9
90012203001 41.521653   -73.470862  103.1
90012203002 41.487018   -73.45847   95.8
90012301002 41.442759   -73.311749  103.8
90010702001 41.161921   -73.22484   130.6
90010702002 41.163873   -73.22144   137.8
90010702003 41.15867    -73.219191  181.1
90010703001 41.160754   -73.21476   215.2
90010705001 41.167282   -73.191851  175
90010743001 41.18634    -73.159732  166.9
90010743002 41.182201   -73.158335  109
90010743003 41.180505   -73.162622  152.2
90010743004 41.178543   -73.168002  157.3
90010743005 41.181  -73.168064  143.4
90010743006 41.182831   -73.16868   122.4
90011103022 41.269651   -73.130548  88.6
90011104001 41.294908   -73.161871  111.3
90012302001 41.413873   -73.304276  93.1
90012303003 41.387196   -73.321197  118.5
90010705002 41.167522   -73.196366  213.2
90010706001 41.177971   -73.193067  236.6
90010706002 41.167732   -73.187421  227.7
90010709001 41.170459   -73.203877  159.7
90010709002 41.17138    -73.198856  186.7
90010710001 41.171339   -73.218595  126.6
90010744001 41.179957   -73.157483  135.6
90010744002 41.177069   -73.162353  133.4
90010744003 41.172159   -73.168866  185.4
90010744004 41.176011   -73.16636   169.5
90010801001 41.200673   -73.150037  105.6
90010801003 41.193386   -73.151688  140.3
90011105004 41.309581   -73.141151  77.3
90012304001 41.384815   -73.294462  118.4
90012304002 41.36671    -73.293527  94.8
90012304003 41.368872   -73.348572  194.7
90012305011 41.406865   -73.223661  89.3
90010710002 41.172463   -73.214353  184.7
90010712001 41.180827   -73.207841  133.3
90010712002 41.179002   -73.205237  206.9
90010801004 41.199783   -73.15404   140.2
90010802001 41.190012   -73.142391  106.3
90010802002 41.189527   -73.147431  86.6
90010802003 41.188494   -73.152008  121.6
90010804001 41.182524   -73.140233  153.5
90010804002 41.177371   -73.137682  151.9
90012002001 41.381013   -73.410319  87.5
90012305021 41.375831   -73.251305  105.6
90012305023 41.379858   -73.219021  96.8
90010712003 41.177009   -73.202378  168.4
90010712004 41.173824   -73.203364  197.4
90010713001 41.18072    -73.201927  184
90010713002 41.178332   -73.198693  183.5
90010714001 41.188573   -73.196834  115.9
90010714002 41.185972   -73.201774  118.1
90010805002 41.152953   -73.123918  71.8
90010806001 41.185641   -73.129554  112.4
90012003021 41.36255    -73.396786  86.7
90012003022 41.351419   -73.408962  154
90012402002 41.317929   -73.400807  91.5
90012402003 41.300946   -73.348506  126.8
90010202001 41.134991   -73.600739  118.3
90010202002 41.114341   -73.58158   84.7
90010203001 41.154604   -73.545957  90.1
90010203003 41.15133    -73.581789  109.2
90010353001 41.126492   -73.477104  191.2
90010353002 41.129396   -73.513016  221
90010354001 41.192382   -73.482245  120.4
90010354002 41.160459   -73.474248  114.7
90010354003 41.144611   -73.464233  216.9
90010354004 41.186241   -73.495502  88.6
90010503004 41.149218   -73.336642  192.9
90010503005 41.169512   -73.351917  140.6
90010504002 41.116467   -73.375013  85.9
90010505002 41.116352   -73.352404  85.4
90010203004 41.136534   -73.573863  86.2
90010205002 41.066638   -73.562444  77.2
90010425001 41.160707   -73.404989  125.9
90010425003 41.144366   -73.403332  121.1
90010426003 41.133452   -73.385111  81.7
90010505003 41.111412   -73.358066  80.8
90010505004 41.129533   -73.36223   82.9
90010551001 41.233676   -73.362879  108.9
90010206001 41.103581   -73.554734  85.2
90010206003 41.085439   -73.552623  82.5
90010426004 41.12787    -73.392559  136.8
90010427001 41.149039   -73.424079  107
90010428002 41.131288   -73.416989  91
90010551003 41.21145    -73.381718  77.7
90010551004 41.247205   -73.406188  77.1
90010552001 41.213714   -73.338138  108.3
90010552003 41.201885   -73.365519  115.7
90010208003 41.087838   -73.544622  77.2
90010209001 41.098298   -73.515074  83.6
90010428004 41.127102   -73.399138  85.3
90010429001 41.149545   -73.437497  77
90010430002 41.12977    -73.433261  106.9
90010602003 41.193534   -73.252047  60.8
90010602004 41.187197   -73.257167  141.4
90010210001 41.086533   -73.521131  112.1
90010211001 41.072121   -73.517654  101.2
90010211003 41.075939   -73.52826   78.2
90010431001 41.102395   -73.446269  83.8
90010431002 41.1173 -73.459513  73.3
90010432002 41.110378   -73.442314  92.3
90010212002 41.070902   -73.543556  89.6
90010213001 41.070755   -73.553697  110.1
90010213003 41.057543   -73.550212  98.6
90010433002 41.120549   -73.433645  95.1
90010434001 41.124754   -73.414431  91.3
90010434002 41.122855   -73.419197  87.9
90010434003 41.129448   -73.422258  98.3
90010435001 41.125176   -73.386176  144.2
90010214001 41.053676   -73.554293  202.3
90010214002 41.050584   -73.555773  176.2
90010214003 41.04669    -73.557427  103
90010214004 41.053666   -73.562879  172.1
90010215001 41.053793   -73.54926   145.9
90010215002 41.050154   -73.548156  139.8
90010435002 41.120456   -73.394265  87.9
90010435003 41.117986   -73.388516  78.1
90010436002 41.111907   -73.404062  183.2
90010437001 41.117371   -73.414574  202.5
90010215003 41.046584   -73.550538  148.7
90010215004 41.050229   -73.551746  126
90010216001 41.063583   -73.538563  185.4
90010216002 41.060054   -73.543822  132.2
90010216004 41.062798   -73.535453  124.6
90010437002 41.11312    -73.413212  213.7
90010438001 41.114109   -73.420907  167.6
90010438002 41.114952   -73.424774  122.8
90010438003 41.109739   -73.423166  149.8
90010438004 41.10928    -73.42707   137.6
90010101023 41.117859   -73.646129  87.8
90010102013 41.061299   -73.62279   157
90010217001 41.056839   -73.527159  171.4
90010217003 41.055427   -73.533343  129.1
90010217004 41.057926   -73.534384  138.6
90010217005 41.057235   -73.529757  104.5
90010218011 41.067416   -73.5255    144.2
90010439001 41.097703   -73.435218  153.8
90010439004 41.08607    -73.443137  68.4
90010440001 41.10246    -73.422491  199.8
90010102022 41.05194    -73.591855  97.6
90010103002 41.03803    -73.628652  87.4
90010218012 41.063118   -73.529794  118.4
90010218013 41.062331   -73.523699  120.1
90010218023 41.059329   -73.520307  107.8
90010219001 41.057436   -73.508325  96.8
90010440002 41.102279   -73.426726  201.9
90010440004 41.096429   -73.424339  166.7
90010440005 41.091685   -73.428074  265.9
90010441001 41.09657    -73.419621  174.2
90010441002 41.095089   -73.417375  165.8
90010103005 41.029176   -73.648761  130.3
90010220002 41.053379   -73.518227  148.5
90010221001 41.051607   -73.522784  157.5
90010442002 41.104538   -73.408893  154.1
90010442003 41.100721   -73.407695  121.1
90010105004 41.018874   -73.641155  144.3
90010221002 41.046457   -73.522742  133.3
90010221003 41.039903   -73.52882   126.5
90010223001 41.038742   -73.54947   135.6
90010223002 41.0331 -73.548214  78.3"


ny2 <- read.table(textConnection(mytext), sep = " ",
                  check.names = FALSE,
                  strip.white = TRUE,
                  header = TRUE)

names(ny2) <- c('id','lat','long','prediction')
us.states <- map_data("state")
plot.states <- c('connecticut') # subset to Connecticut for ease of use in this example

p <- ggplot() +
    geom_polygon(data = us.states[us.states$region %in% plot.states, ],
                 aes(x = long, y = lat, group = group), 
                 colour = "white", fill = "lightblue") +
    geom_point(data = ny2, aes(x = long, y = lat, 
                 colour = prediction), group = NULL) +
    stat_density2d(data = ny2, aes(x = long, y = lat), size = 0.02) +
    coord_map() +
    theme()

print(p)
-------------------------------------------------------------------------------------------------------
limits scale_x_... scale_y... xlim ylim coord_.... ?coord_cartesian map coord_map ggplot(spf1, aes(x=long,y=lat,group=group)) + 
  geom_polygon(colour  = 'grey90') +
  coord_map(xlim = c(-2, 2),ylim = c(50, 51))
-------------------------------------------------------------------------------------------------------
map_var<-function(data,var,ttl,coord_x,coord_y,group='group'){
    dist<-ggplot(aes_string(x=coord_x,y=coord_y,group=group,fill=var),data=data) + 
            geom_polygon(colour='white',size=.2) + 
            coord_equal() + 
            theme_opts + 
            labs(title=ttl) +
            scale_fill_gradient2(low='#ECE7F2',mid='#A6BDDB',high='#3300CC')

    hist<-ggplot(aes_string(x=var,group=group,fill=var),data=data) +
            geom_histogram() + 
            theme_hist +
            xlab('Bins') +
            scale_fill_gradient2(low='#ECE7F2',mid='#A6BDDB',high='#3300CC')

    grid.arrange(dist,hist)
    }

map_var(co_mapd,var='tot_pop',ttl='Distribution of Population',coord_x='long',coord_y='lat')
-------------------------------------------------------------------------------------------------------
windRose windRose.2 <- function (mydata, ws = "ws", wd = "wd", ws2 = NA, wd2 = NA, ws.int = 2, 
    angle = 30, type = "default", cols = "default", grid.line = NULL, 
    width = 1, seg = NULL, auto.text = TRUE, breaks = 4, offset = 10, 
    paddle = TRUE, key.header = NULL, key.footer = "(m/s)", key.position = "bottom", 
    key = TRUE, dig.lab = 5, statistic = "prop.count", pollutant = NULL, 
    annotate = TRUE, border = NA, ...) 
{
    if (is.null(seg)) 
        seg <- 0.9
    if (length(cols) == 1 && cols == "greyscale") {
        trellis.par.set(list(strip.background = list(col = "white")))
        calm.col <- "black"
    }
    else {
        calm.col <- "forestgreen"
    }
    current.strip <- trellis.par.get("strip.background")
    on.exit(trellis.par.set("strip.background", current.strip))
    if (360/angle != round(360/angle)) {
        warning("In windRose(...):\n  angle will produce some spoke overlap", 
            "\n  suggest one of: 5, 6, 8, 9, 10, 12, 15, 30, 45, etc.", 
            call. = FALSE)
    }
    if (angle < 3) {
        warning("In windRose(...):\n  angle too small", "\n  enforcing 'angle = 3'", 
            call. = FALSE)
        angle <- 3
    }
    extra.args <- list(...)
    extra.args$xlab <- if ("xlab" %in% names(extra.args)) 
        quickText(extra.args$xlab, auto.text)
    else quickText("", auto.text)
    extra.args$ylab <- if ("ylab" %in% names(extra.args)) 
        quickText(extra.args$ylab, auto.text)
    else quickText("", auto.text)
    extra.args$main <- if ("main" %in% names(extra.args)) 
        quickText(extra.args$main, auto.text)
    else quickText("", auto.text)
    if (is.character(statistic)) {
        ok.stat <- c("prop.count", "prop.mean", "abs.count", 
            "frequency")
        if (!is.character(statistic) || !statistic[1] %in% ok.stat) {
            warning("In windRose(...):\n  statistic unrecognised", 
                "\n  enforcing statistic = 'prop.count'", call. = FALSE)
            statistic <- "prop.count"
        }
        if (statistic == "prop.count") {
            stat.fun <- length
            stat.unit <- "%"
            stat.scale <- "all"
            stat.lab <- ""
            stat.fun2 <- function(x) signif(mean(x, na.rm = TRUE), 
                3)
            stat.lab2 <- "mean"
            stat.labcalm <- function(x) round(x, 1)
        }
        if (statistic == "prop.mean") {
            stat.fun <- function(x) sum(x, na.rm = TRUE)
            stat.unit <- "%"
            stat.scale <- "panel"
            stat.lab <- "Proportion contribution to the mean (%)"
            stat.fun2 <- function(x) signif(mean(x, na.rm = TRUE), 
                3)
            stat.lab2 <- "mean"
            stat.labcalm <- function(x) round(x, 1)
        }
        if (statistic == "abs.count" | statistic == "frequency") {
            stat.fun <- length
            stat.unit <- ""
            stat.scale <- "none"
            stat.lab <- "Count by wind direction"
            stat.fun2 <- function(x) round(length(x), 0)
            stat.lab2 <- "count"
            stat.labcalm <- function(x) round(x, 0)
        }
    }
    if (is.list(statistic)) {
        stat.fun <- statistic$fun
        stat.unit <- statistic$unit
        stat.scale <- statistic$scale
        stat.lab <- statistic$lab
        stat.fun2 <- statistic$fun2
        stat.lab2 <- statistic$lab2
        stat.labcalm <- statistic$labcalm
    }
    vars <- c(wd, ws)
    diff <- FALSE
    rm.neg <- TRUE
    if (!is.na(ws2) & !is.na(wd2)) {
        vars <- c(vars, ws2, wd2)
        diff <- TRUE
        rm.neg <- FALSE
        mydata$ws <- mydata[, ws2] - mydata[, ws]
        mydata$wd <- mydata[, wd2] - mydata[, wd]
        id <- which(mydata$wd < 0)
        if (length(id) > 0) 
            mydata$wd[id] <- mydata$wd[id] + 360
        pollutant <- "ws"
        key.footer <- "ws"
        wd <- "wd"
        ws <- "ws"
        vars <- c("ws", "wd")
        if (missing(angle)) 
            angle <- 10
        if (missing(offset)) 
            offset <- 20
        if (is.na(breaks[1])) {
            max.br <- max(ceiling(abs(c(min(mydata$ws, na.rm = TRUE), 
                max(mydata$ws, na.rm = TRUE)))))
            breaks <- c(-1 * max.br, 0, max.br)
        }
        if (missing(cols)) 
            cols <- c("lightskyblue", "tomato")
        seg <- 1
    }
    if (any(type %in% openair:::dateTypes)) 
        vars <- c(vars, "date")
    if (!is.null(pollutant)) 
        vars <- c(vars, pollutant)
    mydata <- openair:::checkPrep(mydata, vars, type, remove.calm = FALSE, 
        remove.neg = rm.neg)
    mydata <- na.omit(mydata)
    if (is.null(pollutant)) 
        pollutant <- ws
    mydata$x <- mydata[, pollutant]
    mydata[, wd] <- angle * ceiling(mydata[, wd]/angle - 0.5)
    mydata[, wd][mydata[, wd] == 0] <- 360
    mydata[, wd][mydata[, ws] == 0] <- -999
    if (length(breaks) == 1) 
        breaks <- 0:(breaks - 1) * ws.int
    if (max(breaks) < max(mydata$x, na.rm = TRUE)) 
        breaks <- c(breaks, max(mydata$x, na.rm = TRUE))
    if (min(breaks) > min(mydata$x, na.rm = TRUE)) 
        warning("Some values are below minimum break.")
    breaks <- unique(breaks)
    mydata$x <- cut(mydata$x, breaks = breaks, include.lowest = FALSE, 
        dig.lab = dig.lab)
    theLabels <- gsub("[(]|[)]|[[]|[]]", "", levels(mydata$x))
    theLabels <- gsub("[,]", " to ", theLabels)
    prepare.grid <- function(mydata) {
        if (all(is.na(mydata$x))) 
            return()
        levels(mydata$x) <- c(paste("x", 1:length(theLabels), 
            sep = ""))
        all <- stat.fun(mydata[, wd])
        calm <- mydata[mydata[, wd] == -999, ][, pollutant]
        mydata <- mydata[mydata[, wd] != -999, ]
        calm <- stat.fun(calm)
        weights <- tapply(mydata[, pollutant], list(mydata[, 
            wd], mydata$x), stat.fun)
        if (stat.scale == "all") {
            calm <- calm/all
            weights <- weights/all
        }
        if (stat.scale == "panel") {
            temp <- stat.fun(stat.fun(weights)) + calm
            calm <- calm/temp
            weights <- weights/temp
        }
        weights[is.na(weights)] <- 0
        weights <- t(apply(weights, 1, cumsum))
        if (stat.scale == "all" | stat.scale == "panel") {
            weights <- weights * 100
            calm <- calm * 100
        }
        panel.fun <- stat.fun2(mydata[, pollutant])
        u <- mean(sin(2 * pi * mydata[, wd]/360))
        v <- mean(cos(2 * pi * mydata[, wd]/360))
        mean.wd <- atan2(u, v) * 360/2/pi
        if (all(is.na(mean.wd))) {
            mean.wd <- NA
        }
        else {
            if (mean.wd < 0) 
                mean.wd <- mean.wd + 360
            if (mean.wd > 180) 
                mean.wd <- mean.wd - 360
        }
        weights <- cbind(data.frame(weights), wd = as.numeric(row.names(weights)), 
            calm = calm, panel.fun = panel.fun, mean.wd = mean.wd)
        weights
    }
    if (paddle) {
        poly <- function(wd, len1, len2, width, colour, x.off = 0, 
            y.off = 0) {
            theta <- wd * pi/180
            len1 <- len1 + off.set
            len2 <- len2 + off.set
            x1 <- len1 * sin(theta) - width * cos(theta) + x.off
            x2 <- len1 * sin(theta) + width * cos(theta) + x.off
            x3 <- len2 * sin(theta) - width * cos(theta) + x.off
            x4 <- len2 * sin(theta) + width * cos(theta) + x.off
            y1 <- len1 * cos(theta) + width * sin(theta) + y.off
            y2 <- len1 * cos(theta) - width * sin(theta) + y.off
            y3 <- len2 * cos(theta) + width * sin(theta) + y.off
            y4 <- len2 * cos(theta) - width * sin(theta) + y.off
            lpolygon(c(x1, x2, x4, x3), c(y1, y2, y4, y3), col = colour, 
                border = border)
        }
    }
    else {
        poly <- function(wd, len1, len2, width, colour, x.off = 0, 
            y.off = 0) {
            len1 <- len1 + off.set
            len2 <- len2 + off.set
            theta <- seq((wd - seg * angle/2), (wd + seg * angle/2), 
                length.out = (angle - 2) * 10)
            theta <- ifelse(theta < 1, 360 - theta, theta)
            theta <- theta * pi/180
            x1 <- len1 * sin(theta) + x.off
            x2 <- rev(len2 * sin(theta) + x.off)
            y1 <- len1 * cos(theta) + x.off
            y2 <- rev(len2 * cos(theta) + x.off)
            lpolygon(c(x1, x2), c(y1, y2), col = colour, border = border)
        }
    }
    mydata <- cutData(mydata, type, ...)
    results.grid <- ddply(mydata, type, prepare.grid)
    results.grid$calm <- stat.labcalm(results.grid$calm)
    results.grid$mean.wd <- stat.labcalm(results.grid$mean.wd)
    strip.dat <- openair:::strip.fun(results.grid, type, auto.text)
    strip <- strip.dat[[1]]
    strip.left <- strip.dat[[2]]
    pol.name <- strip.dat[[3]]
    if (length(theLabels) < length(cols)) {
        col <- cols[1:length(theLabels)]
    }
    else {
        col <- openColours(cols, length(theLabels))
    }
    max.freq <- max(results.grid[, (length(type) + 1):(length(theLabels) + 
        length(type))], na.rm = TRUE)
    off.set <- max.freq * (offset/100)
    box.widths <- seq(0.002^0.25, 0.016^0.25, length.out = length(theLabels))^4
    box.widths <- box.widths * max.freq * angle/5
    legend <- list(col = col, space = key.position, auto.text = auto.text, 
        labels = theLabels, footer = key.footer, header = key.header, 
        height = 0.6, width = 1.5, fit = "scale", plot.style = if (paddle) "paddle" else "other")
    legend <- openair:::makeOpenKeyLegend(key, legend, "windRose")
    temp <- paste(type, collapse = "+")
    myform <- formula(paste("x1 ~ wd | ", temp, sep = ""))
    mymax <- 2 * max.freq
    myby <- if (is.null(grid.line)) 
        pretty(c(0, mymax), 10)[2]
    else grid.line
    if (myby/mymax > 0.9) 
        myby <- mymax * 0.9
    xyplot.args <- list(x = myform, xlim = 1.03 * c(-max.freq - 
        off.set, max.freq + off.set), ylim = 1.03 * c(-max.freq - 
        off.set, max.freq + off.set), data = results.grid, type = "n", 
        sub = stat.lab, strip = strip, strip.left = strip.left, 
        as.table = TRUE, aspect = 1, par.strip.text = list(cex = 0.8), 
        scales = list(draw = FALSE), panel = function(x, y, subscripts, 
            ...) {
            panel.xyplot(x, y, ...)
            angles <- seq(0, 2 * pi, length = 360)
            sapply(seq(off.set, mymax, by = myby), function(x) llines(x * 
                sin(angles), x * cos(angles), col = "grey85", 
                lwd = 1))
            subdata <- results.grid[subscripts, ]
            upper <- max.freq + off.set
            larrows(-upper, 0, upper, 0, code = 3, length = 0.1)
            larrows(0, -upper, 0, upper, code = 3, length = 0.1)
            ltext(upper * -1 * 0.95, 0.07 * upper, "W", cex = 0.7)
            ltext(0.07 * upper, upper * -1 * 0.95, "S", cex = 0.7)
            ltext(0.07 * upper, upper * 0.95, "N", cex = 0.7)
            ltext(upper * 0.95, 0.07 * upper, "E", cex = 0.7)
            if (nrow(subdata) > 0) {
                for (i in 1:nrow(subdata)) {
                  with(subdata, {
                    for (j in 1:length(theLabels)) {
                      if (j == 1) {
                        temp <- "poly(wd[i], 0, x1[i], width * box.widths[1], col[1])"
                      } else {
                        temp <- paste("poly(wd[i], x", j - 1, 
                          "[i], x", j, "[i], width * box.widths[", 
                          j, "], col[", j, "])", sep = "")
                      }
                      eval(parse(text = temp))
                    }
                  })
                }
            }
            ltext(seq((myby + off.set), mymax, myby) * sin(pi/4), 
                seq((myby + off.set), mymax, myby) * cos(pi/4), 
                paste(seq(myby, mymax, by = myby), stat.unit, 
                  sep = ""), cex = 0.7)
            if (annotate) if (statistic != "prop.mean") {
                if (!diff) {
                  ltext(max.freq + off.set, -max.freq - off.set, 
                    label = paste(stat.lab2, " = ", subdata$panel.fun[1], 
                      "\ncalm = ", subdata$calm[1], stat.unit, 
                      sep = ""), adj = c(1, 0), cex = 0.7, col = calm.col)
                }
                if (diff) {
                  ltext(max.freq + off.set, -max.freq - off.set, 
                    label = paste("mean ws = ", round(subdata$panel.fun[1], 
                      1), "\nmean wd = ", round(subdata$mean.wd[1], 
                      1), sep = ""), adj = c(1, 0), cex = 0.7, 
                    col = calm.col)
                }
            } else {
                ltext(max.freq + off.set, -max.freq - off.set, 
                  label = paste(stat.lab2, " = ", subdata$panel.fun[1], 
                    stat.unit, sep = ""), adj = c(1, 0), cex = 0.7, 
                  col = calm.col)
            }
        }, legend = legend)
    xyplot.args <- openair:::listUpdate(xyplot.args, extra.args)
    plt <- do.call(xyplot, xyplot.args)
    if (length(type) == 1) 
        plot(plt)
    else plot(useOuterStrips(plt, strip = strip, strip.left = strip.left))
    newdata <- results.grid
    output <- list(plot = plt, data = newdata, call = match.call())
    class(output) <- "openair"
    invisible(output)
} windRose.2 stat.lab <- "Frequency of counts by wind direction (%)" stat.lab <- ""
-------------------------------------------------------------------------------------------------------
x1<-replicate(300,rbinom(k,n,p1[1,])) 
x2<-replicate(300,rbinom(k,n,p1[2,])) k=1 rbinom(k,n,p1[1,]) p1[1,] rate1 rate2 p1 p1 x1<-replicate(300,rbinom(k,n,p1[1,])) 
x2<-replicate(300,rbinom(k,n,p1[2,]))

rate1<-x1/60  # Estimated p's
rate2<-x2/60
library(car)
plot.new()
ell <- dataEllipse(rate1, rate2, levels=c(0.05, 0.95), plot.points=T, pch=NA)
library(sp)
within<-point.in.polygon(p1[1,], p1[2,], ell$`0.95`[,1], ell$`0.95`[,2])
mean(within)  

plot(p1[1,which(within==1)], p1[2,which(within==1)], col="blue", ylim=c(0,1),xlim=c(0,1))
points(p1[1,which(within==0)], p1[2,which(within==0)], col="green")

ell <- dataEllipse(rate1, rate2, levels=c(0.05, 0.95), plot.points=T, pch=NA, add=T) x1<-rbinom(300,n,p1[1,])
x2<-rbinom(300,n,p1[2,])
rate1<-x1/60  # Estimated p's
rate2<-x2/60
library(car)
plot.new()
ell <- dataEllipse(rate1, rate2, levels=c(0.05, 0.95), plot.points=T, pch=NA)
library(sp)
within<-point.in.polygon(p1[1,], p1[2,], ell$`0.95`[,1], ell$`0.95`[,2])
mean(within)  

plot(p1[1,which(within==1)], p1[2,which(within==1)], col="blue", ylim=c(0,1),xlim=c(0,1))
points(p1[1,which(within==0)], p1[2,which(within==0)], col="green")
ell <- dataEllipse(rate1, rate2, levels=c(0.05, 0.95), plot.points=T, pch=NA, add=T)
-------------------------------------------------------------------------------------------------------
# Simulate the data (from normal distribution)
d<-rnorm(1000)
# Calculate the density of the data
xd<-density(d)$x
yd<-density(d)$y
# Specify how many curves to plot
no.of.curves<-51

# Open a new plot window
x11(6, 8)
# Set background to black
par(bg=1)
# The the initial plot
plot(x=xd, y=yd+(no.of.curves-1)/10, ylim=c(0,no.of.curves/10+max(yd)), col="grey50", type="l", lwd=2)
# Color the curve with black
polygon(xd, yd+(no.of.curves-1)/10-0.02, col="black", border=NA)
# Add more urves to the plot
for(i in 1:no.of.curves) {
   lines(x=xd, y=yd+(no.of.curves-i)/10, ylim=c(0,no.of.curves/10+max(yd)), col="grey50", type="l", lwd=2)
   polygon(xd, yd+(no.of.curves-i)/10-0.02, col="black", border=NA)
} d<-structure(list(x = c(1L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L, 2L, 
3L, 3L, 3L, 3L, 3L, 4L, 4L, 4L, 4L, 4L, 5L, 5L, 5L, 5L, 5L), 
    y = c(1L, 2L, 3L, 4L, 5L, 1L, 2L, 3L, 4L, 5L, 1L, 2L, 3L, 
    4L, 5L, 1L, 2L, 3L, 4L, 5L, 1L, 2L, 3L, 4L, 5L), z = c(5.47, 
    3.36, 2.99, 3.04, 3.73, 3.25, 3.04, 2.19, 1.6, 2.63, 3.49, 
    2.48, 2.7, 1.6, 2.7, 3.33, 1.94, 2.39, 2.89, 2.94, 4.35, 
    3.21, 3.4, 3.36, 4.74)), .Names = c("x", "y", "z"), class = "data.frame", row.names = c(NA, 
-25L))

yvals<-rev(unique(d$y))
plot(x=0, y=0, ylim=c(min(d$y), max(d$y)+max(d$z)), xlim=c(min(d$x), max(d$x)), type="n", axes=F, xlab="", ylab="") 
 for(i in 1:length(yvals)) {
   a<-d[d$y==yvals[i],]
   polygon(x=a$x, y=a$z+i, border="grey75", col="black")
}
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(scales)
library(maps)

csv.file <- "http://www.census.gov/popest/data/maps/2011/maps-county2011.csv"

mydf <- read.csv(csv.file, skip = 4, header = TRUE, check.names = FALSE)
mydf <- mydf[, c(1, 2, 5, 10, 11)] # we can drop most columns

colnames(mydf) <- c("code", "subregion", "population", "density", "area")
mydf$population <- as.numeric(gsub(",", "", mydf$population)) # remove commas
mydf$area <- as.numeric(gsub(",", "", mydf$area)) # remove commas

nj.pop <- mydf[substr(mydf$code, 1, 3) == '340', ] # new jersey code is 34000
nj.pop <- nj.pop[2:nrow(nj.pop), ] # drop first row i.e. new jersey state itself
nj.pop$subregion <- tolower(gsub(" County", "", nj.pop$subregion))
nj.pop$subregion <- gsub("\\.", "", nj.pop$subregion)
nj.pop$density_d <- cut(nj.pop$density,
                        breaks = c(0,30,100,300,500,1000,3000,5000,100000),
                        dig.lab = 6, include.lowest = TRUE)

nj.pop

nj.shp <- map_data("county") # grab...
nj.shp <- nj.shp[nj.shp$region == 'new jersey', ] # ...and subset

identical(unique(nj.shp2$subregion), unique(nj.pop$subregion)) # should be TRUE

nj.both <- merge(nj.pop, nj.shp2, by = "subregion")

p <- ggplot(nj.both, aes(long, lat, group = group)) +
    geom_polygon(aes(fill = density_d), colour = alpha("white", 1/2),
                 size = 0.2) +
    scale_fill_brewer(palette = "PuRd") +
    coord_equal()

print(p)
-------------------------------------------------------------------------------------------------------
summary() summary() time surv upper lower mod<-summary(leukemia.surv) plot() polygon() lower upper lines() type="s" lines() with(mod,plot(time,surv,type="n",xlim=c(5,50),ylim=c(0,1)))
with(mod,polygon(c(time,rev(time)),c(lower,rev(upper)),
                 col = "grey75", border = FALSE))
with(mod,lines(time,surv,type="s"))
-------------------------------------------------------------------------------------------------------
print(ggmap(map)) + geom_polygon(data = poa, aes(x = LON, y = LAT, group = order), alpha = .5, colour = "black", fill = NA)) poa <<- poa
-------------------------------------------------------------------------------------------------------
polygon polygon(x=c(0:5, rev(0:5 )), y=c(rep(0, 6), rep(4,6)), density=10, angle=45)
-------------------------------------------------------------------------------------------------------
x <- seq(-2, 2, 0.01)
y <- seq(-2, 2, 0.01)

plot(x,y, xlim = c(-2,2), ylim=c(-2,2), type='n', asp = 1)
curve((  1 * (4 - x^2)^0.5 ), add=TRUE, from=-2 , to =2)
curve(( -1 * (4 - x^2)^0.5 ), add=TRUE, from=-2 , to =2)
rect(-2,-2,2,2)

# to fill circle and square
plot(x,y, xlim = c(-2,2), ylim=c(-2,2), type='n', asp = 1)
x2 <- c(seq(-2, 2, 0.01), seq(-2, 2, 0.01))
y2 <- c((  1 * (4 - x2[1:401]^2)^0.5 ), ( -1 * (4 - x2[402:802]^2)^0.5 ))
rect(-2,-2,2,2, col = 'red')
polygon(x2,y2, col = 'green', border = NA) circle.square.function <- function(radius, x.midpoint, y.midpoint, 
                                   my.x.lim, my.y.lim) {

  x <- seq(x.midpoint-radius, x.midpoint+radius, 0.01)
  y <- seq(y.midpoint-radius, y.midpoint+radius, 0.01)

  plot(x,y, xlim = my.x.lim, ylim = my.y.lim, type='n', asp = 1)
  curve((  1 * (radius^2 - (x - x.midpoint)^2)^0.5 + y.midpoint), add=TRUE, 
                from = (x.midpoint-radius) , to = (x.midpoint+radius))
  curve(( -1 * (radius^2 - (x - x.midpoint)^2)^0.5 + y.midpoint), add=TRUE, 
                from = (x.midpoint-radius) , to = (x.midpoint+radius))
  rect((x.midpoint-radius),(y.midpoint-radius),
       (x.midpoint+radius),(y.midpoint+radius))

}

radius     <-  10          # radius of circle
x.midpoint <- 150          # center of circle on x-axis
y.midpoint <-  50          # center of circle on y-axis
my.x.lim   <- c(-100,200)  # x-axis to plot
my.y.lim   <- c(   0,200)  # y-axis to plot

circle.square.function(radius, x.midpoint, y.midpoint, my.x.lim, my.y.lim)
-------------------------------------------------------------------------------------------------------
m1 geom_polygon() library(SuppDists)
library(ggplot2)
# function to calculate density along a grid
JohnsonDensity = function(m1 = 0, m2 = 1, m3 = -0.2, m4 = 3.7, n = 10000) {
    parms <- JohnsonFit(c(m1, m2, m3, m4))
    J_quantiles = na.omit(qJohnson(seq(0, 1, length.out = n+2), parms))
    J_pdf = dJohnson(J_quantiles, parms)
    return( data.frame(pdf = c(J_pdf, 0, 0), x = c(J_quantiles, J_quantiles[length(J_quantiles)], J_quantiles[1]) ) )
}

# values of the pdf along the grid for two distributions
data_density = rbind(data.frame(var1 = "now", JohnsonDensity() ), data.frame(var1 = "hist", JohnsonDensity(m1 = 0.2)) )

ggplot(data_density, aes(x = x, y = pdf, color = var1, fill = var1)) + geom_polygon(alpha = 0.5) n
-------------------------------------------------------------------------------------------------------
d1 <- data.frame(x = c(0,0.5,0),y = c(0,1,1))
p + geom_polygon(data = d1,aes(x = x,y = y),fill = "white",colour = "black") grid.path
-------------------------------------------------------------------------------------------------------
sf require("rgdal") # requires sp, will use proj.4 if installed
require("maptools")
require("ggplot2")
require("plyr")

workingDir <- ""

sf <- readOGR(dsn=workingDir, layer="BK50_Ausschnitt005")
sf@data$id <- rownames(sf@data)
sf.points <- fortify(sf, region="id")
sf.df <- join(sf.points, sf@data, by="id")

ggplot(sf.df,aes(x=long, y=lat, fill=NFK)) + coord_equal() + geom_polygon(colour="black", size=0.1, aes(group=group))
-------------------------------------------------------------------------------------------------------
library("rgeos")
library("sp")
library("ggplot2")
library("plyr") rworldmap library("rworldmap")
data(countriesLow)
ctry <- countriesLow[countriesLow$ISO3.1 %in% c("TZA", "KEN", "UGA", "RWA", "BDI"),] head #generate a grid of points
xy<-expand.grid(long=seq(25,45,0.5),lat=seq(-15,5,0.5))
xy.sp <- SpatialPoints(xy, proj4string=CRS(proj4string(ctry)))
Overlay<-over(xy.sp,ctry)
xy<-xy[!is.na(Overlay$ISO3.1),] fx.ggplot fx.ggplot<-function(ctry, aesfill="id", scalefill="Country", pathcol="white") {
    ##ctry is a shapefile of countries
    ctry@data$id = rownames(ctry@data)
    ctry.points = fortify(ctry, region="id")
    ctry.df = join(ctry.points, ctry@data, by="id")
    ggplot(ctry.df, aes(long, lat)) +
        geom_polygon(aes_string(group="group", fill=aesfill)) +
        geom_path(colour = pathcol) +
        scale_fill_brewer(scalefill)
} aes long lat geom_polygon group fill aes_string (p <- fx.ggplot(ctry)) p + geom_point(data=xy)
-------------------------------------------------------------------------------------------------------
index(ratioresults) > index(x)
[1] "2003-02-01" "2003-02-03" "2003-02-07" "2003-02-09" "2003-02-14" Date x=zoo(matrix(runif(11),ncol=1),as.Date("2012-08-01") + 0:10)
colnames(x)="ratio"
plot(index(x),x$ratio,type="o",col="red",ylim=c(0,1))
polygon(index(x)[c(1,1:11,11)],c(0,x$ratio,0),col="red") x ylim
-------------------------------------------------------------------------------------------------------
#With an example dataset: please provide one when you need help!
ratioresults<-as.zoo(runif(10,0,1))
plot(index(ratioresults),ratioresults, type="o", col="red", 
     xaxs="i",yaxs="i", ylim=c(0,2))
polygon(c(index(ratioresults),rev(index(ratioresults))),
        c(as.vector(ratioresults),rep(0,length(ratioresults))),col="red") polygon ylim yaxs="i"
-------------------------------------------------------------------------------------------------------
# prepare data for circles
green <- circleFun(center = c(5, 5), diameter = 1.5, npoints = 100)
yellow <- circleFun(center = c(5, 5), diameter = 3, npoints = 100)
orange <- circleFun(center = c(5, 5), diameter = 4.5, npoints = 100)
red <- circleFun(center = c(5, 5), diameter = 6, npoints = 100)

dat <- rbind(green, yellow, orange, red)

# specify levels to get the order of colours right,
# and set the plotting order from large (red) to small (green) circle
dat$fill <- factor(rep(c("green", "yellow", "orange", "red"), each = 100),
                   levels = rev(c("green", "yellow", "orange", "red")))

# dummy data for points
dat2 <- data.frame(x = rnorm(100, mean = 3), y = rnorm(100, mean = 3))

ggplot(data = dat, aes(x = x, y = y)) +
  geom_polygon(aes(fill = fill)) +
  geom_point(data = dat2, aes(x = x, y = y)) +
  coord_cartesian(xlim = c(0, 5), ylim = c(0, 5)) + 
  scale_fill_manual(values = rev(c("green", "yellow", "orange", "red"))) theme(legend.position = "none") scale_fill_identity() scale_fill_manual()
-------------------------------------------------------------------------------------------------------
fill aes library(maps)
world<-map_data("world")

set.seed(123)
w2<-data.frame(world,data=sample(10,length(unique(world$group)),T)[world$group])

ggplot(w2,aes(long,lat,group=group,fill=data))+
    geom_polygon(color="white")+
    scale_fill_gradient(low="lightgreen",high="darkgreen")+
    theme(panel.background = element_rect(fill = "lightsteelblue2"))
-------------------------------------------------------------------------------------------------------
library(akima)

# interpolation
fld <- with(df, interp(x = Lon, y = Lat, z = Rain))

filled.contour(x = fld$x,
               y = fld$y,
               z = fld$z,
               color.palette =
                 colorRampPalette(c("white", "blue")),
               xlab = "Longitude",
               ylab = "Latitude",
               main = "Rwandan rainfall",
               key.title = title(main = "Rain (mm)", cex.main = 1)) library(ggplot)
library(reshape2)

# prepare data in long format
df <- melt(fld$z, na.rm = TRUE)
names(df) <- c("x", "y", "Rain")
df$Lon <- fld$x[df$x]
df$Lat <- fld$y[df$y]

ggplot(data = df, aes(x = Lon, y = Lat, z = Rain)) +
  geom_tile(aes(fill = Rain)) +
  stat_contour() +
  ggtitle("Rwandan rainfall") +
  xlab("Longitude") +
  ylab("Latitude") +
  scale_fill_continuous(name = "Rain (mm)",
                        low = "white", high = "blue") +
  theme(plot.title = element_text(size = 25, face = "bold"),
        legend.title = element_text(size = 15),
        axis.text = element_text(size = 15),
        axis.title.x = element_text(size = 20, vjust = -0.5),
        axis.title.y = element_text(size = 20, vjust = 0.2),
        legend.text = element_text(size = 10)) ggmap # grab a map. get_map creates a raster object
library(ggmap)
rwanda1 <- get_map(location = c(lon = 29.75, lat = -2),
                  zoom = 9,
                  maptype = "toner",
                  source = "stamen")
# alternative map
# rwanda2 <- get_map(location = c(lon = 29.75, lat = -2),
#                   zoom = 9,
#                   maptype = "terrain")

# plot the raster map
g1 <- ggmap(rwanda1)
g1

# plot map and rain data
# use coord_map with default mercator projection
g1 + 
  geom_tile(data = df, aes(x = Lon, y = Lat, z = Rain, fill = Rain), alpha = 0.8) +
  stat_contour(data = df, aes(x = Lon, y = Lat, z = Rain)) +
  ggtitle("Rwandan rainfall") +
  xlab("Longitude") +
  ylab("Latitude") +
  scale_fill_continuous(name = "Rain (mm)",
                        low = "white", high = "blue") +
  theme(plot.title = element_text(size = 25, face = "bold"),
        legend.title = element_text(size = 15),
        axis.text = element_text(size = 15),
        axis.title.x = element_text(size = 20, vjust = -0.5),
        axis.title.y = element_text(size = 20, vjust = 0.2),
        legend.text = element_text(size = 10)) +
  coord_map() # Since I don't have your map object, I do like this instead:
# get map data from
# http://biogeo.ucdavis.edu/data/diva/adm/RWA_adm.zip
# unzip files to folder named "rwanda"

# read shapefile with rgdal::readOGR
# just try the first out of three shapefiles, which seemed to work.
# 'dsn' (data source name) is the folder where the shapefile is located
# 'layer' is the name of the shapefile without the .shp extension.

library(rgdal)
rwa <- readOGR(dsn = "rwanda", layer = "RWA_adm0")
class(rwa)
# [1] "SpatialPolygonsDataFrame"

# convert SpatialPolygonsDataFrame object to data.frame
rwa2 <- fortify(rwa)
class(rwa2)
# [1] "data.frame"

# plot map and raindata  
ggplot() + 
  geom_polygon(data = rwa2, aes(x = long, y = lat, group = group),
               colour = "black", size = 0.5, fill = "white") +
  geom_tile(data = df, aes(x = Lon, y = Lat, z = Rain, fill = Rain), alpha = 0.8) +
  stat_contour(data = df, aes(x = Lon, y = Lat, z = Rain)) +
  ggtitle("Rwandan rainfall") +
  xlab("Longitude") +
  ylab("Latitude") +
  scale_fill_continuous(name = "Rain (mm)",
                        low = "white", high = "blue") +
  theme_bw() +
  theme(plot.title = element_text(size = 25, face = "bold"),
        legend.title = element_text(size = 15),
        axis.text = element_text(size = 15),
        axis.title.x = element_text(size = 20, vjust = -0.5),
        axis.title.y = element_text(size = 20, vjust = 0.2),
        legend.text = element_text(size = 10)) +
  coord_map()
-------------------------------------------------------------------------------------------------------
geom_polygon poly_df <- rbind(setNames(toyset[,1:2],c('x','y')),
                 setNames(toyset[6:1,3:4],c('x','y')))

ggplot(toyset) + 
    geom_path(aes(xa, ya)) + 
    geom_path(aes(xb, yb)) +
    geom_point(aes(xa, ya)) + 
    geom_point(aes(xb, yb)) +
    geom_polygon(data = poly_df,aes(x = x,y = y),fill = "lightblue",alpha = 0.25) geom_path
-------------------------------------------------------------------------------------------------------
require(ggplot2)   
require(cshapes)

world <- cshp(date=as.Date("2012-01-1"))
world.points <- fortify(world, region='COWCODE')

world.points2 <- merge(world.points,world@data,by.x="id",by.y="COWCODE",all.x=TRUE )

# Add a variable 'size' per country 
world.points2$size <- factor(ifelse(world.points2$AREA < 121600,"small",ifelse(world.points2$AREA > 515000, "large", "medium")))

# Coord_fixed fixes the aspect ratio.
p <- ggplot(world.points2,aes(long,lat,group=group,fill=size)) + geom_polygon(colour="grey50") + coord_fixed()
p
-------------------------------------------------------------------------------------------------------
readOGR ggplot2 RColorBrewer ggplot2 aes geom_polygon # if the packages are not installed, you will have to install and load them.
install.packages("rgdal")
install.packages("ggplot2")
install.packages("scales")
library(rgdal)
library(ggplot2)
library(scales)

require(rgdal)
require(ggplot2)
require(scales)

work.dir <- "your_dirname" # your directory
                                     # no trailing slash

orl <- readOGR(work.dir, layer = "Orleans_ZCTA_2010_SP")
orl.df <- fortify(orl) # ggplot needs data frame, not spatial object

ggplot(data = orl.df, aes(x = long, y = lat, group = group)) +
    geom_polygon(aes(fill = orl.df$group)) +
    coord_equal() +
    theme(legend.position = "none")
-------------------------------------------------------------------------------------------------------
griddg Tps xvals <- seq(-10, 4, len=20)
yvals <- seq(49, 63, len=20)
griddf <- expand.grid(lon=xvals, lat=yvals)
griddg <- predict(fit, x=as.matrix(griddf) )

dat2 <- cbind(griddf, mm=griddg)
head(dat2)
fit <- Tps(cbind(dat2$lon, dat2$lat), dat2$mm, scale.type="unscaled")
surface (fit, nx=100, ny=100)
world(add=TRUE) Tps #option 2
source("matrix.poly.r") #http://menugget.blogspot.de/2012/04/create-polygons-from-matrix.html
source("val2col.R") # http://menugget.blogspot.de/2011/09/converting-values-to-color-levels.html
source("image.scale.R") # http://menugget.blogspot.de/2011/08/adding-scale-to-image-plot.html

#new grid and predition
xvals <- seq(-10, 4, len=100)
yvals <- seq(49, 63, len=100)
griddf <- expand.grid(lon=xvals, lat=yvals)
griddg <- predict(fit, x=as.matrix(griddf) )

#make polygons for new grid, calculate color levels
mat <- matrix(griddg, nrow=length(xvals), ncol=length(yvals))
poly <- matrix.poly(xvals, yvals, z=mat, n=seq(mat))
pal <- colorRampPalette(c("blue", "cyan", "yellow", "red"))
COL <- val2col(mat, col=pal(100))

#required packages
library(maps)
library(mapproj)

#plot
png("tmp.png", width=5, height=4, res=400, units="in")
layout(matrix(1:2, nrow=1, ncol=2), widths=c(4,1), heights=4)
par(mar=c(1,1,1,1))
map("world", proj="stereographic", orient=c(mean(yvals),mean(xvals),0), par=NULL, t="n", xlim=range(xvals), ylim=range(yvals))
for(i in seq(poly)){
 polygon(mapproject(poly[[i]]), col=COL[i], border=COL[i], lwd=0.3)
}
map("world", proj="stereographic", orient=c(mean(yvals),mean(xvals),0), par=NULL, add=T)
map.grid(col=rgb(0,0,0,0.5), labels=F)
box()

par(mar=c(5,0,5,4))
image.scale(mat, col=pal(100), horiz=FALSE, axes=FALSE, xlab="", ylab="")
axis(4)
mtext("mm", side=4, line=2.5)
box()

dev.off()
-------------------------------------------------------------------------------------------------------
library(lubridate)
library(reshape2)
# simulating data...
Date  <- seq(as.Date("1953-10-01"),as.Date("2010-10-01"),by="day")
Year  <- year(Date)
Month <- month(Date)
Day <- day(Date)
set.seed(1)
Flow <- rpois(length(Date), 2000)
Data <- data.frame(Date=Date,Year=Year,Month=Month,Day=Day,Flow=Flow)

# use acast to get it in a convenient shape:
PlotData <- acast(Data,Year~Month+Day,value.var="Flow")
# apply for quantiles
Quantiles <- apply(PlotData,2,function(x){
    quantile(x,probs=c(1,.9,.75,.5,.25,.1,0),na.rm=TRUE)
  })
Mean <- colMeans(PlotData, na.rm=TRUE)
# ugly way to get month tick separators
MonthTicks <- cumsum(table(unlist(lapply(strsplit(names(Mean),split="_"),"[[",1))))

# and finally your question:
plot(1:366,seq(0,max(Flow),length=366),type="n",xlab = "Water Year",ylab="Discharge",axes=FALSE)
polygon(c(1:366,366:1),c(Quantiles["50%",],rev(Quantiles["75%",])),border=NA,col=gray(.6))
polygon(c(1:366,366:1),c(Quantiles["50%",],rev(Quantiles["25%",])),border=NA,col=gray(.4))
lines(1:366,Quantiles["90%",], col = gray(.5), lty=4)
lines(1:366,Quantiles["10%",], col = gray(.5))
lines(1:366,Quantiles["100%",], col = gray(.7))
lines(1:366,Quantiles["0%",], col = gray(.7), lty=4)
lines(1:366,Mean,lwd=3)
axis(1,at=MonthTicks, labels=NA)
text(MonthTicks-15,-100,1:12,pos=1,xpd=TRUE)
axis(2) polygon()
-------------------------------------------------------------------------------------------------------
library(raster)
adm1 <- getData('GADM', country='HUN', level=0)
adm2 <- getData('GADM', country='HUN', level=1) fortify ggplot library(ggplot2)
fadm1 = fortify(adm1)
fadm2 = fortify(adm2) ggplot(fadm1, aes(x = long, y = lat, group = group)) + geom_path() +
    geom_polygon(data = fadm2, aes(x = long, y = lat), 
                 fill = "green", alpha = 0.5) +
    geom_path(data = fadm2, aes(x = long, y = lat), color = "blue") + 
    theme_bw() m0 + geom_polygon(size = .01,
        aes(x = long, y = lat, group = group, fill = as.factor('red')),
        data = MapC,
        alpha = .6) +
    geom_path(color = 'grey50', size = .1, aes(x = long, y = lat, group = group),
        data=MapP, alpha=.9) +
    guides(fill=FALSE)
-------------------------------------------------------------------------------------------------------
# read data into R (for example - your states)
shapefile <- readShapeSpatial(’tr48_d00.shp’,proj4string = CRS("+proj=longlat +datum=WGS84"))
# convert to a data.frame using fortify function
data <- fortify(shapefile)
#and plot your data using qmap or ggmap
qmap(’texas’, zoom = 6, maptype = ’satellite’) + geom_polygon(aes(x = long, y = lat, group = group), data = data,colour = ’white’, fill = ’black’, alpha = .4, size = .3)
-------------------------------------------------------------------------------------------------------
library(ggplot2); library(animation); library(maps); library(plyr)

county <- map_data("county")

wy <- county[county$region =="wyoming",]

l = length((wy$subregion))
#Add random variales
wy <- mutate(wy, a = runif(length(region)), 
             b = runif(length(region)), 
             c= runif(length(region)))

test <- function(j){             
  ggplot(wy, aes(long, lat, group = group))+ 
    geom_path() + 
    geom_polygon(aes_string(fill=j))
}

test("c")
test("b")

wy$1 <- wy$a

oopt <- animation::ani.options(interval = 0.1)

FUN2 <- function() {
  v = c("a","b","c")
  lapply(v, function(i) {
    print(test(i))
    ani.pause()
  })
}
FUN2()

saveHTML(FUN2(), autoplay = FALSE, loop = FALSE, verbose = FALSE, outdir = "images/animate/new",
         single.opts = "'controls': ['first', 'previous', 'play', 'next', 'last', 'loop', 'speed'], 'delayMin': 0") print(test(i))
-------------------------------------------------------------------------------------------------------
segment plot(...,type='l') + polygon(..) plot(c(0,0.5,0,1,1,0), c(0,0.5,1,1,0,0), type="l")
polygon(c(0,0.5,0,1,1,0), c(0,0.5,1,1,0,0), col="grey")
-------------------------------------------------------------------------------------------------------
star <- function(n){
    x11(width=5, height=5)
v.x <- seq(0, 2*pi - pi/n , length.out=2*n)
v.x[seq(1, length.out=n, by=2)] <- cos(v.x[seq(1, length.out=n, by=2)])
v.x[seq(2, length.out=n, by=2)] <- cos(v.x[seq(2, length.out=n, by=2)])*0.5
v.y <- seq(0, 2*pi, length.out=2*n - 1)
v.y[seq(1, length.out=n, by=2)] <- sin(v.y[seq(1, length.out=n, by=2)])
v.y[seq(2, length.out=n, by=2)] <- sin(v.y[seq(2, length.out=n, by=2)])*0.5
plot(-1:1, -1:1, type="n", axes=FALSE, xlab="", ylab="")
polygon(x=v.x, y=v.y)
}

# par(mfrow=c(3,3))
# for (k in 1:9){
#    star(k*5)
# }
n <- as.numeric(readline(prompt="Enter n corner > ")) ; star(n)
-------------------------------------------------------------------------------------------------------
ggplot SpatialPolygonsDataFrame data.frame ggplot2 fortify fortify.SpatialPolygonsDataFrame data id data.frame data SpatialPolygonsDataFrame data.frames c10 <- fortify(colorado.county10)

c10d <- cbind(c10, colorado.county10@data[c10$id,])

ggplot(c10d, aes(long, lat, group = group)) +
   geom(aes(fill = factor(P0010001)), colour = alpha("white", 1/2), size = 0.2) +
   scale_fill_brewer(pal = "PuRd") base
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(reshape)
event.day <- c("A", "A", "A", "A", "B", "B")
event <- c(1, 2, 3, 4, 5, 6)
sys <- c(120, 160, 100, 180, 100, 180)
duration <- c(50, 100, 50, 150, 350, 0)
df <- data.frame(event.day, event, sys, duration)
df$end <- c(df$sys[-1], NA)

## replacing na values
df.value.na <- is.na(df$end)
df[df.value.na,]$end <- df[df.value.na,]$sys

## calculating the slope
df$slope <- df$end / df$sys

## creating rows for each event depending on the duration
event.id <- vector()
segment.id <- vector()

for(i in 1:nrow(df)) {
event.id <- c(event.id, rep(df[i,]$event, each = df[i,]$duration))
segment.id <- c(segment.id,c(1:df[i,]$duration))
}

## merging the original dataframe with the additional segments
df.segments <- data.frame(event.id, segment.id) 
df <- merge(df, df.segments, by.x = c("event"), by.y = c("event.id"))

## calculate the start and end values for the newly created segements
df$segment.start <- df$sys + (df$segment.id - 1) * (df$end - df$sys) / df$duration
df$segment.end <- df$sys + (df$segment.id) * (df$end - df$sys) / df$duration

## just a simple calculation
value.max <- max(df$sys)

df$high <- 1 + 0.45 * df$segment.end / value.max
df$low <- 1 - 0.45 * df$segment.end / value.max
df$percent <- df$segment.end / value.max 
df$id <- seq_along(df$sys)
df$idByDay <- ave( 1:nrow(df), df$event.day,FUN=function(x) seq_along(x))


## how many events in total, necessary
newevents <- nrow(df)

## subsetting the original data.frame
df <- df[,c("event.day", "id", "idByDay", "segment.id", "segment.start", "duration", "segment.end", "high", "low", "percent")]

## melting the data.frame
df.melted <- melt(df, id.vars = c("event.day", "id", "idByDay", "segment.id", "segment.start", "duration", "segment.end","percent"))
df.melted <- df.melted[order(df.melted$id,df.melted$segment.id),]

## this is a tricky one, basically this a self join, of two tables
#  every event is available twice, this is due to melt in the previous section
#  a dataframe is produced where every event is contained 4 times, except the first and last 2 rows,
#  the first row marks the start of the first polygon
#  the last row marks the end of the last polygon
df.melted <- rbind(df.melted[1:(nrow(df.melted)-2),],df.melted[3:nrow(df.melted),])
df.melted <- df.melted[order(df.melted$id,df.melted$segment.id),]


## grouping, necessary for drawing the polygons
#  the 1st polygon spans from the 1st event, and the first 2 rows from 2nd event
#  the 2nd polygon spans from last 2 rows of the 2nd event and the first 2 rows from 3rd event
#  ...
#  the last polygon spans from the last 2 rows of the next to last event and the 2 rows of the last event
df.melted$grouping <- rep (1:(newevents-1), each=4)
df.melted <- df.melted[order(df.melted$id, df.melted$grouping, df.melted$variable), ]


## adding a 4 point for each group
df.melted$point <- rep(c(1,2,4,3),(newevents-1))
df.melted <- df.melted[order(df.melted$grouping,df.melted$point), ]

## drawing the polygons
p <-        ggplot()

p <- p +    geom_polygon(data = df.melted,aes(x = value,y =idByDay,group = grouping,fill = percent)) 

p <- p +    labs(x = "something", y="something else")

p <- p +    theme(
                panel.background = element_blank()
                #,panel.grid.minor = element_blank()
            #axis.title.x=element_blank()
                #,axis.text.x=element_text(size=12, face=2, color="darkgrey")
                #,axis.title.y=element_blank()
            #,axis.ticks.y = element_blank()
                #,axis.text.y = element_blank()
)

p <- p +    scale_fill_gradient(
            low = "lightgrey"
            ,high = "red"
            ,guide = 
                guide_legend(
                    title = "Sys" 
                    ,order = 1
                    ,reverse = FALSE
                    ,ncol = 2
                    ,override.aes = list(alpha = NA)
                )
        )

p <- p +    facet_wrap(~event.day, ncol=2)

p
-------------------------------------------------------------------------------------------------------
<<Heatmap matrix variable>> library(RColorBrewer) #to use brewer.pal
library(fields) #to use designer.colors

#Function to create the polygon for each hexagon
Hexagon <- function (x, y, unitcell = 1, col = col) {
  polygon(c(x, x, x + unitcell/2, x + unitcell, x + unitcell, x + unitcell/2), c(y + unitcell), col = col, border=NA)
}#function

#Start with a matrix that would be the numerical representation of you heatmap
#Here [1,1] will become the lower left node (1st row, 1st column), 
#[1,2] will become the node to the right
#[2,1] will be the first node to the left in the second row
#So visually you work your way from bottom left to top right
x <- as.vector(<<Heatmap matrix variable>>)

#Number of rows and columns of your SOM
SOM_Rows <- dim(<<Heatmap matrix variable>>)[1]
SOM_Columns <- dim(<<Heatmap matrix variable>>)[2]

#To make room for the legend
par(mar = c(0.4, 2, 2, 7))

#Initiate the plot window but do show any axes or points on the plot
plot(0, 0, type = "n", axes = FALSE, xlim=c(0, SOM_Columns), 
     ylim=c(0, SOM_Rows), xlab="", ylab= "", asp=1)

#Create the color palette 
#I use designer.colors to interpolate 50 colors between 
#the maxmimum number of allowed values in Brewer 
ColRamp <- rev(designer.colors(n=50, col=brewer.pal(9, "Spectral")))

#Make a vector with length(ColRamp) number of bins between the minimum and 
#maximum value of x. 
#Next match each point from x with one of the colors in ColorRamp
ColorCode <- rep("#FFFFFF", length(x)) #default is all white
Bins <- seq(min(x, na.rm=T), max(x, na.rm=T), length=length(ColRamp))
for (i in 1:length(x))
    if (!is.na(x[i])) ColorCode[i] <- ColRamp[which.min(abs(Bins-x[i]))] 

#Actual plotting of hexagonal polygons on map
offset <- 0.5 #offset for the hexagons when moving up a row
for (row in 1:SOM_Rows) {
  for (column in 0:(SOM_Columns - 1)) 
     Hexagon(column + offset, row - 1, col = ColorCode[row + SOM_Rows * column])
  offset <- ifelse(offset, 0, 0.5)
}

#Add legend to the right if you want to
image.plot(legend.only=TRUE, col=ColRamp, zlim=c(min(x, na.rm=T), max(x, na.rm=T)))
-------------------------------------------------------------------------------------------------------
rworldmap sp polygon spTransform rgdal library(rworldmap)
library(sp)

sPDFworld <- getMap(resolution="low")
#getMap() maps have ADMIN & NAME fields with country names formatted differently
#use sPDFworld$ADMIN sPDFworld$NAME to check

country <- "United Kingdom"

#to plot just this country (uses sp)
plot(sPDFworld[ sPDFworld$ADMIN==country, ] )

#shade a latitude region
polygon(x=c(-180,-180,180,180),y=c(55,60,60,55),col=adjustcolor('grey',alpha.f=0.5),border=NA)
-------------------------------------------------------------------------------------------------------
## Loading packages
    library(rgdal)
    library(plyr)
    library(maps)
    library(maptools)
    library(mapdata)
    library(ggplot2)
    library(RColorBrewer)
    library(foreign)  
    library(sp)

    ## get.centroids: function to extract polygon ID and centroid from shapefile
    get.centroids = function(x){
    poly = MoroccoReg@polygons[[x]]
    ID   = poly@ID
    centroid = as.numeric(poly@labpt)
    return(c(id=ID, long=centroid[1], lat=centroid[2]))
    }

    ## Loading shapefiles and .csv files
    #Morocco <- readOGR(dsn=".", layer="Morocco_adm0")
    MoroccoReg <- readOGR(dsn=".", layer="Morocco_adm1")
    MoroccoYield <- read.csv(file = "F:/Purdue University/RA_Position/PhD_ResearchandDissert/PhD_Draft/Country-CGE/RMaps_Morocco/Morocco_Yield.csv", header=TRUE, sep=",", na.string="NA", dec=".", strip.white=TRUE)
    MoroccoYield$ID_1 <- substr(MoroccoYield$ID_1,3,10) # Eliminate the ID_1 column

    ## Reorder the data in the shapefile
    MoroccoReg    <- MoroccoReg[order(MoroccoReg$ID_1), ]
    MoroccoYield  <- cbind(id=rownames(MoroccoReg@data),MoroccoYield) # Add the column "id" for correct merging with the spatial data 

    ## Build table of labels for annotation (legend).
    labs <- do.call(rbind,lapply(1:14,get.centroids))
    labs <- merge(labs,MoroccoYield[,c("id","ID_1","Label")],by="id")
    labs[,2:3] <- sapply(labs[,2:3],function(x){as.numeric(as.character(x))})
    labs$sort <- as.numeric(as.character(labs$ID_1))
    labs <- labs[order(labs$sort),]

    MoroccoReg.df <- fortify(MoroccoReg) # transform shapefile into dataframe
    MoroccoReg.df <- merge(MoroccoReg.df,MoroccoYield, by="id") # merge the spatial data and the yield data
    str(MoroccoReg.df)

    ## Define new theme for map
    ## I have found this function on the website
    theme_map <- function (base_size = 12, base_family = "") {
    theme_gray(base_size = base_size, base_family = base_family) %+replace% 
    theme(
    axis.line=element_blank(),
    axis.text.x=element_blank(),
    axis.text.y=element_blank(),
    axis.ticks=element_blank(),
    axis.ticks.length=unit(0.3, "lines"),
    axis.ticks.margin=unit(0.5, "lines"),
    axis.title.x=element_blank(),
    axis.title.y=element_blank(),
    legend.background=element_rect(fill="white", colour=NA),
    legend.key=element_rect(colour="white"),
    legend.key.size=unit(1.2, "lines"),
    legend.position="right",
    legend.text=element_text(size=rel(0.8)),
    legend.title=element_text(size=rel(0.8), face="bold", hjust=0),
    panel.background=element_blank(),
    panel.border=element_blank(),
    panel.grid.major=element_blank(),
    panel.grid.minor=element_blank(),
    panel.margin=unit(0, "lines"),
    plot.background=element_blank(),
    plot.margin=unit(c(1, 1, 0.5, 0.5), "lines"),
    plot.title=element_text(size=rel(1.2)),
    strip.background=element_rect(fill="grey90", colour="grey50"),
    strip.text.x=element_text(size=rel(0.8)),
    strip.text.y=element_text(size=rel(0.8), angle=-90) 
    )   
    }

    MoroccoRegMap1 <- ggplot(data = MoroccoReg.df, aes(long, lat, group = group)) 
    MoroccoRegMap1 <- MoroccoRegMap1 + geom_polygon(aes(fill = A2Med_noCO2))
    MoroccoRegMap1 <- MoroccoRegMap1 + geom_path(colour = 'gray', linestyle = 2)
    #MoroccoRegMap <- MoroccoRegMap + scale_fill_gradient(low = "#CC0000",high = "#006600")
    MoroccoRegMap1 <- MoroccoRegMap1 + scale_fill_gradient2(name = "%Change in yield",low = "#CC0000",mid = "#FFFFFF",high = "#006600")
    MoroccoRegMap1 <- MoroccoRegMap1 + labs(title="SRES_A2, noCO2 Effect")
    MoroccoRegMap1 <- MoroccoRegMap1 + coord_equal() + theme_map()
    MoroccoRegMap1 <- MoroccoRegMap1 + geom_text(data=labs, aes(x=long, y=lat, label=ID_1, group=ID_1), size=6)
    MoroccoRegMap1 <- MoroccoRegMap1 + annotate("text", x=max(labs$long)-5, y=min(labs$lat)+3-0.5*(1:14),
                                        label=paste(labs$ID_1,": ",labs$Label,sep=""),
                                        size=5, hjust=0)
    MoroccoRegMap1
-------------------------------------------------------------------------------------------------------
plot(1:100, -log(1:100), type="l")
polygon(c(1:100,1), c(-log(1:100),-log(100)),col="grey70")
-------------------------------------------------------------------------------------------------------
angle=pi/3
x <- c(0,0.5,0.5*cos(angle),0)
y <- c(0,0,sin(angle),0)
y1 <- c(0,0,-sin(angle),0)

plot(-1:1,-1:1,type='n')
polygon(x=x,y=y,col='red')      ## you can replace polygon by lines here 
polygon(x=x,y=y1,col='green')
-------------------------------------------------------------------------------------------------------
library(rgdal)
library(ggplot2)

work.dir <- "your_work_dir"
mun.neth <- readOGR(work.dir, layer = 'gem_2012_v1')

mun.neth.fort <- fortify(mun.neth, region = "AANT_INW")
mun.neth.fort$id <- as.numeric(mun.neth.fort$id)
mun.neth.fort$id <- mun.neth.fort$id/1000 # optionally change to thousands?
mun.neth.fort[mun.neth.fort$id <= 0, 'id'] <- NA # some areas not numerically valid,
                                                 # presumably water zones

ggplot(data = mun.neth.fort, aes(x = long, y = lat, fill = id, group = group)) +
    geom_polygon(colour = "black") +
    coord_equal() +
    theme()
-------------------------------------------------------------------------------------------------------
xlim <- c(min(x1,x2),max(x1,x2))
ylim <- c(min(y1,y2),max(y1,y2))
xlim <- xlim+c(-1,1)*(xlim[2]-xlim[1])*0.04 # extend by 4% on each side
ylim <- ylim+c(-1,1)*(ylim[2]-ylim[1])*0.04 # extend by 4% on each side
n1 <- length(x1)
n2 <- length(x2)
xS <- c(xlim[1],xlim,rev(xlim),xlim[1])
yS <- c(0,rep(ylim,each=2),0)
plot(NA,xlim=xlim,ylim=ylim,xaxs='i',yaxs='i')
polygon(xS,yS,border=NA,col=rgb(0,0,0))
polygon(c(x1,xS),c(y1,yS),border=NA,col=rgb(1,1,1))
polygon(c(x2,xS),c(y2,yS),border=NA,col=rgb(1,1,1))
box()
polygon(x1,y1)
polygon(x2,y2)
-------------------------------------------------------------------------------------------------------
xA <- 0:6
yA <- c(0,1,2,1,0,-1,0)
xB <- c(x1,rev(x1))
yB <- c(x1*rev(x1)/5,x1*rev(x1)/10)
plot(NA,xlim=extendrange(c(xA,xB)),
            ylim=extendrange(c(yA,yB)),xaxs='i',yaxs='i',frame.plot=F)
polygon(x = c(xA,tail(xA,1)), y = c(yA,0),col=rgb(1,0,1,0.5),border="white")
polygon(x = c(xB,tail(xB,1)), y = c(yB,0),col=rgb(1,0,1,0.5),border='white')
-------------------------------------------------------------------------------------------------------
MoroccoYields.csv -0.205 Region 4 l'Oriental (Region 6) ## Loading packages
library(rgdal)
library(plyr)
library(maps)
library(maptools)
library(mapdata)
library(ggplot2)
library(RColorBrewer)
library(foreign)  
library(sp)

# get.centroids: function to extract polygon ID and centroid from shapefile
get.centroids = function(x){
  poly = MoroccoReg@polygons[[x]]
  ID   = poly@ID
  centroid = as.numeric(poly@labpt)
  return(c(id=ID, long=centroid[1], lat=centroid[2]))
}
#setwd("Directory where shapefile and Yields are stored")
## Loading shapefiles and .csv files
MoroccoReg        <- readOGR(dsn=".", layer="Morocco_adm1")
MoroccoYield      <- read.csv(file = "Morocco_Yield.csv", header=TRUE, sep=",", na.string="NA", dec=".", strip.white=TRUE)
MoroccoYield$ID_1 <- substr(MoroccoYield$ID_1,3,10)

## Reorder the data in the shapefile based on the category variable "ID_1" and change to dataframe
MoroccoReg    <- MoroccoReg[order(MoroccoReg$ID_1), ]
MoroccoYield  <- cbind(id=rownames(MoroccoReg@data),MoroccoYield)
#  build table of labels for annotation (legend).
labs          <- do.call(rbind,lapply(1:14,get.centroids))
labs          <- merge(labs,MoroccoYield[,c("id","ID_1","Label")],by="id")
labs[,2:3]    <- sapply(labs[,2:3],function(x){as.numeric(as.character(x))})
labs$sort <- as.numeric(as.character(labs$ID_1))
labs          <- labs[order(labs$sort),]

MoroccoReg.df <- fortify(MoroccoReg)
## This does NOT work...
## Add the yield impacts column to shapefile from the .csv file by "ID_1"
## Note that in the .csv file, I just added the column "ID_1" to match it with the shapefile
#MoroccoReg.df <- cbind(MoroccoReg.df,MoroccoYield,by = 'ID_1')
## Do it this way...
MoroccoReg.df <- merge(MoroccoReg.df,MoroccoYield, by="id")

## Check the structure and contents of shapefile
attributes(MoroccoReg.df)
## Plotting 

MoroccoRegMap1 <- ggplot(data = MoroccoReg.df, aes(long, lat, group=id)) 
MoroccoRegMap1 <- MoroccoRegMap1 + geom_polygon(aes(fill = A2Med_noCO2))
MoroccoRegMap1 <- MoroccoRegMap1 + geom_path(colour = 'gray', linestyle = 2)
MoroccoRegMap1 <- MoroccoRegMap1 + scale_fill_gradient2(name = "%Change in yield",low = "#CC0000",mid = "#FFFFFF",high = "#006600")
MoroccoRegMap1 <- MoroccoRegMap1 + labs(title="SRES_A2, noCO2 Effect")
MoroccoRegMap1 <- MoroccoRegMap1 + coord_equal() #+ theme_map()
MoroccoRegMap1 <- MoroccoRegMap1 + geom_text(data=labs, aes(x=long, y=lat, label=ID_1), size=4)
MoroccoRegMap1 <- MoroccoRegMap1 + annotate("text", x=max(labs$long)-5, y=min(labs$lat)+3-0.5*(1:14),
                                            label=paste(labs$ID_1,": ",labs$Label,sep=""),
                                            size=3, hjust=0)
MoroccoRegMap1 MoroccoReg.df <- cbind(MoroccoReg.df,MoroccoYield,by = 'ID_1') cbind(...) cbind(...) MoroccoReg.df MoroccoYield cbind(...) by="ID_1" by" "ID_1" head(MoroccoReg.df) R ID_1 ID_1 csv "TR" MoroccoReg    <- MoroccoReg[order(MoroccoReg$ID_1), ] cbind(...) MoroccoYeild MoroccoYield  <- cbind(id=rownames(MoroccoReg@data),MoroccoYield) MoroccoYield id ID_1 fortify(...) merge(...) merge(...) by= MoroccoReg.df <- fortify(MoroccoReg)
MoroccoReg.df <- merge(MoroccoReg.df,MoroccoYield, by="id") MoroccoYield MoroccoReg.df MoroccoYield$ID_1 MoroccoYield$Label get.centroid(...) MoroccoYield labs id:    polygon ID
long:  centroid longitude
lat:   centroid latitude
ID_1:  region ID
label: region name
sort:  a sortable (numeric) version of ID_1 ...
MoroccoRegMap1 <- MoroccoRegMap1 + geom_text(data=labs, aes(x=long, y=lat, label=label.id), size=4)
MoroccoRegMap1 <- MoroccoRegMap1 + annotate("text", x=max(labs$long)-5, y=min(labs$lat)+3-0.5*(1:14),
                                            label=paste(labs$label.id,": ",labs$Label,sep=""),
                                            size=3, hjust=0) annotate(...) MoroccoRegMap1 <- ggplot(data = MoroccoReg.df, aes(long, lat, group=group)) 
MoroccoRegMap1 <- MoroccoRegMap1 + geom_polygon(aes(fill = A2Med_noCO2))
MoroccoRegMap1 <- MoroccoRegMap1 + geom_path(colour = 'gray', linestyle = 2)
MoroccoRegMap1 <- MoroccoRegMap1 + scale_fill_gradient2(name = "%Change in yield",low = "#CC0000",mid = "#FFFFFF",high = "#006600")
MoroccoRegMap1 <- MoroccoRegMap1 + labs(title="SRES_A2, noCO2 Effect")
MoroccoRegMap1 <- MoroccoRegMap1 + coord_equal() #+ theme_map()
MoroccoRegMap1 <- MoroccoRegMap1 + geom_text(data=labs, aes(x=long, y=lat, label=ID_1, group=ID_1), size=4)
MoroccoRegMap1 <- MoroccoRegMap1 + annotate("text", x=max(labs$long)-5, y=min(labs$lat)+3-0.5*(1:14),
                                            label=paste(labs$ID_1,": ",labs$Label,sep=""),
                                            size=3, hjust=0) ggplot MoroccoReg.df$group aes(..., group=group) aes(...,group=id) ggplot "group" geom_text(...) labs group group geom_text(...)
-------------------------------------------------------------------------------------------------------
density angle polygon() x=seq(-7,10,length=200)
 y1=dnorm(x,mean=0,sd=1)
 plot(x,y1,type="l",lwd=2,col="red")
 y2=dnorm(x,mean=3,sd=2)
 lines(x,y2,type="l",lwd=2,col="blue")


 polygon(x,pmin(y1,y2), density = 10, angle = -45)
-------------------------------------------------------------------------------------------------------
plot(NA,xlim=c(0,1),ylim=c(0,1), xaxs="i",yaxs="i") # Empty plot
a <- curve(x^2-0.25, add = TRUE) # First curve
b <- curve(0.5-x^4, add = TRUE) # Second curve
names(a) <- c('xA','yA')
names(b) <- c('xB','yB')
with(as.list(c(b,a)),{
    id <- yB<=yA
    # b<a area
    polygon(x = c(xB[id], rev(xA[id])),y = c(yB[id], rev(yA[id])), density=10, angle=60, border=NULL)
    # a>b area
    polygon(x = c(xB[!id], rev(xA[!id])),y = c(yB[!id], rev(yA[!id])), density=10, angle=30, border=NULL)
})
-------------------------------------------------------------------------------------------------------
sf fill= aes() geom_polygon() score qmap('oakland, ca', zoom=10,maptype='hybrid') + 
     geom_polygon(aes(x=long, y=lat, group=group, fill=score), 
                     data=sf, colour="white",alpha=.5, size=.3)
-------------------------------------------------------------------------------------------------------
require("rgdal")
require("maptools")
require("ggplot2")
require("plyr")

# read temperature data
setwd("<location if your data file>")
temp.data        <- read.csv(file = "levels.dat", header=TRUE, sep=" ", na.string="NA", dec=".", strip.white=TRUE)
temp.data$CODINE <- str_pad(temp.data$CODINE, width = 5, side = 'left', pad = '0')

# read municipality polygons
setwd("<location of your shapefile")
esp     <- readOGR(dsn=".", layer="poligonos_municipio_etrs89")
muni    <- subset(esp, esp$PROVINCIA == "46" | esp$PROVINCIA == "12" | esp$PROVINCIA == "3")
# fortify and merge: muni.df is used in ggplot
muni@data$id <- rownames(muni@data)
muni.df <- fortify(muni)
muni.df <- join(muni.df, muni@data, by="id")
muni.df <- merge(muni.df, temp.data, by.x="CODIGOINE", by.y="CODINE", all.x=T, a..ly=F)
# create the map layers
ggp <- ggplot(data=muni.df, aes(x=long, y=lat, group=group)) 
ggp <- ggp + geom_polygon(aes(fill=LEVEL))         # draw polygons
ggp <- ggp + geom_path(color="grey", linestyle=2)  # draw boundaries
ggp <- ggp + coord_equal() 
ggp <- ggp + scale_fill_gradient(low = "#ffffcc", high = "#ff4444", 
                                 space = "Lab", na.value = "grey50",
                                 guide = "colourbar")
ggp <- ggp + labs(title="Temperature Levels: Comunitat Valenciana")
# render the map
print(ggp) readOGR(...) SpacialDataFrame muni@polygons muni@data fortify(...) ggplot [1] Import temperature data file (temp.data)
[2] Import polygon shapefile of municipalities (muni)
[3] Convert muni polygons to a data frame for plotting (muni.df <- fortify(...))
[4] Join columns from muni@data to muni.df
[5] Join columns from temp.data to muni.df
[6] Make the plot fortify(...) id id muni@data muni@data$id <- rownames(muni@data) id muni@data id muni.df muni.df <- join(muni.df, muni@data, by="id") LEVEL temp.data muni.df temp.data CODINE CODIGOINE muni.df CODIGOINE char(5) CODINE CODINE char(5) temp.data$CODINE <- str_pad(temp.data$CODINE, width = 5, side = 'left', pad = '0') temp.dat muni.df muni.df <- merge(muni.df, temp.data, by.x="CODIGOINE", by.y="CODINE", all.x=T, a..ly=F) merge(...) join(...) join(...) join(...) LEVEL geom_polygon(...) geom_path(...)
-------------------------------------------------------------------------------------------------------
lattice::xyplot library(lattice)
library(zoo)
library(colorspace)

nCols <- ncol(unemployUSA)
pal <- rainbow_hcl(nCols, c=70, l=75, start=30, end=300)
myTheme <- custom.theme(fill=pal, lwd=0.2)

xyplot(unemployUSA, superpose=TRUE, auto.key=FALSE,
       panel=panel.flow, prepanel=prepanel.flow,
       origin='themeRiver', scales=list(y=list(draw=FALSE)),
       par.settings=myTheme) xyplot panel.flow prepanel.flow panel.flow <- function(x, y, groups, origin, ...){
  dat <- data.frame(x=x, y=y, groups=groups)
  nVars <- nlevels(groups)
  groupLevels <- levels(groups)

  ## From long to wide
  yWide <- unstack(dat, y~groups)
  ## Where are the maxima of each variable located? We will use
  ## them to position labels.
  idxMaxes <- apply(yWide, 2, which.max)

  ##Origin calculated following Havr.eHetzler.ea2002
  if (origin=='themeRiver') origin= -1/2*rowSums(yWide)
  else origin=0 
  yWide <- cbind(origin=origin, yWide)
  ## Cumulative sums to define the polygon
  yCumSum <- t(apply(yWide, 1, cumsum))
  Y <- as.data.frame(sapply(seq_len(nVars),
                            function(iCol)c(yCumSum[,iCol+1],
                                            rev(yCumSum[,iCol]))))
  names(Y) <- levels(groups)
  ## Back to long format, since xyplot works that way
  y <- stack(Y)$values

  ## Similar but easier for x
  xWide <- unstack(dat, x~groups)
  x <- rep(c(xWide[,1], rev(xWide[,1])), nVars)
  ## Groups repeated twice (upper and lower limits of the polygon)
  groups <- rep(groups, each=2)

  ## Graphical parameters
  superpose.polygon <- trellis.par.get("superpose.polygon")
  col = superpose.polygon$col
  border = superpose.polygon$border 
  lwd = superpose.polygon$lwd 

  ## Draw polygons
  for (i in seq_len(nVars)){
    xi <- x[groups==groupLevels[i]]
    yi <- y[groups==groupLevels[i]]
    panel.polygon(xi, yi, border=border,lwd=lwd, col=col[i])
  }

  ## Print labels
  for (i in seq_len(nVars)){
    xi <- x[groups==groupLevels[i]]
    yi <- y[groups==groupLevels[i]]
    N <- length(xi)/2
    ## Height available for the label
    h <- unit(yi[idxMaxes[i]], 'native') -
      unit(yi[idxMaxes[i] + 2*(N-idxMaxes[i]) +1], 'native')
    ##...converted to "char" units
    hChar <- convertHeight(h, 'char', TRUE)
    ## If there is enough space and we are not at the first or
    ## last variable, then the label is printed inside the polygon.
    if((hChar >= 1) && !(i %in% c(1, nVars))){
      grid.text(groupLevels[i],
                xi[idxMaxes[i]],
                (yi[idxMaxes[i]] +
                 yi[idxMaxes[i] + 2*(N-idxMaxes[i]) +1])/2,
                gp = gpar(col='white', alpha=0.7, cex=0.7),
                default.units='native')
    } else {
      ## Elsewhere, the label is printed outside

      grid.text(groupLevels[i],
                xi[N],
                (yi[N] + yi[N+1])/2,
                gp=gpar(col=col[i], cex=0.7),
                just='left', default.units='native')
    }
  }
}

prepanel.flow <- function(x, y, groups, origin,...){
  dat <- data.frame(x=x, y=y, groups=groups)
  nVars <- nlevels(groups)
  groupLevels <- levels(groups)
  yWide <- unstack(dat, y~groups)
  if (origin=='themeRiver') origin= -1/2*rowSums(yWide)
  else origin=0
  yWide <- cbind(origin=origin, yWide)
  yCumSum <- t(apply(yWide, 1, cumsum))

  list(xlim=range(x),
       ylim=c(min(yCumSum[,1]), max(yCumSum[,nVars+1])),
       dx=diff(x),
       dy=diff(c(yCumSum[,-1])))
}
-------------------------------------------------------------------------------------------------------
# Set a seed to get a reproducible example
set.seed(12345)

num.points <- 100

# Create some data
x.vals <- 1:num.points
values <- rnorm(n=num.points, mean=0, sd=10)

# Plot the graph
plot(x.vals, values, t="o", pch=20, xlab="", ylab="", las=1)
abline(h=0, col="darkgray", lwd=2)

# We need to find the intersections of the curve with the x axis
# Those lie between positive and negative points
# When the sign changes the product between subsequent elements
# will be negative
crossings <- values[-length(values)] * values[-1]
crossings <- which(crossings < 0)

# You can draw the points to check (uncomment following line)
# points(x.vals[crossings], values[crossings], col="red", pch="X")

# We now find the exact intersections using a proportion
# See? Those high school geometry problems finally come in handy
intersections <- NULL
for (cr in crossings)
  {
  new.int <- cr + abs(values[cr])/(abs(values[cr])+abs(values[cr+1]))
  intersections <- c(intersections, new.int)
  }

# Again, let's check the intersections
# points(intersections, rep(0, length(intersections)), pch=20, col="red", cex=0.7)

last.intersection <- 0
for (i in intersections)
  {
  ids <- which(x.vals<=i & x.vals>last.intersection)
  poly.x <- c(last.intersection, x.vals[ids], i)
  poly.y <- c(0, values[ids], 0)
  if (max(poly.y) > 0)
    {
    col="green"
    }
  else
    {
    col="red"
    }
  polygon(x=poly.x, y=poly.y, col=col)

  last.intersection <- i
  }
-------------------------------------------------------------------------------------------------------
x1<-rnorm(250,0.4,0.9)
x <- as.matrix(x1)
# t <- ts(x[,1], start=c(1,1), frequency=30)
plot(x1,main="Daily closing price of Walterenergie",ylab="Adjusted close Returns",xlab="Times",col="blue", type="l")
polygon( c(0,1:250,251), c(0, x1, 0) , col="red") plot(t,main="Daily closing price of Walterenergie",ylab="Adjusted close Returns",xlab="Times",col="blue", type="l")
polygon( c(1,1+(0:250)/30), c(0, t, 0) , col="red")
-------------------------------------------------------------------------------------------------------
#  Not tested...
ggplot(outputData, aes(long,lat, group = group)) + 
  geom_polygon(aes(fill = meanadjsmr)) + 
  geom_path() +
  labs(x=" ", y=" ") + 
  scale_fill_manual(name = "", values = cust_brewer) + 
  theme(legend.text = element_text(size = 12)) color=black geom_path(...)
-------------------------------------------------------------------------------------------------------
cover <- do.call(rbind, list( data.frame(x=1,y=0), 
                                 subset(df, x > 1),  # the x,y points
                                  data.frame(x=df[nrow(df), "x"],y= 0), # drop to y=0
                                  data.frame(x=1,y=0)) )  # complete the bottom
  p + geom_segment(aes(x=1,y=0, xend=2.5, yend=ytop)) +
       geom_polygon(data = cover, aes(x, y)) cover <- do.call(rbind, list( data.frame(x=1,y=0), 
                               subset(df, x > 1), 
                               data.frame(x=df[nrow(df), "x"],y= -0.001), 
                               data.frame(x=1,y=0)) ) cover <- do.call(rbind, list( data.frame(x=1,y=0), 
                              subset(df, x > 1), 
                              data.frame(x=df[nrow(df), "x"],y= -0.001)) )
-------------------------------------------------------------------------------------------------------
readOGR(...) fortify(...) library(rgdal)
library(ggplot2)
library(stringr)
library(RColorBrewer)

setwd("<directory containing shapfiles and sample data>")

data     <- read.csv("Sample.csv",header=T) # your sample data, downloaded as csv
data$ZIP <- str_pad(data$ZIP,5,"left","0") # convert ZIP to char(5) w/leading zeros

zips     <- readOGR(dsn=".","tl_2013_us_zcta510") # import zip code polygon shapefile
map      <- zips[zips$ZCTA5CE10 %in% data$ZIP,]   # extract only zips in your Sample.csv
map.df   <- fortify(map)        # convert to data frame suitable for plotting
# merge data from Samples.csv into map data frame
map.data <- data.frame(id=rownames(map@data),ZIP=map@data$ZCTA5CE10)
map.data <- merge(map.data,data,by="ZIP")
map.df   <- merge(map.df,map.data,by="id")
# load state boundaries
states <- readOGR(dsn=".","gz_2010_us_040_00_5m")
states <- states[states$NAME %in% c("New York","New Jersey"),] # extract NY and NJ
states.df <- fortify(states)    # convert to data frame suitable for plotting

ggMap <- ggplot(data = map.df, aes(long, lat, group = group)) 
ggMap <- ggMap + geom_polygon(aes(fill = Probability_1))
ggMap <- ggMap + geom_path(data=states.df, aes(x=long,y=lat,group=group))
ggMap <- ggMap + scale_fill_gradientn(name="Probability",colours=brewer.pal(9,"Reds"))
ggMap <- ggMap + coord_equal()
ggMap rgdal map map@polygons map@data Sample.csv 1. Load polygon shapefiles into Spatial object ( => zips)
2. Subset if appropriate ( => map).
3. Convert to data frame suitable for plotting ( => map.df).
4. Merge data from Sample.csv into map.df.
5. Draw the map. Probability_1 map@data map@data ZCTA5CE10 map@data id map@data$ZCTA5CE10 ZIP Sample.csv map.df long lat group map.df fortify(...) geom_polygon(...) map.df$Probability_1 geom_path(...) scale_fill_gradientn(...) coord_equal(...)
-------------------------------------------------------------------------------------------------------
g <- data.frame(x=c(1,.6,.6),
                y=c(0,.4,0),
                z=c(0,0,.4),         Series="Green")
y <- data.frame(x=c(.6,.1,.1,.3,.6),
                y=c(.4,.9,.5,.3,.3),
                z=c( 0, 0,.4,.4,.1), Series="Yellow")
b <- data.frame(x=c(.6,.3,.3,.6),
                y=c(.3,.3, 0, 0),
                z=c(.1,.4,.7,.4),    Series="Blue")
r <- data.frame(x=c(.3, 0,0,.3),
                y=c(.3,.3,0, 0),
                z=c(.4,.7,1,.7),     Series="Red")
p <- data.frame(x=c(.1,0, 0,.3,.1),
                y=c(.9,1,.3,.3,.5),
                z=c( 0,0,.7,.4,.4),  Series="Purple")
DATA=rbind(g,y,b,r,p)
ggtern(data=DATA,aes(x,y,z)) + 
geom_polygon(aes(fill=Series),alpha=.5,color="black",size=0.25) +
  scale_fill_manual(values=as.character(unique(DATA$Series))) +
  theme(legend.position=c(0,1),legend.justification=c(0,1)) + 
  labs(fill="Region",title="Sample Filled Regions")
-------------------------------------------------------------------------------------------------------
library(rgdal)
library(ggplot2)
library(RColorBrewer)
library(reshape)
library(gridExtra)

setwd("<directory with all your files...>")

get.centroids = function(x){   # extract centroids from polygon with given ID
  poly = wmap@polygons[[x]]
  ID   = poly@ID
  centroid = as.numeric(poly@labpt)
  return(c(id=ID, c.long=centroid[1], c.lat=centroid[2]))
}

wmap   <- readOGR(dsn=".", layer="ne_110m_admin_0_countries")
wyield <- read.csv(file = "AllWorldCountries_CCShocksGTAP.csv", header=TRUE)
wyield <- transform(wyield, ID_1 = substr(ID_1,3,10))  #strip leading "TR"

# wmap@data and wyield have common, unique field: name
wdata  <- data.frame(id=rownames(wmap@data),name=wmap@data$name)
wdata  <- merge(wdata,wyield, by="name")
labs   <- do.call(rbind,lapply(1:17,get.centroids)) # extract polygon IDs and centroids from shapefile
wdata  <- merge(wdata,labs,by="id")
wdata[c("c.lat","c.long")] <- sapply(wdata[c("c.lat","c.long")],function(x) as.numeric(as.character(x)))

wmap.df <- fortify(wmap)                # data frame for world map
wmap.df <- merge(wmap.df,wdata,by="id") # merge data to fill polygons

palette <- brewer.pal(11,"Spectral")    # ColorBrewewr.org spectral palette, 11 colors
ggmap   <- ggplot(wmap.df, aes(x=long, y=lat, group=group))
ggmap   <- ggmap + geom_polygon(aes(fill=AVG))
ggmap   <- ggmap + geom_path(colour="grey50", size=.1)
ggmap   <- ggmap + geom_text(aes(x=c.long, y=c.lat, label=ID_1),size=3)
ggmap   <- ggmap + scale_fill_gradientn(name="% Change",colours=rev(palette))
ggmap   <- ggmap + theme(plot.title=element_text(face="bold"),legend.position="left")
ggmap   <- ggmap + coord_fixed()
ggmap   <- ggmap + labs(x="",y="",title="Average Yield Impacts across SRES Scenarios (% Change)")
ggmap   <- ggmap + theme(plot.margin=unit(c(0,0.03,0,0.05),units="npc"))
ggmap

box.df       <- wdata[order(as.numeric(wdata$ID_1)),]    # order by ID_1
box.df$label <- with(box.df, paste0(name_long," [",ID_1,"]")) # create labels for boxplot
box.df       <- melt(box.df,id.vars="label",measure.vars=c("A1B","A1BLow","A1F","A1T","A2","B1","B1Low","B2"))
box.df$label <- factor(box.df$label,levels=unique(box.df$label)) # need this so orderin is maintained in ggplot

ggbox   <- ggplot(box.df,aes(x=label, y=value))
ggbox   <- ggbox + geom_boxplot(fill="grey", outlier.colour = "blue", outlier.shape = 16, outlier.size = 4)
ggbox   <- ggbox + stat_summary(fun.y=mean, geom="point", shape=21, size= 4, color= "red")
ggbox   <- ggbox + coord_flip()
ggbox   <- ggbox + labs(x="", y="% Change", title="Distribution of Yield Impacts by GTAP region")
ggbox   <- ggbox + theme(plot.title=element_text(face="bold"), axis.text=element_text(color="black"))
ggbox   <- ggbox + theme(plot.margin=unit(c(0,0.03,0,0.0),units="npc"))
ggbox

grid.newpage()
pushViewport(viewport(layout=grid.layout(2,1,heights=c(0.40,0.60))))
print(ggmap, vp=viewport(layout.pos.row=1,layout.pos.col=1))
print(ggbox, vp=viewport(layout.pos.row=2,layout.pos.col=1)) ggplot coord_fixed() ## re-order the shapefile
wyield <- cbind(id=rownames(wmap@data),wyield) wmap@data wyield wyield name wmp.df id wdata  <- data.frame(id=rownames(wmap@data),name=wmap@data$name)
wdata  <- merge(wdata,wyield, by="name")
...
wmap.df <- fortify(wmap)                # data frame for world map
wmap.df <- merge(wmap.df,wdata,by="id") # merge data to fill polygons
-------------------------------------------------------------------------------------------------------
col plot() f() polygon() g()
-------------------------------------------------------------------------------------------------------
#Data generation
n <- 10000
datam <- matrix(c(rep(1,n), 2*runif(n)-1, 2*runif(n)-1), n) 
# leading 1 column needed for computation
# second column has x coordinates, third column has y coordinates
datam.df<-data.frame(datam)
datam.df$X1<-NULL
f <- c(1.0, 0.5320523, 0.6918301)   # the given target function
f.col <- ifelse(sign(datam %*% f)==1,"darkred", "darkblue")    
f.fun<-sign(datam %*% f)

# perceptron algorithm to find g:
perceptron = function(datam, ylist) {
  w <- c(1,0,0)             # starting vector
  made.mistake = TRUE 
  while (made.mistake) {
  made.mistake=FALSE 
  for (i in 1:n) {
  if (ylist[i] != sign(t(w) %*% datam[i,])) {
    w <- w + ylist[i]*datam[i,]
    made.mistake=TRUE 
  }
 }
}
return(w=w)
}


g <- perceptron(datam, f.fun)
g.fun<-sign(datam %*% g) plot(datam.df$X2, datam.df$X3, col=f.col, pch=".", cex=2) chull() plot(datam.df$X2, datam.df$X3, col=f.col, pch=".", xlim=c(-1,-0.5), ylim=c(-1,-.5), cex=3, main="f function")
datam.df.f<-datam.df[f.fun==1,]
ch.f<-chull(datam.df.f$X2, datam.df.f$X3 )
ch.f <- rbind(x = datam.df.f[ch.f, ], datam.df.f[ch.f[1], ])
polygon(ch.f, lwd=3, col=rgb(0,0,180,alpha=50, maxColorValue=255)) g.col <- ifelse(sign(datam %*% g)==1,"darkred", "darkblue")    
    plot(datam.df$X2, datam.df$X3, col=g.col, pch=".", xlim=c(-1,-0.5), ylim=c(-1,-.5), cex=3, main="g function")
    datam.df.g<-datam.df[g.fun==1,]
    ch.g<-chull(datam.df.g$X2, datam.df.g$X3 )
    ch.g <- rbind(x = datam.df.g[ch.g, ], datam.df.g[ch.g[1], ])
    polygon(ch.g, col=rgb(0,0,180,alpha=50, maxColorValue=255), lty=3, lwd=3) ch.f
lm.f<-lm(c(ch.f$X3[ ch.f$X2> -0.99 & ch.f$X2< -0.65 & ch.f$X3<0 ])~c(ch.f$X2[ ch.f$X2>-0.99 & ch.f$X2< -0.65 & ch.f$X3<0]))
curve(lm.f$coefficients[1]+x*lm.f$coefficients[2], from=-1., to=-0.59, lwd=5, add=T)
lm.g<-lm(c(ch.g$X3[ ch.g$X2> -0.99 & ch.g$X2< -0.65 & ch.g$X3<0 ])~c(ch.g$X2[ ch.g$X2>-0.99 & ch.g$X2< -0.65 & ch.g$X3<0]))
curve(lm.g$coefficients[1]+x*lm.g$coefficients[2], from=-1., to=-0.59, lwd=5, add=T, lty=3)
-------------------------------------------------------------------------------------------------------
# data 
cities <- sort(c(rep('Stockholm', 3), 'Oslo', 'Rome', 'Rome', 'Paris', rep('Bonn',10), 'Paris', 'Paris', 'Stockholm'))

# get frequencies
freq <- as.data.frame(table(cities))
library(plotrix)
freq$Freq <- rescale(freq$Freq, c(1,10)) # c(scale_min, scale_max)

# get cities latitude/longitude - kindly provided by google:
library(ggmap)
lonlat <- geocode(unique(cities)) 
cities <- cbind(freq, lonlat)

# get matches between names {maps} names and EU country names
library(maps)
eu <- c("Austria", "Belgium", "Bulgaria", "Croatia", "Cyprus", "Czech Republic", 
        "Denmark", "Estonia", "Finland", "France", "Germany", "Greece", 
        "Hungary", "Ireland", "Italy", "Latvia", "Lithuania", "Luxembourg", 
        "Malta", "Netherlands", "Poland", "Portugal", "Romania", "Slovakia", 
        "Slovenia", "Spain", "Sweden", "United Kingdom")
warning("No matches in database for ", paste(setdiff(eu, map_data('world')$region), collapse=", ")) 
europe <- map_data('world', region=eu)

# plot
library(ggplot2)
ggplot(europe, aes(x=long, y=lat, group=group)) +
  geom_polygon(fill="white", colour="black") +
  xlim(-20, 40) + ylim(25,75) +
  geom_point(data=cities, inherit.aes=F, aes(x=lon, y=lat, size=Freq), colour="red", alpha=.8) + 
  geom_text(data=cities, inherit.aes=F, aes(x=lon, y=lat, label=cities), vjust=1, colour="red", alpha=.5)
-------------------------------------------------------------------------------------------------------
Area Area Area Area library(rgdal)
library(ggplot2)

setwd("<directory containing all your shapefiles>")
plt.map <- readOGR(dsn=".",layer="plots")
veg.map <- readOGR(dsn=".",layer="veg_in_plots")
# associate LocCode with polygon IDs
plt.data <- cbind(id=rownames(plt.map@data), LocCode=plt.map@data$LocCode)
veg.data <- cbind(id=rownames(veg.map@data), LocCode=veg.map@data$LocCode)
# function to extract area from polygon data
get.area <- function(polygon) {
  row <- data.frame(id=polygon@ID, area=polygon@area, stringsAsFactors=F)
  return(row)
}
# area of each plot polygon
plt.areas <- do.call(rbind,lapply(plt.map@polygons, get.area))
plt.data  <- merge(plt.data,plt.areas, by="id")  # append area column to plt.data
# area of each vegetation polygon
veg.areas <- do.call(rbind,lapply(veg.map@polygons, get.area))
veg.data  <- merge(veg.data,veg.areas, by="id")  # append area column to veg.data
# total area of vegetation polygons by LocCode
veg.smry  <- aggregate(area~LocCode,data=veg.data,sum)
smry      <- merge(plt.data,veg.smry,by="LocCode")
smry$coverage <- with(smry,100*area.y/area.x)    # coverage percentage
# total area for vegetation object with A < 5 msq
veg.lt5   <- aggregate(area~LocCode,data=veg.data[veg.data$area<5,],sum)
smry      <- merge(smry, veg.lt5, by="LocCode") 
# fraction of covered area coming from veg. obj. with A < 5 msq
smry$pct.lt5 <- with(smry, 100*area/area.y) # head(smry)
#   LocCode id   area.x   area.y coverage      area  pct.lt5
# 1       1  3 1165.916 259.2306 22.23408  60.98971 23.52720
# 2      10 11 1242.770 366.3222 29.47626  88.21827 24.08216
# 3      11 12 1181.366 213.2105 18.04779 129.21612 60.60496
# 4      12 13 1265.352 577.6037 45.64767 236.83946 41.00380
# 5      13 14 1230.662 226.2686 18.38593  48.09509 21.25575
# 6      14 15 1274.538 252.0577 19.77640  46.94874 18.62619 readOGR(...) rgdal map map <- readOGR(dsn=".",layer="myShapeFile") map@polygon map@data get.area(...) lapply(...) rbind(...) plt.areas <- do.call(rbind,lapply(plt.map@polygons, get.area))
veg.areas <- do.call(rbind,lapply(veg.map@polygons, get.area)) LocCode plt.data <- cbind(id=rownames(plt.map@data), LocCode=plt.map@data$LocCode)
veg.data <- cbind(id=rownames(veg.map@data), LocCode=veg.map@data$LocCode) plt.data  <- merge(plt.data,plt.areas, by="id")  # append area column to plt.data
veg.data  <- merge(veg.data,veg.areas, by="id")  # append area column to veg.data veg.smry  <- aggregate(area~LocCode,data=veg.data,sum) smry      <- merge(plt.data,veg.smry,by="LocCode") smry area.x area.y +proj=utm +zone=13 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0 smry veg.lt5   <- aggregate(area~LocCode,data=veg.data[veg.data$area<5,],sum)
smry      <- merge(smry, veg.lt5, by="LocCode") cols   <- c("id","LocCode")
plt.df <- fortify(plt.map)
plt.df <- merge(plt.df,plt.data[cols],by="id")
veg.df <- fortify(veg.map)
veg.df <- merge(veg.df,veg.data[cols],by="id")
ggp <- ggplot(plt.df, aes(x=long, y=lat, group=group))
ggp <- ggp + geom_path()
ggp <- ggp + geom_polygon(data=veg.df, fill="green")
ggp <- ggp + facet_wrap(~LocCode,scales="free")
ggp <- ggp + theme(axis.text=element_blank())
ggp <- ggp + labs(x="",y="")
ggp <- ggp + coord_fixed()
ggp
-------------------------------------------------------------------------------------------------------
wp<-ggplot()+
   geom_polygon(data=word.df,aes(long,lat,group=group))+
   geom_hex(data=cleanTwittes,aes(lon,lat),bins = 55,alpha=8/10)+
   theme_bw()+
   labs(title = paste(nbTwittes,"twittes entre",minT,"et",maxT, "sur 'terroir'"))
   coord_equal()
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(maps)
df$div <- paste("DIV#", df$div)
ggplot(data=df, aes(x=lon, y=lat)) + 
  geom_polygon(
    data=map_data("state"), 
    aes(x=long, y=lat, group = group),
    colour="white", fill="grey10"
  ) + 
  geom_point(aes(color=score), size=3) +
  facet_wrap(~ div) +
  coord_cartesian(xlim=c(-125, -85), ylim=c(30, 42)) +
  scale_colour_gradient2(
    low="red", mid="yellow", high="green", midpoint=mean(df$score)
  ) data.frame
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(rgdal)           # for readOGR(...) and spTransform(...)
library(RColorBrewer)    # for brewer.pal(...)

setwd("<directory with shapefile>")
map <- readOGR(dsn=".",layer="Ortsteile")
map <- spTransform(map,CRS=CRS("+init=epsg:4839"))
map.data <- data.frame(id=rownames(map@data), map@data)
map.df   <- fortify(map)
map.df   <- merge(map.df,map.data,by="id")
ggplot(map.df, aes(x=long, y=lat, group=group))+
  geom_polygon(aes(fill=Einwohnerd))+
  geom_path(colour="grey")+
  scale_fill_gradientn(colours=rev(brewer.pal(10,"Spectral")))+
  theme(axis.text=element_blank())+
  labs(title="Berlin Ortsteile", x="", y="")+
  coord_fixed() ggplot readOGR(...) SpatialDataFrame polygons data map@polygons map@data map@data map.data fortify(...) ggplot map.df id id map.data map.data map.df id ggplot:       set the default dataset to map.df; identify x- and y-axis columns
geom_polygon: identify column for fill (color of polygon)
geom_path:    polygon boundaries
theme:        turn off axis text
labs:         title, turn off x- and y-axis labels
coord_fixed:  ensures that the map is not distorted scale_fill_gradientn(...) colours= library(colorRamps) scale_fill_gradientn(...) scale_fill_gradientn(colours=matlab.like(10))+
-------------------------------------------------------------------------------------------------------
ggplot ggplot ggplot grid library(ggplot2)
library(maps)
df <- df[complete.cases(df),]
df$dist.london <- sqrt((df$Lat - 51.5) ^ 2 + (df$Lon - 0.1275) ^ 2)
df$rg <- cut(df$dist.london, c(0, 10, 35, 65, 100, 150, 300), include.lowest=T)
levels(df$rg) <- c("UK", "RoE", "Israel", "Midwest", "US West", "New Zealand")

RoE <- c("France", "Germany", "Denmark", "Spain", "Italy", "Belgium", "Netherlands")
West <- tolower(c("Washington", "Oregon", "California", "Nevada", "Idaho"))
Lakes <- tolower(c("Michigan", "Illinois", "Wisconsin", "Indiana", "Ohio", "New York"))
mdat <- rbind(
  map_data('world', c("UK", RoE, "Israel", "New Zealand")),
  map_data("state", c(West, Lakes))
)
reg.map <- rbind(
  cbind(RoE, "RoE"),
  cbind(West, "US West"),
  cbind(Lakes, "Midwest"),
  cbind("UK", "UK"),
  cbind("Israel", "Israel"),
  cbind("New Zealand", "New Zealand")
)
mdat$rg <- factor(reg.map[match(mdat$region, reg.map[, 1]), 2], levels=levels(df$rg))
mdat <- subset(mdat, !(rg == "RoE" & (lat < 35 | long < -20)))
mdat <- subset(mdat, !(rg == "UK" & (lat < 50 | long < -20)))
mdat <- subset(mdat, !(rg == "New Zealand" & (lat > -20 | long < 100)))

ggplot(data=df) + 
  geom_polygon(dat=mdat, aes(long, lat, group=group), fill="grey50", color="grey10") +
  geom_point(aes(x = Lon, y = Lat, size=`area`), col="red") +
  facet_wrap(~ rg, scales="free")
-------------------------------------------------------------------------------------------------------
alpha= aes() scale_alpha_continuous() ggplot() + 
  geom_polygon(data=all_states, aes(x=long, y=lat, group=group), 
               color="white", fill="grey80") + 
  stat_density2d(data=df, aes(x=long, y=lat, fill=..level.., alpha=..level..), 
                 size=2, bins=5, geom='polygon') +
  geom_point(data=df, aes(x=long, y=lat), 
             color="coral1", position=position_jitter(w=0.4,h=0.4), alpha=0.8) + 
  theme_bw()+
  scale_alpha_continuous(range=c(0.1,0.5))
-------------------------------------------------------------------------------------------------------
