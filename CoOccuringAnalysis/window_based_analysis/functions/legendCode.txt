
library(maptools)
substitute your shapefiles here
state.map <- readShapeSpatial("BRASIL.shp")
counties.map <- readShapeSpatial("55mu2500gsd.shp")
## this is the variable we will be plotting
counties.map@data$noise <- rnorm(nrow(counties.map@data)) plot.heat <- function(counties.map,state.map,z,title=NULL,breaks=NULL,reverse=FALSE,cex.legend=1,bw=.2,col.vec=NULL,plot.legend=TRUE) {
  ##Break down the value variable
  if (is.null(breaks)) {
    breaks=
      seq(
          floor(min(counties.map@data[,z],na.rm=TRUE)*10)/10
          ,
          ceiling(max(counties.map@data[,z],na.rm=TRUE)*10)/10
          ,.1)
  }
  counties.map@data$zCat <- cut(counties.map@data[,z],breaks,include.lowest=TRUE)
  cutpoints <- levels(counties.map@data$zCat)
  if (is.null(col.vec)) col.vec <- heat.colors(length(levels(counties.map@data$zCat)))
  if (reverse) {
    cutpointsColors <- rev(col.vec)
  } else {
    cutpointsColors <- col.vec
  }
  levels(counties.map@data$zCat) <- cutpointsColors
  plot(counties.map,border=gray(.8), lwd=bw,axes = FALSE, las = 1,col=as.character(counties.map@data$zCat))
  if (!is.null(state.map)) {
    plot(state.map,add=TRUE,lwd=1)
  }
  ##with(counties.map.c,text(x,y,name,cex=0.75))
  if (plot.legend) legend("bottomleft", cutpoints, fill = cutpointsColors,bty="n",title=title,cex=cex.legend)
  ##title("Cartogram")
} plot.heat(counties.map,state.map,z="noise",breaks=c(-Inf,-2,-1,0,1,2,Inf))
-------------------------------------------------------------------------------------------------------
plot.multi.dens <- function(s)
{
junk.x = NULL
junk.y = NULL
for(i in 1:length(s))
{
junk.x = c(junk.x, density(s[[i]])$x)
junk.y = c(junk.y, density(s[[i]])$y)
}
xr <- range(junk.x)
yr <- range(junk.y)
plot(density(s[[1]]), xlim = xr, ylim = yr, main = "")
for(i in 1:length(s))
{
lines(density(s[[i]]), xlim = xr, ylim = yr, col = i)
}
}
dnow <- read.table("http://dpaste.com/88561/plain/")
library(sqldf)
x <- unlist(sqldf("select V1 from dnow where V2==0"))
y <- unlist(sqldf("select V1 from dnow where V2==1"))
z <- unlist(sqldf("select V1 from dnow where V2==2"))
plot.multi.dens(list(x,y,z))
library(Hmisc)
le <- largest.empty(x,y,.1,.1)
legend(le,legend=c("x","y","z"), col=(1:3), lwd=2, lty = 1)
-------------------------------------------------------------------------------------------------------
# Create the data (means) matrix
# Using the matrix accommodates two or more factors for each class

data.m <- matrix(c(75,34,19, 39,90,41), nrow = 2, ncol=3, byrow=TRUE,
               dimnames = list(c("Factor 1", "Factor 2"),
                                c("Class A", "Class B", "Class C")))

# Create the standard error matrix

error.m <- matrix(c(12,10,7, 4,7,3), nrow = 2, ncol = 3, byrow=TRUE)

# Join the data and s.e. matrices into a data frame

data.fr <- data.frame(data.m, error.m) 

# load library {gplots}

library(gplots)

# Plot the bar graph, with standard errors

with(data.fr,
     barplot2(data.m, beside=TRUE, axes=T, las=1, ylim = c(0,120),  
                main=" ", sub=" ", col=c("gray20",0),
                    xlab="Class", ylab="Total amount (Mean +/- s.e.)",
                plot.ci=TRUE, ci.u=data.m+error.m, ci.l=data.m-error.m, ci.lty=1))

# Now, give it a legend:

legend("topright", c("Factor 1", "Factor 2"), fill=c("gray20",0),box.lty=0)
-------------------------------------------------------------------------------------------------------
R test <- read.table("/tmp/test.txt", header=TRUE)
png(filename="/tmp/test.png", height=750, width=1000, 
    bg="white", res=300)
par(mar=c(2.5,2.5,0.75,0.75), 
    family="Gill Sans", font=1, # font 2 would be bold
    cex=0.75, cex.lab=0.75, cex.axis=0.75) 
mymax <- max(test$Region1, test$Region2)*1.25

plot(test$Region1, type="b", col="#304E67", 
     ylim=c(0, mymax), lwd=3,
     bty="l", axes=FALSE, ann=FALSE, cex=1.0, tck=1)

axis(1, lwd.ticks=0, at=1:length(test$Year), lab=test$Year)
axis(2, lwd=0, las=1, at=c(0,25,50,75,100), yaxp=c(0,100,4))
# grid(nx = NA, ny = 5, col = "lightgray") # wrong, see axTicks
for(y in c(25, 50, 75, 100)) {
  lines(rep(y, length(test$Region1)), type="l", col="lightgray", lwd=1)
}

lines(test$Region1, type="b", col="#304E67", lwd=3)
lines(test$Region2, type="b", col="#974449", lwd=3)

# title(xlab="Year", col.lab=rgb(0,0.5,0))
# title(ylab="Output", col.lab=rgb(0,0.5,0))
legend(1, mymax+8, c("Region 1","Region 2"), cex=0.75, 
       col=c("#304E67" ,"#974449"), 
       pch=1:1, # circles
       lty=1:1, # solid 
       lwd=1.5, # line width
       bty="n") # no box around

dev.off() Year Region1 Region2
2007 17 55
2008 26 43
2009 53 70
2010 96 58
-------------------------------------------------------------------------------------------------------
data <- read.table("http://dpaste.com/173536/plain/", header = FALSE)

sample1 <- unlist(apply(as.matrix(data),1,function(x) rep(x[1],x[2])))
sample2 <- unlist(apply(as.matrix(data),1,function(x) rep(x[1],x[3])))

plot(ecdf(sample1), verticals=TRUE, do.p=FALSE,
main="ECDF plot for both samples", xlab="Scores", 
ylab="Cumulative Percent",lty="dashed")

lines(ecdf(sample2), verticals=TRUE, do.p=FALSE,
col.h="red", col.v="red",lty="dotted")

legend(100,.8,c("Sample 1","Sample 2"),
col=c("black","red"),lty=c("dashed","dotted"))
-------------------------------------------------------------------------------------------------------
df data <- tapply(df$total_dist, list(df$groupname,df$bin), sum)

barplot(data,beside=T,col=c("#ee7700","#3333ff")
,main="European Parliament Elections",xlab="Group",ylab="Seats")

legend(locator(1),rownames(data),fill=c("#ee7700","#3333ff")) library(ggplot2)
qplot(factor(bin),data=df,geom="bar",fill=groupname,weight=total_dist,position="dodge",
main = "European Parliament Elections", xlab="Group",ylab="Seats")
-------------------------------------------------------------------------------------------------------
legend() text() legend(3.5, 150, legend = c(paste("Mean =", round(MyMean, 1)),
                            paste("Median =",round(MyMedian, 1)),
                            paste("Std.Dev =", round(MySd, 1))), 
                  bty = "n") "topleft"
-------------------------------------------------------------------------------------------------------
text(1.5, 150, paste("Mean =", round(MyMean, 1), "\nMedian =", 
         round(MyMedian, 1), "\nStd.Dev =", round(MySd, 1)), pos = 4) text(5.0, 150, paste("Mean = ", round(MyMean, 1), "\nMedian = ", 
        round(MyMedian, 1), "\nStd.Dev = ", round(MySd, 1), sep = ''), pos = 2)
-------------------------------------------------------------------------------------------------------
## generate some random data
carrotLengths <- rnorm(1000,15,5)
cucumberLengths <- rnorm(200,20,7)
## calculate the histograms - don't plot yet
histCarrot <- hist(carrotLengths,plot = FALSE)
histCucumber <- hist(cucumberLengths,plot = FALSE)
## calculate the range of the graph
xlim <- range(histCucumber$breaks,histCarrot$breaks)
ylim <- range(0,histCucumber$intensities,
              histCarrot$intensities)
## plot the first graph
plot(histCarrot,xlim = xlim, ylim = ylim,
     col = rgb(1,0,0,0.4),xlab = 'Lengths',
     freq = FALSE, ## relative, not absolute frequency
     main = 'Distribution of carrots and cucumbers')
## plot the second graph on top of this
opar <- par(new = FALSE)
plot(histCucumber,xlim = xlim, ylim = ylim,
     xaxt = 'n', yaxt = 'n', ## don't add axes
     col = rgb(0,0,1,0.4), add = TRUE,
     freq = FALSE) ## relative, not absolute frequency
## add a legend in the corner
legend('topleft',c('Carrots','Cucumbers'),
       fill = rgb(1:0,0,0:1,0.4), bty = 'n',
       border = NA)
par(opar) hist
-------------------------------------------------------------------------------------------------------
carrots <- rnorm(100000,5,2)
cukes <- rnorm(50000,7,2.5) ## calculate the density - don't plot yet
densCarrot <- density(carrots)
densCuke <- density(cukes)
## calculate the range of the graph
xlim <- range(densCuke$x,densCarrot$x)
ylim <- range(0,densCuke$y, densCarrot$y)
#pick the colours
carrotCol <- rgb(1,0,0,0.2)
cukeCol <- rgb(0,0,1,0.2)
## plot the carrots and set up most of the plot parameters
plot(densCarrot, xlim = xlim, ylim = ylim, xlab = 'Lengths',
     main = 'Distribution of carrots and cucumbers', 
     panel.first = grid())
#put our density plots in
polygon(densCarrot, density = -1, col = carrotCol)
polygon(densCuke, density = -1, col = cukeCol)
## add a legend in the corner
legend('topleft',c('Carrots','Cucumbers'),
       fill = c(carrotCol, cukeCol), bty = 'n',
       border = NA)
-------------------------------------------------------------------------------------------------------
xts zoo zoo > x <- zoo(rnorm(5),sprintf("FY%02d",1:5))
> y <- zoo(rnorm(5),sprintf("FY%02d",1:5))
> merge(x,y)
               x           y
FY01  0.32707886 -1.81414982
FY02 -0.95177700  0.37772862
FY03 -0.03052571 -1.13047719
FY04  1.19139973  0.96962871
FY05 -0.76484142 -0.08187144 quantmod::chartSeries xts library(quantmod)
symbols=c("DGS1","DGS2","DGS3","DGS5","DGS7","DGS10","DGS20")
getSymbols(symbols,src="FRED")
all <- na.omit(merge(DGS1,DGS2,DGS3,DGS5,DGS7,DGS10,DGS20))

years <- c(1,2,3,5,7,10,20)
# use xts indexing, since getSymbols returns xts
histDate <- "2007-09-01/2007-09-10"
# create zoo objects for non-time-based indexing
hist <- zoo(t(all[histDate]), order.by=years)
curr <- zoo(t(last(all)), order.by=years)

currHist <- merge(curr,hist)
plotCol <- rainbow(NCOL(currHist))
plot(currHist, screens=1, col=plotCol, pch=20, type="o", ann=FALSE)
title(main="Term Structure of Interest Rates",col.main="red", font.main=4)
title(xlab="Years to Maturity",ylab="Interest Rate",col.lab=rgb(0,0.5,0))
legend(15,1.5,colnames(currHist),cex=0.8,col=plotCol,pch=20)
-------------------------------------------------------------------------------------------------------
lower <- 0
upper <- 20
t <- seq(lower,upper,0.01)
fA <- dexp(t, rate = 0.4)
fB <- dgamma(t,shape = 8, rate = 2)
## C has the same distribution as (A + B)/2
dC <- function(x, lower, upper, exp.rate, gamma.rate, gamma.shape){
  integrand <- function(Y, X, exp.rate, gamma.rate, gamma.shape){
    dexp(Y, rate = exp.rate)*dgamma(2*X-Y, rate = gamma.rate, shape = gamma.shape)*2
  }
  out <- NULL
  for(ix in seq_along(x)){
    out[ix] <-
      integrate(integrand, lower = lower, upper = upper,
                X = x[ix], exp.rate = exp.rate,
                gamma.rate = gamma.rate, gamma.shape = gamma.shape)$value
  }
  return(out)
}
fC <- dC(t, lower=lower, upper=upper, exp.rate=0.4, gamma.rate=2, gamma.shape=8)
## plot the resulting distribution
plot(t,fA,
     ylim = range(fA,fB,na.rm=TRUE,finite = TRUE),
     xlab = 'x',ylab = 'f(x)',type = 'l')
lines(t,fB,lty = 2)
lines(t,fC,lty = 3)
legend('topright', c('A ~ exp(0.4)','B ~ gamma(8,2)', 'C ~ (A+B)/2'),lty = 1:3)
-------------------------------------------------------------------------------------------------------
legend() R> DF <- data.frame(VAR1=rnorm(100), VAR2=rnorm(100))
R> with(DF, plot(VAR1, VAR2))
R> abline(fit <- lm(VAR2 ~ VAR1, data=DF), col='red')
R> legend("topright", bty="n", legend=paste("R2 is", 
+         format(summary(fit)$adj.r.squared, digits=4))) bty="n" format() text() main= sub= plot()
-------------------------------------------------------------------------------------------------------
build_legend <- function(name, mapping, layers, default_mapping, theme) {
  legend_data <- plyr::llply(layers, build_legend_data, mapping, default_mapping)

  # determine if the elements are aligned horizontally or vertically
  horiz<-(!is.null(theme$legend.align) && theme$legend.align=="horizontal")

  # Calculate sizes for keys - mainly for v. large points and lines
  size_mat <- do.call("cbind", plyr::llply(legend_data, "[[", "size"))
  if (is.null(size_mat)) {
    key_sizes <- rep(0, nrow(mapping))
  } else {
    key_sizes <- apply(size_mat, 1, max)
  }

  title <- theme_render(
    theme, "legend.title",
    name, x = 0, y = 0.5
  )

                                        # Compute heights and widths of legend table
  nkeys <- nrow(mapping)
  hgap <- vgap <- unit(0.3, "lines")

  numeric_labels <- all(sapply(mapping$.label, is.language)) || suppressWarnings(all(!is.na(sapply(mapping$.label, "as.numeric"))))
  hpos <- numeric_labels * 1

  labels <- lapply(mapping$.label, function(label) {
    theme_render(theme, "legend.text", label, hjust = hpos, x = hpos, y = 0.5)
  })

  # align horizontally
  if(!horiz){
    label_width <- do.call("max", lapply(labels, grobWidth))
    label_width <- convertWidth(label_width, "cm")
    label_heights <- do.call("unit.c", lapply(labels, grobHeight))
    label_heights <- convertHeight(label_heights, "cm")

    width <- max(unlist(plyr::llply(legend_data, "[[", "size")), 0)
    key_width <- max(theme$legend.key.size, unit(width, "mm"))

    widths <- unit.c(
                     hgap, key_width,
                     hgap, label_width,
                     max(
                         unit(1, "grobwidth", title) - key_width - label_width,
                         hgap
                         )
                     )
    widths <- convertWidth(widths, "cm")

    heights <- unit.c(
                      vgap, 
                      unit(1, "grobheight", title),
                      vgap, 
                      unit.pmax(
                                theme$legend.key.size, 
                                label_heights, 
                                unit(key_sizes, "mm")
                                ),
                      vgap
                      )  
    heights <- convertHeight(heights, "cm")

  }else{
    label_width <- do.call("unit.c", lapply(labels, grobWidth))
    label_width <- convertWidth(label_width, "cm")
    label_heights <- do.call("max", lapply(labels, grobHeight))
    label_heights <- convertHeight(label_heights, "cm")

    height <- max(unlist(plyr::llply(legend_data, "[[", "size")), 0)
    key_heights <- max(theme$legend.key.size, unit(height, "mm"))

    key_width <- unit.pmax(theme$legend.key.size, unit(key_sizes, "mm"))
    # width of (key gap label gap) x nkeys
    kglg_width<-do.call("unit.c",lapply(1:length(key_width), function(i)unit.c(key_width[i], hgap, label_width[i], hgap)))
    widths <- unit.c(
                      hgap,
                      kglg_width,
                      max(
                          unit(0,"lines"),
                          unit.c(unit(1, "grobwidth", title) - (sum(kglg_width) - hgap))
                          )
                      )
    widths <- convertWidth(widths, "cm")

    heights <- unit.c(
                       vgap, 
                       unit(1, "grobheight", title),
                       vgap, 
                       max(
                           theme$legend.key.size,
                           label_heights, 
                           key_heights
                           ),
                       vgap
                       )  
  heights <- convertHeight(heights, "cm")

  }

  # Layout the legend table
  legend.layout <- grid.layout(
    length(heights), length(widths), 
    widths = widths, heights = heights, 
    just = c("left", "centre")
  )

  fg <- ggname("legend", frameGrob(layout = legend.layout))
  fg <- placeGrob(fg, theme_render(theme, "legend.background"))

  fg <- placeGrob(fg, title, col = 2:(length(widths)-1), row = 2)
  for (i in 1:nkeys) {

    if(!horiz){
      fg <- placeGrob(fg, theme_render(theme, "legend.key"), col = 2, row = i+3)
    }else{
      fg <- placeGrob(fg, theme_render(theme, "legend.key"), col = 1+(i*4)-3, row = 4)
    }

    for(j in seq_along(layers)) {
      if (!is.null(legend_data[[j]])) {
        legend_geom <- Geom$find(layers[[j]]$geom$guide_geom())
        key <- legend_geom$draw_legend(legend_data[[j]][i, ],
           c(layers[[j]]$geom_params, layers[[j]]$stat_params))
        if(!horiz){
          fg <- placeGrob(fg, ggname("key", key), col = 2, row = i+3)
        }else{
          fg <- placeGrob(fg, ggname("key", key), col = 1+(i*4)-3, row = 4)
        }
      }
    }
    label <- theme_render(
      theme, "legend.text", 
      mapping$.label[[i]], hjust = hpos,
      x = hpos, y = 0.5
    )
    if(!horiz){
      fg <- placeGrob(fg, label, col = 4, row = i+3)
    }else{
      fg <- placeGrob(fg, label, col = 1+(i*4)-1, row = 4)
    }
  }
  fg
}

assignInNamespace("build_legend", build_legend, "ggplot2")

# test and usage
# specify by opts(legend.align="horizontal")
p1<-qplot(mpg, wt, data=mtcars, colour=cyl)+opts(legend.align="horizontal",legend.position="bottom")
p2<-qplot(mpg, wt, data=mtcars, colour=cyl)
-------------------------------------------------------------------------------------------------------
layout() legend()
-------------------------------------------------------------------------------------------------------
layout(matrix(c(1,2), nrow = 1), widths = c(0.7, 0.3))
par(mar = c(5, 4, 4, 2) + 0.1)
plot(1:3, rnorm(3), pch = 1, lty = 1, type = "o", ylim=c(-2,2))
lines(1:3, rnorm(3), pch = 2, lty = 2, type="o")
par(mar = c(5, 0, 4, 2) + 0.1)
plot(1:3, rnorm(3), pch = 1, lty = 1, ylim=c(-2,2), type = "n", axes = FALSE, ann = FALSE)
legend(1, 1, c("group A", "group B"), pch = c(1,2), lty = c(1,2))
-------------------------------------------------------------------------------------------------------
par(xpd=TRUE) bty='L' par(xpd=TRUE) set.seed(1) # just to get the same random numbers
 par(xpd=FALSE) # this is usually the default

 plot(1:3, rnorm(3), pch = 1, lty = 1, type = "o", ylim=c(-2,2), bty='L')
 # this legend gets clipped:
 legend(2.8,0,c("group A", "group B"), pch = c(1,2), lty = c(1,2))

 # so turn off clipping:
 par(xpd=TRUE)
 legend(2.8,-1,c("group A", "group B"), pch = c(1,2), lty = c(1,2))
-------------------------------------------------------------------------------------------------------
... plot legend legend foo.plot <- function(x,y,...) {
    plot(x,y,...)
    legend("bottomleft", "bar", pch = 1, ...)
} > foo.plot(1, 1, xjust = 0.5)
Warning messages:
1: In plot.window(...) : "xjust" is not a graphical parameter
2: In plot.xy(xy, type, ...) : "xjust" is not a graphical parameter
3: In axis(side = side, at = at, labels = labels, ...) :
  "xjust" is not a graphical parameter
4: In axis(side = side, at = at, labels = labels, ...) :
  "xjust" is not a graphical parameter
5: In box(...) : "xjust" is not a graphical parameter
6: In title(...) : "xjust" is not a graphical parameter plot.default axis box localPlot() plot() bar.plot <- function(x, y, pch = 1, ...) {
    localPlot <- function(..., legend, fill, border, angle, density,
                          xjust, yjust, x.intersp, y.intersp,
                          text.width, text.col, merge, trace, plot = TRUE, ncol,
                          horiz, title, inset, title.col, box.lwd,
                          box.lty, box.col, pt.bg, pt.cex, pt.lwd) plot(...)
    localPlot(x, y, pch = pch, ...)
    legend(x = "bottomleft", legend = "bar", pch = pch, ...)
} 'plot' TRUE bar.plot(1, 1, xjust = 0.5, title = "foobar", pch = 3) bty bty 'pch' bar.plot() 'pch' lme() la.args <- function(x = "bottomleft", legend = "bar", pch = 1, ...)
    c(list(x = x, legend = legend, pch = pch), list(...))

foo.plot <- function(x,y, legend.args = la.args(), ...) {
    plot(x, y, ...)
    do.call(legend, legend.args)
} foo.plot(1,1, xaxt = "n", legend.args=la.args(bg = "yellow", title = "legend")) la.args() la.args()
-------------------------------------------------------------------------------------------------------
splinefun method=monoH.FC ?spline ## An example of  monotone  interpolation
n <- 20
set.seed(11)
x. <- sort(runif(n)) ; y. <- cumsum(abs(rnorm(n)))
plot(x.,y.)
curve(splinefun(x.,y.)(x),                add=TRUE, col=2, n=1001)
curve(splinefun(x.,y., method="mono")(x), add=TRUE, col=3, n=1001)
legend("topleft", paste("splinefun( \"", c("fmm", "monoH.CS"), "\" )", sep=''),
         col=2:3, lty=1)
-------------------------------------------------------------------------------------------------------
color.legend(0,13,6.5,14,legend=c(-1,-0.5,0,0.5,1),
   rect.col=color.scale(cbind(cors,c(-1,rep(1,11))),c(0,1),0,c(1,0))[,1:12], 
   align="rb")
-------------------------------------------------------------------------------------------------------
xyplot xyplot.zoo plot.zoo xblocks dts <- as.Date("20050101", '%Y%m%d') + seq(0,1000,15)
A <- data.frame( Dates = dts, Gas = 4000 + cumsum(abs( rnorm(length(dts), 100, 30))))

A <- transform( A,               
               Year = format(Dates, '%Y'),
               DayOfYear = as.numeric( format(Dates, '%j')),
               GasDiff = c(diff( Gas ),NA)) library(lattice) # xyplot
library(latticeExtra) # layer_, panel.xblocks
library(gridExtra) # grid.arrange
library(RColorBrewer) # brewer.pal

png("png1.png")
p1 <- xyplot(GasDiff ~ Dates, group = Year, A, type = "l",
    par.settings = list(superpose.line = list(col = 1:nlevels(A$Year))),
    auto.key = list(lines = TRUE, points = FALSE))

p2 <- xyplot(GasDiff ~ DayOfYear | Year, A, type = "l", layout = c(1, 3))

p3 <- xyplot(GasDiff ~ DayOfYear, A, group = Year, type = "l",
    auto.key = list(lines = TRUE, points = FALSE))

# and here is another style:

myPalette <- brewer.pal(nlevels(A$Year), "Set3")
p4 <- xyplot(GasDiff ~ Dates, A, type = "l", col = 1) + 
    layer_(panel.xblocks(A$Dates, myPalette[A$Year]))

grid.arrange(nrow = 2, p1, p2, p3, p4)
dev.off() png("png2.png")
library(zoo)
library(lattice)
library(latticeExtra) # layer_, panel.xblocks
library(gridExtra) # grid.arrange
library(RColorBrewer) # brewer.pal

z <- with(A, zoo(GasDiff, Dates))
year <- format(time(z), "%Y")

# split years into separate columns and plot
P1 <- xyplot(do.call("merge", split(z, year)), screen = 1, col = 1:3)

# split years into separate columns and use day.of.year as time
day.of.year <- function(x) as.numeric(format(x, "%j"))
zz <- read.zoo(A[c(1, 5, 3)], FUN = day.of.year, split = 3)
colnames(zz) <- unique(year)
P2 <- xyplot(na.approx(zz, na.rm = FALSE))

P3 <- xyplot(na.approx(zz, na.rm = FALSE), screen = 1, col = 1:3, auto.key = TRUE)

pal <- brewer.pal(nlevels(factor(year)), "Set3")
P4 <- xyplot(z, screen = 1) + layer_(panel.xblocks(time(z), pal[factor(year)]))

grid.arrange(nrow = 2, P1, P2, P3, P4)
dev.off() z zz pal library(zoo)
library(RColorBrewer) # brewer.pal

png("png3a.png")
plot(do.call("merge", split(z, year)), screen = 1, col = 1:3)
dev.off()
png("png3b.png")
plot(na.approx(zz, na.rm = FALSE))
dev.off()
png("png3c.png")
plot(na.approx(zz, na.rm = FALSE), screen = 1, col = 1:3)
legend("topleft", colnames(zz), lty = 1, col = 1:3, bty = "n")
dev.off()
png("png3d.png")
plot(z, type = "n")
xblocks(time(z), pal[factor(year)])
lines(z)
dev.off()
-------------------------------------------------------------------------------------------------------
P     <- 3                             # number of groups for ANOVA
fVals <- seq(0, 1.2, length.out=100)   # effect sizes f for ANOVA
dVals <- seq(0, 3, length.out=100)     # effect sizes d for t-Test
nn    <- seq(10, 25, by=5)             # group sizes
alpha <- 0.05                          # test for level alpha

# function to calculate one-way ANOVA power for given group size
getFPow <- function(n) {
    critF <- qf(1-alpha, P-1, P*n - P) # critical F-value

    # probabilities of exceeding this F-value given the effect sizes f
    # P*n*fVals^2 is the non-centrality parameter
    1-pf(critF, P-1, P*n - P, P*n * fVals^2)
}

# function to calculate one-sample t-Test power for given group size
getTPow <- function(n) {
    critT <- qt(1-alpha, n-1)           # critical t-value

    # probabilities of exceeding this t-value given the effect sizes d
    # sqrt(n)*d is the non-centrality parameter
    1-pt(critT, n-1, sqrt(n)*dVals)
}

powsF <- sapply(nn, getFPow)      # ANOVA power  for for all group sizes
powsT <- sapply(nn, getTPow)      # t-Test power for for all group sizes

dev.new(width=10, height=5)
par(mfrow=c(1, 2))
matplot(fVals, powsF, type="l", lty=1, lwd=2, xlab="effect size f",
        ylab="Power", main="Power one-way ANOVA", xaxs="i",
        xlim=c(-0.05, 1.1), col=c("blue", "red", "darkgreen", "green"))
legend(x="bottomright", legend=paste("Nj =", c(10, 15, 20, 25)), lwd=2,
       col=c("blue", "red", "darkgreen", "green"))
matplot(dVals, powsT, type="l", lty=1, lwd=2, xlab="effect size d",
        ylab="Power", main="Power one-sample t-Test", xaxs="i",
        xlim=c(-0.05, 1.1), col=c("blue", "red", "darkgreen", "green"))
legend(x="bottomright", legend=paste("N =", c(10, 15, 20, 25)), lwd=2,
       col=c("blue", "red", "darkgreen", "green"))
-------------------------------------------------------------------------------------------------------
stackpoly plotrix library(plotrix)
#create proportions table
pdat <- prop.table(xtabs(Prop2~Hour+Category,Dat),margin=1)
#draw chart
stackpoly(pdat,stack=T,xaxlab=rownames(pdat))
#add legend
legend(1,colnames(pdat),bg="#ffffff55",fill=rainbow(dim(pdat)[2]))
-------------------------------------------------------------------------------------------------------
library(igraph)
rm(list=ls())
req.data <- as.data.frame(Titanic)
lookup <- c("M","F","C","A","N","Y")
names(lookup) <- c("Male","Female","Child","Adult","Yes","No")

req.data$board <- "board"
req.data$Class.m <- paste(req.data$board,req.data$Class,sep="_")
req.data$Sex.m <- paste(req.data$board,req.data$Class,req.data$Sex,
                        sep="_")
req.data$Age.m <- paste(req.data$board,req.data$Class,req.data$Sex,
                        req.data$Age,sep="_")
req.data$Survived.m <- paste(req.data$board,req.data$Class,req.data$Sex,
                           req.data$Age,req.data$Survived,sep="_")

tmp <- data.frame(from=
                  do.call("c",lapply(req.data[,c("board",
                                                 "Class.m",
                                                 "Sex.m",
                                                 "Age.m")],as.character)),
                  to=do.call("c",lapply(req.data[,c("Class.m",
                    "Sex.m",
                    "Age.m",
                    "Survived.m")],as.character)),
                  stringsAsFactors=FALSE)

tmp  <- tmp [!duplicated(tmp ),];rownames(tmp) <- NULL
tmp$num <- unlist(lapply(strsplit(tmp$to,"_"),
                         FUN=function(x){
                           check1 <- req.data$Class==x[2]
                           check2 <- req.data$Sex == x[3]
                           check3 <- req.data$Age == x[4]
                           check4 <- req.data$Survived == x[5]
                           sum(req.data$Freq[ifelse(is.na(check1),TRUE,check1)   &
                                             ifelse(is.na(check2),TRUE,check2)   &
                                             ifelse(is.na(check3),TRUE,check3)   &
                                             ifelse(is.na(check4),TRUE,check4)])}))


g <- graph.data.frame(tmp, directed=TRUE)
V(g)$label <- unlist(lapply(strsplit(V(g)$name,"_"),
                            FUN=function(y){ifelse(y[length(y)] %in% names(lookup),
                              lookup[y[length(y)]],y[length(y)])}))
E(g)$label <- tmp$num
plot(g,layout=layout.reingold.tilford,ylim=c(1,-1),edge.arrow.size=0.5,vertex.size=7)
legend("topleft", paste(lookup ,names(lookup),sep=" : "),ncol=2,bty="n",cex=0.7) 
### To find the case for crew members 
tmp1  <- tmp [grepl("Crew",tmp$from),];rownames(tmp1) <- NULL
g <- graph.data.frame(tmp1, directed=TRUE)
V(g)$label <- unlist(lapply(strsplit(V(g)$name,"_"),
                            FUN=function(y){ifelse(y[length(y)] %in% names(lookup),
                              lookup[y[length(y)]],y[length(y)])}))
E(g)$label <- tmp1$num
plot(g,layout=layout.reingold.tilford,ylim=c(1,-1),edge.arrow.size=0.5)
legend("topleft", paste(lookup ,names(lookup),sep=" : "),ncol=2,bty="n",cex=0.7)
-------------------------------------------------------------------------------------------------------
legend("bottom",
       legend = c("Bilateral Aid","","","Other","",""),
       fill = c("deepskyblue4","darkolivegreen4","firebrick4","deepskyblue",
                "darkolivegreen1","firebrick1"),
       bg = "white", ncol = 2)
-------------------------------------------------------------------------------------------------------
override.aes guides + guides(colour = guide_legend(override.aes = list(alpha = 1))) subset(diamonds,FALSE) NULL NaN # Alpha parameter washes out legend:
gp <- ggplot() + geom_point(data=diamonds, aes(depth, price, colour=clarity), alpha=0.1)
print(gp)

# Full color legend:
dummyData <- diamonds[1, ]
dummyData$price <- NaN
#dummyData <- subset(diamonds, FALSE)   # this would be nicer but it doesn't work!
gp <- ggplot() +
  geom_point(data=diamonds, aes(depth, price, colour=clarity), alpha=0.1, legend=FALSE) + 
  geom_point(data=dummyData, aes(depth, price, colour=clarity), alpha=1.0, na.rm=TRUE)
print(gp)
-------------------------------------------------------------------------------------------------------
#Build the data
 t <- 1:1000
 x1 <- 100 * sin(0.01 * t)
 x2 <- 200 * cos(0.04 * t)

 #Set up the plot area for two "crammed" plots
 par(pty="m", plt=c(0.1, 1, 0, 1), omd=c(0.1,0.9,0.1,0.9))
 par(mfrow = c(2, 1))

 #Plot x1 and x2 together
 plot(t, x1, type="l", ylim = 1.5 * range(x1, x2), xaxt="n", xlab="", ylab="", main="", col="blue", las=2)
 lines(t, x2, lwd=1, col="red")
 mtext(side=2, "Top Plot", line=5.3, cex=0.8)
 mtext(side=2, "(units)", line=4, cex=0.8)
 grid()
 mtext(side=3, "2 Plots Crammed Together", line=1.5, cex=1.2)
 legend("topright", legend=c("100 * sin(0.01 * t)", "200 * cos(0.4 * t)"), bg="white", lwd=c(1, 1), col=c("blue", "red"), cex=0.9)

 #Place the 1st x-axis
 axis(side = 1, col="blue", col.axis="blue")
 linloc <- par()$usr[3]
 abline(h=linloc, col="blue")
 mtext(side=1, "First X-Axis", line=2.5, cex=0.8, col="blue")

 #Place the fake 2nd x-axis
 xaxis2 <- 1:10
 par(plt=c(0.1,1,0.6,1))
 plot(xaxis2, type="n", xaxt="n", xlab="", yaxt="n", ylab="", xlim=range(xaxis2), bty="n")
 axis(side = 1, col="red", col.axis="red")
 linloc <- par()$usr[3]
 abline(h=linloc, col="red")
 mtext(side=1, "Second X-Axis", line=2.5, cex=0.8, col="red")
-------------------------------------------------------------------------------------------------------
library(plotrix)

 #Build the matrix data to look like a correlation matrix
 n <- 8
 x <- matrix(runif(n*n), nrow=n)
 xmin <- 0
 xmax <- 1
 for (i in 1:n) x[i, i] <- 1.0 #Make the diagonal all 1's

 #Generate the palette for the matrix and the legend.  Generate labels for the legend
 palmat <- color.scale(x, c(1, 0.4), c(1, 0.4), c(0.96, 1))
 palleg <- color.gradient(c(1, 0.4), c(1, 0.4), c(0.96, 1), nslices=100)
 lableg <- c(formatC(xmin, format="f", digits=2), formatC(1*(xmax-xmin)/4, format="f", digits=2), formatC(2*(xmax-xmin)/4, format="f", digits=2), formatC(3*(xmax-xmin)/4, format="f", digits=2), formatC(xmax, format="f", digits=2))

 #Set up the plot area and plot the matrix
 par(mar=c(5, 5, 5, 8))
 color2D.matplot(x, cellcolors=palmat, main=paste(n, " X ", n, " Matrix Using Color2D.matplot", sep=""), show.values=2, vcol=rgb(0,0,0), axes=FALSE, vcex=0.7)
 axis(1, at=seq(1, n, 1)-0.5, labels=seq(1, n, 1), tck=-0.01, padj=-1)

 #In the axis() statement below, note that the labels are decreasing.  This is because
 #the above color2D.matplot() statement has "axes=FALSE" and a normal axis()
 #statement was used.
 axis(2, at=seq(1, n, 1)-0.5, labels=seq(n, 1, -1), tck=-0.01, padj=0.7)

 #Plot the legend
 pardat <- par()
 color.legend(pardat$usr[2]+0.5, 0, pardat$usr[2]+1, pardat$usr[2], paste(" ", lableg, sep=""), palleg, align="rb", gradient="y", cex=0.7)
-------------------------------------------------------------------------------------------------------
legend('topright',...)
-------------------------------------------------------------------------------------------------------
set.seed(1)
baseball <- data.frame(pitchNumber = seq_len(50),
                       outcome = factor(sample(c("B","H","S","S","X","H"), 
                                               50, replace = TRUE)))
> head(baseball)
  pitchNumber outcome
1           1       H
2           2       S
3           3       S
4           4       H
5           5       H
6           6       H ## better colours - like ggplot for the cool kids
##cols <- c("red","green","blue","yellow")
cols <- head(hcl(seq(from = 0, to = 360,
                    length.out = nlevels(with(baseball, outcome)) + 1), 
                 l = 65, c = 100), -1) pitchNumber type = "h" with(baseball, plot(pitchNumber, y = rep(1, length(pitchNumber)), type = "h", 
                    ylim = c(0, 1.2), col = cols[outcome],
                    ylab = "", xlab = "Pitch", axes = FALSE, lwd = 2))
with(baseball, points(pitchNumber, y = rep(1, length(pitchNumber)), pch = 16, 
                      col = cols[outcome])) axis(side = 1)
box()
## note: this assumes that the levels are in alphabetical order B,H,S,X...
legend("topleft", legend = c("Ball","Hit","Swinging Strike","X??"), lty = 1,
       pch = 16, col = cols, bty = "n", ncol = 2, lwd = 2)
-------------------------------------------------------------------------------------------------------
for #Set the number of bets and number of trials and % lines
numbet <- 6000 #6000 bets
numtri <- 1000 #Run 1000 trials of the 6000 bets
perlin <- 0.05 #Show the +/- 5% lines on the graph
rantri <- 60 #The 60th trial (just a random trial to be drawn)

#Fill a matrix where the rows are the cumulative bets and the columns are the trials
xcum <- matrix(NA, nrow=numbet, ncol=numtri)
for (i in 1:numtri) {
  x <- sample(c(-1,1), numbet, replace = TRUE)
  xcum[,i] <- cumsum(x)
}

#Plot the trials as transparent lines so you can see the build up
matplot(xcum, type="l", xlab="Number of Bets", ylab="Cumulative Sum", main="Cumulative Results", col=rgb(0.01, 0.01, 0.01, 0.02))
grid()

#Sort the trials of each bet so you can pick out the desired %
xcumsor <- xcum
for (i in 1:numbet) {
  xcumsor[i,] <- xcum[i,order(xcum[i,])]
}

#Draw the upper/lower limit lines and the 50% probability line     
lines(xcumsor[, perlin*numtri], type="l", lwd=2, col=rgb(1, 0.0, 0.0)) #Lower limit
lines(xcumsor[, 0.5*numtri], type="l", lwd=3, col=rgb(0, 1, 0.0)) #50% Line
lines(xcumsor[, (1-perlin)*numtri], type="l", lwd=2, col=rgb(1, 0.0, 0.0)) #Upper limit

#Show one of the trials
lines(xcum[, rantri], type="l", lwd=1, col=rgb(1, 0.8, 0)) #Random trial

#Draw the legend
legend("bottomleft", legend=c("Various Trials", "Single Trial", "50% Probability", "Upper/Lower % Limts"), bg="white", lwd=c(1, 1, 3, 2), col=c("darkgray", "orange", "green", "red")) #Set the bet sequence and the % lines
betseq <- 1:100000 #1 to 100,000 bets
perlin <- 0.05 #Show the +/- 5% lines on the graph

#Calculate the Upper and Lower limits using perlin
#qnorm() gives the multiplier for the square root
upplim <- qnorm(1-perlin)*sqrt(betseq)
lowlim <- qnorm(perlin)*sqrt(betseq)

#Get the range for y
yran <- range(upplim, lowlim)

#Plot the upper and lower limit lines
plot(betseq, upplim, ylim=yran, type="l", xlab="", ylab="")
lines(betseq, lowlim) dralim lines dralim #Set the bet sequence and the % lines
betseq <- 0:700 #0 to 700 bets
perlin <- 0.05 #Show the +/- 5% lines on the graph

#Define a function that plots the upper and lower % limit lines
dralim <- function(stax, endx, perlin) {
  lines(stax:endx, qnorm(1-perlin)*sqrt((stax:endx)-stax))
  lines(stax:endx, qnorm(perlin)*sqrt((stax:endx)-stax))
}

#Build the plot area and draw the vertical dashed lines
plot(betseq, rep(0, length(betseq)), type="l", ylim=c(-50, 50), main="", xlab="Trial Number", ylab="Cumulative Hits")
abline(h=0)
abline(v=35, lty="dashed") #Seg 1
abline(v=185, lty="dashed") #Seg 2
abline(v=385, lty="dashed") #Seg 3
abline(v=485, lty="dashed") #Seg 4
abline(v=585, lty="dashed") #Seg 5

#Draw the % limit lines that correspond to the vertical dashed lines by calling the
#new function dralim.
dralim(0, 35, perlin) #Seg 1
dralim(36, 185, perlin) #Seg 2
dralim(186, 385, perlin) #Seg 3
dralim(386, 485, perlin) #Seg 4
dralim(486, 585, perlin) #Seg 5
dralim(586, 701, perlin) #Seg 6
-------------------------------------------------------------------------------------------------------
plot(1L:10, main="Aʙᴄᴅᴇғɢʜɪᴊᴋʟᴍɴᴏᴘǫʀsᴛᴜᴠᴡxʏᴢ")
legend("bottomright", expression(\Delta Zʀᴛ1")
-------------------------------------------------------------------------------------------------------
plotCI plotrix plot.skyline ape library(ape)
library(plotrix)
data(bird.orders)

new_tree <- compute.brlen(bird.orders, runif, min = 0, max = 5)
sk1 <- skyline(new_tree)   

subst.rate <- 0.0023
year <- 2011
m <- sk1$population.size
lm <- length(m)

plot(sk1, show.years=TRUE, subst.rate = subst.rate, present.year = year, col="red")

plotCI(x = (-c(0, sk1$time))/subst.rate + year, y = c(m, m[lm]),
        uiw = runif(length(sk1$time)+1, min = 1, max = 30), # some random deviation
        #liw = runif(length(sk1$time)+1, min = 1, max = 30), # this one can be missing, see ?plotCI
        add = TRUE,
        pt.bg = NA
)

legend(.15,500, c("classic", "generalized"), col="red",lty=1)
-------------------------------------------------------------------------------------------------------
example(nls)
legend("topleft", legend = capture.output(summary(nlmod)), cex = .5)
-------------------------------------------------------------------------------------------------------
pairs f <- factanal(mtcars, factors=3)
pairs(f$loadings) f <- factanal(mtcars, factors=5)
pairs(f$loadings, col=1:ncol(mtcars), upper.panel=NULL, main="Factor loadings")
par(xpd=TRUE) 
legend('topright', bty='n', pch='o', col=1:ncol(mtcars), attr(f$loadings, 'dimnames')[[1]], title="Variables") library(scatterplot3d)
f <- factanal(mtcars, factors=3)
scatterplot3d(as.data.frame(unclass(f$loadings)), main="3D factor loadings", color=1:ncol(mtcars), pch=20)
-------------------------------------------------------------------------------------------------------
family legend() par() x <- y <- 1:10
plot(x, y, type = "n")
text(x = 5, y = 5, labels = "foo", family = "serif")

## set the font family to "serif"
## saving defaults in `op`
op <- par(family = "serif")

## plot legend as usual
legend("topright", legend = "foo legend", pch = 1, bty = "n")

## reset plotting parameters
par(op) family plot() family = "serif" text() par()
-------------------------------------------------------------------------------------------------------
questionnumbers<-c(1,2,3,4,5,6,7,8)
result1<-c(0.2,0.4,0.3,0.6,0.9,0.3,0.4,0.8)
result2<-c(0.4,0.9,0.3,0.1,0.4,0.6,0.3,0.2)

plot(questionnumbers, result2, type = 'b', ylim = c(0,0.9), col = 'green', xlab = 'Question Nunbers', ylab = '', main = 'Chart 2', panel.first = grid(nx = NA, ny = NULL))
lines(questionnumbers, result1, col = 'blue', type = 'b')
legend('bottomleft', c('result1','result2'), fill = c('blue', 'green'), cex = 0.8, bty = 'n', horiz = TRUE)
-------------------------------------------------------------------------------------------------------
goodfit grid ?rootogram getAnywhere(rootogram.default) grid.legend grid gridBase library("vcd")
dummy <- rnbinom(200, size=1.5, prob=0.8)
gf <- goodfit(dummy, type="nbinomial", method="MinChisq")
plot(gf)
pushViewport(viewport(x=unit(0.8, "npc"),
                      y=unit(0.8, "npc"),
                      width=stringWidth("Legend x"),
                      height=unit(6, "line"),
                      name="vp1"))
grid.legend(labels=c("Legend 1", "Legend 2"), pch=1:2)
popViewport()
-------------------------------------------------------------------------------------------------------
> cs <- c(bquote(theta == .(a)),bquote(theta == .(a)))
> cs
[[1]]
theta == 123

[[2]]
theta == 123

> sapply(cs, class)
[1] "call" "call" > c(as.expression(bquote(theta == .(a))), as.expression(bquote(theta == .(a))))
expression(theta == 123, theta == 123)
> plot(1,1)
> legend('bottomleft',legend= c(as.expression(bquote(theta == .(a))), 
+                               as.expression(bquote(theta == .(a))))) sapply plot(1,1)
legend("bottomleft", 
       sapply(c(bquote(theta == .(a)), bquote(theta == .(a))), as.expression))
-------------------------------------------------------------------------------------------------------
grid_legend vcd goodfit grid.legend fill=c(NA,"gray") legend grid_legend library("vcd")
dummy <- rnbinom(200, size=1.5, prob=0.8)
gf <- goodfit(dummy, type="nbinomial", method="MinChisq")
plot(gf)
grid_legend(x=unit(0.8, "npc"),
            y=unit(0.8, "npc"),
            labels=c("est NBinom (MinChiSq)","obs"),
            title="",
            pch=c(16,15),col=c("red","gray"))
-------------------------------------------------------------------------------------------------------
?legend #Construct some data and start the plot
x <- 0:64/64
y <- sin(3*pi*x)
plot(x, y, type="l", col="blue")
points(x, y, pch=21, bg="white")

#Grab the plotting region dimensions
rng <- par("usr")

#Call your legend with plot = FALSE to get its dimensions
lg <- legend(rng[1],rng[2], "sin(c x)", pch=21, 
            pt.bg="white", lty=1, col = "blue",plot = FALSE)

#Once you have the dimensions in lg, use them to adjust
# the legend position
#Note the use of xpd = NA to allow plotting outside plotting region             
legend(rng[1],rng[4] + lg$rect$h, "sin(c x)", pch=21, 
            pt.bg="white", lty=1, col = "blue",plot = TRUE, xpd = NA)
-------------------------------------------------------------------------------------------------------
par('usr') grconvertX grconvertY plot(1:10)
par(xpd=NA)
legend(par('usr')[1], par('usr')[4], yjust=0, legend='anything', pch=1)
legend( grconvertX(1, from='npc'), grconvertY(1, from='npc'), yjust=0,
 xjust=1, legend='something', lty=1)
-------------------------------------------------------------------------------------------------------
plot(1:10)                    # simple plot
legend("bottomright", "foo")  # 'foo' in bottom-right corner locator() legend()
-------------------------------------------------------------------------------------------------------
set.seed(1)
t1 = rnorm(10); t2 = rnorm(10, 2)
t1_g2 = rnorm(10, 4);t2_g2 = rnorm(10)

##Don't print the axes labels
par(ann=FALSE)

##Plot first set of data.
##Need to check for sensible ranges
##Use the jitter function to spread data out.
plot(jitter(rep(0,10),amount=0.2), t1,
     xlim=range(-0.5,3.5), ylim=range(-3,8),
     axes=FALSE,frame.plot=TRUE)
points(jitter(rep(1,10), amount=0.2), t1_g2, col=2)
points(jitter(rep(2,10), amount=0.2), t2)
points(jitter(rep(3,10), amount=0.2), t2_g2, col=2)

##Add in the y-axis
axis(2, seq(-4,8,by=2))

##Add in the x-axis labels
mtext("Treatment 1", side = 1, at=0.5)
mtext("Treatment 2", side = 1, at=2.5)

##Add in the means
segments(-0.25, mean(t1), 0.25, mean(t1))
segments(0.75, mean(t1_g2), 1.25, mean(t1_g2))
segments(1.75, mean(t2), 2.25, mean(t2))
segments(2.75, mean(t2_g2), 3.25, mean(t2_g2))

##Add in the legend
legend(0, 8, c("Group 1", "Group 2"), col=1:2, pch=1)
-------------------------------------------------------------------------------------------------------
jet.colors <-
   colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan",
                      "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))
plot(x,y, col=jet.colors(12)[z], ylim=c(0,100), pch=20, cex=2)
legend(8.5,90, col = jet.colors(12)[z], legend=z, pch=15) text(x, y+2, labels=z)  #offset vertically to see the colors require(akima)
require(lattice)
ak.interp <- interp(x,y,z)
pdf(file="out.pdf")
levelplot(ak.interp$z, main="Output of akima plotted with lattice::levelplot", contour=TRUE)
 dev.off()
-------------------------------------------------------------------------------------------------------
# Compare MPG distributions for cars with 
# 4,6, or 8 cylinders
library(sm)
attach(mtcars)

# create value labels 
cyl.f <- factor(cyl, levels= c(4,6,8),
    labels = c("4 cylinder", "6 cylinder", "8 cylinder")) 

# plot densities 
sm.density.compare(mpg, cyl, xlab="Miles Per Gallon")
title(main="MPG Distribution by Car Cylinders")

# add legend via mouse click
colfill<-c(2:(2+length(levels(cyl.f)))) 
legend(locator(1), levels(cyl.f), fill=colfill)
-------------------------------------------------------------------------------------------------------
data<-iris
plot(data$Sepal.Length, data$Sepal.Width, col=data$Species)
legend(7,4.3,unique(data$Species),col=1:length(data$Species),pch=1) ggplot2
-------------------------------------------------------------------------------------------------------
palette col = somefactor palette()
[1] "black"   "red"     "green3"  "blue"    "cyan"    "magenta" "yellow"  "gray" legend('topright', legend = levels(iris$Species), col = 1:3, cex = 0.8, pch = 1) ?rainbow
-------------------------------------------------------------------------------------------------------
legend library(RColorBrewer)
My.pal <- brewer.pal(9, "reds") WT my.pal binz
-------------------------------------------------------------------------------------------------------
y <- rnorm(1000, 0, 1) 
x <- rnorm(1000, 0.5, 2) 
DF <- data.frame("Group"=c(rep(c("y","x"), each=1000)), "Value"=c(y,x))

library(sm)

with(DF, sm.density.compare(Value, Group, xlab="Grouping"))
title(main="Comparative Density Graph")
legend(-9, .4, levels(DF$Group), fill=c("red", "darkgreen"))
-------------------------------------------------------------------------------------------------------
# Expand right side of clipping rect to make room for the legend
par(xpd=T, mar=par()$mar+c(0,0,0,6))

# Plot graph normally
plot(1:3, rnorm(3), pch = 1, lty = 1, type = "o", ylim=c(-2,2))
lines(1:3, rnorm(3), pch = 2, lty = 2, type="o")

# Plot legend where you want
legend(3.2,1,c("group A", "group B"), pch = c(1,2), lty = c(1,2))

# Restore default clipping rect
par(mar=c(5, 4, 4, 2) + 0.1)
-------------------------------------------------------------------------------------------------------
plot(1:3,
    col=c("black",rgb(96,123,139, 50, maxColorValue=255),
               rgb(225,64,5, 50,maxColorValue=255)),pch=19)

legend("topright", c("Shuffled", "Riffled", "Somosome"), cex=1.0, bty="n",
   col=c("black",rgb(96,123,139, 50, maxColorValue=255),
      rgb(225,64,5, 50, maxColorValue=255)),pch=19)
-------------------------------------------------------------------------------------------------------
colvec <- rgb(rbind(t(col2rgb("black")), ## this is obviously just 0, 0, 0
                    c(96,123,139),
                    c(225,64,5)),
              alpha=50,max=255)

plot(shuffled, p_val, pch=19, col=colvec[1], xlim=c(0,100), ylim=c(0,1))
points(ri, p_val, pch=19, col=colvec[2], 
       xlim=c(0,100), ylim=c(0,1))
points(somo, p_val, pch=19, col=colvec[3], 
       xlim=c(0,100), ylim=c(0,1))
legend("topright", c("Shuffled", "Riffled", "Somosome"), cex=1.0, bty="n",
       col=colvec)
-------------------------------------------------------------------------------------------------------
qplot(1:4, 1:4, colour = letters[1:4]) + guides(colour = guide_legend(nrow = 2, byrow = T))
-------------------------------------------------------------------------------------------------------
text(axTicks(1), par("usr")[3] - 2, srt=45, adj=1, labels=lab, xpd=T, cex=0.8) axTicks(1) > axTicks(1)
[1]  5 10 15 1:19 text(1:19, par("usr")[3] - 2, srt=45, adj=1, labels=lab, xpd=T, cex=0.8) Runtime <- c(579,0,581,610,830,828,592,651,596,596,591,581,587,
             594,604,606,447,434,445)
g_range <- range(0,Runtime)
lab <- c('2011-07-20','2011-08-03','2011-08-10','2011-08-17','2011-08-24',
         '2011-08-25','2011-08-27','2011-08-31','2011-09-07','2011-09-10',
         '2011-09-14','2011-09-21','2011-09-28','2011-10-05','2011-10-06',
         '2011-10-07','2011-10-13','2011-10-19','2011-10-31')
## plot
op <- par(mar = c(6,4,4,2) + 0.1) ## bigger bottom margin
plot(Runtime, type="o", col="blue", ylim=g_range, axes=FALSE, ann=FALSE)
box()
axis(1, at=1:19, lab=FALSE)
text(1:19, par("usr")[3] - 40, srt=45, adj=1.2, labels=lab, xpd=T, cex=0.7)
axis(2, las=1, at=500*0:g_range[2])
title(main="Runtime", col.main="red", font.main=4)
title(xlab="Build", col.lab=rgb(0,0.5,0), line = 4.5)
title(ylab="MS", col.lab=rgb(0,0.5,0))
legend("topright", c("AveElapsedTime"), cex=0.8, col=c("blue"), pch=21, lty=1)
## reset par
par(op) y y ## load gridBase
require(gridBase)

## do the base plot parts
op <- par(mar = c(6,4,4,2) + 0.1) ## bigger bottom margin
plot(1:19, Runtime, type="o", col="blue", ylim=g_range, axes=FALSE, ann=FALSE)
box()
axis(1, at=1:19, lab=FALSE)
axis(2, las=1, at=500*0:g_range[2])
title(main="Runtime", col.main="red", font.main=4)
title(xlab="Build", col.lab=rgb(0,0.5,0), line = 4.5)
title(ylab="MS", col.lab=rgb(0,0.5,0))
legend("topright", c("AveElapsedTime"), cex=0.8, col=c("blue"), pch=21, lty=1)
## at this point, DO NOT alter the dimensions of the plotting window

## now do the grid business
vps <- baseViewports()
pushViewport(vps$inner, vps$figure, vps$plot)
## this adds the text
grid.text(lab, x = unit(1:19, "native"), y = unit(-1, "lines"),
          just = "right", rot = 60, gp = gpar(cex = 0.7))
## this finishes off the viewport - you have to do this or things will go wrong:
popViewport(3)
## reset par
par(op) pdf()
-------------------------------------------------------------------------------------------------------
as.expression(z) drawGraph <- function(x, y, z) {
    g_range <- range(0,x)
    plot(x, type="o", col="blue", ylim=g_range,axes=FALSE, ann=FALSE)
    box()
    axis(1, at=1:19, lab=FALSE)
    text(1:19, labels=y,par("usr")[3] - 2, srt=45, adj=1.2, xpd=T, cex=0.3)
    axis(2, las=1, at=500*0:g_range[2])
    main_title<-as.expression(z)
    title(main=main_title, col.main="red", font.main=4)
    title(xlab="Build", col.lab=rgb(0,0.5,0))
    title(ylab="MS", col.lab=rgb(0,0.5,0))
    legend("topright", g_range[2], c("z"), cex=0.8, col=c("blue"), pch=21, lty=1);
}
x <- rpois(19, 4)
AveElapsedTime=paste("The average time with ranges:", 
                       round(range(x)[1], 3), 
                        "to" , round(range(x), 3)[1])
lab=1:19
drawGraph(AET, lab, AveElapsedTime)
-------------------------------------------------------------------------------------------------------
plotvar=c(rep(NA,20),rep(0,20),1:10)
nclr <- 8
plotclr <- brewer.pal(nclr,"BuPu")
class <- classIntervals(plotvar, nclr, style="quantile")
colcode <- findColours(class, plotclr)

plot(1:10)

legend(5,5, legend=names(attr(colcode, "table")),
    fill=attr(colcode, "palette"), cex=0.6, bty="n") set.seed(310366)
x=1:30
y=30*runif(30)
plotvar=sample(5+10*c(rep(NA,20),runif(10)))
nclr <- 8
plotclr <- brewer.pal(nclr,"Spectral")
class <- classIntervals(plotvar, nclr, style="quantile")
colcode <- findColours(class, plotclr)

plot(x,y,col="black",pch=21,bg=colcode)

legend(5,10, legend=c("Missing",names(attr(colcode, "table"))),
    fill=c("white",attr(colcode, "palette")), cex=0.6, bty="n")
-------------------------------------------------------------------------------------------------------
lty plot(c(0,1), c(0, 1), type = "n")
legend("topleft", legend = c("Model", "Data"),
       lwd = c(3, NA),
       lty = c(1, 0), # 0=blank, 1=solid (default). See ?par for more.
       pch = c(NA, 16),
       bty = "n", inset = 0.02,
       cex = 2) lwd ?par lty lwd
-------------------------------------------------------------------------------------------------------
rect d <- as.matrix(read.table("http://dl.dropbox.com/u/2505196/postH.dat"))
#remove upper half of the values (as they are mirrored values)
d[upper.tri(d)] <- NA
dat <- within(as.data.frame(as.table(d)),{
Var1 <- as.numeric(Var1)
Var2 <- as.numeric(Var2)})
par(mar=c(6,3,3,6))
colPh=c("gray50","gray90","black")
plot(dat$Var1,dat$Var2,bg = colPh[1+findInterval(dat$Freq, c(-5.45,5.45))],
    col="white",cex=1.2,pch = 21,axes=F,xlab="",ylab="")
labDis <- rep(c("A","B","C","D","E"),times=7)
labChar <- c(1:7)
axis(1,at=1:35,labels=labDis,cex.axis=0.5,tick=F,line=-1.4)
axis(1,at=seq(3,33,5),labels=labChar, tick=F)
#drawing lines above axis for better identification
rect(1,0,5,0,angle=90);rect(6,0,10,0,angle=90);rect(11,0,15,0,angle=90);
rect(16,0,20,0,angle=90);rect(21,0,25,0,angle=90);rect(26,0,30,0,angle=90);
rect(31,0,35,0,angle=90)
axis(4,at=1:35,labels=labDis,cex.axis=0.5,tick=F,line=-1.4)
axis(4,at=seq(3,33,5),labels=labChar,tick=F)
#drawing lines above axis for better identification
rect(36,1,36,5,angle=90);rect(36,6,36,10,angle=90);rect(36,11,36,15,angle=90);
rect(36,16,36,20,angle=90);rect(36,21,36,25,angle=90);rect(36,26,36,30,angle=90);
rect(36,31,36,35,angle=90)
legend("topleft",legend=c("not significant","p<0.01","p<0.05"),pch=16,
col=c("gray90","gray50","black"),cex=0.7,bty="n")
-------------------------------------------------------------------------------------------------------
oma mtext op <- par(
  oma=c(0,0,3,0),# Room for the title and legend
  mfrow=c(2,2)
)
for(i in 1:4) {
  plot( cumsum(rnorm(100)), type="l", lwd=3,
  col=c("navy","orange")[ 1+i%%2 ], 
  las=1, ylab="Value",
  main=paste("Random data", i) )
}
par(op) # Leave the last plot
mtext("Main title", line=2, font=2, cex=1.2)
op <- par(usr=c(0,1,0,1), # Reset the coordinates
          xpd=NA)         # Allow plotting outside the plot region
legend(-.1,1.15, # Find suitable coordinates by trial and error
  c("one", "two"), lty=1, lwd=3, col=c("navy", "orange"), box.col=NA)
-------------------------------------------------------------------------------------------------------
plot(1:5,type="n",main="Pie charts are evil",xlab="",ylab="",axes=FALSE)#empty plot
require(plotrix)
main_col <- c("#ff0000","#80ff00","#00ffff")#nice colors
main_pie <- floating.pie(3,3,c(40,50,20), col=main_col,radius=1)#your big pie
#here are your small pies with labels using plotrix functions
small_col <- c("black","white")
small_lab <- c("I","II")
A <- floating.pie(3.8,4.5,c(15,5), col=small_col,radius=0.2)
pie.labels(3.8,4.5,A,small_lab,border=F,radius=0.3,cex=0.8)
B <- floating.pie(1.7,2,c(15,25), col=small_col,radius=0.2)
pie.labels(1.7,2,B,small_lab,border=F,radius=0.3,cex=0.8)
C <- floating.pie(4.3,2,c(5,45), col=small_col,radius=0.2)
pie.labels(4.3,2,C,small_lab,border=F,radius=0.3,cex=0.8)
#and finally very useful legend
legend("right",legend=c("A","B","C"),col=main_col,bty="n",pch=15)
-------------------------------------------------------------------------------------------------------
pt.cex legend() cex pt.cex title.cex
-------------------------------------------------------------------------------------------------------
legend("topleft", legend=levels(factor(data.c)), text.col=seq_along(levels(factor(data.c))))
-------------------------------------------------------------------------------------------------------
#Plot an empty graph and legend to get the size of the legend
x <-1:10
y <-11:20
plot(x,y,type="n", xaxt="n", yaxt="n")
my.legend.size <-legend("topright",c("Series1","Series2","Series3"),plot = FALSE)

#custom ylim. Add the height of legend to upper bound of the range
my.range <- range(y)
my.range[2] <- 1.04*(my.range[2]+my.legend.size$rect$h)

#draw the plot with custom ylim
plot(x,y,ylim=my.range, type="l")
my.legend.size <-legend("topright",c("Series1","Series2","Series3"))
-------------------------------------------------------------------------------------------------------
max() legend ylim a=c(rnorm(1000))
b=c(rnorm(1000))
par(mfrow=c(1,2))
plot(a,ylim=c(0,max(a)+1))
legend(x=max(a)+0.5,legend="a",pch=1)
plot(a,b,ylim=c(0,max(b)+1),pch=2)
legend(x=max(b)-1.5,y=max(b)+1,legend="b",pch=2)
-------------------------------------------------------------------------------------------------------
set.seed(121)
a=sample(1:100,5)
b=sample(1:100,5)
c=sample(1:100,5)

dev.off()

layout(rbind(1,2), heights=c(7,1))  # put legend on bottom 1/8th of the chart

plot(a,type='l',ylim=c(min(c(a,b,c)),max(c(a,b,c))))
lines(b,lty=2)
lines(c,lty=3,col='blue')

# setup for no margins on the legend
par(mar=c(0, 0, 0, 0))
# c(bottom, left, top, right)
plot.new()
legend('center','groups',c("A","B","C"), lty = c(1,2,3),
       col=c('black','black','blue'),ncol=3,bty ="n")
-------------------------------------------------------------------------------------------------------
ind <- function(x) {
  # Divide each column by the first non-NA value
  # (There may already be a function to do that.)
  coredata(x) <- t(t(coredata(x)) / apply(coredata(x),2,function(u){ c(u[!is.na(u)&u!=0],NA)[1] }))
  x
}
x <- cbind( Ad(GSPC), Ad(VIX) )
x <- x["2011-11::"]

# Using base graphics
matplot( 
  index(x), coredata(ind(x)), 
  xlab="", ylab="", main="",
  type="l", lty=1, lwd=3, axes=FALSE 
)
abline(h=1, lty=3, col="lightgrey")
axis(2, las=1)
axis.Date(1, index(x))
box()
legend( "topleft", gsub("\\..*", "", names(x)), lty=1, lwd=3, col=1:2 )

# If you prefer ggplot2
library(ggplot2)
library(reshape2)
d <- data.frame( date = index(x), coredata(ind(x)) )
names(d) <- gsub("\\..*", "", names(d))
d <- melt(d, id.vars="date")
ggplot(d, aes(date, value, color=variable)) + geom_line(size=2)
-------------------------------------------------------------------------------------------------------
plot.VennDiagram y$colors getAnywhere("plot.VennDiagram") col.fn <- function(col, alpha=0.3) {
    col<- hcl(col * 360, 130, 60)
    col <- col2rgb(col)/255
    col <- rgb(col[1, ], col[2, ], col[3, ], alpha)
    col
}

COL <- col.fn(y$colors)
# The original order of columns in x is jumbled in the object returned
# by venneuler. This code is needed to put the colors and labels back
# in the original order (here alphabetical).
LABS <- y$labels
id <-  match(colnames(x), LABS)

plot(y)
legend(.05, .9, legend = LABS[id], fill = COL[id], x="topleft")
-------------------------------------------------------------------------------------------------------
dat <- structure(list(Response = c(1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 
  1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 0L, 0L, 0L, 0L, 0L, 
  0L, 0L), Temperature = c(29.33, 30.37, 29.52, 29.66, 29.57, 30.04, 
  30.58, 30.41, 29.61, 30.51, 30.91, 30.74, 29.91, 29.99, 29.99, 
  29.99, 29.99, 29.99, 29.99, 30.71, 29.56, 29.56, 29.56, 29.56, 
  29.56, 29.57, 29.51)), .Names = c("Response", "Temperature"), 
  class = "data.frame", row.names = c(NA, -27L))

temperature.glm <- glm(Response ~ Temperature, data=dat, family=binomial)

plot(dat$Temperature, dat$Response, xlab="Temperature", 
     ylab="Probability of Response")
curve(predict(temperature.glm, data.frame(Temperature=x), type="resp"), 
      add=TRUE, col="red")
# To add an additional curve, e.g. that which corresponds to 'Set 1':
curve(plogis(-88.4505 + 2.9677*x), min(dat$Temperature), 
      max(dat$Temperature), add=TRUE, lwd=2, lty=3)
legend('bottomright', c('temp.glm', 'Set 1'), lty=c(1, 3), 
       col=2:1, lwd=1:2, bty='n', cex=0.8) curve x y plogis(z) 1/(1+exp(-z)) min(dat$Temperature) max(dat$Temperature) x y x curve n <- 100 # size of random sample

# generate random temperature data (n draws, uniform b/w 27 and 33)
temp <- runif(n, 27, 33)

# Define a function to perform a Bernoulli trial for each value of temp, 
#   with probability of success for each trial determined by the logistic
#   model with intercept = alpha and coef for temperature = beta.
# The function also plots the outcomes of these Bernoulli trials against the 
#   random temp data, and overlays the curve that corresponds to the model
#   used to simulate the response data.
sim.response <- function(alpha, beta) {
  y <- sapply(temp, function(x) rbinom(1, 1, plogis(alpha + beta*x)))  
  plot(y ~ temp, pch=20, xlab='Temperature', ylab='Response')
  curve(plogis(alpha + beta*x), min(temp), max(temp), add=TRUE, lwd=2)    
  return(y)
} # Simulate response data for your model 'Set 1'
y <- sim.response(-88.4505, 2.9677)

# Simulate response data for your model 'Set 2'
y <- sim.response(-88.585533, 2.972168)

# Simulate response data for your model temperature.glm
# Here, coef(temperature.glm)[1] and coef(temperature.glm)[2] refer to
#   the intercept and slope, respectively
y <- sim.response(coef(temperature.glm)[1], coef(temperature.glm)[2])
-------------------------------------------------------------------------------------------------------
1.5, 0.5 legend("right", c("Mon","Tue","Wed","Thu","Fri"), cex=0.8, fill=colors) pie legend
-------------------------------------------------------------------------------------------------------
# Create a legend at the right   
legend("topleft", c("Mon","Tue","Wed","Thu","Fri"), cex=0.8, fill=colors) legend
-------------------------------------------------------------------------------------------------------
trace = TRUE text() trace pos = 2 set.seed(1)
    plot(1:10,runif(min=0,max=10,10),type='l',ylim=c(0,10),xlim=c(0,10),col=1)
    lines(1:10,runif(min=0,max=10,10),col=2,lty=2)
    lines(1:10,runif(min=0,max=10,10),col=3,lty=2)
    a <- legend(1,10,lty=1:3,col=1:3,legend=c("","",""),bty="n",trace=TRUE)
    text(a$text$x-1,a$text$y,c("line 1","line 2","line 3"),pos=2)
-------------------------------------------------------------------------------------------------------
plot.igraph library(igraph)

data <- read.table(text=
"Item A,Item B,Weight
X,Y,2
X,Z,5
Y,Z,3
Y,W,2", sep=',',header=TRUE)

g <- graph.data.frame(data,directed=TRUE)

vColors <- 'MediumSeaGreen'
vSizes <- 40 
vShapes <- 'circle' 
vLabels <- V(g)$name
vFontSizes <- 1.5

eColors <- 'blue'
eArrowSizes <- 1
eWidths <- 1
eLabels <- as.character(E(g)$Weight)
eLTypes <- 'dashed'
eFontSizes <- 1.5

plot(g, layout=layout.fruchterman.reingold,
        vertex.color=vColors, vertex.size=vSizes, vertex.shape=vShapes, 
        vertex.label=vLabels, vertex.label.dist=0, vertex.label.cex=vFontSizes,
        edge.color=eColors, edge.width=eWidths, edge.arrow.size=eArrowSizes,  
        edge.label=eLabels, edge.lty=eLTypes, edge.label.cex=eFontSizes) plot() legend(x=-1,c('X - Foo','Y - Bar','Z - Foo2','W - Bar2'))
-------------------------------------------------------------------------------------------------------
library(ecolitk)

plot.new()
plot.window(c(-5, 5), c(-5, 5))

plot.chrom = function(data, chromlength, radius=1,
                        width=chromlength/length(data), ...) {
    linesCircle(radius, ...)
    starts = seq(1, chromlength - width, width)

    scale = .5 / max(abs(data))
    for (i in 1:length(starts)) {
        polygonChrom(starts[i], starts[i]+width, chromlength, radius,
                data[i] * scale + radius, ...)
    }
}

plot.chrom(rnorm(100, 10, 1), 10000, radius=1)
plot.chrom(rnorm(100, 10, 2), 10000, radius=2, col="blue")
plot.chrom(rnorm(100, 10, 5), 10000, radius=3, col="red")
plot.chrom(rnorm(100, 10, 10), 10000, radius=4, col="green")

legend("topright", legend=c("chr1", "chr2", "chr3", "chr4"),
       col=c("black", "blue", "red", "green"), lty=1) plot.multi.chrom = function(data, colors, spacing=50) {
    plot.new()
    plot.window(c(-5, 5), c(-5, 5))

    lengths = ddply(data, .(chr), function(x) max(x$position))
    nchrom = NROW(lengths)
    offsets = cumsum(c(0, lengths[, 2])) + cumsum(c(0, rep(spacing, nchrom)))
    tot.length = offsets[length(offsets)] + spacing

    scales = .75 / apply(abs(data[, 3:NCOL(data)]), 2, max)

    for (i in 1:NROW(data)) {
        for (j in 3:NCOL(data)) {
            start = offsets[data[i, 1]] + data[i, 2]
            polygonChrom(start, start + 1, tot.length,
                         j - 2, data[i, j] * scales[j - 2] + j - 2,
                         col=colors[j - 2])
        }
    }
}

chr <- rep (1:4, each = 200) 
position <- c(1:200, 1:200, 1:200, 1:200)
v1bar <- rnorm(800, 10, 2)
v2bar <- rnorm(800, 10, 2)
v3bar <- rnorm(800, 10, 2)
mydata <- data.frame(chr=chr, position, v1bar, v2bar, v3bar)

 require(plyr) 

plot.multi.chrom(mydata, colors=c("red", "black", "green"), spacing=50)

legend("topright", legend=c("V1", "V2", "V3"),
       col=c("red", "black", "green"), lty=1)
-------------------------------------------------------------------------------------------------------
pdf() pdf(width=4.375, height=2.8, file = "out.pdf")

par(bty="l",las=1,lwd=1,cex=0.7,oma = c(1, 1, 0, 1), mar = c(3, 4, 3.5, 5))
plot(1:10,type="l")
legend.names <-c("Dividend yield (L)","Core CPI (L)",
    "Dividend yield - core CPI spread (R)")
legend("bottomright", legend=legend.names,  lwd=1, cex=0.7, col =1:3,lty=1:3)

dev.off()
-------------------------------------------------------------------------------------------------------
recordPlot() replayPlot() pdf() legend() recordGraphics() my.savePlot <- function(filename, type) {
   if (type == "pdf") {
      saved.plot <- recordPlot()
      pdf(filename, width  = par("din")[1],
                    height = par("din")[2])
      replayPlot(saved.plot)
      invisible(dev.off())
   } else {
      savePlot(filename, type)
   }
}

win.graph(width=4.375,height=2.8)
par(bty="l",las=1,lwd=1,cex=0.7,oma = c(1, 1, 0, 1), mar = c(3, 4, 3.5, 5))
plot(1:10,type="l")
legend.names <-c("Dividend yield (L)","Core CPI (L)",
                 "Dividend yield - core CPI spread (R)")
recordGraphics(legend("bottomright", legend=legend.names,
                      lwd=1, cex=0.7, col =1:3,lty=1:3),
               list(), getNamespace("graphics"))

my.savePlot(filename = paste("out.pdf",sep=""), type ="pdf")
-------------------------------------------------------------------------------------------------------
pdf("out.pdf", width=4.375,height=2.8)
par(bty="l",las=1,lwd=1,cex=0.7,oma = c(1, 1, 0, 1), mar = c(3, 4, 3.5, 5))
plot(1:10,type="l")
legend.names <-c("Dividend yield (L)","Core CPI (L)",
             "Dividend yield - core CPI spread (R)")
legend("bottomright", legend=legend.names,  lwd=1, cex=0.7, col =1:3,lty=1:3)
dev.off()
-------------------------------------------------------------------------------------------------------
set.seed(2)
    plot(0:10, rnorm(11), col = sample(c("green", "blue"), 11, replace = TRUE), 
        pch = sample(c(3, 19), 11, replace = TRUE), xlim = c(0, 12))
    legend("topright", pch = c(3, 19, NA, 3, 19), 
        col = c("green", "green", NA, "blue", "blue"), 
        legend = c("green cross", "green dot", NA, "blue cross", "blue dot")) legend() trace=TRUE
-------------------------------------------------------------------------------------------------------
reverse = TRUE ggplot(datam,aes(x = variable, y = value,fill = factor(as.numeric(ind)))) +
  geom_bar(position = "fill") + scale_y_continuous(labels =percent_format()) +
  scale_fill_discrete("Barcode\nMatch") + xlab("Barcode")+ylab("Reads") +
  guides(fill = guide_legend(reverse = TRUE))
-------------------------------------------------------------------------------------------------------
plot() Raster* image(temp_var, axes=FALSE, xlab="", ylab="") layout(matrix(c(1,1,1,1,1,2,2), 7, 1))
par(mar=c(0,0,0,0))
image(temp_var, axes=FALSE, xlab="", ylab="")
plot(c(0,1), c(0,1), type="n", xlab="", ylab="", axes=FALSE)
legend(0.1,0.9, legend=c(1:5), fill=rainbow(5), horiz=TRUE)
-------------------------------------------------------------------------------------------------------
guides p + guides(colour = guide_legend(title.hjust = 0.5)) guides
-------------------------------------------------------------------------------------------------------
geom_ribbon dat <- data.frame(cond1=c("a","a","b","b"),
          cond2=c("c","d","c","d"),
          x=c(1,5),
          y=c(1,5),
          sl=c(1,1.2,0.9,1.1),
          int=c(0,0.1,0.1,0),
          slopeU=c(1.1,1.3,1.2,1.2),
          slopeL=c(.9,1,0.7,1))

genRibbon <- function(param,xrng){
    #xrng is a vector of min/max x vals in original data
    r <- abs(diff(xrng))
    #adj for plot region expansion
    x <- seq(xrng[1] - 0.05*r,xrng[2] + 0.05*r,length.out = 3)
    #create data frame
    res <- data.frame(cond1 = param$cond1,
                      cond2 = param$cond2,
                      x = x,
                      y = param$int + param$sl * x,
                      ymin = param$int + param$slopeL * x,
                      ymax = param$int + param$slopeU * x)
    #Toss the min/max x vals just to be safe; needed them 
    # only to get the corresponding y vals
    res$x[which.min(res$x)] <- -Inf
    res$x[which.max(res$x)] <- Inf
    #Return the correspondinng geom_ribbon
    geom_ribbon(data = res,aes(x = x,y=y, ymin = ymin,ymax = ymax,
                               fill = cond1,colour = NULL),
                alpha = 0.5)
}

ribs <- dlply(dat,.(cond1,cond2),genRibbon,xrng = c(1,5)) geom_ribbon p + ribs + 
    guides(fill = guide_legend(override.aes = list(alpha = 0.1))) alpha
-------------------------------------------------------------------------------------------------------
dataPlot1 <- data.frame(x=temp1, y=temp2, z=temp3) legend= legend() legtxt=c("x","y","z") legend
-------------------------------------------------------------------------------------------------------
temperature <- function(temp1,temp2,temp3)
{ t1 <- deparse(substitute(temp1))
  t2 <- deparse(substitute(temp2))
  t3 <- deparse(substitute(temp3)) 
    dataPlot1 <- data.frame(temp1,temp2,temp3)
    matplot(dataPlot1,axes=T,frame=T,type="l",
            xlab="time (hour)",ylab="temperature(C)",
            main=names(dataPlot1))
    lines(dataPlot1[1],lty=1,col="blue")
    lines(dataPlot1[2],lty=2,col="red")
    lines(dataPlot1[3],lty=2,col="forestgreen")  
    legend("topright", c(t1,t2,t3), lty=c(1,2,2),
            col=c("blue","red","forestgreen"))
-------------------------------------------------------------------------------------------------------
colour library(scales)
+ guides(colour = guide_legend(title.position = "left")) guide_colorbar guide_legend library(ggplot2)
library(scales)
p <- ggplot(mtcars, aes(wt, mpg))
p + geom_point(aes(colour = qsec)) + 
    guides(colour = guide_legend(title.position = "right"))
-------------------------------------------------------------------------------------------------------
> plot(1,1)
> legend(c("A", "B"), col = 1:2, x = 1, y = .8, lty="99", pch=1:2) lty 9 9
-------------------------------------------------------------------------------------------------------
"Average daily per capita calories from the U.S. food availability, adjusted for spoilage and other waste",,,,,,
,,,,,,
"Meat, eggs, and nuts",Dairy,Fruit,Vegetables,Flour and cereal products,Added fats and oils and dairy fats,Caloric sweeteners
,,,,,,
,,,,,,
,,,,,,
,,,,,,
463,267,70,125,432,411,402
472,268,72,123,426,405,405
470,265,67,122,421,416,410 skip read.csv d <- read.csv("Calories.csv", skip=2)
matplot(d, type="l", lty=1, lwd=3, las=1)
legend("topleft", names(d), col=1:ncol(d), lty=1, lwd=3)
-------------------------------------------------------------------------------------------------------
points plot(1,1)
legend(c("A", "B"), col = 1:2, x = 1, y = .8, lty=1, pt.bg=1:2, pch=21:22)
-------------------------------------------------------------------------------------------------------
legend() x1 y1 body(legend)[[46]] legend2 <- legend
body(legend2)[[49]] <- quote(
  invisible(list(rect = list(w = w, h = h, left = left, top = top),
  text = list(x = xt, y = yt), points = list(x = x1, y = y1)))
) plot(-100:100, -100:100, type = "b") pch = 21 pt.bg = 'white' legend2() pt.lwd pt.cex myLegend <- legend2(1, .8, bty = 'n', c('sugar','citrus','none'), pch = 21,
  pt.bg = 'white', pt.lwd = 0, lty = c(1, 2, 3), lwd = 1.5, title = "Condition",
  pt.cex = c(1.8), cex = 1.5) points() myLegend points(myLegend$points$x, myLegend$points$y, pch = c('s','c','u'), cex = 1.5)
-------------------------------------------------------------------------------------------------------
library(reshape2) # for melt
df <- melt(outer(1:4, 1:4), varnames = c("X1", "X2"))
p1 <- ggplot(df, aes(X1, X2)) + geom_tile(aes(fill = value))
p1 + scale_fill_continuous(guide = guide_legend()) +
    theme(legend.position="bottom")
-------------------------------------------------------------------------------------------------------
# run this code before calling ggplot2 function
guides_merge <- function(gdefs) {
  gdefs <- lapply(gdefs, function(g) { g$hash <- paste(g$order, g$hash, sep = "z"); g})
  tapply(gdefs, sapply(gdefs, function(g)g$hash), function(gs)Reduce(guide_merge, gs))
}
environment(guides_merge) <- environment(ggplot)
assignInNamespace("guides_merge", guides_merge, pos = "package:ggplot2") order guide_legend guide_colorbar # specify the order of the legend.
qplot(data = mpg,x = displ, y = cty, size = hwy, colour = class, alpha = cyl)+
 guides(size = guide_legend(order = 1), colour = guide_legend(order = 2), alpha = guide_legend(order = 3))

qplot(data = mpg,x = displ, y = cty, size = hwy, colour = class, alpha = cyl)+
 guides(size = guide_legend(order = 3), colour = guide_legend(order = 1), alpha = guide_legend(order = 2)) order
-------------------------------------------------------------------------------------------------------
?legend plot(1:10,type = "n")
abline(v=seq(1,10,1), col='grey', lty='dotted')
legend(1, 5, "This legend text should not be disturbed by the dotted grey lines,\nbut the plotted dots should still be visible",box.lwd = 0,box.col = "white",bg = "white")
points(1:10,1:10) \n
-------------------------------------------------------------------------------------------------------
value<-rnorm(100,1000,200) ##create list of numbers, "scan()" may be used for real observations
nmbrs<-length(value) ## determine the length of vector
obrv<-1:length(value) ## create list of observations
par(xpd=FALSE)
sd1<-sd(value[1:20])*1 ## 1 standart deviation
sd2<-sd(value[1:20])*2 ## 2 standart deviations
sd3<-sd(value[1:20])*3 ## 3 standart deviations
usd1<-mean(value)+sd1 ## upper limit
lsd1<-mean(value)-sd1 ## lower limit
lsd2<-mean(value)-sd2 ## lower limit
usd2<-mean(value)+sd2 ## upper limit
usd3<-mean(value)+sd3 ## upper limit
lsd3<-mean(value)-sd3 ## lower limit

## ploting the grid
plot(obrv,value,type="n",xlab="Observations",ylab="Value",ylim=c(lsd3-sd1,usd3+sd1))
abline(h=mean(value),col=2,lty=1)
abline(h=usd1,col=3,lty=3)
abline(h=lsd1,col=3,lty=3)
abline(h=usd2,col=4,lty=2)
abline(h=lsd2,col=4,lty=2)
abline(h=usd3,col=6,lty=1)
abline(h=lsd3,col=6,lty=1)


## 20 first values for L-G chart for QC limits
for (i in 1:20) 
{
points(obrv[i],value[i],col="black")
}
lines(obrv[1:20],value[1:20],col="red")


## if over mean - "red", under mean - "blue"
for (i in 21:nmbrs) 
{
points(obrv[i],value[i],col="blue")
segments(obrv[i-1],value[i-1],obrv[i],value[i],col="blue")
}

# 1s points - blue; 2s points - red
#if (value[i]<usd1 || value[i]>lsd1) points(obrv[i],value[i],col="blue")
#if (value[i]>usd1 || value[i]<lsd1) points(obrv[i],value[i],col="red")

#12s violation rule
#if (value[i]>usd1 || value[i]<usd1) text(30, usd3, "12s violation")
#if (value[i]>usd1 || value[i]<usd1) text(30, usd3, "12s violation")
#segments(obrv[i-1],value[i-1],obrv[i],value[i],col="blue")
#if (value[i]>usd1) break
#}


#legend placement - might be omited
#legend(1,min(value)-sd1*0.2,bg=8,c("mean","sd1","sd2","sd3"),lty=c(1,3,2,1),lwd=c(2.5,2.5,2.5,2.5),col=c(2,3,4,6),cex=0.8)
-------------------------------------------------------------------------------------------------------
par(mfrow = c(2,1), mar = c(4,4,1,1), oma=c(2,2,2,2))
stuff <- c("ed", "bla")
cols <- c("red", "blue")
for(i in 1:length(stuff)) {
x <- rnorm(10,3,2)
y <- seq(1,10)
plot(x,y, type = "o", col = cols[i], xlab = paste("stuff about", stuff[i]))}
legend("bottomright", legend = stuff, col = cols, lwd = 1, bty = "n")
par(mfrow=c(1,1))
title(main = "ed & bla", outer = T)
mtext("This is a plot", 3, line=0.5, adj=1.0, cex=1, outer=TRUE)
-------------------------------------------------------------------------------------------------------
ggplot() group group centroids geom_text groups=NULL geom_text ggplot(map.data2, aes(long, lat, group=group)) +  
   geom_polygon(aes(fill=level), colour=alpha('white', 1/2), size=0.2) +
   geom_polygon(data=ny, colour='black', fill=NA) + 
   scale_fill_brewer(palette='RdYlBu', guide = guide_legend(title = 
         "Percent Passing"))+
   facet_grid(.~Subject)+
   geom_text(data=centroids, aes(x=long, y=lat, 
     label=subregion, angle=angle, group=NULL), size=3) +   # THIS HAS CHANGED!
   opts(title = " 
     New York State Counties Passing Rate \non Elementary ELA Assessments") +
   opts(axis.text.x = theme_blank(), axis.text.y = theme_blank(), 
       axis.ticks = theme_blank())+
   opts(legend.background = theme_rect()) +
   scale_x_continuous('') + scale_y_continuous('') + 
   labs(title = "legend title") + theme_bw()+
    opts(axis.line=theme_blank(),axis.text.x=theme_blank(),
      axis.text.y=theme_blank(),axis.ticks=theme_blank(),
      axis.title.x=theme_blank(), legend.position="bottom",
      axis.title.y=theme_blank(),
      panel.background=theme_blank(),panel.grid.major=theme_blank(),
      panel.grid.minor=theme_blank(),plot.background=theme_blank())
-------------------------------------------------------------------------------------------------------
seg.len plot(1,1)
legend("bottomleft", 
  c("A","B","C"), 
  lwd=3, bty="n",lty=c(1,3,4),
  seg.len=5
)
-------------------------------------------------------------------------------------------------------
cols <- rainbow(nrow(mtcars))
mtcars$car <- rownames(mtcars)

ggplot(mtcars, aes(mpg, disp, colour = car)) + geom_point() +
  scale_colour_manual(limits = mtcars$car, values = cols) +
  guides(colour = guide_legend(ncol = 3))
-------------------------------------------------------------------------------------------------------
%# read file lines
fid = fopen('data.txt', 'rt', 'native', 'UTF-8');
C = textscan(fid, '%s', 'Delimiter','\n');
fclose(fid);
C = C{1};

%# split into labels/data
labels = C(1:2:end);
data = cellfun(@str2num, C(2:2:end), 'UniformOutput',false);
data = cell2mat(data);

%# HACK: MATLAB has issues displaying unicode text
labels = num2str((1:size(data,1))', 'Point %d'); %# you might need to normalize the attributes
%#data = zscore(data);

plot(data');            %'# plot lines
set(gca, 'XTick',1:numDim, 'XGrid','on')
xlabel('Features'), ylabel('Feature value')
title('Parallel Coordinates')
legend(labels)          %# show legend of labels %# parallel coordinates (similar the above)
parallelcoords(data, 'Group',labels)

%# glyph plot (stars)
glyphplot(data, 'obslabels',labels, 'glyph','star') %# glyph plot (Chernoff faces)
glyphplot(data, 'obslabels',labels, 'glyph','face') %# Andrews curves
andrewsplot(data, 'Group',labels)
-------------------------------------------------------------------------------------------------------
library(scales)
i + guides(colour = guide_legend(nrow = 2)
-------------------------------------------------------------------------------------------------------
lines density dat <- read.table(text = "info mean sd
info1 20.84 4.56
info2 29.18 5.41
info3 38.90 6.22
", header = TRUE)

densities <- apply(dat[, -1], 1, function(x) rnorm(n = 1000, mean = x[1], sd = x[2]))
colnames(densities) <- dat$info

plot(0, type = "n", xlim = c(min(densities), max(densities)), ylim = c(0, .2))
for (d in 1:ncol(densities)){
  lines(density(densities[, d]), lty = d)
}
legend("topright", legend=colnames(densities), lty=1:ncol(densities)) library(reshape2)
library(ggplot2)
#Put into long format
densities.m <- melt(densities)
#Plot
ggplot(densities.m, aes(value, linetype = Var2)) + geom_density()
-------------------------------------------------------------------------------------------------------
plot_colors <- c("blue","black", "green", "orange", "pink")
text <- c("Fabricated Metal", "Iron and Steel", "Paper", 
"Beverages", "Tobacco")
plot.new()
par(xpd=TRUE)
legend("center",legend = text, text.width = max(sapply(text, strwidth)),col=plot_colors, lwd=5, cex=1, horiz = TRUE)
par(xpd=FALSE)
-------------------------------------------------------------------------------------------------------
m <- matrix(c(1,2,3,4,5,6,7,7,7),nrow = 3,ncol = 3,byrow = TRUE)

layout(mat = m,heights = c(0.4,0.4,0.2))

for (i in 1:6){
    par(mar = c(2,2,1,1))
    plot(runif(5),runif(5),xlab = "",ylab = "")
}


plot(1, type = "n", axes=FALSE, xlab="", ylab="")
plot_colors <- c("blue","black", "green", "orange", "pink")
legend(x = "top",inset = 0,legend = c("Fabricated Metal", "Iron and Steel", "Paper","Beverages", "Tobacco"), col=plot_colors, lwd=5, cex=.5, horiz = TRUE)
-------------------------------------------------------------------------------------------------------
dat <- data.frame(V1 = 1:6, V2 = c(11613, 6517, 2442, 687, 159, 29))

addMyLegend <- function(data, where = "topright", digits = 3, ...) {
    MEAN <- round(mean(data), digits = digits)
    SD <- round(sd(data), digits = digits)
    legend(where, legend = list(bquote(Mean == .(MEAN)), bquote(SD == .(SD))), ...)
}

plot(dat, type = "h")
addMyLegend(dat$V1, digits = 2, bty = "n") == = ?bquote .( ) foo == .(bar) bar bar bar 1.3 bquote(foo == .(bar)) expression(foo == 1.3) addMyLegend() ?legend legend() ... addMyLegend()
-------------------------------------------------------------------------------------------------------
require(Hmisc) 
myMean <- wtd.mean(dat$V1, dat$V2)
mySD <- sqrt(wtd.var(dat$V1, dat$V2))
plot(dat,main="title",type="h")

L= list( bquote(Mean== .(myMean)), bquote(SD== .(mySD) ) ) 
legend('topright', legend=sapply(L, as.expression))
-------------------------------------------------------------------------------------------------------
# Some toy data
df <- expand.grid(x = factor(seq(1:5)), y = factor(seq(1:5)), KEEP.OUT.ATTRS = FALSE)
df$Count = seq(1:25)

# A plot
library(ggplot2)
p = ggplot(data = df, aes( x = x, y = y, label = Count, size = Count)) + 
   geom_point(colour = NA) +
   geom_text(show_guide = FALSE) +  
   guides(size = guide_legend(override.aes = list(colour = "black", shape = utf8ToInt("N")))) +
   scale_size(range = c(2, 10))

p # Some toy data
df <- expand.grid(x = factor(seq(1:5)), y = factor(seq(1:5)), KEEP.OUT.ATTRS = FALSE)
df$Count = seq(1:25)

# A plot
library(ggplot2)
p = ggplot(data = df, aes( x = x, y = y, label = Count, size = Count)) + 
    geom_text() +
    scale_size(range = c(2, 10))
p

library(grid)
grid.gedit("^key-[-0-9]+$", label = "N")
-------------------------------------------------------------------------------------------------------
1:4 end y for sapply sapply(seq_along(y), function(i) {
   legend(end[i],y[i], name[i], xjust=0, yjust=0.5)
 })
-------------------------------------------------------------------------------------------------------
library(reshape)
test = data.frame(x =  rep(1:3, each = 2),
                  group =  rep(c("Group 1","Group 2"),3),
                  groupcd= rep(c(1,2),3),
                  y=   c(22,8,11,4,7,5)
                  )
colors<-c("red","blue")

#Transform  data to wide format 
test_transposed<-reshape(test, 
                         idvar='x',
                         drop="group",
                         timevar="groupcd", 
                         direction="wide")
colors<-c("red","blue")

#drop x column
test_transposed$x<-NULL

matplot(test_transposed, 
        type = "b",
        ylab="y",
        col=colors,
        main="MATPLOT with groups",
        pch = 1:2)

legend("top", legend=unique(test$group), lty=1:2, col=colors,pch=1:2  )
-------------------------------------------------------------------------------------------------------
exports <- data.frame(100*rbind('Americas'=runif(6),'Asia'=runif(6),'Other'=runif(6)))
colnames(exports) <- 2004:2009
series_we_want <- c(1,2,3)
barplot( as.matrix(exports[series_we_want,]))
legend(x="topleft", legend=rev(rownames(exports)[series_we_want])) exports <- data.frame(100*rbind('Americas'=runif(6),'Asia'=runif(6),'Other'=runif(6)))
colnames(exports) <- 2004:2009
series_we_want <- c(1,2,3)
test_data<-as.matrix(exports[series_we_want])

 barplot( test_data, 
          legend.text=as.character(rev(rownames(exports)[series_we_want])), 
           args.legend = list(x="topleft"))
-------------------------------------------------------------------------------------------------------
inset legend "topright" # Random data to plot:
A <- data.frame(x=rnorm(100, 20, 2), y=rnorm(100, 20, 2))
B <- data.frame(x=rnorm(100, 21, 1), y=rnorm(100, 21, 1))

# Add extra space to right of plot area; change clipping to figure
par(mar=c(5.1, 4.1, 4.1, 8.1), xpd=TRUE)

# Plot both groups
plot(y ~ x, A, ylim=range(c(A$y, B$y)), xlim=range(c(A$x, B$x)), pch=1,
               main="Scatter plot of two groups")
points(y ~ x, B, pch=3)

# Add legend to top right, outside plot region
legend("topright", inset=c(-0.2,0), legend=c("A","B"), pch=c(1,3), title="Group") inset=c(-0.2,0)
-------------------------------------------------------------------------------------------------------
library(scales)
plot_aas_wait_class <- ggplot()+
  geom_area(data=DF_AAS, aes(x = snap_time, y = aas,fill = wait_class),stat = "identity", position = "stack",alpha=.9)+
  scale_fill_brewer(palette="Paired",breaks = sort(levels(DF_AAS$wait_class)))+
  scale_y_continuous(breaks = seq(0, max(DF_AAS$aas)+(max(DF_AAS$aas)*.2), 5))+
  opts(panel.background = theme_rect(colour = "#aaaaaa")) +  
  opts(legend.position = "bottom",legend.direction = "horizontal") + 
 

plot_aas_event <- ggplot()+
  geom_area(data=DF_AAS_EVENT, aes(x = snap_time, y = aas,fill = wait_class_event),stat = "identity", position = "stack")+
  scale_fill_brewer(palette="Paired",breaks = DF_AAS_EVENT$wait_class_event)+
  scale_y_continuous(breaks = seq(0, max(DF_AAS_EVENT$aas)+(max(DF_AAS_EVENT$aas)*.2), 5))+
  opts( panel.background = theme_rect(colour = "#aaaaaa")) +  
  opts(legend.position = "bottom",legend.direction = "horizontal") + 



grid.arrange(arrangeGrob(plot_aas_wait_class, plot_aas_event),heights=c(1/2,1/2),ncol=1) + scale_x_datetime(breaks = date_breaks("2 hours")) geom_rect alpha = 0.25 Inf -Inf geom_rect
-------------------------------------------------------------------------------------------------------
ltext1 <- c(ltext,"emp") # this is not necessary if you already added 
legend("topright",ltext1,bty="n",col=c(cm.colors(6),"black"),pch=c(rep(15,6),-1),lty = c(0,0,0,0,0,0,1));
-------------------------------------------------------------------------------------------------------
legend x <-10:1
y <-11:20
plot(x,y,type="h")
my.legend.size <- legend("topright",c("Series1","Series2","Series3"))
> my.legend.size
$rect
$rect$w
[1] 1.599609

$rect$h
[1] 1.506977

$rect$left
[1] 8.760391

$rect$top
[1] 20.36


$text
$text$x
[1] 9.266641 9.266641 9.266641

$text$y
[1] 19.98326 19.60651 19.22977 #second legend

plot(x,y,type="h")
my.legend.size <-legend("topright",c("Series1","Series2","Series3"))
my.legend.size2 <-legend("right",c("Long series name","Series5","Series6"),plot = FALSE)
legend(x=my.legend.size2$rect$left,y=my.legend.size$rect$top-my.legend.size$rect$h,c("Long series name","Series5","Series6")) bty = "n"
-------------------------------------------------------------------------------------------------------
pdf() Sweave() pdf() pdf("pdfPlot.pdf")
    plot(0.5, 0.5, xlim = c(0,1), ylim = c(0,1))
    legend("bottomright", c("data", "summary", "curve", "conf. region"), pch = c(2,1,NA,NA), lwd = c(NA,NA, 2,1))
dev.off() cairo_pdf() cairo_pdf("cairo_pdfPlot.pdf")
    plot(0.5, 0.5, xlim = c(0,1), ylim = c(0,1))
    legend("bottomright", c("data", "summary", "curve", "conf. region"), pch = c(2,1,NA,NA), lwd = c(NA,NA, 2,1))
dev.off() knitr dev="cairo_pdf" fig=TRUE <<dev="cairo_pdf">>=
...
...
@ library(knitr); knit("myScript.Rnw") Sweave("myScript.Rnw") Sweave() <<results=tex, term=FALSE, echo=FALSE>>=
cairo_pdf("myPlot.pdf", width=5)
    plot(0.5, 0.5, xlim = c(0,1), ylim = c(0,1))
    legend("bottomright", c("data", "summary", "curve", "conf. region"),pch = c(2,1,NA,NA), lwd = c(NA,NA, 2,1))
dev.off()
cat("\\includegraphics{myPlot.pdf}\n\n")
@
-------------------------------------------------------------------------------------------------------
TRUE FALSE . require(ggplot2)
ggplot(dat, aes(FALSE., TRUE., colour = as.factor(d), group = as.factor(d))) + 
  geom_line() colnames(dat)[2:3] <- c("T", "F")

dis <- unique(dat$d)

plot(NA, xlim = c(0, max(dat$F)), ylim = c(0, max(dat$T)))
for (i in seq_along(dis)){
  subdat <- subset(dat, d == dis[i])
  with(subdat, lines(F,T, col = linecols[i]))
}
legend("bottomright", legend=dis, fill=linecols)
-------------------------------------------------------------------------------------------------------
pdf(file="Lplot.pdf")
  plot(mydata.Lest, xlim=c(0,200), ylim=c(0,200), main="L Function", 
          xlab="Distance Between Particles (r)", ylab=expression(paste(L(r))),  
          lty = c(2,1,4), col = c("red", "black","blue"), border = "black"))
  legend(x=165, y=30, c("CSR", "mydata", "mydata.hex")
  plot(mydata.hex.Lest, xlim=c(0,200), ylim=c(0,200), add = TRUE, 
           lty = c(4,2), col = c("blue", "red"))
dev.off()
-------------------------------------------------------------------------------------------------------
matplot #Fake data
x <- data.frame(x = 1:100, y1 = rnorm(100), y2 = runif(100))
#Plot
matplot(x[,1], x[, -1], type="l", lty = 1)
#Everyone needs a little legend love
legend("topright", legend = colnames(x)[-1], fill=seq_along(colnames(x)[-1])) library(ggplot2)
library(reshape2)
#Melt into long format with first column as the id variable
x.m <- melt(x, id.vars = 1)
#Plot it
ggplot(x.m, aes(x, value, colour = variable)) +
  geom_line() +
  theme_bw()
-------------------------------------------------------------------------------------------------------
fill = type scale_fill_manual guides fill = NA guides library(ggplot2)

temp = read.table(text = "
type    name    value
A john  47.6
B john  55.6
C john  57.7
A amy   13.15
B amy   23.1
C amy   24.9
A lily  14.0
B lily  18.1
C lily  21.9
A sam   38.8
B sam   44.8
C sam   45.9
A frank 63.6
B frank 64.4
C frank 64.7
A xia   52.8
B xia   54.1
C xia   56.4
A yan   53.8
B yan   56.1
C yan   58.6", header = TRUE, sep = "")


qplot(type, value, geom="bar", fill=type, data=temp, group=name, facets= .~name, stat="identity") + 
   scale_fill_manual(values = rep("salmon",3), labels = c("A - atype", "B - btype", "C - ctype")) +
   guides(fill = guide_legend(override.aes = list(fill = "white"))) +
   theme_bw() + 
   opts(axis.title.y=theme_text(size=16,angle=90),axis.title.x=theme_text(size=16,angle=0)) + 
   opts(axis.text.x=theme_text(size=10)) + 
   opts(axis.text.y=theme_text(size=14)) + 
   opts(strip.background = theme_rect(colour = 'steelblue', fill = 'white', size = 2)) + 
   opts(legend.title=theme_blank()) + 
   opts(legend.position="top") +
   opts(legend.key = theme_rect(colour = NA))
-------------------------------------------------------------------------------------------------------
1 - plnorm() plnorm() ## Function to plot aft data
plot.aft <- function(x, legend = c("ICU Patients", "Non-ICU Patients"),
    xlab = "Days since Infection", ylab="Percent Surviving", lwd = 2,
    col = c("red", "black"), at = c(0, 20, 40, 60, 80, 100, 120, 140, 160, 180),
        ...)
{
    plot(x[, 1], x[, 2], type = "l", ylim = c(0, 1), xaxt = "n", 
            xlab = xlab, ylab = ylab, col = col[2], lwd = 2, ...)
    axis(1, at = at)
    lines(x[, 1], x[, 3], col = col[1], lwd=2)
    legend("topright", legend = legend, lwd = lwd, col = col)
} ## Specify coefficients, variables, and linear models
beta0 <- 5.00
beta1 <- -0.500
icu <- c(0, 1)
t <- seq(0, 180)
linmod <- beta0 + (beta1 * icu)
names(linmod) <- c("unexposed", "exposed")

## Generate s(t) from exponential AFT model
s0.exp <- dexp(exp(-linmod["unexposed"]) * t)
s1.exp <- dexp(exp(-linmod["exposed"]) * t)

## Generate s(t) from lognormal AFT model
s0.lnorm <- 1 - plnorm(t, meanlog = linmod["unexposed"])
s1.lnorm <- 1 - plnorm(t, meanlog = linmod["exposed"]) ## Plot survival
plot.aft(data.frame(t, s0.exp, s1.exp), main = "Exponential model")
plot.aft(data.frame(t, s0.lnorm, s1.lnorm), main = "Log-normal model") plnorm(t, meanlog = linmod["exposed"]) pnorm((log(t) - linmod["exposed"]) / 1)
-------------------------------------------------------------------------------------------------------
plot(...)
lines(...)
grid(...)
legend(...) # legend has to be the last command!
-------------------------------------------------------------------------------------------------------
legend legend("topleft", col=2:3, legend=c("x", "y"), lty=1) ?legend
-------------------------------------------------------------------------------------------------------
guide_legend() nrow ncol library(ggplot2)

q <- ggplot(diamonds, aes(x = table, fill = clarity)) +
geom_histogram() +
scale_y_continuous()

q + guides(fill = guide_legend(nrow = 4, title.hjust = 0.4,
title.theme = theme_text(size = 12, face = "bold"))) +
xlim(45, 75)
-------------------------------------------------------------------------------------------------------
plot <- ggplot(diamond.data, aes(carat, price, colour = clarity, shape = cut)) +
  geom_point() + opts(legend.position = "top")

plot + guides(colour = guide_legend(order = 1), 
              shape = guide_legend(order = 2)) plot + guides(colour = guide_legend(order = 2), 
              shape = guide_legend(order = 1))
-------------------------------------------------------------------------------------------------------
guides(colour = guide_legend(override.aes = list(shape = NA)))
-------------------------------------------------------------------------------------------------------
names.arg axisnames=TRUE las=1 fill col pch=0.8 par(las=1)
bnames <- c(3,4,5,6,6,7,10,11) #listed for informational purposes, same as jd2c$
plot<-barplot(tab, beside=TRUE, axisnames=TRUE,
              main = 'Time Spent Left vs. Right',
              sub = 'Female 2c', xlab= 'Days After Entry',
              ylab = 'Proportion of Time Spent',
              col=c('blue', 'red'), ylim = c(0,1),
              names.arg=bnames)
legend('topleft', cex=1,  c('Left' , 'Right'), fill=c('blue', 'red'))
-------------------------------------------------------------------------------------------------------
names.arg barplot plot<-barplot(tab, beside=TRUE, axisnames=FALSE, main = 'Time Spent Left vs. Right', sub = 'Female 2c', xlab= 'Days After Entry', ylab = 'Proportion of Time Spent', col=c('blue', 'red'), ylim = c(0,1))
legend('topleft', .8,  c('Left' , 'Right'), pch=c(.8), col=c('blue', 'red'))
names.arg = jd2c$d.in.p plot<-barplot(tab, beside=TRUE, axisnames=FALSE, main = 'Time Spent Left vs. Right', sub = 'Female 2c', xlab= 'Days After Entry', ylab = 'Proportion of Time Spent', col=c('blue', 'red'), ylim = c(0,1), names.arg = jd2c$d.in.p)
legend('topleft', .8,  c('Left' , 'Right'), pch=c(.8), col=c('blue', 'red')) axisnames=TRUE
-------------------------------------------------------------------------------------------------------
qplot(df$Site,data=df,weight=df$Count,geom="histogram", fill=df$Group, ylim = c(0,16)) + 
  xlab("Sites") + 
  ylab("Counts") + 
  scale_fill_hue(h=c(0,360), l=70, c=70,name = "Emergent Groups") +
  guides(fill = guide_legend(reverse = TRUE)) # reorder the groups
df$Group <- factor(df$Group , 
                   levels=levels(df$Group)[order(levels(df$Group), decreasing = TRUE)])

qplot(df$Site,data=df,weight=df$Count,geom="histogram", fill=df$Group, ylim = c(0,16)) + 
  xlab("Sites") + 
  ylab("Counts") + 
  scale_fill_hue(h=c(0,360), l=70, c=70,name = "Emergent Groups") +
  guides(fill = guide_legend(reverse = TRUE)) # reorder the sites
df$Site <- factor(df$Site, 
                  levels = levels(df$Site)[order(aggregate(Count ~ Site, data = df, sum)$Count, 
                                                 decreasing = TRUE)])
# reorder the groups
df$Group <- factor(df$Group , 
                   levels=levels(df$Group)[order(levels(df$Group), decreasing = TRUE)])

qplot(df$Site,data=df,weight=df$Count,geom="histogram", fill=df$Group, ylim = c(0,16)) + 
  xlab("Sites") + 
  ylab("Counts") + 
  scale_fill_hue(h=c(0,360), l=70, c=70,name = "Emergent Groups") +
  guides(fill = guide_legend(reverse = TRUE))
-------------------------------------------------------------------------------------------------------
color_foo <- colorRampPalette(c('lightblue','darkblue'))
colors <- color_foo(3)

plot(range(data.df[,3]), range(data.df[,4]),
        xlab="Axis 1",ylab="Axis 2",type = "n")
points(data.df$Axis1,data.df$Axis2,
        pch=c(3,4)[data.df$Plant],
        col = colors[data.df$Type])
legend("topright",legend=c("Plant1","Plant2"),pch = 3:4)
legend("bottomright",legend=c("Type1","Type2","Type3"),pch = 20,col = colors)
-------------------------------------------------------------------------------------------------------
require(gplots)
require(RColorBrewer)

## Some fake data for you
data_matrix <- matrix(runif(100, 0, 3.5), 10, 10)

## The colors you specified.
myCol <- c("blue", "green", "yellow", "orange", "red")
## Defining breaks for the color scale
myBreaks <- c(0, .3, 1, 1.3, 3, 3.5)

hm <- heatmap.2(data_matrix, scale="none", Rowv=NA, Colv=NA,
                col = myCol, ## using your colors
                breaks = myBreaks, ## using your breaks
                dendrogram = "none",  ## to suppress warnings
                margins=c(5,5), cexRow=0.5, cexCol=1.0, key=TRUE, keysize=1.5,
                trace="none") legend hm <- heatmap.2(data_matrix, scale="none", Rowv=NA, Colv=NA,
                col = myCol, ## using your colors
                breaks = myBreaks, ## using your breaks
                dendrogram = "none",  ## to suppress warnings
                margins=c(5,5), cexRow=0.5, cexCol=1.0, key=FALSE,
                trace="none")
legend("left", fill = myCol,legend = c("0 to .3", "0.3 to 1", "1 to 1.3", "1.3 to 3", ">3"))
-------------------------------------------------------------------------------------------------------
plot.new()
    d <- melt(as.matrix(data.frame(y1=1/(1:10),y2=1/(10:1))))
    ggplot(d, aes(x=Var1, y=value,fill=Var2)) + 
    geom_bar(stat="identity",position='dodge') legend('top',paste("sums:",tapply(d$value,d$Var2,sum)))
-------------------------------------------------------------------------------------------------------
dat <- data.frame(xvals=1:100,
                  y=matrix(rnorm(600),ncol=6)) loess predict formulae <- lapply(names(dat)[-1],
                   function(yvar) as.formula(paste(yvar,"xvals",sep="~")))
loessfits <- lapply(formulae,loess,data=dat)

xl <- with(dat,seq(min(xvals),max(xvals), length.out=1000))
pvals <- do.call(cbind,lapply(loessfits,predict,newdata=data.frame(xvals=xl))) ?par ## set box type (open), horizontal tick labels, axis label and title size
par(bty="l",las=1,cex.main=2,cex.lab=2) cvec <- c("gray","pink","red","cyan","black","green")
lvec <- 1:6 matplot(xl,pvals,type="l",col=cvec,lty=lvec,
        xlab='X label', ylab='Y label')    
legend("topright", paste0("L",1:6), pch=1, lty=lvec,col=cvec, inset = .02)
-------------------------------------------------------------------------------------------------------
my_hist <- ggplot(diamonds, aes(clarity, fill=cut)) + geom_bar()

#create inset table
my_table <- tableGrob(head(diamonds)[,1:3], gpar.coretext = gpar(fontsize=8), gpar.coltext=gpar(fontsize=8), gpar.rowtext=gpar(fontsize=8))

#Extract Legend
g_legend <- function(a.gplot){
  tmp <- ggplot_gtable(ggplot_build(a.gplot))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)}

legend <- g_legend(my_hist)

#Create the viewports, push them, draw and go up
grid.newpage()
vp1 <- viewport(width = 0.75, height = 1, x = 0.375, y = .5)
vpleg <- viewport(width = 0.25, height = 0.5, x = 0.85, y = 0.75)
subvp <- viewport(width = 0.3, height = 0.3, x = 0.85, y = 0.25)
print(my_hist + opts(legend.position = "none"), vp = vp1)
upViewport(0)
pushViewport(vpleg)
grid.draw(legend)
#Make the new viewport active and draw
upViewport(0)
pushViewport(subvp)
grid.draw(my_table)
-------------------------------------------------------------------------------------------------------
# Load required packages
library(ggplot2)
library(reshape2)

    # Read in data
df = read.table(text = "
activity                         yes    no  dontknow
Social.events                     27    3   3
Academic.skills.workshops         23    5   8
Summer.research                   22    7   7
Research.fellowship               20    6   9
Travel.grants                     18    8   7
Resume.preparation                17    4   12
RAs                               14    11  8
Faculty.preparation               13    8   11
Job.interview.skills              11    9   12
Preparation.of.manuscripts        10    8   14
Courses.in.other.campuses          5    11  15
Teaching.fellowships               4    14  16
TAs                                3    15  15
Access.to.labs.in.other.campuses   3    11  18
Interdisciplinay.research          2    11  18
Interdepartamental.projects        1    12  19", header = TRUE, sep = "")

    # Melt the data frame
dfm = melt(df, id.vars=c("activity"), measure.vars=c("yes","no","dontknow"),
    variable.name="haveused", value.name="responses")

    # Reorder the levels of activity
dfm$activity = factor(dfm$activity, levels = df$activity)

    # Draw the plot
ggplot(dfm, aes(x=activity, y=responses)) + 
    geom_bar(aes(fill=haveused)) +
    opts(axis.text.x = theme_text(angle = 90, hjust = 1)) +   # Rotate tick mark labels
    guides(fill = guide_legend(reverse = TRUE))     # Reverse the order of the colours in the legend # Get the positions of the labels
library(plyr)
dfm = ddply(dfm, .(activity), transform, pos = cumsum(responses) - 0.5*responses)

    # Draw the plot
ggplot(dfm, aes(x=activity, y=responses)) + 
geom_bar(aes(fill=haveused)) +
opts(axis.text.x = theme_text(angle = 90, hjust = 1)) +
guides(fill = guide_legend(reverse = TRUE)) +
geom_text(aes(label = responses, y = pos), size = 3)  # labels inside the bar segments
-------------------------------------------------------------------------------------------------------
legend() cols <- c("orange","forestgreen")
legend("topright", legend = c("North"),fill = cols, border = cols, bty = "n") 
stats:::plot.dendrogram() text() stats:::plot.dendrogram() if (!is.null(et <- attr(x, "edgetext"))) {
    my <- mean(hgt, yTop)
    if (horiz) 
        text(my, x0, et)
    else text(x0, my, et)
} ns::: ns
-------------------------------------------------------------------------------------------------------
pdf sim_bayes <- function(p=0.5, N=10, y_lim=15, prior_a=1, prior_b=1) {
    success <- 0
    for (i in 1:N) {
        pdf(paste("posterior",i,".pdf",sep=""), height=4, width=6.5)

        if (runif(1,0,1) <= p)
            success<-success + 1

        # Start a new plot.
        curve(dbeta(x,prior_a,prior_b), lty=2,
              xlim=c(0,1), ylim=c(0,y_lim), xlab='p', ylab='Posterior Density')
        # Update plot.
        curve(dbeta(x,success+prior_a, (i-success) + prior_b), add=TRUE)

        legend('topright',legend=c('Prior','Updated Posteriors','Final Posterior'),lty=c(2,1,1), col=c('black','black','red'))

        dev.off()
    }
}

# `x` had no visible binding in your implementation, so I took the following
# from the `dbeta` documentation example.
x <- seq(0, 1, length=21)
sim_bayes()
-------------------------------------------------------------------------------------------------------
add=TRUE sim_bayes<-function(p=0.5,N=10,y_lim=15,prior_a=1,prior_b=1)
{
   print(paste("The prior expectation of p is ",prior_a/(prior_a+prior_b)))
   success<-0
   curve(dbeta(x,prior_a,prior_b),xlim=c(0,1),ylim=c(0,y_lim),xlab='p',ylab='Posterior Density',lty=2)
   legend('topright',legend=c('Prior','Updated Posteriors','Final Posterior'),lty=c(2,1,1),col=c('black','black','red'))

  for(i in 1:N)
     {

        if(runif(1,0,1)<=p) success<-success+1 #this is where we see if there is a "success"

      curve(dbeta(x,success+prior_a,(i-success)+prior_b)) #plot updated
      }
curve(dbeta(x,success+prior_a,(i-success)+prior_b),col='red',lwd=1.5) #plot final posterior
} sim_bayes(p=0.6,N=90,prior_a=1,prior_b=1)
-------------------------------------------------------------------------------------------------------
library(ggplot2); library(gridExtra)
my_hist<-ggplot(diamonds, aes(clarity, fill=cut)) + geom_bar() 

#create inset table 
my_table<- tableGrob(head(diamonds)[,1:3], 
    gpar.coretext =gpar(fontsize=8), gpar.coltext=gpar(fontsize=8),  
    gpar.rowtext=gpar(fontsize=8)) 

#Extract Legend 
g_legend<-function(a.gplot){ 
  tmp <- ggplot_gtable(ggplot_build(a.gplot)) 
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box") 
  legend <- tmp$grobs[[leg]] 
  return(legend)} 

legend <- g_legend(my_hist) 
grid.draw(legend)
-------------------------------------------------------------------------------------------------------
set.seed(1410)
df<-data.frame(
  "site.x"=c(rep("a",4),rep("b",4),rep("c",4),rep("d",4)),
  "site.y"=c(rep(c("e","f","g","h"),4)),
  "bond.strength"=sample(1:100,16, replace=TRUE), stringsAsFactors=FALSE)


Placement <- data.frame(site=c(unique(df$site.x),unique(df$site.y)), x = NA, y = NA, stringsAsFactors=FALSE)

Placement$x <- ifelse(Placement$site %in% unique(df$site.x), 0, 1)

Placement$y[Placement$x==0] <- seq(1,0,length=sum(Placement$x==0))
Placement$y[Placement$x==1] <- seq(1,0,length=sum(Placement$x==1))

cols <- rep("red",nrow(df))
cols[df$bond.strength < 33] <- "green"
cols[df$bond.strength >= 33 & df$bond.strength < 66] <- "yellow"

# Empty plot:
par(mar=c(0,0,0,0))
plot(1,type="n",xlim=c(-0.2,1.6),ylim=c(0,1),bty="n",axes=FALSE,xlab="",ylab="")
abline(v=c(0,1))
text(Placement$x + ifelse(Placement$x==0,-0.1,0.1),Placement$y,Placement$site)

for (i in 1:nrow(df))
{
  lines(c(0,1),Placement$y[c(match(df$site.x[i],Placement$site),match(df$site.y[i],Placement$site))],col=cols[i],lwd=2)
}

legend("right",col=c("green","yellow","red"),lty=1,lwd=2,legend=c("0-33","33-66","66-100"),title="bondstrength",cex=1.5,bty="n")
-------------------------------------------------------------------------------------------------------
mx=12
 my=12
 par(mar = c(mx,my, 4, 2) + 0.1)
 plot(c(1,4),c(1,4),type="n",main="title",xlab="site.x",ylab="ylab")
 rect(xleft,ybottom,xright,ytop,col=c("blue","red","green"))
 text(par()$usr[1]-0.5,y.label.position,y.label,xpd=TRUE,adj=1)
 text(y=par()$usr[3]-0.5,x=x.label.position,x.label,xpd=TRUE,adj=1,srt=90) mx my xpd=TRUE par(xpd=TRUE)
 legend(locator(1),legend=c("Species A","Species B","Species C"),fill=c("blue", "red", "green")) locator(1) list(x=-0.7,y=0.6) ggplot
-------------------------------------------------------------------------------------------------------
par("mfg") par(mai=c(2.5, 2.25, 0.82, 0.42), mgp=c(9, 1, 0))
plot(c(1,4), c(1,4), xaxp=c(1,4,3), yaxp=c(1,4,3), type="n", 
  main="title", xlab="site.x", ylab="ylab")
rect(xleft, ybottom, xright, ytop, col=c("blue","red","green"))
axis(1, at=x.label.position, labels=x.label, las=2)
axis(2, at=y.label.position, labels=y.label, las=2)
par(xpd=TRUE)
legend(x=0.25, y=0.75, legend=c("Text", "Text", "Text"),fill=c("blue", "red", "green"),title="Legend") ggplot2
-------------------------------------------------------------------------------------------------------
viewport layout() rescale asp plot.igraph() leg t8g legend <- g_legend(leg)
vpleg <- viewport(width = 0.1, height = 0.1, x=0.85,y=0.5)
layout(matrix(c(1,2),1,2,byrow=T),widths=c(3,1))
plot(t8g,edge.width=1,edge.arrow.size=0.1,vertex.label.cex=0.2,main="b2_top10")
pushViewport(vpleg)
grid.draw(legend)
-------------------------------------------------------------------------------------------------------
data <- data.frame(type = sample(letters[1:3],20,replace=T),
                   x = runif(20),
                   y = runif(20))
dict <- data.frame(type = letters[1:4],
                   color = c("red","green","blue","black"))
plot(data$x, data$y, col = merge(data,dict)$color)
legend("topleft",legend=dict$type, col=dict$color, pch=1) data_dict <- merge(data,dict)
plot(y~x, col=color, data=data_dict, pch=as.vector(type))
legend("topleft",legend=unique(data_dict$type), col=unique(data_dict$color), pch=1)
-------------------------------------------------------------------------------------------------------
guides(colour = guide_legend(nrow = 2))
-------------------------------------------------------------------------------------------------------
i <- seq(1 : length(y))
m <- cumsum(y)/i

se_y <- sqrt((1/(i-1)*cumsum(y^2) - i/(i-1)*m^2))

error <- qnorm(0.975)*se_y/sqrt(i)
lower <- m - error
upper <- m + error

# equivalent (slightly slower) methods for getting the std. errors

# method2:
se_2 <- rep(NA, length(y))
for (n in 1:length(y))  {
  se_2[n] <- sd(y[1:n])
}
# method3:
se_3 <- sapply(1:length(y), FUN= function(x) sd(y[1:x])) # plotting means and ci's against sample size (= up to 10000)
plot(x=i, y=m, xlab="Number of iterations (sample size)", 
title("Convergence of the ENVP's mean"), 
ylab="E[y] estimates and 95% CI's (EUR millions)", cex=0.4, ylim=c(2620, 2665))
lines(lower, col="gold")
lines(upper, col="gold")
legend("bottomright", legend=c("envp's mean", "95% ci"),cex=0.8, col=c("black", "gold"), lwd=2, lty=1, bty="n")

dev.copy(tiff, file="mc_envp.tiff", height=6, width=6, units="in", res=200)
dev.off(); dev.off()
windows.options(reset=TRUE)
-------------------------------------------------------------------------------------------------------
par(xpd=NA) ?par xpd clip quartz(title="PCoA",12,6)
par(mfrow=c(1,2),oma=c(5,0,0,0),xpd=NA)

plot(1:3,4:6,main="plot 1")

plot(1:3,4:6,main="plot 2")
legend(-0.5,3.5,ncol=3,c("0-1 km","1-5 km","outside barrier"), fill=c("green","orange","red"), title="Fetch")
-------------------------------------------------------------------------------------------------------
par=mfrow(...) layout() layout(matrix(c(1,2,3,3), ncol=2, byrow=TRUE), heights=c(4, 1))

par(mai=rep(0.5, 4))
plot(1:3,4:6,main="plot 1")
plot(1:3,4:6,main="plot 2")

par(mai=c(0,0,0,0))
plot.new()
legend(x="center", ncol=3,legend=c("0-1 km","1-5 km","outside barrier"),fill=c("green","orange","red"), title="Fetch")
-------------------------------------------------------------------------------------------------------
require(vegan)
data(dune) dij <- vegdist(dune) ## bray curtis dissimilarity
clu <- hclust(dij, method = "average")
grp <- cutree(clu, 3) grp R> grp
 2 13  4 16  6  1  8  5 17 15 10 11  9 18  3 20 14 19 12  7 
 1  1  1  2  1  1  1  1  3  2  1  1  1  1  1  2  2  3  1  1 set.seed(2) ## setting a seed to make this reproducible
ord <- metaMDS(dune) col <- c("red2", "green4", "mediumblue") grp col col grp R> col[grp]
 [1] "red2"       "red2"       "red2"       "green4"     "red2"      
 [6] "red2"       "red2"       "red2"       "mediumblue" "green4"    
[11] "red2"       "red2"       "red2"       "red2"       "red2"      
[16] "green4"     "green4"     "mediumblue" "red2"       "red2" plot() plot(ord, type = "n", display = "sites")
points(ord, col = col[grp], bg = col[grp], pch = 21)
legend("topright", legend = paste("Cluster", 1:3),col = col, pt.bg = col, bty = "n", pch = 21) ordihull() ordihull(ord, groups = grp, display = "sites") plot() points()
-------------------------------------------------------------------------------------------------------
quantile() rug() set.seed(1)
X <- rnorm(200)
boxplot(X, yaxt = "n")

## compute the required quantiles
qntl <- quantile(X, probs = c(0.85, 0.90))

## add them as a rgu plot to the left hand side
rug(qntl, side = 2, col = "blue", lwd = 2)

## add the box and axes
axis(2)
box() str() set.seed(1) ## make reproducible
HWD <- data.frame(Hour = rep(0:23, 10),
                  Houston_Load = rnorm(24*10)) Hour Hour quantile() quants <- sapply(split(HWD$Houston_Load, list(HWD$Hour)),
                 quantile, probs = c(0.85, 0.9)) R> quants <- sapply(split(HWD$Houston_Load, list(HWD$Hour)),
+                  quantile, probs = c(0.85, 0.9))
R> quants
            0         1        2         3         4         5        6
85% 0.3576510 0.8633506 1.581443 0.2264709 0.4164411 0.2864026 1.053742
90% 0.6116363 0.9273008 2.109248 0.4218297 0.5554147 0.4474140 1.366114
            7         8        9       10        11        12       13       14
85% 0.5352211 0.5175485 1.790593 1.394988 0.7280584 0.8578999 1.437778 1.087101
90% 0.8625322 0.5969672 1.830352 1.519262 0.9399476 1.1401877 1.763725 1.102516
           15        16        17        18       19        20       21
85% 0.6855288 0.4874499 0.5493679 0.9754414 1.095362 0.7936225 1.824002
90% 0.8737872 0.6121487 0.6078405 1.0990935 1.233637 0.9431199 2.175961
          22        23
85% 1.058648 0.6950166
90% 1.145783 0.8436541 boxplot(Houston_Load ~ Hour, data = HWD, axes = FALSE)
xlocs <- 1:24 ## where to draw marks
tickl <- 0.15 ## length of marks used
for(i in seq_len(ncol(quants))) {
    segments(x0 = rep(xlocs[i] - 0.15, 2), y0 = quants[, i],
             x1 = rep(xlocs[i] + 0.15, 2), y1 = quants[, i],
             col = c("red", "blue"), lwd = 2)
}
title(xlab = "Hour", ylab = "Houston Load")
axis(1, at = xlocs, labels = xlocs - 1)
axis(2)
box()
legend("bottomleft", legend = paste(c("0.85", "0.90"), "quantile"),bty = "n", lty = "solid", lwd = 2, col = c("red", "blue"))
-------------------------------------------------------------------------------------------------------
library(decon) # for DeconPdf
library(deamer) # for deamerKE

set.seed(12345)
shape=5; scale=1; mu=0; sd=0.2

x <- rweibull(5000, shape=shape, scale=scale)
noise <- rnorm(5000, mean=mu, sd=sd)
y=x+noise
curve(dweibull(x,shape,scale),lwd=2, from = 0, to = 2)

est <- deamerKE(y, noise.type="Gaussian", mu=mu, sigma=sd, from=0, to=2)
lines(est)

estDecon <- DeconPdf(y, sd, error="normal", fft=TRUE)
lines(estDecon, lty=2)

legend('topright', lty=c(1,1,2), lwd=c(2,1,1), legend=c("true", "deamerKE", "DeconPdf"))
-------------------------------------------------------------------------------------------------------
ggplot(df, aes(x=x, y=y, linetype=fac)) +
  geom_line() +
  geom_segment(aes(x=2, y=7, xend=7, yend=7), colour="red") +
  scale_linetype_discrete(guide=guide_legend(override.aes=aes(colour="blue")))
-------------------------------------------------------------------------------------------------------
p + guides(fill = guide_legend(override.aes = list(shape = 21)))
-------------------------------------------------------------------------------------------------------
lty=NULL plot.new()
legend("top",ncol=1,c("Mound reef (M)","Spur and Groove (SG)),pch=3:8, title="Reef Types",cex=1,lwd=2, lty=NULL) lwd=2 plot.new()
legend("top",ncol=1,c("Mound reef (M)","Spur and Groove (SG)"), pch=3:8, title="Reef Types",cex=1)
-------------------------------------------------------------------------------------------------------
lwd=2 legend() lwd=
-------------------------------------------------------------------------------------------------------
library(beeswarm)
  beeswarm(time_survival ~ event_survival, data = breast,
    method = 'smile',
    pch = 16, pwcol = as.numeric(ER),
    xlab = '', ylab = 'Follow-up time (months)',
    labels = c('Censored', 'Metastasis'))
  legend('topright', legend = levels(breast$ER)title = 'ER', pch = 16, col = 1:2)
-------------------------------------------------------------------------------------------------------
grob grid.arrange library(gridExtra)
g_legend<-function(a.gplot){
    tmp <- ggplot_gtable(ggplot_build(a.gplot))
    leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
    legend <- tmp$grobs[[leg]]
    legend
}

legend <- g_legend(plot1)

grid.arrange(legend, plot1+ theme(legend.position = 'none'), 
    ncol=2, nrow=1, widths=c(1/6,5/6)) g_legend
-------------------------------------------------------------------------------------------------------
matplot matplot ?matplot ?par # Generate data
categories <- c("Entertainment", "Games", "Health", "Personal Finance",
    "Shopping", "Music", "USSites", "Porn")
colors <- c("green", "blue", "cyan", "yellow", "magenta", "orange",
    "red", "black")
markers <- 1:8
pt <- matrix(runif(length(categories)*23), length(categories), 23)

# Plot
matplot(1:23, t(pt), type="l", col=colors, lty=1, pch=markers,
        bty="n", las=1, main="Categorical Percent over Time")
legend("topright", col=colors, categories, bg="white", lwd=1, pch=markers)
-------------------------------------------------------------------------------------------------------
period.apply() endpoints() library(zoo)                                # for zoo objects
library(xts)                                # for period.apply

gcdata <- read.table("http://bernd.eckenfels.net/view/gc1001.ygc.csv",
                     header=TRUE, sep=",", dec=".")
timestamps <- gcdata$Timestamp + 
              as.POSIXct(strptime("2012-01-01 00:00:00", 
                         format="%Y-%m-%d %H:%M:%S"))
gcdatazoo <- zoo(gcdata[-1], order.by=timestamps)    # as zoo object zoo plotAreaCorridor <- function(x, y, col.poly1="lightgray", col.poly2="gray",...) {
    x.pol <- c(x, rev(x), x[1])
    y.pol <- c(y[,1], rev(y[,5]),y[,1][1])
    plot(x, y[,6]+1, type="n", ...) 
    polygon(x.pol, y.pol, col=col.poly1, lty=0)

    x.pol <- c(x, rev(x), x[1])
    y.pol <- c(y[,2], rev(y[,4]), y[,1][1])
    polygon(x.pol, y.pol, col=col.poly2, lty=0)

    lines(x, y[,3], col="blue") # median
    lines(x, y[,6], col="red")  # max

    invisible(NULL)
} agg <- period.apply(gcdatazoo[,"Pause.s."],               # to which data
                    INDEX=endpoints(gcdatazoo, "hours", k=2), # every 2 hours
                    FUN=function(x) quantile(x,               # what fun.
                                             probs=c(5,20,50,80,95,100)/100)) 

#v99 = q99(gcdata$Pause.s.)        # what is q99 ?
v99 <- mean(agg[,5])                  # mean of 95-th percentile?
plotAreaCorridor(index(agg),          # use time index as x axis
                 coredata(agg),       # and matrix part of zoo object as data
                 ylim=c(0,max(agg[,5])*1.5),
                 ylab="Quantiles of GC events",
                 main="NewPar Collection Activity")
abline(h=median(gcdatazoo[,"Pause.s."]), col="lightblue")
abline(h=v99, col="grey")
labeltxt <- paste("99%=",round(v99,digits=3),"s n=", nrow(gcdatazoo),sep="")
text(x=index(agg)[20], y=1.5*v99, labeltxt, col="grey", pos=3)  # or legend()
-------------------------------------------------------------------------------------------------------
library('ggplot2')
library('plyr')
library('RColorBrewer')
library(scales)


label_positions<- function(x) {
  n<-length(x)
  wynik<-numeric(n)
  for (i in 1:n){
    if (i==1) {
      wynik[i]<-0+x[i]/2
    }
    else {
      wynik[i]<-x[i]-(x[i]-x[i-1])/2
    }
  }
  return(wynik)
}

exam1<-ddply(example,.(GroupingVar,FacetVar,VarOfInterest), 'nrow')
exam1.1<-ddply(example,.(GroupingVar,FacetVar),summarise, sr=mean(as.numeric(VarOfInterest),na.rm=T),
               odch=sd(as.numeric(VarOfInterest,na.rm=T)))

exam1<-merge(exam1,exam1.1,by.x=c('GroupingVar','FacetVar'),by.y=c('GroupingVar','FacetVar'))

names(exam1)[4]<-'Count'

exam2<-mutate(exam1,cumul=ave(Count,list(GroupingVar,FacetVar),FUN=cumsum),
              N=ave(cumul, list(GroupingVar,FacetVar),FUN=max),
              CumSumPercent=cumul/N*100,
              Freq=Count/N*100)


exam2<-mutate(exam2,cfrq = ave(CumSumPercent, list(GroupingVar,FacetVar), FUN = label_positions))
exam2$XLabel<-paste(exam2$GroupingVar,' (N=',exam2$N,')',sep='')
exam2$PosMean<-105

p<-ggplot(exam2, aes(x = Etykieta, y = Freq, fill = VarOfInterest)) +
  geom_bar(stat = 'identity',colour="black") +
  labs (x = "", y = "Percentage", fill=" ") + 
  scale_fill_brewer(name="Rating", palette="Greens", breaks = rev(levels(exam2$VarOfInterest))) +
  geom_text(aes(y = cfrq, label=paste(sprintf("%.01f",Freq), "%", sep='')), size=5) +
  geom_text(aes(y=PosMean,label=paste(sprintf("%.02f",sr),' (',sprintf("%.02f",odch),')',sep='')),size=5)+
                      facet_wrap(~FacetVar,ncol=1)  +
                       coord_flip() + ylab('Procent odpowiedzi') + 
  guides(fill=guide_legend(title=NULL)) + theme_bw()  + 
  theme(legend.position="bottom",strip.text.x=element_text(size=15,face='bold'),
        axis.text.x =element_text(size=12,face='bold'), axis.text.y =element_text(size=12,face='bold'),
        axis.title.x=element_text(size=15,face='bold'), axis.title.y=element_text(size=15,face='bold'),
        strip.background=element_rect(colour='black'))

plot(p)
-------------------------------------------------------------------------------------------------------
library(scales)
ggplot(data, aes(x = x, y = y)) +
          geom_point(aes(size = Rank, shape = Quantified)) +
          scale_shape_manual("Quantified", labels = c("Yes", "No"), values = c(1, 4)) + 
          guides(size = guide_legend(override.aes = list(shape = 1)))
-------------------------------------------------------------------------------------------------------
par(cex=.64) op <- par(cex=.64)  # this fix the legend size for all plots
plot(x=1:4,y=1:4)
legend("bottom",legend = c("a","b","c","d"),horiz=TRUE,text.font=2) # no need to set cex anymore
plot(x=1:2,y=1:2)
legend("bottom",legend = c("a","b"),horiz=TRUE,text.font=2)
par(op) # At end of plotting, reset to previous settings
-------------------------------------------------------------------------------------------------------
color=dat3$cols ggplot(dat3, aes(x=variable,  y=value, fill=grouping.var)) + 
  geom_bar(position="dodge", stat="identity")  +
  coord_flip() + theme_bw() + 
  theme(legend.position="top", legend.background = element_rect(color="white"),
        panel.grid.major=element_blank(),panel.grid.minor=element_blank(),
        legend.title=element_blank(), axis.ticks.y = element_blank(), 
        axis.text.y = element_blank()) +
          ylab("") +  xlab("") + facet_wrap(~variable, ncol=2, scales = "free_x") +
          scale_fill_manual(values=c("#0000FF", "#FF0000"),
                            guide = guide_legend(reverse=TRUE))+
geom_text(aes(label = labs,  y = loc, x = variable),
          size = 5, position = position_dodge(width=0.9))
-------------------------------------------------------------------------------------------------------
legend("bottomleft", legend = paste("Group", 1:7), pch=1, col=1:7) y legend() 0 -200 200 ?legend
-------------------------------------------------------------------------------------------------------
mydf$Labels = substr(mydf$Prod, 1, 2)
f = factor(mydf$Labels)
l = levels(f)
plot(mydf$Date, mydf$Avg, xlab="Date", ylab="Avg", col=f)
legend("topright", legend = l, fill = 1:length(l), title = "Prods")
-------------------------------------------------------------------------------------------------------
plot.stacked plot.stacked <- function(x,y, ylab="", xlab="", ncol=1, xlim=range(x, na.rm=T), ylim=c(0, 1.2*max(rowSums(y), na.rm=T)), border = NULL, col=rainbow(length(y[1,]))){

    plot(x,y[,1], ylab=ylab, xlab=xlab, ylim=ylim, xaxs="i", yaxs="i", xlim=xlim, t="n")
    bottom=0*y[,1]
    for(i in 1:length(y[1,])){
        top=rowSums(as.matrix(y[,1:i]))
        polygon(c(x, rev(x)), c(top, rev(bottom)), border=border, col=col[i])
        bottom=top
    }
    abline(h=seq(0,200000, 10000), lty=3, col="grey")
    legend("topleft", rev(colnames(y)), ncol=ncol, inset = 0, fill=rev(col), bty="0", bg="white", cex=0.8, col=col)
    box()
} set.seed(1)
m <- 500
n <- 15
x <- seq(m)
y <- matrix(0, nrow=m, ncol=n)
colnames(y) <- seq(n)
for(i in seq(ncol(y))){
    mu <- runif(1, min=0.25*m, max=0.75*m)
    SD <- runif(1, min=5, max=30)
    TMP <- rnorm(1000, mean=mu, sd=SD)
    HIST <- hist(TMP, breaks=c(0,x), plot=FALSE)
    fit <- smooth.spline(HIST$counts ~ HIST$mids)
    y[,i] <- fit$y
}

    plot.stacked(x,y) plot.stream library(devtools)
source_url('https://gist.github.com/menugget/7864454/raw/f698da873766347d837865eecfa726cdf52a6c40/plot.stream.4.R')

set.seed(1)
m <- 500
n <- 50
x <- seq(m)
y <- matrix(0, nrow=m, ncol=n)
colnames(y) <- seq(n)
for(i in seq(ncol(y))){
    mu <- runif(1, min=0.25*m, max=0.75*m)
    SD <- runif(1, min=5, max=30)
    TMP <- rnorm(1000, mean=mu, sd=SD)
    HIST <- hist(TMP, breaks=c(0,x), plot=FALSE)
    fit <- smooth.spline(HIST$counts ~ HIST$mids)
    y[,i] <- fit$y
}
y <- replace(y, y<0.01, 0)

#order by when 1st value occurs
ord <- order(apply(y, 2, function(r) min(which(r>0))))
y2 <- y[, ord]
COLS <- rainbow(ncol(y2))

png("stream.png", res=400, units="in", width=12, height=4)
par(mar=c(0,0,0,0), bty="n")
plot.stream(x,y2, axes=FALSE, xlim=c(100, 400), xaxs="i", center=TRUE, spar=0.2, frac.rand=0.1, col=COLS, border=1, lwd=0.1)
dev.off() #plot.stream makes a "stream plot" where each y series is plotted 
#as stacked filled polygons on alternating sides of a baseline.
#
#Arguments include:
#'x' - a vector of values
#'y' - a matrix of data series (columns) corresponding to x
#'order.method' = c("as.is", "max", "first") 
#  "as.is" - plot in order of y column
#  "max" - plot in order of when each y series reaches maximum value
#  "first" - plot in order of when each y series first value > 0
#'center' - if TRUE, the stacked polygons will be centered so that the middle,
#i.e. baseline ("g0"), of the stream is approximately equal to zero. 
#Centering is done before the addition of random wiggle to the baseline. 
#'frac.rand' - fraction of the overall data "stream" range used to define the range of
#random wiggle (uniform distrubution) to be added to the baseline 'g0'
#'spar' - setting for smooth.spline function to make a smoothed version of baseline "g0"
#'col' - fill colors for polygons corresponding to y columns (will recycle)
#'border' - border colors for polygons corresponding to y columns (will recycle) (see ?polygon for details)
#'lwd' - border line width for polygons corresponding to y columns (will recycle)
#'...' - other plot arguments
plot.stream <- function(
    x, y, 
    order.method = "as.is", frac.rand=0.1, spar=0.2,
    center=TRUE,
    ylab="", xlab="",  
    border = NULL, lwd=1, 
    col=rainbow(length(y[1,])),
    ylim=NULL, 
    ...
){

if(sum(y < 0) > 0) error("y cannot contain negative numbers")

if(is.null(border)) border <- par("fg")
border <- as.vector(matrix(border, nrow=ncol(y), ncol=1))
col <- as.vector(matrix(col, nrow=ncol(y), ncol=1))
lwd <- as.vector(matrix(lwd, nrow=ncol(y), ncol=1))

if(order.method == "max") {
    ord <- order(apply(y, 2, which.max))
    y <- y[, ord]
    col <- col[ord]
    border <- border[ord]
}

if(order.method == "first") {
    ord <- order(apply(y, 2, function(x) min(which(r>0))))
    y <- y[, ord]
    col <- col[ord]
    border <- border[ord]
}

bottom.old <- x*0
top.old <- x*0
polys <- vector(mode="list", ncol(y))
for(i in seq(polys)){
    if(i %% 2 == 1){ #if odd
        top.new <- top.old + y[,i]
        polys[[i]] <- list(x=c(x, rev(x)), y=c(top.old, rev(top.new)))
        top.old <- top.new
    }
    if(i %% 2 == 0){ #if even
        bottom.new <- bottom.old - y[,i]
        polys[[i]] <- list(x=c(x, rev(x)), y=c(bottom.old, rev(bottom.new)))
        bottom.old <- bottom.new
    }
}

ylim.tmp <- range(sapply(polys, function(x) range(x$y, na.rm=TRUE)), na.rm=TRUE)
outer.lims <- sapply(polys, function(r) rev(r$y[(length(r$y)/2+1):length(r$y)]))
mid <- apply(outer.lims, 1, function(r) mean(c(max(r, na.rm=TRUE), min(r, na.rm=TRUE)), na.rm=TRUE))

#center and wiggle
if(center) {
    g0 <- -mid + runif(length(x), min=frac.rand*ylim.tmp[1], max=frac.rand*ylim.tmp[2])
} else {
    g0 <- runif(length(x), min=frac.rand*ylim.tmp[1], max=frac.rand*ylim.tmp[2])
}

fit <- smooth.spline(g0 ~ x, spar=spar)

for(i in seq(polys)){
    polys[[i]]$y <- polys[[i]]$y + c(fit$y, rev(fit$y))
}

if(is.null(ylim)) ylim <- range(sapply(polys, function(x) range(x$y, na.rm=TRUE)), na.rm=TRUE)
plot(x,y[,1], ylab=ylab, xlab=xlab, ylim=ylim, t="n", ...)
for(i in seq(polys)){
    polygon(polys[[i]], border=border[i], col=col[i], lwd=lwd[i])
}

}
-------------------------------------------------------------------------------------------------------
apply parse(text = ...) .expressions <- paste(colnames(data),greek,sep="")
legend_expressions <-parse(text = .expressions)

matplot(data)
legend(1,max(data),fill=c("black","red","green","blue"),legend_expressions) ~ sep = '' sep = '~' paste .expressions <- paste(colnames(data),greek,sep="~")
legend_expressions <-parse(text = .expressions)

matplot(data)
legend(1,max(data),fill=c("black","red","green","blue"),legend_expressions) sprintf greek <- c("alpha", "beta", "gamma", "delta")
other_stuff <- c('hello world','again this','and again','hello')

.expressions <- mapply(sprintf, colnames(data), other_stuff, greek, 
                       MoreArgs = list(fmt = '"%s %s"~(%s)'))

.expressions  
##                           A                           B                           C                           D 
## "\"A hello world\"~(alpha)"   "\"B again this\"~(beta)"   "\"C and again\"~(gamma)"       "\"D hello\"~(delta)" 

 legend_expressions <-parse(text = .expressions)

matplot(data)
legend(1,max(data),fill=c("black","red","green","blue"),legend_expressions)
-------------------------------------------------------------------------------------------------------
parse() greek <- c("alpha", "beta", "gamma", "delta")
cnames <- paste(LETTERS[1:4], letters[1:4])

legend_expressions <- 
sapply(1:4, function(i) {
    as.expression(substitute(A (B), 
                  list(A = as.name(cnames[i]), B = as.name(greek[i]))))
})

matplot(data)
legend(1,max(data),fill=c("black","red","green","blue"),legend_expressions)
-------------------------------------------------------------------------------------------------------
paste() expression() example(plotmath) demo(plotmath) phantom() < plot(1)
legend(x = "topleft", legend = expression(paste(r^2==0.9230, ",  ", P<phantom(), "0.0001")))
-------------------------------------------------------------------------------------------------------
substitute phantom plot(1)
options(scipen=10)
legend(x = "topleft", legend = substitute(list(r^2 == r2, P < p), list(r2=0.923, p=0.0001)))
-------------------------------------------------------------------------------------------------------
set.seed(001)
DF <- data.frame(matrix(rnorm(400, 100, 12), ncol=4)) # some data
den<-apply(DF, 2, density) # estimating density


par(mfrow=c(2,2))
sapply(den, plot) # plot each density
par(mfrow=c(1,1)) par(mfrow=c(2,2))
for(i in 1:length(den)){
  plot(den[[i]], 
       main=paste('density ', i))
}
par(mfrow=c(1,1)) par(mfrow=c(2,2)) sapply(den, plot) plot(den[[1]], ylim=c(0,.04), 
     main='Densities altogether') # plot the first density
for(i in 2:length(den)){          # Add the lines to the existing plot
  lines(den[[i]], col=i)          
} legend legend('topright', paste('density ', 1:4), col=1:4, lty=1, cex=.65)
-------------------------------------------------------------------------------------------------------
?plotmath bar() plotmath avg plotmath bquote() .( ) .( ) legend() test <- c(10,20,40,80,80)
avg <- mean(test)
avg <- format(avg,digits=2)

plot(test, xlab="x", ylab="y", pch = 4)
legend("topleft", legend = bquote(bar(x)*":" ~ .(avg))) avg avg <- round(avg)
-------------------------------------------------------------------------------------------------------
par(new=TRUE) lines() par(new=TRUE) xlim survfit # Fake data for the plots
pump <- data.frame(TIME=rweibull(40, 2, 20),
                   CENSUS=runif(40) < .3,
                   DEVICE=rep(0:1, c(20,20)))
# load package
library("survival")

# Fit models
mfit.overall <-survfit(Surv(TIME, CENSUS==0) ~ 1, data=pump)
mfit.htx <- survfit(Surv(TIME, CENSUS==0) ~ 1, data=pump, subset=DEVICE==1)

# Plot
plot(mfit.overall, col=1, xlim=range(pump$TIME), fun=function(x) 1-x)
# `xlim` makes sure the x-axis is the same in both plots
# `fun` flips the curve to start at 0 and increase
par(new=TRUE)
plot(mfit.htx, col=2, xlim=range(pump$TIME), fun=function(x) 1-x,
    ann=FALSE, axes=FALSE, bty="n") # This hides the annotations of the 2nd plot
legend("topright", c("All", "HTX"), col=1:2, lwd=1)
-------------------------------------------------------------------------------------------------------
plot.new() lines() "surfit" plot(mfit.overall, col=1, xlim=range(pump$TIME), fun=function(x) 1-x)
lines(mfit.htx, col=2, fun=function(x) 1-x)
lines(mfit.htx, col=2, fun=function(x) 1-x, lty = "dashed", conf.int = "only")
legend("topleft", c("All", "HTX"), col=1:2, lwd=1, bty = "n") lines() lty lines() lines()
-------------------------------------------------------------------------------------------------------
legend(-2,0,legend=c("V1","V2"),pch=c(15,16),col=c("blue","red"),lty=c(1,2)) legend
-------------------------------------------------------------------------------------------------------
library(ggplot2) # using version 0.9.2.1
library(maps)

# load us map data
all_states <- map_data("state")

# start a ggplot. it won't plot til we type p
p <- ggplot()  

# add U.S. states outlines to ggplot
p <- p + geom_polygon(data=all_states, aes(x=long, y=lat, group = group),
     colour="grey", fill="white" )

# add total Population
p <- p + geom_point(data=df1, aes(x=longitude, y=latitude, size = totalPop), 
     colour="#b5e521")

# add sub Population as separate layer with smaller points at same long,lat
p <- p + geom_point(data=df1, aes(x=longitude, y=latitude, size = subPop), 
     colour="#00a3e8")

# change name of legend to generic word "Population"
p <- p + guides(size=guide_legend(title="Population"))

# display plot
p get_map() ggmap require(ggmap)
require(mapproj)
map <- get_map(location = 'united states', zoom = 3, maptype = "terrain", 
       source = "google")
p <- ggmap(map)
-------------------------------------------------------------------------------------------------------
plot(x=c(2,4,8),y=c(5,4,2),pch=16)
points(x=c(3,5),y=c(2,4),pch="+")
legend(7,4.5,pch=c(NA,16),legend=c("A","B")) # NA means don't plot pt. character 
legend(7,4.5,pch=c("+",NA),legend=c("A","B")) pdf() bmp() png()
-------------------------------------------------------------------------------------------------------
guides ggplot(foo, aes(x = length, y = height, color=group, shape=quality)) + 
  geom_point(size=5) + 
  guides(colour = guide_legend(override.aes = list(shape = 15))) shape
-------------------------------------------------------------------------------------------------------
set.seed(001)    
low <- runif(10,min=10, max=50)

high <- runif(10,min=10000, max=11000)
plot(
  high,
  type="l",
  ylim=c(0,11000)
)
lines(low, type="l")


plot(high,            
     type="l",              
     col="red",              
     bty='l',                
     ylab='', xlab='',      
     las=1,                 
     cex.axis=.75)     

par(new=TRUE)                

plot(low,
     type="l", 
     col="blue", 
     bty='n',                
     xaxt="n",               
     yaxt="n",               
     xlab="", ylab="", 
     cex.axis=.75)

axis(4, las=1, cex.axis=.75) 

legend('topright', c('high', 'low'), col=c('red', 'blue'), lty=1, bty='n', cex=.75)
-------------------------------------------------------------------------------------------------------
ld polygon par()$cin par()$ps par()$usr ld plot(1)
legendLabel<-c("t\nu ","tu","wh","trr\nni")
ld <- legend("top",legend=legendLabel,horiz=TRUE,fill=c("red","blue","gray","black"), bty="n")

CIN <- par()$cin
PS <- par()$ps
USR <- par()$usr
CIN.USR <- c((CIN[1]/72*PS)/(USR[2]-USR[1]), (CIN[2]/72*PS)/(USR[4]-USR[3]))

xs <- c(ld$text$x[1], ld$text$x[1], ld$text$x[length(ld$text$x)], ld$text$x[length(ld$text$x)])
ys <- c(ld$text$y[1], ld$text$y[1], ld$text$y[length(ld$text$x)], ld$text$y[length(ld$text$x)])

polygon(
x = xs + c(-3*CIN.USR[1], -3*CIN.USR[1], 2*CIN.USR[1], 2*CIN.USR[1]), 
y = ys+c(-1*CIN.USR[2], 1*CIN.USR[2], 1*CIN.USR[2], -1*CIN.USR[2])
)
-------------------------------------------------------------------------------------------------------
bty="n" ld<-legend("top",legend=legendLabel, cex=0.65, fill=colorNames, horiz=TRUE,bty="n")
  height<-(ld$rect$top-ld$text$y[1])*2
  xs <- c(ld$rect$left, ld$rect$left, ld$rect$left+ld$rect$w, ld$rect$left+ld$rect$w)
  ys <- c(ld$rect$top, ld$rect$top-height, ld$rect$top-height, ld$rect$top)
  polygon(x = xs , y = ys)
-------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------
par(bty="l",las=1)
scatterplot(Comp1~ln1wr|Season, moose,  
      xlab = "Risk", ylab = "Principal component 1",
            labels= row.names(moose),
            by.groups=TRUE, smooth=FALSE, boxplots=FALSE,
            grid=FALSE,
            legend.plot=FALSE)
legend("bottomright", title="Season",legend=levels(moose$Season), bty="n",pch=1:2, col=1:2) ?legend bty "n" bty="l" las=1 grid=FALSE
-------------------------------------------------------------------------------------------------------
require(reshape2)

meltpath <- function(x){
  require(data.table)
  x <- melt(data = x, id.vars = 'id', measure.vars = names(x)[-1])
  names(x) <- c('id','year','category')
  x$year <- factor(x$year)
  id <- unique(x$id)
  idtable <- data.table(id = id, count = 1:length(id))
  x <- x[order(x$id), ]
  x <- merge(x, idtable, by='id')
  return(x)
}

carpath <- function(datatable, max_x = max(datatable$count)){
  require(ggplot2)
  p = ggplot(datatable, aes(x = count, y = year, fill = category)) + 
    geom_tile() +
    scale_y_discrete(name = "year\n", 
                     breaks = rev(levels(datatable$year))) + 
    scale_x_continuous(name = "cumulative count", 
                      limits = c(0,max_x)) +
    guides(fill = guide_legend(title="Career stage\n",reverse=TRUE)) +
    theme(panel.grid.major = element_blank(), 
         panel.background = element_blank(), 
         axis.ticks = element_blank(),
         plot.title = element_text(vjust = 1.2, face="bold", size=20),
         axis.title.y = element_text(size=15, face="bold"),
         axis.text.y = element_text(size=15, colour="black"),
         legend.title = element_text(size = 15),
         legend.text = element_text(size = 15)) +
         scale_fill_brewer(palette = "Dark2") +
    ggtitle("Career path of individual Students by year")
  p
}

test <- structure(list(
  id = 1:6,
  y2002 = c("freshman","freshman","freshman","sophomore","sophomore","senior"),
  y2003 = c("freshman","junior","sophomore","sophomore","sophomore","senior"),
  y2004 = c("junior","sophomore","sophomore","senior","senior",NA),
  y2005 = c("senior","senior","senior",NA, NA, NA)), 
                  .Names = c("id","2002","2003","2004","2005"),
                  row.names = c(c(1:6)),
                  class = "data.frame")
# Grow dataset
testg = data.frame()
for (i in rownames(test)) {
  test0 <- test[rep(i, each=abs(floor(rnorm(1)*100))),]
  testg <- rbind(testg, test0)
}
testg$id <- 1:nrow(testg)
# Munge
test0 <- testg
test1 <- melt(data = test0, id.vars = 'id', measure.vars = names(test0)[-1])
names(test1) <- c('id','year','category')
test1$category[test1$category == 'freshman'] <- 1
test1$category[test1$category == 'junior'] <- 2
test1$category[test1$category == 'sophomore'] <- 3
test1$category[test1$category == 'senior'] <- 4
test1$category <- factor(test1$category, levels=1:4, labels = c('1. freshman','2. junior','3. sophomore','4. senior'))
test1 <- test1[order(test1$category), ]
test1 <- dcast(test1, id ~ year)
test1 <- test1[order(test1$'2005',test1$'2004',test1$'2003',test1$'2002'), ]
test2 <- meltpath(test1)
carpath(test2)
-------------------------------------------------------------------------------------------------------
a<-c(1,1,2,3,3,3,3,4,54,56,2,23,1,3,23)
par(mfrow=c(1,2)) 
hist(a) 

graphics::legend(x=10,y=10,c(">0%",">20%"),x.intersp=1,y.intersp=1,cex=c(1),bty="n",fill=c("black",),pch=c(24,22),pt.cex = c(2,2), lwd=1.5,title='Histo') 

hist(a) 

graphics::legend(x=10,y=10,c(">0%",">20%"), x.intersp=1,y.intersp=1,cex=c(1),bty="n",pch=c(24,22),pt.cex = c(1,2,3,3,4), lwd=1.5, title = 'Histo whithout fill ')
-------------------------------------------------------------------------------------------------------
legend box.cex y.intersp source("http://www.math.mcmaster.ca/bolker/R/misc/legendx.R")
a<-c(1,1,2,3,3,3,3,4,54,56,2,23,1,3,23)
cex <- 1
hist(a)
legend("topright",c(">0%",">20%"),bty="n",fill=c("black","gray50","gray70","gray85","white"), box.cex=c(3,3),y.intersp=2.8)
-------------------------------------------------------------------------------------------------------
plot( 1, type = "n", axes = FALSE, xlab = "", ylab = "" ) # Empty plot
par( lend = 1 ) # Rectangular line endings
legend("topleft",c( "Red", "Black" ),col = c("red", "black"),lty = 1, lwd = 10)
-------------------------------------------------------------------------------------------------------
df1 <- read.table(text="group   x     y   
group1 -0.212201  0.358867
group2 -0.279756 -0.126194
group3  0.186860 -0.203273
group4  0.417117 -0.002592
group1 -0.212201  0.358867
group2 -0.279756 -0.126194
group3  0.186860 -0.203273
group4  0.186860 -0.203273",header=TRUE)

df2 <- read.table(text="group   x     y   
group1  0.211826 -0.306214
group2 -0.072626  0.104988
group3 -0.072626  0.104988
group4 -0.072626  0.104988
group1  0.211826 -0.306214
group2 -0.072626  0.104988
group3 -0.072626  0.104988
group4 -0.072626  0.104988",header=TRUE)


library(ggplot2)
library(gridExtra)

p1 <- ggplot(df1, aes(x=x, y=y,colour=group)) + geom_point(position=position_jitter(w=0.04,h=0.02),size=1.8) + theme(legend.position="bottom")

p2 <- ggplot(df2, aes(x=x, y=y,colour=group)) + geom_point(position=position_jitter(w=0.04,h=0.02),size=1.8)

#extract legend
#https://github.com/hadley/ggplot2/wiki/Share-a-legend-between-two-ggplot2-graphs
g_legend<-function(a.gplot){
  tmp <- ggplot_gtable(ggplot_build(a.gplot))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)}

mylegend<-g_legend(p1)

p3 <- grid.arrange(arrangeGrob(p1 + theme(legend.position="none"),
                         p2 + theme(legend.position="none"),
                         nrow=1),
             mylegend, nrow=2,heights=c(10, 1))
-------------------------------------------------------------------------------------------------------
# some data
require(vegan)
data(dune)
data(dune.env)

# vector holding the colors
cols <- c("red", "blue", "pink", "green")

# NMDS with bray-curtis distance
nmds <- metaMDS(dune, "bray", 2)

# empty plot
plot(nmds, type = "n")

# Add points colored by Environmental Variable Management
points(nmds, col = cols[dune.env$Management], pch = 16)

# add legend
legend("topright", legend=levels(dune.env$Management), col=cols, pch = 16)
-------------------------------------------------------------------------------------------------------
legend("topleft", legend=c(l[["m1"]]$label, l[["m2"]]$label),col=c(l[["m1"]]$col,l[["m2"]]$col), pch=0.5,title.adj=100,cex=0.8,y.intersp=2)
-------------------------------------------------------------------------------------------------------
library(gridExtra)
         grid.arrange(p0 , p1,  g_legend(p), ncol=3,
         heights=c(10, 1),widths =c(1,2,1) ,as.table =TRUE)
-------------------------------------------------------------------------------------------------------
mod.aic <- coxph(Surv(time, event) ~ 
               x + frailty.gamma(cluster, eps=1e-10, method="aic", sparse=0),
             outer.max=1000, iter.max=10000,
             data=dat)

plot(survfit(mod.aic), col=4) par(mfrow=c(2,3))
res <- sapply( 1:6 , function(x) {
                      mod <- 
                        coxph(Surv(time, event) ~ 
                        x + frailty.gamma(cluster, eps=1e-10, method="em", sparse=0),
                        outer.max=1000, iter.max=10000,
                        data=subset(dat,cluster != x)
                        )
                     plot(survfit(mod), col=4,main= paste ('cluster', x, 'is removed'))
                     legend(10,1,mod$iter)
              }) library(ggplot2
qplot(data = dat, x=time , y = x , facets= event~cluster)
-------------------------------------------------------------------------------------------------------
symbolListForLegend from rpy2.robjects.vectors import IntVector
symbolListForLegend = [dataDict['symbols'][category] \
                       for category in dataDict['symbols']
symbolVectorForLegend = IntVector(symbolListForLegend)
r.legend(1.5, -42, nameListForLegend,pch = symbolVectorForLegend, cex=3, col="black", border = 0)
-------------------------------------------------------------------------------------------------------
text df <- data.frame(Rows = letters[6:10],value=c("L","L","L","L","N"))
x <- matrix(seq(1,10,by=0.1),ncol=5,nrow=5)
colnames(x) <- letters[1:5]
rownames(x) <- letters[6:10]
plot(hclust(t(dist(x))))
axis(1,at=seq(1,length(rownames(x)),1),labels=FALSE)
text(seq(1,length(rownames(x)),1),labels="\u2594",col=c(rep("red",2),"blue",rep("red",2)),cex=25,par("usr")[3]+0.005)
legend("topright",legend=c("L","N"),col=c("red","blue"))
-------------------------------------------------------------------------------------------------------
legend(x=1e+04, y=0.2, c("Original","Minus 30 minutes"), col=c("black","red"), lty=c("dashed","dotted"))
-------------------------------------------------------------------------------------------------------
legend trace= # plot a test plot
> plot(1:10)

# calculate the details for a legend in the bottomright, save the data
# and don't add the legend itself
> legdata <- legend("bottomright","boom",trace=TRUE,plot=FALSE)

> legdata
$rect
$rect$w
[1] 1.454288

$rect$h
[1] 1.65623

$rect$left
[1] 8.905712

$rect$top
[1] 2.29623


$text
$text$x
[1] 9.456811

$text$y
[1] 1.468115

# re-use the saved legend data to push the legend up slightly
> legend(list(x=legdata$rect$left,y=legdata$rect$top+0.5),"boom")
-------------------------------------------------------------------------------------------------------
legend legend("topright", c("reading/Writing", "Speaking"), col=c("darkblue","red"), lwd=10); lwd "topright" "top"
-------------------------------------------------------------------------------------------------------
end = c("reading/Writing", "Speaking"), fill = c("darkblue", "red")) heights1 = c(5, 5, 4.5, 4, 4, 4, 4.5, 2, 4, 4) # Your data matrix dimnames mydata <- matrix(heights1, ncol = 2, byrow = TRUE,
                 dimnames = list(c("Spanish", "English", "Hindi", 
                                   "Arabic", "Body Lang"),
                                 c("Reading/Writing", "Speaking")))
mydata # Much more meaningful to look at than a simple vector
#           Reading/Writing Speaking
# Spanish               5.0        5
# English               4.5        4
# Hindi                 4.0        4
# Arabic                4.5        2
# Body Lang             4.0        4 colors <- c("darkblue", "red") # Define the colors you're using legend.text = TRUE, args.legend = list(x = "topright", bty = "n") barplot(t(mydata), beside = TRUE, col = colors, 
        ylim = c(0, 6), axes = FALSE,
        xlab = "Language starting with mostly used",
        main = "Languages (Verbal & Non-verbal)") axis(2, at = 0:5, labels = 0:5)
legend("topright", colnames(mydata), fill = colors, bty = "n")
-------------------------------------------------------------------------------------------------------
group ?group ggplot(dat) + geom_line(aes(x, value, group = interaction(rep,variable), color = variable), alpha = 0.3) guide_legend(override.aes = ...)) ?guides ?guide_legend ggplot(dat) + geom_line(aes(x, value, group = interaction(rep,variable), color = variable), 
                           alpha = 0.3) + 
  scale_colour_discrete(guide = guide_legend(override.aes = list(alpha = 1)))
-------------------------------------------------------------------------------------------------------
xpd=TRUE par() par(xpd=TRUE)
pie(numb, col=colors, labels=numb_labels, clockwise=TRUE)
legend(-1.4,1.6, legend = xx, fill=colors, bty="n")
-------------------------------------------------------------------------------------------------------
ggplot2 layout par(mai = c(0,0,0,0))
layout(c(1,2),heights=c(0.3,1))
plot.new()
legend("bottom", legend = xx, fill=colors, bty="n")
pie(numb, col=colors, labels=numb_labels, clockwise=TRUE)
-------------------------------------------------------------------------------------------------------
size aes_string ggplot vendor == "z" df$vendor_z <- df$vendor=="z"     # create a new column 

ggplot(df) +
  aes_string(x = "x", y = "y", color = "vendor", size = "vendor_z") +
  geom_point() +
  scale_size_manual(values = c(3, 5), guide = FALSE) + 
  guides(colour = guide_legend(override.aes = list(size = c(3, 3, 5)))) vendor_z aes_string ggplot size scale_size_manual size guide = FALSE size size color ggplot ggplot(df) +
  aes_string(x = "x", y = "y", color = "vendor", size = "vendor_z") +
  geom_point() +
  geom_point(data = df[df$vendor_z, ], aes(x = x, y = y),
             size = 3, shape = 21, fill = "white", show_guide = FALSE) +
  scale_size_manual(values = c(3, 5), guide = FALSE) + 
  guides(colour = guide_legend(override.aes = list(size = c(3, 3, 5)))) geom_point df[df$vendor_z, ] size 3 shape 21 fill show_guide = FALSE shape geom_line show_guide = FALSE ggplot(df) +
  aes_string(x = "x", y = "y", color = "vendor", size = "vendor_z") +
  geom_point() +
  geom_line(size=1.5, show_guide = FALSE) +   # this is the only difference
  scale_size_manual(values = c(3, 5), guide = FALSE) +
  guides(colour = guide_legend(override.aes = list(size = c(3, 3, 5))))
-------------------------------------------------------------------------------------------------------
+ guides(shape=guide_legend(override.aes=list(colour="white")) set_theme(theme_black); defaultcol = "white" # for slides
 # or
 set_theme(theme_bw); defaultcol = "black"    # for paper + guides(shape=guide_legend(override.aes=list(colour=defaultcol))
-------------------------------------------------------------------------------------------------------
+ guides(fill = guide_legend(override.aes= list(alpha = 0.4))) geom_ribbon dt1 <- data.frame(x = c(x,x),
                  ymin = c(y1,y3),
                  ymax = c(y2,y4),
                  grp = rep(c('red','blue'),each = 10))
ggplot(data = dt1,aes(x = x,ymin = ymin, ymax = ymax,fill = grp)) + 
    geom_ribbon(alpha = 0.4) + 
    scale_fill_manual(name = "legendname",
                      values = c('red','blue'),
                      labels = c('one','two'))
-------------------------------------------------------------------------------------------------------
caret train This function sets up a grid of tuning parameters for a number 
      of classification and regression routines. require(quantmod) 
require(nnet)
require(caret)
T = seq(0,20,length=200)
y = 1 + 3*cos(4*T+2) +.2*T^2 + rnorm(200)
dat <- data.frame( y, x1=Lag(y,1), x2=Lag(y,2))
names(dat) <- c('y','x1','x2')
#Fit model
model <- train(y ~ x1+x2 , 
               dat, 
               method='nnet', 
               linout=TRUE, 
               trace = FALSE)
ps <- predict(model, dat)

#Examine results

plot(T,Y,type="l",col = 2)
lines(T[-c(1:2)],ps, col=3)
legend(5, 70, c("y", "pred"), cex=1.5, fill=2:3)
-------------------------------------------------------------------------------------------------------
# Compare MPG distributions for cars with 
# 4,6, or 8 cylinders
library(sm)
attach(mtcars)

# create value labels 
cyl.f <- factor(cyl, levels= c(4,6,8),
  labels = c("4 cylinder", "6 cylinder", "8 cylinder")) 

# plot densities 
sm.density.compare(mpg, cyl, xlab="Miles Per Gallon")
title(main="MPG Distribution by Car Cylinders")

# add legend via mouse click
colfill<-c(2:(2+length(levels(cyl.f)))) 
legend(locator(1), levels(cyl.f), fill=colfill)
-------------------------------------------------------------------------------------------------------
## dput(read.csv("barcharttest.csv"))
x <- structure(list(ID = 1:7,
  sex = structure(c(1L, 1L, 1L, 2L, 2L, 1L, 2L), .Label = c("female", "male"),
   class = "factor"),
  val = c(309L, 192L, 384L, 27L, 28L, 245L, 183L),
  stat = structure(c(1L, 2L, 2L, 1L, 2L, 1L, 1L), .Label = c("NS", "sig"),
    class = "factor")),
               .Names = c("ID", "sex", "val", "stat"),
               class = "data.frame", row.names = c(NA, -7L)) ID    sex val stat
1  1 female 309   NS
2  2 female 192  sig
3  3 female 384  sig
4  4   male  27   NS
5  5   male  28  sig
6  6 female 245   NS
7  7   male 183   NS sexcols <- c("pink","blue")
## png("barplot.png")  ## for output graph
par(las=1,bty="l")  ## I prefer these settings; see ?par
b <- with(x,barplot(val,col=sexcols[sex])) ## b saves x coords of bars
legend("topright",levels(x$sex),fill=sexcols,bty="n")
## use xpd=NA to make sure that star on tallest bar doesn't get clipped;
##   pos=3 puts the text above the (x,y) location specified
text(b,x$val,ifelse(x$stat=="sig","*",""),pos=3,cex=2,xpd=NA)
axis(side=1,at=b,label=x$ID)
## dev.off()
-------------------------------------------------------------------------------------------------------
?legend plot PrecentageVector1 <- c(10,20,30)
plot(xlim=c(0,100), ylim=c(0,1), main=NULL, xaxs="i", yaxs="i", 
     ecdf(PrecentageVector1),  col="red", do.p = FALSE, pch=19, 
     lwd=3, panel.first = grid()) 
legend("bottomleft",c("A","B","C"))
-------------------------------------------------------------------------------------------------------
plot.new();

     legend(x=.5,y=.9, c("A","B","C","D"), pch=c(1,4,3,2), cex=.8, bty="n",col=c("green","yellow","red","blue"))
-------------------------------------------------------------------------------------------------------
pch col fill plot.new()
legend(x=.5,y=.9, c("A","B","C","D"), cex=.8, bty="n",col=c("green", "yellow", "red", "blue"), pch=c(15, 15, 15, 17))
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(reshape)
library(car)

G1 <- 1:10
G2 <- 11:20
G3 <- 21:30
G4 <- 31:35
G5 <- 36:41

sdata <- read.csv("http://dl.dropbox.com/u/58164604/sdata.csv", stringsAsFactors = FALSE)
pdata<-melt(sdata, id.vars="Var")
jdata <-pdata

pdata$group <- recode(pdata$Var, "G1 = 'A'; G2 = 'B'; G3 = 'C'; G4 = 'D'; G5 = 'E'")

VarArea <- data.frame(unique(pdata$Var))
VarFinalArea <-c()
for (g in 1:max(VarArea))
{
VarNum<-pdata[which(pdata$Var==g),1:c(ncol(pdata))]
VarMin <- min(VarNum$value)
VarMax <- max(VarNum$value)
VarMinMax <- cbind(VarMin, VarMax)
VarFinalArea <- rbind(VarFinalArea,VarMinMax)
}
VarFinal <- data.frame(cbind(VarArea,VarFinalArea))
colnames(VarFinal)<-c("Variable", "Min", "Max")
VarFinal$group <- recode(VarFinal$Variable, "G1 = 'A'; G2 = 'B'; G3 = 'C'; G4 = 'D'; G5 = 'E'")

VarArea <- data.frame(unique(jdata$Var))
NumV <- max(VarArea)
VarFinalMin <-c()
for (g in 1:NumV)
{
VarNum<-jdata[which(jdata$Var==g),1:c(ncol(jdata))]
VarN <- g
VarMin <- min(VarNum$value)
VarMinN <- cbind(VarN, VarMin)
VarFinalMin <- rbind(VarFinalMin,VarMinN)
}
VFinalMin <- data.frame(VarFinalMin)
colnames(VFinalMin)<-c("Variable", "Value")
VFinalMin_Max<-max(VFinalMin$Value)

VarFinalMax <-c()
for (g in 1:NumV)
{
VarNum<-jdata[which(jdata$Var==g),1:c(ncol(jdata))]
VarN <- g
VarMax <- max(VarNum$value)
VarMaxN <- cbind(VarN, VarMax)
VarFinalMax <- rbind(VarFinalMax,VarMaxN)
}
VFinalMax <- data.frame(VarFinalMax)
colnames(VFinalMax)<-c("Variable", "Value")
VFinalMax_Min<-min(VFinalMax$Value)

VFinal<-rbind(VFinalMin, VFinalMax)
VFinal$Group <- recode(VFinal$Variable, "G1 = 'A'; G2 = 'B'; G3 = 'C'; G4 = 'D'; G5 = 'E'")

VLarge <- VFinal[which(VFinal$Value >= VFinalMax_Min),]
VLarge <- VLarge[order(-VLarge$Variable, VLarge$Group),]
VSmall <- VFinal[which(VFinal$Value <= VFinalMin_Max),]
VSmall <- VSmall[order(VSmall$Variable, VSmall$Group),]
VFinal <- rbind(VSmall, VLarge)

AMin <-min(jdata$value)
AMax <-max(jdata$value)

AMinValue<-round_any(AMin,1000, f =floor)
AMaxValue<-round_any(AMax,1000, f =ceiling)

ggplot(VFinal, aes(Variable, Value, colour = Group)) + geom_polygon(colour=NA, aes(fill=Group), alpha=0.5) +scale_x_discrete(name="Missing Variable Number", limits=c(1:NumV)) + theme(axis.text.x=element_text(angle=270, vjust=0.5, hjust=0.0))+ scale_y_continuous(name="Within Cluster Sum of Squares", limits=c(AMinValue, AMaxValue), breaks = seq(AMinValue, AMaxValue, 1000)) + guides(fill=guide_legend(title="Variable Groups"))+ scale_fill_manual("Variable Groups", values = c("A" = "red", "B" = "blue", "C" = "purple", "D" = "salmon", "E" = "orange"))

last_plot()+geom_line(data=subset(pdata,variable =='Mean'), alpha=0.5, aes(Var, value, size= ''), colour="black", inherit.aes = FALSE)+ guides (size = 
guide_legend(title = "Mean", override.aes = list(size = 1.5, colour = "black")))

last_plot()+geom_line(data=subset(pdata,variable!='Mean'),size=0.5, alpha=0.5, aes(Var, value, shape=variable), colour='black', inherit.aes = FALSE) 

last_plot()+geom_point(data=subset(pdata,variable!='Mean'), aes(Var, value, shape = variable, col=group),alpha=1.0, inherit.aes = FALSE) + labs (shape = "Number of Clusters") + guides(scale_alpha(guide='none')) + guides(colour = "none") + scale_colour_manual("Variable Groups", values = c("A" = "red", "B" = "blue", "C" = "purple", "D" = "salmon", "E" = "orange"))

last_plot()+ ggtitle("Clusters with Missing Variables") + theme(plot.title = element_text(size = 14, colour = "black", face = "bold"))
-------------------------------------------------------------------------------------------------------
# data
temp <- structure(list(type = structure(c(1L, 2L, 3L, 2L, 3L, 3L), .Label = c("A", 
"B", "C"), class = "factor"), items = c(16L, 16L, 16L, 32L, 32L, 
64L), value = c(6.3, 8.3, 7.9, 7.7, 8.3, 7.9)), .Names = c("type", 
"items", "value"), class = "data.frame", row.names = c(NA, -6L
))

# plot
library(ggplot2)
ggplot(temp, aes(type, value, fill=type, group=items, facets=items)) + 
    geom_bar(stat="identity") + 
    facet_grid(.~ items, scales = "free_x", space="free") + 
    labs(y="value") + 
    scale_fill_manual(values = rep("steelblue",3), 
                      labels = c("A: Item A", "B: Item B", "C: Item C")) + 
    guides(fill = guide_legend(override.aes = list(fill = "white"))) + 
    theme_bw() + 
    opts(axis.title.y=theme_text(size=16,angle=90),
         axis.title.x=theme_text(size=16,angle=0)) + 
    opts(axis.text.x=theme_text(size=12)) + 
    opts(axis.text.y=theme_text(size=14)) + 
    opts(strip.background = theme_rect(colour = 'steelblue', fill = 'white',size = 1)) + 
    opts(legend.position="top", legend.text=theme_text(size=15), 
         legend.title=theme_text(size=0,colour="white")) +  
    opts(legend.key = theme_rect(colour = NA))
-------------------------------------------------------------------------------------------------------
require(tikzDevice)


setwd("/Path/To/LaTeX/Files/")

#Names of LaTeX symbols
syms <- c('alpha', 'theta', 'tau', 'beta', 'vartheta', 'pi', 'upsilon', 'gamma', 'varpi', 'phi', 'delta', 'kappa', 'rho', 'varphi', 'epsilon', 'lambda', 'varrho', 'chi', 'varepsilon', 'mu', 'sigma', 'psi', 'zeta', 'nu', 'varsigma', 'omega', 'eta', 'xi', 'Gamma', 'Lambda', 'Sigma', 'Psi', 'Delta', 'Xi', 'Upsilon', 'Omega', 'Theta', 'Pi', 'Phi')
len <- length(syms)

# random colors (red, green, blue)
r <- round(runif(len), 2)
g <- round(runif(len), 2)
b <- round(runif(len), 2)

# calculate dummy data points
x <- runif(50,1,10)
y <- x + rnorm(length(x))
fit <- lm(y ~ x)
rsq <- summary(fit)$r.squared
rsq <- signif(rsq,4)

# plot the result, will create symbol-regression.tex in the working
# directory the first time this is run it may take a long time because the
# process of calulating string widths for proper placement is
# computationally intensive, the results will get cached for the current R
# session or will get permenantly cached if you set
# options( tikzMetricsDictionary='/path/to/dictionary' ) which will be
# created if it does not exist.  Also if the flag standAlone is not set to
# TRUE then a file is created which can be included with \include{}

tikz('symbolr.tex', width = 4,height = 4,pointsize = 12)

# The syntax is mar=c(bottom, left, top, right).
par(mar=c(2,2,2,2))
# plot the box and the regression line
plot(x, y, type='n', xlab='', ylab='')
box()
abline(fit)

# add the latex symbols as points
text(x, y, paste('\\color[rgb]{',r,',',g,',',b,'}{$\\',syms,'$}',sep=''))
# Display the correlation coefficient
mtext(paste("Linear model: $R^{2}=",rsq,"$" ),line=0.5)
# and the equation of the line
legend('bottom', legend = paste("$y = ", round(coef(fit)[2],3),'x +', round(coef(fit)[1],3), '$',  sep=''), bty= 'n')

# Close the device
dev.off()
-------------------------------------------------------------------------------------------------------
require(reshape2)
df <- read.csv("TestData.csv", header=T)
# melting by "Label". `melt is from the reshape2 package. 
# do ?melt to see what other things it can do (you will surely need it)
df.m <- melt(df, id.var = "Label")
> df.m # pasting some rows of the melted data.frame

#     Label variable      value
# 1    Good       F1 0.64778924
# 2    Good       F1 0.54608791
# 3    Good       F1 0.46134200
# 4    Good       F1 0.79421221
# 5    Good       F1 0.56919951
# 6    Good       F1 0.73568570
# 7    Good       F1 0.65094207
# 8    Good       F1 0.45749702
# 9    Good       F1 0.80861929
# 10   Good       F1 0.67310067
# 11   Good       F1 0.68781739
# 12   Good       F1 0.47009455
# 13   Good       F1 0.95859182
# 14   Good       F1 1.00000000
# 15   Good       F1 0.46908343
# 16    Bad       F1 0.57875528
# 17    Bad       F1 0.28938046
# 18    Bad       F1 0.68511766

require(ggplot2)
ggplot(data = df.m, aes(x=variable, y=value)) + geom_boxplot(aes(fill=Label)) p <- ggplot(data = df.m, aes(x=variable, y=value)) + 
             geom_boxplot(aes(fill=Label))
p + facet_wrap( ~ variable, scales="free") x-labels y-labels title legend heading jitter p <- ggplot(data = df.m, aes(x=variable, y=value)) 
p <- p + geom_boxplot(aes(fill=Label))
p <- p + geom_jitter()
p <- p + facet_wrap( ~ variable, scales="free")
p <- p + xlab("x-axis") + ylab("y-axis") + ggtitle("Title")
p <- p + guides(fill=guide_legend(title="Legend_Title"))
p geom_point() position_dodge require(ggplot2)
p <- ggplot(data = df.m, aes(x=variable, y=value)) 
p <- p + geom_boxplot(aes(fill = Label))
# if you want color for points replace group with colour=Label
p <- p + geom_point(aes(y=value, group=Label), position = position_dodge(width=0.75))
p <- p + facet_wrap( ~ variable, scales="free")
p <- p + xlab("x-axis") + ylab("y-axis") + ggtitle("Title")
p <- p + guides(fill=guide_legend(title="Legend_Title"))
p
-------------------------------------------------------------------------------------------------------
p <- ggplot(df, aes(x=rating, fill=cond)) + 
           geom_density(alpha=.3) + 
           xlab("NEW RATING TITLE") + 
           ylab("NEW DENSITY TITLE")
p <- p + guides(fill=guide_legend(title="New Legend Title")) p + scale_fill_discrete(name = "New Legend Title")
-------------------------------------------------------------------------------------------------------
x <- rnorm(1000, mean=3, sd=2)
y <- rnorm(500, mean=3.5, sd=3)

dx <- density(x)
dy <- density(y)

plot.new()
plot.window(xlim=range(c(dx$x, dy$x)), ylim=range(c(dx$y, dy$y)))
with(dx, lines(x, y))
with(dy, lines(x, y, lty=2))
axis(1)
axis(2)
legend(topright, lty=1:2, c('x', 'y'))
mtext(side=1, line=2, 'Observed values')
mtext(side=2, line=2, 'Estimated probability mass')
title('Smoothed Density Estimates for 2-sample experiment')
-------------------------------------------------------------------------------------------------------
legend("topright", c("Germany", "Plastic"), col=c("blue", "red"), lwd=10) fill legend("topright", c("Germany", "Plastic"), fill=c("blue", "red")) ?legend
-------------------------------------------------------------------------------------------------------
# some semi-random data …
df <- structure(list(Germany = c(1L, 3L, 6L, 1L, 2L), Plastic = c(2L, 
5L, 4L, 2L, 3L)), .Names = c("Germany", "Plastic"), class = "data.frame", row.names = c(NA, 
-5L))

# Expand right side of clipping rect to make room for the legend
par(xpd=T, mar=par()$mar+c(0,0,0,4))

# Graph data (transposing the matrix) using heat colors,  
# put 10% of the space between each bar, and make labels  
# smaller with horizontal y-axis labels
barplot(t(df), main="Barrier distribution", xlab="Barrier [kcal/mol]", ylab="Mutant count", 
   col=c("blue", "red"), space=0.1, cex.axis=0.8, las=1,
   names.arg=c("Mon","Tue","Wed","Thu","Fri"), cex=0.8) 

# Place the legend at (4,9) using blue and red
legend(4, 9, names(df), lwd=4, col=c("blue", "red"))

# Restore default clipping rect
par(mar=c(5, 4, 4, 2) + 0.1)
-------------------------------------------------------------------------------------------------------
scatterplot3d library(scatterplot3d)

# some basic dummy data
DF <- data.frame(x = runif(10),
  y = runif(10), 
  z = runif(10), 
  group = sample(letters[1:3],10, replace = TRUE))

# create the plot, you can be more adventurous with colour if you wish
s3d <- with(DF, scatterplot3d(x, y, z, color = as.numeric(group), pch = 19))

# add the legend using `xyz.convert` to locate it 
# juggle the coordinates to get something that works.
legend(s3d$xyz.convert(0.5, 0.7, 0.5), pch = 19, yjust=0,legend = levels(DF$group), col = seq_along(levels(DF$group))) lattice cloud key cloud(z~x+y, data = DF, pch= 19, col.point = DF$group, 
  key = list(points = list(pch = 19, col = seq_along(levels(DF$group))), 
  text = list(levels(DF$group)), space = 'top', columns = nlevels(DF$group)))
-------------------------------------------------------------------------------------------------------
plot(rnorm(50), pch=c(15:17), col=1:2)
# Plot legend text, inset could be used to shift legend text to the right
pos <- legend('topleft', legend=c("a","b","c"), cex=1.5)
# Plot symbols in two columns, shifted to the left by 3 and 1 respectively
points(x=rep(pos$text$x, times=2) - c(3,1), 
    y=rep(pos$text$y, times=2), 
    pch=rep(c(15:17), times=2), col=rep(1:2, times=3))
-------------------------------------------------------------------------------------------------------
locator() locator() plot(1:100) coords <- locator() Stop .. Stop Locator coords
$x
[1] 30.26407
$y
[1] 81.66773 text(x=30.26407, y=81.66773,label="This label appears where I clicked") text(x=coords$x, y=coords$y,label="This label appears where I clicked") text pos=4 text(x=30,y=80,pos=4,label = "hello") legend() ggplot2 ggplot2
-------------------------------------------------------------------------------------------------------
matplot dat <- matrix(runif(40,1,20),ncol=4) # make data
 matplot(dat, type = c("b"),pch=1,col = 1:4) #plot
 legend("topleft", legend = 1:4, col=1:4, pch=1) # optional legend ggplot pch matplot() plot()
-------------------------------------------------------------------------------------------------------
R> library(reshape2)
R> dd = melt(hej3, colnames(hej3)[c(1:2, 4, 6:10)])
R> dd = dd[dd$variable=="Delägare.män.",c(1, 9:10)]
R> head(dd, 4)
   Year variable value
1  1901        N    85
3  1902        N    92
5  1903        N    99
7  1904        N   112 + geom_line(data=dd, aes(x=Year, y = value, linetype=variable), 
          size = 1.5,  alpha = 1) + + coord_cartesian(ylim = c(-300, 600)) ggplot(subset(hej3,variable=="Delägare.män."), aes(x = Year)) + 
geom_line(data=dd, aes(x=Year, y = value, linetype=variable), 
          size = 1.5,  alpha = 1) + 
geom_ribbon(aes(ymax = Max, 
                ymin = Min, fill = "Delägare Män Max/Min"), linetype = 3, 
            alpha = 0.4) + 
geom_ribbon(aes(ymax = Mean+sd, ymin = Mean-sd, fill = "Mean +- sd"), 
            colour = "grey50", linetype = 3, alpha = 0.8)+
scale_color_manual("Variabler", breaks = c("Antal Kassor","Medelvärde"),  
                   values = c("Antal Kassor" = "black", "Medelvärde" = "#6E6E6E")) + 
scale_fill_manual(" Ribbons", breaks = c("Delägare Män Max/Min", "Mean +- sd"), 
                  values = c(`Delägare Män Max/Min` = "grey50", `Mean +- sd` = "#4E4E4E")) + 
theme(legend.direction = "horizontal", legend.position = "bottom", legend.key = element_blank(), 
      legend.background = element_rect(fill = "white", colour = "gray30")) + 
guides(fill = guide_legend(keywidth = 0.9, keyheight = 1))    +
coord_cartesian(ylim = c(-300, 600))
-------------------------------------------------------------------------------------------------------
geom_line() linetype= aes() + geom_line(aes(y = Mean, color = "Medelvärde",linetype = "Medelvärde"), 
            size = 1.5, alpha = 1)  
 + geom_line(aes(y = N, 
                color = "Antal Kassor",linetype="Antal Kassor"), size = 0.9, alpha = 1) scale_linetype_manual() scale_colour_manual() +scale_linetype_manual("Variabler",values=c("Antal Kassor"=2,"Medelvärde"=1)) guides() linetype colours + guides(fill = guide_legend(keywidth = 1, keyheight = 1),
    linetype=guide_legend(keywidth = 3, keyheight = 1),
    colour=guide_legend(keywidth = 3, keyheight = 1)) theplot<- ggplot(subset(hej3,variable=="Delägare.män."), aes(x = Year)) + 

  geom_line(aes(y = Mean, color = "Medelvärde",linetype = "Medelvärde"), 
            size = 1.5, alpha = 1) + 

  geom_ribbon(aes(ymax = Max, 
                  ymin = Min, fill = "Delägare Män Max/Min"), linetype = 3, 
              alpha = 0.4) + 

  geom_ribbon(aes(ymax = Mean+sd, ymin = Mean-sd, fill = "Mean +- sd"), 
              colour = "grey50", linetype = 3, alpha = 0.8)+

  #geom_line(aes(y = Sum, 
  #color = "Sum Delägare Män"), size = 0.9, linetype = 1, alpha = 1) + 

  geom_line(aes(y = N, 
                color = "Antal Kassor",linetype="Antal Kassor"), size = 0.9, alpha = 1)+

  scale_y_continuous(breaks = seq(-500, 4800, by = 100), limits = c(-500, 4800), 
                     labels = seq(-500, 4800, by = 100))+ 
  scale_x_continuous(breaks=seq(1901,1930,2))+
  labs(title = "Manliga Delägare i Yrkeskassor") +

  scale_color_manual("Variabler", breaks = c("Antal Kassor","Medelvärde"),  
                     values = c("Antal Kassor" = "black", "Medelvärde" = "#6E6E6E")) + 
  scale_fill_manual(" Ribbons", breaks = c("Delägare Män Max/Min", "Mean +- sd"), 
                    values = c(`Delägare Män Max/Min` = "grey50", `Mean +- sd` = "#4E4E4E")) + 
  scale_linetype_manual("Variabler",values=c("Antal Kassor"=2,"Medelvärde"=1))+
  theme(legend.direction = "horizontal", legend.position = "bottom", legend.key = element_blank(), 
        legend.background = element_rect(fill = "white", colour = "gray30")) + 
  guides(fill = guide_legend(keywidth = 1, keyheight = 1), linetype=guide_legend(keywidth = 3, keyheight = 1),
         colour=guide_legend(keywidth = 3, keyheight = 1)) +
     coord_cartesian(ylim = c(-300, 600))
-------------------------------------------------------------------------------------------------------
?legend legend('topright', names(a)[-1] , 
   lty=1, col=c('red', 'blue', 'green',' brown'), bty='n', cex=.75)
-------------------------------------------------------------------------------------------------------
cumsum heights =c(cumsum(dat[,1])-dat[,1]/2,cumsum(dat[,2])-dat[,2]/2), dat
        Male   Female
100 68.33333 31.66667
200 53.33333 46.66667
300 70.00000 30.00000
400 70.00000 30.00000
500 61.66667 38.33333 midpts <- barplot(dat,col=rainbow(5),beside=F)
legend(2, 320, rownames(dat), cex=1, angle = c(135, 45),  fill =rainbow(5))
text(x= rep(midpts,each=5),
y =c(cumsum(dat[,1])-dat[,1]/2,cumsum(dat[,2])-dat[,2]/2),
label = round(unlist(dat),2),cex=1.2)
-------------------------------------------------------------------------------------------------------
layout pairs mfrow oma pairs(iris[1:4], main = "Anderson's Iris Data -- 3 species",
      pch = 21, bg = c("red", "green3", "blue")[iris$Species],
      oma=c(4,4,6,12))
# allow plotting of the legend outside the figure region 
# (ie within the space left by making the margins big)
par(xpd=TRUE)
legend(0.85, 0.7, as.vector(unique(iris$Species)),  fill=c("red", "green3", "blue"))
-------------------------------------------------------------------------------------------------------
legend lattice ggplot2 library(lattice)
 xyplot(y~x,groups=group,auto.key=T) x<-rnorm(mean=0,sd=1,500)
y<-sample(1:500,500,replace=T)
group<-as.factor(sample(c('A','B','C'),500,replace=T,prob=c(0.2,0.3,0.5)))
plot(x,y,col=group,pch=as.numeric(group))

legend(2, 500, c('A','B','C'),cex=1.5, pch=1:3,col=1:3)
-------------------------------------------------------------------------------------------------------
override.aes guide_legend() g <- g + guides(shape=guide_legend(override.aes=list(size=5)))
print(g)
-------------------------------------------------------------------------------------------------------
z scale_linetype_manual(values = factor(unique(othr)) scale_linetype_manual(values =c(1,2)) chp <- ggplot(data=z,aes(x=x,y=y,colour = group, linetype=as.factor(othr))) + 
  geom_errorbar(aes(ymin = y - ySD, ymax = y + ySD)) + 
  geom_errorbarh(aes(xmin = x - xSD, xmax = x + xSD)) +
  theme_bw() +
  guides(linetype=FALSE)
chp guides(linetype=FALSE) guides(colour=guide_legend(override.aes=list(linetype=c(2,rep(1,times=9))))) override.aes guide_legend() linetype linetype=2 linetype = 1
-------------------------------------------------------------------------------------------------------
# set the margins
tmpmar <- par("mar")
tmpmar[3] <- 0.5
par(mar=tmpmar)

# get underlying plot
x <- 1:10
y <- jitter(x^2)
plot(x, y, pch=20)

# basic straight line of fit
fit <- glm(y~x)
co <- coef(fit)
abline(fit, col="blue", lwd=2)

# exponential
f <- function(x,a,b) {a * exp(b * x)}
fit <- nls(y ~ f(x,a,b), start = c(a=1, b=1)) 
co <- coef(fit)
curve(f(x, a=co[1], b=co[2]), add = TRUE, col="green", lwd=2) 

# logarithmic
f <- function(x,a,b) {a * log(x) + b}
fit <- nls(y ~ f(x,a,b), start = c(a=1, b=1)) 
co <- coef(fit)
curve(f(x, a=co[1], b=co[2]), add = TRUE, col="orange", lwd=2) 

# polynomial
f <- function(x,a,b,d) {(a*x^2) + (b*x) + d}
fit <- nls(y ~ f(x,a,b,d), start = c(a=1, b=1, d=1)) 
co <- coef(fit)
curve(f(x, a=co[1], b=co[2], d=co[3]), add = TRUE, col="pink", lwd=2) # legend
legend("topleft",legend=c("linear","exponential","logarithmic","polynomial"),col=c("blue","green","orange","pink"),lwd=2,)
-------------------------------------------------------------------------------------------------------
> set.seed(1)
> DF <- data.frame(2000:2009,matrix(rnorm(50, 1000, 200), ncol=5))
> colnames(DF) <- c('Year', paste0('Country', 2:ncol(DF)))
> DF # this is how the data.frame looks like:
   Year  Country2  Country3  Country4  Country5  Country6
1  2000  874.7092 1302.3562 1183.7955 1271.7359  967.0953
2  2001 1036.7287 1077.9686 1156.4273  979.4425  949.3277
3  2002  832.8743  875.7519 1014.9130 1077.5343 1139.3927
4  2003 1319.0562  557.0600  602.1297  989.2390 1111.3326
5  2004 1065.9016 1224.9862 1123.9651  724.5881  862.2489
6  2005  835.9063  991.0133  988.7743  917.0011  858.5010
7  2006 1097.4858  996.7619  968.8409  921.1420 1072.9164
8  2007 1147.6649 1188.7672  705.8495  988.1373 1153.7066
9  2008 1115.1563 1164.2442  904.3700 1220.0051  977.5308
10 2009  938.9223 1118.7803 1083.5883 1152.6351 1176.2215
> matplot(DF[,-1], col=1:ncol(DF), type='l', lty=1, ylim=range(DF), axes=FALSE)
> axis(1, 1:nrow(DF), as.character(DF[,1]))
> axis(2)
> box() #- to make it look "as usual"
> legend('topright', names(DF), col=1:ncol(DF), lty=1, cex=.65)
-------------------------------------------------------------------------------------------------------
ts set.seed(1)
DF <- data.frame(2000:2009,matrix(rnorm(50, 1000, 200), ncol=5))
colnames(DF) <- c('Year', paste0('Country', 2:ncol(DF)))
DF.TS <- ts(DF[-1], start = 2000, frequency = 1)
DF.TS
# Time Series:
# Start = 2000 
# End = 2009 
# Frequency = 1 
#       Country2  Country3  Country4  Country5  Country6
# 2000  874.7092 1302.3562 1183.7955 1271.7359  967.0953
# 2001 1036.7287 1077.9686 1156.4273  979.4425  949.3277
# 2002  832.8743  875.7519 1014.9130 1077.5343 1139.3927
# 2003 1319.0562  557.0600  602.1297  989.2390 1111.3326
# 2004 1065.9016 1224.9862 1123.9651  724.5881  862.2489
# 2005  835.9063  991.0133  988.7743  917.0011  858.5010
# 2006 1097.4858  996.7619  968.8409  921.1420 1072.9164
# 2007 1147.6649 1188.7672  705.8495  988.1373 1153.7066
# 2008 1115.1563 1164.2442  904.3700 1220.0051  977.5308
# 2009  938.9223 1118.7803 1083.5883 1152.6351 1176.2215 # Each country in a separate panel, no legends required
plot(DF.TS) # All countries in one plot... colorful, common scale, and so on
plot(DF.TS, plot.type="single", col = 1:ncol(DF.TS))
legend("bottomleft", colnames(DF.TS), col=1:ncol(DF), lty=1, cex=.65)
-------------------------------------------------------------------------------------------------------
raster r <-raster(t(matrix((data=corr), ncol=720, nrow=1440)))
r1 <- raster(t(matrix((data=over), ncol=720, nrow=1440)))
m <- r > r1 #Compare the two rasters
image( m , col = c("#EF8A62" , "#67A9CF" ) ) #Hexadecimal colour specification
legend( "bottomleft" , legend = c( "Y" , "Y1") , fill = c("#EF8A62" , "#67A9CF" ) , border = "#D9D9D9" , bty = "n")
-------------------------------------------------------------------------------------------------------
p + guides(colour = guide_legend())
-------------------------------------------------------------------------------------------------------
legend_texts = expression(
   Omega^2, Omega*10)

 legend("topleft", legend = legend_texts, col = c(1:2), pch = c(1:2), lty = 1) Omega^10 Omega*10 Omega%*%10
-------------------------------------------------------------------------------------------------------
parse text <- paste("alpha^2%*%",parse(text=pretty10exp(factor,drop.1=T)),sep="")
text
[1] "alpha^2%*%10^-5" # which we then use as the expression in your call to legend
legend("topleft", legend=parse(text=text), pch=1, lty=1) ?parse
-------------------------------------------------------------------------------------------------------
legend(0.5, 0.8, paste("region", 1:5),density=c(20,20,20,20,0),angle=c(90,0,45,135,0))
-------------------------------------------------------------------------------------------------------
layout(matrix(c(1,2),nrow=1),
       width=c(4,1)) #Divide your plotting region in two inequal part
par(mar=c(5,4,4,0)) #Get rid of the margin on the right side
plot(NA,xlim=c(0,1),ylim=c(0,1),
     xlab=expression(delta),ylab="K", xaxs="i",yaxs="i") # Here's your delta
a1 <- curve((x+x^7-x^2-x^4)/(1+x-x^3-x^4), from=0, n=450000, add = TRUE)

...

par(mar=c(5,0,4,2)) #No margin on the left side
plot(c(0,1),type="n", axes=F, xlab="", ylab="") #Empty plot
legend("top",legend=c("1","2","3","4","5"), density=c(20,20,20,20,NA), angle=c(90,0,45,135,NA), col=c(NA,NA,NA,NA,"black"), bty="n", cex=1.5) text mtext locator par(mar=c(5,4,4,8))
plot(NA,xlim=c(0,1),ylim=c(0,1),
     xlab=expression(delta),ylab="K", xaxs="i",yaxs="i") # Here's your delta
     a1 <- curve((x+x^7-x^2-x^4)/(1+x-x^3-x^4), from=0, n=450000, add = TRUE)

...

legend(1,1,legend=c("1","2","3","4","5"), density=c(20,20,20,20,NA), angle=c(90,0,45,135,NA), col=c(NA,NA,NA,NA,"black"), bty="n", cex=1.5, xpd=TRUE)
-------------------------------------------------------------------------------------------------------
lwd plot(rnorm(100)*13)
legend(-0.145, 25, c("(Gaussian) Kernel density","fitted normal distribution"),lwd=0.1, cex=0.8, col=c("black","black"), lty=1:2) plot(rnorm(100)*13)
legend(-0.145, 25, c("(Gaussian) Kernel density","fitted normal distribution"),lwd=3, cex=0.8, col=c("black","black"), lty=1:2)
-------------------------------------------------------------------------------------------------------
windows(width=10, height=8) cex=0.7 bty = "n" \n "topleft" 
legend("topleft", legend=c("(Gaussian)\nKernel\ndensity","Fitted\nnormal\ndistribution\n"),bty = "n",lwd=2, cex=0.7, col=c("black","black"), lty=1:2)
-------------------------------------------------------------------------------------------------------

order= guides() guide_legend() order= colour= linetype= order=1 +guides(fill = guide_legend(keywidth = 2, keyheight = 1,order=2),
        linetype=guide_legend(keywidth = 3, keyheight = 1,order=1),
         colour=guide_legend(keywidth = 6, keyheight = 1,order=1))
-------------------------------------------------------------------------------------------------------
guides bp + guides(fill=guide_legend("Sample"),shape=guide_legend("Sample"))
-------------------------------------------------------------------------------------------------------
xpd par(mfrow=c(2,2), xpd=TRUE)
barplot(tN, col = 2:3)
barplot(tN, col = 2:3)
barplot(tN, col = 2:3)
barplot(tN, col = 2:3)
legend(-4.5, 56,  c("A", "B"), col=2:3,lwd=1) locator()
-------------------------------------------------------------------------------------------------------
locator {graphics} ?locator

legend(locator(1), border=FALSE, fill=FALSE, "try the position")
-------------------------------------------------------------------------------------------------------
border= legend() legend() legend() density= fill= plot(1:4, 1:4, type="n", xaxt="n", xlab="", yaxt="n", ylab="")
polygon(c(2,4,2), c(1,3,3), col="gray")
polygon(c(3,3,1), c(1,3,2), col="red", density=10)
legend("topleft", legend=c("A", "B", "AB"), fill=c("gray", "red", "gray"),
       density=c(NA, 10, NA), bty="n",border=c("black", "red", "black")) 
legend("topleft", legend=c("A", "B", "AB"), fill=c("gray", "red", "red"),
       density=c(NA, 10, 10), bty="n",border=c("black", "red", "black"))
-------------------------------------------------------------------------------------------------------
substitute as.expression atop legend v <- c(
 as.expression(substitute(atop(Qua[0.99]^normal == "", dummy), list(dummy=round(dummy1,4)))),
 as.expression(substitute(atop(Qua[0.95]^normal == "", dummy), list(dummy=round(dummy2,4)))),
 as.expression(substitute(atop(Qua[0.99]^t == "", dummy), list(dummy=round(dummy3,4))))
)
cols <- c("red","black","darkgreen")
legend("topright", legend=v, bty = "n",lwd=2, cex=1, col=cols, text.col=cols, lty=c(1,3,5)) text.col bquote substitute v <- c(
  as.expression(bquote(atop(Qua[0.99]^normal == "", .(round(dummy1,4))))),
  as.expression(bquote(atop(Qua[0.95]^normal == "", .(round(dummy2,4))))),
  as.expression(bquote(atop(Qua[0.99]^t == "", .(round(dummy3,4)))))
 ) bold v <- c(
 as.expression(substitute(atop(Qua[bold(0.99)]^bold(normal) == "", dummy), list(dummy=round(dummy1,4)))),
 as.expression(substitute(atop(Qua[bold(0.95)]^bold(normal) == "", dummy), list(dummy=round(dummy2,4)))),
 as.expression(substitute(atop(Qua[bold(0.99)]^bold(t) == "", dummy), list(dummy=round(dummy3,4))))
) textstyle v <- c(
 as.expression(substitute(atop(Qua[textstyle(0.99)]^textstyle(normal) == "", dummy), list(dummy=round(dummy1,4)))),
 as.expression(substitute(atop(Qua[textstyle(0.95)]^textstyle(normal) == "", dummy), list(dummy=round(dummy2,4)))),
 as.expression(substitute(atop(Qua[textstyle(0.99)]^textstyle(t) == "", dummy), list(dummy=round(dummy3,4))))
)
-------------------------------------------------------------------------------------------------------
c sapply as.expression atop 0,95 0.95 * "," 0 95 . [0,99] [0.99] bquote(atop(foo_0.99^normal ==, .round(bar, 4))) > bquote(atop(foo_0.99^normal ==, .round(bar, 4)))
Error: unexpected ',' in "bquote(atop(foo_0.99^normal ==," == == == phantom() == "" "" phantom() text.col test <- 10:1
dummy1 <- 0.004323423
dummy2 <- 0.054
dummy3 <- 0.032
plot(test, 1:10)

## list of expressions
exprs <-
  list(bquote(atop(Qua_0 * "," * 99^normal == phantom(), .(round(dummy1, 4)))),
       bquote(atop(Qua_0 * "," * 95^normal == phantom(), .(round(dummy2, 4)))),
       bquote(atop(Qua_0 * "," * 99^t == phantom(), .(round(dummy3, 4)))))
## fudge to get them as an expression vector
exprs <- sapply(exprs, as.expression)

cols <- c("red", "black", "darkgreen")
legend("topright", legend = exprs, bty = "n", lwd = 2, cex = 1, col = cols, lty=c(1,3,5), text.col = cols) _ [ ] atop y.intersp legend 2 plot(test, 1:10)

## list of expressions
exprs <-
  list(bquote(atop(Qua[0.99]^normal == phantom(), .(round(dummy1, 4)))),
       bquote(atop(Qua[0.95]^normal == phantom(), .(round(dummy2, 4)))),
       bquote(atop(Qua[0.99]^t == phantom(), .(round(dummy3, 4)))))
## fudge to get them as an expression vector
exprs <- sapply(exprs, as.expression)

cols <- c("red", "black", "darkgreen")
legend("topright", legend = exprs, bty = "n", lwd = 2, cex = 1, col = cols,lty=c(1,3,5), text.col = cols, y.intersp = 2)
-------------------------------------------------------------------------------------------------------
scale_colour_manual scale_colour_discrete(name='', guide=guide_legend(nrow=4)) + scale_colour_manual(values=c("black", "green"), name="", 
              guide=guide_legend(nrow=4)) +
-------------------------------------------------------------------------------------------------------
y <- c(5, 2, 3, 2)
x <- factor(c("A", "B", "C", "A"))
z <- factor(c("D", "E", "F", "E"))

p <- qplot(x, y, geom = "point") +
  theme(axis.text.x = element_text(color = z)) g_legend g_legend<-function(a.gplot){
  tmp <- ggplot_gtable(ggplot_build(a.gplot))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  legend
} x z legends <- list(g_legend(p + geom_point(aes(color = x))),
                g_legend(p + geom_point(aes(color = z)) + 
                          scale_color_manual(values = palette()[as.numeric(z)]))) palette() z <- factor(c(1, 2, 3)) element_text(color = z) geom_point(aes(color = z)) element_text(color = z) plot(1, col = 2) library(gridExtra)
grid.arrange(p + geom_point(aes(color = x)) + guides(color = 'none'), 
             do.call(arrangeGrob, legends), nrow = 1, widths = c(0.8, 0.2))
-------------------------------------------------------------------------------------------------------
require(xts)

X.stock.rtns <- xts(rnorm(1000,0.00001,0.0003), Sys.Date()-(1000:1))
Y.stock.rtns <- xts(rnorm(1000,0.00003,0.0004), Sys.Date()-(1000:1))
Z.stock.rtns <- xts(rnorm(1000,0.00005,0.0005), Sys.Date()-(1000:1))
rtn.obj <- merge(X.stock.rtns , Y.stock.rtns, Z.stock.rtns)
colnames(rtn.obj) <- c("x","y","z")

# advanced charts.PerforanceSummary based on ggplot
gg.charts.PerformanceSummary <- function(rtn.obj, geometric = TRUE, main = "", plot = TRUE)
  {

    # load libraries
    suppressPackageStartupMessages(require(ggplot2))
    suppressPackageStartupMessages(require(scales))
    suppressPackageStartupMessages(require(reshape))
    suppressPackageStartupMessages(require(PerformanceAnalytics))

    # create function to clean returns if having NAs in data
    clean.rtn.xts <- function(univ.rtn.xts.obj,na.replace=0){
    univ.rtn.xts.obj[is.na(univ.rtn.xts.obj)]<- na.replace
    univ.rtn.xts.obj  
  }

    # Create cumulative return function
    cum.rtn <- function(clean.xts.obj, g = TRUE)
    {
      x <- clean.xts.obj
      if(g == TRUE){y <- cumprod(x+1)-1} else {y <- cumsum(x)}
      y
    }

    # Create function to calculate drawdowns
    dd.xts <- function(clean.xts.obj, g = TRUE)
    {
      x <- clean.xts.obj
      if(g == TRUE){y <- Drawdowns(x)} else {y <- Drawdowns(x,geometric = FALSE)}
      y
    }

    # create a function to create a dataframe to be usable in ggplot to replicate charts.PerformanceSummary
    cps.df <- function(xts.obj,geometric)
    {
      x <- clean.rtn.xts(xts.obj)
      series.name <- colnames(xts.obj)[1]
      tmp <- cum.rtn(x,geometric)
      tmp$rtn <- x
      tmp$dd <- dd.xts(x,geometric)
      colnames(tmp) <- c("Index","Return","Drawdown") # names with space
      tmp.df <- as.data.frame(coredata(tmp))
      tmp.df$Date <- as.POSIXct(index(tmp))
      tmp.df.long <- melt(tmp.df,id.var="Date")
      tmp.df.long$asset <- rep(series.name,nrow(tmp.df.long))
      tmp.df.long
    }

    # A conditional statement altering the plot according to the number of assets
    if(ncol(rtn.obj)==1)
    {
      # using the cps.df function
      df <- cps.df(rtn.obj,geometric)
      # adding in a title string if need be
      if(main == ""){
        title.string <- paste("Asset Performance")
      } else {
        title.string <- main
      }

    gg.xts <- ggplot(df, aes_string( x = "Date", y = "value", group = "variable" )) +
      facet_grid(variable ~ ., scales = "free_y", space = "fixed") +
      geom_line(data = subset(df, variable == "Index")) +
      geom_bar(data = subset(df, variable == "Return"), stat = "identity") +
      geom_line(data = subset(df, variable == "Drawdown")) +
      geom_hline(yintercept = 0, size = 0.5, colour = "black") +
      ggtitle(title.string) +
      theme(axis.text.x = element_text(angle = 0, hjust = 1)) +
      scale_x_datetime(breaks = date_breaks("6 months"), labels = date_format("%m/%Y")) +
      ylab("") +
      xlab("")

  } 
 else 
  {
    # a few extra bits to deal with the added rtn columns
    no.of.assets <- ncol(rtn.obj)
    asset.names <- colnames(rtn.obj)
    df <- do.call(rbind,lapply(1:no.of.assets, function(x){cps.df(rtn.obj[,x],geometric)}))
    df$asset <- ordered(df$asset, levels=asset.names)
    if(main == ""){
      title.string <- paste("Asset",asset.names[1],asset.names[2],asset.names[3],"Performance")
    } else {
      title.string <- main
    }

    if(no.of.assets>5){legend.rows <- 5} else {legend.rows <- no.of.assets}

      gg.xts <- ggplot(df, aes_string(x = "Date", y = "value" )) +

      # panel layout
      facet_grid(variable~., scales = "free_y", space = "fixed", shrink = TRUE, drop = TRUE, margin = 
                 , labeller = label_value) + # label_value is default

      # display points for Index and Drawdown, but not for Return
      geom_point(data = subset(df, variable == c("Index","Drawdown"))
                 , aes(colour = factor(asset), shape = factor(asset)), size = 1.2, show_guide = TRUE) + 

      # manually select shape of geom_point
      scale_shape_manual(values = c(1,2,3)) + 

      # line colours for the Index
      geom_line(data = subset(df, variable == "Index"), aes(colour = factor(asset)), show_guide = FALSE) +

      # bar colours for the Return
      geom_bar(data = subset(df,variable == "Return"), stat = "identity"
           , aes(fill = factor(asset), colour = factor(asset)), position = "dodge", show_guide = FALSE) +

      # line colours for the Drawdown
      geom_line(data = subset(df, variable == "Drawdown"), aes(colour = factor(asset)), show_guide = FALSE) +

      # horizontal line to indicate zero values
      geom_hline(yintercept = 0, size = 0.5, colour = "black") +

      # horizontal ticks
      scale_x_datetime(breaks = date_breaks("6 months"), labels = date_format("%m/%Y")) +

      # main y-axis title
      ylab("") +

      # main x-axis title
      xlab("") +

      # main chart title
      ggtitle(title.string)

      # legend 

      gglegend <- guide_legend(override.aes = list(size = 3))

      gg.xts <- gg.xts + guides(colour = gglegend, size = "none") +

      # gglegend <- guide_legend(override.aes = list(size = 3), direction = "horizontal") # direction overwritten by legend.box?
      # gg.xts <- gg.xts + guides(colour = gglegend, size = "none", shape = gglegend) + # Warning: "Duplicated override.aes is ignored"

      theme( legend.title = element_blank()
             , legend.position = c(0,1)
             , legend.justification = c(0,1)
             , legend.background = element_rect()
             , legend.box = "horizontal" # not working?
             , axis.text.x = element_text(angle = 0, hjust = 1)
            )

}

assign("gg.xts", gg.xts,envir=.GlobalEnv)
if(plot == TRUE){
    plot(gg.xts)
} else {}

}

# display chart
gg.charts.PerformanceSummary(rtn.obj, geometric = TRUE) # create a function to store fancy axis labels 

    my_labeller <- function(var, value){ # from the R Cookbook
        value <- as.character(value)
        if (var=="variable") 
        {
              value[value=="Index"] <- "Cumulative Returns"
              value[value=="Return"] <- "Daily Returns"
              value[value=="Drawdown"] <- "Drawdown"
        }
        return(value)
    } theme( legend.title = element_blank()
         , legend.position = c(0,1)
         , legend.justification = c(0,1)
         , legend.background = element_rect()
         #, legend.key = element_rect(fill="white",colour="white")# added as afterthought
         , legend.box = "horizontal" # not working?
         , axis.text.x = element_text(angle = 0, hjust = 1)
         #, axis.title.y = element_text(size=2,colour="black")
         , strip.background = element_rect(fill = 'white')
         , panel.background = element_rect(fill = 'white', colour = 'white')
         , panel.grid.major = element_line(colour = "grey", size = 0.5) 
         , panel.grid.minor = element_line(colour = NA, size = 0.0)
        )
-------------------------------------------------------------------------------------------------------

curve curve(x^(2) / 2,from = 0,to = 100,col = 'red',type = 'p',pch = 16,n = 20)
curve((1-x^(2))/2 + 5000,from = 0,to = 100,col = 'blue',type = 'p',pch = 15,add = TRUE,n = 20)
legend("topleft", inset = c(0,0.4), cex = 1.5, bty = "n", legend = c("A", "B"), text.col = c("red", "blue"),col = c("red", "blue"), pch = c(16,15)) curve add par
-------------------------------------------------------------------------------------------------------
cut() levels() gsub() , - ( [ legend() cuts col=rbPal(10) pch=16 cuts<-levels(cut(a,breaks = 10))
cuts<-gsub(","," - ",cuts)
cuts<-gsub("\\(","[",cuts)
cuts
 [1] "[0.901 - 10.8]" "[10.8 - 20.7]"  "[20.7 - 30.7]"  "[30.7 - 40.6]"  "[40.6 - 50.5]"  "[50.5 - 60.4]"  "[60.4 - 70.3]" 
 [8] "[70.3 - 80.3]"  "[80.3 - 90.2]"  "[90.2 - 100]"  
plot(a,col=b,pch=16)
legend("top",cuts,col=rbPal(10),pch=16)
-------------------------------------------------------------------------------------------------------
legend a <- sample(1:100)
rbPal <- colorRampPalette(c('red','blue'))
b <- rbPal(10)[as.numeric(cut(a,breaks = 10))]
plot(a,col=b,pch=16)
legend('topright', legend=c("[20.7 - 30.7]", "[60.4 - 70.3]"), col=c("#C60038","#5500AA"), pch=16) ggplot2 x <- sample(1:100)
y <- sample(1:100)
fact <- runif(100)
df <- data.frame(x,y,fact)
ggplot(data=df, aes(x=x,y=y,col=fact)) + geom_point()
-------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------
legend plot plot() legend() plot(kmenfprimaria.dos.inicio, ylab="2B. Probabilidad de supervivencia", 
 family="Times Roman", xlab="Tiempo en días", 
 sub="Mediana: LLA 175 IC 95% (142-295); LMA: 159 IC 95% (59-NR). p(log-rank)=0.783",
 ps=3, cex.main=0.9, cex.sub=0.7, cex.lab=0.7, 
 main="Supervivencia por diagnóstico", cex.main=0.9, lty=c(1,2), lwd=2)

 legend(450, 0.8,legend= c("LLA","LMA"), lty=c(1,2), lwd=2)
-------------------------------------------------------------------------------------------------------
ggplot(dat.sub,aes(dat.Freq,color=dat.Function),shape=dat.Function)+ 
  stat_density(geom="path",position="identity",size=0.5)+
  theme(legend.position="bottom",legend.direction="vertical")+
  guides(color=guide_legend(ncol=2))
-------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------
plot(1:10, rnorm(10) * 1:10)
legend("bottomleft", legend = c("entry1"), bty = "n",lwd = 2, cex = 1.2, col = c("black", "blue", "red"), lty = c(1, 1, NA), pch = c(NA, NA, 8))
-------------------------------------------------------------------------------------------------------
set.seed(1)
n = 10
x <- runif(n, min=0, max=2)
y <- runif(n, min=8, max=24)
z <- runif(n, min=0, max=100)

#z to cex function
a <- 1
b <- 0.02
z.cex <- a + b*z

example.cex <- seq(1,3,0.5)
example.z <- (example.cex - a)/b
example.z 


plot(x, y, pch=21, bg="orange", col="red", cex=z.cex, lwd=2, bty="n", xaxt="n", yaxt="n", xlab="", ylab="")
grid()
axis(1, at=seq(0,2,0.5), pos=16, col="green4", lwd=3)
axis(2, at=seq(8,24,4), pos=1, col="green4", lwd=3)
legend("topright", legend=c(example.z), pch=21, pt.bg="orange", col="red", pt.cex=example.cex, title="sales vol.", bg="white")
-------------------------------------------------------------------------------------------------------
bquote .() f<-function(x,alpha=0.9){ .... plot(x) legend("topleft", bquote(.(alpha)) ) } ?plotmath substitute alpha=0.2
 substitute( alpha, list(alpha=alpha) )
 #0.2 bquote x<-seq(0,60,length=150) 
 y<-rnorm(150,0,10) 
 yy<-x+y 
 d<-cbind(x,yy) 
 m<-lm(d[,2]~d[,1]) 
 plot(x,yy) > abline(m) 
 label1<-summary(m)$'r.squared' 
 label2<-summary(m)$'adj.r.squared' 
 legend("topleft", legend=bquote( R^2==.(label1)*";"~Adj.R^2==.(label2) ) )
-------------------------------------------------------------------------------------------------------

ggplot(pd[pd$score1 != 0,], aes(x=x, y=species)) +
  coord_fixed(ratio = 1.5, xlim=c(0.5,16.5), ylim=c(0.5, 3.5)) +
  geom_tile(aes(fill=score1)) +
  scale_fill_gradient2("Score 1", limits=c(0,4),low="#762A83", mid="white", high="#1B7837", guide=guide_colorbar(title.position="top")) +
  geom_text(data=pd, aes(label=letters, size = score2, color=factor(change)), family="mono") +
  scale_size_continuous(range = c(4, 8)) +
  scale_color_manual("Change", values=c("black", "#F2A11F"), labels=c("None", "Some"), guide=guide_
legend(direction="vertical", title.position="top", override.aes=list(shape = "A"))) +
  theme(panel.background=element_rect(fill="white", colour="white"),
        axis.title = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.y = element_text(family="mono", size=rel(2)),
        axis.text.x = element_text(size=rel(0.7)),
        legend.text = element_text(size=rel(0.7)),
        legend.key.size = unit(0.7, "lines"),
        legend.position = "bottom", legend.box = "horizontal") +
  ggtitle("What about Score2?") library(ggplot2)
library(grid)
library(proto)

GeomTile2 <- proto(ggplot2:::GeomTile, {
  reparameterise <- function(., df, params) {
    df <- .$.super$reparameterise(df, params)
    if (params$ud == "u") 
      transform(df, ymin = y) 
    else 
        transform(df, ymax = (y-ymin)*0.8 + ymin, ymin = (y-ymin)*0.2 + ymin)
  }
  draw <- function(..., ud) {.$.super$draw(..., ud)}
})
geom_tile2 <- function (mapping = NULL, data = NULL, stat = "identity", position = "identity", ..., ud = "u") { 
  GeomTile2$new(mapping = mapping, data = data, stat = stat, position = position, ..., ud = ud)
}

ggplot(pd, aes(x=x, y=species)) +
  coord_fixed(ratio = 1.5, xlim=c(0.5,16.5), ylim=c(0.5, 3.5)) +
  geom_tile2(aes(fill=score1), ud = "u") +
  geom_tile2(aes(fill = score2), ud = "d") +
  scale_fill_gradient2("Score 1", limits=c(0,4),low="#762A83", mid="white", high="#1B7837", guide=guide_colorbar(title.position="top")) +
  geom_text(data=pd, aes(label=letters, color=factor(change)), size=rel(5), family="mono") +
  scale_color_manual("Change", values=c("black", "#F2A11F"), labels=c("None", "Some"), guide=guide_legend(direction="vertical", title.position="top", override.aes=list(shape = "A"))) +
  theme(panel.background=element_rect(fill="white", colour="white"),
        axis.title = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.y = element_text(family="mono", size=rel(2)),
        axis.text.x = element_text(size=rel(0.7)),
        legend.text = element_text(size=rel(0.7)),
        legend.key.size = unit(0.7, "lines"),
        legend.position = "bottom", legend.box = "horizontal") +
  ggtitle("What about Score2?")
-------------------------------------------------------------------------------------------------------
bty = "n" ?par bty pch plot.new()
legend(x=0, y=.15, "legend1 ", cex=1, pt.cex=1.4, bty="n", pch=22, col="black",pt.bg="green")
legend(x=.75,y=.15, "legend 2", cex=1, pt.cex =1.4, bty="n", pch=24, col="red", pt.bg="white") pch ?pch
-------------------------------------------------------------------------------------------------------
plot.new()
 legend(x=0,y=.15, c(" legend1"), cex=1,pt.cex =1.4,col=c("green"), bty="o",fill="green", pch=c(15, 15, 15, 17) )
 legend(x=.75,y=.15, " legend", cex=1, pt.cex =1.4,bty="o",col=c("black"), pch=c(17), box.col="red")
-------------------------------------------------------------------------------------------------------
plot.new()
legend(x=0, y=.15, "legend1", cex=1, pt.cex =1.4, bty="n", pch=22, pt.bg = "green")
legend(x=.75, y=.15, "legend2", cex=1, pt.cex =1.4, bty="n", pch=24, pt.bg = "black") pch
-------------------------------------------------------------------------------------------------------
legend("bottom", c("px", "y"), col=c("blue", "red"), lty = c(1), cex = 0.7)
-------------------------------------------------------------------------------------------------------
ggplot(datat, aes(x=Carga, y=Cat.A.88, fill=Vagas)) + 
  geom_bar(stat='identity', position='dodge') + ylab('Vagas') + 
  xlab('Carga horária') + facet_grid(. ~ Categoria) + coord_flip() + 
  guides(fill = guide_legend(reverse=T))
-------------------------------------------------------------------------------------------------------
geom_line() aes() data= groups= ggplot() linetype="dotted" aes() scale_color_manual() guides() guide_legend() ggplot(data, aes(x = x, y= mean, group = as.factor(data$group), 
                          colour=as.factor(data$group))) + 
  geom_line() + geom_point() + 
  geom_line(aes(y=lower),linetype="dotted") + 
  geom_line(aes(y=upper),linetype="dotted")+
  scale_color_manual(name="Groups",values=c("red", "blue"))+
  guides(colour = guide_legend(override.aes = list(linetype = 1)))
-------------------------------------------------------------------------------------------------------
library("ggplot2")
library("scales")
library("chron") y y$Time2 <- as.chron(y$Time1, format="%H:%M")
y$Time2 <- y$Time2 - floor(y$Time2) y > str(y)
'data.frame':   50 obs. of  5 variables:
 $ DATE : Date, format: "2013-04-14" "2013-04-14" ...
 $ Time : POSIXct, format: "2013-04-26 17:14:00" "2013-04-26 17:29:00" ...
 $ CPU  : num  30.4 30.1 30 31 30 ...
 $ Time1: chr  "20:14" "20:29" "20:44" "20:59" ...
 $ Time2:Class 'times'  atomic [1:50] 0.843 0.853 0.864 0.874 0.885 ...
  .. ..- attr(*, "format")= chr "h:m:s" timesreverse_trans <- function() {
    trans <- function(x) {-as.numeric(x)}
    inv <- function(x) {times(-x)}
    fmt <- function(x) {
        notone <- x != 1
        simplify <- !any(diff(x) < 1/(24*60))
        ifelse(notone,
               format(x-floor(x), simplify=simplify),
               ifelse(simplify, "24:00", "24:00:00"))
    }
    trans_new("chrontimes-reverse",
              transform = trans,
              inverse = inv,
              breaks = pretty_breaks(),
              format = fmt,
              domain=c(0,1))
}
scale_y_times <- function(..., trans=NULL) {
    scale_y_continuous(trans=timesreverse_trans(), ...)
} ggplot(y,aes(DATE, Time2, fill=CPU)) + 
  geom_tile() + 
  scale_fill_gradientn(name="CPU Utilization", colours=cols, 
                       values=val, limits=c(0,100), breaks = brk) + 
  scale_x_date(breaks = "1 days", labels=date_format("%a")) + 
  scale_y_times() +
  guides(fill = guide_legend(keywidth = 5, keyheight = 1)) +
  theme_bw()
-------------------------------------------------------------------------------------------------------
guides() colour= guide_legend() override.aes= size= ggplot(iris,aes(Petal.Width,Petal.Length,color=Species))+geom_line()+theme_bw()+
       guides(colour = guide_legend(override.aes = list(size=3))) geom_point(size=0) guides() linetype=0 size=3 ggplot(iris,aes(Petal.Width,Petal.Length,color=Species))+geom_line()+theme_bw()+
       geom_point(size=0)+
       guides(colour = guide_legend(override.aes = list(size=3,linetype=0)))
-------------------------------------------------------------------------------------------------------
ggsave ggplot(DATA, aes(x=factor(0),fill=factor(LABELS),weight=VALUES)) +
   geom_bar(width=1) +
   coord_polar(theta='y') +
   guides(fill=guide_legend(title='LEGEND')) 
ggsave("plot.png", width = 10, height = 5) width height ggsave
-------------------------------------------------------------------------------------------------------
legend(x_position, y_position, legend=c("mm8_12598_altPromoter","mm8_1457_starngeSplice"), col=linecols, pch=15, bty="o")
-------------------------------------------------------------------------------------------------------
override.aes= guides() color= shape=c(NA,16) linetype=c(1,0) ggplot(df) +
  geom_line(aes(id, line, colour = "line")) +
  geom_point(aes(id, points, colour = "points"))+
  guides(color=guide_legend(override.aes=list(shape=c(NA,16),linetype=c(1,0))))
-------------------------------------------------------------------------------------------------------
geom xx.sub1.df geom geom_point p <- ggplot(xx.sub2.df) + 
  aes(long, lat, fill = (SID79/BIR79)*1000, group = group) + 
  geom_polygon() + geom_path(color="grey80") +
  coord_equal() + 
  scale_fill_gradientn(colours = brewer.pal(7, "YlOrBr")) +
  geom_polygon(data = xx.sub1.df, fill = "grey50") + 
  geom_path(data = xx.sub1.df, color="grey80") +
  labs(fill = "Mapped value", title = "Title")

#Now we add geom_point() setting shape as NA, but the colour as "grey50", so the 
#legend will be displaying the right colour

p2 <- p + geom_point(data = xx.sub1.df, aes(size="xx.sub1", shape = NA), colour = "grey50") p2 + guides(size=guide_legend("Source", override.aes=list(shape=15, size = 10)))
-------------------------------------------------------------------------------------------------------
orditkplot() ordispider() ordispider() require("vegan")
data(dune)
data(dune.env)

mod <- decorana(dune)

plot(mod, display = "sites", type = "n")

## colour & shape according to Management
col <- c("red","orange","forestgreen","navy")
pch <- 1:4
## add the points
with(dune.env,
     points(mod, display = "sites", col = col[Management],
            pch = pch[Management]))
## add a legend
legend("topright",legend = with(dune.env, levels(Management)),col = col, pch = pch, title = "Management",bty = "n") locator() plot(mod, display = "sites", type = "p")
with(dune.env, ordispider(mod, groups = Management, col = "red"))
## select 4 locations
coords <- locator(with(dune.env, length(levels(Management))))

## now you have to click on the plot where you want the labels
## automagically finishes after you click the 4th label in this case

## draw labels
text(coords, labels = with(dune.env, levels(Management)))
-------------------------------------------------------------------------------------------------------
pch legend("topright",legend=c("Gini < 0.05","Gini > 0.6"), pch=15,col=cols)
-------------------------------------------------------------------------------------------------------
legend("topright",legend=c("Gini < 0.05","Gini > 0.6"), pch=15, col=cols)
-------------------------------------------------------------------------------------------------------
+ guides(col=guide_legend(ncol=2))
-------------------------------------------------------------------------------------------------------
?points with(data.cold,plot(date,death,pch=".", ylab= expression("Mortality Count"), main = "Daily Mortality in cold season"))
with(data.warm ,points(date,death,pch=".", ylab= expression("Mortality Count"), main = "Daily Mortality in warm season", col="red"))
legend("topright", c("cold", "warm"), fill=c("black", "red"))
-------------------------------------------------------------------------------------------------------
library(vcd)
par(mar=c(6,4,5,4)+0.1)
plot(0,type="n")

g = grid_legend(0.5, 0.5, pch=c(22,22), col=c("red"),gp=gpar(fill = c("Darkgreen")),labels=c("Control Chemical","Test Chemicals"), title = "Legend Title", draw=FALSE)

grid.draw(grobTree(g, vp=viewport(x=0.93,angle=-90)))
-------------------------------------------------------------------------------------------------------
cex(.something) cex legend() plot(meuse, pch=16)
legend("topleft", "Example Text", cex=2)
-------------------------------------------------------------------------------------------------------
plot(rnorm(10))
legend("top", legend="test", pch=21) #everything is normal sized (cex=1 default from par())
legend("topleft", legend="test", pch=21, cex=0.5) #everything is small
legend("topright", legend="test", pch=21, pt.cex=1, cex=0.5) #the point is normal, but the rest is small
-------------------------------------------------------------------------------------------------------
pt.cex = 1 cex plot(c(1,1))
legend("topleft", "Legend", cex=1.3, pch=1, pt.cex = 1)
-------------------------------------------------------------------------------------------------------
fill override.aes= guides() color= fill= scale_color_manual() p +  scale_color_discrete(labels=c("a"=expression(a[{foo}]),
                                   "b"=expression(b[{bar}]))) +
  scale_fill_discrete(guide="none")+
  guides(color=guide_legend(override.aes=list(fill=c("#F8766D","#00BFC4"))))
-------------------------------------------------------------------------------------------------------
gridExtra grid.arrange() p1.leg <- ggplot(dsamp,aes(price,carat,colour=clarity))+geom_point()
p1<-ggplot(dsamp,aes(price,carat,colour=clarity))+geom_point()+
      theme(legend.position="none")
p2 <-ggplot(dsamp,aes(price,depth,colour=clarity))+geom_point()+
     theme(legend.position="none") g_legend() g_legend <- function(a.gplot){
  tmp <- ggplot_gtable(ggplot_build(a.gplot))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)}

leg<-g_legend(p1.leg) arrangeGrob() grid.arrange() arrangeGrob() library(gridExtra)
grid.arrange(arrangeGrob(arrangeGrob(p1,p2),leg,ncol=2,widths=c(5/6,1/6))) grid.arrange(arrangeGrob(p1,p2,leg,ncol=3,widths=c(3/7,3/7,1/7)))
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(grid)

pd = data.frame(
  letters = strsplit("AGTGACCGACTATCATAGTGACCCAGAATCATAGTGACCGAGTATGAT", "")[[1]],
  species = rep(c("Human", "Armadillo", "Porcupine"), each=16),
  x       = rep(1:16, 3),
  change  = c(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
              0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,
              0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0),
  score1  = c(0,0,0,0,0,0,1,1,2,2,2,3,3,3,4,3,
              0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,
              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),
  score2  = c(0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,
              0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,
              0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0)
)


p1=ggplot(pd[pd$score1 != 0,], aes(x=x, y=species)) +
  coord_fixed(ratio = 1.5, xlim=c(0.5,16.5), ylim=c(0.5, 3.5)) +
  geom_tile(aes(fill=score1)) +
  scale_fill_gradient2("Score 1", limits=c(0,4),low="#762A83", mid="white", high="#1B7837", guide=guide_colorbar(title.position="top")) +
  geom_text(data=pd, aes(label=letters, color=factor(change)), size=rel(5), family="mono") +
  scale_color_manual("Change", values=c("black", "#F2A11F"), labels=c("None", "Some"), guide=guide_legend(direction="vertical", title.position="top", override.aes=list(shape = "A"))) +
  theme(panel.background=element_rect(fill="white", colour="white"),
        axis.title = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.y = element_text(family="mono", size=rel(2)),
        axis.text.x = element_text(size=rel(0.7)),
        legend.text = element_text(size=rel(0.7)),
        legend.key.size = unit(0.7, "lines"),
        legend.position = "bottom", legend.box = "horizontal") +
  ggtitle("Voila, the Score2!")

p2=ggplot(pd[pd$score2 != 0,], aes(x=x, y=species)) +
  coord_fixed(ratio = 1.5, xlim=c(0.5,16.5), ylim=c(0.5, 3.5)) +
  geom_tile(aes(fill=score2)) +
  scale_fill_gradient2("Score 2", limits=c(0,3),low="#1B7837", mid="white", high="#762A83", guide=guide_colorbar(title.position="top")) +
  geom_text(data=pd, aes(label=letters, color=factor(change)), size=rel(5), family="mono") +
  scale_color_manual("Change", values=c("black", "#F2A11F"), labels=c("None", "Some"), guide=guide_legend(direction="vertical", title.position="top", override.aes=list(shape = "A"))) +
  theme(panel.background=element_rect(fill="white", colour="white"),
        axis.title = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.y = element_text(family="mono", size=rel(2)),
        axis.text.x = element_text(size=rel(0.7)),
        legend.text = element_text(size=rel(0.7)),
        legend.key.size = unit(0.7, "lines"),
        legend.position = "bottom", legend.box = "horizontal") +
  ggtitle("What about Score2?")


p1g=ggplotGrob(p1)
p2g=ggplotGrob(p2)

combo.grob = p1g

combo.grob$grobs[[8]] = cbind(p1g$grobs[[8]][,1:4], 
                              p2g$grobs[[8]][,3:5], 
                              size="first")

combo.grob$grobs[[4]] = reorderGrob(
                          addGrob(p1g$grobs[[4]], 
                                  getGrob(p2g$grobs[[4]], 
                                          "geom_rect.rect", 
                                          grep=TRUE)), 
                          c(1,2,5,3,4))
grid.newpage()
grid.draw(combo.grob)
-------------------------------------------------------------------------------------------------------
bquote .() legend(locator(1), legend= bquote("Linear model: "* R^2*.(ps)), 
        text.col= "red",cex=1,bty="n") paste legend(locator(1), expression(Linear~model*":"~ R^2 == 0.1234),
    text.col= "black",cex=1,bty="n")
-------------------------------------------------------------------------------------------------------
color=variable linetype=variable aes() ggplot() geom_vline() geom_point() aes() color="s.mean" linetype="s.mean" scale_color"manual() scale_linetype_manual() guides() override.aes= ggplot(sdata.m, aes(x=value, color=variable,linetype=variable))+
  stat_ecdf(size=1)+
  geom_vline(data=ddata.m,
             aes(xintercept = value,color=variable,linetype=variable),
             size=2) +
  geom_point(aes(x=mean(sdata.m$value[sdata.m$variable=="s.a"]),
       color="s.mean",linetype="s.mean",y=.5),size = 5) +
  geom_point(aes(x=mean(sdata.m$value[sdata.m$variable=="s.b"]),
        color="s.mean",linetype="s.mean",y=.5),size = 5)+
  scale_color_manual(breaks=c("d.a","d.b","s.a","s.b","s.mean"),
                     values=c("blue","blue","red","red","green"))+
  scale_linetype_manual(breaks=c("d.a","d.b","s.a","s.b","s.mean"),
                     values=c(1,2,1,2,0))+
  guides(color=guide_legend(override.aes=list(shape=c(NA,NA,NA,NA,16))))
-------------------------------------------------------------------------------------------------------
ggplot(sdata.m, aes(x=value, color=variable,linetype=variable,shape=variable))+
  stat_ecdf(size=1)+
  geom_vline(data=ddata.m,
             aes(xintercept = value,color=variable,linetype=variable,shape=variable),
             size=2) +
  geom_point(aes(x=mean(sdata.m$value[sdata.m$variable=="s.a"]),
                 color="s.a.mean",linetype="s.a.mean",shape="s.a.mean",
                 y=.5),size = 5) +
  geom_point(aes(x=mean(sdata.m$value[sdata.m$variable=="s.b"]),
                 color="s.b.mean",linetype="s.b.mean",shape="s.b.mean",
                 y=.5),size = 5) +
  scale_shape_manual(breaks=c("d.a","d.b","s.a","s.a.mean","s.b","s.b.mean"),
                     values=c(16,16,16,16,16,16)) +
  scale_color_manual(breaks=c("d.a","d.b","s.a","s.a.mean","s.b","s.b.mean"),
                     values=c("blue","red","blue","blue","red","red"))+
  scale_linetype_manual(breaks=c("d.a","d.b","s.a","s.a.mean","s.b","s.b.mean"),
                        values=c(2,2,1,0,1,0))+
  guides(color=guide_legend(override.aes=list(shape=c(NA,NA,NA,16,NA,16))))
-------------------------------------------------------------------------------------------------------
p + guides(fill=guide_legend(keyheight=unit(1,"cm"))) + theme(plot.margin=unit(c(1,1,1,1),"cm"))
showViewport(col="black",label=TRUE, newpage=TRUE, leaves=FALSE) library(gtable)
g = ggplotGrob(p)
leg = gtable_filter(g, "guide")
plot(leg)
leg$heights
# sum(0.5lines, sum(1.5mm, 10mm, 0mm, 1.5mm), 0.5lines)+0cm
grid.rect(height=leg$heights) 
grid.rect(height=leg$heights - unit(1,"line"), gp=gpar(lty=2)) guide.margin
-------------------------------------------------------------------------------------------------------
p+geom_jitter(data=df, aes(x=x, y=y, color=value, size = value)) 
+scale_size_continuous(name = "Legend Name", breaks= c(.25, .50,.75), labels=c(".25",".50",".75"))+scale_colour_gradient(name = "Legend Name", breaks= c(.25, .50,.75), labels=c(".25", ".50",".75"))+ 
guides(colour = guide_legend())
-------------------------------------------------------------------------------------------------------
OxTemp <- read.table("http://pastebin.com/raw.php?i=37zUkaA4",header=TRUE,stringsAsFactors=FALSE)

library(ggplot2)
OxTemp$Month <- factor(OxTemp$Month, 
                       levels=c("Jan", "Feb", "Mar","Apr", "May", "Jun","Jul", "Aug", "Sep", "Oct", "Nov", "Dec"), ordered=TRUE)
OxTemp$Season <- factor(OxTemp$Season, 
                       levels=c("Spring", "Summer", "Autumn", "Winter"), ordered=TRUE)

library(plyr)
slopedat <- ddply(OxTemp,.(Month),function(df) data.frame(slope=format(signif(coef(lm(MaxT~Year,data=df))[2],2),scientific=-2),
                                                          y=max(predict(lm(MaxT~Year,data=df)))))



p <- ggplot(OxTemp, aes(x=Year, y=MaxT)) + 
  geom_smooth(aes(group=Month, colour=Season, linetype=Month),method = 'lm',size = 1, se = F) +
  scale_colour_manual(values=c("Winter"= 4, "Spring" = 1, "Summer" = 2,"Autumn" = 3)) +
  geom_text(data=slopedat,aes(x=2005,y=y,label=paste0("slope = ",slope))) +
  scale_x_continuous(limits=c(1950, 2010)) +
  guides(linetype=guide_legend(override.aes=list(colour=c("Jan"= 4, "Feb" = 4, "Mar" = 1,
                                                          "Apr" = 1, "May" = 1, "Jun" = 2,
                                                          "Jul" = 2, "Aug" = 2, "Sep" = 3, 
                                                          "Oct" = 3, "Nov" = 3, "Dec" = 4)),keywidth=5))

print(p)
-------------------------------------------------------------------------------------------------------
data <- read.csv("stackfig1_2.csv")
library(Hmisc)

label1=c(0,100,200,300)
plot(data$TimeVariable2C,data$Variable2C,axes=FALSE,ylab="",xlab="",xlim=c(0,24),
     ylim=c(0,2.4),xaxs="i",yaxs="i",pch=19)
lines(data$TimeVariable3C,data$Variable3C)
axis(2,tick=T,at=seq(0.0,2.4,by=0.6),label= seq(0.0,2.4,by=0.6))
axis(1,tick=T,at=seq(0,24,by=6),label=seq(0,24,by=6))
mtext("(C)",side=1,outer=F,line=-10,adj=0.8)
minor.tick(nx=5,ny=5)

par(new=TRUE)
plot(data$TimeVariable1C,data$Variable1C,axes=FALSE,xlab="",ylab="",type="l",
     ylim=c(800,0),xaxs="i",yaxs="i")
axis(3,xlim=c(0,24),tick=TRUE,at= seq(0,24,by=6),label=seq(0,24,by=6),col.axis="violetred4",col="violetred4")
axis(4,tick=TRUE,at= label1,label=label1,col.axis="violetred4",col="violetred4")
polygon(data$TimeVariable1C,data$Variable1C,col='violetred4',border=NA)


legend("top", legend = c("Variable A","Variable B","Variable C"), col = c("black","violetred4","black"),ncol = 2, lwd =c("","",2),pch=c(19,15,NA),cex=1) cex
-------------------------------------------------------------------------------------------------------
cols <- c("LINE1"="#f04546","LINE2"="#3591d1","BAR"="#62c76b")
ggplot(data=data,aes(x=a)) + 
  geom_bar(stat="identity", aes(y=h, fill = "BAR"),colour="#333333")+ #green
  geom_line(aes(y=b,group=1, colour="LINE1"),size=1.0) +   #red
  geom_point(aes(y=b, colour="LINE1"),size=3) +           #red
  geom_errorbar(aes(ymin=d, ymax=e, colour="LINE1"), width=0.1, size=.8) + 
  geom_line(aes(y=c,group=1,colour="LINE2"),size=1.0) +   #blue 
  geom_point(aes(y=c,colour="LINE2"),size=3) +           #blue
  geom_errorbar(aes(ymin=f, ymax=g,colour="LINE2"), width=0.1, size=.8) + 
  scale_colour_manual(name="Error Bars",values=cols) + scale_fill_manual(name="Bar",values=cols) +
  ylab("Symptom severity") + xlab("PHQ-9 symptoms") +
  ylim(0,1.6) +
  theme_bw() +
  theme(axis.title.x = element_text(size = 15, vjust=-.2)) +
  theme(axis.title.y = element_text(size = 15, vjust=0.3)) + theme(legend.key = element_rect(fill = "white",colour = "white")) guide = guide_legend(fill = NULL,colour = NULL) ggplot(data=data,aes(x=a)) + 
  geom_bar(stat="identity", aes(y=h,fill = "BAR", colour="BAR"))+ #green
  geom_line(aes(y=b,group=1, colour="LINE1"),size=1.0) +   #red
  geom_point(aes(y=b, colour="LINE1", fill="LINE1"),size=3) +           #red
  geom_errorbar(aes(ymin=d, ymax=e, colour="LINE1"), width=0.1, size=.8) + 
  geom_line(aes(y=c,group=1,colour="LINE2"),size=1.0) +   #blue 
  geom_point(aes(y=c,colour="LINE2", fill="LINE2"),size=3) +           #blue
  geom_errorbar(aes(ymin=f, ymax=g,colour="LINE2"), width=0.1, size=.8) + 
  scale_colour_manual(name="Error Bars",values=cols, guide = guide_legend(fill = NULL,colour = NULL)) + 
  scale_fill_manual(name="Bar",values=cols, guide="none") +
  ylab("Symptom severity") + xlab("PHQ-9 symptoms") +
  ylim(0,1.6) +
  theme_bw() +
  theme(axis.title.x = element_text(size = 15, vjust=-.2)) +
  theme(axis.title.y = element_text(size = 15, vjust=0.3)) override.aes guide_legend ggplot(data=data,aes(x=a)) + 
  geom_bar(stat="identity", aes(y=h,fill = "BAR", colour="BAR"))+ #green
  geom_line(aes(y=b,group=1, colour="LINE1"),size=1.0) +   #red
  geom_point(aes(y=b, colour="LINE1", fill="LINE1"),size=3) +           #red
  geom_errorbar(aes(ymin=d, ymax=e, colour="LINE1"), width=0.1, size=.8) + 
  geom_line(aes(y=c,group=1,colour="LINE2"),size=1.0) +   #blue 
  geom_point(aes(y=c,colour="LINE2", fill="LINE2"),size=3) +           #blue
  geom_errorbar(aes(ymin=f, ymax=g,colour="LINE2"), width=0.1, size=.8) + 
  scale_colour_manual(name="Error Bars",values=cols, 
                      guide = guide_legend(override.aes=aes(fill=NA))) + 
  scale_fill_manual(name="Bar",values=cols, guide="none") +
  ylab("Symptom severity") + xlab("PHQ-9 symptoms") +
  ylim(0,1.6) +
  theme_bw() +
  theme(axis.title.x = element_text(size = 15, vjust=-.2)) +
  theme(axis.title.y = element_text(size = 15, vjust=0.3))
-------------------------------------------------------------------------------------------------------
title.hjust p <- p + guides(colour=guide_legend(title.position="top", 
                                     title.hjust =0.5))
-------------------------------------------------------------------------------------------------------
dat <- data.frame(distance <- seq(-1500 ,1500 ,25),
                  A=rnorm(length(distance),mean=0,sd=0.1),
                  B=rnorm(length(distance),mean=0,sd=0.09))

plot(dat[,c(1,2)],type="l",
     col="blue",
     main="My Title",
     xlab="My X Label",
     ylab="My Y Label",
     axes=F)
lines(dat[,c(1,3)],type="l",col="red")

axis(1, pos=0,las=1)
axis(2, pos=0,las=1)

legend("topright", pch = c("-","-"), 
col = c("blue", "red"), legend = c("A", "B"))
-------------------------------------------------------------------------------------------------------
plot(c(1,20), c(0,3), type="n")
xx <- c(0,1,1,0)
thelabels <- paste(1:20, " ", LETTERS[1:20], LETTERS[1:20], sep="")
for (i in 1:20){
  polygon(xx, c(0,0,1,1))
  text(mean(xx), 0.5, i)
  xx <- xx + 1
}
legend("topleft", "groups", legend = thelabels, pch="",ncol=4)
-------------------------------------------------------------------------------------------------------
# Multidimensional scaling
library(MASS)
set.seed(1)
labels <- as.factor(sample(LETTERS[1:5], 100, replace=TRUE))
dat <- mvrnorm(n=100, mu = c(1:4), Sigma=matrix(1:16, ncol=4)) + as.numeric(labels)^2
#> dim(dat)
#[1] 100   4

# Euclidean distance matrix (100x100)
d <- dist(dat)

# Classical MDS for distance matrix d
# http://en.wikipedia.org/wiki/Multidimensional_scaling
mds <- cmdscale(d, k = 2)
x <- mds[,1]
y <- mds[,2]

plot(x,y, col=rainbow(5)[as.numeric(labels)], pch=16, main="MDS for object 'dat'")
legend("topright", legend=unique(labels), col=rainbow(5)[unique(as.numeric(labels))], pch=16)
-------------------------------------------------------------------------------------------------------
leg<-as.factor(paste("m =",c(b1,c1,d1)))
legend("bottomright", levels(leg), lwd=1, lty=1, col=c(1,2,3), cex=1.25)
-------------------------------------------------------------------------------------------------------
lgnd <- c(bquote(italic(b)[1] == .(b1)*m),
          bquote(italic(c)[1] == .(c1)*m),
          bquote(italic(d)[1] == .(d1)*m))
legend(2,4, as.expression(lgnd))
-------------------------------------------------------------------------------------------------------
legend(...expression(""<="1.0"),col="gray"...) ?plotmath expression() x <- 0:64/64
y <- sin(3*pi*x)
plot(x, y, type= "l", col= "blue",
     main= expression("How to add the symbol"<="to a legend"))
points(x, y, pch= 1, bg= "white")
legend(.4,1, expression(""<= "1.0"), pch= 1, pt.bg= "white", lty= 1, col= "blue")
-------------------------------------------------------------------------------------------------------
layout(1:2, heights=c(1, 5))

# Legend panel
par(mar=rep(0,4))
plot(0, 0, type="n", ann=FALSE, axes=FALSE)
legend("center", c("5-10 cm", "15-20 cm", "25-30 cm"), horiz=TRUE,lty=2:4, col=1:3)

# Plot panel
par(mar=c(5,4,0,2))
plot(1:20, cumsum(rnorm(20))) par(new=TRUE) par(mar=c(5,4,5,2))
plot(1:20, cumsum(rnorm(20)))

par(new=TRUE, mar=c(0,0,1,0))
plot(0, 0, type="n", ann=FALSE, axes=FALSE)
legend("top", c("5-10 cm", "15-20 cm", "25-30 cm"), horiz=TRUE, lty=2:4, col=1:3)
-------------------------------------------------------------------------------------------------------
inset par(mar=c(5, 5, 6, 3), xpd=TRUE)

plot(time, layer_0, ylim=c(0,1), type="o", lty=1, lwd=2,ylab="Longitudinal fCOVER",     xlab="Days after seeding", cex.lab=1.5, cex.axis=1.5, cex.main=1.5, cex.sub=1.5)
segments(time, layer_0-layer_0_sd,time, layer_0+layer_0_sd, lwd=2)
segments(time-epsilon,layer_0-layer_0_sd,time+epsilon,layer_0-layer_0_sd, lwd=2)
segments(time-epsilon,layer_0+layer_0_sd,time+epsilon,layer_0+layer_0_sd, lwd=2)

for (i in c(1:5)){ 
  par(new=TRUE)
  eval(parse(text=paste("plot(time, layer_",i,", ylim=c(0,1), type='o', xlab='',     ylab='', xaxt='n', yaxt='n',lwd=2, lty=",i+1,", col=",i+1,")+
  segments(time, layer_",i,"-layer_",i,"_sd,time, layer_",i,"+layer_",i,"_sd,     col=",i+1,",lwd=2)+
  segments(time-epsilon,layer_",i,"-layer_",i,"_sd,time+epsilon,layer_",i,"-layer_",i,"_sd, col=",i+1,",lwd=2)+
  segments(time-epsilon,layer_",i,"+layer_",i,"_sd,time+epsilon,layer_",i,"+layer_",i,"_sd, col=",i+1,",lwd=2)", sep="")))
}

legend("top", inset = c(0, -0.25), legend=c("0-5 cm","5-10 cm", "10-15 cm", "15-20 cm", "20-25 cm","25-30 cm"), lty=c(1,2,3,4,5,6), col=c(1,2,3,4,5,6),ncol=3, lwd=2, cex=1.5)
-------------------------------------------------------------------------------------------------------
n.cases n.cases ncases output$mydata() mydata <- reactive(f(input$n.cases,
  input$p0,
  input$OR.cas.ctrl,
  input$Nh,
  input$sig.level)) output$powHap() output$powHap <- renderPlot(
{
   print(ggplot(data = mydata(), aes(ncases, power)) + 
     theme_bw() + 
     theme(text=element_text(family="Helvetica", size=12)) + 
     labs(title = "Ad-hoc power for haplogroup") +
     scale_color_brewer(palette = "Dark2", guide = guide_legend(reverse=TRUE)) +
     xlab("number of cases/controls") +
     ylab("power") +
     scale_x_log10() +
     geom_line(alpha=0.8, size=0.2) +
     geom_point(aes(shape = factor(OR)), colour="black"))
}) data = mydata() data = output$mydata output$mydata
-------------------------------------------------------------------------------------------------------
ggplot2 boxplot bxp xypolygon my.bxp <- function (all.bxp.argument,angle,density, ...) {
    .....#### bxp code
    xypolygon(xx, yy, lty = boxlty[i], lwd = boxlwd[i], 
    border = boxcol[i],angle[i],density[i])  
    .......## bxp code after
    xypolygon(xx, yy, lty = "blank", col = boxfill[i],angle[i],density[i])      
    ......

} require(stats)
set.seed(753)
(bx.p <- boxplot(split(rt(100, 4), gl(5, 20))))
layout(matrix(c(1,2),nrow=1),
       width=c(4,1)) 
angles=c(60,30,40,50,60)
densities=c(50,30,40,50,30)
par(mar=c(5,4,4,0)) #Get rid of the margin on the right side
my.bxp(bx.p,angle=angles,density=densities)
par(mar=c(5,0,4,2)) #No margin on the left side
plot(c(0,1),type="n", axes=F, xlab="", ylab="")
legend("top", paste("region", 1:5),angle=angles,density=densities)
-------------------------------------------------------------------------------------------------------
xlim ylim col.01line x1 = runif(100)
x2 = runif(100)
x3 = runif(100)
plot.ecdf(x1, col="blue", main="Distribution XYZ",xlab="x_i", ylab="Prob(x_i<=y)", ylim=c(0, 1), xlim=c(0,1), col.01line="white", verticals=FALSE)
lines(ecdf(x2), col="red", col.01line="white")
lines(ecdf(x3), col="green", col.01line="white")
legend(600,0.6,c("x1","x2","x3"), lty=c(1,1,1), lwd=c(1,1,1),col=c("blue","red","green")) plot f1 = ecdf(x1)
f2 = ecdf(x2)
f3 = ecdf(x3)
pts = seq(0, 1, 0.01)
plot(pts, f1(pts), col="blue", type="b", xlab="x_i", ylab="Prob(x_i<=y)", pch=16, main="Distribution XYZ")
lines(pts, f2(pts), col="red", type="b", pch=16)
lines(pts, f3(pts), col="green", type="b", pch=16)
legend("topleft", c("x1","x2","x3"), fill=c("blue","red","green"))
-------------------------------------------------------------------------------------------------------
plot.ecdf(x1, col="blue",
     main="Distribution XYZ",
     xlab="x_i", ylab="Prob(x_i<=y)", 
     xaxs="i",yaxs="i", xlim=c(0,1000) )

lines(ecdf(x2), col="red")    
lines(ecdf(x3), col="green")  
legend(600,0.6, c("x1","x2","x3"), lty=c(1,1,1), lwd=c(1,1,1),col=c("blue","red","green"))
-------------------------------------------------------------------------------------------------------
grid.arrange(arrangeGrob(dataleg, pvalleg, nrow=1, ncol=2, widths=c(unit(1, "npc"), unit(5, "cm"))), stat, nrow=2, heights=c(unit(.2, "npc"), unit(.8, "npc"))) h <- ggplot(data.frame(a=rnorm(10), b=rnorm(10), c=factor(rbinom(10, 1,.5), labels=c("Gene segments", "Model")), d=factor("")), 
        aes(x=a, y=b)) +
   geom_line(aes(color=c), size=1.3) + geom_polygon(aes(fill=d)) +
   scale_color_manual(values=c("blue", "red"), name="Data type") + 
   scale_fill_manual(values="gray", name="P-value") 
 g_legend<-function(a.gplot){
   tmp <- ggplot_gtable(ggplot_build(a.gplot))
   leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
   legend <- tmp$grobs[[leg]]
   return(legend)
 }
 legend <- g_legend(h)

 grid.arrange(stat, legend, nrow=1, ncol=2, widths=c(unit(.8, "npc"), unit(.2, "npc")))
 grid.arrange(legend, stat, nrow=2, ncol=1, heights=c(unit(.2, "npc"), unit(.8, "npc")))
-------------------------------------------------------------------------------------------------------
meanqual 1:length(meanqual) seq() length meanqual plot plot <- plot(x=seq(5,90,5), y=meanqual, type="o", 
             xlab="% Size of Wave", ylab="Values",xaxt='n', lty=1)
legend('bottomright', c("Values"),pch=21, lty=1, cex=1)
axis(side=1, at= seq(10,90,5), labels=seq(10,90,5))
-------------------------------------------------------------------------------------------------------
speed <- structure(list(A = c(3.59e-05, 3.75e-05, 9.67e-05, 3.92e-05,
  2.14e-05, 9.8e-05, 0.000228481, 0.000228481, 0.000415583, 0.000859052,  
0.002014948, 0.004079371, 0.00406138, 0.004353728, 0.008455587,     
0.007780939, 0.018260469, NA, NA, NA, NA, NA, NA), B = c(4.76, 6.28, 10.5,
 10.6, 12.3, 12.8, 16, 16.8, 20.7, 25.2, 34.4, 36.4, 37.7, 43.6, 48.7, 49.2,
 66.5, NA, NA, NA, NA, NA, NA), C = c(1.734691244, 2.016976959, 1.707373272, 
1.461511521, 0.805880184, 0.417509677, 0.427070968, 0.220364977, 0.21763318, 
0.170282028, 0.169826728, 0.095612903, 0.094247005, 0.048717051, 0.044072995, 
0.034921475,  0.023721106, 0.022901567, 0.018485161, 0.015252535, 0.008240922, 
 0.003942894, 0.002868387), D = c(176, 175, 169, 169, 169, 162, 161, 146, 146,
 143, 143, 121, 117, 90, 90, 77.7, 70.3, 69.2, 67, 59.6, 50.4, 36.1, 33.7), 
E = c(0.0235, 0.044636324, 0.075155479, 0.072909589, 0.09736484, 0.0988621, 
0.199428082, 0.202422603, 0.362878995, 0.370365297, 0.355392694, 1.438410959, 
0.727212329,  0.722221461, 1.40597032, NA, NA, NA, NA, NA, NA, NA, NA), 
F = c(69L, 90L, 111L, 114L, 114L, 116L, 143L, 146L, 161L, 163L, 164L, 170L, 
172L, 175L, 180L, NA, NA, NA, NA, NA, NA, NA, NA), G = c(35.29300714, 
17.47300714, 4.351007143, 3.182292857, 3.182292857, 1.411864286, 1.435007143,
 NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,  NA, NA, NA, NA), H = c(180L, 180L, 180L, 180L, 177L, 175L, 171L,  NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,
 NA, NA, NA, NA, NA, NA ), I = c(0.021, 0.0258, 0.029929032, 0.034574194, 
0.064612903,   0.088870968, 0.17816129, 0.163967742, NA, NA, NA, NA, NA, 
NA,NA, NA, NA, NA, NA, NA, NA, NA, NA), J = c(67, 68.7, 75.2, 84.6,  115,
 121, 152, 155, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA)), 
.Names = c("A", "B", "C", "D", "E", "F", "G", "H", "I", "J"),
 class = "data.frame", row.names = c(NA, -23L)) plot(speed$A,speed$B,xlim=range(1e-5:100),ylim=range(0:200),xlab="Time",ylab="Distance",pch=19,log="x")
points(speed$C,speed$D,col="red",pch=21)
points(speed$E,speed$F,col="blue",pch=18)
points(speed$G,speed$H,col="yellow",pch=19)
points(speed$I,speed$J,col="green",pch=20)
legend("top", legend = c("Car 1","Car 2","Car 3","Car 4","Car 5"), col = c("black","red","blue","yellow","green"),ncol = 2,pch=c(19,21,18,19,20)) library(ggplot2)
ggplot(speed,aes(A,B))+geom_point()+xlim(1e-5,100)+ylim(0,200)+scale_x_log10()+
  geom_point(data=speed,aes(C,D),col="red")+geom_point(data=speed,aes(E,F),col="blue")+
  geom_point(data=speed,aes(G,H),col="green")+geom_point(data=speed,aes(I,J),col="orange",shape=2)+
  xlab("Distance")+ylab("Distance") ## Separate the data by cars
car1 <- speed[,c(1,2)]
car1$id <- "Car1"
car2 <- speed[,c(3,4)]
car2$id <- "Car2"
car3 <- speed[,c(5,6)]
car3$id <- "Car3"
car4 <- speed[,c(7,8)]
car4$id <- "Car4"
car5 <- speed[,c(9,10)]
car5$id <- "Car5"
names(car1)<- names(car2) <- names(car3) <- names(car4) <- names(car5)<- c("distance","speed","id") myspeed <- rbind(car1,car2,car3,car4,car5) ggplot(myspeed,aes(distance,speed))+geom_point(aes(color=id))+xlim(1e-5,100)+ylim(0,200)+scale_x_log10()
-------------------------------------------------------------------------------------------------------
inset= legend plot(1:10)
legend("topleft","blah",inset=0.05) plot(1:10)
xyratio <- do.call("/",as.list(par("pin")))
inset.amount <- 0.05
legend("topleft","blah",inset=c(inset.amount,inset.amount * xyratio))
-------------------------------------------------------------------------------------------------------
windows()
  plot(x, y, type="l", lwd=2, col="blue", ylim=c(0, 12), xaxs="i", yaxs="i")
  lines(x,z, lwd=2, col="red")
  legend("topleft", legend=c("y","z"), lwd=c(2,2), col=c("blue","red")) quartz() windows()
-------------------------------------------------------------------------------------------------------
legend() fill="green" pch=c(15, 15, 15, 17) plot.new()
legend(x=0,y=.15, c("Some Text"), cex=1,pt.cex =1.4,col=c("green"), bty="n",fill="green", border="black")
-------------------------------------------------------------------------------------------------------
# Precision of factorial calculation (very important for the Fisher's Exact Test)
library(gmp)
perfectprecision<-list()
singleprecision<-c()
doubleprecision<-c()
for (x in 1:100){
    perfectprecision[x][[1]]<-factorialZ(x)
    singleprecision<-c(singleprecision,factorial(x))
    doubleprecision<-c(doubleprecision,prod(1:x))
}


plot(0,col="white",xlim=c(1,100),ylim=c(0,log10(abs(doubleprecision[100]-singleprecision[100])+1)),
        ,ylab="Log10 Absolute Difference from Big Integer",xlab="x!")
for(x in 1:100) {
    points(x,log10(abs(perfectprecision[x][[1]]-singleprecision[x])+1),pch=16,col="blue")
    points(x,log10(abs(perfectprecision[x][[1]]-doubleprecision[x])+1),pch=20,col="red")
}
legend("topleft",col=c("blue","red"),legend=c("factorial(x)","prod(1:x)"),pch=c(16,20))
-------------------------------------------------------------------------------------------------------
aes # subset of iris data
vdf = iris[which(iris$Species == "virginica"),]
# plot from iris and from vdf
library(ggplot2)
ggplot(iris) + geom_line(aes(x=Sepal.Width, y=Sepal.Length, colour=Species)) +
  geom_line(aes(x=Sepal.Width, y=Sepal.Length, colour="gray"), 
            size=2, data=vdf) library(ggplot2)
ggplot(iris) + 
  geom_line(aes(x=Sepal.Width, y=Sepal.Length, colour=Species)) +
  geom_line(aes(x=Sepal.Width, y=Sepal.Length,size=2), colour="gray",
            override.aes=TRUE,  data=vdf) +
   guides(size = guide_legend(title='vdf color'))
-------------------------------------------------------------------------------------------------------
dat$cat <- factor(dat$cat,levels = c('b','a'))

ggplot(dat,aes(x = name,y = num, fill = cat)) + 
    geom_bar(stat = "identity",position = "dodge") + 
    coord_flip() + 
    scale_fill_manual(values = c('blue','red')) +
    guides(fill = guide_legend(reverse = TRUE)) stat = "identity"
-------------------------------------------------------------------------------------------------------
library(reshape2)
m = melt(my.datamat)

s3d = scatterplot3d(m, type = "h"
              , lwd = 5, pch = " "
              , x.ticklabs = rownames(my.datamat)
              , y.ticklabs = colnames(my.datamat)
              , color = grey(150:1 / 200), main = "Northern Trust Data"
              ,lab=c(length(rownames(my.datamat)),length(colnames(my.datamat))) # defines how many ticks should appear on each axis
                    ) # regression plane
s3d$plane3d(lm(value~., data=nt.dat), lty.box="solid" ) plot(0,0, xlim=c(1,length(colnames(my.datamat)))
        ,ylim = range(my.datamat)
     , type='n'
     ,xaxt = "n")

sapply(1:length(rownames(my.datamat))
       ,function(i){lines(my.datamat[i,]
                          , col=i)} )

legend("topright", legend=rownames(my.datamat),lty=rep(1,length(rownames(my.datamat))),col=c(1:length(rownames(my.datamat))))

axis(1, at = 1:length(colnames(my.datamat))
      , labels=colnames(my.datamat))
-------------------------------------------------------------------------------------------------------
barplot barplot(
  with(dat,prop.table(table(feel,grade))),
  beside=TRUE,
  xlab="Grade",
  ylab="% Feeling Within Grade Group",
  col=grey((1:5)/5)
)
legend("topright",as.character(feelops),fill=grey(1:5/5))
-------------------------------------------------------------------------------------------------------
plots <- dlply(df, .(Method), function (x1) {
    ggplot(subset(melt(cor(x1[sapply(x1,is.numeric)]))[lower.tri(c),],Var1 != Var2),
           aes(x=Var1,y=Var2,fill=value)) + geom_tile(aes(fill = value),colour = "white") +
        geom_text(aes(label = sprintf("%1.2f",value)), vjust = 1) + 
        theme_bw() +
        scale_fill_gradient2(name="R^2",midpoint=0.7,low = "white", high = "red") + xlab(NULL)+ylab(NULL) + theme(axis.text.x=element_blank(),axis.text.y=element_blank(), axis.ticks=element_blank(),panel.border=element_blank()) + ggtitle(x1$Method) + theme(plot.title = element_text(lineheight=1,face="bold")) + geom_text(data = subset(melt(cor(x1[sapply(x1,is.numeric)])),Var1==Var2),aes(label=Var1),vjust=3 ) })

#Function to grab legend
g_legend<-function(a.gplot){
    tmp <- ggplot_gtable(ggplot_build(a.gplot))
    leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
    legend <- tmp$grobs[[leg]]
    legend
}

legend <- g_legend(plots$WIG_Method)


grid.arrange(legend,plots$Single_ROI+theme(legend.position='none'), plots$Simple_2_ROI+theme(legend.position='none'),plots$WIG_Method+theme(legend.position='none'), plots$WIG_drawn_bg+theme(legend.position='none'), ncol=5, nrow=1, widths=c(1/17,4/17,4/17,4/17,4/17))
-------------------------------------------------------------------------------------------------------
grid.arrange library(gridExtra)
g_legend <- function(a.gplot){
      tmp <- ggplot_gtable(ggplot_build(a.gplot))
     leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
     legend <- tmp$grobs[[leg]]
     legend
 }
 legend1 <- g_legend(p1)
 legend2 <- g_legend(p2)

grid.arrange(p1 + theme(legend.position = 'none'), legend1, 
             p2 + theme(legend.position = 'none'), legend2,
            ncol=2, widths = c(5/6,1/6)) R
-------------------------------------------------------------------------------------------------------
legend library("heatmap.plus")

#Create dummy data
data <- replicate(10, rnorm(10)) 
rsc <- c("green", "green", "black", "green", "green", "black", "black", "green", "green", "black")
rsc <- cbind(rsc, rsc)
colnames(rsc) <- c("Groups", "")

#Plot
heatmap.plus(data, RowSideCol = rsc)

#Legend on position (40, 2)
legend(40, 2,legend=c("Title","","Group1","Group2"), fill=c("white", "white", "green","black"), border=FALSE, bty="n", y.intersp = 0.7, cex=0.7)
-------------------------------------------------------------------------------------------------------
pch= lty= legend("topleft",c("x","y"),pch=c(19,NA),lty=c(NA,2),col=c("red","blue"))
-------------------------------------------------------------------------------------------------------
seqrplot seq?plot layout withlegend = FALSE opar <- par(mfrow=c(1,2))
seqrplot(mvad.seq, dist.matrix = mvad.dist,
         criterion = "density", nrep = 1, title = "End CS qualification",
         border = NA, axes=FALSE, withlegend=F)
axis(1, at = c(1, 6, 12, 18, 24, 30, 36, 42, 48, 54, 60, 66, 70), 
     labels = c(1, 6, 12, 18, 24, 30, 36, 42, 48, 54, 60, 66, 70))
seqlegend(mvad.seq)
par(opar)
-------------------------------------------------------------------------------------------------------
p + guides(shape = guide_legend(override.aes = list(linetype = 0))) NULL
-------------------------------------------------------------------------------------------------------
rbind cbind # sample data
A1 <- rnorm(100,1)
B1 <- rnorm(100,2)
C1 <- rnorm(100,3)
D1 <- rnorm(100,4)
E1 <- rnorm(100,5)
A2 <- rnorm(100,3)
B2 <- rnorm(100,4)
C2 <- rnorm(100,5)
D2 <- rnorm(100,6)
E2 <- rnorm(100,7)

dflist <- list(A1=A1,B1=B1,C1=C1,D1=D1,E1=E1,A2=A2,B2=B2,C2=C2,D2=D2,E2=E2)
out <- data.frame(test=do.call(c,dflist))
out$group1 <- rep(1:10,times=sapply(dflist,function(x) length(x)))

# plot
boxplot(test~group1, data=out, at = c(seq(1,13,by=3),seq(2,14,by=3)),
    names=NA, col=rep(c("red","blue"),each=5))
axis(1,at=seq(1.5,13.5,by=3),labels=LETTERS[1:5])
legend(x=1, y=9, legend=c("Type 1","Type 2"), fill=c("red","blue"))
-------------------------------------------------------------------------------------------------------
set.seed(1)

getRewardsGaussian <- function(arms, plays) {
## assuming each action has a normal distribution 

  # first generate new means
  QStar <- rnorm(arms, 0, 1)

  # then for each mean, generate `play`-many samples
  sapply(QStar, function(u)
    rnorm(plays, u, 1))
}


CalculateRewardsPerMethod <- function(arms=7, epsi1=0.01, epsi2=0.1
                    , plays=1000, methods=c("greedy", "epsi1", "epsi2")) {

  # names for easy handling
  names(methods) <- methods
  arm.names <- paste0("Arm", ifelse((1:arms)<10, 0, ""), 1:arms)

  # this could be different if not all actions' rewards have a gaussian dist.
  rewards.source <- getRewardsGaussian(arms, plays) 

  # Three dimensional array to track running averages of each method
  running.avgs <- 
    array(0, dim=c(plays, arms, length(methods))
           , dimnames=list(PlayNo.=NULL, Arm=arm.names, Method=methods))

  # Three dimensional array to track the outcome of each play, according to each method 
  rewards.received <- 
    array(NA_real_, dim=c(plays, 2, length(methods))
                  , dimnames=list(PlayNo.=seq(plays), Outcome=c("Arm", "Reward"), Method=methods))


  # define the function internally to not have to pass running.avgs 
  chooseAnArm <- function(p) {
    # Note that in a tie, which.max returns the lowest value, which is what we want
    maxes <- apply(running.avgs[p, ,methods, drop=FALSE], 3, which.max)

    # Note: deliberately drawing two separate random numbers and keeping this as 
    #       two lines of code to accent that the two draws should not be related 
    if(runif(1) < epsi1)
      maxes["epsi1"] <- sample(arms, 1)

    if(runif(1) < epsi2)
      maxes["epsi2"] <- sample(arms, 1)

    return(maxes)
  }

  ## TODO:  Perform each action at least once, then select according to algorithm
  ## Starting points. Everyone starts at machine 3
  choice <- c(3, 3, 3)
  reward <- rewards.source[1, choice]
  ## First run, slightly different
  rewards.received[1,,] <- rbind(choice, reward)
  running.avgs[1, choice, ] <- reward # if different starting points, this needs to change like below

  ## HERE IS WHERE WE START PULLING THE LEVERS ##
  ## ----------------------------------------- ##
  for (p in 2:plays) {
    choice <- chooseAnArm(p)
    reward <- rewards.source[p, choice]

    # Note: When dropping a dim, the methods will be the columns 
    #       and the Outcome info will be the rows. Use `rbind` instead of `cbind`.
    rewards.received[p,,names(choice)] <- rbind(choice, reward)

    ## Update the running averages. 
    ## For each method, the current running averages are the same as the
    ##    previous for all arms, except for the one chosen this round.
    ##    Thus start with last round's averages, then update the one arm.
    running.avgs[p,,] <- running.avgs[p-1,,]

    # The updating is only involved part (due to lots of array-indexing)
    running.avgs[p,,][cbind(choice, 1:3)] <- 
     sapply(names(choice), function(m) 
       # Update the running average for the selected arm (for the current play & method) 
          mean( rewards.received[ 1:p,,,drop=FALSE][ rewards.received[1:p,"Arm",m] == choice[m],"Reward",m])
     )
  } # end for-loop


  ## DIFFERENT RETURN OPTIONS ##
  ## ------------------------ ##


  ## All rewards received, in simplifed matrix (dropping information on arm chosen)
  # return(rewards.received[, "Reward", ])

  ## All rewards received, along with which arm chosen: 
  #   return(rewards.received)

  ## Running averages of the rewards received by method
  return( apply(rewards.received[, "Reward", ], 2, cumsum) / (1:plays) )

}


### EXECUTION (AND SIMULATION)

## PARAMETERS
arms   <- 10
plays  <- 1000
epsi1  <- 0.01
epsi2  <- 0.1
simuls <- 50  # 2000
methods=c("greedy", "epsi1", "epsi2")

## Single Iteration: 
### we can run system time to get an idea for how long one will take
tme <- system.time( CalculateRewardsPerMethod(arms=arms, epsi1=epsi1, epsi2=epsi2, plays=plays) )
cat("Expected run time is approx: ", round((simuls * tme[["elapsed"]]) / 60, 1), " minutes")

## Multiple iterations (simulations)
rewards.received.list <- replicate(simuls, CalculateRewardsPerMethod(arms=arms, epsi1=epsi1, epsi2=epsi2, plays=plays), simplify="array")

## Compute average across simulations
rewards.received <- apply(rewards.received.list, 1:2, mean)

## RESULTS
head(rewards.received, 17)
MeanRewards <- rewards.received

## If using an alternate return method in `Calculate..` use the two lines below to calculate running avg
#   CumulRewards <- apply(rewards.received, 2, cumsum)
#   MeanRewards  <- CumulRewards / (1:plays)

## PLOT
plot.ts(MeanRewards[, "greedy"], col = 'red', lwd = 2, ylim = range(MeanRewards), ylab = 'Average reward', xlab="Plays")
  lines(MeanRewards[, "epsi1"], col = 'orange', lwd = 2)
  lines(MeanRewards[, "epsi2"], col = 'navy', lwd = 2)
  grid(col = 'darkgray')

  legend('bottomright', c('greedy', paste("epsi1 =", epsi1), paste("epsi2 =", epsi2)), col = c('red', 'orange', 'navy'), lwd = 2, cex = 0.8)
-------------------------------------------------------------------------------------------------------
get.testbed = function(arms = 10, plays = 500, u = 0, sdev.arm = 1, sdev.rewards = 1){

  optimal = rnorm(arms, u, sdev.arm)
  rewards = sapply(optimal, function(x)rnorm(plays, x, sdev.rewards))

  list(optimal = optimal, rewards = rewards)
}

play.slots = function(arms = 10, plays = 500, u = 0, sdev.arm = 1, sdev.rewards = 1, eps = 0.1){

  testbed = get.testbed(arms, plays, u, sdev.arm, sdev.rewards)
  optimal = testbed$optimal
  rewards = testbed$rewards

  optim.index = which.max(optimal)
  slot.rewards = rep(0, arms)
  reward.hist = rep(0, plays)
  optimal.hist = rep(0, plays)
  pulls = rep(0, arms)
  probs = runif(plays)

  # vetorizar
  for (i in 1:plays){

      ## dont use ifelse() in this case
      ## idx = ifelse(probs[i] < eps, sample(arms, 1), which.max(slot.rewards))

      idx = if (probs[i] < eps) sample(arms, 1) else which.max(slot.rewards)
      reward.hist[i] = rewards[i, idx]

      if (idx == optim.index)
        optimal.hist[i] = 1

      slot.rewards[idx] = slot.rewards[idx] + (rewards[i, idx] - slot.rewards[idx])/(pulls[idx] + 1)
      pulls[idx] = pulls[idx] + 1
  }

  list(slot.rewards = slot.rewards, reward.hist = reward.hist, optimal.hist = optimal.hist, pulls = pulls)
}

do.simulation = function(N = 100, arms = 10, plays = 500, u = 0, sdev.arm = 1, sdev.rewards = 1, eps = c(0.0, 0.01, 0.1)){

  n.players = length(eps)
  col.names = paste('eps', eps)
  rewards.hist = matrix(0, nrow = plays, ncol = n.players)
  optim.hist = matrix(0, nrow = plays, ncol = n.players)
  colnames(rewards.hist) = col.names
  colnames(optim.hist) = col.names

  for (p in 1:n.players){
    for (i in 1:N){
      play.results = play.slots(arms, plays, u, sdev.arm, sdev.rewards, eps[p])
      rewards.hist[, p] = rewards.hist[, p] + play.results$reward.hist
      optim.hist[, p] = optim.hist[, p] + play.results$optimal.hist
    } 
  }

  rewards.hist = rewards.hist/N
  optim.hist = optim.hist/N
  optim.hist = apply(optim.hist, 2, function(x)cumsum(x)/(1:plays))

  ### Plot helper ###
  plot.result = function(x, n.series, colors, leg.names, ...){
    for (i in 1:n.series){
      if (i == 1)
        plot.ts(x[, i], ylim = 2*range(x), col = colors[i], ...)
      else
        lines(x[, i], col = colors[i], ...)
      grid(col = 'lightgray')
    }
    legend('topleft', leg.names, col = colors, lwd = 2, cex = 0.6, box.lwd = NA)
  }
  ### Plot helper ###

  #### Plots ####
  require(RColorBrewer)
  colors = brewer.pal(n.players + 3, 'Set2')
  op <-par(mfrow = c(2, 1), no.readonly = TRUE)

  plot.result(rewards.hist, n.players, colors, col.names, xlab = 'Plays', ylab = 'Average reward', lwd = 2)
  plot.result(optim.hist, n.players, colors, col.names, xlab = 'Plays', ylab = 'Optimal move %', lwd = 2)
  #### Plots ####

  par(op)
} do.simulation(N = 100, arms = 10, eps = c(0, 0.01, 0.1))
-------------------------------------------------------------------------------------------------------
> print(data.frame(n=2:3, x=1:6))
- n x
1 2 1
2 3 2
3 2 3
4 3 4
5 2 5
6 3 6 > print(expand.grid(x=1:5, n=2:3))
-  x n
1  1 2
2  2 2
3  3 2
4  4 2
5  5 2
6  1 3
7  2 3
8  3 3
9  4 3
10 5 3 lapply(2:3, FUN=function(n) (f(n, x=1:5)))
#[[1]]
#[1] 0.0004981910 0.0006066275 0.0007328627 0.0008786344 0.0010456478
#
#[[2]]
#[1] 0.0007464956 0.0009087272 0.0010974595 0.0013152213 0.0015644676 wrapper <- function(i, x, n, fti){
    # As was provided by OP
    g<-function(x) {do.call(paste("d",i,sep=""),c(list(x=x),fti$estimate))}

    G<-function(x) {do.call(paste("p",i,sep=""),c(list(q=x),fti$estimate))}
    # does the i in fti refer to fit of i:th distribution, i.e. should it be a list where i:th location in ft is i:th distribution estimates?

    f<-function(n,x) {n*g(x)*(1-G(x))^(n-1)}
    # was missing a '-' and a '}'

    h<- function(n) {integrate(function(x) {x*f(n,x)},0,Inf)}

    list(gres = g(x), Gres = G(x), fres = f(n,x), hres = h(n))
}

# Example data
require("fitdistrplus")
data(groundbeef)
serving <- groundbeef$serving

# Gumbel distribution
d1 <- function(x, a, b) 1/b*exp((a-x)/b)*exp(-exp((a-x)/b))
p1 <- function(q, a, b) exp(-exp((a-q)/b))
q1 <- function(p, a, b) a-b*log(-log(p))

fti1 <- fitdist(serving, "1", start=list(a=10, b=10))
#> fti1$estimate
#       a        b 
#56.95893 29.07871

# Normal distribution

# dnorm, pnorm and qnorm are available in the default environment
d2 <- dnorm
p2 <- pnorm
q2 <- qnorm

fti2 <- fitdist(serving, "2", start=list(mean=0, sd=1))
#> fti2$estimate
#    mean       sd 
#73.67743 35.92581

# Sequence of x-values
xs <- seq(-100, 100, by=1)

print((resultdist1n2 <- wrapper(i=1, x=xs, n=2, fti=fti1))$hres)
print((resultdist1n3 <- wrapper(i=1, x=xs, n=3, fti=fti1))$hres)
print((resultdist2n2 <- wrapper(i=2, x=xs, n=2, fti=fti2))$hres)
print((resultdist2n3 <- wrapper(i=2, x=xs, n=3, fti=fti2))$hres)

plot(xs, resultdist1n2$fres, col=1, type="l", ylim=c(0,0.025), xlab="x", ylab="f(n, x)")
points(xs, resultdist1n3$fres, col=2, type="l")
points(xs, resultdist2n2$fres, col=3, type="l")
points(xs, resultdist2n3$fres, col=4, type="l")
legend("topleft", legend=c("Gamma (i=1) n=2", "Gamma (i=1) n=3", "Normal (i=2) n=2", "Normal (i=2) n=3"), col=1:4, lty=1) h(n=2) for distribution i=1:
53.59385 with absolute error < 0.00022
h(n=3) for distribution i=1:
45.23146 with absolute error < 4.5e-05
h(n=2) for distribution i=2:
53.93748 with absolute error < 1.1e-05
h(n=3) for distribution i=2:
44.06331 with absolute error < 2e-05 ns <- 0:256
res1 <- lapply(ns, FUN=function(nseq) wrapper(i=1, x=xs, n=nseq, fti=fti1))
par(mfrow=c(1,2))
plot.new()
plot.window(xlim=c(-100,100), ylim=c(0, 0.05))
box(); axis(1); axis(2); title(xlab="x", ylab="f(n,x)", main="f(n,x) for gamma (i=1), n=0:256")
for(i in 1:length(ns)) points(xs, res1[[i]]$fres, col=rainbow(257)[i], type="l")
# perform similarly for the other distributions by calling with i=2, fti=fti2
# h as a function of n for dist i=1
plot(ns, unlist(lapply(res1, FUN=function(x) x$hres$value)), col=rainbow(257), xlab="n", ylab="h(n)", main="h(n) for gamma (i=1), n=0:256")
-------------------------------------------------------------------------------------------------------
library(ggplot2)
p <- ggplot() + geom_point(data=diamonds, aes(x=cut, y=mean(depth), color=clarity), shape=15, size=5)
p <- p + guides(color=guide_legend(title=NULL)) 
p <- p + theme(legend.key = element_blank())
p <- p  + geom_boxplot(data=diamonds,aes(x=cut,fill=factor(clarity),y=depth)) + guides(fill=FALSE)
p
-------------------------------------------------------------------------------------------------------
B <- 10
ind <- replicate(B,sample(seq(1:n),n,replace=TRUE))

#you need to pass a function to apply
bst.sample <- apply(ind,2, 
                function(i) lda(Species~Petal.Length+Petal.Width,data=Iris[i,]))
#extract means
bst.means <- lapply(bst.sample,function(x) x$means)

#bind means into array
library(abind)
bst.means <- do.call(function(...) abind(..., along=3), bst.means)

#you need to make sure that alle points are inside the axis limits
plot(bst.means[1,1,],bst.means[1,2,], 
     xlim=range(bst.means[,1,]), ylim=range(bst.means[,2,]), 
     xlab=dimnames(bst.means)[[2]][1],ylab=dimnames(bst.means)[[2]][2],
     col=1)
points(bst.means[2,1,],bst.means[2,2,], col=2)
points(bst.means[3,1,],bst.means[3,2,], col=3)
legend("topleft", legend=dimnames(bst.means)[[1]], col=1:3, pch=1)
-------------------------------------------------------------------------------------------------------
ggplot ggplot # UK shapefile found via http://www.gadm.org/download
uk.url <- "http://www.filefactory.com/file/s3dz3jt3vr/n/GBR_adm_zip"

# replace following with your working directory - no trailing slash
work.dir <- "C:/Temp/r.temp/gb_map"

# the full file path for storing file
file.loc <- paste0(work.dir, "/uk.zip")

download.file (uk.url, destfile = file.loc, mode = "wb")
unzip(file.loc, exdir = work.dir)

# open the shapefile
require(rgdal)
uk <- readOGR(work.dir, layer = "GBR_adm2")

# make some fake data to plot
uk@data$count <- round(runif(nrow(uk@data), 0, 2500), 0)
uk@data$count <- as.numeric(uk@data$count)

# and plot it
plot(uk, col = gray(uk@data$count/2500)) legend # UK shapefile found via http://www.gadm.org/download
uk.url <- "http://www.filefactory.com/file/s3dz3jt3vr/n/GBR_adm_zip"

# replace following with your working directory - no trailing slash
work.dir <- "C:/Temp/r.temp/gb_map"

# the full file path for storing file
file.loc <- paste0(work.dir, "/uk.zip")

download.file (uk.url, destfile = file.loc, mode = "wb")
unzip(file.loc, exdir = work.dir)

# open the shapefile
require(rgdal)
uk <- readOGR(work.dir, layer = "GBR_adm2")

# make some fake data to plot
uk@data$count <- as.numeric(round(runif(nrow(uk@data), 0, 2500), 0))
uk@data$bin <- cut(uk@data$count, seq(0, 2500, by = 250), 
      include.lowest = TRUE, dig.lab = 4)

# labels for the legend
lev = levels(uk@data$bin)
lev2 <- gsub("\\,", " to ", lev)
lev3 <- gsub("\\]$", "", lev2)
lev4 <- gsub("\\(|\\)", " ", lev3)
lev5 <- gsub("^\\[", " ", lev4)
my.levels <- lev5

# Create a function to generate a continuous color palette
rbPal <- colorRampPalette(c('red','blue'))
uk@data$Col <- rbPal(10)[as.numeric(cut(uk@data$count, seq(0, 2500, by = 250)))]

# Plot
plot(uk, col = uk@data$Col)
legend("topleft", fill = uk@data$Col, legend = my.levels, col = uk@data$Col)
-------------------------------------------------------------------------------------------------------
x <- 1:10 ; y <- x ^ 2
plot(x, y) 
legend( locator(1), c("label 1", "label 2", "label 3"), lty=c(1,2,0),pch=c("  C"))
-------------------------------------------------------------------------------------------------------
plot(x=c(2,4,8),y=c(5,4,2),pch=16)
points(x=c(3,5),y=c(2,4),pch="+")
legend(7,4.5,pch=c(43,16),legend=c("A","B"))
-------------------------------------------------------------------------------------------------------
maraqa <- c(84.8,68.9,84.9,92.5)
aqua <- c(75,65.1,79.4,82.3)
mar <- c(84.7,68.3,84.5,77.4)

# combine data as matrix
mat<-cbind(maraqa, aqua, mar)
rownames(mat)<-c("A", "B", "C", "D")

#define colours
coll<-c("red", "blue", "black")

matplot(mat, type="l", ylim=c(60, 95), ylab="y TBA", main="TBA", xlab="x TBA", 
        axes=FALSE, frame.plot=FALSE, col=coll, lty=rep(1,3))
# axes= do you want standart axis or make your own?
# frame.plot= frame arround plot yes/no

matpoints(mat, pch=rep(17,3), col=coll, ad=TRUE)
# to add points, pch controlls for type of points

axis(side=1, 1:4, labels=rownames(mat))
axis(side=2, 60:95, labels=60:95)
legend("topleft",lty=c(1,1,1),,col = coll, cex=0.7)# scaling parameter
-------------------------------------------------------------------------------------------------------
grid_legend <- function (x, y, pch = NA, col = par('col'), labels, frame = TRUE, 
  hgap = unit(0.8, "lines"), vgap = unit(0.8, "lines"), default_units = "lines", 
  gp = gpar(), draw = TRUE, title = NULL, just = 'center', lwd = NA, lty = NA, 
  gp.title = NULL, gp.labels = NULL, gp.frame = gpar(fill = "transparent")) 
{

  if(is.character(x))
    switch(x,
           topleft = {x = unit(0,'npc'); y = unit(1,'npc'); just = c(0,1)},
           topright = {x = unit(1,'npc'); y = unit(1,'npc'); just = c(1,1)},
           bottomright = {x = unit(1,'npc'); y = unit(0,'npc'); just = c(1,0)},
           bottomleft = {x = unit(0,'npc'); y = unit(0,'npc'); just = c(0,0)})

  labels <- as.character(labels)
  nlabs <- length(labels)

  if(length(pch) == 1)
    pch <- rep(pch, nlabs)
  if(length(lwd) == 1)
    lwd <- rep(lwd, nlabs)
  if(length(lty) == 1)
    lty <- rep(lty, nlabs)
  if(length(col) == 1)
    col <- rep(col, nlabs)
  if(length(gp.labels) == 1)
    gp.labels <- rep(list(gp.labels), nlabs)


  if (is.logical(title) && !title) 
    title <- NULL
  ifelse(is.null(title), tit <- 0, tit <- 1)

  if (!is.unit(hgap)) 
    hgap <- unit(hgap, default_units)
  if (length(hgap) != 1) 
    stop("hgap must be single unit")
  if (!is.unit(vgap)) 
    vgap <- unit(vgap, default_units)
  if (length(vgap) != 1) 
    stop("vgap must be single unit")

  if(tit)
    legend.layout <- grid.layout(nlabs + tit, 3,
                                 widths = unit.c(unit(2, "lines"),
                                 max(unit(rep(1, nlabs), "strwidth", as.list(c(labels))),
                                 unit(1, "strwidth", title) - unit(2, "lines")), hgap),
                                 heights = unit.pmax(unit(1, "lines"),
                                 vgap + unit(rep(1, nlabs + tit ),
                                           "strheight", as.list(c(labels,title)))))
  else
     legend.layout <- grid.layout(nlabs, 3, widths = unit.c(unit(2, 
      "lines"), max(unit(rep(1, nlabs), "strwidth", as.list(labels))), 
      hgap), heights = unit.pmax(unit(1, "lines"), vgap + unit(rep(1, 
      nlabs), "strheight", as.list(labels))))

  fg <- frameGrob(layout = legend.layout, gp = gp)

  if (tit)
    fg <- placeGrob(fg, textGrob(title, x = .2, y = 0.5, just = c("left", "center"), gp = gp.title), col = 1, row = 1)

  for (i in 1:nlabs) {
    if(!is.na(pch[i]))
      fg <- placeGrob(fg, pointsGrob(0.5, 0.5, pch = pch[i], gp = gpar(col = col[i])), col = 1, row = i + tit)
      else if(!is.na(lwd[i]) || !is.na(lty[i]))
        fg <- placeGrob(fg, linesGrob( unit(c(0.2, .8), "npc"),  unit(c(.5), "npc"), 
                                gp = gpar(col = col[i], lwd = lwd[i], lty=lty[i])), col = 1, row = i + tit)

    fg <- placeGrob(fg, textGrob(labels[i], x = .1, y = 0.5, just = c("left", "center"), gp = gp.labels[[i]]), col = 2, row = i + tit)
  }

  pushViewport(viewport(x, y, height = grobHeight(fg), width = grobWidth(fg), just = just ))

  if (frame) 
    fg <- placeGrob(fg, rectGrob(gp = gp.frame))
  if (draw) 
    grid.draw(fg)
  popViewport(1)
  invisible(fg)
} require(grid)
png("grid_legend.png", 500, 400)
grid.newpage()
pushViewport(viewport(height = .9, width = .9 ))
grid.rect(gp = gpar(lwd = 2, lty = 2))

grid_legend(x = unit(.05,'npc'),
            y = unit(.05,'npc'),
            just = c(0,0),
            pch = c(1,2,3),
            col = c(1,2,3),
            lwd=NA, 
            lty=NA,
            labels = c("b",'r','g'),
            title = NULL,
            gp=gpar(lwd=2, cex=1),
            hgap = unit(.8, "lines"),
            vgap = unit(.9, "lines"))

grid_legend(x = unit(1,'npc'),
            y = unit(1,'npc'),
            just = c(1,1),
            pch = NA,
            col = c(1,2,3,4),
            lwd=c(1,1,1,3), 
            lty=c(1,2,1,3),
            labels = c("black",'red','green','blue'),
            gp.labels = list(gpar(col = 1), gpar(col = 2), 
                             gpar(col = 3), gpar(col = 4)),
            title = NULL,
            gp=gpar(lwd=2, cex=1),
            hgap = unit(.8, "lines"),
            vgap = unit(.9, "lines"))

grid_legend(x = 'topleft',
            pch = c(1,NA,2,NA),
            col = c(1,2,3,4),
            lwd=NA, 
            lty=c(NA,2,NA,3),
            labels = c("black",'red','green','blue'),
            title = 'Some LONG Title',
            gp.title = gpar(col = 3),
            gp.frame = gpar(col = 4, lty = 2, fill = "transparent"),
            gp.labels = gpar(col = 6),
            gp=gpar(lwd=2, cex=2, col = 1),
            hgap = unit(.8, "lines"),
            vgap = unit(.9, "lines"))


grid_legend(x = .7,
            y = .7,
            pch = c(1,NA,2,NA),
            col = c(1,2,3,4),
            lwd=1, 
            lty=c(NA,2,NA,3),
            labels = c("black",'red','green','blue'),
            title = 'short T',
            gp=gpar(lwd=1, cex=.7,col = 1),
            hgap = unit(.8, "lines"),
            vgap = unit(.9, "lines"))

grid_legend(x = 'bottomright',
            pch = c(1,NA,2,NA),
            col = c(2),
            lwd=NA, 
            lty=c(NA,2,NA,3),
            labels = c("black",'red','green','blue'),
            title = NULL,
            gp=gpar(lwd=2, cex=1,col = 1),
            hgap = unit(.8, "lines"),
            vgap = unit(.9, "lines"))
dev.off()
-------------------------------------------------------------------------------------------------------
sigma <- c(1,2,3)
mu <- c(4,5,6)
rp <- vector('expression',3)
i=1
for (i in 1:length(sigma)){
  jnk=paste("paste(sigma == ", sigma[i],",', ',", "mu == ", mu[i],")")
  rp[i]=parse(text=jnk)  
}
plot(0);legend(x="bottomleft",legend=rp)
-------------------------------------------------------------------------------------------------------
# example data:
dat <- list(a=1:5,b=2:7,c=3:10)
# get plotting:
plot(unlist(dat),type="n",xlim=c(1,max(sapply(dat,length))))
mapply(lines,dat,col=seq_along(dat),lty=2)
legend("topleft",names(dat),lty=2,col=seq_along(dat))
-------------------------------------------------------------------------------------------------------
pt.bg = 'white' plot(x, x, type="b")
legend("bottomright", c("dinges"), cex=1.2, pch = 21,pt.bg = 'white', lty = 1, bty="n")
-------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------
plot(NORM, TEE, ylim = c(-4, 5), main = "NORM and TEE plot") points(NORM[NORM^2 -1> TEE], TEE[ TEE + 1< NORM^2], col = "blue")
legend(legend = c("TEE > NORM^2 - 1 ", "TEE < NORM^2 - 1" ), col = c(1, 4), x = "topright", pch = 1) par(mfrow = c(1, 2))
plot(NORM, TEE, ylim = c(-4, 5), main = "NORM and TEE plot")
plot(NORM, TEE, ylim = c(-4, 5), main = "NORM and TEE plot")
points(NORM[NORM^2 -1> TEE], TEE[ TEE + 1< NORM^2], col = "blue") screen.split(2,2)
#[1] 1 2 3 4
screen(1) # what follows goes in slot (1,1)
hist(RandomNormal, seq(-3.2, 3.2, .2), prob = TRUE)
curve(dnorm(x), add = TRUE, col = "red");
screen(2) # what follows goes in slot (1,2);
boxplot(DATA.oner);
screen(3) # similarly for (2,1);
plot(NORM, TEE, ylim = c(-4, 5), main = "NORM and TEE plot");
screen(4) # similarly for (2,2);
plot(NORM, TEE, ylim = c(-4, 5), main = "NORM and TEE plot");
points(NORM[NORM^2 - 1 > TEE], TEE[TEE + 1 < NORM^2], col = "blue"); screen(1) # Watch the screen (1,1) go blank
boxplot(DATA.oner, main = "Box Plots of DATA.oner")

screen(2) # again for slot (1,2)
hist(RandomNormal, seq(-3.2, 3.2, .2), prob = TRUE)
curve(dnorm(x), add = TRUE, col = "red") split.screen(c(2,1)) # The screen is now split in two
# [1] 1 2
split.screen(c(1,2), screen = 2) # splits the second into 2
# [1] 3 4
screen(1) # note screen 2 is now refered to as 3 and 4
hist(RandomNormal, seq(-3.2, 3.2, .2), prob = TRUE)
curve(dnorm(x), add = TRUE, col = "red")
legend(legend = c("Theoretical N(0, 1)"), col = c(2, 3), x = "topright", lty = 1)

screen(3) # We call on screen 3 and 4, not 2
boxplot(DATA.oner, main = "Box Plot of DATA.oner")

screen(4)
plot(NORM, TEE, ylim = c(-4, 5), main = "NORM and TEE plot")
-------------------------------------------------------------------------------------------------------
p <- ggplot(dt2) +
geom_line(aes(x=Value,y=y,group=Trial,color=Trial,size=N)) +
scale_size(range=c(0.1, 2)) +
guides(size=FALSE, color=guide_legend(override.aes=list(size=c(2, .1)))) scales <- c(0.1, 2) # the range you want: min, max
vals <- summary(lm(scales ~ c(min(dt2$N), max(dt2$N))))$coefficients[,1]
sizes <- vals[2] * unique(dt2$N) + vals[1]

ggplot(dt2) +
geom_line(aes(x=Value,y=y,group=Trial,color=Trial,size=N)) +
scale_size(range=scales) +
guides(size=FALSE, color=guide_legend(override.aes=list(size=sizes)))
-------------------------------------------------------------------------------------------------------
ggplot(dt2) + geom_line(aes(x = Value, y = y, group = Trial, color = Trial, size = N)) + scale_size(range = c(0.1, 2)) + guides(size = F, color = guide_legend(override.aes = list(size = range(0.1,2)))) N <- dt2$N size = N
-------------------------------------------------------------------------------------------------------
# Clear all
rm(list = ls())

# Load the library that reads xls files
library(gdata)

# Get the data in
data = read.csv('Readings.csv')

# Extract each Column
readings = data[,"Reading"]
dates = as.Date(data[,"Reading.Date"])

# Order the data correctly
readings = readings[order(dates)]
dates = dates[order(dates)]

# Calculate the difference between each date (in days) and readings
diff.readings = diff(readings)
diff.dates = as.numeric(diff(dates)) # Convert from days to an integer

# Calculate the usage per reading period
usage.per.period = diff.readings/diff.dates

# Get Every single day between the very first reading and the very last
# seq will create a sequence: first argument is min, second is max, and 3rd is the step size (which in this case is 1 day)
days = seq(min(dates),max(dates), 1)
# This creates an empty vector to get data from the for loop below
usage.per.day = numeric()

# The length of the diff.dates is the number of periods that exist.
for (period in 1:(length(diff.dates))){
    # to convert usage.per.period to usage.per.day, we need to replicate the 
    # value for the number of days in that period. the function rep will 
    # replicate a number: first argument is the number to replicate, and the 
    # second number is the number of times to replicate it. the function c will 
    # concatinate the current vector and the new period, sort of 
    # like value = value + 6, but with vectors. 
    usage.per.day = c(usage.per.day, rep(usage.per.period[period], diff.dates[period]))
}
# The for loop above misses out on the last day, so I add that single value manually
usage.per.day[length(usage.per.day)+1] = usage.per.period[period]

# Get the number of readings for each year
years = names(table(format(dates, "%Y")))

# Now break down the usages and the days by year
# list() creates an empty list
usage.per.day.grouped.by.year = list()
year.day = list()
# This defines some colors for plotting, rainbow(n) will give you 
colors = rainbow(length(years))
for (year.index in 1:length(years)){
    # This is a vector of trues and falses, to say whether a day is in a particular
    # year or not
    this.year = (days >= as.Date(paste(years[year.index],'/01/01',sep="")) &
                 days <= as.Date(paste(years[year.index],'/12/31',sep="")))
    usage.per.day.grouped.by.year[[year.index]] = usage.per.day[this.year]
    # We only care about the month and day, so drop the year
    year.day[[year.index]] = as.Date(format(days[this.year], format="%m/%d"),"%m/%d")
    # In the first year, we need to set up the whole plot
    if (year.index == 1){
        # create a png file with file name image.png
        png('image.png')
        plot(year.day[[year.index]], # x coords
             usage.per.day.grouped.by.year[[year.index]], # y coords
             "l", # as a line
             col=colors[year.index], # with this color
             ylim = c(min(usage.per.day),max(usage.per.day)), # this y max and y min
             ylab='Usage', # with this lable for y axis
             xlab='Date', # with this lable for x axis
             main='Usage Over Time') # and this title
    }
    else {
        # After the plot is set up, we just need to add each year
        lines(year.day[[year.index]], # x coords
            usage.per.day.grouped.by.year[[year.index]], # y coords
            col=colors[year.index]) # color
    }
}
# add a legend to the whole thing
legend("topright" , legend = years, lty=c(1,1), lwd=c(2.5,2.5), col=colors) 
dev.off() # save the png to file Reading Date,Reading
1/1/10,10
2/1/10,20
3/6/10,30
4/1/10,40
5/7/10,50
6/1/10,60
7/1/10,70
8/1/10,75
9/22/10,80
10/1/10,85
11/1/10,90
12/1/10,95
1/1/11,100
2/1/11,112.9545455
3/1/11,120.1398601
4/1/11,127.3251748
5/1/11,134.5104895
6/1/11,141.6958042
7/1/11,148.8811189
8/1/11,156.0664336
9/17/11,190
10/1/11,223.9335664
11/1/11,257.8671329
12/1/11,291.8006993
1/1/12,325.7342657
2/1/12,359.6678322
3/5/12,375
4/1/12,380
5/1/12,385
6/1/12,390
7/1/12,400
8/1/12,410
9/1/12,420
-------------------------------------------------------------------------------------------------------
guides(fill=guide_legend(ncol=2))
-------------------------------------------------------------------------------------------------------
ggplot(...) + ... + guide_legend(title="my awesome title")
-------------------------------------------------------------------------------------------------------
fill="white" fill="white" fill="black" col = rainbow(12, alpha = 1)
plot(1)
legend("top", border="white", col=col, legend=1:12, horiz=TRUE, pch=15)
legend("bottom", border="white", col=col, legend=1:12, horiz=TRUE, pch=15, fill="black")
-------------------------------------------------------------------------------------------------------
cor A<-data.frame(A1=c(1,2,3,4,5),B1=c(6,7,8,9,10),C1=c(11,12,13,14,15 ))

B<-data.frame(A2=c(6,7,7,10,11),B2=c(2,1,3,8,11),C2=c(1,5,16,7,8))

cor(A,B)

#           A2        B2       C2
# A1 0.9481224 0.9190183 0.459588
# B1 0.9481224 0.9190183 0.459588
# C1 0.9481224 0.9190183 0.459588

diag(cor(A,B))
#[1] 0.9481224 0.9190183 0.4595880 Unit: microseconds
                   expr     min       lq   median       uq      max neval
        diag(cor(A, B)) 230.292 238.4225 243.0115 255.0295  352.955   100
      mapply(cor, A, B) 267.076 281.5120 286.8030 299.5260  375.087   100
 unlist(Map(cor, A, B)) 250.053 259.1045 264.5635 275.9035 1146.140   100 set.seed(42)
A <- as.data.frame(matrix(rnorm(10*n),ncol=n))
B <- as.data.frame(matrix(rnorm(10*n),ncol=n)) b <- sapply(2^(1:12), function(n) {
    set.seed(42)
    A <- as.data.frame(matrix(rnorm(10*n),ncol=n))
    B <- as.data.frame(matrix(rnorm(10*n),ncol=n))

    require(microbenchmark)
    res <- print(microbenchmark(
                   diag(cor(A,B)),
                   mapply(cor, A, B),
                   unlist(Map(cor,A,B)),
                   times=10
                 ),unit="us")
    res$median
})

b <- t(b)

matplot(x=1:12,log10(b),type="l",
        ylab="log10(median [µs])", 
        xlab="log2(n)",col=1:3,lty=1)
legend("topleft", legend=c("diag(cor(A, B))", "mapply(cor, A, B)","unlist(Map(cor,A,B))"),lty=1, col=1:3)
-------------------------------------------------------------------------------------------------------
gridExtra grid.arrange() from rpy2.robjects.packages import importr
gridextra = importr('gridExtra')
from rpy2.robjects.lib import ggplot2
_ggplot2 = ggplot2.ggplot2
def dollar(x, name): # should be included in rpy2.robjects, may be...
    return x[x.index(name)]

def g_legend(a_gplot):
    tmp = _ggplot2.ggplot_gtable(_ggplot2.ggplot_build(a_gplot))
    leg = [dollar(x, 'name')[0] for x in dollar(tmp, 'grobs')].index('guide-box')
    legend = dollar(tmp, 'grobs')[leg]
    return legend
legend1 = g_legend(p1)
legend2 = g_legend(p2)
nolegend = ggplot2.theme(**{'legend.position': 'none'})
gridexta.grid_arrange(p1 + nolegend, legend1, 
                      p2 + nolegend, legend2,
                      ncol=2, widths = FloatVector((5.0/6,1.0/6)))
-------------------------------------------------------------------------------------------------------
plot(as.zoo(x), las=1)
par(new=TRUE)               
plot(as.zoo(y),
     col=2,
     bty='n',               
     xaxt="n",               
     yaxt="n",              
     xlab="", ylab="")

axis(4, las=1)

legend("topleft",           legend=c("x","y"), col=1:2,lty=1,              cex=0.85)
-------------------------------------------------------------------------------------------------------
pch V2 pch plot(dfk$V5,dfk$V6, main = "1880 - 1 - 1/4", sub = NULL, xlab = "LON", ylab = "LAT",
         ylim=c(-50,0),xlim=c(-50,0), col = rainbow(length(dfk$V2))               
         [rank(dfk$V2)],pch=c(1:25)[rank(dfk$V2)/2],cex=2)

legend('topright',legend=dfk$V2[!duplicated(dfk$V2)],col=rainbow(length(dfk$V2))[rank(dfk$V2)[!duplicated(dfk$V2)]],pch=c(1:25)[rank(dfk$V2)[!duplicated(dfk$V2)]/2],cex=2)
-------------------------------------------------------------------------------------------------------

legend("topright", legend=unique(data$category), pch=1, col=unique(data$category))
-------------------------------------------------------------------------------------------------------
my.symbols library(TeachingDemos)
ms.Cleveland <- function(num.pt = 1, cex=2, ...) {
    funs <- list(
        open = function(cex, ...) 
            points(0,0, pch=1, lwd=2, cex=cex, ...),
        filled = function(cex, ...)
            points(0,0, pch=16, cex=cex, ...),
        half = function(cex, ...)
            points(0,0, pch=1, lwd=5, cex=cex, ...),
        vert = function(cex, ...) {
            points(0,0, pch=1, lwd=2, cex=cex, ...)
            points(0,0, pch='|', lwd=2, cex=cex/2, ...)
          },
        dot = function(....) {
            points(0,0, pch=1, lwd=2, cex=cex, ...)
            points(0,0, pch=16, cex=cex/3, ...)
          }
    )
    funs[[num.pt]](cex, ...)
}

### create size variable for mtcars
sz <- findInterval( mtcars$wt, quantile( mtcars$wt, c(0.2, 0.4, 0.6, 0.8) ) ) + 1

with(mtcars, my.symbols(wt, mpg, ms.Cleveland, num.pt=sz, add=FALSE, 
    symb.plots=TRUE))
tmp <- legend('topright', pch=1, col=NA, pt.cex=2,legend=c('Small', 'SMed', 'Medium', 'LMed', 'Large'))

my.symbols( (tmp$rect$left + tmp$text$x)/2, tmp$text$y, ms.Cleveland, num.pt=1:5,
    symb.plots=TRUE) ms.Cleveland col=NA my.symbols
-------------------------------------------------------------------------------------------------------
ylim= mvad.seq seqmtplot(mvad.seq, title="Mean time", ylim=c(0,30)) yaxis=FALSE withlegend=F par(mfrow=c(1,2))
seqmtplot(mvad.seq, title="Mean time", yaxis=F, ylim=c(0,30), withlegend=FALSE) 
axis(2, at=seq(from=0, to=30, by=5))
seqlegend(mvad.seq) seqmeant(mvad.seq)
-------------------------------------------------------------------------------------------------------
residues2 df1 <- data.frame(r1=seq(4), r2=rep(1,4),
                  c1=c(0.99613318, 0.98771518,  0.98681384, 0.99225447) )
### give order (for plotting)
df1 <- within(df1, c2 <- rank(c1))
### create blank plot
with(df1, plot(r1,r2, xlab="residues_1", ylab="residues_2", cex.lab=1.5))
### strongest red to largest color
with(df1, points(r1, r2, cex=15, pch=19, col = rev(heat.colors(4))[c2] ))
### make legend
l1 <- as.matrix(df1[ ,"c1"])
graphics::legend("topright", legend=l1, lty=1, title="covariance", lwd=3,col = rev(heat.colors(4))[df1$c2], cex=2) .png
-------------------------------------------------------------------------------------------------------
ggplot(data,aes(col1,group=col2,fill="id"))+
geom_bar(position="identity",alpha=0.5)+
scale_fill_manual(name="id",values="blue") ggplot(data,aes(col1,fill=as.factor(col2)))+geom_bar(position="dodge") guides(fill=guide_legend(title="Col2",
                       direction = "vertical",title.position="top",
                       title.vjust = 0.5)) # just example ggplot(data, aes(x = z,colour="id"))+ 
geom_density()+
scale_colour_manual(name="id",values="blue") guide-box
-------------------------------------------------------------------------------------------------------
"bottomright", "bottom", "bottomleft", "left", "topleft", "top", "topright", "right" "center" 
legend( x= "topright", y=0.92, legend=c("quantile","90st", "91st", "(90st+91st)/2"), col=c("blue", "yellow", "green", "red"),   pch=c(".",".", ".", "."))
-------------------------------------------------------------------------------------------------------
?<function name> # here I generate some example data, set.seed makes it reproducible
set.seed(33)
x <- 1:20; y0 <- 20; y1 <- 25; y2 <- 300
for(i in 2:20){
  y0 <- c(y0, y0[i-1]+rnorm(1, mean=0.25, sd=1.5))
  y1 <- c(y1, y1[i-1]+rnorm(1, mean=0,    sd=1))
  y2 <- c(y2, y2[i-1]+rnorm(1, mean=-10,  sd=5))
}
max(y0, y1)  
# [1] 35.3668
min(y0, y1)
# [1] 17.77653
# from 0 to 50 seems like a reasonable Y range for the plotting area

windows()
  plot (x, y0, pch=6,  cex=.5, col="blue", type="b", 
        xlab="Mb", ylab="Pi", ylim=c(0, 50))
  lines(x, y1, pch=18, cex=.5, col="red",  type="b")

# We need to create a new variable that will fit within this plotting area
y2new <- scale(y2)        # this makes y2 have mean 0 & sd 1
y2new <- y2new*sd(y0)     # now its sd will equal that of y0
y2new <- y2new+mean(y0)   # now its mean will also equal that of y0

  lines(x, y2new, pch=24, cex=.5, col="green", type="b")

# now y2 fits within the window, but we need an axis which must map the 
#   plotted points to the original values

summary(y0)
#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
#   17.78   20.64   24.34   25.62   30.25   35.37
summary(y2)
#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
#   125.1   178.2   222.2   220.0   266.3   300.0
sd(y0)
# [1] 5.627629
sd(y2)
#[1] 54.76167

# thus, we need an axis w/ 25.62 showing 220 instead, & where 5.63 higher
#   shows 54.76 higher instead

increments <- (mean(y0)-seq(from=0, to=50, by=10))/sd(y0)
increments
# [1]  4.5521432  2.7751960  0.9982488 -0.7786983 -2.5556455
# [6] -4.3325927
newTicks   <- mean(y2) - increments*sd(y2)
newTicks
# [1] -29.24281  68.06579 165.37438 262.68298 359.99158
# [6] 457.30017

# the bottom of the y axis in the plot is 4.55 sd's below y0's mean, 
#   thus the bottom of the new axis should be about -30, and the top of 
#   the new axis should be about 460

  axis(side=4, at=seq(0, 50, 10), labels=round(newTicks), col="green")
  legend("bottomleft", c("y0 (left axis)", "y1 (left axis)", "y2 (right axis)"), pch=c(6, 18, 24), lty=1, col=c("blue", "red", "green")) plotyy()
-------------------------------------------------------------------------------------------------------
density angle 
legend(17,47,legend= legend_map, fill=c("white","darkgrey", "black","grey30","grey13"), density = c(NA,NA,24,NA,24), angle = c(NA,NA,30,NA,110), bty="n",cex=0.6)
-------------------------------------------------------------------------------------------------------
gtable library(ggplot2)
p <- ggplot(data, aes(x = legend.var, y = score, fill = Indicator), color='black') + 
  geom_bar(width = 1, alpha=0.5, stat="identity") + 
  scale_y_continuous() + 
  coord_polar()  + 
  theme( axis.ticks = element_blank()) + 
  facet_wrap(~Village, nrow=2, ncol=3) + 
  guides(colour = guide_legend(title.hjust = 0.5)) +
  theme(legend.position=c(0.85,0.25))

#create table
library(gridExtra)
tab <- tableGrob(unique(data[, c("legend.var", "Variables")]), 
                 show.rownames=FALSE, gpar.coretext=gpar(fontsize=10), 
                 gpar.coltext=gpar(fontsize=10, fontface='bold'),
                 gpar.corefill = gpar(fill = "grey90", col = "white"),
                 gpar.colfill = gpar(fill = "grey80", col = "white"))

#arrange grobs
library(gtable)
a <- gtable(unit(c(0.7, 0.3) ,c("npc")), unit(1, "npc"))
a <- gtable_add_grob(a, ggplotGrob(p),1,1)
a <- gtable_add_grob(a, tab,1,2)

#plot
grid.draw(a)
-------------------------------------------------------------------------------------------------------
### add a column for color
dat_1 <- data.frame(xvar = x_axis, 
                  yvar = y_axis,
                  col1 = 1:7) ggplot(dat_1, aes(x=xvar, y=yvar)) +
 geom_point(shape=19, size=5, aes(colour = col1)) +
 scale_colour_continuous( low = "blue", high = "red", space = "Lab",
  name="observation", label=rep("", nrow(dat_1)) ,
  guide = guide_legend(direction = "horizontal", 
   title.position = "bottom",     title.hjust=0.5) ) +
 theme(legend.position = "bottom")  +
 scale_y_continuous(expression(atop('Net'~CO[2]~'Flux '~CO[2]~' (β)' ))) +   
 scale_x_continuous(expression(atop('Gross'~CO[2]))) "" dat_1$col1 <- rep(seq(7), 8)[-7*8] scale_color_brewer set.seed(1)
dat_1 <- data.frame(xvar = sample(1:55),
                    yvar = sample(100:154),
                    col1 = c(seq(10), rep(seq(15), each=3))
                    )
-------------------------------------------------------------------------------------------------------
guides() size linetype=0 override.aes= +guides(size= guide_legend(override.aes = list(linetype = 0)))
-------------------------------------------------------------------------------------------------------
legend plot( 0, type="n", xlim=c(0,5), ylim=c(0,5) )
A <- matrix( c( c(1,2,3,4), c(2,1,2,4)), ncol=2 )
B <- matrix( c( c(1,2,3,4), c(1,3,3,2)), ncol=2 )
lines( A, col="red" )
points( A, col="blue", pch=15 )
lines( B, col="green" )
points( B, col="purple", pch=17 )

legend( x="topleft", legend=c("Red line, blue points","Green line, purple points"),col=c("red","green"), lwd=1, lty=c(1,2),  pch=c(NA,NA) )

legend( x="topleft", legend=c("Red line, blue points","Green line, purple points"),col=c("blue","purple"), lwd=1, lty=c(0,0), pch=c(15,17) ) legend 
legend( x="topleft", legend=c("",""),col=c("blue","purple"), lwd=1, lty=c(0,0), pch=c(15,17), bty='n' ) legend
-------------------------------------------------------------------------------------------------------
true_Y = c(1,1,1,1,2,1,2,1,2,2)
probs = c(1,0.999,0.999,0.973,0.568,0.421,0.382,0.377,0.146,0.11)

getROC_AUC = function(probs, true_Y){
    probsSort = sort(probs, decreasing = TRUE, index.return = TRUE)
    val = unlist(probsSort$x)
    idx = unlist(probsSort$ix)  

    roc_y = true_Y[idx];
    stack_x = cumsum(roc_y == 2)/sum(roc_y == 2)
    stack_y = cumsum(roc_y == 1)/sum(roc_y == 1)    

    auc = sum((stack_x[2:length(roc_y)]-stack_x[1:length(roc_y)-1])*stack_y[2:length(roc_y)])
    return(list(stack_x=stack_x, stack_y=stack_y, auc=auc))
}

aList = getROC_AUC(probs, true_Y) 

stack_x = unlist(aList$stack_x)
stack_y = unlist(aList$stack_y)
auc = unlist(aList$auc)

plot(stack_x, stack_y, type = "l", col = "blue", xlab = "False Positive Rate", ylab = "True Positive Rate", main = "ROC")
axis(1, seq(0.0,1.0,0.1))
axis(2, seq(0.0,1.0,0.1))
abline(h=seq(0.0,1.0,0.1), v=seq(0.0,1.0,0.1), col="gray", lty=3)
legend(0.7, 0.3, sprintf("%3.3f",auc), lty=c(1,1), lwd=c(2.5,2.5), col="blue", title = "AUC")
-------------------------------------------------------------------------------------------------------
h1$set(dom = "myChart") server.R server.R ui.R renderChart2 dev rCharts renderChart require(rCharts)
require(shiny)
runApp(list(
  ui =  pageWithSidebar(
    headerPanel("rCharts: Highcharts"),
    sidebarPanel(selectInput(
      inputId = "x",
      label = "Choose X",
      choices = c('SepalLength', 'SepalWidth', 'PetalLength', 'PetalWidth'),
      selected = "SepalLength"
    )),
    mainPanel(showOutput("myChart", "Highcharts"))
  ),
  server = function(input, output){
    output$myChart <- renderChart2({
      h1 <- Highcharts$new()
      h1$chart(type = "spline")
      h1$series(data = c(1, 3, 2, 4, 5), dashStyle = "longdash")
      h1$series(data = c(NA, 4, 1, 3, 4), dashStyle = "shortdot")
      h1$legend(symbolWidth = 80)
      return(h1)
    })
  }
))
-------------------------------------------------------------------------------------------------------
rev(terrain.colors()) ?raster::plot my_col = rev(terrain.colors(n = 4))
# my_col = c('beige','red','green','blue') legend = FALSE plot(my_raster, legend = FALSE, col = my_col) fill
 legend(x='bottomleft', legend = c("land", "ocean/lake", "rivers", "water bodies"), fill = my_col)
-------------------------------------------------------------------------------------------------------
# original data
type <- factor(rep(c("A", "B", "C"), 5))
x <- 1:15
y <- 2 * x + rnorm(15, 0, 2)

df <- data.frame(type, x, y)

# create a copy of original data, but set y = x
# this data will be used for the one-to-one line
df2 <- data.frame(type, x, y = x)

# bind original and 'one-to-one data' together
df3 <- rbind.data.frame(df, df2)

# create a grouping variable to separate stat_smoothers based on original and one-to-one data 
df3$grp <- as.factor(rep(1:2, each = nrow(df)))

# plot
# use original data for points
# use 'double data' for abline and one-to-one line, set colours by group
ggplot(df, aes(x = x, y = y)) +
  geom_point(size = 3) +
  facet_wrap(~ type) +
  stat_smooth(data = df3, aes(colour = grp), method = "lm", se = FALSE, size = 1) +
  scale_colour_manual(values = c("red","blue"),
                      labels = c("abline", "one-to-one"),
                      name = "") +
  theme(legend.position = "top")

# If you rather want to stack the two keys in the legend you can add:
# guide = guide_legend(direction = "vertical")
#...as argument in scale_colour_manual geom_abline
-------------------------------------------------------------------------------------------------------
coord_cartesian limits df1.m$grp <- ifelse(df1.m$variable %in% c('3rd-person verbs','Nouns'),'grp1','grp2')
g1 <- ggplot(df1.m, aes(group=grp, categories, value, shape=variable, colour=variable)) + 
        geom_hline(yintercept=0, size=4, color="white") + 
        geom_point(aes(shape=variable), size=2, alpha=I(0.8)) + 
        scale_shape_manual(values = 1:12) + 
        geom_smooth() + 
        scale_x_discrete("\n(a) Involved features", expand=c(0.05, 0.05)) + 
        coord_cartesian(ylim=(c(-1,1))) + 
        scale_y_continuous(name="Log Odds Ratio", oob=rescale_none) + 
        guides(colour=guide_legend(title=NULL), shape=guide_legend(title=NULL)) + 
        theme(legend.position="right",
                 legend.justification=c(0,0),
                 legend.text=element_text(size=10),
                 panel.grid.minor = element_blank(),
                 axis.text=element_text(size=10,color="black"),
                 axis.title=element_text(size=12,face="bold")
                ) grid.arrange
-------------------------------------------------------------------------------------------------------
stat_function legend stat_summary geom_line stat_summary # load relevant packages
library(ggplot2)
library(reshape2)
library(RColorBrewer)
library(gridExtra)
library(gtable)
library(plyr)

# create base data
df <- data.frame(A = rnorm(1000, sd = 0.25), 
                 B = rnorm(1000, sd = 0.25),
                 C = rnorm(1000, sd = 0.25))    
melt.df <- melt(df)
melt.df$ypos <- as.numeric(melt.df$variable)

# plot points only, to get a colour legend for points
p1 <- ggplot(data = melt.df, aes(x = value, y = ypos, colour = variable)) +
  geom_point(position = "jitter", alpha = 0.2, size = 2) + 
  xlim(-1, 1) + ylim(-5, 5) +
  guides(colour = 
           guide_legend("Type", override.aes = list(alpha = 1, size = 4)))

p1

# grab colour legend for points
legend_points <- gtable_filter(ggplot_gtable(ggplot_build(p1)), "guide-box")

# grab colours for points. To be used in final plot
point_cols <- unique(ggplot_build(p1)[["data"]][[1]]$colour)


# create data for lines
# define function for lines
fun.bar <- function(x, param = 4) {
  return(((x + 1) ^ (1 - param)) / (1 - param))
}

# parameters for lines
pars = c(1.7, 2:8)

# for each value of parameters and x (i.e. x = melt.df$value),
# calculate ypos for lines
df2 <- ldply(.data = pars, .fun = function(pars){
  ypos = fun.bar(melt.df$value, pars)
  data.frame(pars = pars, value = melt.df$value, ypos)
})

# colour palette for lines
line_cols <- brewer.pal(length(pars), "Set1")    

# plot lines only, to get a colour legends for lines
# please note that when using ylim:
# "Observations not in this range will be dropped completely and not passed to any other layers"
# thus the warnings
p2 <- ggplot(data = df2,
             aes(x = value, y = ypos, group = pars, colour = as.factor(pars))) +
  geom_line() +
  xlim(-1, 1) + ylim(-5, 5) +
  scale_colour_manual(name = "Param", values = line_cols, labels = as.character(pars))

p2

# grab colour legend for lines
legend_lines <- gtable_filter(ggplot_gtable(ggplot_build(p2)), "guide-box") 


# plot both points and lines with legend suppressed
p3 <- ggplot(data = melt.df, aes(x = value, y = ypos)) +
  geom_point(aes(colour = variable),
             position = "jitter", alpha = 0.2, size = 2) +
  geom_line(data = df2, aes(group = pars, colour = as.factor(pars))) +
  xlim(-1, 1) + ylim(-5, 5) +
  theme(legend.position = "none") +
  scale_colour_manual(values = c(line_cols, point_cols))
  # the colours in 'scale_colour_manual' are added in the order they appear in the legend
  # line colour (2, 3) appear before point cols (A, B, C)
  # slightly hard-coded
  # see alternative below

p3

# arrange plot and legends for points and lines with viewports
# define plotting regions (viewports)
# some hard-coding of positions
grid.newpage()
vp_plot <- viewport(x = 0.45, y = 0.5,
                    width = 0.9, height = 1)

vp_legend_points <- viewport(x = 0.91, y = 0.7,
                      width = 0.1, height = 0.25)

vp_legend_lines <- viewport(x = 0.93, y = 0.35,
                         width = 0.1, height = 0.75)

# add plot
print(p3, vp = vp_plot)

# add legend for points
upViewport(0)
pushViewport(vp_legend_points)
grid.draw(legend_points)

# add legend for lines
upViewport(0)
pushViewport(vp_legend_lines)
grid.draw(legend_lines) # A second alternative, with greater control over the colours
# First, plot both points and lines with colour legend suppressed
# let ggplot choose the colours
p3 <- ggplot(data = melt.df, aes(x = value, y = ypos)) +
  geom_point(aes(colour = variable),
             position = "jitter", alpha = 0.2, size = 2) +
  geom_line(data = df2, aes(group = pars, colour = as.factor(pars))) +
  xlim(-1, 1) + ylim(-5, 5) +
  theme(legend.position = "none")

p3

# build p3 for rendering
# get a list of data frames (one for each layer) that can be manipulated
pp3 <- ggplot_build(p3)

# grab the whole vector of point colours from plot p1
point_cols_vec <- ggplot_build(p1)[["data"]][[1]]$colour

# grab the whole vector of line colours from plot p2
line_cols_vec <- ggplot_build(p2)[["data"]][[1]]$colour

# replace 'colour' values for points, with the colours from plot p1
# points are in the first layer -> first element in the 'data' list
pp3[["data"]][[1]]$colour <- point_cols_vec

# replace 'colour' values for lines, with the colours from plot p2
# lines are in the second layer -> second element in the 'data' list
pp3[["data"]][[2]]$colour <- line_cols_vec

# build a plot grob from the data generated by ggplot_build
# to be used in grid.draw below
grob3 <- ggplot_gtable(pp3)

# arrange plot and the two legends with viewports
# define plotting regions (viewports)
vp_plot <- viewport(x = 0.45, y = 0.5,
                    width = 0.9, height = 1)

vp_legend_points <- viewport(x = 0.91, y = 0.7,
                             width = 0.1, height = 0.25)

vp_legend_lines <- viewport(x = 0.92, y = 0.35,
                            width = 0.1, height = 0.75)

grid.newpage()

pushViewport(vp_plot)
grid.draw(grob3)

upViewport(0)
pushViewport(vp_legend_points)
grid.draw(legend_points)

upViewport(0)
pushViewport(vp_legend_lines)
grid.draw(legend_lines)
-------------------------------------------------------------------------------------------------------
fun.bar <- function(x, param = 4) {
  return(((x + 1) ^ (1 - param)) / (1 - param))
}

plot.foo <- function(df, par = c(1.7, 2:8)) {
  require(ggplot2)
  require(reshape2)
  require(RColorBrewer)
  melt.df <- melt(df)
  melt.df$ypos <- as.numeric(melt.df$variable)
  # the trick is to override factor levels
  levels(melt.df$variable) <- 1:nlevels(melt.df$variable)
  p <- ggplot(data = melt.df, aes(x = value, y = ypos, colour = variable)) +
    geom_point(position = "jitter", alpha = 0.2, size = 2) + 
    xlim(-1, 1) + ylim(-5, 5) + 
    guides(colour = 
      guide_legend("Type", override.aes = list(alpha = 1, size = 4)))
  pal <- brewer.pal(length(par), "Set1")
  for (i in seq_along(par)) {
    p <- p + stat_function(fun = fun.bar, 
      arg = list(param = par[i]), colour = pal[i], size = 1.3)
  }
  # points are displayed by supplying values for manual scale
  p + scale_colour_manual(values = pal, limits = seq_along(par), labels = par) + 
  # this needs proper "for" cycle to remove hardcoded labels
  annotate("text", x = 0.8, y = 1, label = "A", size = 8) +
  annotate("text", x = 0.8, y = 2, label = "B", size = 8) +
  annotate("text", x = 0.8, y = 3, label = "C", size = 8)
}

df.foo <- data.frame(A=rnorm(1000, sd=0.25), 
  B=rnorm(1000, sd=0.25), C=rnorm(1000, sd=0.25))
plot.foo(df.foo)
-------------------------------------------------------------------------------------------------------
df library("ggplot2")
library("reshape2")
library("grid") df.m df.m <- melt(df, id="Years")
df.m$measure <- gsub("(.*) \\(.*", "\\1", df.m$variable)
df.m$facet <- gsub(".*\\((.*)\\)", "\\1", df.m$variable) colour shape variable shape colour ggplot(df.m, aes(group=1, x=Years, y=value, colour=measure, shape=measure)) +
    scale_colour_manual(name='', values=c('chartreuse4', 'deepskyblue3')) +
    scale_shape_manual(name='', values=c(19, 17)) +
    geom_point(size=3) +
    facet_grid(.~facet) +
    coord_cartesian(ylim=(c(0.0,0.45))) +
    scale_x_discrete("", expand=c(0.01, 0.01)) +
    scale_y_continuous(name="") +
    guides(colour=guide_legend(title='', ncol=2, keywidth=unit(2,'lines'))) +
    theme(legend.position="top",
          legend.key=element_blank(),
          legend.background=element_rect(colour='black', fill='transparent'),
          legend.text=element_text(size=12),
          panel.grid.minor = element_blank(),
          panel.margin=unit(1, 'lines'),
          axis.text=element_text(size=12,color="black"),
          axis.title=element_text(size=16),
          strip.text.y = element_text(size = 14)) breaks scale_colour_manual scale_shape_manual g <- g + scale_colour_manual(name='',
                             breaks=c('% of Women (Physics)', 'Divergence (Physics)'),
                             labels=c('% of Women', 'Divergence'),
                             values=c('chartreuse4', 'deepskyblue3','chartreuse4', 
                                      'deepskyblue3', 'chartreuse4', 'deepskyblue3'))
g <- g + scale_shape_manual(name='',
                            breaks=c('% of Women (Physics)', 'Divergence (Physics)'),
                            labels=c('% of Women', 'Divergence'),
                            values=c(19, 17, 19, 17, 19, 17))
-------------------------------------------------------------------------------------------------------
legend("topright",col=c("blue", "red"), lwd=2,
 legend=c("signal","std dev"), cex=0.85, bty="n", xjust=1, seg.len=0.5)
-------------------------------------------------------------------------------------------------------
warning labels par table text table plot plot.factor #random data.  DF = datProjektMehr, artmehr = ArtMehrspr, mehrviel = Mehrspr_Vielf 
    DF <- data.frame(artmehr = sample(letters[1:4], 20, T), mehrviel = as.factor(sample(1:5, 20, T)))

    #your code of plotting
    par(mar = c(4.5,4.5,9.5,4), xpd = TRUE)
    plot(factor(artmehr) ~ mehrviel, data = DF, col = terrain.colors(4),
         bty = 'L', main = "Vielfalt nutzen")
    legend("topright", inset=c(0,-.225), title="Art der Mehrsprachigkeit",    levels(factor(DF$artmehr)),fill=terrain.colors(4), horiz=TRUE)

    #no need to "table()" many times
    tab = table(DF$artmehr, DF$mehrviel)

    #maximum value of x axis (at least in my machine)
    #I found -through trial and error- that for a factor of n levels, x.max = 1 + (n-1)*0.02
    x.max = 1 + (length(levels(DF$mehrviel)) - 1) * 0.02

    #coordinates of "mehrviel" (as I named it)
    mehrviel.coords = ((cumsum(apply(tab, 2, sum)) / sum(tab)) * x.max) - ((apply(tab, 2, sum) / sum(tab)) / 2)

    #coordinates of "artmehr" (as I named it)
    artmehr.coords <- apply(tab, 2, function(x) { cumsum(x / sum(x)) })
    artmehr.coords <- apply(artmehr.coords, 2, function(x) { x - c(x[1]/2, diff(x)/2) })

    #"text" the values in your table
    #don't plot "0"s
    for(i in 1:ncol(artmehr.coords))
     {
      text(x = mehrviel.coords[i], y = artmehr.coords[,i], labels = ifelse(tab[,i] != 0, tab[,i], ""), cex = 2)
     } table tab
       1 2 3 4 5
     a 1 1 0 1 0
     b 0 0 2 1 2
     c 1 1 2 1 0
     d 2 0 0 3 2 level text
-------------------------------------------------------------------------------------------------------
pairs(iris[1:4], 
  main = "Width and Length (cm) of Iris's Petals and Sepals: Setosa, Veriscolor, Virginica", 
  pch = 24, bg = c("mediumorchid4", "mediumpurple1", "lightpink1")[unclass(iris$Species)], 
  upper.panel=NULL, labels=c("Sepal Length","Sepal Width","Petal Length","Petal Width"), 
  font.labels=1, cex.labels=2)

legend(x = "topright",legend = levels(iris$Species),pch = 24,pt.bg = c("mediumorchid4", "mediumpurple1", "lightpink1"),inset = 0.1) locator inset
-------------------------------------------------------------------------------------------------------
n <- 50
data <- data.frame(years=1950+(1:n), cars=rnorm(n), emission=runif(n,0,10)) itvl <- c(0,2,4,6,8,10)
plot(data$years, data$cars, cex=findInterval(data$emission, itvl), col="black" ) legend() legend("topright", legend=itvl, pt.cex=itvl, pch=1)
-------------------------------------------------------------------------------------------------------
ggplot2 melt reshape2 complete.cases library(reshape2)

dat.m <- melt(dat)
library(ggplot2)
ggplot(dat.m[complete.cases(dat.m),]) +
  geom_line(aes(x=Var1,y=value,color=factor(Var2))) +
  xlab("location")+ylab("Measurement")+
  guides(color = guide_legend(title = "Tube numbers"))
-------------------------------------------------------------------------------------------------------
pdf(file="myplot.pdf", width = 10, height =13) #create new pdf
plot(diff ~ abund_mean) #see data
abline(lm<- lm(diff ~ abund_mean)) #add regression to plot 
legend("topright", bty="n", legend=paste
("R2 is", format(summary(lm)$adj.r.squared, digits=4))) #print the regr. coeff. on plot
dev.off() #end of pdf creation
summary(lm) #see all the regression coefficients (F-statistic, RSE, etc.)
-------------------------------------------------------------------------------------------------------
guides() override.aes= size= fill=NA legend.key= theme() df<-data.frame(x=rep(1:5,each=3),y=1:15,group=rep(c("A","B","C"),each=5))
ggplot(df,aes(x,y,color=group,fill=group))+geom_line()+
  guides(colour = guide_legend(override.aes = list(size = 10)))+
  theme(legend.key=element_rect(fill=NA))
-------------------------------------------------------------------------------------------------------
fill=NA override.aes= stat_smooth() se=TRUE theme() legend.key= ggplot(dd, aes(x = x, y = y, colour = col)) + geom_point(alpha = 1/5)+
  stat_smooth(method = "lm")+
  guides(colour = guide_legend(override.aes = list(alpha = 1,fill=NA))) + 
  theme(legend.key=element_rect(fill="white"))
-------------------------------------------------------------------------------------------------------
image #matrix with the part of your data 10x10 you uploaded
mat <- as.matrix(read.table(text = "0 0 0 0 0 0 0 0 0 0
41 10 2 0 0 0 0 0 0 0
75 36 20 9 4 2 1 0 0 0
91 65 47 31 20 13 8 5 3 2
97 78 64 47 35 25 18 12 8 5
99 88 76 63 50 39 29 22 16 11
99 93 85 74 63 52 42 32 25 19
99 96 91 83 73 64 53 44 35 28
99 98 94 88 81 72 64 54 46 37
99 98 96 92 87 80 72 64 55 47"))

#neccessary step to `image` the expected. read `?image`
t_mat <- t(mat[ncol(mat):1,])

#basic plot
image(t_mat, col = colorRampPalette(c("blue", "red"))(10), axes = F)

#creaty matrix with `NA`s and fill 
#only the values you want to appear yellow.
#here: say 45 to 55
yellows <- matrix(nrow = nrow(t_mat), ncol = ncol(t_mat))
yellows[which(t_mat > 45 & t_mat < 55)] <- t_mat[which(t_mat > 45 & t_mat < 55)] 

#overlay "yellows" to basic plot
image(yellows, col = rgb(1,1,0,1/2), add = T) legend title(main = "imageplot", xlab = "x axis", ylab = "y axis")
legend(x = 0.6, y = 1.15, legend = c("<45", "45-55", ">55"), fill = c("blue", rgb(1,1,0,1/2), "red"), xpd = T, ncol = 3) #I guess you'll need to use `axis(1, at = seq(0,1,0.0101), labels = seq(1, 100, 1))` 
#but I'm not sure
axis(1, at = seq(0,1,0.11), labels = seq(1, 10, 1)) 
axis(2, at = seq(0,1,0.11), labels = seq(1, 10, 1))
-------------------------------------------------------------------------------------------------------
library(maps) 
library(mapdata)

test<-data.frame(Authors=(letters[1:9]), LAT=runif(9,-90,90), LONG=runif(9,-180,180))
map('worldHires') 
text(test$LONG,test$LAT,labels=1:9, col="red", font=2)
legend("bottom",legend=test$Authors, col="red", pch=as.character(1:9), bg="white", ncol=3) text points points pch=as.character(1:9) font=2
-------------------------------------------------------------------------------------------------------
rcrop legend(x = 'top', legend = unique(getValues(rcrop)), fill = my_col)
-------------------------------------------------------------------------------------------------------
plot(rcrop,col=my_col[unique(getValues(rcrop))],legend=F,box=F,axes=F)
legend_full<-data.frame(levels(rcrop))
legend(x='top', legend =as.character(unlist(legend_full[unique(getValues(rcrop)),2])),fill = my_col[unique(getValues(rcrop))])
-------------------------------------------------------------------------------------------------------
bar ## second try--facet by county

N = 100
industry = ['a','b','c']
city = ['x','y','z']
ind = np.random.choice(industry, N)
cty = np.random.choice(city, N)
jobs = np.random.randint(low=1,high=250,size=N)
df_city =pd.DataFrame({'industry':ind,'city':cty,'jobs':jobs})

## how many panels do we need?
cols =df_city.city.value_counts().shape[0]
fig, axes = plt.subplots(1, cols, figsize=(8, 8))

for x, city in enumerate(df_city.city.value_counts().index.values):
    data = df_city[(df_city['city'] == city)]
    data = data.groupby(['industry']).jobs.sum()
    print (data)
    print type(data.index)
    left=  [k[0] for k in enumerate(data)]
    right=  [k[1] for k in enumerate(data)]

    axes[x].bar(left,right,label="%s" % (city))
    axes[x].set_xticks(left, minor=False)
    axes[x].set_xticklabels(data.index.values)

    axes[x].legend(loc='best')
    axes[x].grid(True)
    fig.suptitle('Employment By Industry By City', fontsize=20)
-------------------------------------------------------------------------------------------------------
#random data
DF <- data.frame(range = c("10 - 20", "28 - 30", "3 - 8", 
                          "100 - 180", "185 - 190", "200 - 350"), 
                    type = rep(c("helix", "beta", "turn"), 2), stringsAsFactors = F)

#manipulate "from - to" numerically
newDF <- cbind(DF, do.call(rbind, strsplit(DF$range, " - ")), stringsAsFactors = F)
names(newDF) <- c(names(DF), "xleft", "xright") #name the columns
newDF$"xleft" <- as.numeric(newDF$"xleft")  #make the values numeric
newDF$"xright" <- as.numeric(newDF$"xright") # -//-

#> newDF
#      range  type xleft xright
#1   10 - 20 helix    10     20
#2   28 - 30  beta    28     30
#3     3 - 8  turn     3      8
#4 100 - 180 helix   100    180
#5 185 - 190  beta   185    190
#6 200 - 350  turn   200    350

#color for each type
colors. <- c(rgb(0,1,0,1/3), rgb(0,0,1,1/3), rgb(1,0,0,1/3))[as.factor(newDF$type)]

#background plot 
plot(NULL, xlim = c(0, max(newDF[c("xleft", "xright")])), 
                        ylim = c(0,1), yaxt = "n", ann = F)

#legend
legend(x = max([c("xleft", "xright")]) * 0.5, y = 1.15, xpd = T, ncol = 3, legend = c("beta"), fill = c(rgb(0,1,0,1/3), rgb(0,0,1,1/3), rgb(1,0,0,1/3)))

#function that draws rectangles for each range
fun <- function(xl, yb, xr, yt, col.)
{
 rect(xleft = xl, ybottom = yb, xright = xr, ytop = yt, col = col.)
} 

#draw all rectangles
mapply(fun, xl = newDF$xleft, xr = newDF$xright, col. = colors., 
                       MoreArgs = list(yb = 0, yt = 1)) jpeg
-------------------------------------------------------------------------------------------------------
chart.TimeSeries cex.main cex.lab title par par() main="" las library(PerformanceAnalytics)
data(managers)
par(mar=c(1,4,4,2)) # c(bottom, left, top, right)
chart.CumReturns(managers[,1:3],geometric=TRUE,wealth.index=TRUE,main="",xlab="",col=bluefocus,cex.axis=0.8,cex.lab=0.6,las=1)
par(xpd=NA)
legend(legend=paste(paste(c("Performance indexiert"),"1")),cex=0.7, col=bluefocus,lty=1, lwd=2, bty="n", 
text.col="black", ncol=1, "bottom", inset = c(0.0, -.20))
text_note=c(paste("Quelle: Bloomberg,", "letzter Datenpunkt:", "last(data$date)"))
mtext(text_note ,cex=0.4,col="grey",side = 1, line = 4, outer = FALSE,padj=0,adj=1)
-------------------------------------------------------------------------------------------------------
guides() ggplot(diamonds, aes(x=x, y=price, colour=color, size=depth)) + 
geom_point() + 
guides(size=guide_legend(override.aes=list(colour="steelblue")))
-------------------------------------------------------------------------------------------------------
apply quantile set.seed(1)
Fund <- matrix(rnorm(20*10), ncol=20, nrow=10)
qs <- apply(Fund, 2, quantile, probs=c(0.05, 0.5, 0.95))
qs
ylim=range(qs)
plot(seq(ncol(Fund)), qs[1,], t="l", lty=2, ylim=ylim) #5%
lines(seq(ncol(Fund)), qs[2,], lty=1, lwd=2) #50%
lines(seq(ncol(Fund)), qs[3,], lty=2, col=2)  #95%
legend("topleft", legend=rev(rownames(qs)), lwd=c(1,2,1), col=c(2,1,1), lty=c(2,1,2))
-------------------------------------------------------------------------------------------------------
plot.trellis # Save the legend from the last plot
plot.grob = trellis.last.object()
legend.grob = lattice:::evaluate.legend( plot.grob$legend )

# Modify the default plotting function
f = lattice:::plot.trellis
b = body(f)
fun.line = which(!is.na(str_match(as.character(b),"evaluate.legend")))
new.line = substitute(legend <- if(is.null(legend.object)) 
                        evaluate.legend(x$legend) else legend.object)
body(f)[[fun.line]] = new.line
args = formals(f)
formals(f) = do.call(alist, c( args[2:length(args)-1], alist(legend.object=NULL,...=)) )

# Note that evaluate.legend is no longer taking up any time because it's not called
Rprof()
f(plot.grob,legend.object=legend.grob)
Rprof(NULL)
head(summaryRprof()$by.total)

# the modified function is faster
times = data.frame( modified.fun=NA, standard.fun=NA )
for( i in 1:100 ) {
  t1 = profr( f(plot.grob,legend.object=legend.grob), interval=0.001 )[1,"time"]
  t2 = profr( plot(plot.grob), interval=0.001 )[1,"time"]
  times = rbind( times, c( t1, t2 ) )
}
colMeans(na.omit(times))
modified.fun standard.fun 
     0.11435      0.19757 evaluate.legend plot.trellis plot.trellis grid plot.trellis grid grid
-------------------------------------------------------------------------------------------------------
guides() override.aes= ggplot(df) + geom_point(aes(x, y, color=z), alpha=0.1)+
  guides(colour = guide_legend(override.aes = list(alpha=1)))
-------------------------------------------------------------------------------------------------------
names=data$method
x = 1:13*2-1
CI.up = as.numeric(data$mean)+as.numeric(data$ci)
CI.dn = as.numeric(data$mean)-as.numeric(data$ci)
plot(data$mean~x, cex=1.5,xaxt='n',ylim=c(0.3,0.40), xlab='',ylab='lalala!', main='blahblahblah',col='blue',pch=16)
axis(1, at=x, labels=names)
arrows(x,CI.dn,x,CI.up,code=3,length=0.2,angle=90,col='red')
legend("bottomleft",paste(names,": S.E=",data$se),ncol=6,text.width=1)
-------------------------------------------------------------------------------------------------------
data = read.csv(file="home",sep=",")

df = data.frame(data)
df

   ExperimentID clients connections msgSize     Mean Deviation     Error
1             4      50          50      10 73.19379 21.313889 0.2263254
2             5      50          10      10 73.25170 21.457139 0.2265276
3             6      50         100      10 73.20642 21.396485 0.2261432
4             7      50          50    1999 53.75247 11.863616 0.1695395
5             8      50          10    1999 53.88464 12.778998 0.2234775
6             9      50         100    1999 53.99422 11.947930 0.2085102
7            10      10          50    1999 49.74034  9.296995 0.3855425
8            11      10          10    1999 49.77624  8.639379 0.3566724
9            12      10         100    1999 50.30912 10.800443 0.4442306
10           13      10          50      10 68.80108 19.674006 0.5892552
11           14      10          10      10 69.41143 19.671618 0.5845524
12           15      10         100      10 69.09130 19.821473 0.5894541
13           16     100          10    1999 56.32045 16.370877 0.1940681
14           17     100          50    1999 55.93405 14.007772 0.2272496

par(mfrow=c(1,2)) #plot two graphs (Message Size = 10 and Message Size = 1999) side by side.

msg_10 = subset(df, data_df$msgSize == 10)
msg_10

   ExperimentID clients connections msgSize     Mean Deviation     Error
1             4      50          50      10 73.19379  21.31389 0.2263254
2             5      50          10      10 73.25170  21.45714 0.2265276
3             6      50         100      10 73.20642  21.39648 0.2261432
10           13      10          50      10 68.80108  19.67401 0.5892552
11           14      10          10      10 69.41143  19.67162 0.5845524
12           15      10         100      10 69.09130  19.82147 0.5894541


plot(msg_10$Mean ~ msg_10$clients, col=as.factor(msg_10$connections), pch=19,  xlab="Clients", ylab="Mean", xlim=c(0,60), ylim=c(68,74), main="Message Size = 10",cex.main=0.85)
legend("bottomright", legend=unique(msg_10$connections), col=as.factor(msg_10$connections),pch=19,title="connections")

msg_1999 = subset(df, data_df$msgSize == 1999)
msg_1999

   ExperimentID clients connections msgSize     Mean Deviation     Error
4             7      50          50    1999 53.75247 11.863616 0.1695395
5             8      50          10    1999 53.88464 12.778998 0.2234775
6             9      50         100    1999 53.99422 11.947930 0.2085102
7            10      10          50    1999 49.74034  9.296995 0.3855425
8            11      10          10    1999 49.77624  8.639379 0.3566724
9            12      10         100    1999 50.30912 10.800443 0.4442306
13           16     100          10    1999 56.32045 16.370877 0.1940681
14           17     100          50    1999 55.93405 14.007772 0.2272496


plot(msg_1999$Mean ~ msg_1999$clients, col=as.factor(msg_1999$connections), pch=19, xlab="Clients", ylab="Mean", xlim=c(0,100), ylim=c(48,58), main="Message Size = 1999",cex.main=0.85)
legend("bottomright", legend=unique(msg_1999$connections), col=as.factor(msg_1999$connections),pch=19,title="connections") #Message Size = 10
ggplot(data=msg_10,aes(clients,Mean)) + geom_point(data=msg_10,aes(color=as.factor(connections)),size=5) + theme_bw() + labs(title="Message Size = 10", color="Connections")

#Message Size = 1999
ggplot(data=msg_1999,aes(clients,Mean)) + geom_point(data=msg_1999,aes(color=as.factor(connections)),size=5) + theme_bw() + labs(title="Message Size = 1999", color="Connections")
-------------------------------------------------------------------------------------------------------
pretty() common_x ## Setup
library(data.table)
library(plyr)
library(ggplot2)

spec <- function(){
  x <- runif(100, 0, 100)
  data.frame(x=x, y=jitter(dnorm(x, mean=jitter(50), sd=jitter(5)), amount=0.01))
}
all <- ldply(1:5, function(ii) data.frame(spec(), id=ii))

## Function that uses data.table rather than plyr to compute and add offsets
spread_plot <- function(d, s=1){
    d <- data.table(d, key="id")
    ranges <- d[, list(min=min(x), max=max(x), length=length(x)),by="id"]
    common_x <- seq(max(ranges$min), min(ranges$max), length=max(ranges$length))
    new_y <- d[,list(y=approx(x, y, common_x)$y, N=seq_along(common_x)),
               by="id"]
    shift <- max(new_y[, max(abs(diff(y))), by = "N"][[2]])
    shift <- pretty(c(0, shift), n=0)[2]
    origins <- s*seq(0, by=shift, length=length(unique(d$id)))
    d[,y:=(y + origins[.GRP]),by="id"]
    d
}

## Try it out
test <- spread_plot(all)
ggplot(test, aes(x, y, colour=id, group=id))+
  geom_line() + guides(colour=guide_legend())
-------------------------------------------------------------------------------------------------------
geom_line() ggplot(data3, aes(year, NY.GDP.MKTP.KD.ZG, color = country)) + geom_line() + 
  xlab('Year') + ylab('GDP per capita') +
labs(title = "Annual GDP Growth rate (%)") +
  theme_bw() +
  geom_line(data=subset(data3, country == "China"), colour="black", size=1.5) override.aes # Needed to access hue_pal(), which is where ggplot's
# default colours come from
library(scales)

ggplot(data3, aes(year, NY.GDP.MKTP.KD.ZG, color = country)) + geom_line() + 
  xlab('Year') + ylab('GDP per capita') +
  labs(title = "Annual GDP Growth rate (%)") +
  theme_bw() +
  geom_line(data=subset(data3, country == "World"), colour="black", size=1.5) +
  guides(colour=guide_legend(override.aes=list(
    colour=c(hue_pal()(11)[1:10], "black"), size=c(rep(1, 10), 1.5))))
-------------------------------------------------------------------------------------------------------
grid.arrange g_legend<-function(a.gplot){
  tmp <- ggplot_gtable(ggplot_build(a.gplot))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)}

n <- 4; cols <- hcl(h=seq(15, 375-360/n, length=n)%%360, c=100, l=65)

cols1 <- cols[4:3]
names(cols1) <-  c("positive", "non-positive")
plt_1 <- ggplot(data.one) + 
  geom_point(data=data.one,aes(x, y, color=lbl)) +
  scale_color_manual(values=cols1)


cols2 <- cols[1:2]
names(cols2) <-  c("high", "low")
plt_2 <- ggplot(data.one) + 
  geom_line(data=data.two, aes(x, y, color=classification)) +
  scale_color_manual(values=cols2)


mylegend_1<-g_legend(plt_1)
mylegend_2<-g_legend(plt_2)

plt <- ggplot(data.one) + 
  geom_point(data=data.one,aes(x, y, color=lbl)) +
  geom_line(data=data.two, aes(x, y, color=classification)) +
  scale_color_discrete(guide="none")

library(gridExtra)
grid.arrange(plt,
             arrangeGrob(mylegend_1, mylegend_2, nrow=6),
             ncol=2,widths=c(7,1))
-------------------------------------------------------------------------------------------------------
expression plot(1,1)
legend("topleft", expression(paste(Delta, "Value")))
-------------------------------------------------------------------------------------------------------
aes() p <- ggplot(Data, aes(x=IndID, y=Avg))+
  geom_point(aes(color = "Avg"))+
  geom_errorbar(aes(ymin=Avg-AvgSE, ymax=Avg+AvgSE))+
  geom_point(aes(y=OBS, color = "OBS"), pch = 8, show_guide = T) +
  theme(axis.text.x=element_text(angle=30, hjust=1)) scale_colour_manual() guides() p + scale_colour_manual(values = c("black", "red")) + 
  guides(colour = guide_legend(override.aes = list(shape = c(16, 8))))
-------------------------------------------------------------------------------------------------------
library(doMPI)
nworkers <- 4
cl <- startMPIcluster(nworkers)
comm <- cl$comm  # get communicator number
registerDoMPI(cl)
cap <- capabilities()
if (cap['aqua']) quartz() else if (cap['X11']) X11() else windows()
plot(integer(0), integer(0),
     main='Random points generated by doMPI workers',
     xlab='X', ylab='Y', xlim=c(1,100), ylim=c(1,100))
legend('topright', sprintf('worker %d', 1:nworkers), pch=1:nworkers)

# The argument "p" is a list of arguments to the function "points"
plotpoint <- function(x, p) {
  do.call('points', p)
  x
}

foreach(i=icount(100), .combine='plotpoint',
        .init=NULL, .inorder=FALSE) %dopar% {
  Sys.sleep(abs(rnorm(1, mean=3)))
  list(x=sample(100,1), y=sample(80,1), pch=mpi.comm.rank(comm))
}
text(50, 90, 'Finished')
Sys.sleep(10)

closeCluster(cl)
mpi.quit() points plotpoint x .init
-------------------------------------------------------------------------------------------------------
color= fill= p+guides(color=guide_legend("Legend title")) p + labs(color="Legend title")
-------------------------------------------------------------------------------------------------------
show_guide=FALSE geom_boxplot() override.aes= guide_legend() guides() paste() expression() ggplot()+
  geom_boxplot(data=r2df.realtime,aes(as.factor(yr),r2phvrcn,col='model1'),
                                           outlier.shape=3,show_guide=FALSE)+
  geom_boxplot(data=r2df,aes(x=as.factor(yr),y=r2phv,col='model2'),show_guide=FALSE)+
  geom_point(data=r2df,aes(x=as.factor(yr),y=r2recon,col='model3'),shape=6)+
  geom_point(data=r2df.sameyr,aes(x=as.factor(yr),y=r2phvrcn,col='model4'),shape=6)+
  scale_color_manual(values=c('blue','red','green','black'))+
  facet_grid(~mth)+
  guides(color=guide_legend('Model',override.aes=list(shape=c(1,1,6,6))))+
  labs(title=expression(paste("Real-time Ensemble of Cross-Validated Skill Scores 
                                                                (",r^2,")",sep='')))
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(reshape)
event.day <- c("A", "A", "A", "A", "B", "B")
event <- c(1, 2, 3, 4, 5, 6)
sys <- c(120, 160, 100, 180, 100, 180)
duration <- c(50, 100, 50, 150, 350, 0)
df <- data.frame(event.day, event, sys, duration)
df$end <- c(df$sys[-1], NA)

## replacing na values
df.value.na <- is.na(df$end)
df[df.value.na,]$end <- df[df.value.na,]$sys

## calculating the slope
df$slope <- df$end / df$sys

## creating rows for each event depending on the duration
event.id <- vector()
segment.id <- vector()

for(i in 1:nrow(df)) {
event.id <- c(event.id, rep(df[i,]$event, each = df[i,]$duration))
segment.id <- c(segment.id,c(1:df[i,]$duration))
}

## merging the original dataframe with the additional segments
df.segments <- data.frame(event.id, segment.id) 
df <- merge(df, df.segments, by.x = c("event"), by.y = c("event.id"))

## calculate the start and end values for the newly created segements
df$segment.start <- df$sys + (df$segment.id - 1) * (df$end - df$sys) / df$duration
df$segment.end <- df$sys + (df$segment.id) * (df$end - df$sys) / df$duration

## just a simple calculation
value.max <- max(df$sys)

df$high <- 1 + 0.45 * df$segment.end / value.max
df$low <- 1 - 0.45 * df$segment.end / value.max
df$percent <- df$segment.end / value.max 
df$id <- seq_along(df$sys)
df$idByDay <- ave( 1:nrow(df), df$event.day,FUN=function(x) seq_along(x))


## how many events in total, necessary
newevents <- nrow(df)

## subsetting the original data.frame
df <- df[,c("event.day", "id", "idByDay", "segment.id", "segment.start", "duration", "segment.end", "high", "low", "percent")]

## melting the data.frame
df.melted <- melt(df, id.vars = c("event.day", "id", "idByDay", "segment.id", "segment.start", "duration", "segment.end","percent"))
df.melted <- df.melted[order(df.melted$id,df.melted$segment.id),]

## this is a tricky one, basically this a self join, of two tables
#  every event is available twice, this is due to melt in the previous section
#  a dataframe is produced where every event is contained 4 times, except the first and last 2 rows,
#  the first row marks the start of the first polygon
#  the last row marks the end of the last polygon
df.melted <- rbind(df.melted[1:(nrow(df.melted)-2),],df.melted[3:nrow(df.melted),])
df.melted <- df.melted[order(df.melted$id,df.melted$segment.id),]


## grouping, necessary for drawing the polygons
#  the 1st polygon spans from the 1st event, and the first 2 rows from 2nd event
#  the 2nd polygon spans from last 2 rows of the 2nd event and the first 2 rows from 3rd event
#  ...
#  the last polygon spans from the last 2 rows of the next to last event and the 2 rows of the last event
df.melted$grouping <- rep (1:(newevents-1), each=4)
df.melted <- df.melted[order(df.melted$id, df.melted$grouping, df.melted$variable), ]


## adding a 4 point for each group
df.melted$point <- rep(c(1,2,4,3),(newevents-1))
df.melted <- df.melted[order(df.melted$grouping,df.melted$point), ]

## drawing the polygons
p <-        ggplot()

p <- p +    geom_polygon(data = df.melted
            ,aes(
                x = value
                ,y =idByDay
                ,group = grouping
                ,fill = percent

            )
        ) 

p <- p +    labs(x = "something", y="something else")

p <- p +    theme(
                panel.background = element_blank()
                #,panel.grid.minor = element_blank()
            #axis.title.x=element_blank()
                #,axis.text.x=element_text(size=12, face=2, color="darkgrey")
                #,axis.title.y=element_blank()
            #,axis.ticks.y = element_blank()
                #,axis.text.y = element_blank()
)

p <- p +    scale_fill_gradient(
            low = "lightgrey"
            ,high = "red"
            ,guide = 
                guide_legend(
                    title = "Sys" 
                    ,order = 1
                    ,reverse = FALSE
                    ,ncol = 2
                    ,override.aes = list(alpha = NA)
                )
        )

p <- p +    facet_wrap(~event.day, ncol=2)

p
-------------------------------------------------------------------------------------------------------
grid viewport library(grid)
library(gtable)

# create plot with legend with alpha = 1
g1 <- ggplot(the_data, aes(y = value, x = cat2, alpha = cat1, fill = cat2)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_alpha_discrete(range = c(0.5, 1)) +
  theme_bw() +
  guides(fill = guide_legend(title = "A",
                             title.hjust = 0.4),
         alpha = FALSE) +
  theme_bw() +
  theme(legend.text = element_blank())

g1

# grab legend
legend_g1 <- gtable_filter(ggplot_gtable(ggplot_build(g1)), "guide-box") 


# create plot with 'pale' legend
g2 <- ggplot(the_data, aes(y = value, x = cat2, alpha = cat1, fill = cat2)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_alpha_discrete(range = c(0.5, 1)) +
  guides(fill = guide_legend(override.aes = list(alpha = 0.5),
                             title = "B",
                             title.hjust = 0.3),
         alpha = FALSE) +
  theme_bw()
g2

# grab legend
legend_g2 <- gtable_filter(ggplot_gtable(ggplot_build(g2)), "guide-box") 



# arrange plot and legends

# legends to the right

# define plotting regions (viewports)
vp_plot <- viewport(x = 0.4, y = 0.5,
                    width = 0.8, height = 1)

vp_legend_g1 <- viewport(x = 0.85, y = 0.5,
                           width = 0.4, height = 0.4)

vp_legend_g2 <- viewport(x = 0.90, y = 0.5,
                           width = 0.4, height = 0.4)


# clear current device
grid.newpage()

# add objects to the viewports
# plot without legend
print(g1 + theme(legend.position = "none"), vp = vp_plot)
upViewport(0)

pushViewport(vp_legend_g1)
grid.draw(legend_g1)
upViewport(0)

pushViewport(vp_legend_g2)
grid.draw(legend_g2) # legends on top
vp_plot <- viewport(x = 0.5, y = 0.4,
                    width = 1, height = 0.85)

vp_legend_g1 <- viewport(x = 0.5, y = 0.9,
                         width = 0.4, height = 0.4)

vp_legend_g2 <- viewport(x = 0.55, y = 0.9,
                         width = 0.4, height = 0.4)

grid.newpage()

print(g1 + theme(legend.position = "none"), vp = vp_plot)
upViewport(0)

pushViewport(vp_legend_g1)
grid.draw(legend_g1)
upViewport(0)

pushViewport(vp_legend_g2)
grid.draw(legend_g2)
-------------------------------------------------------------------------------------------------------
library(microbenchmark)
library(data.table)
timings <- sapply(1:10, function(n) {
  DF <- data.frame(id=rep(as.character(seq_len(2^n)), each=40), val=rnorm(40*2^n), stringsAsFactors=FALSE)
  DT <- data.table(DF, key="id")     
  tofind <- unique(DF$id)[n-1]
  print(microbenchmark( DF[DF$id==tofind,],
                        DT[DT$id==tofind,],
                        DT[id==tofind],
                        `[.data.frame`(DT,DT$id==tofind,),
                        DT[tofind]), unit="ns")$median
})

matplot(1:10, log10(t(timings)), type="l", xlab="log2(n)", ylab="log10(median (ns))", lty=1)
legend("topleft", legend=c("DF[DF$id == tofind, ]","DT[DT$id == tofind, ]","DT[id == tofind]","`[.data.frame`(DT,DT$id==tofind,)","DT[tofind]"),
       col=1:5, lty=1)
-------------------------------------------------------------------------------------------------------
"bottomright" legend() legend(x1,y1,c("seed match"), bty="n", lty=1, col="red", cex=0.8)
-------------------------------------------------------------------------------------------------------
legend(x = 0.25, y = 35, c("seed match", "background"), bty="n", lty=c(1,1), col=c("red","black"), cex=0.8, inset=0)
-------------------------------------------------------------------------------------------------------
plot(spa, asp = 1, type = "n", main = "Brown trout", 
     xlab = "x coordinate (km)", ylab = "y coordinate (km)")
lines(spa, col="light blue")
points(spa, col = "brown", cex = spe$TRU)
points(spa, col = "green", cex = spe$OMB)
legend("topright", legend = c("Brown Trout", "Grayling"),col = c("brown","green"), pch = 1, bty = "n") points() lines() points()
-------------------------------------------------------------------------------------------------------
ggplot(...) stat_ellipse(...) library(ggplot2)

df     <- data.frame(iris)                   # iris dataset
pca    <- prcomp(df[,1:4], retx=T, scale.=T) # scaled pca [exclude species col]
scores <- pca$x[,1:3]                        # scores for first three PC's

# k-means clustering [assume 3 clusters]
km     <- kmeans(scores, centers=3, nstart=5)
ggdata <- data.frame(scores, Cluster=km$cluster, Species=df$Species)

# stat_ellipse is not part of the base ggplot package
source("https://raw.github.com/low-decarie/FAAV/master/r/stat-ellipse.R") 

ggplot(ggdata) +
  geom_point(aes(x=PC1, y=PC2, color=factor(Cluster)), size=5, shape=20) +
  stat_ellipse(aes(x=PC1,y=PC2,fill=factor(Cluster)),
               geom="polygon", level=0.95, alpha=0.2) +
  guides(color=guide_legend("Cluster"),fill=guide_legend("Cluster")) ggdata$Clusters ggdata$Species ggplot
-------------------------------------------------------------------------------------------------------
set.seed(10)
dat <- data.frame(A = rnorm(20), B = rnorm(20), C = rnorm(20)) # create a QQ-plot of B as a function of A
qqplot(dat$A, dat$B, xlim = range(dat), ylim = range(dat), 
       xlab = "A", ylab = "B/C")
# create a diagonal line
abline(a = 0, b = 1)
# add the points of C
points(sort(dat$A), sort(dat$C), col = "red")
# create a legend
legend("bottomright", legend = c("B", "C"), pch = 1, col = c("black", "red"))
-------------------------------------------------------------------------------------------------------
x = seq(0, 3, len = 100)
y1 = function(x) x^2 -2*x +2
y2 = function(x) -4*x + 1
z = function(x) y1(x)/(y1(x)-y2(x)) plot(x,y1(x),ylim=c(-12,5),type="l",ylab="y")
lines(x,y2(x),col="blue")
lines(x,z(x),col="red")
abline(h=0,v=0,col="gray")
legend("bottomleft",c("y1(x)","y2(x)","z(x)"),fill=c("black","blue","red"))
-------------------------------------------------------------------------------------------------------
matplot library(randomForest)
model = randomForest(Species ~., data=iris, ntree=100, proximity=T)
layout(matrix(c(1,2),nrow=1),
       width=c(4,1)) 
par(mar=c(5,4,4,0)) #No margin on the right side
plot(model, log="y")
par(mar=c(5,0,4,2)) #No margin on the left side
plot(c(0,1),type="n", axes=F, xlab="", ylab="")
legend("top", colnames(model$err.rate),col=1:4,cex=0.8,fill=1:4)
-------------------------------------------------------------------------------------------------------
matplot # Select first column (Count) as x variable, and all colums _except_ x as y variable. 

# basic, default matplot
matplot(x = df[ , 1], y = df[ , -1] , type = "l")

# slightly customized matplot
# create a vector of numbers, one for each response variable
# numbers are mapped to colours in plot and legend
cols = seq_len( ncol(df)-1 )

matplot(x = df[, 1], y = df[ , -1] ,
        type = "l",
        lty = 1,
        col = cols)

legend("bottom", legend = names(df[ , -1]), lty = 1,col = cols) ggplot library(reshape2)
library(ggplot2)
df2 <- melt(df, id.var = "Count")
ggplot(data = df2, aes(x = Count, y = value, colour = variable)) +
  geom_line()
-------------------------------------------------------------------------------------------------------
+ guides(colour = guide_legend(override.aes = list(size=10))) size
-------------------------------------------------------------------------------------------------------
legend(x = "topright",legend = c(expression(alpha == 0), expression(0 < {alpha < 1}))
)
-------------------------------------------------------------------------------------------------------
df2 <- stack(df)
df2$ind <- as.character(df2$ind) value1 = 0.8
value2 = 0.8
value3 = 0
greeks <- list(bquote(rho==.(value1)), bquote(rho==.(value2)), bquote(rho==.(value3)))

ggplot(data=df2)+
  stat_density(aes(x=values, group=ind, color=ind), 
               adjust=4, lwd=0.5, geom="line", position="identity")+
  xlim(-3, 3)+
  xlab("Renditen")+
  ylab("Dichte")+
  ggtitle("Renditeverteilung im Heston-Modell")+
  theme(plot.title=element_text(face="bold", size=16, vjust=2, family="Times New Roman"),  
        axis.title.x=element_text(vjust=-1, size=14, family="Times New Roman"),
        axis.title.y=element_text(vjust=-0.25, size=14, family="Times New Roman"), 
        legend.text=element_text(size=14, family="Times New Roman"), 
            legend.title=element_blank(),
        legend.margin=unit(1, "cm"),
        legend.key.height=unit(1, "line"), 
        legend.key.size=unit(0.4, "cm"), 
        legend.key=element_rect(fill=NA), 
        legend.background=element_blank(),
        plot.margin=unit(c(1,1,1,1), "cm"))+
  scale_colour_manual(values=1:3, labels=greeks) 
 +guides(colour=guide_legend(override.aes=list(linetype=1:3)))
-------------------------------------------------------------------------------------------------------
symbols(DF$V1,DF$V2, circles = V3, inches = 0.35, fg = "darkblue", bg = "red")
text(DF$V1, DF$V2 + c( 0, 0, 0, 1, -1,0 ), V4, cex = 0.5)

legend("topright", legend=c("15", "20", "25", "30"), pch = 21,bty = "n",col = "black",pt.bg = "red",         pt.cex = c(0.5,1,1.5,2))       

# thanks to at @Josh O'Brien for pt.cex
-------------------------------------------------------------------------------------------------------
bquote as.expression plot(1:10)
legend(2, 10, c(as.expression(bquote("BW (MPE = 3%," ~ R^2 ~ "= 0.77)")),as.expression(bquote("MY (MPE = 5%," ~ R^2 ~ "= 0.80)"))), pch=c(2,3))
-------------------------------------------------------------------------------------------------------
legend arrangeGrob legend legend g_legend <- function(a.gplot){
    tmp <- ggplot_gtable(ggplot_build(a.gplot))
    leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
    legend <- tmp$grobs[[leg]]
    return(legend)
}
legend <- g_legend(p) widths pp <- arrangeGrob(p + theme(legend.position = "none"), widths=c(3/4, 1/4),arrangeGrob( legend,leg.df.grob), ncol = 2)
-------------------------------------------------------------------------------------------------------
c( as.expression ( bquote... plot(1:10)
legend(2, 10, expression("BW (MPE = 3%," ~ R^2 ~ "= 0.77)","MY (MPE = 5%," ~ R^2 ~ "= 0.80)"), pch=c(2,3)) expression % plot(1:10)
legend(2, 10, expression(BW * list(MPE == 3*'%', R^2 == 0.77),MY * list( MPE == 5*'%',R^2 == 0.80)), 
       pch=c(2,3))
-------------------------------------------------------------------------------------------------------
scale_fill_brewer(palette="Blues") guides(size=guide_legend(override.aes = list(fill="black", alpha=1))) , color=guide_legend(override.aes = list(alpha=0.9))
-------------------------------------------------------------------------------------------------------
legend(x,y,...) x=seq(0,3,length.out=10)
plot(x,x)
legend(2,1,"My legend")   # I can see you... x=seq(0,1,length.out=10)
plot(x,x)
legend(2,1,"My legend")   # Nope.
-------------------------------------------------------------------------------------------------------
(1) ggplot(dat.m[!grepl("^empty", dat.m$Category), ], aes(<etc>...)) (2) + guides(fill=guide_legend(override.aes=list(alpha=1)))
-------------------------------------------------------------------------------------------------------
geom_text scale_fill_gradientn scale_fill_gradientn dat.m <- data.frame(Month=months(seq(as.Date("2000/1/1"), 
              by = "month", length.out = 12)),month.id = 1:12)

yy <- merge(yy,dat.m)
library(ggplot2)
ggplot(yy ,aes(reorder(Month,month.id), Year, fill=Peak_Logons)) +
    geom_tile() + 
    theme_bw() + 
    guides(fill = guide_legend(keywidth = 5, keyheight = 1)) + 
    theme(axis.text.x = element_text(size=10, angle=45, hjust=1)) +
    geom_text(aes(label=paste(Peak_Logons,format(Time,"%H"),sep='-'))) +
    scale_fill_gradient(low = "yellow",  high = "red")
-------------------------------------------------------------------------------------------------------
Logons y$Logons<-as.numeric(gsub(",","",y$Logons)) fill= geom_tile() scale_fill_... scale_fill_gradientn() ggplot(y ,aes(Month, Year, fill=Logons, 
  label=paste(paste(weekdays(Date), format(Date,"%H:%M"), sep="\n"), "\n",Logons))) + 
  geom_tile() + theme_bw() + 
  guides(fill = guide_legend(keywidth = 5, keyheight = 1)) + 
  theme(axis.text.x = element_text(size=10, angle=45, hjust=1)) +  
  geom_text(size=3)+ 
  scale_fill_gradientn(limits=c(200000,  1500000),
                       breaks = c(200000, 400000, 800000, 1000000, 1300000, 1500000), 
     labels = c("0 month", "1 month", "3 months","6 months", "9 months", "12 months"),
     colours = c("#E69F00", "#56B4E9", "#009E73","#F0E442", "#0072B2", "#D55E00")) guides(fill = guide_legend(keywidth = 5, keyheight = 1))
-------------------------------------------------------------------------------------------------------
cse cse=0 newdat p <- ggplot(data=newdat, mapping=aes(x=v0, y=dv280, colour=treatment)) +
  geom_point() +
  geom_smooth(method='lm', se=TRUE, fullrange=TRUE) +
  scale_colour_discrete(guide=guide_legend(title.position='left', title.hjust=1))
p + theme_bw() + coord_cartesian(xlim=c(-1,1), ylim=c(0.4,0.65)) +     
  geom_hline(yintercept=0, colour='gray35', linetype='dashed') +
  geom_vline(xintercept=0, colour='gray35', linetype='dashed') newdat p <- ggplot(data=newdat, mapping=aes(x=v0, y=dv280, ymin=tlo, ymax=thi, colour=treatment, fill=treatment)) +
  geom_ribbon(alpha=0.2, aes(colour=NULL)) +
  geom_point() +
  geom_line() +
  scale_colour_discrete(guide=guide_legend(title.position='left', title.hjust=1))
p + theme_bw() +   
  geom_hline(yintercept=0, colour='gray35', linetype='dashed') +
  geom_vline(xintercept=0, colour='gray35', linetype='dashed')
-------------------------------------------------------------------------------------------------------
p <- ggplot(data=newdat, mapping=aes(x=v0, y=dv280, colour=treatment)) +
  geom_point() +
  geom_smooth(data=nd, method='lm', se=TRUE) +
  scale_colour_discrete(guide=guide_legend(title.position='left', title.hjust=1)) newdat geom_points(...) nd geom_smooth(...) nd nd p <- ggplot(data=nd, mapping=aes(x=v0, y=dv280, colour=treatment)) +
  geom_point() +
  geom_smooth(data=nd, method='lm', se=TRUE) +
  scale_colour_discrete(guide=guide_legend(title.position='left', title.hjust=1)) nd se=0 nd lm geom_smooth(...) lm dv280 > 5 p <- ggplot(data=newdat, mapping=aes(x=v0, y=dv280, colour=treatment)) +
  geom_point() +
  geom_smooth(data=subset(newdat,dv280>5), method='lm', se=TRUE) +
  scale_colour_discrete(guide=guide_legend(title.position='left', title.hjust=1)) lme model dat$dv280 dat newdat$dv280 v0 treatment cse nd$dv280 v0 treatment cse=0 nd$dv280 v0 treatment ggplot dat$dv280 cse
-------------------------------------------------------------------------------------------------------
d <- ggplot(data=mtcars, aes(x=cyl, y=mpg, color=factor(vs))) + geom_point()
d + stat_summary(fun.y = "mean", fun.ymin = "mean", fun.ymax = "mean", 
                 colour = "black", aes(shape="total"), geom="point") +
    guides(colour=guide_legend(order=1), shape=guide_legend(title=NULL, order=2))
-------------------------------------------------------------------------------------------------------
#Orignal Data as per Question
a <- c(0.1, 0.5,0.5, 0.6, 0.2, 0          , 0         , 0.004166667, 0.45) 
b <- c(0.75,0.5,0  , 0.1, 0.2, 0.951612903,0.918103448, 0.7875     , 0.45)
c <- c(0.15,0  ,0.5, 0.3, 0.6, 0.048387097,0.081896552, 0.208333333, 0.10) 
d <- c(500,2324.90,2551.44,1244.50, 551.22,-644.20,-377.17,-100, 2493.04) 
df <- data.frame(a, b, c, d)

#For labelling each point.
df$id <- 1:nrow(df)

#Build Plot
ggtern(data=df,aes(x=c,y=a,z=b),aes(x,y,z)) + 
  stat_density2d(geom="polygon",
                 n=400,
                 aes(fill=..level..,
                 weight=d,
                 alpha=abs(..level..)),
                 binwidth=100) + 
  geom_density2d(aes(weight=d,color=..level..),
                 n=400,
                 binwidth=100) +
  geom_point(aes(fill=d),color="black",size=5,shape=21) + 
  geom_text(aes(label=id),size=3) + 
  scale_fill_gradient(low="yellow",high="red") + 
  scale_color_gradient(low="yellow",high="red") + 
  theme_tern_rgbw() + 
  theme(legend.justification=c(0,1), legend.position=c(0,1)) + 
  guides(fill = guide_colorbar(order=1),
         alpha= guide_legend(order=2),
         color="none") + 
  labs(  title= "Ternary Plot and Filled Contour",
         fill = "Value, V",alpha="|V - 0|")

#Save Plot
ggsave("TernFilled.png")
-------------------------------------------------------------------------------------------------------
PlotIt <- function(df) {
  Alpha <- function(x) pmax(0.1, pmin(1, 2.05 - 0.152 * log(x)))
  p <- ggplot(df) + 
    geom_point(aes(x = x, y = y, colour = group), size = 1.5,
               shape = 1, alpha = Alpha(nrow(df))) +
    expand_limits(y = 1) + expand_limits(y = 5) +
    geom_hline(aes(yintercept = c(2.5, 4.5)), linetype = "dotdash") +
    guides(colour = guide_legend(override.aes = list(alpha = 1)))
  print(p)
}
-------------------------------------------------------------------------------------------------------
legend('topright',c('','name'),lty=c(1,NA),pch=c(NA,'X'),bg='white',ncol=2) lty=c(1,2,3,NA,NA,NA)
-------------------------------------------------------------------------------------------------------
lgd lgd <- legend("topleft", legend = c("", ""), pch = NA, lty = c(1, 2), bty="n")
legend(lgd$rect$left+lgd$rect$w, lgd$rect$top, legend = c("Line 1", "Line 2"), pch = c(1,2), bty="n")
-------------------------------------------------------------------------------------------------------
require(vegan)
data(dune)
data(dune.env)

mds <- cmdscale(vegdist(dune, method='bray'))


# set colors and shapes
cols = c('red', 'blue', 'black', 'steelblue')
shps = c(15, 16, 17)
# empty plot
plot(mds, type = 'n')
# add points
points(mds, col = cols[dune.env$Management], pch = shps[dune.env$Use])
# add legend
legend('topright', col=cols, legend=levels(dune.env$Management), pch = 16, cex = 0.7)
legend('bottomright', legend=levels(dune.env$Use), pch = shps, cex = 0.7) > levels(dune.env$Management)
[1] "BF" "HF" "NM" "SF" cols[dune.env$Management] cols
-------------------------------------------------------------------------------------------------------
library(demography)

fr.mort_age = extract.ages(fr.mort,0:60,F)    
fr.mort_age_yr = extract.years(fr.mort_age,1918:1950)    
plot.demogdata(fr.mort_age_yr,series='male')   
legend("bottomright",legend=unique(fr.mort_age_yr$year),
  col=rainbow(length(fr.mort_age_yr$year)*1.25), ncol=5, pch=19, 
  title="Year", cex=0.5)
-------------------------------------------------------------------------------------------------------
# Load data
data(Feldspar)

# Sort it by decreasing pressure 
# (so small grobs sit on top of large grobs
Feldspar <- Feldspar[with(Feldspar, order(-P.Gpa)), ]

# Build and Render the Plot
ggtern(data = Feldspar, aes(x = An, y = Ab, z = Or)) + 
#the layer
geom_point(aes(fill = T.C, 
               size = P.Gpa, 
               shape = Feldspar)) + 
#scales
scale_shape_manual(values = c(21, 24)) + 
scale_size_continuous(range = c(2.5, 7.5)) + 
scale_fill_gradient(low = "green", high = "red") + 

#theme tweaks
theme_tern_bw()  + 
theme(legend.position      = c(0, 1), 
      legend.justification = c(0, 1), 
      legend.box.just      = "left") + 

#tweak guides
guides(shape= guide_legend(order   =1,
                           override.aes=list(size=5)),
       size = guide_legend(order   =2),
       fill = guide_colourbar(order=3)) +

#labels and title
labs(size = "Pressure/GPa", 
     fill = "Temperature/C") + 
ggtitle("Feldspar - Elkins and Grove 1990") ggtern(data=Feldspar,aes(An,Ab,Or)) +
  geom_confidence(aes(group=Feldspar,
                      fill=..level..,
                      alpha=1-..level..),
                      n=2000,
                  breaks=c(0.01,0.02,0.03,0.04,
                           seq(0.05,0.95,by=0.1),
                           0.99,0.995,0.9995),
                  color=NA,linetype=1) +
  geom_density2d(aes(color=..level..)) + 
  geom_point(fill="white",aes(shape=Feldspar),size=5) +  
  theme_tern_bw() + 
  theme_tern_nogrid() + 
  theme(ternary.options=element_ternary(padding=0.2),
                        legend.position=c(0,1),
                        legend.justification=c(0,1),
                        legend.box.just="left") +
  labs(color="Density",fill="Confidence",
   title="Feldspar - Elkins and Grove 1990 + Confidence Levels + Density") +
  scale_color_gradient(low="gray",high="magenta") +
  scale_fill_gradient2(low="red",mid="orange",high="green",
                       midpoint=0.8) +
  scale_shape_manual(values=c(21,24)) + 
  guides(shape= guide_legend(order   =1,
                             override.aes=list(size=5)),
         size = guide_legend(order   =2),
         fill = guide_colourbar(order=3),
         color= guide_colourbar(order=4),
         alpha= "none")
-------------------------------------------------------------------------------------------------------
test$Time <- as.POSIXct(test$Time,format='%d/%m/%Y %H:%M')
## build p1 and p2 using your original code

grid.arrange(p1+theme(legend.position='none'),
             p2+theme(axis.title.y=element_blank()),
             ncol=2) g_legend<-function(a.gplot){
  tmp <- ggplot_gtable(ggplot_build(a.gplot))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  legend
}
legend1 <- g_legend(p2)
grid.arrange(p1+theme(legend.position='none'),
             p2+theme(axis.title.y=element_blank(),legend.position='none'),
             legend1,
             ncol=3,nrow=1,widths= c(3/7,3/7,1/7))
-------------------------------------------------------------------------------------------------------
library(gplots)
library(RColorBrewer)

#Table formatting 
rownames(df)<-df[,1] #setting row names
df<-as.matrix(df[,-1])

# Defining breaks for the color scale!
##defining color scale

myCol <- c("white",colorRampPalette(c("green","darkgreen"))(100),"black",colorRampPalette(c("red","darkred"))    (100)) 
#you can change the colors here. 
#It is important to have the total number of colors defined for all the breaks. 
#i.e if the number of breaks is 100, then there should be 99 colors defined.
#You can change the gradient of the shades by changing no of splots, 
#I have used 100 here

##defining breaks
myBreaks <- c(-1,0,seq(1e-5,1-1e-5,length=100),1,seq(1+1e-3,200,length=100)) 

#set your break start/end and the length here
# I have set it as per your requirements here. Teh shades

#Plotting heatmap 

pdf("temporal_data.pdf",width=8,height=8)
hm <- heatmap.2(df, scale="none", Colv=NA,
                col = myCol, ## using your colors
                breaks = myBreaks, ## using your breaks
                dendrogram = "row",  ## row dendograms
                , cexRow=1, cexCol=1, key=FALSE,
                margins = c(2, 12),trace="none")
legend("topleft", fill = c("white","green","black","red"),legend = c("0", "0.0001 to 0.999", "1",">1"),cex=1,horiz =TRUE)
dev.off()
-------------------------------------------------------------------------------------------------------
override.aes = list(linetype = 0) guides() hline() ## add horizontal lines for EPA MCL and Upper Prediction Limit
geom_hline(data = limits, aes(yintercept = GWPS, linetype = "GWPS"), colour = "black", size = 0.75, show_guide = T) +
geom_hline(data = limits, aes(yintercept = DMR_limit, linetype = "DMR Limit"), size = 0.75, show_guide = T) +
scale_linetype_manual(name = "Limits", labels = c("GWPS", "DMR Limit"), values = c("GWPS" = 1, "DMR Limit" = 2)) + guides() guides(colour = guide_legend(override.aes = list(linetype = 0 )), 
       fill = guide_legend(override.aes = list(linetype = 0 )), 
       shape = guide_legend(override.aes = list(linetype = 0 )), 
       linetype = guide_legend()) + geom_vline(aes()) scale_linetype_manual()
-------------------------------------------------------------------------------------------------------
matplot require(ggplot2)
require(reshape2)
dat<-data.frame('No.'=1:2,replies=2:3,PlusOnes=3:4,Reshares=c(1,5))
melted=melt(dat,id.vars='No.')

ggplot(melted,aes(x=factor(No.),y=value,color=factor(variable),group=factor(variable)))+
geom_line()+xlab('No.')+guides(color=guide_legend("Series"))+
labs(title="Insert Title Here") melt() No.
-------------------------------------------------------------------------------------------------------
legend text legend(x='bottomright', legend='Cor = 0.34') legend(x='bottomright', legend=paste('Cor =',round(cor(survey$Age, survey$Height),2)))
-------------------------------------------------------------------------------------------------------
# after reading in dataframe into d

m <- t(d)
barplot(m[2:3, ] , beside=TRUE, names.arg=m[1, ], 
        col=2:3, las=1, xlab="Year")
legend("topleft", legend=c("Balance", "TotalDeposits"), fill=2:3, box.col=NA)
-------------------------------------------------------------------------------------------------------
color= fill= ggplot(aes(-PC1, PC2, size=Acute, shape=Visits, color=WardEuc,fill=WardEuc), data=df)+
  geom_point()+
  geom_hline(yintercept= 0, linetype=3) +
  geom_vline(xintercept = 0, linetype=3) +
  scale_color_manual(values = c("black","#E31A1C","#66A61E","#332288")) +
  scale_fill_manual(values = c("black","#E31A1C","#66A61E","#332288")) +
  scale_shape_manual(values = c(24,21), labels=c("1","2")) +
  labs (x="Dim1 (60.98%)", y="Dim2 (13.80%)") +
  theme_bw(base_size = 16) +
  theme (panel.grid.major = element_blank(),panel.grid.minor = element_blank())  + 
  scale_size_continuous(range = c(1, 8),labels=c("0","1","2","3"))+ #  
  guides(shape=guide_legend("Var1"), size = guide_legend("Var2"),
         color=guide_legend("Cluster"),fill=guide_legend("Cluster")) override.aes= guides() ggplot(aes(-PC1, PC2, size=Acute, shape=Visits, fill=WardEuc), data=df)+
  geom_point()+
  geom_hline(yintercept= 0, linetype=3) +
  geom_vline(xintercept = 0, linetype=3) +
  scale_color_manual(values = c("black","#E31A1C","#66A61E","#332288")) +
  scale_fill_manual(values = c("black","#E31A1C","#66A61E","#332288")) +
  scale_shape_manual(values = c(24,21), labels=c("1","2")) +
  labs (x="Dim1 (60.98%)", y="Dim2 (13.80%)") +
  theme_bw(base_size = 16) +
  theme (panel.grid.major = element_blank(),panel.grid.minor = element_blank())  + 
  scale_size_continuous(range = c(1, 8),labels=c("0","1","2","3"))+ #  
  guides(shape=guide_legend("Var1"), size = guide_legend("Var2"), 
         fill=guide_legend("Cluster",override.aes=list(shape=21)))
-------------------------------------------------------------------------------------------------------
x.ts <- ts(x)
y.ts <- ts(y, start = 15)
ts.plot(x.ts, y.ts, col = 1:2, lty = 1:2)

legend("topleft", c("x", "y"), col = 1:2, lty = 1:2) # optional
-------------------------------------------------------------------------------------------------------
ggplot(diamonds, aes(clarity, fill = cut)) + geom_bar(position = "dodge") + 
# linetype has to be aes; show_guide = TRUE is important
  geom_hline(aes(yintercept = 1500, linetype = "Expected value"), 
             show_guide = TRUE) + 
# 2 means dashed
  scale_linetype_manual("Title", values = 2) +
# This fixes some problems, try linetype = 1 and another legend will be ruined
  guides(fill = guide_legend(override.aes = list(linetype = 0)))
-------------------------------------------------------------------------------------------------------
myplot() myPlot <- function(myTitle="Fig. 1. The effect of anomalous levels of sea surface temperature on coral bleaching") {
  plot(temp.a~Response,data=sst.brazil.bleach,pch=15, col="red", ylim=c(0,6),xlim=c(0,30), 
       main=mytitle,
       xlab="Bleaching response index",ylab=" Total annual sea surface temperature anomalies\n(°C)") 
  points(temp.a~Response,data=sst.seychelles.bleach,pch=16, col="blue") 
  points(temp.a~Response,data=sst.indo.bleach,pch=17, col="orange") 
  legend("bottomright", bty= "n", c("Brazil","Seychelles","Indonesia"),col=c('red', 'blue', 'orange'),pch=c(15,16,17))
}

myplot()
myPlot("I want another title for this one") myplot.r source("myplot.r")
-------------------------------------------------------------------------------------------------------
z <- LETTERS[1:7]

df <- list(
  data.frame(ID=LETTERS[1:3],
             LON=c(1,10,12),
             LAT=c(1,14,13)),
  data.frame(ID=LETTERS[3:5],
             LON=c(2,11,18),
             LAT=c(2,9,20))
  )


layout(t(1:2))
for (i in 1:2){  
  plot(df[[i]]$LON, df[[i]]$LAT, 
       col = rainbow(length(z))[match(df[[i]]$ID,z)], 
       pch=16)
  legend("topleft", legend=z, col=rainbow(length(z)),pch=16)
}
-------------------------------------------------------------------------------------------------------
ncol=2 override.aes + guides(colour = guide_legend(override.aes = list(size=4),ncol=2)) +theme(plot.margin=unit(c(0,0,0,0),"mm")) library(grid)
-------------------------------------------------------------------------------------------------------
stat_smooth() fill= aes() se=FALSE stat_smooth() +stat_smooth(method = "loess", formula = y ~ x, level=0, size = 1, 
              aes(group = gender, colour=gender),se=FALSE) guides() override.aes= + guides(color=guide_legend(override.aes=list(fill=NA)))
-------------------------------------------------------------------------------------------------------
base points lines barplot plot par(mar=c(5,5,2,3)+0.1)
ratio<-9e6/0.14
bar.col<-'#558ED5'
vencido.col<-'#77933C'
castigos.col<-'#FE0F0F'
b<-barplot(Data$'Monto Otorgado acumulado',names.arg=Data$Month,col=bar.col,border=FALSE,main='My Plot',ylim=c(0,9e6),axes=FALSE)
lines(b,Data$'% Vencida' * ratio, col=vencido.col,lwd=2) 
points(b,Data$'% Vencida' * ratio, col=vencido.col,bg='white',pch=21) 
lines(b,Data$'% Castigos' * ratio, col=castigos.col,lwd=2)
points(b,Data$'% Castigos' * ratio, col=castigos.col,bg='white',pch=21)
left.axis.pos<-seq(0,9e6,by=1e6)
axis(2,at=left.axis.pos,labels=formatC(left.axis.pos, big.mark = ",", format = "d"),las=2)
right.axis.ticks<-0:14
axis(4,at=(right.axis.ticks/100)*ratio,labels=paste0(right.axis.ticks,'%'),las=2)
legend('topleft',legend=c('Monto Otorgado acumulado','% Vencido','% Castigos'),col=c(bar.col,vencido.col,castigos.col),lty=1,lwd=c(4,2,2),bty='n')
par(mar=c(5,4,2,2)+0.1)
-------------------------------------------------------------------------------------------------------
ggplot library(ggplot2)

ggplot(aes(x=hp, y=mpg, shape=as.factor(am), color=as.factor(am)), data=mtcars)+ 
  facet_grid(gear~cyl) +
  geom_point(size=I(3)) +
  xlab("Horsepower") +
  ylab("Miles per Gallon") am as.factor(am) shape am guides(shape = guide_legend(title="am"),
       color = guide_legend(title="am"))
-------------------------------------------------------------------------------------------------------
MCsubsetDT1112 <- read.csv("~/Downloads/MCsubsetDT1112.csv")
MCsubsetTemp1112 <- read.csv("~/Downloads/MCsubsetTemp1112.csv")

ggplot() +
  geom_bar(data = MCsubsetDT1112, 
           aes(x=as.Date(Date,"%m/%d/%Y"), y=Mean, group=SiteSub, fill=SubstrateConcat),
           stat="identity", position="dodge") +
  geom_bar(data = MCsubsetDT1112, 
           aes(x=as.Date(Date,"%m/%d/%Y"), y=Mean, group=SiteSub, fill=SubstrateConcat),    
           stat="identity", position="dodge", color="black", show_guide=FALSE) +
  geom_line(aes(x=as.Date(Date,"%m/%d/%Y"),y=Mean,group=SiteSub,  color=WaterType, linetype=SubstrateConcat), 
            data=MCsubsetTemp1112, size=1) + 
  geom_hline(yintercept=20, linetype="dashed") +
  ylim(-5,35) +
  labs(x= "Date", y=expression("Temperature  " ( degree~C)), color="Water Type", 
        linetype="Substrate",fill="delta-T Substrate") +
  scale_linetype_manual(values=c("solid", "dashed", "dotdash"), 
                        labels=c("Bottom", "Column", "Surface")) +
  scale_x_date(labels=date_format("%b %Y")) +
  scale_color_manual(values=c("darkblue", "maroon"), labels=c("non-Warm", "Warm")) +
  scale_fill_manual(values=c("white", "black","grey"), labels=c("Bottom", "Surface")) +
  guides(linetype=guide_legend(override.aes=list(fill=NA)),
         color=guide_legend(override.aes=list(fill=NA)),
         fill = guide_legend(override.aes = list(color = "black"))) +
  theme(plot.title=element_text(color="black", size=16, face="bold"),
        axis.line=element_line(color="black"),
        axis.title=element_text(color="black", size=16),
        axis.text=element_text(color="black", size=14),
        panel.background=element_rect(fill="white"),
        legend.background=element_blank(),
        legend.text=element_text(color="black"),
        legend.key = element_rect(colour = "black",fill = NA)) as.Date()
-------------------------------------------------------------------------------------------------------
