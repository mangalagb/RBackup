plot(flow~factor(month),xlab="Month",ylab="Total Flow per Month",ylim=c(0,55000), xaxt="n") axis(1, at=1:12, labels=month.name)
-------------------------------------------------------------------------------------------------------
## data
N <- 10
dnow <- data.frame(x=1:N, y=runif(N), labels=paste("This is \nobservation ",1:N))
## make margins wide
par(mfrow=c(1,1), mar=c(10,10,6,4))
## plot without axix labels or ticks
with(dnow, plot(x,y, xaxt="n", xlab=""))
## the positions we ant to plot
atn <- seq(1,N,3)
## the label for these positions
lab <- dnow$labels[atn]
## plot the axis, but do not plot labels
axis(1, at=atn, labels=FALSE)
## plot labels
text(atn, ## x position
     par("usr")[3]-.05, ## position of the low axis
     srt=45, ## angle
     labels=lab, ##labels
     xpd=TRUE, ## allows plotting outside the region 
     pos=2)
## par("usr")[3]
-------------------------------------------------------------------------------------------------------
png("bipartite.png")

## Make up data.
data <- data.frame(X1=sample(state.region, 10),
                   X2=sample(state.region, 10))

## Set up plot window.
plot(0, xlim=c(0,1), ylim=c(0,1),
     type="n", axes=FALSE, xlab="", ylab="")

factor.to.int <- function(f) {
  (as.integer(f) - 1) / (length(levels(f)) - 1)
}

segments(factor.to.int(data$X1), 0, factor.to.int(data$X2), 1,
         col=data$X1)
axis(1, at = seq(0, 1, by = 1 / (length(levels(data$X1)) - 1)),
     labels = levels(data$X1))
axis(3, at = seq(0, 1, by = 1 / (length(levels(data$X2)) - 1)),
     labels = levels(data$X2))
dev.off()
-------------------------------------------------------------------------------------------------------
yaxt = "n" plot((1:100)^3, log = "y", yaxt = "n")
axis(2, format(c(1,10,100)^3, scientific=FALSE))
-------------------------------------------------------------------------------------------------------
library(lattice)
library(grid)  # needed for grid.text

# data

Lines.raw <- "Date  Fo  Co
6/27/2007  57.1  13.9
6/28/2007  57.7  14.3
6/29/2007  57.8  14.3
6/30/2007  57  13.9
7/1/2007  57.1  13.9
7/2/2007  57.2  14.0
7/3/2007  57.3  14.1
7/4/2007  57.6  14.2
7/5/2007  58  14.4
7/6/2007  58.1  14.5
7/7/2007  58.2  14.6
7/8/2007  58.4  14.7
7/9/2007    58.7 14.8
"

# in reality next stmt would be DF <- read.table("myfile.dat", header = TRUE)
DF <- read.table(textConnection(Lines.raw), header = TRUE)
DF$Date <- as.Date(DF$Date, "%m/%d/%Y")

par.settings <- list(
        layout.widths = list(left.padding = 10, right.padding = 10),
        layout.heights = list(bottom.padding = 10, top.padding = 10)
)

xyplot(Co ~ Date, DF, default.scales = list(y = list(relation = "free")),
        ylab = "C", par.settings = par.settings)

trellis.focus("panel", 1, 1, clip.off = TRUE)
  pr <- pretty(DF$Fo)
  at <- 5/9 * (pr - 32)
  panel.axis("right", at = at, lab = pr, outside = TRUE)
  grid.text("F", x = 1.1, rot = 90) # right y axis label
trellis.unfocus()
-------------------------------------------------------------------------------------------------------
valact <- subset(val, variable=='actual')
valsort <- valact[ order(-valact[,"Value"]),] boxplot() op <- par(mar=c(3,3,3,3)) 
bp <- barplot(valsort [ , "Value"], ylab="", xlab="", ylim=c(0,1),    
              names.arg=as.character(valsort[,"State"]), main="How's that?") 
lines(bp, cumsum(valsort[,"Value"])/sum(valsort[,"Value"]), 
      ylim=c(0,1.05), col='red') 
axis(4)
box() 
par(op) lines()
-------------------------------------------------------------------------------------------------------
R> library(zoo)
R> zdf <- zoo(df$val, order.by=df$date)
R> plot(zdf)
R> help(plot.zoo) R> fmt <- "%Y-%m"  ## year-mon
R> txt <- format(index(zdf), fmt)
R> plot(zdf, xaxt='n')
R> axis(side=1, at=index(zdf), lab=txt)
R> at lab
-------------------------------------------------------------------------------------------------------
x <- seq(as.POSIXct("1949-01-01", tz="GMT"), length=36, by="months")
y <- rnorm(length(x))

plot(x, y, type="l", xaxt="n")
rect(xleft=as.POSIXct("1950-01-01", tz="GMT"),
     xright=as.POSIXct("1950-12-01", tz="GMT"),
     ybottom=-4, ytop=4, col="#123456A0") # use alpha value in col
idx <- seq(1, length(x), by=6)
axis(side=1, at=x[idx], labels=format(x[idx], "%Y-%m")) plot(x, y, type="n", xaxt="n")
rect(xleft=as.POSIXct("1950-01-01", tz="GMT"),
     xright=as.POSIXct("1950-12-01", tz="GMT"),
     ybottom=-4, ytop=4, col="lightblue")
lines(x, y)
idx <- seq(1, length(x), by=6)
axis(side=1, at=x[idx], labels=format(x[idx], "%Y-%m"))
box()
-------------------------------------------------------------------------------------------------------
R test <- read.table("/tmp/test.txt", header=TRUE)
png(filename="/tmp/test.png", height=750, width=1000, 
    bg="white", res=300)
par(mar=c(2.5,2.5,0.75,0.75), 
    family="Gill Sans", font=1, # font 2 would be bold
    cex=0.75, cex.lab=0.75, cex.axis=0.75) 
mymax <- max(test$Region1, test$Region2)*1.25

plot(test$Region1, type="b", col="#304E67", 
     ylim=c(0, mymax), lwd=3,
     bty="l", axes=FALSE, ann=FALSE, cex=1.0, tck=1)

axis(1, lwd.ticks=0, at=1:length(test$Year), lab=test$Year)
axis(2, lwd=0, las=1, at=c(0,25,50,75,100), yaxp=c(0,100,4))
# grid(nx = NA, ny = 5, col = "lightgray") # wrong, see axTicks
for(y in c(25, 50, 75, 100)) {
  lines(rep(y, length(test$Region1)), type="l", col="lightgray", lwd=1)
}

lines(test$Region1, type="b", col="#304E67", lwd=3)
lines(test$Region2, type="b", col="#974449", lwd=3)

# title(xlab="Year", col.lab=rgb(0,0.5,0))
# title(ylab="Output", col.lab=rgb(0,0.5,0))
legend(1, mymax+8, c("Region 1","Region 2"), cex=0.75, 
       col=c("#304E67" ,"#974449"), 
       pch=1:1, # circles
       lty=1:1, # solid 
       lwd=1.5, # line width
       bty="n") # no box around

dev.off() Year Region1 Region2
2007 17 55
2008 26 43
2009 53 70
2010 96 58
-------------------------------------------------------------------------------------------------------
rawData <- read.csv("solar.csv", na.strings="-")
data <- ts(t(as.matrix(rawData[,2:13])), names=rawData[,1], start=1996)

inkblot <- function(series, col=NULL, min.height=40, col.value=24, col.category=17, ...) {  
  # assumes non-negative values  
  # assumes that series is multivariate series  
  # assumes that series names are set, i.e. colnames(series) != NULL  

  x <- as.vector(time(series))  
  if(length(col)==0){  
    col <- rainbow(dim(series)[2])  
  }  

  ytotal <- 0  
  for(category in colnames(series)) {  
    y <- series[, category]
    y <- y[!is.na(y)]
    ytotal <- ytotal + max(y, min.height)  
  }  

  oldpar = par(no.readonly = TRUE)   
  par(mar=c(2,3,0,10)+0.1, cex=0.7)  

  plot(x, 1:length(x), type="n", ylim=c(0,1)*ytotal, yaxt="n", xaxt="n", bty="n", ylab="", xlab="", ...) 
  axis(side=1, at=x)  

  catNumber <- 1  
  offset <- 0  
  for(category in rev(colnames(series))) {  
    print(paste("working on: ", category))
    y <- 0.5 * as.vector(series[,category])  
    offset <- offset + max(max(abs(y[!is.na(y)])), 0.5*min.height)  
    print(paste("offset= ", str(offset)))
    polygon(c(x, rev(x)), c(offset+y, offset-rev(y)), col=col[catNumber], border=NA)  
    mtext(text=y[1], side=2, at=offset, las=2, cex=0.7, col=col.value)  
    mtext(text=y[length(y)], side=4, line=-1, at=offset, las=2, cex=0.7, col=col.value)  
    mtext(text=category, side=4, line=2, at=offset, las=2, cex=0.7, col=col.category)  
    offset <- offset + max(max(abs(y[!is.na(y)])), 0.5*min.height)  
    catNumber <- catNumber + 1   
  }  
}  


inkblot(data)
-------------------------------------------------------------------------------------------------------
par(new=TRUE) x <- 1:20
plot(x, log(x), type='l') 
par(new=TRUE)              # key: ask for new plot without erasing old
plot(x, sqrt(x), type='l', col='red', xlab="", yaxt="n")
axis(4)
-------------------------------------------------------------------------------------------------------
> plot(x = dataset$x, y = dataset$y)
> axis(4, at = axTicks(2), label = axTicks(2) * 10)
-------------------------------------------------------------------------------------------------------
expression() axis(1, at=c(0:2), labels=c(expression(0-10), expression(11-30), expression(31-70)))
-------------------------------------------------------------------------------------------------------
png(filename="figure.png", width=900, bg="white")
par(mar=c(5,6,4,1)+.1)
barplot(c(1.1, 0.8, 0.7), horiz=TRUE, border="blue", axes=FALSE, col="darkblue")
axis(2, at=1:3, lab=c("elephant", "hippo", "snorkel"), las=1, cex.axis=1.3)
dev.off()
-------------------------------------------------------------------------------------------------------
g <- (nrow(data)-1)/(3*nrow(data))

plot(data[,"dist.mean"],col=2, type='o',lwd=2,cex=1.5, main="This is the title of the graph",
 xlab="x-Label", ylab="y-Label", xaxt="n",
 ylim=c(0,max(data[,"dist.mean"])+max(data[,"dist.sd"])),
 xlim=c(1-g,nrow(data)+g))
axis(side=1,at=c(1:nrow(data)),labels=data[,"ob_time"])

for (i in 1:nrow(data)) {
lines(c(i,i),c(data[i,"dist.mean"]+data[i,"dist.sd"],data[i,"dist.mean"]-data[i,"dist.sd"]))
lines(c(i-g,i+g),c(data[i,"dist.mean"]+data[i,"dist.sd"], data[i,"dist.mean"]+data[i,"dist.sd"]))
lines(c(i-g,i+g),c(data[i,"dist.mean"]-data[i,"dist.sd"], data[i,"dist.mean"]-data[i,"dist.sd"]))
}
-------------------------------------------------------------------------------------------------------
set.seed(100)
Data <- rbind(matrix(rnorm(100, sd = 0.3), ncol = 2),
           matrix(rnorm(100, mean = 1, sd = 0.3), ncol = 2))
colnames(x) <- c("x", "y")

# noise <- runif(100,0,.05)
line.width <- rep(.004, dim(Data)[1])
Y <- NULL
X <- NULL
k.range <- 2:10

plot(0,0, col = "white", xlim = c(1,10), ylim = c(-.5,1.6),
    xlab = "Number of clusters", ylab = "Clusters means", main = "(Basic) Clustergram")
axis(side =1, at = k.range)
abline(v = k.range, col = "grey")

centers.points <- list()

for(k in k.range)
{
    cl <- kmeans(Data, k)

    clusters.vec <- cl$cluster
    the.centers <- apply(cl$centers,1, mean)

    noise <- unlist(tapply(line.width, clusters.vec, cumsum))[order(seq_along(clusters.vec)[order(clusters.vec)])]  
    noise <- noise - mean(range(noise))
    y <- the.centers[clusters.vec] + noise
    Y <- cbind(Y, y)
    x <- rep(k, length(y))
    X <- cbind(X, x)

    centers.points[[k]] <- data.frame(y = the.centers , x = rep(k , k)) 
#   points(the.centers ~ rep(k , k), pch = 19, col = "red", cex = 1.5)
}

require(colorspace)
COL <- rainbow_hcl(100)
matlines(t(X), t(Y), pch = 19, col = COL, lty = 1, lwd = 1.5)

# add points
lapply(centers.points, function(xx) {with(xx,points(y~x, pch = 19, col = "red", cex = 1.3))})
-------------------------------------------------------------------------------------------------------
image heatmap nba <- read.csv("http://datasets.flowingdata.com/ppg2008.csv")

dst <- dist(nba[1:20, -1],)
dst <- data.matrix(dst)

dim <- ncol(dst)

image(1:dim, 1:dim, dst, axes = FALSE)

axis(1, 1:dim, nba[1:20,1], cex.axis = 0.5)
axis(2, 1:dim, nba[1:20,1], cex.axis = 0.5)

for (i in 1:dim)
    {
    for (j in 1:dim)
        {
        txt <- sprintf("%0.1f", dst[i,j])
        text(i, j, txt, cex=0.5)
        }
    }
-------------------------------------------------------------------------------------------------------
+.POSIXt scatterplot(dataset$d1 ~ as.numeric(dataset$Time) | dataset$d3, data=dataset, xaxt="n")
axis(1, at=as.numeric(dataset$Time), labels=dataset$Time, cex.axis=0.5)
-------------------------------------------------------------------------------------------------------
half=FALSE panel.axis(side=c("bottom"),
           at=c(0, 25, 50, 75, 100),
           labels=c("0%", "25%", "50%", "75%", "100%"),
           rot=0, half=FALSE, ticks=TRUE) panel.grid panel.abline panel.barchart() panel.grid(h=FALSE, v=-1)
-------------------------------------------------------------------------------------------------------
grid.yaxis(name="ya", main=TRUE, at=seq(0.1, 0.9, length=5))
grid.remove(gPath("ya", "ticks"))
grid.remove(gPath("ya", "major"))
-------------------------------------------------------------------------------------------------------
R> xpos <- seq(0, 1000, by=100)
R> plot(1:1000, rnorm(1000), type="l", xaxt="n")
R> axis(1, at=xpos, labels=sprintf("%.2fkb", xpos/1000)) xpos
-------------------------------------------------------------------------------------------------------
labels= axis() as.character() at=
-------------------------------------------------------------------------------------------------------
fft plotFFT getFFTFreqs plotFFT # Gets the frequencies returned by the FFT function
getFFTFreqs <- function(Nyq.Freq, data)
    {
    if ((length(data) %% 2) == 1) # Odd number of samples
        {
        FFTFreqs <- c(seq(0, Nyq.Freq, length.out=(length(data)+1)/2), 
               seq(-Nyq.Freq, 0, length.out=(length(data)-1)/2))
        }
    else # Even number
        {
        FFTFreqs <- c(seq(0, Nyq.Freq, length.out=length(data)/2), 
               seq(-Nyq.Freq, 0, length.out=length(data)/2))
        }

    return (FFTFreqs)
    }

# FFT plot
# Params:
# x,y -> the data for which we want to plot the FFT 
# samplingFreq -> the sampling frequency
# shadeNyq -> if true the region in [0;Nyquist frequency] will be shaded
# showPeriod -> if true the period will be shown on the top
# Returns a list with:
# freq -> the frequencies
# FFT -> the FFT values
# modFFT -> the modulus of the FFT
plotFFT <- function(x, y, samplingFreq, shadeNyq=TRUE, showPeriod = TRUE)
    {
    Nyq.Freq <- samplingFreq/2
    FFTFreqs <- getFFTFreqs(Nyq.Freq, y)

    FFT <- fft(y)
    modFFT <- Mod(FFT)
    FFTdata <- cbind(FFTFreqs, modFFT)
    plot(FFTdata[1:nrow(FFTdata)/2,], t="l", pch=20, lwd=2, cex=0.8, main="",
        xlab="Frequency (Hz)", ylab="Power")
    if (showPeriod == TRUE)
        {
        # Period axis on top        
        a <- axis(3, lty=0, labels=FALSE)
        axis(3, cex.axis=0.6, labels=format(1/a, digits=2), at=a)
        }
    if (shadeNyq == TRUE)
        {
        # Gray out lower frequencies
        rect(0, 0, 2/max(x), max(FFTdata[,2])*2, col="gray", density=30)
        }

    ret <- list("freq"=FFTFreqs, "FFT"=FFT, "modFFT"=modFFT)
    return (ret)
    } # A sum of 3 sine waves + noise
x <- seq(0, 8*pi, 0.01)
sine <- sin(2*pi*5*x) + 0.5 * sin(2*pi*12*x) + 0.1*sin(2*pi*20*x) + 1.5*runif(length(x))
par(mfrow=c(2,1))
plot(x, sine, "l")
res <- plotFFT(x, sine, 100) linearChirp <- function(fr=0.01, k=0.01, len=100, samplingFreq=100)
    {
    x <- seq(0, len, 1/samplingFreq)
    chirp <- sin(2*pi*(fr+k/2*x)*x) 

    ret <- list("x"=x, "y"=chirp)
    return(ret)
    }

chirp <- linearChirp(1, .02, 100, 500)
par(mfrow=c(2,1))
plot(chirp, t="l")
res <- plotFFT(chirp$x, chirp$y, 500, xlim=c(0, 4))
-------------------------------------------------------------------------------------------------------
x <- rbinom(1000, 2000, 0.001)
tmp <- hist(x, breaks=0:(max(x)+1), xaxt="n", right=FALSE, freq=FALSE)
axis(1, at=tmp$mids, labels=0:max(x))
-------------------------------------------------------------------------------------------------------
filled.contour plot.axes filled.contour(x = seq(from=-1.5,to=1.5,length=20),
      y = seq(from=1,to=3.75,length=25), z = mypredict,
      col = hsv(h=seq(from=2/3,to=0,length=20),s=1,v=1),
      plot.axes = {axis(1); axis(2); rect(left, bottom, right, top);}) lines rect
-------------------------------------------------------------------------------------------------------
X <- rep(1:10,10)
Z <- as.factor(sample(letters[1:10],100,replace=T))

plot(jitter(as.numeric(Z),factor=0.2),X,xaxt="n")
axis(1,at=1:10,labels=levels(Z))
-------------------------------------------------------------------------------------------------------
cex.axis set.seed(123)
foo <- data.frame(X = rnorm(10), Y = rnorm(10))
plot(Y ~ X, data = foo, cex.axis = 3) > sessionInfo()
R version 2.11.1 Patched (2010-08-17 r52767)
Platform: x86_64-unknown-linux-gnu (64-bit)

locale:
 [1] LC_CTYPE=en_GB.UTF-8       LC_NUMERIC=C              
 [3] LC_TIME=en_GB.UTF-8        LC_COLLATE=en_GB.UTF-8    
 [5] LC_MONETARY=C              LC_MESSAGES=en_GB.UTF-8   
 [7] LC_PAPER=en_GB.UTF-8       LC_NAME=C                 
 [9] LC_ADDRESS=C               LC_TELEPHONE=C            
[11] LC_MEASUREMENT=en_GB.UTF-8 LC_IDENTIFICATION=C       

attached base packages:
[1] grid      stats     graphics  grDevices utils     datasets  methods  
[8] base     

other attached packages:
[1] ggplot2_0.8.8 proto_0.3-8   reshape_0.8.3 plyr_1.2.1   

loaded via a namespace (and not attached):
[1] digest_0.4.2 tools_2.11.1 cex.axis cex.lab plot(Y ~ X, data = foo, cex.lab = 3) barplot() cex.names barplot() cex.axis horiz = TRUE barplot() axis() axis() barplot()
-------------------------------------------------------------------------------------------------------
plot() axis() xaxt yaxt plot() plot(Y ~ X, data=foo,yaxt="n")
axis(2,cex.axis=2) plot(Y ~ X, data=foo,xaxt="n")
axis(1,cex.axis=2) tN <- table(sample(letters[1:5],100,replace=T,p=c(0.2,0.1,0.3,0.2,0.2)))

op <- par(mfrow=c(1,2))
barplot(tN, col=rainbow(5),cex.axis=0.5) # for the Y-axis
barplot(tN, col=rainbow(5),cex.names=0.5) # for the X-axis
par(op)
-------------------------------------------------------------------------------------------------------
par(xaxp = c(x1, x2, n)) plot(..., xaxp = c(x1, x2, n)) x1 x2 n n+1 ?par axis() plot(... , xaxt = "n") axis() side at labels axis(side = 1, at = v1, labels = v2) side v1 c(1, 3, 5) v2 v1 c("group a", "group b", "group c") ?axis
-------------------------------------------------------------------------------------------------------
plot(1:10, 1:10, axes = FALSE)
axis(side = 1, at = c(1,5,10))
axis(side = 2, at = c(1,3,7,10))
box()
-------------------------------------------------------------------------------------------------------
m <- matrix(1:30, ncol=6)
colnames(m) <- paste("C", 1:6, sep="")
rownames(m) <- paste("R", 1:5, sep="")
m

image(1:ncol(m), 1:nrow(m), t(m), col = terrain.colors(60), axes = FALSE)
axis(1, 1:ncol(m), colnames(m))
axis(2, 1:nrow(m), rownames(m))
for (x in 1:ncol(m))
  for (y in 1:nrow(m))
    text(x, y, m[y,x])
-------------------------------------------------------------------------------------------------------
x <- c(rexp(1000,0.5)+0.5,rexp(100,0.5)*100)

breaks<- c(0,0.1,0.2,0.5,1,2,5,10,20,50,100,200,500,1000,10000)
major <- c(0.1,1,10,100,1000,10000)


H <- hist(log10(x),plot=F)


plot(H$mids,H$counts,type="n",
      xaxt="n",
      xlab="X",ylab="Counts",
      main="Histogram of X",
      bg="lightgrey"
)
abline(v=log10(breaks),col="lightgrey",lty=2)
abline(v=log10(major),col="lightgrey")
abline(h=pretty(H$counts),col="lightgrey")
plot(H,add=T,freq=T,col="blue")
#Position of ticks
at <- log10(breaks)

#Creation X axis
axis(1,at=at,labels=10^at) ?par
-------------------------------------------------------------------------------------------------------
# Generate some dummy data
datapoints <- runif(10000, 0, 100)

par (mfrow = c(2,2))

# We will plot 4 histograms, with different bin size
binsize <- c(1, 5, 10, 20)

for (bs in binsize)
    {
    # Plot the histogram. Hide the axes by setting axes=FALSE
    h <- hist(datapoints, seq(0, 100, bs), col="black", axes=FALSE, 
        xlab="", ylab="", main=paste("Bin size: ", bs))
    # Plot the x axis without modifying it
    axis(1)
    # This will NOT plot the axis (lty=0, labels=FALSE), but it will return the tick values
    yax <- axis(2, lty=0, labels=FALSE)
    # Plot the axis by appropriately scaling the tick values
    axis(2, at=yax, labels=yax/bs)
    }
-------------------------------------------------------------------------------------------------------
bigmacprice <- data.frame(
    country = c("Switzerland", "Brazil", "Euro area",
        "Canada", "Japan", "United States",
        "Britain", "Singapore", "South Korea",
        "South Africa", "Mexico", "Thailand",
        "Russia", "Malaysia", "China"),
    price = c(6.78, 5.26, 4.79, 4.18, 3.91, 3.71,
              3.63, 3.46, 3.03, 2.79, 2.58, 2.44,
              2.39, 2.25, 2.18)
)


plotbigmac <- function(mac, base = "United States", xlim = c(-40, 100)) {
    mac <- mac[order(mac$price),]
    base = which(mac$country == base)
    height <- (mac$price / mac[base, "price"] - 1) * 100
    par(bg = "#d0e0e7", col.main = "#262324", col.axis = "#393E46",
        mar = c(8, 8, 6, 6), las = 1)
    barplot(height, width = .1, space = .4,
        names.arg = mac$country, #cex.names = .8,
        col = "#01516c", border = "#7199a8", # border = "#577784",
        horiz = TRUE, xlim = c(-40, 100), axes = FALSE)
    axis(3, lty = 0)
    title(main = "Bunfight\nBig Mac index", col = "#393E46")

    abline(v = seq(-100, 100, 10), col = "white", lwd = 2)
    abline(v = 0, col = "#c8454e", lwd = 2)
    par(xpd = TRUE)
    for (i in 1:nrow(mac)) {
        rect(105, (i - 1) / 7, 118, i / 7 - 0.05,
        col = "white", border = "#7199a8")
        text(112, (i - 1) / 7 + 0.05, mac$price[i], cex = 0.8, col = "#393E46")
    }
    rect(-120, 2.5, -90, 3, col = "#c8454e", border = "#c8454e")
    text(-68, -.2, "Sources:", col = "#393E46")
    text(-64, -.3, "McDonald's;", col = "#393E46")
    text(-60, -.4, "The Economist", col = "#393E46")
}

plotbigmac(bigmacprice) barplot barplot plotBigMac <- function(mac, base = "United States") {
    old.par <- par(no.readonly = TRUE)
    on.exit(par(old.par))
    # Create data:
    mac <- mac[order(mac$price),]
    base = which(mac$country == base)
    height <- (mac$price / mac[base, "price"] - 1) * 100
    # Costume 'barplot'
    NN <- length(height)
    width <- rep(1, length.out = NN)
    delta <- width / 2
    w.r <- cumsum(width + 0.5)
    w.m <- w.r - delta
    w.l <- w.m - delta
    xlim <- c(range(-.01 * height, height)[1], 100)
    ylim <- c(min(w.l), max(w.r))
    par(bg = "#d0e0e7", col.main = "#262324", col.axis = "#393E46",
        mar = c(8, 8, 6, 6), las = 1, cex = 0.9)
    plot.new()
    plot.window(xlim, ylim)
    abline(v = seq(-100, 100, 20), col = "white", lwd = 2)
    rect(0, w.l, height, w.r, col = "#01516c", border = "#7199a8", lwd = 1)

    # Lines and axis
    abline(v = 0, col = "#c8454e", lwd = 2)
    axis(3, axTicks(3), abs(axTicks(3)), lty = 0)
    axis(2, labels = mac$country, at = w.m, lty = 0)

    # Move outside of plot area
    par(xpd = TRUE)

    # Text misc.
    text(5, (w.l[base] + w.r[base]) / 2, "nil", font = 3)
    text(8, w.r[NN] + 2.3, "+")
    text(-8, w.r[NN] + 2.3, "-")

    # Create price boxes:
    rect(105, w.l, 125, w.r,
        col = "white", border = "#7199a8", lwd = 1)
    text(115, (w.r + w.l)/2, mac$price, cex = 0.8, col = "#393E46")

}
-------------------------------------------------------------------------------------------------------
... plot legend legend foo.plot <- function(x,y,...) {
    plot(x,y,...)
    legend("bottomleft", "bar", pch = 1, ...)
} > foo.plot(1, 1, xjust = 0.5)
Warning messages:
1: In plot.window(...) : "xjust" is not a graphical parameter
2: In plot.xy(xy, type, ...) : "xjust" is not a graphical parameter
3: In axis(side = side, at = at, labels = labels, ...) :
  "xjust" is not a graphical parameter
4: In axis(side = side, at = at, labels = labels, ...) :
  "xjust" is not a graphical parameter
5: In box(...) : "xjust" is not a graphical parameter
6: In title(...) : "xjust" is not a graphical parameter plot.default axis box localPlot() plot() bar.plot <- function(x, y, pch = 1, ...) {
    localPlot <- function(..., legend, fill, border, angle, density,
                          xjust, yjust, x.intersp, y.intersp,
                          text.width, text.col, merge, trace, plot = TRUE, ncol,
                          horiz, title, inset, title.col, box.lwd,
                          box.lty, box.col, pt.bg, pt.cex, pt.lwd) plot(...)
    localPlot(x, y, pch = pch, ...)
    legend(x = "bottomleft", legend = "bar", pch = pch, ...)
} 'plot' TRUE bar.plot(1, 1, xjust = 0.5, title = "foobar", pch = 3) bty bty 'pch' bar.plot() 'pch' lme() la.args <- function(x = "bottomleft", legend = "bar", pch = 1, ...)
    c(list(x = x, legend = legend, pch = pch), list(...))

foo.plot <- function(x,y, legend.args = la.args(), ...) {
    plot(x, y, ...)
    do.call(legend, legend.args)
} foo.plot(1,1, xaxt = "n", legend.args=la.args(bg = "yellow", title = "legend")) la.args() la.args()
-------------------------------------------------------------------------------------------------------
help(par) mar oma par(mar=c(5,3,1,1))   # extra large bottom margin
hist(vector, axes = FALSE, breaks = chartBreaks)
axis(1, at = tickMarks, labels = eventTypes, las = 2, tick = FALSE)
-------------------------------------------------------------------------------------------------------
zoo ?plot.zoo z <- zoo(d[,-1],as.Date(d[,1]))
plot(z)

# Example of custom axis labels
plot(z$Entry.Count, screen = 1, col = 1:2, xaxt = "n")
ix <- seq(1, length(time(z)), 3)
axis(1, at = time(z)[ix], labels = format(time(z)[ix],"%b-%d"), cex.axis = 0.7)
-------------------------------------------------------------------------------------------------------
x <- 10*(1:nrow(volcano))
 y <- 10*(1:ncol(volcano))
 image(x, y, volcano, col = terrain.colors( length(seq(90, 200, by = 5))-1), axes = FALSE, breaks= seq(90, 200, by = 5) )
 axis(1, at = seq(100, 800, by = 100))
 axis(2, at = seq(100, 600, by = 100))
 box()
 title(main = "Maunga Whau Volcano", font.main = 4)



 x <- 10*(1:nrow(volcano))
 y <- 10*(1:ncol(volcano))
 image(x, y, volcano, col = terrain.colors( length(seq(150, 200, by = 5))-1), axes = FALSE, breaks= seq(150, 200, by = 5) )
 axis(1, at = seq(100, 800, by = 100))
 axis(2, at = seq(100, 600, by = 100))
 box()
 title(main = "Maunga Whau Volcano Restricted to elevations above 150", font.main = 4)
-------------------------------------------------------------------------------------------------------
plot.TukeyHSD2 <- function (x, ...) {
    for (i in seq_along(x)) {
        xi <- x[[i]][, -4, drop = FALSE]
        yvals <- nrow(xi):1
        plot(c(xi[, "lwr"], xi[, "upr"]), rep.int(yvals, 2), 
            type = "n", axes = FALSE, xlab = "", ylab = "", ...)
        axis(1, ...)
        axis(2, at = nrow(xi):1, labels = dimnames(xi)[[1L]], 
            srt = 0, ...)
        abline(h = yvals, lty = 1, lwd = 1, col = "lightgray")
        abline(v = 0, lty = 2, lwd = 1, ...)
        segments(xi[, "lwr"], yvals, xi[, "upr"], yvals, col="black", ...)
        segments(as.vector(xi), rep.int(yvals - 0.1, 3), as.vector(xi), 
            rep.int(yvals + 0.1, 3), col="black", ...)
        title(main = paste(format(100 * attr(x, "conf.level"), 
            2), "% family-wise confidence level\n", sep = ""), 
            xlab = paste("Differences in mean levels of", names(x)[i]))
        box()
    }
}
-------------------------------------------------------------------------------------------------------
import random 
import networkx as nx
z=[int(random.gammavariate(alpha=9.0,beta=2.0)) for i in range(100)]
G=nx.configuration_model(z) Notes
-----
As described by Newman [1]_.

A non-graphical degree sequence (not realizable by some simple
graph) is allowed since this function returns graphs with self
loops and parallel edges.  An exception is raised if the degree
sequence does not have an even sum.

This configuration model construction process can lead to
duplicate edges and loops.  You can remove the self-loops and
parallel edges (see below) which will likely result in a graph
that doesn't have the exact degree sequence specified.  This
"finite-size effect" decreases as the size of the graph increases.

References
----------
.. [1] M.E.J. Newman, "The structure and function
       of complex networks", SIAM REVIEW 45-2, pp 167-256, 2003.

Examples
--------
>>> from networkx.utils import powerlaw_sequence
>>> z=nx.create_degree_sequence(100,powerlaw_sequence)
>>> G=nx.configuration_model(z)

To remove parallel edges:

>>> G=nx.Graph(G)

To remove self loops:

>>> G.remove_edges_from(G.selfloop_edges()) #!/usr/bin/env python
import random
import matplotlib.pyplot as plt
import networkx as nx

def seq(n):
    return [random.gammavariate(alpha=2.0,beta=1.0) for i in range(100)]    
z=nx.create_degree_sequence(100,seq)
nx.is_valid_degree_sequence(z)
G=nx.configuration_model(z)  # configuration model

degree_sequence=sorted(nx.degree(G).values(),reverse=True) # degree sequence
print "Degree sequence", degree_sequence
dmax=max(degree_sequence)

plt.hist(degree_sequence,bins=dmax)
plt.title("Degree histogram")
plt.ylabel("count")
plt.xlabel("degree")

# draw graph in inset 
plt.axes([0.45,0.45,0.45,0.45])
Gcc=nx.connected_component_subgraphs(G)[0]
pos=nx.spring_layout(Gcc)
plt.axis('off')
nx.draw_networkx_nodes(Gcc,pos,node_size=20)
nx.draw_networkx_edges(Gcc,pos,alpha=0.4)

plt.savefig("degree_histogram.png")
plt.show()
-------------------------------------------------------------------------------------------------------
x.Date <- as.Date(paste(rep(2003:2004, each = 12), rep(1:12, 2), 1, sep = "-"))
x <- zoo(rnorm(24), x.Date)
plot(x) plot(x, xaxt = "n")
axis(1, at = time(x), labels = FALSE) plot(x)
axis(1, at = time(x), labels = FALSE) ## weekly ticks
plot(x)
times <- time(x)
ticks <- seq(times[1], times[length(times)], by = "weeks")
axis(1, at = ticks, labels = FALSE, tcl = -0.3) ?axis.Date ?plot.zoo
-------------------------------------------------------------------------------------------------------
xx.Date <- as.Date((Sys.Date()-500):Sys.Date())
x <- zoo(cumsum(rnorm(501)), xx.Date)
tt=time(x)
plot(x, xaxt ="n")
tt <- time(x)
ix <- seq(1, length(tt), by=60) #every 60 days
fmt <- "%b-%d" # format for axis labels
labs <- format(tt[ix], fmt)
axis(side = 1, at = tt[ix], labels = labs,  cex.axis = 0.7)
-------------------------------------------------------------------------------------------------------
ticksAt Data <- data.frame(date=Sys.Date()+1:10,time=paste(5,41:50,sep=":"))
with(Data, plot(date,time,yaxt="n"))
ticksAt <- c(1,3,5,7,9)
axis(2, at=ticksAt, labels=as.character(Data$time)[ticksAt]) ?plot.zoo ?par
-------------------------------------------------------------------------------------------------------
hist( rlnorm(1000, log(130) ), breaks=seq(0, 3000, by=200), xlim=c(0,2100) , axes=FALSE)
axis(1, at=seq(0 , 2000, by=200) axis(1, at=seq(0 , 2000, by=200) , las=2)
-------------------------------------------------------------------------------------------------------
set.seed(2); x <- rlnorm(1000, log(130))
hist(x, breaks=seq(0, 3000, by=200), xlim=c(0,2100), xaxt="n")

axis(1, at=c(0,2100), labels=c("",""), lwd.ticks=0)
axis(1, at=seq(0 , 2000, by=200), lwd=0, lwd.ticks=1)
-------------------------------------------------------------------------------------------------------
seriation set.seed(1)
dat <- data.frame(A = c(rnorm(10, 2), rnorm(10, -2), rnorm(10, -2)),
                  B = c(rnorm(10, 0), rnorm(10, 5), rnorm(10, -2)),
                  C = c(rnorm(10, 0), rnorm(10, 0), rnorm(10, -10)))

## randomise the rows
dat <- dat[sample(nrow(dat)),]
clus <- kmeans(scale(dat, scale = FALSE), centers = 3, iter.max = 50,
               nstart = 10)

## means of n points in each cluster
mns <- sapply(split(dat, clus$cluster), function(x) mean(unlist(x)))

## order the data by cluster with clusters ordered by `mns`, low to high
dat2 <- dat[order(order(mns)[clus$cluster]), ]

## heatmaps
## original first, then reordered:
layout(matrix(1:2, ncol = 2))
image(1:3, 1:30, t(data.matrix(dat)), ylab = "Observations", 
      xlab = "Variables", xaxt = "n", main = "Original")
axis(1, at = 1:3)
image(1:3, 1:30, t(data.matrix(dat2)), ylab = "Observations", 
      xlab = "Variables", xaxt = "n", main = "Reordered")
axis(1, at = 1:3)
layout(1)
-------------------------------------------------------------------------------------------------------
\documentclass[a4paper]{article}
\usepackage{graphicx}
\begin{document}
\title{Test document}
\maketitle

Don't miss the great information in Figure \ref{myfig}!


<<p=mplfig, label=myfig, caption = "Figure caption...">>=
import sys
import pylab as pl

pl.plot([1,2,3,4,5],['2,4,6,8,10'], 'b.', markersize=15)
pl.axis('scaled')
pl.axis([-3,3, -3,3]) # [xmin,xmax, ymin,ymax]
@

\end{document}
-------------------------------------------------------------------------------------------------------
TkBuildDist <- function(  x=seq(min+(max-min)/nbin/2,
                                max-(max-min)/nbin/2,
                                length.out=nbin),
                          min=0, max=10, nbin=10, logspline=TRUE,
                          intervals=FALSE) {

    if(logspline) logspline <- require(logspline)
    require(tkrplot)

    xxx <- x

    brks <- seq(min, max, length.out=nbin+1)
    nx <- seq( min(brks), max(brks), length.out=250 )

    lx <- ux <- 0
    first <- TRUE

    replot <- if(logspline) {
        if(intervals) {
            function() {
                hist(xxx, breaks=brks, probability=TRUE,xlab='', main='')
                xx <- cut(xxx, brks, labels=FALSE)
                fit <- oldlogspline( interval = cbind(brks[xx], brks[xx+1]) )
                lines( nx, doldlogspline(nx,fit), lwd=3 )
                if(first) {
                    first <<- FALSE
                    lx <<- grconvertX(min, to='ndc')
                    ux <<- grconvertX(max, to='ndc')
                }
            }
        } else {
            function() {
                hist(xxx, breaks=brks, probability=TRUE,xlab='', main='')
                fit <- logspline( xxx )
                lines( nx, dlogspline(nx,fit), lwd=3 )
                if(first) {
                    first <<- FALSE
                    lx <<- grconvertX(min, to='ndc')
                    ux <<- grconvertX(max, to='ndc')
                }
            }
        }
    } else {
        function() {
            hist(xxx, breaks=brks, probability=TRUE,xlab='',main='')
            if(first) {
                first <<- FALSE
                lx <<- grconvertX(min, to='ndc')
                ux <<- grconvertX(max, to='ndc')
            }
        }
    }

    tt <- tktoplevel()
    tkwm.title(tt, "Distribution Builder")

    img <- tkrplot(tt, replot, vscale=1.5, hscale=1.5)
    tkpack(img, side='top')

    tkpack( tkbutton(tt, text='Quit', command=function() tkdestroy(tt)),
           side='right')

    iw <- as.numeric(tcl('image','width',tkcget(img,'-image')))

    mouse1.down <- function(x,y) {
        tx <- (as.numeric(x)-1)/iw
        ux <- (tx-lx)/(ux-lx)*(max-min)+min
        xxx <<- c(xxx,ux)
        tkrreplot(img)
    }

    mouse2.down <- function(x,y) {
        if(length(xxx)) {
            tx <- (as.numeric(x)-1)/iw
            ux <- (tx-lx)/(ux-lx)*(max-min)+min
            w <- which.min( abs(xxx-ux) )
            xxx <<- xxx[-w]
            tkrreplot(img)
        }
    }

    tkbind(img, '<ButtonPress-1>', mouse1.down)
    tkbind(img, '<ButtonPress-2>', mouse2.down)
    tkbind(img, '<ButtonPress-3>', mouse2.down)

    tkwait.window(tt)

    out <- list(x=xxx)
    if(logspline) {
        if( intervals ) {
            xx <- cut(xxx, brks, labels=FALSE)
            out$logspline <- oldlogspline( interval = cbind(brks[xx], brks[xx+1]) )
        } else {
            out$logspline <- logspline(xxx)
        }
    }

    if(intervals) {
        out$intervals <- table(cut(xxx, brks))
    }

    out$breaks <- brks

    return(out)
} TkBuildDist2 <- function( min=0, max=1, nbin=10, logspline=TRUE) {
    if(logspline) logspline <- require(logspline)
    require(tkrplot)

    xxx <- rep( 1/nbin, nbin )

    brks <- seq(min, max, length.out=nbin+1)
    nx <- seq( min, max, length.out=250 )

    lx <- ux <- ly <- uy <- 0
    first <- TRUE

    replot <- if(logspline) {
        function() {
            barplot(xxx, width=diff(brks), xlim=c(min,max), space=0,
                    ylim=c(0,0.5), col=NA)
            axis(1,at=brks)
            xx <- rep( 1:nbin, round(xxx*100) )
            capture.output(fit <- oldlogspline( interval = cbind(brks[xx], brks[xx+1]) ))
            lines( nx, doldlogspline(nx,fit)*(max-min)/nbin, lwd=3 )

            if(first) {
                first <<- FALSE
                lx <<- grconvertX(min, to='ndc')
                ly <<- grconvertY(0,   to='ndc')
                ux <<- grconvertX(max, to='ndc')
                uy <<- grconvertY(0.5, to='ndc')
            }
        }
    } else {
        function() {
            barplot(xxx, width=diff(brks), xlim=range(brks), space=0,
                    ylim=c(0,0.5), col=NA)
            axis(at=brks)
            if(first) {
                first <<- FALSE
                lx <<- grconvertX(min, to='ndc')
                ly <<- grconvertY(0,   to='ndc')
                ux <<- grconvertX(max, to='ndc')
                uy <<- grconvertY(0.5, to='ndc')
            }
        }
    }

    tt <- tktoplevel()
    tkwm.title(tt, "Distribution Builder")

    img <- tkrplot(tt, replot, vscale=1.5, hscale=1.5)
    tkpack(img, side='top')

    tkpack( tkbutton(tt, text='Quit', command=function() tkdestroy(tt)),
           side='right')

    iw <- as.numeric(tcl('image','width',tkcget(img,'-image')))
    ih <- as.numeric(tcl('image','height',tkcget(img,'-image')))



    md <- FALSE

    mouse.move <- function(x,y) {
        if(md) {
            tx <- (as.numeric(x)-1)/iw
            ty <- 1-(as.numeric(y)-1)/ih

            w <- findInterval(tx, seq(lx,ux, length=nbin+1))

            if( w > 0 && w <= nbin && ty >= ly && ty <= uy ) {
                 xxx[w] <<- 0.5*(ty-ly)/(uy-ly)
                xxx[-w] <<- (1-xxx[w])*xxx[-w]/sum(xxx[-w])

                tkrreplot(img)
            }
        }
    }

    mouse.down <- function(x,y) {
        md <<- TRUE
        mouse.move(x,y)
    }

    mouse.up <- function(x,y) {
        md <<- FALSE
    }

    tkbind(img, '<Motion>', mouse.move)
    tkbind(img, '<ButtonPress-1>', mouse.down)
    tkbind(img, '<ButtonRelease-1>', mouse.up)

    tkwait.window(tt)

    out <- list(breaks=brks, probs=xxx)
    if(logspline) {
        xx <- rep( 1:nbin, round(xxx*100) )
        out$logspline <- oldlogspline( interval = cbind(brks[xx], brks[xx+1]) )
    }

    return(out)
}
-------------------------------------------------------------------------------------------------------
"Date" "POSIXct" "POSIXlt" Lines <- "Date            Visits
11/1/2010   696537
11/2/2010   718748
11/3/2010   799355
11/4/2010   805800
11/5/2010   701262
11/6/2010   531579
11/7/2010   690068
11/8/2010   756947
11/9/2010   718757
11/10/2010  701768
11/11/2010  820113
11/12/2010  645259"

dm <- read.table(text = Lines, header = TRUE)
dm$Date <- as.Date(dm$Date, "%m/%d/%Y")
plot(Visits ~ Date, dm, xaxt = "n", type = "l")
axis(1, dm$Date, format(dm$Date, "%b %d"), cex.axis = .7) text = Lines "myfile.dat" library(zoo)
z <- read.zoo(text = Lines, header = TRUE, format = "%m/%d/%Y")
plot(z, xaxt = "n")
axis(1, dm$Date, format(dm$Date, "%b %d"), cex.axis = .7) plot(Visits ~ Date, dm) plot(z) axis
-------------------------------------------------------------------------------------------------------
Lines <- "Date            Visits
11/1/2010   696537
11/2/2010   718748
11/3/2010   799355
11/4/2010   805800
11/5/2010   701262
11/6/2010   531579
11/7/2010   690068
11/8/2010   756947
11/9/2010   718757
11/10/2010  701768
11/11/2010  820113
11/12/2010  645259"

dm <- read.table(textConnection(Lines), header = TRUE)
dm$Date <- as.Date(dm$Date, "%m/%d/%Y")
plot(Visits ~ Date, dm, xaxt = "n", type = "l")
axis(1,at=NULL, labels=F)
text(x = dm$Date, par("usr")[3]*.97, labels = paste(dm$Date,' '), srt = 45, pos = 1, xpd = TRUE,cex=.7)
-------------------------------------------------------------------------------------------------------
melt reshape2 cast as.POSIXlt(your.unix.timestamps, origin="1970-01-01", tz="GMT") format # original data
data.timestamps = c(1297977452, 1297977452, 1297977453, 1297977454, 1297977454, 1297977454, 1297977455, 1297977455)
data.unique.timestamps = unique(data.timestamps)

# get the labels
data.labels = format(as.POSIXlt(data.unique.timestamps, origin="1970-01-01", tz="GMT"), "%H:%M:%S")

# plot the histogram without axes
hist(data.timestamps, axes=F)

# add axes manually
axis(2)
axis(1, at=unique(data.timestamps), labels=data.labels)
-------------------------------------------------------------------------------------------------------
tikzAnnotate tikzAnnotate grid grid print gridToDevice <- function(x = 0, y = 0, units = 'native') {
  # Converts a coordinate pair from the current viewport to an "absolute
  # location" measured in device units from the lower left corner. This is done
  # by first casting to inches in the current viewport and then using the
  # current.transform() matrix to obtain inches in the device canvas.
  x <- convertX(unit(x, units), unitTo = 'inches', valueOnly = TRUE)
  y <- convertY(unit(y, units), unitTo = 'inches', valueOnly = TRUE)

  transCoords <- c(x,y,1) %*% current.transform()
  transCoords <- (transCoords / transCoords[3])

  return(
    # Finally, cast from inches to native device units
    c(
      grconvertX(transCoords[1], from = 'inches', to ='device'),
      grconvertY(transCoords[2], from = 'inches', to ='device')
    )
  )

} tikzAnnotate grid lattice require(tikzDevice)
require(grid)
options(tikzLatexPackages = c(getOption('tikzLatexPackages'),
                "\\usetikzlibrary{shapes.arrows}"))

tikz(standAlone=TRUE)

xs <- 15:20
ys <- 5:10

pushViewport(plotViewport())
pushViewport(dataViewport(xs,ys))

grobs <- gList(grid.rect(),grid.xaxis(),grid.yaxis(),grid.points(xs, ys))

coords <- gridToDevice(17, 7)
tikzAnnotate(paste('\\node[single arrow,anchor=tip,draw,fill=green,left=1em]',
  'at (', coords[1],',',coords[2],') {Look over here!};'))

dev.off() ggplot tikzDevice
-------------------------------------------------------------------------------------------------------
plot() axis() axis(1,at=axis.pos[axis.ind],labels=axis.txt[axis.ind]) axis.ind strftime() '%d %b' R> strftime(Sys.Date(), "%d %b")
[1] "26 Feb"
-------------------------------------------------------------------------------------------------------
starttime <- strptime("20110110", "%Y%m%d")
 endtime <- strptime("20110226 1202", "%Y%m%d %H%M")
 #This is actually determined programmatically, but that's not important
 xrange <- c(starttime, endtime)
 yrange <- c(0, 100)
 par(mar=par()$mar+c(0,0,0,7),bty="l")

 #I added xaxt="n" to supress the plotting of the x-axis
 plot(xrange, yrange, type="n", xaxt="n", xlab="Submission Time", ylab="Best Score", main="Top Scores for each team over time")

 #I added the following two lines to plot the x-axis with a label every 7 days
 atx <- seq(starttime, endtime, by=7*24*60*60)
 axis(1, at=atx, labels=format(atx, "%b\n%d"), padj=0.5)

 #More code to loop and add a bunch of lines(), but it's not really relevant
-------------------------------------------------------------------------------------------------------
depth.class <- cut(quakes$depth, c(40, 120, 200, 300, 400, 500, 600, 680), include.lowest = TRUE) mean.mag <- tapply(quake$mag, depth.class, mean) mean.mag <- tapply(quake$mag, depth.class, mean, na.rm = TRUE) plot(mean.mag, type = "l", xlab = "magnitude class") plot(mean.mag, type = "l", xlab = "magnitude class", axes = FALSE)
axis(1, 1:nlevels(depth.class), levels(depth.class))
axis(2)
box()
-------------------------------------------------------------------------------------------------------
plot(1:10, xaxt = "n", xlab='Some Letters')
axis(1, at=1:10, labels=letters[1:10])
-------------------------------------------------------------------------------------------------------
# The data have a common independent variable (x)
x <- 1:10

# Generate 4 different sets of outputs
y1 <- runif(10, 0, 1)
y2 <- runif(10, 100, 150)
y3 <- runif(10, 1000, 2000)
y4 <- runif(10, 40000, 50000)
y <- list(y1, y2, y3, y4)

# Colors for y[[2]], y[[3]], y[[4]] points and axes
colors = c("red", "blue", "green")

# Set the margins of the plot wider
par(oma = c(0, 2, 2, 3))

plot(x, y[[1]], yaxt = "n", xlab = "Common x-axis", main = "A bunch of plots on the same graph", 
     ylab = "")
lines(x, y[[1]])

# We use the "pretty" function go generate nice axes
axis(at = pretty(y[[1]]), side = 2)

# The side for the axes.  The next one will go on 
# the left, the following two on the right side
sides <- list(2, 4, 4) 

# The number of "lines" into the margin the axes will be
lines <- list(2, NA, 2)

for(i in 2:4) {
  par(new = TRUE)
  plot(x, y[[i]], axes = FALSE, col = colors[i - 1], xlab = "", ylab = "")
  axis(at = pretty(y[[i]]), side = sides[[i-1]], line = lines[[i-1]], 
      col = colors[i - 1])
  lines(x, y[[i]], col = colors[i - 1])
}

# Profit.
-------------------------------------------------------------------------------------------------------
#Generate the data for the four graphs
x <- seq(1, 50, 1)
y1 <- 10*rnorm(50)
y2 <- 100*rnorm(50)
y3 <- 1000*rnorm(50)
y4 <- 10000*rnorm(50)

#Set up the plot area so that multiple graphs can be crammed together
par(pty="m", plt=c(0.1, 1, 0, 1), omd=c(0.1,0.9,0.1,0.9))

#Set the area up for 4 plots
par(mfrow = c(4, 1))

#Plot the top graph with nothing in it =========================
plot(x, y1, xlim=range(x), type="n", xaxt="n", yaxt="n", main="", xlab="", ylab="")
mtext("Four Y Plots With the Same X", 3, line=1, cex=1.5)

#Store the x-axis data of the top plot so it can be used on the other graphs
pardat<-par()
xaxisdat<-seq(pardat$xaxp[1],pardat$xaxp[2],(pardat$xaxp[2]-pardat$xaxp[1])/pardat$xaxp[3])

#Get the y-axis data and add the lines and label
yaxisdat<-seq(pardat$yaxp[1],pardat$yaxp[2],(pardat$yaxp[2]-pardat$yaxp[1])/pardat$yaxp[3])
axis(2, at=yaxisdat, las=2, padj=0.5, cex.axis=0.8, hadj=0.5, tcl=-0.3)
abline(v=xaxisdat, col="lightgray")
abline(h=yaxisdat, col="lightgray")
mtext("y1", 2, line=2.3)
lines(x, y1, col="red")

#Plot the 2nd graph with nothing ================================
plot(x, y2, xlim=range(x), type="n", xaxt="n", yaxt="n", main="", xlab="", ylab="")

#Get the y-axis data and add the lines and label
pardat<-par()
yaxisdat<-seq(pardat$yaxp[1],pardat$yaxp[2],(pardat$yaxp[2]-pardat$yaxp[1])/pardat$yaxp[3])
axis(2, at=yaxisdat, las=2, padj=0.5, cex.axis=0.8, hadj=0.5, tcl=-0.3)
abline(v=xaxisdat, col="lightgray")
abline(h=yaxisdat, col="lightgray")
mtext("y2", 2, line=2.3)
lines(x, y2, col="blue")

#Plot the 3rd graph with nothing =================================
plot(x, y3, xlim=range(x), type="n", xaxt="n", yaxt="n", main="", xlab="", ylab="")

#Get the y-axis data and add the lines and label
pardat<-par()
yaxisdat<-seq(pardat$yaxp[1],pardat$yaxp[2],(pardat$yaxp[2]-pardat$yaxp[1])/pardat$yaxp[3])
axis(2, at=yaxisdat, las=2, padj=0.5, cex.axis=0.8, hadj=0.5, tcl=-0.3)
abline(v=xaxisdat, col="lightgray")
abline(h=yaxisdat, col="lightgray")
mtext("y3", 2, line=2.3)
lines(x, y3, col="green")

#Plot the 4th graph with nothing =================================
plot(x, y4, xlim=range(x), type="n", xaxt="n", yaxt="n", main="", xlab="", ylab="")

#Get the y-axis data and add the lines and label
pardat<-par()
yaxisdat<-seq(pardat$yaxp[1],pardat$yaxp[2],(pardat$yaxp[2]-pardat$yaxp[1])/pardat$yaxp[3])
axis(2, at=yaxisdat, las=2, padj=0.5, cex.axis=0.8, hadj=0.5, tcl=-0.3)
abline(v=xaxisdat, col="lightgray")
abline(h=yaxisdat, col="lightgray")
mtext("y4", 2, line=2.3)
lines(x, y4, col="darkgray")

#Plot the X axis =================================================
axis(1, at=xaxisdat, padj=-1.4, cex.axis=0.9, hadj=0.5, tcl=-0.3)
mtext("X Variable", 1, line=1.5)
-------------------------------------------------------------------------------------------------------
## dummy data
dat <- data.frame(Depth = sample(c(3:6), 20, replace = TRUE), OM = 5 * runif(20)) side = 2 ## margin for side 2 is 7 lines in size
op <- par(mar = c(5,7,4,2) + 0.1) ## default is c(5,4,4,2) + 0.1 ## draw the plot but without annotation
boxplot(OM ~ Depth, data = dat, axes = FALSE, ann = FALSE)
## add axes
axis(1, at = 1:4, labels = c(" ", "Shallow", "Deep", " "), cex.axis = 1.5)
axis(2, cex.axis = 2)
## now draw the y-axis annotation on a different line out from the plot
## using the extra margin space:
title(ylab = "Loss of Percent Organic Matter per Year", cex.lab = 1.5,
      line = 4.5)
## draw the box to finish off
box() par(op) ylab op <- par(mar = c(5,7,4,2) + 0.1) ## default is c(5,4,4,2) + 0.1 op title() title(ylab = "Loss of Percent Organic Matter per Year", cex.lab = 1.5,
      line = 4.5) 4.5 5 'line' 'line' title()
-------------------------------------------------------------------------------------------------------
ggplot(
  melt(data.frame(date=as.Date(rownames(data), "%Y%m%d"), data), id.vars="date"),
  aes(date, value, colour=variable)) + 
  geom_line() ggplot(
  melt(data.frame(date=as.Date(rownames(data), "%Y%m%d"), data), id.vars="date"),
  aes(date, value)) + 
  geom_line() + 
  facet_wrap(~variable) +
  opts(axis.text.x=theme_text(angle=90)) d <- data.frame(date=as.Date(rownames(data), "%Y%m%d"), data)
matplot(d[,1], d[,-1], type="b", pch=1, xaxt="n")
axis(1, d[,1], labels=d[,1])
-------------------------------------------------------------------------------------------------------
axis at label x <- sample(1:100, 10, replace = T) # just 10 random numbers
y <- sample(1:100, 10, replace = T) # 10 more random numbers
par(mar = c(10, 5, 5, 5)) 
    # increasing the 1st number to 10 makes 10 lines below axis 1
plot(x~y) # normal plot
axis(1, at = c(20, 40, 60, 80), labels = c("1", "2", "3", "4"), line = 5, col = 4) 
    # the "line" indicates which of the 10 lines made above to put the axis on
-------------------------------------------------------------------------------------------------------
#Build the data
 t <- 1:1000
 x1 <- 100 * sin(0.01 * t)
 x2 <- 200 * cos(0.04 * t)

 #Set up the plot area for two "crammed" plots
 par(pty="m", plt=c(0.1, 1, 0, 1), omd=c(0.1,0.9,0.1,0.9))
 par(mfrow = c(2, 1))

 #Plot x1 and x2 together
 plot(t, x1, type="l", ylim = 1.5 * range(x1, x2), xaxt="n", xlab="", ylab="", main="", col="blue", las=2)
 lines(t, x2, lwd=1, col="red")
 mtext(side=2, "Top Plot", line=5.3, cex=0.8)
 mtext(side=2, "(units)", line=4, cex=0.8)
 grid()
 mtext(side=3, "2 Plots Crammed Together", line=1.5, cex=1.2)
 legend("topright", legend=c("100 * sin(0.01 * t)", "200 * cos(0.4 * t)"), bg="white", lwd=c(1, 1), col=c("blue", "red"), cex=0.9)

 #Place the 1st x-axis
 axis(side = 1, col="blue", col.axis="blue")
 linloc <- par()$usr[3]
 abline(h=linloc, col="blue")
 mtext(side=1, "First X-Axis", line=2.5, cex=0.8, col="blue")

 #Place the fake 2nd x-axis
 xaxis2 <- 1:10
 par(plt=c(0.1,1,0.6,1))
 plot(xaxis2, type="n", xaxt="n", xlab="", yaxt="n", ylab="", xlim=range(xaxis2), bty="n")
 axis(side = 1, col="red", col.axis="red")
 linloc <- par()$usr[3]
 abline(h=linloc, col="red")
 mtext(side=1, "Second X-Axis", line=2.5, cex=0.8, col="red")
-------------------------------------------------------------------------------------------------------
library(plotrix)

 #Build the matrix data to look like a correlation matrix
 n <- 8
 x <- matrix(runif(n*n), nrow=n)
 xmin <- 0
 xmax <- 1
 for (i in 1:n) x[i, i] <- 1.0 #Make the diagonal all 1's

 #Generate the palette for the matrix and the legend.  Generate labels for the legend
 palmat <- color.scale(x, c(1, 0.4), c(1, 0.4), c(0.96, 1))
 palleg <- color.gradient(c(1, 0.4), c(1, 0.4), c(0.96, 1), nslices=100)
 lableg <- c(formatC(xmin, format="f", digits=2), formatC(1*(xmax-xmin)/4, format="f", digits=2), formatC(2*(xmax-xmin)/4, format="f", digits=2), formatC(3*(xmax-xmin)/4, format="f", digits=2), formatC(xmax, format="f", digits=2))

 #Set up the plot area and plot the matrix
 par(mar=c(5, 5, 5, 8))
 color2D.matplot(x, cellcolors=palmat, main=paste(n, " X ", n, " Matrix Using Color2D.matplot", sep=""), show.values=2, vcol=rgb(0,0,0), axes=FALSE, vcex=0.7)
 axis(1, at=seq(1, n, 1)-0.5, labels=seq(1, n, 1), tck=-0.01, padj=-1)

 #In the axis() statement below, note that the labels are decreasing.  This is because
 #the above color2D.matplot() statement has "axes=FALSE" and a normal axis()
 #statement was used.
 axis(2, at=seq(1, n, 1)-0.5, labels=seq(n, 1, -1), tck=-0.01, padj=0.7)

 #Plot the legend
 pardat <- par()
 color.legend(pardat$usr[2]+0.5, 0, pardat$usr[2]+1, pardat$usr[2], paste(" ", lableg, sep=""), palleg, align="rb", gradient="y", cex=0.7)
-------------------------------------------------------------------------------------------------------
hist(dat, breaks="hours", freq=TRUE, col = "red", axes = FALSE)
axis.POSIXct(side = 1, dat)
axis(2)
-------------------------------------------------------------------------------------------------------
hist(Data, breaks="hours", freq=T, xlab="Time", col="red",
  main="Sat  Volume",axes=F)
Axis(Data,col="black",side=1)
axis(2,col="black") Axis() axis() DateTime hist()
-------------------------------------------------------------------------------------------------------
Rowv Colv NA heatmap(as.matrix(df)[order(k$cluster),],Rowv=NA,Colv=NA,scale="none",labRow=NA) image() image myHeatmap <- function(x,ord,xlab="",ylab="",main="My Heatmap",
                      col=heat.colors(5), ...){
    op <- par(mar=c(3,0,2,0)+0.1)
    on.exit(par(op))
    nc <- NCOL(x)
    nr <- NROW(x)
    labCol <- names(x)

    x <- t(x[ord,])
    image(1L:nc, 1L:nr, x, xlim = 0.5 + c(0, nc), ylim = 0.5 +
        c(0, nr), axes = FALSE, xlab=xlab, ylab=ylab, main=main,
        col=col,...)

    axis(1, 1L:nc, labels = labCol, las = 2, line = -0.5, tick = 0)
    axis(2, 1L:nr, labels = NA, las = 2, line = -0.5, tick = 0)
}

library(RColorBrewer)
myHeatmap(df,order(k$cluster),col=brewer.pal(5,"BuGn")) RColorBrewer
-------------------------------------------------------------------------------------------------------
#Generate the data
 list<-exp(seq(log(600), log(225000), length.out=10))
 g_range=range(0,list)

 #Setup the plotting area and plot it
 par(plt=c(0.2, 0.9, 0.2, 0.9))
 plot(list, axes=FALSE, xlab="", ylab="")

 #Plot the x-axis
 axis(1)
 mtext("Index", side=1, line=2)

 #Plot the y-axis     
 axis(2, las=2)
 mtext("Total", side=2, line=5)
-------------------------------------------------------------------------------------------------------
set.seed(1)
baseball <- data.frame(pitchNumber = seq_len(50),
                       outcome = factor(sample(c("B","H","S","S","X","H"), 
                                               50, replace = TRUE)))
> head(baseball)
  pitchNumber outcome
1           1       H
2           2       S
3           3       S
4           4       H
5           5       H
6           6       H ## better colours - like ggplot for the cool kids
##cols <- c("red","green","blue","yellow")
cols <- head(hcl(seq(from = 0, to = 360,
                    length.out = nlevels(with(baseball, outcome)) + 1), 
                 l = 65, c = 100), -1) pitchNumber type = "h" with(baseball, plot(pitchNumber, y = rep(1, length(pitchNumber)), type = "h", 
                    ylim = c(0, 1.2), col = cols[outcome],
                    ylab = "", xlab = "Pitch", axes = FALSE, lwd = 2))
with(baseball, points(pitchNumber, y = rep(1, length(pitchNumber)), pch = 16, 
                      col = cols[outcome])) axis(side = 1)
box()
## note: this assumes that the levels are in alphabetical order B,H,S,X...
legend("topleft", legend = c("Ball","Hit","Swinging Strike","X??"), lty = 1,
       pch = 16, col = cols, bty = "n", ncol = 2, lwd = 2)
-------------------------------------------------------------------------------------------------------
Date dates tbl <- within(tbl, Date <- as.Date(Date, "%d/%m/%Y")) op <- par(mar = c(6,4,4,2) + 0.1) ## larger bottom margin
## plot data but suppress axes and annotation
plot(Version ~ Date, data = tbl, type = "o", axes = FALSE, ann = FALSE)
## Use Axis to plot the Date axis, in 1 month increments
## format the sequence of dates `ds` as abbreviated month name and Year
with(tbl, Axis(Date, at = (ds <- seq(min(Date), max(Date), by = "months")),
               side = 1, labels = format(ds, format = "%b %Y"), las = 2))
## Add y-axis and plot frame
axis(2)
box()
## add on the axis labels
title(ylab = "Version", main = "Releases")
title(xlab = "Date", line = 5) ## pushing the x-axis label down a bit
par(op) ## reset the pars with(tbl, Axis(Date, at = (ds <- seq(min(Date), max(Date), by = "2 months")),
               side = 1, labels = format(ds, format = "%b %y"), las = 2)) with(....)
-------------------------------------------------------------------------------------------------------
start <- as.Date("01/01/2008", "%d/%m/%Y")
end <- as.Date("01/12/2011", "%d/%m/%Y")
x_breaks <- seq(start, end, by = "month") dates Date dates <- as.Date(as.character(tbl$Date), "%d/%m/%Y") las = 3 mar par(las = 3, mar = c(7, 5, 3, 1)) plot(dates,tbl$Version,type="o",main="Releases", xlab="", ylab="Version", xaxt = "n")
axis(side = 1, at = as.numeric(x_breaks), labels = strftime(x_breaks, "%b %Y"))
title(xlab = "Date", line = 5)
-------------------------------------------------------------------------------------------------------
fixInNamespace() error.bars() psych fixInNamespace(error.bars) axis() error.bars() my.error.bars axis() source() error.bars() error.bars() add = TRUE
-------------------------------------------------------------------------------------------------------
eb = fix(error.bars)
-------------------------------------------------------------------------------------------------------
?errbar Hmisc group <- factor(sample(1:10,100,T))
y <- (1:10)[group] + rnorm(100)
grmean <- tapply(y,group,mean)
lims <- tapply(y,list(group),FUN = sd)*2
errbar( 1:10, grmean, grmean + lims, grmean - lims , xaxt="n" )
axis(3)
-------------------------------------------------------------------------------------------------------
group <- factor(rep(1:10,10))
y <- (1:10)[group] + rnorm(100)

grmean <- tapply(y,group,mean)
plot(1:10,grmean,xaxt="n",type="n")

unstacked <- unstack(data.frame(y,group),y~group)
error.bars(unstacked,add=T)
axis(3)
-------------------------------------------------------------------------------------------------------
errbar() x x x require(Hmisc)

## Your example data
set.seed(1)
x <- 1:10
y <- x + rnorm(10)
delta <- runif(10)

## Make some data vanish
x[c(5,6)] <- NA

## Create an index for non-missing observations in `x`
i <- which(!is.na(x))

errbar(x[i], y[i], y[i] + delta[i], y[i] - delta[i], type = "b") require(Hmisc)

## Your example data
set.seed(1)
# `x` should not contain missing values, and is not your platenames vector
x <- 1:10 
y <- x + rnorm(10)
delta <- runif(10)
# xticks represents your platenames vector with missing values
xticks <- c(1, 2, 3, 4, NA, NA, 7, 8, 9, 10)

errbar(x, y, y + delta, y - delta, type = "b")
axis(1, at = xticks, labels = xticks) mtext() errbar(x, y, y + delta, y - delta, type = "b")
mtext(text = xticks, side = 3, line = 2, at = xticks) side line ?mtext
-------------------------------------------------------------------------------------------------------
set.seed(5)
d <- data.frame(x=1:100, y=rlnorm(100, meanlog=5, sdlog=3))
with(d, {
  plot(x, y, log="y", yaxt="n")
  y1 <- floor(log10(range(y)))
  pow <- seq(y1[1], y1[2]+1)
  ticksat <- as.vector(sapply(pow, function(p) (1:10)*10^p))
  axis(2, 10^pow)
  axis(2, ticksat, labels=NA, tcl=-0.25, lwd=0, lwd.ticks=1)
}) lattice latticeExtra library(lattice)
library(latticeExtra)
xyplot(y~x, data=d, scales=list(y=list(log=10)),
       yscale.components=yscale.components.log10ticks)
-------------------------------------------------------------------------------------------------------
df2<-df
df2$y<-50-df2$y #reverse oredr
image(df2,col=heat.colors(256),yaxt="n") #avoid y axis
axis(2, at=c(0,10,20,30,40,50), labels=c(50,40,30,20,10,0)) #draw y axis manually
-------------------------------------------------------------------------------------------------------
tcars <- read.table(textConnection(" V1       Mazda     Toyota     Peugeot
    Car1.txt 0,507778837 0,19834711 0,146892655
    Car2.txt 0,908717802 0,64214047 0,396508728", header=TRUE, dec=",")
 # need to use dec arg with commas as decimal points!
 tcars
        V1     Mazda    Toyota   Peugeot
1 Car1.txt 0.5077788 0.1983471 0.1468927
2 Car2.txt 0.9087178 0.6421405 0.3965087

 matplot(data.matrix(tcars[-1]), type="b", xaxt="n")
 axis(1, labels=tcars[[1]],at=1:NROW(tcars))
-------------------------------------------------------------------------------------------------------
library(plyr)
ps <- ldply(1:36, function(i)data.frame(s=0:i, n=i))
plot.new()
plot.window(c(1,36), c(0,1))
apply(ps, 1, function(x){
  s<-x[1]; n<-x[2];
  lines(c(n, n+1, n, n+1), c(s/n, s/(n+1), s/n, (s+1)/(n+1)), type="o")})
axis(1)
axis(2)
-------------------------------------------------------------------------------------------------------
axis() x <- 1:100000
y <- 1:100000
marks <- c(0,20000,40000,60000,80000,100000)
plot(x,y,log="x",yaxt="n",type="l")
axis(2,at=marks,labels=marks) x <- 1:100000
y <- 1:100000
format(y,scientific=FALSE)
plot(x,y,log="x",yaxt="n",type="l")
axis(2,at=marks,labels=format(marks,scientific=FALSE))
-------------------------------------------------------------------------------------------------------
library(sfsmisc)

#Generate the data
x <- 1:100000
y <- 1:100000

#Setup the plot area
par(pty="m", plt=c(0.1, 1, 0.1, 1), omd=c(0.1,0.9,0.1,0.9))

#Plot a blank graph without completing the x or y axis
plot(x, y, type = "n", xaxt = "n", yaxt="n", xlab="", ylab="", log = "x", col="blue")
mtext(side=3, text="Test Plot", line=1.2, cex=1.5)

#Complete the x axis
eaxis(1, padj=-0.5, cex.axis=0.8)
mtext(side=1, text="x", line=2.5)

#Complete the y axis and add the grid
aty <- seq(par("yaxp")[1], par("yaxp")[2], (par("yaxp")[2] - par("yaxp")[1])/par("yaxp")[3])
axis(2, at=aty, labels=format(aty, scientific=FALSE), hadj=0.9, cex.axis=0.8, las=2)
mtext(side=2, text="y", line=4.5)
grid()

#Add the line last so it will be on top of the grid
lines(x, y, col="blue")
-------------------------------------------------------------------------------------------------------
RasterLayer ## gives an error, but still plots 
raster:::.imageplot(shrunk)
points(shrunk.coords, pch = ".") .imageplot showMethods("plot", classes = "RasterLayer", includeDefs = TRUE) raster:::.plotraster raster:::.imageplot raster:::.plotraster(shrunk, col = rev(terrain.colors(255)), maxpixels = 5e+05)
points(shrunk.coords, pch = ".") raster:::.imageplot(shrunk)
 abline(h = c(-80, 80), v = c(-80, 80)) plot(shrunk)
abline(h = c(-80, 80), v = c(-80, 80)) par() raster:::.imageplot plot(shrunk)
axis(1, pos = 1)
-------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------
plot.zoo plot.zoo(Cl(SPY), yaxt="n", ylab="") plot.xts plot(Cl(SPY), axes=FALSE)
axis(1, at=xy.coords(.index(SPY), SPY[, 1])$x[axTicksByTime(SPY)],
  label=names(axTicksByTime(SPY)), mgp = c(3, 2, 0)) plot.xts axes= TRUE FALSE
-------------------------------------------------------------------------------------------------------
if (axes) {
      if (minor.ticks) 
        axis(1, at = xycoords$x, labels = FALSE, col = "#BBBBBB")
      axis(1, at = xycoords$x[ep], labels = names(ep), las = 1,lwd = 1, mgp = c(3, 2, 0))
    #This is the line to change:
    if (plotYaxis) axis(2)
    }
-------------------------------------------------------------------------------------------------------
dput(Corl) library(zoo)

Corl <- structure(list(Date = structure(c(15155, 15064, 14974, 14882,
  14790, 14699), class = "Date"), Survey = c(60L, 55L, 48L, 48L,
    56L, 57L), Actual = c(NA, 50L, 44L, 36L, 75L, 41L)), .Names = c("Date",
      "Survey", "Actual"), row.names = c(NA, -6L), class = "data.frame")

Corl.zoo <- read.zoo(Corl, FUN=as.yearqtr)
Corl.zoo

        Survey Actual
2010 Q1     57     41
2010 Q2     56     75
2010 Q3     48     36
2010 Q4     48     44
2011 Q1     55     50
2011 Q2     60     NA

plot(Corl.zoo) my.panel <- function(...) {
   lines(...)
   #This line adds the vertical grid lines
   abline(v=time(Corl.zoo), col="lightgray", lty=3)
   panel.number <- parent.frame()$panel.number
   # if bottom panel
   if (!length(panel.number) || panel.number == NCOL(Corl.zoo)) {
      # next line only if non-labelled ticks wanted for each point
      axis(1, at = time(Corl.zoo), lab = FALSE)
      labcou <- 1 #Put a label, counting between labels
      ix <- seq(1, length(Corl.zoo), labcou)
      labs <- format(time(Corl.zoo), "%Y\nQ%q\n ")
      axis(1, at = time(Corl.zoo)[ix], lab = labs[ix], tcl = -0.5, padj=0.6, cex.axis = 1)
   }
}

plot(Corl.zoo, panel = my.panel, xaxt = "n", main="My Title", xlab="")
-------------------------------------------------------------------------------------------------------
axes = FALSE plot() plot(x, y, type="h", log="xy", axes = FALSE) axis(side = 1, at = (locs <- 1/c(1,10,100,1000)), labels = locs)
axis(side = 2)
box() tcl axis() -0.5 foo <- function(i, x, by) seq(x[i,1], x[i, 2], by = by[i])
locs2 <- unlist(lapply(seq_along(locs[-1]), FUN = foo, 
                       x= embed(locs, 2), by = abs(diff(locs)) / 9)) locs2 <- c(outer(1:10, c(10, 100, 1000), "/")) R> locs2
 [1] 0.100 0.200 0.300 0.400 0.500 0.600 0.700 0.800 0.900 1.000 0.010 0.020
[13] 0.030 0.040 0.050 0.060 0.070 0.080 0.090 0.100 0.001 0.002 0.003 0.004
[25] 0.005 0.006 0.007 0.008 0.009 0.010 axis() axis(side = 1, at = locs2, labels = NA, tcl = -0.2) labels = NA at plot(x, y, type="h", log="xy", axes = FALSE)
axis(side = 1, at = (locs <- 1/c(1,10,100,1000)), labels = locs)
axis(side = 1, at = locs2, labels = NA, tcl = -0.3)
axis(side = 2)
box() ylim plot() plot(x, y, type="h", log="xy", axes = FALSE, ylim = c(0.2, 1))
axis(side = 1, at = (locs <- 1/c(1,10,100,1000)), labels = locs)
axis(side = 2)
box()
-------------------------------------------------------------------------------------------------------
library(sfsmisc)

x <- seq(0, 1, length=1001)
y <- dbeta(x, 0.1, 0.1)
plot(x, y, type="h", log="xy", xaxt="n", yaxt="n", ylim=c(0.01, 0.5), main="Title")

atx <- c(0.0001, 0.001, 0.01, 0.1, 1, 10, 100)
eaxis(1, at=atx, labels=format(atx, drop0trailing=TRUE, scientific=FALSE), drop.1=FALSE, small.mult=10 )
aty <- c(0.01, 0.1, 0.5, 1, 10, 100)
eaxis(2, at=aty, labels=format(aty, drop0trailing=TRUE, scientific=FALSE), drop.1=FALSE, small.mult=10 )
grid()
-------------------------------------------------------------------------------------------------------
x <- runif(50, -10, 10)
y <- runif(50, -10, 10)
plot(x, y, yaxt="n") # don't plot y-axis, see ?par, section xaxt
axis(2, pos=0) # Draw y-axis at 0 line grid()
-------------------------------------------------------------------------------------------------------
dat dat <- structure(list(DATE = structure(list(sec = c(0, 0, 0, 0, 0, 0, 
0, 0, 0, 0, 0, 0, 0, 0), min = c(0L, 0L, 0L, 0L, 0L, 0L, 0L, 
0L, 0L, 0L, 0L, 0L, 0L, 0L), hour = c(0L, 6L, 12L, 18L, 0L, 6L, 
12L, 18L, 0L, 6L, 12L, 18L, 0L, 6L), mday = c(18L, 18L, 18L, 
18L, 19L, 19L, 19L, 19L, 20L, 20L, 20L, 20L, 21L, 21L), mon = c(5L, 
5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L, 5L), year = c(111L, 
111L, 111L, 111L, 111L, 111L, 111L, 111L, 111L, 111L, 111L, 111L, 
111L, 111L), wday = c(6L, 6L, 6L, 6L, 0L, 0L, 0L, 0L, 1L, 1L, 
1L, 1L, 2L, 2L), yday = c(168L, 168L, 168L, 168L, 169L, 169L, 
169L, 169L, 170L, 170L, 170L, 170L, 171L, 171L), isdst = c(1L, 
1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L)), .Names = c("sec", 
"min", "hour", "mday", "mon", "year", "wday", "yday", "isdst"
), class = c("POSIXlt", "POSIXt")), GROUP = structure(c(2L, 1L, 
2L, 2L, 1L, 1L, 2L, 1L, 1L, 1L, 2L, 1L, 2L, 1L), .Label = c("L", 
"R"), class = "factor"), GROUP2 = structure(c(1L, 2L, 2L, 1L, 
2L, 2L, 1L, 2L, 1L, 1L, 1L, 1L, 1L, 2L), .Label = c("L", "R"), class = "factor")), .Names = c("DATE", 
"GROUP", "GROUP2"), row.names = c(NA, -14L), class = "data.frame") counts <- apply(dat[, 2:3], 1, function(x) sum(x == "R")) countmat <- t(cbind(L = (NCOL(dat) - 1) - counts, R = counts)) barplot() op <- par(mar = c(9,4,4,2) + 0.1, las = 2)
mids <- barplot(countmat, ylim = c(0,2.5),
                legend.text = c("L","R"),
                args.legend = list(x = "top", bty = "n"))
axis(side = 1, at = mids, labels = as.character(dat$DATE))
par(op) count2 <- with(dat, GROUP == "R")
countmat2 <- t(cbind(R = count2, L = !count2))

op <- par(mar = c(9,4,4,2) + 0.1, las = 2)
mids <- barplot(countmat2, ylim = c(0, 1.5),
                legend.text = c("R","L"),
                args.legend = list(x = "top", bty = "n"))
axis(side = 1, at = mids, labels = as.character(dat$DATE))
par(op)
-------------------------------------------------------------------------------------------------------
convertScaleToBottom <- function(x,botRange,topRange){
    temp <- (x - topRange[1]) / (topRange[2] - topRange[1])
    return(botRange[1] + (temp * (botRange[2] - botRange[1])))
} x z1 <- 5:13
z1Adj <- convertScaleToBottom(z1,range(x),range(z1))

# draw an axis on the top
axis(3, at=z1Adj,labels=round(z1,digits=2),
     col.axis="blue", las=2, cex.axis=0.7, tck=-.01) convertScaleToBottomRev <- function(x,botRange,topRange){
    temp <- (x - topRange[1]) / (topRange[2] - topRange[1])
    return(botRange[2] - (temp * (botRange[2] - botRange[1])))
}
-------------------------------------------------------------------------------------------------------
axes = FALSE at ?axis plot(cars, axes = FALSE)
axis( 1, at = c(5,6,7,10,11,12,21,22,23) )
-------------------------------------------------------------------------------------------------------
pyramid.plot debug(pyramid.plot) if (is.null(laxlab)) {
            laxlab <- seq(xlim[1] - gap, 0, by = -1)
            axis(1, at = -xlim[1]:-gap, labels = laxlab)
        } pyramid.plot pyramid.plot(x,y,labels=groups,
             main="Performance",gap=5e5,show.values=TRUE,
             laxlab=seq(0,1e7,by=1e6),raxlab=seq(0,1e7,by=1e6)) pyramid.plot
-------------------------------------------------------------------------------------------------------
x <- 1:10
y <- exp(1:10)
plot(x,y,log="y") log="x" log="xy" axTicks(x) bquote() bquote() as.expression() bquote() axis() ?plotmath x <- y <- 1:10
plot(x,y,yaxt="n")
aty <- axTicks(2)
labels <- sapply(aty,function(i)
            as.expression(bquote(10^ .(i)))
          )
axis(2,at=aty,labels=labels)
-------------------------------------------------------------------------------------------------------
weekdays(dat) ## days of the week
days <- c('Sun','Mon','Tues','Wed','Thurs','Fri','Sat')

## sample with replacement to generate data for this example
samples <- sample(days,100,replace=TRUE)

## convert to factor
## specify levels to specify the order
samples <- factor(samples,levels=days)

hist(unclass(samples),xaxt="n")
axis(1,at=1:nlevels(samples),lab=levels(samples))
box()
-------------------------------------------------------------------------------------------------------
minor.tick Hmisc ax axis n t.ratio ... axis mn mx mn=0 minor.ticks.axis <- function(ax,n,t.ratio=0.5,mn,mx,...){

  lims <- par("usr")
  if(ax %in%c(1,3)) lims <- lims[1:2] else lims[3:4]

  major.ticks <- pretty(lims,n=5)
  if(missing(mn)) mn <- min(major.ticks)
  if(missing(mx)) mx <- max(major.ticks)

  major.ticks <- major.ticks[major.ticks >= mn & major.ticks <= mx]

  labels <- sapply(major.ticks,function(i)
            as.expression(bquote(10^ .(i)))
          )
  axis(ax,at=major.ticks,labels=labels,...)

  n <- n+2
  minors <- log10(pretty(10^major.ticks[1:2],n))-major.ticks[1]
  minors <- minors[-c(1,n)]

  minor.ticks = c(outer(minors,major.ticks,`+`))
  minor.ticks <- minor.ticks[minor.ticks > mn & minor.ticks < mx]


  axis(ax,at=minor.ticks,tcl=par("tcl")*t.ratio,labels=FALSE)
} x <- 10^(0:8)
y <- 1:9
plot(log10(x),y,xaxt="n",xlab="x",xlim=c(0,9))
minor.ticks.axis(1,9,mn=0,mx=8)
-------------------------------------------------------------------------------------------------------
axis() graphics graphics > data <- log(rnorm(10000, 100, 10))  #simulate some data that looks like yours
> hist(data) # view a normal histogram of the data with log values on the x-axis
> tick_locations = c(4.2, 4.4, 4.6, 4.8, 5.0)  # copy the tick locations from the normal plot
> tick_labels = exp(tick_locations) # reverse the log transformation; you can also create this manually
> hist(data, xaxt = "n")  # plot without the x-axis
> axis(1, at = tick_locations, labels = tick_labels) # add the x-axis with the de-transformed values
-------------------------------------------------------------------------------------------------------
axis(1, at = start(time(myts))[1]:end(time(myts))[1], labels = TRUE)
-------------------------------------------------------------------------------------------------------
days <- seq(min(data$date), max(data$date), by = 'month')
axis(1, at=days,labels=strftime(days, "%F"),tick=FALSE) 
days <- seq(as.Date(min(data$date)), as.Date(max(data$date)), by = 'month')
-------------------------------------------------------------------------------------------------------
ggplot2 d <- read.table(textConnection("Category    SubCat  Value
A           Cat1    0.1
B           Cat1    0.2
A           Cat2    0.3
B           Cat2    0.24
A           Cat3    13
B           Cat3    41
A           Cat4    60
B           Cat4    146"),header = TRUE, sep="")

d$grp <- rep(c('Cat1 - Cat2','Cat3 - Cat4'), each = 4)
ggplot(d,aes(x = Category, y = Value)) + 
    facet_wrap(~grp, scales = "free_y") + 
    geom_bar(aes(fill = SubCat), position = "dodge") ggplot2 twoord.plot par(xaxt = "n") 
twoord.plot(ly = d$Value[1:4],ry = d$Value[5:8], rx = c(9,11,13,15), lx = c(1,3,5,7),
            type = c('bar','bar'), 
            xlim = c(0,16),
            lylim = c(0,0.35),rylim = c(12,150))
par(xaxt="s")           
axis(1, at = c(1,3,5,7,9,11,13,15),las = 3)
-------------------------------------------------------------------------------------------------------
heatmap axis() 
axis(2, iy, labels = labRow, las = 2, line = -0.5, tick = 0,  cex.axis = cexRow) 
par(mar = c(margins[1L], 5, 0, margins[2L])) x  <- as.matrix(mtcars)
rc <- rainbow(nrow(x), start=0, end=.3)
cc <- rainbow(ncol(x), start=0, end=.3)
utils::str(hv) # the two re-ordering index vectors

## no  dendrogram (nor color strip)
heatmap.new(x, Colv = NA, Rowv=NA, col = cm.colors(256), scale="column",
        margins=c(5,2),
        xlab = "specification variables", ylab= "Car Models",
        main = "heatmap(<Mtcars data>, ..., scale = \"column\")")
-------------------------------------------------------------------------------------------------------
boring <- function(x, occ) occ/x

boring_seq <- function(occ, length.out){
  x <- seq(occ, length.out=length.out)
  data.frame(x = x, y = boring(x, occ))
}

numbet <- 31
odds <- 6
plot(1, 0, type="n",  
    xlim=c(1, numbet + odds), ylim=c(0, 1),
    yaxp=c(0,1,2),
    main="Frequency matrix", 
    xlab="Successive occasions",
    ylab="Relative frequency"
    )

axis(2, at=c(0, 0.5, 1))    

for(i in 1:odds){
  xy <- boring_seq(i, numbet+1)
  lines(xy$x, xy$y, type="o", cex=0.5)
}

for(i in 1:numbet){
  xy <- boring_seq(i, odds+1)
  lines(xy$x, 1-xy$y, type="o", cex=0.5)
}
-------------------------------------------------------------------------------------------------------
ps <- ldply(0:35, function(i)data.frame(s=0:i, n=i))
 plot.new()
 plot.window(c(0,36), c(0,1))
 apply(ps[ps$s<6 & ps$n - ps$s < 30, ], 1, function(x){
   s<-x[1]; n<-x[2];
   lines(c(n, n+1, n, n+1), c(s/n, s/(n+1), s/n, (s+1)/(n+1)), type="o")})
 axis(1)
 axis(2)
 lines(6:36, 6/(6:36), type="o")
 # need to fill in the unconnected points on the upper frontier
-------------------------------------------------------------------------------------------------------
dnorm() zmax <- 4
curve(dnorm, -zmax, zmax, xaxt = 'n', bty = 'n')
axis(1, -zmax:zmax, pos = 0) dnorm zscore <- 1.65
segments(zscore, 0, zscore, dnorm(zscore)) x <- seq(zscore, zmax, 0.01)
y <- c(0, dnorm(x)[1:(length(x)-2)],0)
polygon(x,y, density = 20) segments text
-------------------------------------------------------------------------------------------------------
plot(rep(1,3),c(0.2, 0.8, 0.95),ylim=c(0,1),axes=F,xlab="",ylab="",type="o",pch=19)
axis(side=2)
text(rep(1,3),c(0.2, 0.8, 0.95),c("apples", "bananas", "tomatoes"),pos=4,xpd=T) stripchart() stripchart(c(0.2, 0.8, 0.95),vertical=T)
text(rep(1,3),c(0.2, 0.8, 0.95),c("apples", "bananas", "tomatoes"),pos=4)
-------------------------------------------------------------------------------------------------------
set.seed(1)
t1 = rnorm(10); t2 = rnorm(10, 2)
t1_g2 = rnorm(10, 4);t2_g2 = rnorm(10)

##Don't print the axes labels
par(ann=FALSE)

##Plot first set of data.
##Need to check for sensible ranges
##Use the jitter function to spread data out.
plot(jitter(rep(0,10),amount=0.2), t1,
     xlim=range(-0.5,3.5), ylim=range(-3,8),
     axes=FALSE,frame.plot=TRUE)
points(jitter(rep(1,10), amount=0.2), t1_g2, col=2)
points(jitter(rep(2,10), amount=0.2), t2)
points(jitter(rep(3,10), amount=0.2), t2_g2, col=2)

##Add in the y-axis
axis(2, seq(-4,8,by=2))

##Add in the x-axis labels
mtext("Treatment 1", side = 1, at=0.5)
mtext("Treatment 2", side = 1, at=2.5)

##Add in the means
segments(-0.25, mean(t1), 0.25, mean(t1))
segments(0.75, mean(t1_g2), 1.25, mean(t1_g2))
segments(1.75, mean(t2), 2.25, mean(t2))
segments(2.75, mean(t2_g2), 3.25, mean(t2_g2))

##Add in the legend
legend(0, 8, c("Group 1", "Group 2"), col=1:2, pch=1)
-------------------------------------------------------------------------------------------------------
image z = c(5,4,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,
0,0,4,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,
2,0,0,0,2,0,0,0,0,0,
1,0,0,0,0,2,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0)

z = matrix(z, ncol=10)
colnames(z) = c("a","b","c","d","e","f","g","h","i", "j")
rownames(z) = c("a","b","c","d","e","f","g","h","i", "j")

##To get the correct image plot rotation
##We need to flip the plot
image(z[,ncol(z):1], axes=FALSE)

##Add in the y-axis labels. Similar idea for x-axis.
axis(2, at = seq(0, 1, length=length(colnames(z))), labels=colnames(z)) heatmap heatmap(t(z)[ncol(z):1,], Rowv=NA,
               Colv=NA, col = heat.colors(256))
-------------------------------------------------------------------------------------------------------
u <- "http://onlinelibrary.wiley.com/store/10.1111/j.1469-8137.2010.03479.x/asset/image_n/NPH_3479_f1.gif?v=1&t=gskxvi17&s=0f13fa9dae78bd6837aeee594065c6ca112864d2"

imfile <- paste(tempfile(), ".gif", sep = "")

download.file(u, imfile, mode = "wb")

library(raster)  ## rgdal also required for this file format
library(rgdal)

im <- raster(imfile)

plot(im) axis(1, pos = 2) locator points lines text
-------------------------------------------------------------------------------------------------------
axis() plot(temp, xaxt = 'n')
s <- paste('x>', 1:5, sep = '=')
axis(1, 1:5, parse(text = s))
-------------------------------------------------------------------------------------------------------
levels(temp[,"x"]) <- paste("x>=", 1:5, sep="") lev.as.expr <- parse(text=levels(temp[,"x"])) plot(temp, xaxt="n")
axis(side=1, at=1:5, labels=lev.as.expr)
-------------------------------------------------------------------------------------------------------
axis plot(1:10, axes = FALSE) axis(1, at = (1:10) + 0.5, labels = 10:1, tick = FALSE) axis(1, at = (1:10), labels = FALSE, tick = TRUE)
box() axis(2, ...) axis(2)
-------------------------------------------------------------------------------------------------------
xaxp plot(year,dat,xaxp=c(range(year),2)) Date year2 <- as.Date(paste(year,"-01-01",sep="")) plot(year2,dat) plot(year,dat,xaxt="n") axis(1,at=year)
-------------------------------------------------------------------------------------------------------
dat <- data.frame(x=factor(c(-10 ,-5, 0, 1, 2, 3, 4, 5, 10)), y=1:9)

 with(dat, plot(x, y))   # a step-like plot
 with(dat, plot(as.numeric(x), y, type="p", xaxt="n")) # points instead of steps
 axis(1, at=1:9, labels=as.character(dat$x))           # the "irregular" axis axis unique(as.character(.)) axis
-------------------------------------------------------------------------------------------------------
axis() mids <- barplot(x, xlab="")

 axis(1, at=mids, labels=c("AA/AA","AA/CC","AA/AC","AA/NC","CC/AA","CC/CC", "CC/AC","CC/NC","AC/AA","AC/CC","AC/AC","AC/NC"), las=3)
-------------------------------------------------------------------------------------------------------
read.zoo z plot.zoo xyplot.zoo qplot Lines <- "FECHA H_SOLAR;DIR_M;VEL_M;TEMP_M;HR;PRECIP
01/06/14 00:50:00;314.3;1.9;14.1;68.0;-99.9
01/06/14 01:50:00;322.0;1.6;13.3;68.9;-99.9
01/06/14 02:50:00;303.5;2.1;12.3;70.9;-99.9
01/06/14 03:50:00;302.4;1.6;11.6;73.1;-99.9
01/06/14 04:50:00;306.5;1.2;10.9;76.4;-99.9
01/06/14 05:50:00;317.1;0.8;12.6;71.5;-99.9
01/06/14 06:50:00;341.8;0.0;17.1;58.8;-99.9
01/06/14 07:50:00;264.6;1.2;21.8;44.9;-99.9
01/06/14 08:50:00;253.8;2.9;24.7;32.2;-99.9
01/06/14 09:50:00;254.6;3.7;26.7;27.7;-99.9
01/06/14 10:50:00;250.7;4.3;28.3;24.9;-99.9
01/06/14 11:50:00;248.5;5.3;29.1;22.6;-99.9
01/06/14 12:50:00;242.8;4.7;30.3;20.4;-99.9
01/06/14 13:50:00;260.7;4.9;31.3;17.4;-99.9
01/06/14 14:50:00;251.8;5.1;31.9;17.1;-99.9
01/06/14 15:50:00;258.1;4.6;32.4;15.3;-99.9
01/06/14 16:50:00;254.3;5.7;32.4;14.0;-99.9
01/06/14 17:50:00;252.5;4.6;32.0;14.1;-99.9
01/06/14 18:50:00;257.4;3.8;31.1;14.9;-99.9
01/06/14 19:50:00;135.8;4.2;26.0;41.2;-99.9
01/06/14 20:50:00;126.0;1.7;23.5;48.7;-99.9
01/06/14 21:50:00;302.8;0.7;21.6;53.9;-99.9
01/06/14 22:50:00;294.2;1.1;19.3;67.4;-99.9
01/06/14 23:50:00;308.5;1.0;17.5;72.4;-99.9"
cat(Lines, "\n", file = "data.txt")

library(zoo)
z <- read.zoo("data.txt", header = TRUE, sep = ";", na.strings = "-99.9", 
        tz = "", format = "%y/%m/%d %H:%M:%S")
# move last 12 points into following day
time(z)[13:24] <- time(z)[13:24] + 24 * 60 * 60
xlim <- as.POSIXct(c("2001-06-14 00:00:00", "2001-06-14 12:00:00")) plot.zoo # Create manual axis since classic graphic's default is not so good.
# Axis might be ok for real data in which case manual axis setting can be omitted
plot(z$VEL_M, type = "p", xlab = "X", ylab = "Y", col = "blue", xlim = xlim,
    xaxt = "n")
xaxis <- seq(xlim[1], xlim[2], by = "hour")
axis(1, xaxis, as.POSIXlt(xaxis)$hour) xyplot.zoo library(lattice)
xyplot(z$VEL_M, type = "p", xlab = "X", ylab = "Y", col = "blue", xlim = xlim) qplot # unlike classic graphics and lattice graphics, zoo currently 
# does not have a specific interface but we can do this:
library(ggplot2)
qplot(time(z), z$VEL_M, xlab = "X", ylab = "Y") + 
    geom_point(colour = "blue") +
    scale_x_datetime(limits = xlim)
-------------------------------------------------------------------------------------------------------
maxv <- 500

v <- t(<matrix>)
d <- <vector>
di <- <vector>
dm <- <vector>
nr <- nrow(v)
nc <- ncol(v)

library(grid)
vnorm <- v
for (r in 1:nr) {
  for (c in 1:nc) {
    vnorm[r,c] <- min(1, v[r, nc-c+1]/500)
    if (vnorm[r,c] == 0) {vnorm[r,c] <- "blue"}
    else {vnorm[r,c] <- grey(vnorm[r,c])}
  }
}
vnorm <- t(vnorm)

x <- seq(1, nr)
y <- rep(1, nr)
xrange <- range(d)
yrange <- c(0, 24)

bm <- 90
lm <- 40
tm <- 12
rm <- 12

png(file="graph.png", width=nr+lm+rm, height=nc+tm+bm)
par(mai=c(bm/72, lm/72, tm/72, rm/72))
plot(d, y, ann=FALSE, xlim=xrange, ylim=yrange, axes=FALSE, xaxs="i", yaxs="i")
axis(1, at=dm,labels=dm, col.axis="black", las=2)
axis(2, at=seq(0,24),labels=seq(0,24), col.axis="black", las=2)
rasterImage(vnorm, xrange[1], yrange[1], xrange[2], yrange[2], interpolate=FALSE)
dev.off()
-------------------------------------------------------------------------------------------------------
boxplot(a, at = 0:2*3 + 1, xlim = c(0, 9), ylim = range(a, b), xaxt = "n")
boxplot(b, at = 0:2*3 + 2, xaxt = "n", add = TRUE)
axis(1, at = 0:2*3 + 1.5, labels = colnames(a), tick = TRUE) ylim = range(a, b) axis() 0:2*2 0:2*3
-------------------------------------------------------------------------------------------------------
dens <- density(myd)
polygon(c(3, dens$x[dens$x>3 & dens$x < 5], 5), c(0, dens$y[dens$x>=3 & dens$x <= 5], 0),col="tan") dens <- density(myd)
plot(dens, xlim = c(0, 5), xaxt = 'n', bty = 'n')
axis(1, pos = 0)
polygon(c(3, dens$x[dens$x>3 & dens$x < 6], 6), c(0, dens$y[dens$x>=3 & dens$x <= 6], 0),col="tan")
-------------------------------------------------------------------------------------------------------
yaxt="n" seq sprintf round set.seed(1)
x <- runif(10)
plot(x, type="h", yaxt="n")
yLabels <- seq(0.2, 0.8, 0.2)
axis(2, at=yLabels, labels=sprintf(round(100*yLabels), fmt="%2.2f%%"), las=1)
-------------------------------------------------------------------------------------------------------
m axis at= # find the hourly sections of the chron index
m <- trunc((tt-trunc(tt))*24)/(24)
# find the minimum index value for each hour
l <- tapply(tt, m, min)
# plot the series
plot(z[,1], col='red', lty=1, xaxt="n", xlab="")
# add the axis
axis(side=1, at=l, labels=unique(m), las=2)
-------------------------------------------------------------------------------------------------------
text(axTicks(1), par("usr")[3] - 2, srt=45, adj=1, labels=lab, xpd=T, cex=0.8) axTicks(1) > axTicks(1)
[1]  5 10 15 1:19 text(1:19, par("usr")[3] - 2, srt=45, adj=1, labels=lab, xpd=T, cex=0.8) Runtime <- c(579,0,581,610,830,828,592,651,596,596,591,581,587,
             594,604,606,447,434,445)
g_range <- range(0,Runtime)
lab <- c('2011-07-20','2011-08-03','2011-08-10','2011-08-17','2011-08-24',
         '2011-08-25','2011-08-27','2011-08-31','2011-09-07','2011-09-10',
         '2011-09-14','2011-09-21','2011-09-28','2011-10-05','2011-10-06',
         '2011-10-07','2011-10-13','2011-10-19','2011-10-31')
## plot
op <- par(mar = c(6,4,4,2) + 0.1) ## bigger bottom margin
plot(Runtime, type="o", col="blue", ylim=g_range, axes=FALSE, ann=FALSE)
box()
axis(1, at=1:19, lab=FALSE)
text(1:19, par("usr")[3] - 40, srt=45, adj=1.2, labels=lab, xpd=T, cex=0.7)
axis(2, las=1, at=500*0:g_range[2])
title(main="Runtime", col.main="red", font.main=4)
title(xlab="Build", col.lab=rgb(0,0.5,0), line = 4.5)
title(ylab="MS", col.lab=rgb(0,0.5,0))
legend("topright", c("AveElapsedTime"), cex=0.8, col=c("blue"), pch=21, lty=1)
## reset par
par(op) y y ## load gridBase
require(gridBase)

## do the base plot parts
op <- par(mar = c(6,4,4,2) + 0.1) ## bigger bottom margin
plot(1:19, Runtime, type="o", col="blue", ylim=g_range, axes=FALSE, ann=FALSE)
box()
axis(1, at=1:19, lab=FALSE)
axis(2, las=1, at=500*0:g_range[2])
title(main="Runtime", col.main="red", font.main=4)
title(xlab="Build", col.lab=rgb(0,0.5,0), line = 4.5)
title(ylab="MS", col.lab=rgb(0,0.5,0))
legend("topright", c("AveElapsedTime"), cex=0.8, col=c("blue"), pch=21, lty=1)
## at this point, DO NOT alter the dimensions of the plotting window

## now do the grid business
vps <- baseViewports()
pushViewport(vps$inner, vps$figure, vps$plot)
## this adds the text
grid.text(lab, x = unit(1:19, "native"), y = unit(-1, "lines"),
          just = "right", rot = 60, gp = gpar(cex = 0.7))
## this finishes off the viewport - you have to do this or things will go wrong:
popViewport(3)
## reset par
par(op) pdf()
-------------------------------------------------------------------------------------------------------
as.expression(z) drawGraph <- function(x, y, z) {
    g_range <- range(0,x)
    plot(x, type="o", col="blue", ylim=g_range,axes=FALSE, ann=FALSE)
    box()
    axis(1, at=1:19, lab=FALSE)
    text(1:19, labels=y,par("usr")[3] - 2, srt=45, adj=1.2, xpd=T, cex=0.3)
    axis(2, las=1, at=500*0:g_range[2])
    main_title<-as.expression(z)
    title(main=main_title, col.main="red", font.main=4)
    title(xlab="Build", col.lab=rgb(0,0.5,0))
    title(ylab="MS", col.lab=rgb(0,0.5,0))
    legend("topright", g_range[2], c("z"), cex=0.8, col=c("blue"), pch=21, lty=1);
}
x <- rpois(19, 4)
AveElapsedTime=paste("The average time with ranges:", 
                       round(range(x)[1], 3), 
                        "to" , round(range(x), 3)[1])
lab=1:19
drawGraph(AET, lab, AveElapsedTime)
-------------------------------------------------------------------------------------------------------
axes = FALSE axis() # no call to par() needed
plot(c(1:10), axes = FALSE)
axis(1)                     # x-Axis
ticks <- seq(3, 9, 1)       # sequence for ticks and labels
axis(2, at = ticks, labels = ticks)
box()                       # and a box around the plot
-------------------------------------------------------------------------------------------------------
ggplot library(png)
library(grid)
imgfile <- "http://upload.wikimedia.org/wikipedia/commons/e/e1/Tie-dye.png"   
download.file(imgfile,dest="tiedye.png")
r <- readPNG("tiedye.png")
rmat <- matrix(rgb(r[,,1],r[,,2],r[,,3],alpha=0.4),
               nrow=dim(r)[1]) shadow.points <- function(x, y, size=unit(1, "char"), default.units="native", ...) {
 if(!is.unit(x)) {x <- unit(x, default.units) } 
 if(!is.unit(y)) { y <- unit(y, default.units) }
 grid::grid.points(x+0.2*size, y-0.2*size, size=size, gp=gpar(col="black"), pch=20) 
 grid::grid.points(x, y, size=size, default.units=default.units, ...)
} grid.roundrect png("mask.png",width=ncol(r), height=nrow(r), res=1)
grid.roundrect(gp=gpar(fill="black"))
dev.off()
m <- readPNG("mask.png", native=FALSE)
mask <- matrix(rgb(m[,,1],m[,,2],m[,,3]),
               nrow=dim(m)[1])
rmat[mask == "#FFFFFF"] <- "#FFFFFF" grid.newpage()
pushViewport(plotViewport(),
             viewport(xscale=c(0, 10), yscale=c(0, 10)))

grid.raster(rmat,x=unit(0,"native"),y=unit(0,"native"),
            width=1,height=1,just=c(0,0))
grid.roundrect()  ## frame
grid.xaxis(at=seq(2,8,by=2))  ## axes -- shorter to avoid going beyond end of frame
grid.yaxis(at=seq(2,8,by=2))
shadow.points(x=rnorm(10,mean=5),y=rnorm(10,mean=5),pch=20,
            gp=gpar(col="cyan"))
-------------------------------------------------------------------------------------------------------
pupilplot <- function (wf, cp = NULL, col = topo.colors(256), addContours = FALSE, 
cscale = TRUE, ...) 
 {
     if (cscale) {
         mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar
        on.exit(par(par.orig))
        w <- (3 + mar.orig[2]) * par("csi") * 2.54
        layout(matrix(c(2, 1), ncol = 2), widths = c(1, lcm(w)))
        par(las = 1)
        mar <- mar.orig
        mar[4] <- mar[2]
        mar[2] <- 1
        par(mar = mar) 
    thelist <- list(...)  
    findz <- which(names(thelist) == 'zlim')  
    if (length(findz) > 0 ) {   
        zlim <- thelist$zlim  
        }else{  
                zlim <- range(wf, finite = TRUE) #the original line  
        } 
 # end of my hack  
        levels <- seq(zlim[1], zlim[2], length = length(col))
        plot.new()
        plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i", yaxs = "i")
        rect(0, levels[-length(levels)], 1, levels[-1], col = col,  density = NA)
        axis(4)
         box()
        mar <- mar.orig
        mar[4] <- 0
        par(mar = mar)
    }
    if (is.null(cp)) {
        axis1 <- 1:nrow(wf)
        axis2 <- 1:ncol(wf)
    }
    else {
         axis1 <- ((1:nrow(wf)) - cp$xc)/cp$rx
        axis2 <- ((1:ncol(wf)) - cp$yc)/cp$ry
    }
    image(axis1, axis2, wf, col = col, asp = 1, xlab = "X", ylab = "Y",  ...)
     if (addContours) 
        contour(axis1, axis2, wf, add = TRUE)
}
-------------------------------------------------------------------------------------------------------
lattice library(lattice)

 # First make some example data
 df <- data.frame(name=rep(c("a", "b", "c"), each=5), value=rnorm(15))

 # Then try plotting it in both 'orientations'
 # ... as a dotplot
 xyplot(value~name, data=df)
 xyplot(name~value, data=df)

 # ... or perhaps as a 'box-and-whisker' plot
 bwplot(value~name, data=df)
 bwplot(name~value, data=df) base graphics plot(x=df$value, y=df$name, yaxt="n",
     xlab="value", ylab="name")
axis(2, at=1:3, labels=levels(df$name), las=1)
-------------------------------------------------------------------------------------------------------
plot(x, y*10, type = 'l', ylim = range(c(y*10,y1)), yaxt = 'n', col = 'red')
axis(2, (1:6)*10, 1:6, col = 'red')
lines(x1, y1, col = 'blue')
axis(4, (1:6)*10, col = 'blue')
grid(nx = NA, ny = NULL)
-------------------------------------------------------------------------------------------------------
names(tapply(values,index,mean))
[1] "5" "6" "7" "8"

xnames <- names(tapply(values,index,mean)) plot(tapply(values,index,mean),xaxt="n")
axis(1, at=1:length(xnames), labels=xnames)
-------------------------------------------------------------------------------------------------------
zoo lattice library(zoo)
library(lattice)

dat <- 'Date  Time  North  South   West   East  Seast  System
2008-09-12 01:00:00 1919.9 3721.4 2085.9 2565.5 2571.1 12863.8
2008-09-12 02:00:00 1827.0 3518.1 1965.3 2396.9 2410.7 12118.0
2008-09-12 03:00:00 1755.4 3388.4 1866.8 2338.7 2335.2 11684.5
2008-09-12 04:00:00 1733.5 3327.1 1810.0 2295.6 2290.2 11456.4
2008-09-12 05:00:00 1742.7 3327.3 1831.4 2314.2 2302.3 11517.9
2008-09-12 06:00:00 1912.2 3504.4 1986.7 2515.0 2502.6 12420.9'

z <- read.zoo(text = dat,  header = TRUE,  index.column = 1:2, tz = "")
xyplot(z)

zAgg <- aggregate(z$North,  by = as.yearmon,  FUN = mean)

dat2 <- 'Date        x
2008-09 2192.066
2008-10 1885.074
2008-11 1675.373
2008-12 1637.231
2009-01 1752.693
2009-02 1743.393'

zAgg <- read.zoo(text = dat2, header = TRUE,  FUN = as.yearmon)

plot(zAgg, xaxt = "n")

tt <- time(zAgg)
m <- format(tt, "%m")
axis(side = 1, at = tt, labels = ifelse(m == "01", trunc(tt), m), cex.axis = .7)
-------------------------------------------------------------------------------------------------------
as.expression( sapply(1:7, function(x) bquote(italic(X[.(x)]))) )
#-----------
# expression(italic(X[1L]), italic(X[2L]), italic(X[3L]), italic(X[4L]), 
#    italic(X[5L]), italic(X[6L]), italic(X[7L]))

identical(vexpr, as.expression( sapply(1:7, function(x) bquote(italic(X[.(x)]))) ) )
#[1] TRUE parse(text= paste("italic(X[", 1:7, "])", sep="") )  # fewer keystrokes
#--------
# expression(italic(X[1]), italic(X[2]), italic(X[3]), italic(X[4]), 
#    italic(X[5]), italic(X[6]), italic(X[7])) plot(1:7, xaxt="n"); axis(1,at=1:7, labels=...)
-------------------------------------------------------------------------------------------------------
North_Monthly_Avg=aggregate(North,by=list(format(DateTime,'%Y-%m')),mean)
names(North_Monthly_Avg)=c('Month','North')
North_Monthly_Avg$day=15
North_Monthly_Avg$Date=paste(North_Monthly_Avg$Month,North_Monthly_Avg$day,sep='-')
North_Monthly_Avg$Date=strptime(North_Monthly_Avg$Date,'%Y-%m-%d')
plot(m$Date,m$North,xaxt='n') # the xaxt='n' removes any ticks on the x axis
axis(1,as.numeric(m$Date),labels=format(m$Date,'%Y-%m')) # formats the x axis to your liking $day sep paste '-0'
-------------------------------------------------------------------------------------------------------
barplot barplot x = c(1:81)
b <- barplot(x)
## axis(side=1,at=c(0,20,40,60,80),labels=c(20,40,60,80,100))
head(b) b <- barplot(x)
axis(side=1,at=b[c(20,40,60,80)],labels=seq(20,80,by=20)) b <- barplot(x,xlim=c(0,120))
bdiff <- diff(b)[1]
axis(side=1,at=c(b[1]-bdiff,b[c(20,40,60,80)],b[81]+19*bdiff),
              labels=seq(0,100,by=20)) plot(x,type="h",lwd=4,col="gray",xlim=c(0,100)) ggplot library(ggplot2)
d <- data.frame(x=1:81)
ggplot(d,aes(x=x,y=x))+geom_bar(stat="identity",fill="lightblue",
                   colour="gray")+xlim(c(0,100))
-------------------------------------------------------------------------------------------------------
x = c(1:81)
bp <- barplot(x)
axis(side=1,at=bp[1+c(0,20,40,60,80)],labels=c(20,40,60,80,100))
-------------------------------------------------------------------------------------------------------
pars PerformanceAnalytics chart.Boxplot attach(cw)
par(mfrow=c(1,3))
boxplot(weight~Time, horizontal = F, main = "", xlab="Time", ylab="Weight", 
        pars = list(boxcol = "white", medlty = "blank", medpch=16, medcex = 1.3, 
        whisklty = c(1, 1), staplelty = "blank", outcex = 0.5), axes = FALSE)
axis(1,at=1:4,label=c(1:4))
axis(2)
boxplot(weight~Chick, horizontal = F, main = "", xlab = "Chick", 
        ylab = "", pars = list(boxcol = "white", medlty = "blank", medpch=16, 
        medcex = 1.3, whisklty = c(1, 1), staplelty = "blank", outcex = 0.5), 
        axes = FALSE)
axis(1,at=1:3,label=c("A","B","C"))
boxplot(weight~Diet, horizontal = F, main = "", xlab = "Diet", ylab = "", 
        pars = list(boxcol = "white", medlty = "blank", medpch=16, medcex = 1.3, 
        whisklty = c(1, 1), staplelty = "blank", outcex = 0.5), axes = FALSE)
axis(1,at=1:4,label=c("LoFat","HiFat","LoProt","HiProt"))
-------------------------------------------------------------------------------------------------------
apples.d Sweave Rstudio Tinn-R Sweave() FILENAME-CHUNKLABEL.pdf eps eps=true .tex Rstudio Tinn-R xlim ylim test.frame<-data.frame(year=8:11, value= c(12050,15292,23907,33991)) axis() with(test.frame,plot(year,value,axes=FALSE))
axis(1)
axis(2,test.frame$value,las=1) with(test.frame,plot(year,value,axes=FALSE))
axis(1)
axis(2,seq(10000,35000,by=5000),las=1)
-------------------------------------------------------------------------------------------------------
sparklines grid viewpoint par x <- data.frame(V = rnorm(1000), W = rnorm(1000), X = rnorm(1000),
      Y = rnorm(1000), Z = rnorm(10))
 par(mfrow=c(5,1),mar=c(1,0,0,0),oma=c(4,5,4,4))
 plot(x$V,axes=F,ylab="",xlab="",main="",type="l");axis(2,cex.axis=0.7)
 plot(x$W,axes=F,ylab="",xlab="",main="",type="l");axis(2,cex.axis=0.7)
 plot(x$X,axes=F,ylab="",xlab="",main="",type="l");axis(2,cex.axis=0.7)
 plot(x$Y,axes=F,ylab="",xlab="",main="",type="l");axis(2,cex.axis=0.7)
 plot(x$Z,axes=F,ylab="",xlab="",main="",type="l");axis(2,cex.axis=0.7)
 axis(1,pos=c(-2))
-------------------------------------------------------------------------------------------------------
hist(x) myhist(x) myhist(mydata$V3, breaks=c(0,1,2,3,4,5,25), log="xy") myhist <- function(x, ..., breaks="Sturges",
                   main = paste("Histogram of", xname),
                   xlab = xname,
                   ylab = "Frequency") {
  xname = paste(deparse(substitute(x), 500), collapse="\n")
  h = hist(x, breaks=breaks, plot=FALSE)
  plot(h$breaks, c(NA,h$counts), type='S', main=main,
       xlab=xlab, ylab=ylab, axes=FALSE, ...)
  axis(1)
  axis(2)
  lines(h$breaks, c(h$counts,NA), type='s')
  lines(h$breaks, c(NA,h$counts), type='h')
  lines(h$breaks, c(h$counts,NA), type='h')
  lines(h$breaks, rep(0,length(h$breaks)), type='S')
  invisible(h)
}
-------------------------------------------------------------------------------------------------------
library(zoo) 
library(lattice) 

monthly_average <- aggregate(dat.xts$CLPTHV43_Avr.wind.speed.1.m.s..91., 
                              as.yearmon(index(dat.xts)), mean, na.rm=TRUE)


plot(monthly_average, pch = 20, ylim = c(0, 11), type = "o", 
    main = "Average Monthly Wind Speed", xlab = "Months",
    ylab = "Wind Speed(m/s)")
xlabel <- c("July 2010", "Aug 2010", "Sep 2010", "Oct 2010",
"Nov 2010","Dec 2010", "Jan 2011", "Feb 2011", "Mar 2011", 
"Apr 2011", "May 2011", "Jun 2011")
axis(side = 1, at = monthly_average[, 1], lab = xlabel)
-------------------------------------------------------------------------------------------------------
plot(1:12, xaxt = "n")
axis(1, 1:12, month.abb)
-------------------------------------------------------------------------------------------------------
xaxt="n" plot(1:12,1:12,
     pch=20,
     ylim=c(0,11), 
     type="o", xaxt="n",
     main="Average Monthly Wind Spped",
     xlab="Months",
     ylab="Wind Speed(m/s)")

axis(side = 1, at=1:12, lab=c("July 2010", "Aug 2010", "Sep 2010"), las=3)
-------------------------------------------------------------------------------------------------------
test.frame<-data.frame(ratio= c(0.0, 144.321, 159.407, 178.413, 202.557), 
                       value= c(0, 0.84, 0.8925, 0.945, 0.9975))
with(test.frame,plot(ratio, value, ylab= "Hello", xlab="Wonderful", type="o",
                     bty="o", lty="solid", lwd=3, pch=1, xaxp=c(0, 200, 4),  
                     xlim=c(0,200), yaxt = "n", main=" My curve") )
axis(2,seq(0,1, by=0.5), las=2,cex=3,cex.lab=2,cex.axis=1.5,cex.main=2) > with(test.frame, (value[2]-value[1])/(ratio[2]-ratio[1]) )
[1] 0.005820359 > with(test.frame, lm(value ~ ratio - 1 ) )
Coefficients:
   ratio  
0.005325 > with(test.frame, lm(value ~ sqrt(ratio) - 1 ) )
Coefficients:
sqrt(ratio)  
    0.07037 y = 0.07 sqrt(x)
-------------------------------------------------------------------------------------------------------
box(lwd=3) par(mgp=c(3,1.5,0) )  # second element is number of lines below the box for the labels # use par() to increase left margins par( mgp=c(4,1.5,0) ) # First element in mgp vector ..., xaxs="i", yaxs="i", ... # can be done in `par` or in the plot call postscript('doudou.eps',
               width=7, height=6,
               colormodel="cmyk",
               family = "ComputerModern",
               horizontal = FALSE,
               onefile=FALSE,
               paper = "special",
               encoding = "TeXtext.enc",
               pagecentre=FALSE)
par( mgp=c(4,1.5,0), mai=c(1.5, 1.5, 1.5, .75) )  # using inches as the spacing unit
with(test.frame, plot(ratio, value, ylab= "Hello", 
                            xaxs="i", yaxs="i",
                                   xlab="Wonderful",
                                   type="o",        # line and markers
                                   bty="o",         # box around graph
                                   lty="solid",     # solid line or put 1
                                   lwd=3,            # line width
                                   pch=1,            # or enclose symbol in quotes
                                   cex=3,             # size of markers
                                   cex.lab=2,        # label size
                                   cex.axis=3,    # axis annot size problem if big
                                   cex.main=2,          # main title size
                                   xaxp=c(0, 200, 4),  #c(x1, x2, n)
                                   col=2,              # plotting color
                                   xlim=c(0,200),
                                   yaxt = "n",         #suppresses axis
                                   main=" My curve"))

axis(2,seq(0,1, by=0.5), las=2,cex=3,cex.lab=2,cex.axis=1.4, cex.main=2)
box(lwd=3)
dev.off()
-------------------------------------------------------------------------------------------------------
#random data corresponding to your 5 columns    
 x <- data.frame(V = rnorm(100), W = rnorm(100), X = rnorm(100), Y = rnorm(100), 
     Z = rnorm(100))
 #remove axis with 'axes=F', define wider x-limits with 'xlim' 
 stripchart(x[1:5,],vertical=TRUE, pch=19,xlim=c(1,6),axes=F)
 #add boxplots next to stripchart, decrease width with 'boxwex'
 boxplot(x[1:5,],add=T,at=1.5:5.5,boxwex=0.25,axes=F)
 #add custom x axis
 axis(1,at=1.25:5.25,labels=names(x))
-------------------------------------------------------------------------------------------------------
?axis at labels plot(1:10,1:10)
axis(side=4, at=c(3,7), labels=c(30,70))
-------------------------------------------------------------------------------------------------------
line axis() mtext() # Plot and first axis:
plot(1:10,1:10,bty="n",col="red",pch=16,axes=FALSE,xlab="",ylab="")
axis(2,0:11,las=1)
axis(1,0:11,line=1,col="red",col.ticks="red",col.axis="red")
mtext("Label 1",1,line=1,at=0.2,col="red")

# Secondary points and axis:
points(rnorm(10,50,20)/10, rnorm(10,5,2),pch=16, col="blue" )
axis(1,0:11,labels=0:11*10,line=3,col="blue",col.ticks="blue",col.axis="blue")
mtext("Label 2",1,line=3,at=0.2,col="blue")
-------------------------------------------------------------------------------------------------------
panel.first plot.default hist ?plot.default hist(WindSpeed, breaks=c(0:31), freq=TRUE, col="blue", xaxt="n", yaxt="n", 
     xlab="Wind Speed (m/s)", main="Foo", 
     cex.main=1.5, cex.axis=1, cex.lab=1, tck=1, font.lab=2,
     panel.first={
        axis(1, tck=1, col.ticks="light gray")
        axis(1, tck=-0.015, col.ticks="black")
        axis(2, tck=1, col.ticks="light gray", lwd.ticks="1")
        axis(2, tck=-0.015)
        minor.tick(nx=5, ny=2, tick.ratio=0.5)
        box()
 })
-------------------------------------------------------------------------------------------------------
?axis dat <- sample(100, 1000, replace=TRUE)
hist(dat, xaxt='n')
axis(side=1, at=seq(0,100, 10), labels=seq(0,1000,100))
-------------------------------------------------------------------------------------------------------
par()$cex x <- 1:5
y1 <- rnorm(5)
y2 <- rnorm(5,20)

par(mfrow = c(3, 3), mar=c(5,4,4,5)+.1)
plot(x,y1,type="l",col="red")
par(new=TRUE)
plot(x, y2,,type="l",col="blue",xaxt="n",yaxt="n",xlab="",ylab="")
axis(4)
mtext("y2",side=4,line=3, cex=par()$cex)
-------------------------------------------------------------------------------------------------------
DF <- data.frame(times = c("08:09:23.079", "08:30:13.062"), values = 1:2) library(zoo)
library(chron)

# this assumes we want to store times to the second
tt <- times(as.character(DF$times))
z <- zoo(DF$values, tt)

plot(z, xaxt = "n")

# custom axis - assumes sufficiently many points to get reasonable graph
# round tick mark locations to the minute and remove the seconds from label
axt <- trunc(times(axTicks(1)), "min")
axis(1, at = axt, lab = sub(":..$", "", axt)) # with this z we will be store times to the minute
z <- read.zoo(DF, FUN = function(x) trunc(times(as.character(x)), "min"), 
      aggregate = mean)
-------------------------------------------------------------------------------------------------------
# Some data
x <- 1:1000
y <- rnorm(1000)
z <- 1:1000

# colorRamp produces custom palettes, but needs values between 0 and 1
colorFunction <- colorRamp(c("darkblue", "black", "red"))
zScaled <- (z - min(z)) / (max(z) - min(z))

# Apply colorRamp and switch to hexadecimal representation
zMatrix <- colorFunction(zScaled)
zColors <- rgb(zMatrix, maxColorValue=255)

# Let's plot
plot(x=x, y=y, col=zColors, pch="+") layout # Resolution of the legend
n <- 10

# colorRampPalette produces colors in the same way than colorRamp
plot(x=NA, y=NA, xlim=c(0,n), ylim=0:1, xaxt="n", yaxt="n", xlab="z", ylab="")
pal <- colorRampPalette(c("darkblue", "black", "red"))(n)
rect(xleft=0:(n-1), xright=1:n, ybottom=0, ytop=1, col=pal)

# Custom axis ticks (consider pretty() for an automated generation)
lab <- c(1, 500, 1000)
at <- (lab - min(z)) / (max(z) - min(z)) * n
axis(side=1, at=at, labels=lab)
-------------------------------------------------------------------------------------------------------
filled.contour scatter.fill <- function (x, y, z, 
                              nlevels = 20, plot.title, plot.axes, 
                              key.title, key.axes, asp = NA, xaxs = "i", 
                              yaxs = "i", las = 1, 
                              axes = TRUE, frame.plot = axes, ...) 
    {
        mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar
        on.exit(par(par.orig))
        w <- (3 + mar.orig[2L]) * par("csi") * 2.54
        layout(matrix(c(2, 1), ncol = 2L), widths = c(1, lcm(w)))
        par(las = las)
        mar <- mar.orig
        mar[4L] <- mar[2L]
        mar[2L] <- 1
        par(mar = mar)

        #Some simplified level/color picking
        levels <- seq(min(z),max(z),length.out = nlevels)
  col <- colorRampPalette(c("blue","red"))(nlevels)[rank(z)]

        plot.new()
        plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i", 
            yaxs = "i")
  rect(0, levels[-length(levels)], 1, levels[-1L], col = colorRampPalette(c("blue","red"))(nlevels)
        if (missing(key.axes)) {
            if (axes) 
                axis(4)
        }
        else key.axes
        box()
        if (!missing(key.title)) 
            key.title
        mar <- mar.orig
        mar[4L] <- 1
        par(mar = mar)

        #Simplified scatter plot construction
        plot(x,y,type = "n")
        points(x,y,col = col,...)

        if (missing(plot.axes)) {
            if (axes) {
                title(main = "", xlab = "", ylab = "")
                Axis(x, side = 1)
                Axis(y, side = 2)
            }
        }
        else plot.axes
        if (frame.plot) 
            box()
        if (missing(plot.title)) 
            title(...)
        else plot.title
        invisible()
    } x <- runif(40)
y <- runif(40)
z <- runif(40)
scatter.fill(x,y,z,nlevels = 40,pch = 20) filled.contour
-------------------------------------------------------------------------------------------------------
> length(Y)
[1] 30
> length(2:25)
[1] 24 plot(1, 1, xlim=c(108,172), axes=FALSE, type='n', ylim=c(1,30),
    xlab="Average number of syllables per 100 words", 
    ylab="Average number of sentences per 100 words", 
    main="Fry Graph for Estimating Reading Ages (grade level)",
    xaxs = 'i', yaxs = 'i')

axis(1, at = 108:172, labels = TRUE)
axis(2, at = 1:30,  labels=Y, las=2)
grid(nx=64, ny=46, lty="solid", col="gold")
grid(nx=32, ny=23, lty="solid", col="gray65")
box()
-------------------------------------------------------------------------------------------------------
rect d <- as.matrix(read.table("http://dl.dropbox.com/u/2505196/postH.dat"))
#remove upper half of the values (as they are mirrored values)
d[upper.tri(d)] <- NA
dat <- within(as.data.frame(as.table(d)),{
Var1 <- as.numeric(Var1)
Var2 <- as.numeric(Var2)})
par(mar=c(6,3,3,6))
colPh=c("gray50","gray90","black")
plot(dat$Var1,dat$Var2,bg = colPh[1+findInterval(dat$Freq, c(-5.45,5.45))],
    col="white",cex=1.2,pch = 21,axes=F,xlab="",ylab="")
labDis <- rep(c("A","B","C","D","E"),times=7)
labChar <- c(1:7)
axis(1,at=1:35,labels=labDis,cex.axis=0.5,tick=F,line=-1.4)
axis(1,at=seq(3,33,5),labels=labChar, tick=F)
#drawing lines above axis for better identification
rect(1,0,5,0,angle=90);rect(6,0,10,0,angle=90);rect(11,0,15,0,angle=90);
rect(16,0,20,0,angle=90);rect(21,0,25,0,angle=90);rect(26,0,30,0,angle=90);
rect(31,0,35,0,angle=90)
axis(4,at=1:35,labels=labDis,cex.axis=0.5,tick=F,line=-1.4)
axis(4,at=seq(3,33,5),labels=labChar,tick=F)
#drawing lines above axis for better identification
rect(36,1,36,5,angle=90);rect(36,6,36,10,angle=90);rect(36,11,36,15,angle=90);
rect(36,16,36,20,angle=90);rect(36,21,36,25,angle=90);rect(36,26,36,30,angle=90);
rect(36,31,36,35,angle=90)
legend("topleft",legend=c("not significant","p<0.01","p<0.05"),pch=16,
col=c("gray90","gray50","black"),cex=0.7,bty="n")
-------------------------------------------------------------------------------------------------------
?plot.default ?plot xaxt xaxt = 'n' axis ?axis plot(x-vector, y-vector, xaxt = 'n')
axis(1, x-vector, label-x-vector) plot.default axis par
-------------------------------------------------------------------------------------------------------
cex.axis labs <-c("0\n9.3%","1\n7.6%","2\n5.6%","3\n5.1%","4\n5.7%","5\n6.5%","6\n7.3%",
         "7\n7.6%","8\n7.5%","9\n7%", "10\n6.2%","11\n5.2%","12\n4.2%",12:27)
plot(1:27,xaxt = "n")
axis(side=1, at=1:27, labels=labs[0:27],cex.axis=0.35)
-------------------------------------------------------------------------------------------------------
require(plyr)

data(iris)

pcr <- prcomp(~ Sepal.Length + Sepal.Width + Petal.Length + Petal.Width, data = iris)

indiv <- data.frame(pcr$x[,1:2])

indiv$species <- iris$Species

column <- data.frame(pcr$rotation[ ,1:2])

n <- nrow(indiv)

eigenval <- pcr$sdev[1:2]

eigenval <- eigenval * sqrt(n)

indiv <- transform(indiv, pc1 = PC1 / eigenval[1], pc2  = PC2 / eigenval[2])

column <- transform(column, pc1 = PC1 * eigenval[1], pc2  = PC2 * eigenval[2])

### based on stats:::biplot.default

unsigned.range <- function(x) c(-abs(min(x, na.rm = TRUE)),  abs(max(x, na.rm = TRUE)))

rangx1 <- unsigned.range(indiv[, 4])
rangx2 <- unsigned.range(indiv[, 5])
rangy1 <- unsigned.range(column[, 3])
rangy2 <- unsigned.range(column[, 4])

mylim <- range(rangx1, rangx2)
ratio <- max(rangy1/rangx1, rangy2/rangx2)

nspecies <- table(iris$Species)

# compute the convex hull for each species
hull <- dlply(indiv[,1:3], .(species), chull)

# get points connected
hull <- llply(hull, function(x) c(x, x[1]))


plot(pc2 ~ pc1, data = indiv, cex = 0.5, col = c("blue", "yellow", "green")[iris$Species], xlim = mylim, ylim = mylim)

lines(indiv$pc1[hull$setosa], indiv$pc2[hull$setosa] , col = "blue")

lines(indiv$pc1[cumsum(nspecies)[1] + hull$versicolor], indiv$pc2[cumsum(nspecies)[1] + hull$versicolor], col = "yellow")

lines(indiv$pc1[cumsum(nspecies)[2] + hull$virginica],  indiv$pc2[cumsum(nspecies)[2] + hull$virginica], col = "green")

par(new = TRUE)

plot(pc1 ~ pc2, data = column, axes = FALSE, type = "n", xlim = mylim * ratio, ylim = mylim * ratio, xlab = "", ylab = "")

text(column$pc1, column$pc2, labels = rownames(column), cex = 0.5, col = "red")

arrows(0, 0, column$pc1 * 0.8, column$pc2 * 0.8, col = "red", length = 0.2)

axis(3, col = "red")

axis(4, col = "red")
-------------------------------------------------------------------------------------------------------
-age plot(-age~size, type="n",yaxt="n", xlab="", ylab="Age")
lines(-age~size)
segments(0, -age, size, -age)
axis(2, labels=c(0,5,10,15,20), at=-c(0,5,10,15,20), las=1) ylab="" text
-------------------------------------------------------------------------------------------------------
rect() usr plot(1:10, 1:10, type = "n", axes = FALSE) ## no axes
lim <- par("usr")
rect(2, lim[3]-1, 4, lim[4]+1, border = "red", col = "red")
axis(1) ## add axes back
axis(2)
box()   ## and the plot frame rect() X <- c(1,3)
Y <- c(2,4)
plot(1:10, 1:10, type = "n", axes = FALSE) ## no axes
lim <- par("usr")
rect(X[1], Y[1], X[2], Y[2], border = "red", col = "red")
axis(1) ## add axes back
axis(2)
box()   ## and the plot frame botleft <- c(1,2)
topright <- c(3,4)
plot(1:10, 1:10, type = "n", axes = FALSE) ## no axes
lim <- par("usr")
rect(botleft[1], botleft[2], topright[1], topright[2], border = "red",
     col = "red")
axis(1) ## add axes back
axis(2)
box()   ## and the plot frame
-------------------------------------------------------------------------------------------------------
barplot() at= axis() xLabLocs <- barplot(test, space=0.4, xaxt='n', ann=FALSE)
axis(1, cex.axis=0.25, las=2, at=xLabLocs, space=0.4, labels=colnames(test))
 Value ?barplot Value:
     A numeric vector (or matrix, when ‘beside = TRUE’), say ‘mp’,
     giving the coordinates of _all_ the bar midpoints drawn, useful
     for adding to the graph. barplot()
-------------------------------------------------------------------------------------------------------
barp plotrix barp barplot(...,beside=TRUE) barplot(...,beside=FALSE) rect % mybarplot( x, col=heat.colors(255), space=0.2, labels=NULL )
% makes a stacked bar plot with ncol(x) bars, each containing nrow(x)
%  stacks. Coloured according to a *global* colour scale (by value of top edge
%  of the box within the stack). This is as opposed to the same colour 
%  per category across all bars.
%
% PARAMETERS
% ----------
% x     : a matrix. COLUMNS are the categories, ROWS contain the data.
% col   : colour scheme to use. e.g. heat.colors, rainbow, ...
% space : space between bars as a fraction of bar width.
% labels: labels for each category (column) of x, default colnames(x)
%
% EXAMPLE
% -------
% bar plot with 3 categories/bars, 4 stacks in each bar.
% data <- matrix(runif(12),ncol=3,nrow=4)
% colnames(data)<-c('group a','group b','group c')
% mybarplot(data,col=heat.colors(20))
%
mybarplot <- function( x, col=heat.colors(255), space=0.2, labels=colnames(x) )
{
 maxy <- max(x)
 miny <- 0
 n    <- ncol(x)
 m    <- nrow(x)
 wid  <- 1

 # work out boundaries of each rectangle
 # note: sort the y's ascending to draw properly.
 xsort  <- apply(x,2,sort)
 xright <- rep(1:n, m) * (wid+space) - space
 ybottom <- as.vector(t(rbind(miny,xsort)))

 # work out colour of each rectangle,
 # being (y/maxy) along the colour scale.
 fracs<-as.vector(t(xsort))/maxy
 cols <- col[round(fracs*(length(col)-1))+1]

 # plot: set up grid and then draw rectangles
 plot(0, 0, type="n", 
      ylim=c(miny,maxy), xlim=c(0,max(xright)),
      xaxt='n',yaxt='n',xlab=NA,ylab=NA)
 rect(xright-wid, ybottom[1:(length(ybottom)-n)], xright, ybottom[-(1:n)],
      col=cols)

 # draw labels
 axis(1, cex.axis=0.5, las=2, at=xright[1:n]-(space+wid)/2, labels=labels)
 axis(2, cex.axis=0.5, pos=-0.5)
} mybarplot(test) fracs axis xright[1:n]-(space+wid)/2 mybarplot xLabLocs <- mybarplot(test) axis
-------------------------------------------------------------------------------------------------------
grid.xaxis(seq(0,1,by=0.1), vp=viewport(y=1), 
           edits = gEdit(gPath="labels", rot=90))
-------------------------------------------------------------------------------------------------------
library(grid)
library(ggplot2)

## convert the labels to some parameter to be used in the custom grob
## here simply an index that will be interpreted as color
mapping <- function(x, ...){
  seq_along(x)
}

library(grImport)

hourglass <- new("Picture",
paths= list(new("PictureFill",
x=c(0, 1, 0, 1),
y=c(0, 0, 1, 1))),
summary= new("PictureSummary",
numPaths=1,
xscale=c(0, 1),
yscale=c(0, 1)))

## bare bones edit of theme_text()
my_axis <- function () 
{
    structure(function(label, x = 0.5, y = 0.5, default.units = "npc", ...) {
      cols <- mapping(label)

      symbolsGrob(hourglass, x, 0*x + unit(0.5, "npc"),
                  use.gc=FALSE,size=unit(5,"mm"), gp=gpar(fill=cols))

    }, class = "theme", type = "custom", call = match.call())
}

qplot(1:12, rnorm(12)) +
  opts( axis.text.x = my_axis(), axis.ticks.margin = unit(0.5, "cm"))
-------------------------------------------------------------------------------------------------------
axis y <-rnorm(20)^2 * 1000000 /1000000
x <-11:30

plot(x,y, yaxt="n")
my.axis <-paste(axTicks(2),"MM",sep="")
axis(2,at=axTicks(2), labels=my.axis) axis(2,at=axTicks(2), labels=my.axis, las=1)
-------------------------------------------------------------------------------------------------------
scipen ?options las ?par x <- rnorm(20)^2 * 10000000
layout(matrix(1:2, ncol = 2))
plot(x)
getOption("scipen")
opt <- options("scipen" = 20)
getOption("scipen")
plot(x)
options(opt)
layout(1) plot(x / 10000000, axes = FALSE)
axis(1)
pts <- pretty(x / 10000000)
axis(2, at = pts, labels = paste(pts, "MM", sep = ""))
box() pretty() plot() axis() box() opt <- options("scipen" = 20)
op <- par(mar = c(5,7,4,2) + 0.1) ## extra margin to accommodate tick labs
x <- rnorm(20)^2 * 10000000
plot(x, las = 1, ylab = "")       ## no y-axis label 
title(ylab = "label", line = 5.5) ## need to plot the axis label
par(op)
options(opt) las plot() las = 1 axis() op <- par(mar = c(5,5,4,2) + 0.1)
plot(x / 10000000, axes = FALSE, ylab = "")
axis(1)
pts <- pretty(x / 10000000)
axis(2, at = pts, labels = paste(pts, "MM", sep = ""), las = 1)
title(ylab = "my label", line = 4)
box()
par(op)
-------------------------------------------------------------------------------------------------------
axes=FALSE axis.Date # Sample data
library(quantmod)
getSymbols( "^DJI" )
x <- DJI

# Plot without the date axis
matplot( 
  index(x), coredata(Ad(x)), 
  axes=FALSE, 
  xlab="", ylab="",
  type="l", lwd=3
)
axis(2, las=1)

# Some date arithmetics
all_days <- seq.Date( from=min(index(x)), to=max(index(x)), by=1 )
months  <- all_days[ format(all_days, "%d") == "01" ]
january <- all_days[ format(all_days, "%m-%d") == "01-01" ]
april   <- all_days[ format(all_days, "%m-%d") == "04-01" ]
july    <- all_days[ format(all_days, "%m-%d") == "07-01" ]
october <- all_days[ format(all_days, "%m-%d") == "10-01" ]

# Finally plot the axes
axis.Date(1, at=months,  label=FALSE, tcl=-.3) 
axis.Date(1, at=january, label=format(january, "%Y"))
axis.Date(1, at=april,   label=format(april,   "%b"))
axis.Date(1, at=july,    label=format(july,    "%b"))
axis.Date(1, at=october, label=format(october, "%b"))
-------------------------------------------------------------------------------------------------------
# convert ps to RGML
PostScriptTrace(file.path(system.file(package = "grImport"), "doc", "GNU.ps"), "GNU.xml")
PostScriptTrace(file.path(system.file(package = "grImport"), "doc", "tiger.ps"), "tiger.xml")
# read xml
pics <- list(a = readPicture("GNU.xml"), b = readPicture("tiger.xml"))

# custom function for x axis label.
my_axis <- function () {
  structure(
      function(label, x = 0.5, y = 0.5, ...) {
         absoluteGrob(
           do.call("gList", mapply(symbolsGrob, pics[label], x, y, SIMPLIFY = FALSE)),
           height = unit(1.5, "cm"))
    }
)}

qplot(factor(c("a", "b")), 1:2) + opts( axis.text.x = my_axis())
-------------------------------------------------------------------------------------------------------
barplot(as.matrix(taskC), horiz=TRUE, col=rainbow(7), xaxt="n")
axis(1, labels=labels, at=cumsum(taskC)-(taskC/2))
-------------------------------------------------------------------------------------------------------
ind <- function(x) {
  # Divide each column by the first non-NA value
  # (There may already be a function to do that.)
  coredata(x) <- t(t(coredata(x)) / apply(coredata(x),2,function(u){ c(u[!is.na(u)&u!=0],NA)[1] }))
  x
}
x <- cbind( Ad(GSPC), Ad(VIX) )
x <- x["2011-11::"]

# Using base graphics
matplot( 
  index(x), coredata(ind(x)), 
  xlab="", ylab="", main="",
  type="l", lty=1, lwd=3, axes=FALSE 
)
abline(h=1, lty=3, col="lightgrey")
axis(2, las=1)
axis.Date(1, index(x))
box()
legend( "topleft", gsub("\\..*", "", names(x)), lty=1, lwd=3, col=1:2 )

# If you prefer ggplot2
library(ggplot2)
library(reshape2)
d <- data.frame( date = index(x), coredata(ind(x)) )
names(d) <- gsub("\\..*", "", names(d))
d <- melt(d, id.vars="date")
ggplot(d, aes(date, value, color=variable)) + geom_line(size=2)
-------------------------------------------------------------------------------------------------------
help(axis) R> ind <- seq(1, length(b), by=4) R> plot(b,xaxt="n")
R> axis(1,time(b)[ind], format(time(b)[ind]), las=2, cex.axis=0.5) las=2 cex
-------------------------------------------------------------------------------------------------------
abline png("strangeplot.png",width=800)
#extend y-axis to fit inside labels and remove box
plot(b,type="n",xaxt="n",yaxt="n",ylab="",xlab="",ylim=c(min(b)-30,max(b)),bty="n"))
#use 'mpg' to get labels inside
axis(1,time(b)[ind], format(time(b)[ind]), las=2, cex.axis=0.6,tick=F,mgp=c(0,-2.5,0))
axis(2,tick=F,las=1)
#you locate lines slightly to the left of label...
abline(h=seq(0,200,by=50),v=time(b)[ind]-0.5,col=gray(0.9))
#...so you need to add extra single line in the end 
abline(v=max(time(b)[ind])+0.5,col=gray(0.9))
#plot at the end to get it above grid
points(b,type="l")
dev.off()
-------------------------------------------------------------------------------------------------------
x <- rnorm(100)
par(mfrow = c(1, 2))
hist(x, freq = FALSE, axes = FALSE)
axis(2, at = seq(0, 0.4, 0.1), labels = paste(0:4, "%", sep = ""))
hist(x, freq = FALSE)
-------------------------------------------------------------------------------------------------------
hist axis h <- hist(rnorm(100))
plot(h, freq=FALSE, yaxt="n")
axis(2, pretty(h$density), sprintf("%0.0f%%", pretty(h$density)*100)) hist(rnorm(100, s=0.1))
-------------------------------------------------------------------------------------------------------
is.OHLC plot plot.xts2 <- function (x, y = NULL, type = "l", auto.grid = TRUE, major.ticks = "auto", 
    minor.ticks = TRUE, major.format = TRUE, bar.col = "grey", 
    candle.col = "white", ann = TRUE, axes = TRUE, col = "black", ...) 
{
    series.title <- deparse(substitute(x))
    ep <- axTicksByTime(x, major.ticks, format = major.format)
    otype <- type
    if (xts:::is.OHLC(x) && type %in% c("candles", "bars")) {
        x <- x[, xts:::has.OHLC(x, TRUE)]
        xycoords <- list(x = .index(x), y = seq(min(x), max(x), 
                length.out = NROW(x)))
        type <- "n"
    }
    else {
        if (NCOL(x) > 1) 
            warning("only the univariate series will be plotted")
        if (is.null(y)) 
            xycoords <- xy.coords(.index(x), x[, 1])
    }
    plot(xycoords$x, xycoords$y, type = type, axes = FALSE, ann = FALSE, 
        col = col, ...)
    if (auto.grid) {
        abline(v = xycoords$x[ep], col = "grey", lty = 4)
        grid(NA, NULL)
    }
    if (xts:::is.OHLC(x) && otype == "candles") 
        plot.ohlc.candles(x, bar.col = bar.col, candle.col = candle.col, 
            ...)
    dots <- list(...)
    if (axes) {
        if (minor.ticks) 
            axis(1, at = xycoords$x, labels = FALSE, col = "#BBBBBB")
        axis(1, at = xycoords$x[ep], labels = names(ep), las = 1, lwd = 1, mgp = c(3, 2, 0), ...)
        axis(2, ...)
    }
    box()
    if (!"main" %in% names(dots)) 
        title(main = series.title)
    do.call("title", list(...))
    assign(".plot.xts", recordPlot(), .GlobalEnv)
}

plot.xts2(as.xts(sample_matrix[,1]), col = "blue")
-------------------------------------------------------------------------------------------------------
greens <- colorRampPalette(c("white","darkgreen"))
barplot(as.matrix(diff(Post)), horiz=T, col=greens(10)[10*color], axes=F, xlab="Mark")
axis(1, labels=Mark, at=Post)
axis(3, labels=Post, at=Post)
-------------------------------------------------------------------------------------------------------
x <- 1:20
y <- runif(20)
plot(x,y,xaxt = "n")
axis(side = 1, at = x, labels = FALSE, tck = -0.01)
-------------------------------------------------------------------------------------------------------
axes = TRUE degAxis() PlotOnStaticMap() axTicks() degAxis() degreeLabelsEW() degAxis() MyMap PlotOnStaticMap(MyMap, lat = datas$LAT, lon = datas$LON, 
                axes = FALSE, mar = rep(4.5, 4))

# x-axis
xrange <- MyMap$BBOX$ur[2] - MyMap$BBOX$ll[2]
xticklength <- xrange / (length(axTicks(1)) - 1)
xticklabs <- seq(MyMap$BBOX$ll[2], MyMap$BBOX$ur[2], xticklength)
xticklabs <- parse(text = paste(sprintf('%.2f', abs(xticklabs)), 
    ifelse(xticklabs < 0, '*degree*W', '*degree*E'), sep=''))
axis(1, at=axTicks(1), xticklabs, cex.axis=0.8)

# y-axis
yrange <- MyMap$BBOX$ur[1] - MyMap$BBOX$ll[1]
yticklength <- yrange / (length(axTicks(2)) - 1)
yticklabs <- seq(MyMap$BBOX$ll[1], MyMap$BBOX$ur[1], yticklength)
yticklabs <- parse(text = paste(sprintf('%.2f', abs(yticklabs)), 
    ifelse(yticklabs < 0, '*degree*S', '*degree*N'), sep=''))
axis(2, at=axTicks(2), yticklabs, cex.axis=0.8, las=1)
-------------------------------------------------------------------------------------------------------
plot(1:10)
par(new=T)
plot(1:10, rep(50, 10), type='l', axes=F, xlab=NA, ylab=NA)
axis(4)
-------------------------------------------------------------------------------------------------------
axis(1, 1:nc, labels = labCol, las = 2, line = -0.5, tick = 0, cex.axis = cexCol)
if (!is.null(xlab)) 
    mtext(xlab, side = 1, line = margins[1] - 1.25)
axis(4, iy, labels = labRow, las = 2, line = -0.5, tick = 0, cex.axis = cexRow)
if (!is.null(ylab)) 
    mtext(ylab, side = 4, line = margins[2] - 1.25)
-------------------------------------------------------------------------------------------------------
yearmon dput(theMonths)
structure(c(2011.16666666667, 2011.25, 2011.33333333333, 2011.41666666667, 
2011.5, 2011.58333333333, 2011.66666666667, 2011.75, 2011.83333333333, 
2011.91666666667, 2012, 2012.08333333333), class = "yearmon") as.numeric [1] 2011.167 2011.250 2011.333 2011.417 2011.500 2011.583 2011.667 2011.750 2011.833
[10] 2011.917 2012.000 2012.083 axis at labels at axis(1,theMonths,theMonths)
-------------------------------------------------------------------------------------------------------
x<-1:20
y1<-sqrt(x)
y2<-sqrt(x)*x
plot(x,y1,ylim=c(0,25),col="blue")
par(new=TRUE)
plot(x,y2,ylim=c(0,100),col="red",axes=FALSE)
axis(4) axes=FALSE
-------------------------------------------------------------------------------------------------------
rect zoo zoo library(zoo)
#random data combined with time series that starts in 2009-01
v <- zooreg(rnorm(37), start = as.yearmon("2009-1"), freq=12)
plot(v, type = "n",xlab="",xaxt="n")
#this will catch some min and max values for y-axis points in rect
u <- par("usr")
#plot green rect - notice that x-coordinates are defined by date points
rect(as.yearmon("2009-6-30"), u[3], as.yearmon("2010-7-1"), u[4], 
        border = 0, col = "lightgreen")
lines(v)
axis(1, floor(time(v)))
#customized x-axis labels based on dates values
axis(1,at=c(2009.4, 2010.5),padj=-2,lty=0,labels=c("start","end"),cex.axis=0.8)
-------------------------------------------------------------------------------------------------------
myhist <- hist(x,prob=FALSE,col="gray",xlim=c(0,100))
    dens <- density(x)
    axis(side=1, at=seq(0,100, 20), labels=seq(0,100,20))
    lines(dens$x,dens$y*(1/sum(myhist$density))*length(x)) 1/sum(myhist$density) density(x)$x sum(density(x)$y) sum(density(x)$y)/(1/diff(density(x)$x)[1]) hist() length(x) xlim xlim ylim type = "n"
-------------------------------------------------------------------------------------------------------
my.colors = colorRampPalette(c("light green", "yellow", "orange", "red"))
z=matrix(1:100,nrow=1)
x=1
y=seq(3,2345,len=100) # supposing 3 and 2345 are the range of your data
image(x,y,z,col=my.colors(100),axes=FALSE,xlab="",ylab="")
axis(2)
-------------------------------------------------------------------------------------------------------
# Function to plot color bar
color.bar <- function(lut, min, max=-min, nticks=11, ticks=seq(min, max, len=nticks), title='') {
    scale = (length(lut)-1)/(max-min)

    dev.new(width=1.75, height=5)
    plot(c(0,10), c(min,max), type='n', bty='n', xaxt='n', xlab='', yaxt='n', ylab='', main=title)
    axis(2, ticks, las=1)
    for (i in 1:(length(lut)-1)) {
     y = (i-1)/scale + min
     rect(0,y,10,y+1/scale, col=lut[i], border=NA)
    }
} > color.bar(colorRampPalette(c("light green", "yellow", "orange", "red"))(100), -1)
-------------------------------------------------------------------------------------------------------
par(mar = c(10,4,4,2) + 0.1)
plot(1:3,1:3,axes = FALSE,xlab = "")
axis(1,1:3,labels = FALSE)
mtext(c('2000','2001','2002'),side = 1,line = 1,at = 1:3,col = "red")
mtext(c('2010','2011','2012'),side = 1,line = 2,at = 1:3,col = "blue")
mtext(c('2000','2001','2002'),side = 1,line = 3,at = 1:3,col = "red")
mtext(c('2010','2011','2012'),side = 1,line = 4,at = 1:3,col = "blue")
axis(2) mar mtext axis labels c("2000\n2010\n2020","2001\n2011\n2021","2002\n2012\n2022") padj
-------------------------------------------------------------------------------------------------------
plot points axis axis ?axis ?plot ?points # make a data frame similar to yours
mydf <- data.frame( Name=LETTERS, 
        Up=sample.int(15,size=26,replace=T), 
        Down=-sample.int(15,size=26,replace=T) ) # set up a plot: x axis goes from 1 to 26,
# y limit goes from -15 to 15 (picked manually, you can work yours out
#   programmatically)
# Disable plotting of axes (axes=FALSE)
# Put in some x and y labels and a plot title (see ?plot...)
plot(0,xlim=c(1,26),ylim=c(-15,15),type='n',
     axes=FALSE,                 # don't draw axis -- we'll put it in later.
     xlab='Name',ylab='Change',  # x and y labels
     main='Ups and Downs')       #,frame.plot=T -- try if you like. ?plot.default
# Plot the 'Up' column in green (see ?points)
points(Up~Name,mydf,col='green')
# Plot the 'Down' column in red
points(Down~Name,mydf,col='red')
# ***Draw the x axis, with labels being A-Z 
#  (type in 'LETTERS' to the prompt to see what they are)
# see also ?axis
axis(1,at=1:26,labels=LETTERS)
# Draw the y axis
axis(2) ?points ?par ?axis
-------------------------------------------------------------------------------------------------------
dat <- read.csv2(text="start;duration
 1;4
 7;3
 15;2
 ")
 plot(NA, xlim=c(0,20), ylim=c(0,9), ylab="",xlab="X", xaxt="n", yaxt="n")
 with(dat, segments(x0=start, x1=start+duration, y0=2,y1=2))
 with(dat, text( start+duration/2, 2.5, labels=duration))
 axis(1, at=seq(0,20,by=2), labels=seq(0,20,by=2))
-------------------------------------------------------------------------------------------------------
fields:::image.plot par("fg" = NA)
    plot(r, xlim = c(xmin(r), xmax(r)), ylim = c(ymin(r), ymax(r)), axes = FALSE)
    par(new = TRUE,"fg" = "black")
    plot(r, xlim = c(xmin(r), xmax(r)), ylim = c(ymin(r), ymax(r)), axes = FALSE, legend.only = TRUE)
    axis(1, pos = -90, xpd = TRUE)
    rect(-180,-90,180,90,xpd = TRUE)
    ticks <- (ymin(r):ymax(r))[(ymin(r):ymax(r)) %% 20 == 0]
    segments(xmin(r),ticks,xmin(r)-5,ticks, xpd = TRUE)
    text(xmin(r),ticks,ticks,xpd=TRUE,pos=2)
        title("sorry, this could probably be done in some more elegant way")
-------------------------------------------------------------------------------------------------------
par(new=TRUE) ## Set up data
line.x <- 2:10
bar.x <- 2:10
bar.y <- seq(3,7,by=0.5)+rnorm(9)
bar.x <- 1:15
bar.x <- 2:10
line.x <- 1:15
line.y <- rev(60:74)+rnorm(15)
x.range <- range(bar.x, line.x)

## Plot the data
par(mar=c(5,4,4,4)+0.1)    ## Make enough room for both labels
plot(y=bar.y, x=bar.x, type='h', lwd=25, lend=4, xlim=x.range, xlab="Sequence", ylab="", main="Plot with two ordinates - points and lines")
par(new=TRUE)
plot(y=line.y, x=line.x, col='red', type='l', xlim=x.range, axes=FALSE, xlab='', ylab='')

## Set up the axes and labels
axis(side=4, col='red', labels=FALSE)
at = axTicks(4)
mtext(side = 4, text = at, at = at, col = "red", line = 1) 
## Add x-axis labels; this allows customization of the how far out labels are
mtext(text='Descending values', side=4, line=2, col='red')
mtext(text='Ascending values', side=2, line=2)
-------------------------------------------------------------------------------------------------------
plot(pos, type = 'n', xlim = range(c(start, end)), ylim = c(13,0))
grid()
segments(start, pos, end, pos) r <- par('usr') 
plot(pos, type = 'n', xlim = range(c(start, end)), ylim = c(13.5,0.5), xlab = '', 
    xaxt = 'n', yaxt = 'n', panel.first = rect(r[1], r[3], r[2], r[4], col = 'goldenrod'))
# abline(h = 1:13, col = 'white')
# abline(v = 1:13, col = 'white')
grid(lty = 1, col = 'white')
axis(1, 1:13, 1:13, cex.axis = 0.8)
axis(2, 1:13, 1:13, las = 1, cex.axis = 0.8)
segments(start, pos + 0.5, end, pos + 0.5, lwd = 2)
-------------------------------------------------------------------------------------------------------
dev.new() pdf xlims<-c(1,24)
ylims<-c(-2,2)

pdf(file='test1march.pdf', width=3.33,height=4)
plot(NULL,NULL,xlim=xlims,ylim=ylims,axes=FALSE, ann=FALSE)     
axis(1, at=c(0,4,8,12,16,20,24),cex.axis=0.7,mgp=c(3, .3, 0))
axis(2, las=1,cex.axis=0.7,at=c(-2,-1,0,1,2), mgp=c(3, .7, 0))
mtext(side = 1, text =expression('Hour'), line = 1,font=15)
mtext(side = 2, text = expression(paste('NEE ', m^-2,s^-1)), line = 1.5,font=15)
abline(0, 2/24)  # should give a diagonal line
box()
dev.off()
-------------------------------------------------------------------------------------------------------
y y2 # do first plot. Don't draw axis (we'll do it later)
plot(y~x,data=t,axes=F,ylab='y')
# draw y axis (see ?axis, 1=bottom, 2=left, 3=top, 4=right)
axis(2,pretty(range(t$y)))

# tell R to draw over the first plot
par(new=T)

# do second plot. 
plot(y2~x,data=t,axes=F,ylab="")
# draw second axis on the right
axis(4,pretty(range(t$y2)),ylab='y2')

# draw x axis on the bottom
axis(1,pretty(range(t$x)))

# draw the box if you want
box() axis(2,pretty(range(t$y))) pretty par(new=T) y2 x y2 y2 x y2 y par(mar=c(top,left,bottom,right)) ?par c(5,4,4,2)+.1 # get the current margins (top, left, bottom, right)
m <- par('mar')
# make sure the right margin is the same as the left.
m[4]<-m[2]
# set the new margins
par(mar=m)

# .... perform plotting as above. mtext mtext('y2',4,line=2) 'y2' line=2 # margin
m <- par('mar')
m[4] <- m[2]
par(mar=m)

# plotting
plot(y~x,data=t,axes=F,ylab='y')
axis(2,pretty(range(t$y)))
par(new=T)
plot(y2~x,data=t,axes=F,ylab="")
axis(4,pretty(range(t$y2)),ylab='y2')
axis(1,pretty(range(t$x)))
box()

# right-hand ylabel
mtext('y2',4,line=2)
-------------------------------------------------------------------------------------------------------
fig # Sample data
n <- 100
k <- 6
d <- matrix(rnorm(k*n),nc=k)
d[,2] <- d[,1]  # To help check the results
colnames(d) <- LETTERS[1:k]
x <- apply(d,2,cumsum)
r <- hclust(dist(t(d)))
# Plot
op <- par(mar=c(0,0,0,0),oma=c(0,2,0,0))
plot(NA,ylim=c(.5,k+.5), xlim=c(0,4),axes=FALSE)
# Dendrogram. See ?hclust for details.
xc <- yc <- rep(NA,k)
o <- 1:k
o[r$order] <- 1:k
for(i in 1:(k-1)) {
  a <- r$merge[i,1]
  x1 <- if( a<0 ) o[-a] else xc[a]
  y1 <- if( a<0 ) 0 else yc[a]
  b <- r$merge[i,2]
  x2 <- if( b<0 ) o[-b] else xc[b]
  y2 <- if( b<0 ) 0 else yc[b]
  lines( 
    3+c(y1,i,i,y2)/k,
    c(x1,x1,x2,x2),
    lwd=k-i
  )
  xc[i] <- (x1+x2)/2
  yc[i] <- i
}
# Time series
axis(2,1:k,colnames(d)[r$order],las=1)
u <- par()$usr
for(i in 1:k) {
  f <- c(0,3,i-.5,i+.5)
  f <- c( 
    (f[1]-u[1])/(u[2]-u[1]), 
    (f[2]-u[1])/(u[2]-u[1]), 
    (f[3]-u[3])/(u[4]-u[3]), 
    (f[4]-u[3])/(u[4]-u[3])
  )
  par(new=TRUE,fig=f)
  plot(x[,r$order[i]],axes=FALSE,xlab="",ylab="",main="",type="l",col="navy",lwd=2)
  box()
}
par(op) layout
-------------------------------------------------------------------------------------------------------
graphics var.a var.b test <- data.frame(group = 1:10, var.a = rnorm(n = 10, mean = 500, sd = 20),
  var.b = runif(10))

funProp <- function(testCol) {
    test[, testCol]/max(test[, testCol])
}

test$var.a.prop <- funProp("var.a")
test$var.b.prop <- funProp("var.b") barplot() barplot(t(as.matrix(test[, c("var.a.prop", "var.b.prop")])), beside = TRUE,
  yaxt = "n", names.arg = test$group) labels at axis(2, at = seq(0, max(test$var.a.prop), length.out = 10),
  labels = round(seq(0, max(test$var.a), length.out = 10)))

axis(4, at = seq(0, max(test$var.b.prop), length.out = 10),
  labels = round(seq(0, max(test$var.b), length.out = 10), 2)) pretty myLeftAxisLabs <- pretty(seq(0, max(test$var.a), length.out = 10))
myRightAxisLabs <- pretty(seq(0, max(test$var.b), length.out = 10))

myLeftAxisAt <- myLeftAxisLabs/max(test$var.a)
myRightAxisAt <- myRightAxisLabs/max(test$var.b)

barplot(t(as.matrix(test[, c("var.a.prop", "var.b.prop")])),
  beside = TRUE, yaxt = "n", names.arg = test$group,
  ylim=c(0, max(c(myLeftAxisAt, myRightAxisAt))))

axis(2, at = myLeftAxisAt, labels = myLeftAxisLabs)

axis(4, at = myRightAxisAt, labels = myRightAxisLabs)
-------------------------------------------------------------------------------------------------------
axis(2, 1:5, myLabels) datf$pNum <- as.numeric(datf$person)
plot(datf$pNum, xlim = c(0, 53), type = 'n', yaxt = 'n', xlab ='Duration (words)', ylab = 'person', main = 'Speech Duration')
axis(2, 1:5, sort(unique(datf$person)), las = 2, cex.axis = 0.75)
with(datf, segments(start, pNum, end, pNum, lwd = 3, lend=2))
-------------------------------------------------------------------------------------------------------
plotGantt <- function(data, res.col='resources', 
                      start.col='start', end.col='end', res.colors=rainbow(30))
{
  #slightly enlarge Y axis margin to make space for labels
  op <- par('mar')
  par(mar = op + c(0,1.2,0,0)) 

  minval <- min(data[,start.col])
  maxval <- max(data[,end.col])

  res.colors <- rev(res.colors)
  resources <- sort(unique(data[,res.col]),decreasing=T)

  plot(c(minval,maxval),
       c(0.5,length(resources)+0.5),
       type='n', xlab='Duration',ylab=NA,yaxt='n' )
  axis(side=2,at=1:length(resources),labels=resources,las=1)
  for(i in 1:length(resources))
  {
    yTop <- i+0.1
    yBottom <- i-0.1
    subset <- data[data[,res.col] == resources[i],]
    for(r in 1:nrow(subset))
    {
      color <- res.colors[((i-1)%%length(res.colors))+1]
      start <- subset[r,start.col]
      end <- subset[r,end.col]
      rect(start,yBottom,end,yTop,col=color)
    }
  }
  par(op) # reset the plotting margins
} data <- read.table(text=
'"person","n","start","end"
"sam",6,0,6
"greg",5,6,11
"teacher",4,11,15
"sam",4,15,19
"greg",5,19,24
"sally",5,24,29
"greg",4,29,33
"sam",3,33,36
"sally",5,36,41
"researcher",6,41,47
"greg",6,47,53',sep=',',header=T)

plotGantt(data, res.col='person',start.col='start',end.col='end',
          res.colors=c('green','blue','brown','red','yellow'))
-------------------------------------------------------------------------------------------------------
##Some dummy data
dd = data.frame(values = rnorm(40), type=LETTERS[1:4])

##Don't plot the axes labels
##but add in the "plot frame"
boxplot(dd$values ~ dd$type, axes=FALSE, 
                  frame.plot=TRUE, ylim=c(-4, 4))

##Now add in the y-axis
axis(2, seq(-4,4,by=2))
##Add in the x-axis at points: 1.5 and 3.5
axis(1, c(1.5,3.5), c("Med", "Mad"))
-------------------------------------------------------------------------------------------------------
mtext out <- barplot(vals,axes = FALSE)
axis(2)
mtext(1:4,side = 1,at = out,cex = 0.5) barplot
-------------------------------------------------------------------------------------------------------
as.data.frame(cbind(.)) > data1
   subject post pre
1      S01  100  45
10     S10  100  40
9      S09  110  35
4      S04  120  75
3      S03   75  80
2      S02   80  60
5      S05   85  45
6      S06   90  60
8      S08   90  50
7      S07   95  55 data1 = data.frame(subject=subject, post=post, pre=pre)
data1 = data1[order(data1$post),]; 
plot(data1$pre,type="p",ylim=range(data1$pre,data1$post), 
      xaxt="n", ylab="Pre/Post Scores: black=Pre, red=Post")
points(data1$post,col='red')
axis(1, at=1:10, labels=levels(data1$subject)[order(post)]) axis(1, at=1:10, labels=as.character(data1$subject))) # since the set was sorted by `post`
-------------------------------------------------------------------------------------------------------
las=2 plot() xaxt="" axis(1, at= ..., labels=...) text(x=midpts, y=-2, names(DD), cex=0.8, srt=45, xpd=TRUE)
-------------------------------------------------------------------------------------------------------
layout.widths=list(axis.panel=0) par.settings axs="i" x y scales ato<-rep(list(NULL),12); ato[[1]]<-ato[[9]]<-TRUE; ato[[8]] lmi<-rep(list(c(0,10),c(0,10),c(0,20)),4)
useOuterStrips(xyplot(B$yval~B$xval|B$p*B$grp,group=B$gval,
  type=c("l","g"),lwd=2,cex.lab=1.5,as.table=TRUE,
  par.settings=list(plot.symbol=list(pch="*",col="black",cex=1),
  box.umbrella=list(lty=1,col="black",lwd=2),cex=2,
  par.xlab.text=list(cex=1),axis.text=list(cex=1),
  par.ylab.text=list(cex=1),layout.widths=list(axis.panel=0,
  right.padding=3)),panel=mypanel,
  scales=list(y=list(relation="free",limits=lmi,at=ato,axs="i"),
  x=list(axs="i")))) trellis.focus("panel", 4, 2, clip.off=TRUE,highlight=FALSE)
panel.axis(side="right",at=pretty(lmi[[8]]),outside=TRUE) ?xyplot right.padding=3 par.settings left.padding
-------------------------------------------------------------------------------------------------------
lbls <- do.call("expression", lapply(-2:2, function(i) substitute(X * pi, list(X = i))))
plot(-10:10, -10:10, xaxt="n")
axis(1, at=seq(-2,2)*pi, labels=lbls)
-------------------------------------------------------------------------------------------------------
set.seed(231)
 tN <- table(Ni <- stats::rpois(100, lambda=5))
 tNshift <- tN-5
 barplot(tNshift, space = 1.5, yaxt="n", xaxt="n", ylim=range(tNshift))
 abline(0,0)
 axis(2, at= c(-5, pretty(tNshift)), labels=c(0, pretty(tNshift)+5), xpd=TRUE)
-------------------------------------------------------------------------------------------------------
years <- seq(1975,1989,2)
db <- data.frame(Dallas=c( 25, 28, 27, 29, 31, 33, 35, 37),
 Houston=c( 33, 38, 43, 48, 53, 58, 63, 68),
 Lubbock=c( 28, 29, 31, 33, 35, 37, 39, 41),
 Austin= c(22, 24, 26, 28, 30, 32, 34, 36),
 San_Antonio= c(31, 32, 33, 34, 35, 36, 37, 38)
)
db <- as.matrix(db)

#plot
layout(matrix(c(1,2), nrow=1, ncol=2), widths=c(4,1), heights=c(4))
layout.show(2)
par(mar=c(5,5,1,1))
image(x=years, z=db, yaxt="n")
axis(2, at=seq(0,1,,dim(db)[2]), labels=colnames(db))
#image.scale from http://menugget.blogspot.de/2011/08/adding-scale-to-image-plot.html
par(mar=c(5,0,1,5))
image.scale(db, horiz=FALSE, yaxt="n", xaxt="n", xlab="", ylab="")
axis(4)
mtext("temp", side=4, line=2)
box()
-------------------------------------------------------------------------------------------------------
setwd("your working directory")

name <- "example" # Change this if you want

x <- data.frame(sapply(lx, "[", seq(max(sapply(lx, length)))))
len <- ncol(x)
colnames(x)[colnames(x) %in% names(which.min(apply(x, 2, function(x) length(na.omit(x)))))] <- "main.x"
colnames(x)[colnames(x) %in% names(which.max(apply(x, 2, function(x) length(na.omit(x)))))] <- "h.x"
colnames(x)[!colnames(x) %in% c("h.x", "main.x")]  <- c(paste("l", seq(1,len-2),".x", sep = ""))

y <- data.frame(sapply(ly, "[", seq(max(sapply(ly, length)))))
len <- ncol(y)
colnames(y)[colnames(y) %in% names(which.min(apply(y, 2, function(y) length(na.omit(y)))))] <- "main.y"
colnames(y)[colnames(y) %in% names(which.max(apply(y, 2, function(y) length(na.omit(y)))))] <- "h.y"
colnames(y)[!colnames(y) %in% c("h.y", "main.y")]  <- c(paste("l", seq(1,len-2),".y", sep = ""))

tab <- cbind(x,y)

write.table(tab, paste(name, ".txt", sep = ""), sep = "\t", row.names = F) df <- structure(list(h.x = c(1145L, 1095L, 1052L, 1004L, 958L, 909L, 
865L, 820L, 777L, 730L, 680L, 638L, 587L, 546L, 496L, 452L, 407L, 
359L, 312L, 265L, 219L, 174L, 140L, 99L, 61L, 27L), l1.x = c(1081L, 
1060L, 1047L, 1017L, 966L, 854L, 679L, NA, NA, NA, NA, NA, NA, 
NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA), l2.x = c(906L, 
865L, 807L, 735L, 668L, 509L, 360L, NA, NA, NA, NA, NA, NA, NA, 
NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA), l3.x = c(436L, 
407L, 341L, 298L, 215L, 56L, NA, NA, NA, NA, NA, NA, NA, NA, 
NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA), l4.x = c(391L, 
345L, 285L, 228L, 179L, 136L, 4L, NA, NA, NA, NA, NA, NA, NA, 
NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA), main.x = c(1169L, 
3L, 0L, 0L, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 
NA, NA, NA, NA, NA, NA, NA, NA, NA), l5.x = c(1158L, 1165L, 1167L, 
1165L, 1137L, 1106L, 1025L, 927L, 737L, 625L, 330L, 151L, 5L, 
NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA), l6.x = c(721L, 
594L, 531L, 398L, 270L, 205L, 135L, NA, NA, NA, NA, NA, NA, NA, 
NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA), h.y = c(267L, 
267L, 267L, 262L, 259L, 244L, 233L, 221L, 209L, 201L, 192L, 183L, 
180L, 173L, 168L, 164L, 162L, 159L, 157L, 162L, 161L, 177L, 217L, 
259L, 292L, 326L), l1.y = c(305L, 283L, 274L, 255L, 240L, 199L, 
128L, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 
NA, NA, NA, NA, NA), l2.y = c(293L, 268L, 248L, 221L, 199L, 135L, 
94L, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 
NA, NA, NA, NA, NA), l3.y = c(284L, 262L, 224L, 207L, 180L, 146L, 
NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 
NA, NA, NA, NA), l4.y = c(304L, 281L, 260L, 241L, 234L, 225L, 
218L, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 
NA, NA, NA, NA, NA), main.y = c(307L, 304L, 0L, 0L, NA, NA, NA, 
NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 
NA, NA, NA), l5.y = c(296L, 279L, 260L, 254L, 237L, 226L, 215L, 
179L, 109L, 77L, 53L, 49L, 60L, NA, NA, NA, NA, NA, NA, NA, NA, 
NA, NA, NA, NA, NA), l6.y = c(285L, 236L, 215L, 168L, 119L, 107L, 
98L, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 
NA, NA, NA, NA, NA)), .Names = c("h.x", "l1.x", "l2.x", "l3.x", 
"l4.x", "main.x", "l5.x", "l6.x", "h.y", "l1.y", "l2.y", "l3.y", 
"l4.y", "main.y", "l5.y", "l6.y"), class = "data.frame", row.names = c(NA, 
-26L)) ## Measurement of holes in relation to subannual lines

# List of packages needed to run the script

library(plyr)
library(reshape)
library(spatstat)

# Define magnification!

magnification <- 1 # µm/px. I use 1 in this example, because this was taken from jpg, which breaks the relationship. It's wrong to use jpg images in this type of work.

# Open the file

#df <- read.delim("example.txt") Untick this, if you didn't copy the example data frame

df <- data.frame(sapply(df, function(x){replace(x, x == 0, NA)}))  # Replace 0's with NA's since they're some weird relics)

df <- df*(1/magnification) # Convert the unit from pixel to µm

range.x <- c(0, max(df[,grep("x", colnames(df))], na.rm = T))
range.y <- c(0, max(df[,grep("y", colnames(df))], na.rm = T))
x.lim <- c(round_any(min(df[,grep("x", colnames(df))], na.rm = T), 10, floor), round_any(max(df[,grep("x", colnames(df))], na.rm = T), 10, ceiling))
y.lim <- c(round_any(min(df[,grep("y", colnames(df))], na.rm = T), 10, floor), round_any(max(df[,grep("y", colnames(df))], na.rm = T), 10, ceiling))

# Holes

x <- df$h.x
y <- df$h.y

owin <- owin(range.x, range.y, unitname = list("µm", "µm"))
holes <- ppp(x, y, marks = as.factor(seq(1, length(x))), window = owin)

#Lines

x <- df[,grep("x", grep("l", colnames(df), value = T), value = T)]
y <- df[,grep("y", grep("l", colnames(df), value = T), value = T)]
nlines <- ncol(x)
lines <- paste("l", seq(1, nlines), sep = "")

for(j in 1:nlines){
xx <- x[,j][!is.na(x[,j])]
yy <- y[,j][!is.na(y[,j])]
assign(paste("l", j, sep = ""), psp(x0 = xx[1:(length(xx)-1)], x1 = xx[2:length(xx)], y0 = yy[1:(length(yy)-1)], y1 = yy[2:length(yy)], marks =  rep(paste("l", j, sep = ""), (length(xx)-1)), window = owin))
}

a <- l1
for(j in 2:nlines){
a <- superimpose(a, get(lines[j]))}
l.all <- a

# Main axis

x <- df[,grep("x", grep("main", colnames(df), value = T), value = T)]
x <- x[!is.na(x)]
y <- df[,grep("y", grep("main", colnames(df), value = T), value = T)]
y <- y[!is.na(y)]

main <- psp(x0 = x[1], x1 = x[2], y0 = y[1], y1 = y[2], marks = c("main"), window = owin)

start <- ppp(x[1], y[1], marks = c("start"), window = owin)
end <- ppp(x[2], y[2], marks = c("end"), window = owin)

# Calculate the distance of lines from the main axis


tmp <- endpoints.psp(get(lines[1]))
tmp <- superimpose(tmp[1], tmp[npoints(tmp)])
pnt <- tmp[apply(nncross(tmp, main)[1],2, function(x) which.min(x))]
marks(pnt) <- lines[1]

for(j in 2:nlines){
tmp <- endpoints.psp(get(lines[j]))
tmp <- superimpose(tmp[1], tmp[npoints(tmp)])
pnt2 <- tmp[apply(nncross(tmp, main)[1],2, function(x) which.min(x))]
marks(pnt2) <- lines[j]
pnt <- superimpose(pnt, pnt2)}

int <- project2segment(pnt, main)$Xproj

tmp <- t(crossdist(int, start)) 
colnames(tmp) <- int$marks

p.1st <- int[int$marks == apply(tmp, 1, function(x) names(which.min(x)))] # First line is and origo for the main axis is...
l.1st <- l.all[l.all$marks == apply(tmp, 1, function(x) names(which.min(x)))] # First line means actually the line when the clam died

dist.lines <- data.frame(line = int$marks, dist0 = crossdist(int, p.1st))
dist.lines <- dist.lines[order(dist.lines$dist0),]

# Calculate shortest distance from a hole to 1st subaanual line

d <- data.frame(hole = holes$marks)
for(j in 1:nlines){
temp <- nncross(holes, get(lines[j]))
colnames(temp) <- c(lines[j], "which")
d <- cbind(d, temp[1])}

tp <- d[!colnames(d) %in% colnames(d)[1]]

d <- cbind(d, close1 = apply(tp, 1, function(x) names(which.min(x))))
d <- cbind(d, c.dist = apply(tp, 1, function(x) (min(x))))

d <- d[!colnames(d) %in% lines]

# Calculate if holes are occuring after or before a subannual line

d$dist.1st <- nncross(holes, l.1st)[,1] # Calculate distance of holes from the last growth line (when the clam died). 

tmp <- c()
for(j in 1:npoints(holes)){
tmp <- append(tmp, nncross(project2segment(holes[j], l.all[l.all$marks == d$close1[j]])$Xproj, l.1st)[,1])
}

d$dist.cross <- tmp # Distance from 1st line (see above) to a closest point from a hole along the closest line
d$location <- as.factor(ifelse(d$dist.1st >= d$dist.cross, "aft", "bef")) # Before / after subannual line

dat <- d

# Calculate points where the hole axis crosses subannual lines. This is needed for defining in which gap the holes lay

x <- coords(holes)$x
y <- coords(holes)$y
hole.line <- psp(x0 = x[1:length(x)-1], x1 = x[-1], y0 = y[1:length(y)-1], y1 = y[-1], window = owin)
line.cross <- crossing.psp(hole.line, get(lines[1]))
marks(line.cross) <- lines[1]

for(j in 2:nlines){
tmp <- crossing.psp(hole.line, get(lines[j]))
marks(tmp) <- lines[j]
line.cross <- superimpose(line.cross, tmp)}

lp.closestto.h1 <- project2segment(holes[1], get(unique(l.1st$marks)))$Xproj # 1st point
marks(lp.closestto.h1) <- unique(l.1st$marks)
line.cross <- superimpose(line.cross, lp.closestto.h1)

last <- holes[holes$marks==npoints(holes)] # Last point 
p.last <- project2segment(last, l.all[l.all$marks==dist.lines$line[which.max(dist.lines[,"dist0"])]])$Xproj
marks(p.last) <- dist.lines$line[which.max(dist.lines[,"dist0"])]
line.cross <- superimpose(line.cross, p.last)

# Calculate distance between line crossing points

dist <- data.frame()
for(j in 1:(nlines-1)){
p1 <- line.cross[line.cross$marks == as.character(dist.lines$line)[j]]
p2 <- line.cross[line.cross$marks == as.character(dist.lines$line)[j+1]]
if(all(npoints(p1)!=0, npoints(p2)!=0)){
tmp <- nncross(p1,p2)
tmp$points <- paste(as.character(dist.lines$line)[j], as.character(dist.lines$line)[j+1], sep = "-")
dist <- rbind(dist, tmp)}} # Along the hole axis

dist <- dist[!colnames(dist) %in% "which"]
colnames(dist) <- c("dist.gap", "gap")

dist2 <- data.frame()
for(j in 1:(nlines-1)){
p1 <- int[int$marks == as.character(dist.lines$line)[j]]
p2 <- int[int$marks == as.character(dist.lines$line)[j+1]]
if(all(npoints(p1)!=0, npoints(p2)!=0)){
tmp <- nncross(p1,p2)
tmp$points <- paste(as.character(dist.lines$line)[j], as.character(dist.lines$line)[j+1], sep = "-")
dist2 <- rbind(dist2, tmp)}} # Along the main axis

dist2 <- dist2[!colnames(dist2) %in% "which"]
colnames(dist2) <- c("dist.main", "gap.main")

dist <- merge(dist, dist2, by.x = "gap", by.y = "gap.main", all = T, sort = F) 
tmp <- merge(data.frame(gap = dist$gap, line = unlist(lapply(strsplit(dist$gap, "-"), function(x) x[1]))), dist.lines, by = "line", all.x = T, sort = F)
dist <- merge(dist, tmp, by = "gap", all.x = T, sort = F)
dist <- dist[!colnames(dist) %in% "line"]

# Calculate the gap where a hole is located

tmp <- c()
for(j in 1:length(dat$close1)){
tmp <- append(tmp, ifelse(dat$location[j] == "aft", grep(paste("\\", as.character(dat$close1[j]), "\\-", sep = ""), dist$gap, value = T), grep(paste("\\-", as.character(dat$close1[j]), sep = ""), dist$gap, value = T)))}
tmp[is.na(tmp)] <- "after"

dat$gap <- tmp

dat <- merge(dat, dist, by = "gap", all.x = T, sort = F)
dat <- dat[order(dat$hole),]

# Shortest distance to the 2nd subannual line

scnd <- c()
for(j in 1:length(dat$gap)){
scnd <- append(scnd, gsub("-", "", gsub(as.character(dat$close1)[j], "", dat$gap[j])))}

dat$close2 <- scnd

tmp <- data.frame()
for(j in 1:npoints(holes)){
if(as.character(dat$close2[j]) != "after") {tmp1 <- cbind(hole = j, c2 = nncross(holes[j], get(as.character(dat$close2[j]))))}
if(as.character(dat$close2[j]) == "after") {tmp1 <- cbind(hole = j, c2 = nncross(holes[j], last))}
tmp <- rbind(tmp, tmp1)}

tmp <- tmp[!colnames(tmp) %in% "c2.which"]

dat <- merge(dat, tmp, by = "hole", all.x = T, sort = F)
dat <- dat[order(dat$hole),]

# Calculate the distance of holes from crossing points

d <- data.frame()
for(j in 1:npoints(holes)){
temp <- data.frame(hole = j, nncross(holes[holes$marks==dat$hole[j]], line.cross[line.cross$marks==dat$close1[j]]))
d <- rbind(d, temp[c(1:2)])}
colnames(d) <- c("hole", "c1.dist.cross")

d2 <- data.frame()
for(j in 1:npoints(holes)){
temp <- data.frame(hole = j, nncross(holes[holes$marks==dat$hole[j]], line.cross[line.cross$marks==dat$close2[j]]))
d2 <- rbind(d2, temp[c(1:2)])}
colnames(d2) <- c("hole", "c2.dist.cross")

d <- merge(d,d2, by = "hole", sort = F)
dat <- merge(dat, d, by = "hole", sort = F)

dat$dist.ratio.cross <- ifelse(dat$location == "aft", dat$c1.dist.cross/(dat$c1.dist.cross + dat$c2.dist.cross), dat$c2.dist.cross/(dat$c1.dist.cross + dat$c2.dist.cross))
dat$dist.ratio.closest <- ifelse(dat$location == "aft", dat$c.dist/(dat$c.dist + dat$c2.dist), dat$c2.dist/(dat$c.dist + dat$c2.dist))

dat$distance.paral <- ifelse(dat$gap=="after", dat$dist0 + dat$c.dist, dat$dist0 + dat$dist.main*dat$dist.ratio.cross)

print <- dat[c("hole", "distance.paral")]
print 

# Plot

plot(coords(holes)[,1], coords(holes)[,2], main = gsub(".txt", "", files[i]), cex = 3, asp = 1,
axes = F, xlab = "x (µm)", ylab = "y (µm)", xlim = x.lim, ylim = y.lim)
plot(line.cross, chars = 19, col = "blue", add = T)
text(coords(holes)[,1], coords(holes)[,2], seq(1, npoints(holes)))
plot(l.all, col = "red", add = T)
plot(main, add = T, col = "purple")
text(coords(int)[,1], coords(int)[,2], int$marks, col = "blue")
text(coords(start)[,1], coords(start)[,2], start$marks, col = "dark green", cex = 1.2)
text(coords(end)[,1], coords(end)[,2], end$marks, col = "dark green", cex = 1.2)
x.new <- (print[,2]/crossdist(p.1st,end))* coords(end)$x + (1-(print[,2]/crossdist(p.1st,end)))* coords(p.1st)$x
y.new <- (print[,2]/crossdist(p.1st,end))* coords(end)$y + (1-(print[,2]/crossdist(p.1st,end)))* coords(p.1st)$y
text(x.new, y.new, print[,1], adj=c(0,0), font = 2, col = "purple")
axis(1)
axis(2, las = 2)
-------------------------------------------------------------------------------------------------------
# Generate the data
date <- c("2011-11-15", "2011-11-16", "2011-11-17", "2011-11-19")
start <- c("12:01:27", "12:01:25", "12:01:02", "12:01:12")
end <- c("12:30:15", "12:32:15", "12:39:12", "12:30:18")

# Put everything in a data frame and convert to POSIXct objects
# The times will be all converted to today's date
# but this will not influence the plot
df <- data.frame(date = as.POSIXct(date),
                 start = as.POSIXct(start, format="%H:%M:%S"), 
                 end = as.POSIXct(end, format="%H:%M:%S"))

# Get the working range for the axes in order to make them nicer (see below)
x.from <- as.POSIXct(min(date))
x.to <- as.POSIXct(max(date))
y.from <- as.POSIXct(min(start), format="%H:%M:%S")
y.to <- as.POSIXct(max(end), format="%H:%M:%S")

# Create an empty plot, as rect will not create a new one
# We put no axes on the plot
plot(0, "n", xaxt="n", yaxt="n", ylab="", xlab="Day", 
     ylim=c(from, to), xlim=range(df$date))

# Now draw the rectangles (I made them 2 hours-wide)
rect(df$date-3600, df$start, df$date+3600, df$end, col="black")

days <- seq(x.from, x.to, 24*3600)
times <- seq(y.from, y.to, 300) # 5 min (=300 s) axis ticks
# Finally add the axes
axis(1, at=days, labels=strftime(days, "%d/%m"))
axis(2, at=times, labels=strftime(times, "%H:%M"), las=1)
-------------------------------------------------------------------------------------------------------
plot (bp,yv, pch = "*", col = rep(colrs,each=2000)) ?palette palette() plot (bp,yv, pch = "*", col = rep(colrs,each=2000),xaxt="n")
axis(1,at=seq(1000,58000,3000),labels=1:20) cex.axis las=2 plot (bp,yv, pch = "*", col = rep(colrs,each=2000),xaxt="n")
axis(1,at=seq(1000,58000,3000),labels=1:20,cex.axis=0.7,las=2)
-------------------------------------------------------------------------------------------------------
plot(x.fore,axes = FALSE)
axis(2)
axis(1,at = pretty(1:72,n = 6),
       labels = (x$Date[1]-1) + pretty(1:72,n = 6),
       cex.axis = 0.65)
-------------------------------------------------------------------------------------------------------
x$Date = as.Date(x$Date,format="%m/%d/%Y")
x = xts(x=x$Used, order.by=x$Date)
# To get the start date (305)
#     > as.POSIXlt(x = "2011-11-01", origin="2011-11-01")$yday
##    [1] 304
# Add one since that starts at "0"
x.ts = ts(x, freq=365, start=c(2011, 305))
plot(forecast(ets(x.ts), 10)) 2011.85 365*.85 as.POSIXlt(x = "2011-11-01", origin="2011-11-01")$yday as.Date(310, origin="2011-01-01") x = ts(x$Used, start=c(2011, as.POSIXlt("2011-11-01")$yday+1), frequency=365)
# NOTE: We have only selected the "Used" variable 
# since ts will take care of dates
plot(forecast(ets(x), 10)) # 'start' calculation = `as.Date("2011-11-01")-as.Date("2011-01-01")+1`
# No need to convert anything to dates at this point using xts
x = ts(x$Used, start=c(2011, 305), frequency=365)
# Directly plot your forecast without your axes
plot(forecast(ets(x), 10), axes = FALSE)
# Generate labels for your x-axis
a = seq(as.Date("2011-11-01"), by="weeks", length=11)
# Plot your axes.
# `at` is an approximation--there's probably a better way to do this, 
# but the logic is approximately 365.25 days in a year, and an origin
# date in R of `January 1, 1970`
axis(1, at = as.numeric(a)/365.25+1970, labels = a, cex.axis=0.6)
axis(2, cex.axis=0.6) xts ts forecast Point x.fore > forecast(ets(x), 10)
         Point Forecast    Lo 80    Hi 80    Lo 95    Hi 95
2012.000       741.6437 681.7991 801.4884 650.1192 833.1682
2012.003       741.6437 676.1250 807.1624 641.4415 841.8459
2012.005       741.6437 670.9047 812.3828 633.4577 849.8298
2012.008       741.6437 666.0439 817.2435 626.0238 857.2637
2012.011       741.6437 661.4774 821.8101 619.0398 864.2476
2012.014       741.6437 657.1573 826.1302 612.4328 870.8547
2012.016       741.6437 653.0476 830.2399 606.1476 877.1399
2012.019       741.6437 649.1202 834.1672 600.1413 883.1462
2012.022       741.6437 645.3530 837.9345 594.3797 888.9078
2012.025       741.6437 641.7276 841.5599 588.8352 894.4523 lubridate require(lubridate)
y = ts(x$Used, start=c(2011, yday("2011-11-01")), frequency=365)
plot(forecast(ets(y), 10), xaxt="n")
a = seq(as.Date("2011-11-01"), by="weeks", length=11)
axis(1, at = decimal_date(a), labels = format(a, "%Y %b %d"), cex.axis=0.6)
abline(v = decimal_date(a), col='grey', lwd=0.5) ts
-------------------------------------------------------------------------------------------------------
minor.ticks.axis <- function(ax,n,t.ratio=0.5,mn,mx,...){

  lims <- par("usr")
  if(ax %in%c(1,3)) lims <- lims[1:2] else lims[3:4]

  major.ticks <- pretty(lims,n=5)
  if(missing(mn)) mn <- min(major.ticks)
  if(missing(mx)) mx <- max(major.ticks)

  major.ticks <- major.ticks[major.ticks >= mn & major.ticks <= mx]

  labels <- sapply(major.ticks,function(i)
    as.expression(bquote(10^ .(i)))
                   )
  axis(ax,at=major.ticks,labels=labels,...)

  n <- n+2
  minors <- log10(pretty(10^major.ticks[1:2],n))-major.ticks[1]
  minors <- minors[-c(1,n)]

  minor.ticks = c(outer(minors,major.ticks,`+`))
  minor.ticks <- minor.ticks[minor.ticks > mn & minor.ticks < mx]


  axis(ax,at=minor.ticks,tcl=par("tcl")*t.ratio,labels=FALSE)

} x <- 1:8
y <- 10^(sort(runif(8, 1, 10), decreasing = TRUE)) plot(x, log10(y), # function to plot
xlab="",          # suppress x labels
type = 'l',       # specify line graph
xlim = c(min(x), (max(x)*1.3)),  # extend axis limits to give space for text annotation
ylim = c(0, max(log10(y))),      # ditto
axes = FALSE)    # suppress both axes minor.ticks.axis(2, 9, mn=0, mx=10, las=1) axis(3) mtext("x", side = 3, line = 2) text(max(x), min(log10(y)), "Example", pos = 1)
-------------------------------------------------------------------------------------------------------
plot(1:10, ylab = "", xlab="")
at1 <- seq(1, 10, 0.1)
axis(side =1, at1, labels = F) plot(1:10, xlab = "", ylab = "", yaxt='n')
at1 <- seq(1, 10, 0.1)
axis(side =1, at1, labels = F)
-------------------------------------------------------------------------------------------------------
?image dat <- data.matrix(data.frame(Germany = c(0,1,0), Italy = c(1,0,0)))
rownames(dat) <- c("Rain","Hail","Sunny") image(z = dat, col = c("white","red")) op <- par(mar = c(5,5,4,2) + 0.1)
image(z = dat, col = c("white","red"), axes = FALSE)
axis(side = 1, labels = rownames(dat), 
     at = seq(0, by = 0.5, length.out = nrow(dat)))
axis(side = 2, labels = colnames(dat), at = c(0,1), las = 1)
box()
par(op) dat image(z = t(dat), ....) axis() side 2 1 las = 1 op <- par(mar = c(5,5,4,2) + 0.1)
image(z = t(dat2), col = c("white","red"), axes = FALSE)
axis(side = 2, labels = rownames(dat2), 
     at = seq(0, by = 0.5, length.out = nrow(dat2)), las = 1)
axis(side = 1, labels = colnames(dat2), at = c(0,1))
box()
par(op)
-------------------------------------------------------------------------------------------------------
colbarplot <- function(group) {

    myd1 <- myd[myd$group == group,]
    filld1 <- filld[filld$group1 == group,]
    blues <- colorRampPalette(c("yellow", "blue"))
    barplot(as.matrix(diff(myd1$avar)), horiz=T,
            col=blues(10)[10* filld1$fillcol], 
            axes=F, xlab="Mark")
    axis(1, labels=myd$label, at=myd$avar)
    axis(3, labels=myd$avar, at=myd$avar)
}

par(mfrow = c(3, 1))
par(mar = c(2.5, 1, 2.5, 1))
sapply(unique(myd$group),function(x) colbarplot(x))
-------------------------------------------------------------------------------------------------------
opar <- par(mfrow = c(length(unique(myd$group)), 1), mar = c(2.5, 1, 2.5, 1))

for (i in 1:length(unique(myd$group))){
    myd1 <- myd[myd$group ==i,]
    filld1 <- filld[filld$group1 ==i,]
    blues <- colorRampPalette(c("yellow", "blue"))
    barplot(as.matrix(diff(myd1$avar)), horiz=T, 
       col=blues(10)[10* filld1$fillcol], axes=F, xlab="Mark")
    axis(1, labels=myd1$label, at=myd1$avar)
    axis(3, labels=myd1$avar, at=myd1$avar)
 }

 par(opar);
-------------------------------------------------------------------------------------------------------
plot(c(0,13),c(1,12),type = "n",axes = FALSE,xlab = "Position",ylab = "")
segments(x0 = dat$start,
         y0 = dat$pos,
         x1 = dat$end,
         y1 = dat$pos,
         col = "blue",
         lwd = 6,
         lend = 2)
text(x = dat$start - 0.5,y = dat$pos,labels = dat$pos,font = 2)
axis(1)
axis(1,at = c(0,12),labels = FALSE,tcl = 0.5) axis
-------------------------------------------------------------------------------------------------------
axis(1,at=seq(2,60,3),labels=1:20,cex.axis=0.7) groups <- 20
numbox <- 3
total <- groups * numbox
xpoints <- seq(median(1:numbox),total,numbox)
-------------------------------------------------------------------------------------------------------
rgeos gIsValid library(rgeos)
p4 = readWKT("POLYGON ((0 40, 0 0, 40 40, 40 0, 0 40))")
gIsValid(p4, reason = TRUE)
[1] "Self-intersection[20 20]" reason gIsValid(p4)
[1] FALSE
Warning message:
In RGEOSUnaryPredFunc(spgeom, byid, "rgeos_isvalid") :
  Self-intersection at or near point 20 20 plot(p4, col = "grey")
points(20, 20, pch = 3, cex = 3, col = "red")
axis(1);axis(2);box() byid library(maptools)
xx <- readShapePoly(system.file("shapes/sids.shp", package="maptools")[1],
  IDvar="FIPSNO", proj4string=CRS("+proj=longlat +ellps=clrk66"))
gIsValid(xx, byid = TRUE)
37001 37003 37005 37007 37009 37011 
 TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
...
-------------------------------------------------------------------------------------------------------
plot(x,y, type="l", lwd=2, xlim = c(-3.5,3.5)) plot(x,y, type="l", lwd=2, axes = FALSE, xlab = "", ylab = "")
axis(1, at = -3:3, labels = c("-3s", "-2s", "-1s", "mean", "1s", "2s", "3s"))
-------------------------------------------------------------------------------------------------------
x curve() dnorm curve(dnorm, -3.5, 3.5, lwd=2, axes = FALSE, xlab = "", ylab = "")
axis(1, at = -3:3, labels = c("-3s", "-2s", "-1s", "mean", "1s", "2s", "3s")) <- = x <- seq(-4, 4, length=200)
y <- dnorm(x, mean=0, sd=1)
plot(x, y, type="l", lwd=2)
-------------------------------------------------------------------------------------------------------
x<-1:10
y<-1:10
plot(x,y)
abline(a=1,b=0,v=1)

changed to:

x<-1:10
y<-1:10
plot(x,y,xlim=c(-30,30))
abline(a=1,b=0,v=1) text text((0), min(y), "number", pos=2) abline(a=1,b=0,v=1)
axis(1, at=1,labels=1) plot(x,y,xlim=c(-30,30),yaxt="n")
axis(2, at=c(1.77,5,10,15,20,25)) par(mar = c(6.5, 6.5, 6.5, 6.5))
plot(x,y,xlim=c(-30,30))
abline(a=1,b=0,v=1)
axis(2, at=1.77,labels=1.77,mgp = c(10, 2, 0))
-------------------------------------------------------------------------------------------------------
par("mar")
par(mar = c(par("mar")[1:3], 5.1))

plot(x,y, type="n", lwd=4, ylab="", xlab="threshold", xaxt="n",yaxt="n")

axis(1,lwd=4)
axis(2,lwd=4)

points(x, y, col="red", cex=2, pch=19)
abline(h=w, col="red", lwd=4)

par("usr")
par(usr = c(par("usr")[1:2], 80,90))

axis(4, lwd=4)
points(x, z, col="blue", cex=2, pch=19)
points(x, z, type="l", lwd=4)
abline(h=v, col="blue", lwd=4)

mtext("Your text", side = 4, col = "blue",line=3)
mtext("seconds", side = 2, col = "red",line=3)
-------------------------------------------------------------------------------------------------------
plot(rnorm(99), bty="n", axes=FALSE, xlab="", ylab="")
box(col="dodgerblue")
axis(1, col="dodgerblue", col.ticks="green", col.axis="orange", cex.axis=2)
axis(2, col="dodgerblue", col.ticks="green", col.axis="orange", cex.axis=0.8)
mtext("Index", side=1, line=3, col="red", cex=2)
mtext("Value", side=2, line=3, col="purple", cex=0.8)
-------------------------------------------------------------------------------------------------------
matplotlib scipy numpy numpy import scipy as sci
import numpy as np
import pylab as plt

# Create some data
N = 1000
X = np.random.normal(5,1,size=N)
Y = X + np.random.normal(0,5.5,size=N)/np.random.normal(5,.1)
NAMES = ["foo"]*1000 # Customize names here

# Fit a polynomial
(a,b)=sci.polyfit(X,Y,1)

# Find all points above the line
idx = (X*a + b) < Y

# Scatter according to that index
plt.scatter(X[idx],Y[idx], color='r')
plt.scatter(X[~idx],Y[~idx], color='g')

# Find top 10 outliers
err = ((X*a+b) - Y) ** 2
idx_L = np.argsort(err)[-10:]
for i in idx_L:
    plt.text(X[i], Y[i], NAMES[i])

# Color the outliers purple or black
top = idx_L[idx[idx_L]]
bot = idx_L[~idx[idx_L]]

plt.scatter(X[top],Y[top], color='purple')
plt.scatter(X[bot],Y[bot], color='black')

XF = np.linspace(0,10,1000)
plt.plot(XF, XF*a + b, 'k--') 
plt.axis('tight')
plt.show()
-------------------------------------------------------------------------------------------------------
parse(text='70^o*N') o *N labelsX=parse(text=paste(abs(seq(-100, -50, 10)), "^o ", "*W", sep=""))
labelsY=parse(text=paste(seq(50,100,10), "^o ", "*N", sep=""))
plot(-100:-50, 50:100, type="n", xlab="", ylab="", axes=FALSE)
axis(1, seq(-100, -50, 10), labels=labelsX)
axis(2, seq(50, 100, 10), labels=labelsY)
box()
-------------------------------------------------------------------------------------------------------
line loc <- hist(x, xaxt="n",bty="l")
axis(1, at=loc$breaks,line=-.75)
-------------------------------------------------------------------------------------------------------
par(mar=c(5,4.5,4,7))
 image(sample, col=rainbow(25), axes=F)  #redblue() doesn't work on my computer.
 axis(2)
 axis(1, at=seq(0,0.8,0.2), labels=rownames(sample))
 image.plot(sample, legend.only=T) sample = cor(matrix(rnorm(400), nrow=20))
 image(cor(matrix(rnorm(400), nrow=20)), axes=F)
 mtext(text=c(paste("country",1:21)), side=2, line=0.3, at=seq(0,1,0.05), las=1, cex=0.8)
 mtext(text=c(paste("country",1:21)), side=1, line=0.3, at=seq(0,1,0.05), las=2, cex=0.8)
 image.plot(sample, legend.only=T)
-------------------------------------------------------------------------------------------------------
image() axes = FALSE set.seed(42)
X <- as.POSIXct(1:100, origin = "1970-1-1")
Z <- matrix(rnorm(100*100), 100)
image(x = X, z = Z, axes = FALSE)
axis(side = 2)
axis.POSIXct(side = 1, x = X)
box() Axis() image(x = X, z = Z, axes = FALSE)
axis(side = 2)
Axis(x = X, side = 1)
box() Image <- function(x = seq(0, 1, length.out = nrow(z)),
                  y = seq(0, 1, length.out = ncol(z)),
                  z, ...) {
    image(x = X, z = Z, ..., axes = FALSE)
    Axis(x = y, side = 2, ...)
    Axis(x = X, side = 1, ...)
    box()
} Axis() x y image() Image() image() x image.default() x image.default() ?Startup
-------------------------------------------------------------------------------------------------------
plot(c(1,2,3),c(2,4,6),axes=F,xaxs = "i",yaxs="i",xlim=c(0,3),ylim=c(0,6))
axis(side=1, lwd=3, xpd=TRUE, at=0:3)
axis(side=2, lwd=3, xpd=TRUE, at=seq(0,6,2))
-------------------------------------------------------------------------------------------------------
plotCI(..., axes=F) # just ignore the warning
axis(side=1, at=0:99, labels=1,100)
-------------------------------------------------------------------------------------------------------
tkBrush TeachingDemos rechist <- function(x,...){
         tmp <- hist(x,plot=F)
         br <- tmp$breaks
         w <- as.numeric(cut(x,br,include.lowest=TRUE))
         sy <- unlist(lapply(tmp$counts,function(x)seq(length=x)))
         my <- max(sy)
         sy <- sy/my
         my <- 1/my
         sy <- sy[order(order(x))]
        plot.new()
        plot.window(xlim=range(br), ylim=c(0,1))
         rect(br[w], sy-my, br[w+1], sy, 
            border=TRUE, col='grey')
         rect(br[-length(br)], 0, br[-1], tmp$counts*my)
        axis(1)
     }

rechist( iris$Petal.Length )
-------------------------------------------------------------------------------------------------------
PolarImageInterpolate <- function(x, y, z, outer.radius = 1, 
            breaks, col, nlevels = 20, contours = TRUE, legend = TRUE, 
            axes = TRUE, circle.rads = pretty(c(0,outer.radius))){

        minitics <- seq(-outer.radius, outer.radius, length.out = 1000)
        # interpolate the data
        Interp <- akima:::interp(x = x, y = y, z = z, 
                extrap = TRUE, 
                xo = minitics, 
                yo = minitics, 
                linear = FALSE)
        Mat <- Interp[[3]]

        # mark cells outside circle as NA
        markNA <- matrix(minitics, ncol = 1000, nrow = 1000) 
        Mat[!sqrt(markNA ^ 2 + t(markNA) ^ 2) < outer.radius] <- NA 

        # sort out colors and breaks:
        if (!missing(breaks) & !missing(col)){
            if (length(breaks) - length(col) != 1){
                stop("breaks must be 1 element longer than cols")
            }
        }
        if (missing(breaks) & !missing(col)){
            breaks <- seq(min(Mat,na.rm = TRUE), max(Mat, na.rm = TRUE), length = length(col) + 1)
            nlevels <- length(breaks) - 1
        }
        if (missing(col) & !missing(breaks)){
            col <- rev(heat.colors(length(breaks) - 1))
            nlevels <- length(breaks) - 1
        }
        if (missing(breaks) & missing(col)){
            breaks <- seq(min(Mat,na.rm = TRUE), max(Mat, na.rm = TRUE), length = nlevels + 1)
            col <- rev(heat.colors(nlevels))
        }

        # if legend desired, it goes on the right and some space is needed
        if (legend) {
            par(mai = c(1,1,1.5,1.5))
        }

        # begin plot
        image(x = minitics, y = minitics, t(Mat), useRaster = TRUE, asp = 1, 
            axes = FALSE, xlab = "", ylab = "", col = col, breaks = breaks)

        # add contours if desired
        if (contours){
            CL <- contourLines(x = minitics, y = minitics, t(Mat), levels = breaks)
            A <- lapply(CL, function(xy){
                        lines(xy$x, xy$y, col = gray(.2), lwd = .5)
                    })
        }

        # add radial axes if desired
        if (axes){ 
            # internals for axis markup
            RMat <- function(radians){
                matrix(c(cos(radians), sin(radians), -sin(radians), cos(radians)), ncol = 2)
            }    

            circle <- function(x, y, rad = 1, nvert = 500){
                rads <- seq(0,2*pi,length.out = nvert)
                xcoords <- cos(rads) * rad + x
                ycoords <- sin(rads) * rad + y
                cbind(xcoords, ycoords)
            }

            # draw circles
            if (missing(circle.rads)){
                circle.rads <- pretty(c(0,outer.radius))
            }

            for (i in circle.rads){
                lines(circle(0, 0, i), col = "#66666650")
            }

            # put on radial spoke axes:
            axis.rads <- c(0, pi / 6, pi / 3, pi / 2, 2 * pi / 3, 5 * pi / 6)
            r.labs <- c(90, 60, 30, 0, 330, 300)
            l.labs <- c(270, 240, 210, 180, 150, 120)

            for (i in 1:length(axis.rads)){ 
                endpoints <- zapsmall(c(RMat(axis.rads[i]) %*% matrix(c(1, 0, -1, 0) * outer.radius,ncol = 2)))
                segments(endpoints[1], endpoints[2], endpoints[3], endpoints[4], col = "#66666650")
                endpoints <- c(RMat(axis.rads[i]) %*% matrix(c(1.1, 0, -1.1, 0) * outer.radius, ncol = 2))
                lab1 <- bquote(.(r.labs[i]) * degree)
                lab2 <- bquote(.(l.labs[i]) * degree)
                text(endpoints[1], endpoints[2], lab1, xpd = TRUE)
                text(endpoints[3], endpoints[4], lab2, xpd = TRUE)
            }
            axis(2, pos = -1.2 * outer.radius, at = sort(union(circle.rads,-circle.rads)), labels = NA)
            text( -1.21 * outer.radius, sort(union(circle.rads, -circle.rads)),sort(union(circle.rads, -circle.rads)), xpd = TRUE, pos = 2)
        }

        # add legend if desired
        # this could be sloppy if there are lots of breaks, and that's why it's optional.
        # another option would be to use fields:::image.plot(), using only the legend. 
        # There's an example for how to do so in its documentation
        if (legend){
            ylevs <- seq(-outer.radius, outer.radius, length = nlevels + 1)
            rect(1.2 * outer.radius, ylevs[1:(length(ylevs) - 1)], 1.3 * outer.radius, ylevs[2:length(ylevs)], col = col, border = NA, xpd = TRUE)
            rect(1.2 * outer.radius, min(ylevs), 1.3 * outer.radius, max(ylevs), border = "#66666650", xpd = TRUE)
            text(1.3 * outer.radius, ylevs,round(breaks, 1), pos = 4, xpd = TRUE)
        }
    }

    # Example
    set.seed(10)
    x <- rnorm(20)
    y <- rnorm(20)
    z <- rnorm(20)
    PolarImageInterpolate(x,y,z, breaks = seq(-2,8,by = 1)) image() # arguments:

    # Mat, a matrix of z values as follows:
    # leftmost edge of first column = 0 degrees, rightmost edge of last column = 360 degrees
    # columns are distributed in cells equally over the range 0 to 360 degrees, like a grid prior to transform
    # first row is innermost circle, last row is outermost circle

    # outer.radius, By default everything scaled to unit circle 
    # ppa: points per cell per arc. If your matrix is little, make it larger for a nice curve
    # cols: color vector. default = rev(heat.colors(length(breaks)-1))
    # breaks: manual breaks for colors. defaults to seq(min(Mat),max(Mat),length=nbreaks)
    # nbreaks: how many color levels are desired?
    # axes: should circular and radial axes be drawn? radial axes are drawn at 30 degree intervals only- this could be made more flexible.
    # circle.rads: at which radii should circles be drawn? defaults to pretty(((0:ncol(Mat)) / ncol(Mat)) * outer.radius)

    # TODO: add color strip legend.

    PolarImagePlot <- function(Mat, outer.radius = 1, ppa = 5, cols, breaks, nbreaks = 51, axes = TRUE, circle.rads){

        # the image prep
        Mat      <- Mat[, ncol(Mat):1]
        radii    <- ((0:ncol(Mat)) / ncol(Mat)) * outer.radius

        # 5 points per arc will usually do
        Npts     <- ppa
        # all the angles for which a vertex is needed
        radians  <- 2 * pi * (0:(nrow(Mat) * Npts)) / (nrow(Mat) * Npts) + pi / 2
        # matrix where each row is the arc corresponding to a cell
        rad.mat  <- matrix(radians[-length(radians)], ncol = Npts, byrow = TRUE)[1:nrow(Mat), ]
        rad.mat  <- cbind(rad.mat, rad.mat[c(2:nrow(rad.mat), 1), 1])

        # the x and y coords assuming radius of 1
        y0 <- sin(rad.mat)
        x0 <- cos(rad.mat)

        # dimension markers
        nc <- ncol(x0)
        nr <- nrow(x0)
        nl <- length(radii)

        # make a copy for each radii, redimension in sick ways
        x1 <- aperm( x0 %o% radii, c(1, 3, 2))
        # the same, but coming back the other direction to close the polygon
        x2 <- x1[, , nc:1]
        #now stick together
        x.array <- abind:::abind(x1[, 1:(nl - 1), ], x2[, 2:nl, ], matrix(NA, ncol = (nl - 1), nrow = nr), along = 3)
        # final product, xcoords, is a single vector, in order, 
        # where all the x coordinates for a cell are arranged
        # clockwise. cells are separated by NAs- allows a single call to polygon()
        xcoords <- aperm(x.array, c(3, 1, 2))
        dim(xcoords) <- c(NULL)
        # repeat for y coordinates
        y1 <- aperm( y0 %o% radii,c(1, 3, 2))
        y2 <- y1[, , nc:1]
        y.array <- abind:::abind(y1[, 1:(length(radii) - 1), ], y2[, 2:length(radii), ], matrix(NA, ncol = (length(radii) - 1), nrow = nr), along = 3)
        ycoords <- aperm(y.array, c(3, 1, 2))
        dim(ycoords) <- c(NULL)

        # sort out colors and breaks:
        if (!missing(breaks) & !missing(cols)){
            if (length(breaks) - length(cols) != 1){
                stop("breaks must be 1 element longer than cols")
            }
        }
        if (missing(breaks) & !missing(cols)){
            breaks <- seq(min(Mat,na.rm = TRUE), max(Mat, na.rm = TRUE), length = length(cols) + 1)
        }
        if (missing(cols) & !missing(breaks)){
            cols <- rev(heat.colors(length(breaks) - 1))
        }
        if (missing(breaks) & missing(cols)){
            breaks <- seq(min(Mat,na.rm = TRUE), max(Mat, na.rm = TRUE), length = nbreaks)
            cols <- rev(heat.colors(length(breaks) - 1))
        }

        # get a color for each cell. Ugly, but it gets them in the right order
        cell.cols <- as.character(cut(as.vector(Mat[nrow(Mat):1,ncol(Mat):1]), breaks = breaks, labels = cols))

        # start empty plot
        plot(NULL, type = "n", ylim = c(-1, 1) * outer.radius, xlim = c(-1, 1) * outer.radius, asp = 1, axes = FALSE, xlab = "", ylab = "")
        # draw polygons with no borders:
        polygon(xcoords, ycoords, col = cell.cols, border = NA)

        if (axes){

            # a couple internals for axis markup.

            RMat <- function(radians){
                matrix(c(cos(radians), sin(radians), -sin(radians), cos(radians)), ncol = 2)
            }

            circle <- function(x, y, rad = 1, nvert = 500){
                rads <- seq(0,2*pi,length.out = nvert)
                xcoords <- cos(rads) * rad + x
                ycoords <- sin(rads) * rad + y
                cbind(xcoords, ycoords)
            }
            # draw circles
            if (missing(circle.rads)){
                circle.rads <- pretty(radii)
            }
            for (i in circle.rads){
                lines(circle(0, 0, i), col = "#66666650")
            }

            # put on radial spoke axes:
            axis.rads <- c(0, pi / 6, pi / 3, pi / 2, 2 * pi / 3, 5 * pi / 6)
            r.labs <- c(90, 60, 30, 0, 330, 300)
            l.labs <- c(270, 240, 210, 180, 150, 120)

            for (i in 1:length(axis.rads)){ 
                endpoints <- zapsmall(c(RMat(axis.rads[i]) %*% matrix(c(1, 0, -1, 0) * outer.radius,ncol = 2)))
                segments(endpoints[1], endpoints[2], endpoints[3], endpoints[4], col = "#66666650")
                endpoints <- c(RMat(axis.rads[i]) %*% matrix(c(1.1, 0, -1.1, 0) * outer.radius, ncol = 2))
                lab1 <- bquote(.(r.labs[i]) * degree)
                lab2 <- bquote(.(l.labs[i]) * degree)
                text(endpoints[1], endpoints[2], lab1, xpd = TRUE)
                text(endpoints[3], endpoints[4], lab2, xpd = TRUE)
            }
            axis(2, pos = -1.2 * outer.radius, at = sort(union(circle.rads,-circle.rads)))
        }
        invisible(list(breaks = breaks, col = cols))
    } image() set.seed(1)
    x <- runif(20, min = 0, max = 360)
    y <- runif(20, min = 0, max = 40)
    z <- rnorm(20)

    Interp <- akima:::interp(x = x, y = y, z = z, 
            extrap = TRUE, 
            xo = seq(0, 360, length.out = 300), 
            yo = seq(0, 40, length.out = 100), 
            linear = FALSE)
    Mat <- Interp[[3]]

    PolarImagePlot(Mat)
-------------------------------------------------------------------------------------------------------
x <- 1:10
y <- runif(10) * 1e6

yrange <- c(0, 1e6)
ticks <- pretty(yrange)
labels <- format(ticks, big.mark=",", scientific=FALSE)

plot(y~x, yaxt="n", ylim = yrange)
axis(2, at = ticks, labels = labels, las = 1, cex.axis=0.7)
-------------------------------------------------------------------------------------------------------
?options set.seed(42)
dat <- data.frame(x = runif(100, min = 0, max = 1000000),
                  y = runif(100, min = 0, max = 1000000))

layout(matrix(1:2, ncol = 2))
plot(y ~ x, data = dat)
opt <- options(scipen = 10)
plot(y ~ x, data = dat)
options(opt)
layout(1) axes = FALSE plot() axis() format() ?format
-------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------
par(mfrow layout par( oma=c(5,4,4,1)+0.1, mar=c(0,0,0,0) )
layout( matrix( 1:3, nrow=1 ) )
for( i in levels(iris$Species) ) {
    with( iris[ iris$Species==i, ], {
        plot(Sepal.Width, Sepal.Length, ann=FALSE, xaxt='n', yaxt='n',
            ylim=range(iris$Sepal.Length))
        axis(1, outer=TRUE)
        mtext(side=3, i ) }
    )
}
axis(2, outer=TRUE)
-------------------------------------------------------------------------------------------------------
1 - plnorm() plnorm() ## Function to plot aft data
plot.aft <- function(x, legend = c("ICU Patients", "Non-ICU Patients"),
    xlab = "Days since Infection", ylab="Percent Surviving", lwd = 2,
    col = c("red", "black"), at = c(0, 20, 40, 60, 80, 100, 120, 140, 160, 180),
        ...)
{
    plot(x[, 1], x[, 2], type = "l", ylim = c(0, 1), xaxt = "n", 
            xlab = xlab, ylab = ylab, col = col[2], lwd = 2, ...)
    axis(1, at = at)
    lines(x[, 1], x[, 3], col = col[1], lwd=2)
    legend("topright", legend = legend, lwd = lwd, col = col)
} ## Specify coefficients, variables, and linear models
beta0 <- 5.00
beta1 <- -0.500
icu <- c(0, 1)
t <- seq(0, 180)
linmod <- beta0 + (beta1 * icu)
names(linmod) <- c("unexposed", "exposed")

## Generate s(t) from exponential AFT model
s0.exp <- dexp(exp(-linmod["unexposed"]) * t)
s1.exp <- dexp(exp(-linmod["exposed"]) * t)

## Generate s(t) from lognormal AFT model
s0.lnorm <- 1 - plnorm(t, meanlog = linmod["unexposed"])
s1.lnorm <- 1 - plnorm(t, meanlog = linmod["exposed"]) ## Plot survival
plot.aft(data.frame(t, s0.exp, s1.exp), main = "Exponential model")
plot.aft(data.frame(t, s0.lnorm, s1.lnorm), main = "Log-normal model") plnorm(t, meanlog = linmod["exposed"]) pnorm((log(t) - linmod["exposed"]) / 1)
-------------------------------------------------------------------------------------------------------
plot(myd[,1], myd[,2], xaxt="n")
axis(1, at=seq(0,1000,50)) ?axis axis(1, at=seq(0,1000,100), label=paste0("V", seq(0, 1000, 100)))
axis(1, at=seq(50,1000,100), label=F, tick=T)
-------------------------------------------------------------------------------------------------------
axis.POSIXct format dft <- data.frame(x= factor( sample(1:2, 100, repl=TRUE)), 
                  y= Sys.time()+rnorm(100)*4000 )
boxplot(y~x, data=dft, yaxt='n')
axis(2, at=seq(from=range(dft$y)[1], to =range(dft$y)[2], by=3000) , 
         labels=format.POSIXct(seq(from=range(dft$y)[1], to =range(dft$y)[2], by=3000), 
                                 format ="%H:%M:%S") ) Axis.POSIXt boxplot boxplot(y~x, data=dft, yaxt='n')
Axis(side=2, x=range(dft$y), format ="%H:%M:%S") require(ggplot2); p <- ggplot(dft, aes(x,y))
p + geom_boxplot()
-------------------------------------------------------------------------------------------------------
axis(side=1, at=seq(1,28,2), labels=labs[seq(0,28,2)], cex.axis=0.35)
axis(side=1, at=seq(2,28,2), labels=labs[seq(1,27,2)], cex.axis=0.35) cex.axis at= labels=
-------------------------------------------------------------------------------------------------------
plot(NULL, ylim=c(0,4), xlim=range(mydf$pos))
 abline(h=1:4 ,col=1:2 )
 with(mydf, segments(x0=pos, y0=as.numeric(interaction(mydf$grp, mydf$sgrp))-.2, 
                     y1=as.numeric(interaction(mydf$grp, mydf$sgrp))+.2,
                     col= mydf$grp, lty=as.numeric(mydf$sgrp)) ) ylim ylab yaxt="n" axis() plot(NULL, ylim=c(0.5,4.5), xlim=range(mydf$pos))
 with(mydf, segments(x0=pos, 
             y0=c(1.3,1.7,3.3,3.7)[as.numeric(interaction(mydf$grp, mydf$sgrp))]-.1, 
             y1=c(1.3,1.7,3.3,3.7)[as.numeric(interaction(mydf$grp, mydf$sgrp))]+.1, 
             col= mydf$sgrp, lty=as.numeric(mydf$grp)) )
abline(h=c(1.3,1.7,3.3,3.7) ,col= rep(1:2, each=2), lty=1:2,lwd=3)
-------------------------------------------------------------------------------------------------------
data = c(1,3,2)
max_y <- max(data)
plot_colors <- c("blue")
plot(data, type="l", col=plot_colors[1], ylim=c(0,max_y),
     axes=FALSE, xlab=expression(e[3]))

labels <- "e[1],e[2],e[3]"
axis(1, at=c(1,2,3), lab=eval(parse(text=paste("expression(", labels, ")")))) > paste("expression(", labels, ")")
[1] "expression( e[1],e[2],e[3] )"

> parse(text=paste("expression(", labels, ")"))
expression(expression( e[1],e[2],e[3] ))

> eval(parse(text=paste("expression(", labels, ")")))
expression(e[1], e[2], e[3]) labels > parse(text=labels)
Error in parse(text = labels) : <text>:1:5: unexpected ','
1: e[1],
       ^ eval expression > parse(text=paste("expression(", labels, ")"))[[1]]
expression(e[1], e[2], e[3]) axis
-------------------------------------------------------------------------------------------------------
?parse names = c('e[1]', 'e[2]', 'e[3]')
namesExp = do.call(c, lapply(names, function(x) parse(text = x)))
plot(c(1,3,2), type='l', col='blue', axes=FALSE, xlab = expression(e[3]))
axis(3, at=c(1,2,3), lab = names)
axis(1, at=c(1,2,3), lab = namesExp) lapply > print(lapply(names, function(x) parse(text = x)))
[[1]]
expression(e[1])
[[2]]
expression(e[2])
[[3]]
expression(e[3]) do.call unlist(lapply(names, function(x) parse(text = x)), recursive = F) > print(do.call(c, lapply(names, function(x) parse(text = x))))
expression(e[1], e[2], e[3])
-------------------------------------------------------------------------------------------------------
bg_col <- matrix("white",nrow(deciles),ncol(deciles))
bg_col[11,] <- "grey"

# create a plot
hist(foo, freq=F, xlim=c(0,xmax), breaks=50, col="blue")
top <- max(axis(2))
rect(xleft=(.69*xmax), xright=(1.04*xmax), ybottom=(.615*top), ytop=(.665*top), col="gray91", border=NA)
addtable2plot(x=(1.04*xmax), y=(top), xjust=1, yjust=0, table=deciles, cex=0.82,
          title="Title", hlines=TRUE, vlines=TRUE, bty="o", lwd=1.5, bg= bg_col) rect ?addtable2plot
-------------------------------------------------------------------------------------------------------
at = floor(seq(from = 1, to = 5913, length.out = 7))
-------------------------------------------------------------------------------------------------------
hist axis set.seed(123)
d <- rnorm(1000)
hist(d,axes = FALSE)
axis(1,at = seq(-3,3,1),labels = TRUE,pos = 0)
axis(2,pos = -3)
-------------------------------------------------------------------------------------------------------
#See if this is sufficient:
hist(...)
box()

#If not, try custom axes:
hist(..., xlim = c(-.5, .5), axes = F)
box()
axis(1, seq(-.5, .5, length = 6))
axis(2, seq(0, 30, by = 5))
-------------------------------------------------------------------------------------------------------
data <- read.table("data.txt",header=T,row.names=1)
lst  <- c("LABELXYZ123","LABELXZZ123","LABELXYZ345","LABELXYZ567","LABELXYY1234","LABELXXX123")
labs <- row.names(data)
for(i in lst) {
    png(filename=paste(i,".png",sep=""),width = 700, height = 350)
    river  <- data[[paste(i, "_river", sep = "")]]
    lake <- data[[paste(i, "_lake", sep = "")]]
    allt <- c(river,lake)
    plot(river, xaxt='n',xlab="",ylab=i,type="b",col="darkred",lwd=3,ylim=c(min(allt)*1.05,max(allt)*0.95))
    lines(lake,type="b",col="darkgreen",lwd=3)
    axis(1,at=1:16,labels=labs,las=2)
    dev.off()
}
-------------------------------------------------------------------------------------------------------
par( mar=c(1,5,5,1) )
plot.new()
plot.window( xlim=c(0,10), ylim=c(0,11) )

quant_vals <- findInterval( cor_matrix[-11,], 
    c(-Inf, quantile(cor_matrix[-11,], c(0.05, 0.25, 0.45, 0.55, 0.75, 0.95), na.rm=TRUE ),
            Inf) )
quant_vals[ is.na(quant_vals) ] <- 4
cols <- c('#ff0000','#ff6666','#ffaaaa','#ffffff','#aaffaa','#66ff66','#00ff00')
colmat <- matrix( cols[quant_vals], ncol=10, nrow=10)

rasterImage(colmat, 0, 1, 10, 11, interpolate=FALSE)
for(i in seq_along( cor_matrix[11,] ) ) {
    rect( i-1, 0.1, i-1 + cor_matrix[11,i]/max(cor_matrix[11,]), 0.9, col='lightsteelblue3')
}

text( col( cor_matrix )-0.5, 11.5-row( cor_matrix ), cor_matrix, font=2 )
rect( 0,1,10,11 )
rect( 0,0,10,1)
axis(2, at=(11:1)-0.5, labels=rownames(cor_matrix), tick=FALSE, las=2)
axis(3, at=(1:10)-0.5, labels=colnames(cor_matrix), tick=FALSE, las=2)

rect(0,8,3,11, lwd=2)
rect(4,4,7,7, lwd=2)
rect(8,1,10,3, lwd=2)
-------------------------------------------------------------------------------------------------------
axis() axTicks(1)
-------------------------------------------------------------------------------------------------------
las=TRUE axis() dates <-  1:10
returns <- runif(10)

plot(dates, returns, yaxt="n")
axis(2, at=pretty(returns), lab=pretty(returns) * 100, las=TRUE)
-------------------------------------------------------------------------------------------------------
labels axis sprintf boxplot(x, yaxt="n")
axis(2, at=axTicks(2), labels=sprintf("$%s", axTicks(2))) las boxplot(x, yaxt="n")
axis(2, at=axTicks(2), labels=sprintf("$%s", axTicks(2)), las=1)
-------------------------------------------------------------------------------------------------------
xpd=FALSE b <- barplot(c(363.2, 377.4), beside = TRUE, 
   ylim = c(340,380), col = c("orange", "blue"),xpd=FALSE)
axis(side=1,at=b,labels=c("group 1", "group 2"))
box(bty="l")
-------------------------------------------------------------------------------------------------------
?axis xaxp plot(x,y, xaxt="n")
axis(1, xaxp=c(10, 200, 19), las=2) at seq() plot(x,y, xaxt="n")
axis(1, at = seq(10, 200, by = 10), las=2) las
-------------------------------------------------------------------------------------------------------
?axis labels "a logical value specifying whether (numerical) annotations are 
to be made at the tickmarks," x <- seq(10,200,10)
y <- runif(x)
plot(x,y,xaxt='n')
axis(side = 1, at = x,labels = T)
# Since TRUE is the default for labels, you can just use axis(side=1,at=x) r axis
-------------------------------------------------------------------------------------------------------
axis plot(c(-2,2), c(-2,2), axes = FALSE, bty = 'n', panel.first = grid())
axis(1, c(-2, -1, 1, 2), pos = 0, cex.axis = 0.8)
axis(2, c(-2, -1, 1, 2), pos = 0, cex.axis = 0.8, las = 2)
-------------------------------------------------------------------------------------------------------
box box(lwd=4) bty box(lwd=4, bty="u") # For all the different kind of boxes see ?par. font cex.lab cex.axis plot axis axis(1, font=2, cex.axis=1.1) #font=2 correspond to bold face. See ?par for more information family ?x11 axis(1, family="Times") #This will work with Cairo devices for example. cex.axis
-------------------------------------------------------------------------------------------------------
z <- zoo(cbind(a = 1:10, b = 10:1, c = rep(1:5, each = 2))) # test data

nc <- ncol(z)
opar <- par(mfrow = c(nc, 1), mar = c(2, 2, 1.5, 2))
for(i in 1:nc) { plot(z[, i], yaxt="n", main=colnames(z)[i]); axis(2+2*i%%2) }
-------------------------------------------------------------------------------------------------------
barplot() ?barplot bar axis() axis() labels at at bar las = 2 cex.axis = 0.6 title() line mar line title() op <- par(mar= c(15,4,4,2) + 0.1)
bar <- barplot(58:1, xaxt="n", xlab="", ylab="Frequency", col=gray(5:0/5))
axis(1, labels = paste("Long Species Name", 1:58), at = bar,
     las = 2, cex.axis = 0.6)
title(xlab = "Species", line=11)
par(op)
-------------------------------------------------------------------------------------------------------
xlim ylim range() plot(x$Date, x$Value, type="l", col="blue", xaxt="n",
     xlim=range(c(a$Date, x$Date)),
     ylim=range(c(z.pre, x$Value))
)

axis(1, x$Date, format(x$Date, "%b %Y"), cex.axis = .7) 

lines(a$Date, z.pre, col="red")
-------------------------------------------------------------------------------------------------------
require(reshape) 
require(mapdata)
require(mapproj)
df <- read.table('year.dat',head=F)
names(df) <- c("value", "x", "y", "t")
dfc <- cast(df[ ,-4], x ~ y)
mm<-as.matrix(dfc,ncol=480,nrow=241)
#pdf('mappamondo.pdf')
 filled.contour(x=seq(0,360,length.out=480),y=seq(-90,90,length.out=241),mm,color.palette = colorRampPalette(c("lightblue", "blue","violet", "black")),
xlab = "Longitude (°)", ylab = "Latitude (°)",
plot.axes = {axis(1); axis(2);          
map('world2Hires',
xlim = c(0, 360), 
ylim = c(-90, 90), 
add = T, col = "black")}
)

#dev.off()
-------------------------------------------------------------------------------------------------------
horiz.hist <- function(Data, breaks="Sturges", col="transparent", las=1, 
ylim=range(HBreaks), labelat=pretty(ylim), labels=labelat, border=par("fg"), ... )
  {a <- hist(Data, plot=FALSE, breaks=breaks)
  HBreaks <- a$breaks
  HBreak1 <- a$breaks[1]
  hpos <<- function(Pos) (Pos-HBreak1)*(length(HBreaks)-1)/ diff(range(HBreaks))
  barplot(a$counts, space=0, horiz=T, ylim=hpos(ylim), col=col, border=border,...)      
  axis(2, at=hpos(labelat), labels=labels, las=las, ...) 
  print("use hpos() to address y-coordinates") } # Data and basic concept
set.seed(8); ExampleData <- rnorm(50,8,5)+5
hist(ExampleData)
horiz.hist(ExampleData, xlab="absolute frequency") 
# Caution: the labels at the y-axis are not the real coordinates!
# abline(h=2) will draw above the second bar, not at the label value 2. Use hpos:
abline(h=hpos(11), col=2)

# Further arguments
horiz.hist(ExampleData, xlim=c(-8,20)) 
horiz.hist(ExampleData, main="the ... argument worked!", col.axis=3) 
hist(ExampleData, xlim=c(-10,40)) # with xlim
horiz.hist(ExampleData, ylim=c(-10,40), border="red") # with ylim
horiz.hist(ExampleData, breaks=20, col="orange")
axis(2, hpos(0:10), labels=F, col=2) # another use of hpos()
-------------------------------------------------------------------------------------------------------
par ?par dev.new( width= 16, height= 7 )
## set outer margins
par( mar=c(5, 4, 4, 4), cex= 0.9 )
plot( 1:100, type="n", xlab = "", ylab = "", axes = F, las = 2, cex = 0.7 )
axis( 4, at = c ( 0, 30, 60, 90, 120, 150, 180 ), labels = c( "0", "30", "60", "90", "120", "150", "180" ), las = 0, cex.axis = .8,col.lab = "gray80",
tck = 0.01 )
rect( 153, -5.5, 169, 185, col = "gray80", border = NA)
rect( 246, -5.5, 272, 185, col = "gray80", border = NA)
lines( 1:200, col = "gray20" )
#text("Moon phase (º)", 330, 90, cex = .9 )
mtext(side = 4, text = "Moon phase (º)", line = 2, cex = .9 )
mtext(side = 1, text = "Dates", line = 4, cex = .9 )

par( new = T )
plot( 1:220, type = "n", lwd= 1.2, xlab= "", ylab= "Photoperiod (h)", axes = F, cex = .8, col.lab = "red" )
axis( side= 1, at = c ( 1, 20, 51, 82, 112, 143, 173, 204, 235, 264, 295, 324 ), labels = c ( "12 Jun'07", "1 Jul'07", "1 Aug'07", "1 Sep'07", "1 Oct'07", "1 Nov'07", "1 Dec'07", "1 Jan'08", "1 Feb'08", "1 Mar'08", "1 Apr'08", "30 Apr'08" ), las = 2, cex.axis = .75 )
axis ( side = 2, at = c( 12, 13, 14, 15, 16 ), labels = c( "12", "13", "14", "15", "16" ), cex.axis = .8, las = 2)
box()
-------------------------------------------------------------------------------------------------------
> map(projection=foo,parameters=foo)
> par('usr')   # will return vector of plot limits filled.contour(lons, lats, glb.data) filled.contour(lons, lats, glb.data,
plot.axes={axis(1,...);axis(2,...);map(projection=foo,parameters=foo,add=T)}) filled.contour(lons, lats, glb.data,
plot.axes={axis(1,...);axis(2,...);par(usr=c(-180,180,-90,90));
map(add=T)}) filled.contour(lons, lats, glb.data,
plot.axes={axis(1,...);axis(2,...);
par(usr=c(0,360,-90,90));map(add=T);  #eastern hemisphere
par(usr=c(-360,0,-90,90));map(add=T)}   #western
)
-------------------------------------------------------------------------------------------------------
x<-c(1,2,3,11,15) 
y<-c(1.1,1.2,.4,2.1,1.5)
lab<-c(1,2,4,16)
plot(log2(x+1),y,xaxt="n",xlab="x")
axis(1,at=log2(lab+1),labels=lab) lab<-round(2^seq(min(log2(x+1)),max(log2(x+1)),length.out=4)-1)
-------------------------------------------------------------------------------------------------------
library(party)
data(iris)
attach(iris)

ctree <- ctree(Species ~ Sepal.Length + Sepal.Width 
               + Petal.Length + Petal.Width, data = iris)

# getting ctree's class

> class(ctree)
[1] "BinaryTree"
attr(,"package")
[1] "party" ?'plot.BinaryTree' terminal_panel ?node_barplot plot(ctree, terminal_panel = node_barplot(ctree)) horizontal horiz node_barplot node_barplot # Note inclusion of horiz = FALSE
alt_node_barplot <- function (ctreeobj, col = "black", fill = NULL, beside = NULL, 
    ymax = NULL, ylines = NULL, widths = 1, gap = NULL, reverse = NULL, 
    id = TRUE, horiz = FALSE)
{
    getMaxPred <- function(x) {
        mp <- max(x$prediction)
        mpl <- ifelse(x$terminal, 0, getMaxPred(x$left))
        mpr <- ifelse(x$terminal, 0, getMaxPred(x$right))
        return(max(c(mp, mpl, mpr)))
    }
    y <- response(ctreeobj)[[1]]
    if (is.factor(y) || class(y) == "was_ordered") {
        ylevels <- levels(y)
        if (is.null(beside)) 
            beside <- if (length(ylevels) < 3) 
                FALSE
            else TRUE
        if (is.null(ymax)) 
            ymax <- if (beside) 
                1.1
            else 1
        if (is.null(gap)) 
            gap <- if (beside) 
                0.1
            else 0
    }
    else {
        if (is.null(beside)) 
            beside <- FALSE
        if (is.null(ymax)) 
            ymax <- getMaxPred(ctreeobj@tree) * 1.1
        ylevels <- seq(along = ctreeobj@tree$prediction)
        if (length(ylevels) < 2) 
            ylevels <- ""
        if (is.null(gap)) 
            gap <- 1
    }
    if (is.null(reverse)) 
        reverse <- !beside
    if (is.null(fill)) 
        fill <- gray.colors(length(ylevels))
    if (is.null(ylines)) 
        ylines <- if (beside) 
            c(3, 2)
        else c(1.5, 2.5)
    # My edit do not work if beside is not true
    #################################################
    if(!beside) horiz = FALSE
    #################################################

    rval <- function(node) {
        pred <- node$prediction
        if (reverse) {
            pred <- rev(pred)
            ylevels <- rev(ylevels)
        }
        np <- length(pred)
        nc <- if (beside) 
            np
        else 1
        fill <- rep(fill, length.out = np)
        widths <- rep(widths, length.out = nc)
        col <- rep(col, length.out = nc)
        ylines <- rep(ylines, length.out = 2)
        gap <- gap * sum(widths)
        #######################################################
        if (!horiz){
            yscale <- c(0, ymax)
            xscale <- c(0, sum(widths) + (nc + 1) * gap)
        } else {
            xscale <- c(0, ymax)
            yscale <- c(0, sum(widths) + (nc + 1) * gap)
        }                    
        #######################################################
        top_vp <- viewport(layout = grid.layout(nrow = 2, ncol = 3, 
            widths = unit(c(ylines[1], 1, ylines[2]), c("lines", 
                "null", "lines")), heights = unit(c(1, 1), c("lines", 
                "null"))), width = unit(1, "npc"), height = unit(1, 
            "npc") - unit(2, "lines"), name = paste("node_barplot", 
            node$nodeID, sep = ""))
        pushViewport(top_vp)
        grid.rect(gp = gpar(fill = "white", col = 0))
        top <- viewport(layout.pos.col = 2, layout.pos.row = 1)
        pushViewport(top)
        mainlab <- paste(ifelse(id, paste("Node", node$nodeID, 
            "(n = "), "n = "), sum(node$weights), ifelse(id, 
            ")", ""), sep = "")
        grid.text(mainlab)
        popViewport()
        plot <- viewport(layout.pos.col = 2, layout.pos.row = 2, 
            xscale = xscale, yscale = yscale, name = paste("node_barplot", 
                node$nodeID, "plot", sep = ""))
        pushViewport(plot)
        if (beside) {
            #############################################################
            if(!horiz){
                xcenter <- cumsum(widths + gap) - widths/2
                for (i in 1:np) {
                    grid.rect(x = xcenter[i], y = 0, height = pred[i], 
                      width = widths[i], just = c("center", "bottom"), 
                      default.units = "native", gp = gpar(col = col[i], 
                        fill = fill[i]))
                }
                if (length(xcenter) > 1) 
                    grid.xaxis(at = xcenter, label = FALSE)
                grid.text(ylevels, x = xcenter, y = unit(-1, "lines"), 
                    just = c("center", "top"), default.units = "native", 
                    check.overlap = TRUE)
                grid.yaxis()
            } else {
                ycenter <- cumsum(widths + gap) - widths/2
                for (i in 1:np) {
                    grid.rect(y = ycenter[i], x = 0, width = pred[i], 
                    height = widths[i], just = c("left", "center"), 
                    default.units = "native", gp = gpar(col = col[i], 
                     fill = fill[i]))
                }
                if (length(ycenter) > 1) 
                    grid.yaxis(at = ycenter, label = FALSE)
                        grid.text(ylevels, y = ycenter, x = unit(-1, "lines"), 
                        just = c("right", "center"), default.units = "native", 
                         check.overlap = TRUE)
                grid.xaxis()
            }
        #############################################################
        }
        else {
            ycenter <- cumsum(pred) - pred
            for (i in 1:np) {
                grid.rect(x = xscale[2]/2, y = ycenter[i], height = min(pred[i], 
                  ymax - ycenter[i]), width = widths[1], just = c("center", 
                  "bottom"), default.units = "native", gp = gpar(col = col[i], 
                  fill = fill[i]))
            }
            if (np > 1) {
                grid.text(ylevels[1], x = unit(-1, "lines"), 
                  y = 0, just = c("left", "center"), rot = 90, 
                  default.units = "native", check.overlap = TRUE)
                grid.text(ylevels[np], x = unit(-1, "lines"), 
                  y = ymax, just = c("right", "center"), rot = 90, 
                  default.units = "native", check.overlap = TRUE)
            }
            if (np > 2) {
                grid.text(ylevels[-c(1, np)], x = unit(-1, "lines"), 
                  y = ycenter[-c(1, np)], just = "center", rot = 90, 
                  default.units = "native", check.overlap = TRUE)
            }
            grid.yaxis(main = FALSE)
        }
        grid.rect(gp = gpar(fill = "transparent"))
        upViewport(2)
    }
    return(rval)
} plot(ctree, terminal_panel = alt_node_barplot(ctree, horiz = TRUE)) beside horiz beside ?viewport ?grid.rect reverse
-------------------------------------------------------------------------------------------------------
plot(TreeResults,tp_args = list(beside=F)) node_barplot() altbp<-function (ctreeobj, col = "black", fill = NULL, beside = NULL, 
    ymax = NULL, ylines = NULL, widths = 1, gap = NULL, reverse = NULL, 
    id = TRUE,rot=45) 
{
    getMaxPred <- function(x) {
        mp <- max(x$prediction)
        mpl <- ifelse(x$terminal, 0, getMaxPred(x$left))
        mpr <- ifelse(x$terminal, 0, getMaxPred(x$right))
        return(max(c(mp, mpl, mpr)))
    }
    y <- response(ctreeobj)[[1]]
    if (is.factor(y) || class(y) == "was_ordered") {
        ylevels <- levels(y)
        if (is.null(beside)) 
            beside <- if (length(ylevels) < 3) 
                FALSE
            else TRUE
        if (is.null(ymax)) 
            ymax <- if (beside) 
                1.1
            else 1
        if (is.null(gap)) 
            gap <- if (beside) 
                0.1
            else 0
    }
    else {
        if (is.null(beside)) 
            beside <- FALSE
        if (is.null(ymax)) 
            ymax <- getMaxPred(ctreeobj@tree) * 1.1
        ylevels <- seq(along = ctreeobj@tree$prediction)
        if (length(ylevels) < 2) 
            ylevels <- ""
        if (is.null(gap)) 
            gap <- 1
    }
    if (is.null(reverse)) 
        reverse <- !beside
    if (is.null(fill)) 
        fill <- gray.colors(length(ylevels))
    if (is.null(ylines)) 
        ylines <- if (beside) 
            c(3, 2)
        else c(1.5, 2.5)
    rval <- function(node) {
        pred <- node$prediction
        if (reverse) {
            pred <- rev(pred)
            ylevels <- rev(ylevels)
        }
        np <- length(pred)
        nc <- if (beside) 
            np
        else 1
        fill <- rep(fill, length.out = np)
        widths <- rep(widths, length.out = nc)
        col <- rep(col, length.out = nc)
        ylines <- rep(ylines, length.out = 2)
        gap <- gap * sum(widths)
        yscale <- c(0, ymax)
        xscale <- c(0, sum(widths) + (nc + 1) * gap)
        top_vp <- viewport(layout = grid.layout(nrow = 2, ncol = 3, 
            widths = unit(c(ylines[1], 1, ylines[2]), c("lines", 
                "null", "lines")), heights = unit(c(1, 1), c("lines", 
                "null"))), width = unit(1, "npc"), height = unit(1, 
            "npc") - unit(2, "lines"), name = paste("node_barplot", 
            node$nodeID, sep = ""))
        pushViewport(top_vp)
        grid.rect(gp = gpar(fill = "white", col = 0))
        top <- viewport(layout.pos.col = 2, layout.pos.row = 1)
        pushViewport(top)
        mainlab <- paste(ifelse(id, paste("Node", node$nodeID, 
            "(n = "), "n = "), sum(node$weights), ifelse(id, 
            ")", ""), sep = "")
        grid.text(mainlab)
        popViewport()
        plot <- viewport(layout.pos.col = 2, layout.pos.row = 2, 
            xscale = xscale, yscale = yscale, name = paste("node_barplot", 
                node$nodeID, "plot", sep = ""))
        pushViewport(plot)
        if (beside) {
            xcenter <- cumsum(widths + gap) - widths/2
            for (i in 1:np) {
                grid.rect(x = xcenter[i], y = 0, height = pred[i], 
                  width = widths[i], just = c("center", "bottom"), 
                  default.units = "native", gp = gpar(col = col[i], 
                    fill = fill[i]))
            }
            if (length(xcenter) > 1) 
                grid.xaxis(at = xcenter, label = FALSE)
            grid.text(ylevels, x = xcenter, y = unit(-1, "lines"), 
                just = c("center", "top"), default.units = "native", 
                check.overlap = TRUE,rot=rot)
            grid.yaxis()
        }
        else {
            ycenter <- cumsum(pred) - pred
            for (i in 1:np) {
                grid.rect(x = xscale[2]/2, y = ycenter[i], height = min(pred[i], 
                  ymax - ycenter[i]), width = widths[1], just = c("center", 
                  "bottom"), default.units = "native", gp = gpar(col = col[i], 
                  fill = fill[i]))
            }
            if (np > 1) {
                grid.text(ylevels[1], x = unit(-1, "lines"), 
                  y = 0, just = c("left", "center"), rot = 90, 
                  default.units = "native", check.overlap = TRUE)
                grid.text(ylevels[np], x = unit(-1, "lines"), 
                  y = ymax, just = c("right", "center"), rot = 90, 
                  default.units = "native", check.overlap = TRUE)
            }
            if (np > 2) {
                grid.text(ylevels[-c(1, np)], x = unit(-1, "lines"), 
                  y = ycenter[-c(1, np)], just = "center", rot = 90, 
                  default.units = "native", check.overlap = TRUE)
            }
            grid.yaxis(main = FALSE)
        }
        grid.rect(gp = gpar(fill = "transparent"))
        upViewport(2)
    }
    return(rval)
} rot= grid.text beside=T plot(TreeResults,terminal_panel=altbp(TreeResults,ylines=1.2, gap=0.05,rot=45)) node_barplot altbp<-node_barplot
body(altbp)[[8]][[3]][[3]][[23]][[3]][[5]]<-substitute(
grid.text(ylevels, x = xcenter, y = unit(-1, "lines"), just = c("center", 
    "top"), default.units = "native", check.overlap = TRUE,rot=45)
)
plot(TreeResults,terminal_panel=altbp(TreeResults)) altbp
-------------------------------------------------------------------------------------------------------
```{r clock, fig.width=7, fig.height=6, fig.show='animate'}
par(mar = rep(3, 4))
for (i in seq(pi/2, -4/3 * pi, length = 12)) {
    plot(0, 0, pch = 20, ann = FALSE, axes = FALSE)
    arrows(0, 0, cos(i), sin(i))
    axis(1, 0, "VI"); axis(2, 0, "IX")
    axis(3, 0, "XII"); axis(4, 0, "III"); box()
}
```
-------------------------------------------------------------------------------------------------------
par("mfg") par(mai=c(2.5, 2.25, 0.82, 0.42), mgp=c(9, 1, 0))
plot(c(1,4), c(1,4), xaxp=c(1,4,3), yaxp=c(1,4,3), type="n", 
  main="title", xlab="site.x", ylab="ylab")
rect(xleft, ybottom, xright, ytop, col=c("blue","red","green"))
axis(1, at=x.label.position, labels=x.label, las=2)
axis(2, at=y.label.position, labels=y.label, las=2)
par(xpd=TRUE)
legend(x=0.25, y=0.75, 
  legend=c("Text", "Text", "Text"),
  fill=c("blue", "red", "green"),
  title="Legend") ggplot2
-------------------------------------------------------------------------------------------------------
axis plot.histogram labels <- sample(1:9, 1000, replace = T)
.h <- hist(labels)
# if you save the histogram, then you can refer to the components
axis(1, at = .h$breaks))
-------------------------------------------------------------------------------------------------------
box() hist(...., axes = FALSE) ## .... is where your other args go
axis(side = 2)
axis(side = 1, at = seq(1730, 1830, by = 20)) axis(side = 1, at = seq(1725, 1835, by = 20))
-------------------------------------------------------------------------------------------------------
cex.axis axis(1, at = c(32.65), labels = expression("hola"), cex.axis=0.8)
-------------------------------------------------------------------------------------------------------
cex.axis <1 >1 plot(1:50)
axis(1, at = c(32.65), labels = expression("hola"), cex.axis=2)
axis(1, at = c(45), labels = expression("hola"), cex.axis=0.5)
-------------------------------------------------------------------------------------------------------
?curve ?axis ## draw the curve
curve(1-exp(-x^2/730),from=0,to=370,axes=FALSE)
axis(side=2)  ## add default lefthand axis
axis(side=1,at=seq(0,370,by=10))  ## add custom bottom axis
box(bty="l")  ## add a box cex.axis=0.5 staxlab plotrix
-------------------------------------------------------------------------------------------------------
plot(c(1,2.75),c(1,2.75),type="n",main="title",xlab="site.x",ylab="ylab",axes=F) # ann
axis(1,pos=1)
axis(2,pos=1) pos
-------------------------------------------------------------------------------------------------------
barplot(a, ylim = rev(range(c(0, a)))) yaxt = "n" axis() barplot(a, ylim = rev(range(a)), yaxt = "n")
axis(4, at = a)
-------------------------------------------------------------------------------------------------------
quantile() rug() set.seed(1)
X <- rnorm(200)
boxplot(X, yaxt = "n")

## compute the required quantiles
qntl <- quantile(X, probs = c(0.85, 0.90))

## add them as a rgu plot to the left hand side
rug(qntl, side = 2, col = "blue", lwd = 2)

## add the box and axes
axis(2)
box() str() set.seed(1) ## make reproducible
HWD <- data.frame(Hour = rep(0:23, 10),
                  Houston_Load = rnorm(24*10)) Hour Hour quantile() quants <- sapply(split(HWD$Houston_Load, list(HWD$Hour)),
                 quantile, probs = c(0.85, 0.9)) R> quants <- sapply(split(HWD$Houston_Load, list(HWD$Hour)),
+                  quantile, probs = c(0.85, 0.9))
R> quants
            0         1        2         3         4         5        6
85% 0.3576510 0.8633506 1.581443 0.2264709 0.4164411 0.2864026 1.053742
90% 0.6116363 0.9273008 2.109248 0.4218297 0.5554147 0.4474140 1.366114
            7         8        9       10        11        12       13       14
85% 0.5352211 0.5175485 1.790593 1.394988 0.7280584 0.8578999 1.437778 1.087101
90% 0.8625322 0.5969672 1.830352 1.519262 0.9399476 1.1401877 1.763725 1.102516
           15        16        17        18       19        20       21
85% 0.6855288 0.4874499 0.5493679 0.9754414 1.095362 0.7936225 1.824002
90% 0.8737872 0.6121487 0.6078405 1.0990935 1.233637 0.9431199 2.175961
          22        23
85% 1.058648 0.6950166
90% 1.145783 0.8436541 boxplot(Houston_Load ~ Hour, data = HWD, axes = FALSE)
xlocs <- 1:24 ## where to draw marks
tickl <- 0.15 ## length of marks used
for(i in seq_len(ncol(quants))) {
    segments(x0 = rep(xlocs[i] - 0.15, 2), y0 = quants[, i],
             x1 = rep(xlocs[i] + 0.15, 2), y1 = quants[, i],
             col = c("red", "blue"), lwd = 2)
}
title(xlab = "Hour", ylab = "Houston Load")
axis(1, at = xlocs, labels = xlocs - 1)
axis(2)
box()
legend("bottomleft", legend = paste(c("0.85", "0.90"), "quantile"),
       bty = "n", lty = "solid", lwd = 2, col = c("red", "blue"))
-------------------------------------------------------------------------------------------------------
dat$freqs str(foo) str(dat) str(dat$freqs) dat$freq "numeric" ## Make the frequencies numbers (rather than factors)
dat$freqs <- as.numeric(as.character(dat$freqs))
## Find a range of y's that'll leave sufficient space above the tallest bar
ylim <- c(0, 1.1*max(dat$freqs))
## Plot, and store x-coordinates of bars in xx
xx <- barplot(dat$freqs, xaxt = 'n', xlab = '', width = 0.85, ylim = ylim,
              main = "Sample Sizes of Various Fitness Traits", 
              ylab = "Frequency")
## Add text at top of bars
text(x = xx, y = dat$freqs, label = dat$freqs, pos = 3, cex = 0.8, col = "red")
## Add x-axis labels 
axis(1, at=xx, labels=dat$fac, tick=FALSE, las=2, line=-0.5, cex.axis=0.5)
-------------------------------------------------------------------------------------------------------
xaxt="n" axis times <- as.vector(time(Canada) ) plot.ts(c(endog[, names[i]], rep(NA, n.ahead)), main = main[i], 
          ylim = c(ymin, ymax), ylab = ylab, xlab = xlab, col = col.y,  
         ...) axis(1, at=seq_along( c( times, rep(NA,8) )), labels=c( times, rep(NA,8)) ,
        las=3, line=2, cex.axis=0.6) nrow(var.2c.prd$fcst[[1]]) [1] 8 fanchart(var.2c.prd, xaxt="n")
 par(new=TRUE)
 axis(1, at=seq_along( c( times, rep(NA,8) )), labels=c( times, rep(NA,8)) ,
       las=3, line=-26, cex.axis=0.6)
 axis(1, at=seq_along( c( times, rep(NA,8) )), labels=c( times, rep(NA,8)) ,
       las=3, line=0.5, cex.axis=0.6) par(new=TRUE)
-------------------------------------------------------------------------------------------------------
?par cex col par col.lab col.axis main col.main x <- 1:10
y <- 1:10

plot(x , y,xlab="x axis", ylab="y axis",  pch=19, col.axis = 'blue', col.lab = 'red', cex.axis = 1.5, cex.lab = 2) ?axis ?box box plot(x , y,xlab="x axis", ylab="y axis",  pch=19,  cex.lab = 2, axes = F,col.lab = 'red')
box(col = 'lightblue')
axis(1, col = 'blue', col.axis = 'purple', col.ticks = 'darkred', cex.axis = 1.5, font = 2, family = 'serif')
axis(2, col = 'maroon', col.axis = 'pink', col.ticks = 'limegreen', cex.axis = 0.9, font =3, family = 'mono')
-------------------------------------------------------------------------------------------------------
ts.plot(df,col=c(rep("blue",3),rep("black",3))) A-B-C-D-E-F A     B     C     D     E     F
Blue  Blue  Blue  Black Black Black A  B    C
2003-07 445 48 1126
2003-08 429 77 1179
2003-09 421 80 1077 445->429->421 48->77->80 1126->1179->1077 ts.plot(df,col=rep(c("black","blue"),each=3)) each= dput df$X 1,2,3 factor ts.plot(df[-1],col=c(rep("blue",3),rep("black",3)),gpars=list(xaxt="n"))
axis(1,labels=as.character(df$X),at=1:3)
-------------------------------------------------------------------------------------------------------
ylabel <- c(0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6, 1.8, 2.0, 2.2, 2.4, 2.6)
y_range <- range(0, ylabel)
0.2*0:y_range[1] R> 0.2*0:y_range[1]
[1] 0 y_range R> 0.2*0:y_range[2]
[1] 0.0 0.2 0.4
R> 0:y_range[2]
[1] 0 1 2 : x:y seq(from = x, to = y, by = 1) 2.6+1 2.6 to 0, 1, 2 ylabel <- seq(0, 2.6, by = 0.2)
axis(2, at = ylabel) ylabel R> ylabel
[1] 0.0 0.2 0.4 0.6 0.8 1.0 1.2 1.4 1.6 1.8 2.0 2.2 2.4 2.6 dat <- data.frame(y = runif(20, min = 0, max = 3),
                  x = rnorm(20))

plot(y ~ x, data = dat, axes = FALSE)
ylabel <- seq(0, 2.6, by = 0.2)
axis(1)
axis(2, at = ylabel, las = 1)
box()
-------------------------------------------------------------------------------------------------------
polygon y98 = aggregate(gcdata$Pause.s. ~ hours, data=gcdata, FUN=q98)
y02 = aggregate(gcdata$Pause.s. ~ hours, data=gcdata, FUN=q02)
ymax = aggregate(gcdata$Pause.s. ~ hours, data=gcdata, FUN=max)
ymin = aggregate(gcdata$Pause.s. ~ hours, data=gcdata, FUN=min)
ymean = aggregate(gcdata$Pause.s. ~ hours, data=gcdata, FUN=mean)

x = ymean[,1]
y1 = cbind(y02[,2], ymean[,2], y98[,2])
y2 = cbind(ymin[,2], ymean[,2], ymax[,2])

plotAreaCI(x,y2, ylim=c(0,2), xlab="time", ylab="variable")
plotAreaCI(x,y1, ylim=c(0,2), poly.col="blue", add=TRUE) plotAreaCI(x,y2, ylim=c(0,2), xlab="time", ylab="variable", nice.x = TRUE)
plotAreaCI(x,y1, ylim=c(0,2), mean.lwd=2, poly.col="blue", add=TRUE) plotAreaCI plotAreaCI = function(x, y, add=FALSE, nice.x = FALSE,
                          xlim=NULL, ylim=NULL,
                          mean.col="black", mean.lwd=1.5,
                          poly.col="gray", poly.lty=3,
                          xlab=NULL, ylab=NULL, main="",
                          ...) {
      isFactorX = isClass("factor", x)
      if(isFactorX) {
        x.label = x
        x = as.numeric(x)
      }
      if(is.null(xlim)) xlim=range(x, na.rm=TRUE)
      if(is.null(ylim)) ylim=range(y, na.rm=TRUE)
      x.pol = c(x, rev(x), x[1])
      y.pol = c(y[,1], rev(y[,3]), y[,1][3])
      if(!add) {
        plot.new()
        plot.window(xlim=xlim, ylim=ylim, ...)
        if(!nice.x & isFactorX) {
          axis(1, at=x, labels=x.label)
        } else {
          xticks = axTicks(1)
          if(isFactorX) {
            xticks = xticks[xticks>=1]
            axis(1, at=xticks, labels=x.label[xticks])
          } else {
            axis(1)
          }
        }
            axis(2, las=1)
        box()
        title(xlab=xlab, ylab=ylab, main=main)
      }
      polygon(x.pol, y.pol, col=poly.col, lty=poly.lty)
      lines(x, y[,2], col=mean.col, lwd=mean.lwd)
      return(invisible())
    }
-------------------------------------------------------------------------------------------------------
xkcd_line <- function(x, y, color) {
  len <- length(x);
  rg <- par("usr");
  yjitter <- (rg[4] - rg[3]) / 1000;
  xjitter <- (rg[2] - rg[1]) / 1000;
  x_mod <- x + rnorm(len) * xjitter;
  y_mod <- y + rnorm(len) * yjitter;
  lines(x_mod, y_mod, col='white', lwd=10);
  lines(x_mod, y_mod, col=color, lwd=5);
} xkcd_axis <- function() {
  rg <- par("usr");
  yaxis <- 1:100 / 100 * (rg[4] - rg[3]) + rg[3];
  xaxis <- 1:100 / 100 * (rg[2] - rg[1]) + rg[1];
  xkcd_line(1:100 * 0 + rg[1] + (rg[2]-rg[1])/100, yaxis,'black')
  xkcd_line(xaxis, 1:100 * 0 + rg[3] + (rg[4]-rg[3])/100, 'black')
} data <- data.frame(x=1:100)
data$one <- exp(-((data$x - 50)/10)^2)
data$two <- sin(data$x/10)
plot.new()
plot.window(
    c(min(data$x),max(data$x)),
    c(min(c(data$one,data$two)),max(c(data$one,data$two))))
xkcd_axis()
xkcd_line(data$x, data$one, 'red')
xkcd_line(data$x, data$two, 'blue')
-------------------------------------------------------------------------------------------------------
library(dynlm)
set.seed(771104)
x <- 5 + seq(1, 10, len=100) + rnorm(100)
y <- x + rnorm(100)
model <- dynlm(x ~ y)

par(oma=c(1,1,1,2))
plotModel(x, model) # works with models which accept 'predict' and 'residuals' plotModel plotModel =  function(x, model) {
  ymodel1 = range(x, fitted(model), na.rm=TRUE)
  ymodel2 = c(2*ymodel1[1]-ymodel1[2], ymodel1[2])
  yres1   = range(residuals(model), na.rm=TRUE)
  yres2   = c(yres1[1], 2*yres1[2]-yres1[1])
  plot(x, type="l", col="red", lwd=2, ylim=ymodel2, axes=FALSE,
       ylab="", xlab="")
  axis(1)
  mtext("residuals", 1, adj=0.5, line=2.5)
  axis(2, at=pretty(ymodel1))
  mtext("observed/modeled", 2, adj=0.75, line=2.5)
  lines(fitted(model), col="green", lwd=2)
  par(new=TRUE)
  plot(residuals(model), col="blue", type="l", ylim=yres2, axes=FALSE, 
       ylab="", xlab="")
  axis(4, at=pretty(yres1))
  mtext("residuals", 4, adj=0.25, line=2.5)
  abline(h=quantile(residuals(model), probs=c(0.1,0.9)), lty=2, col="gray")
  abline(h=0)
  box()  
}
-------------------------------------------------------------------------------------------------------
graphics # Faking the data, since you didn't provide any
Gene <- data.frame(matrix(rweibull(100*4, 1), 100))
names(Gene) <- paste0("Ind", 1:4)
Gene <- rep(list(Gene), 4)

# Setup the panels
layout(t(1:4))
par(oma=c(2, 4, 4, 0), mar=rep(1, 4), cex=1)
# `mar` controls the space around each boxplot group

# Calculating the range so that the panels are comparable
my.ylim <- c(min(sapply(Gene, min)), max(sapply(Gene, max)))

# Plot all the boxes
for(i in 1:length(Gene)){
    boxplot(Gene[[i]], ylim=my.ylim, axes=FALSE)
    mtext(paste("Gene", i), 1, 0)
    if(i == 1){
        axis(2, las=1)
        mtext("Expression or what you have", 2, 3)
    }
}
title("Look at all my genes!", outer=TRUE) Gene[[i]] get(paste0("Gene", i)) my.ylim <- ... min(c(min(Gene1), min(Gene2) ...
-------------------------------------------------------------------------------------------------------
barplot multipleHist <- function(l, col=rainbow(length(l))) {
    ## create hist for each list element
    l <- lapply(l, hist, plot=FALSE);

    ## get mids
    mids <- unique(unlist(lapply(l, function(x)x$mids)))

    ## get densities
    densities <- lapply(l, function(x)x$density[match(x=mids, table=x$mids, nomatch=NA)]);

    ## create names
    names <- unique(unlist(lapply(l, function(x)x$breaks)))

    a <- head(names, -1)
    b <- names[-1]
    names <- paste("(", a, ", ", b, "]", sep="");

    ## create barplot list
    h <- do.call(rbind, densities);

    ## set names
    colnames(h) <- names;

    ## draw barplot
    barplot(h, beside=TRUE, col=col);

    invisible(l);
} x <- lapply(c(1, 1.1, 4), rnorm, n=1000)
multipleHist(x) multipleHist <- function(l, col=rainbow(length(l))) {
    ## create hist for each list element
    l <- lapply(l, hist, plot=FALSE);

    ## get mids
    mids <- unique(unlist(lapply(l, function(x)x$mids)))

    ## get densities
    densities <- lapply(l, function(x)x$density[match(x=mids, table=x$mids, nomatch=NA)]);

    ## create names
    breaks <- unique(unlist(lapply(l, function(x)x$breaks)))

    a <- head(breaks, -1)
    b <- breaks[-1]
    names <- paste("(", a, ", ", b, "]", sep="");

    ## create barplot list
    h <- do.call(rbind, densities);

    ## set names
    colnames(h) <- names;

    ## draw barplot
    barplot(h, beside=TRUE, col=col, xaxt="n");

    ## draw x-axis
    at <- axTicks(side=1, axp=c(par("xaxp")[1:2], length(breaks)-1))
    labels <- seq(min(breaks), max(breaks), length.out=1+par("xaxp")[3])
    labels <- round(labels, digits=1)
    axis(side=1, at=at, labels=breaks)

    invisible(l);
}
-------------------------------------------------------------------------------------------------------
plot(1:length(sample.list),ylim=c(0,max(unlist(sample.list))),xaxt="n",ann=FALSE)
axis(1,at=1:length(sample.list),labels=1:length(sample.list))

invisible(
  sapply(
      1:length(sample.list),
      function(x) {
        tmp2plot <- sample.list[[x]]
        points(rep(x,length(tmp2plot)),unlist(tmp2plot),col=1:length(tmp2plot),pch=19)
      }
  )
)

title(xlab="Index",ylab="Value")
-------------------------------------------------------------------------------------------------------
else mtext(side = 1, "Value", line = 2) if (key) {
        par(mar = c(5, 4, 2, 1), cex = 0.75)
        tmpbreaks <- breaks
        if (symkey) {
            max.raw <- max(abs(c(x, breaks)), na.rm = TRUE)
            min.raw <- -max.raw
            tmpbreaks[1] <- -max(abs(x), na.rm = TRUE)
            tmpbreaks[length(tmpbreaks)] <- max(abs(x), na.rm = TRUE)
        }
        else {
            min.raw <- min(x, na.rm = TRUE)
            max.raw <- max(x, na.rm = TRUE)
        }
        z <- seq(min.raw, max.raw, length = length(col))
        image(z = matrix(z, ncol = 1), col = col, breaks = tmpbreaks, 
            xaxt = "n", yaxt = "n")
        par(usr = c(0, 1, 0, 1))
        lv <- pretty(breaks)
        xv <- scale01(as.numeric(lv), min.raw, max.raw)
        axis(1, at = xv, labels = lv)
        if (scale == "row") 
            mtext(side = 1, "Row Z-Score", line = 2)
        else if (scale == "column") 
            mtext(side = 1, "Column Z-Score", line = 2)
        else mtext(side = 1, "Value", line = 2)
 .... lots more code below heatmap.2 heatmap.2 <-
-------------------------------------------------------------------------------------------------------
as.yearmon() dat library(zoo)
dat$date <- as.yearmon(dat$date, "%YM%m") dat <- read.table(text = "date    x   x2
1975M1  112.44  113.12
1975M2  113.1   114.36
1975M3  115.04  114.81
1975M4  117.65  115.35
1975M5  119.5   116.92
1975M6  121.4   118.56
1975M7  120.64  118.97
1975M8  119.12  119.84
1975M9  118.91  120.59
1975M10 120.58  122.3
1975M11 121.26  123.35
1975M12 122.34  123.33", header = TRUE) xts as.yearmon() library(xts) # Will also load zoo
dat.xts <- xts(dat[-1], 
               order.by = as.yearmon(dat$date, "%YM%m"))
dat.xts
#               x     x2
# Jan 1975 112.44 113.12
# Feb 1975 113.10 114.36
# Mar 1975 115.04 114.81
# Apr 1975 117.65 115.35
# May 1975 119.50 116.92
# Jun 1975 121.40 118.56
# Jul 1975 120.64 118.97
# Aug 1975 119.12 119.84
# Sep 1975 118.91 120.59
# Oct 1975 120.58 122.30
# Nov 1975 121.26 123.35
# Dec 1975 122.34 123.33 plot.zoo(dat.xts) plot.zoo(dat.xts, 
         plot.type="single", 
         col = c("red", "blue")) set.seed(1)
dat <- data.frame(date = paste0(rep(1975:1977, each = 12), 
                                "M", rep(1:12, times = 3)),
                  x1 = runif(36, min = 100, max = 140),
                  x2 = runif(36, min = 100, max = 140))
library(zoo) # xts is actually unnecessary if this is all you're doing
# Convert your data to a `zoo` object
dat.z <- zoo(dat[-1], order.by = as.yearmon(dat$date, "%YM%m")) plot(dat.z, screen = 1, col = 1:2) xaxt = "n" plot(dat.z, screen = 1, col = 1:2, xaxt = "n") ?plot.zoo tt <- time(dat.z)
# The following is just the sequence 1:36. 
#   If you wanted only every third month plotted,
#   use a sequence like ix <- seq(1, length(tt), 3)
ix <- seq_along(tt) 
# What format do you want for your labels.
#   This yields abbreviated month - abbreviated year
fmt <- "%b-%y" 
labs <- format(tt, fmt) # Generate the vector of your labels las = 2 
axis(side = 1, at = tt[ix], labels = labs[ix], tcl = -0.7, cex.axis = 0.7, las = 2) 
1977.15 pretty()
-------------------------------------------------------------------------------------------------------
expression paste axis(4,at=c(0.75,1.75),labels=c(expression(alpha==0.1),expression(alpha==0.2)),las=1)
-------------------------------------------------------------------------------------------------------
op <- par(mar = c(5,4,4,6) + 0.1)
plot(1:10)
axis(1)
labs <- lapply(alpha, function(x) bquote(alpha == .(x)))
axis(4, at = seq(1, by = 2, length = 5), labels = do.call(expression, labs), las = 1)
par(op) > labs <- lapply(alpha, function(x) bquote(alpha == .(x)))
> labs
[[1]]
alpha == 0.1

[[2]]
alpha == 0.05

[[3]]
alpha == 0.01

[[4]]
alpha == 0.005

[[5]]
alpha == 0.001 do.call() > do.call(expression, labs)
expression(alpha == 0.1, alpha == 0.05, alpha == 0.01, alpha == 
    0.005, alpha == 0.001) labs <- do.call(expression, lapply(alpha, function(x) bquote(alpha == .(x))))
axis(4, at = seq(1, by = 2, length = 5),labels = labs, las = 1)
-------------------------------------------------------------------------------------------------------
library(lattice)
library(grid)  # needed for grid.text

# data

Lines.raw <- "Date  Fo  Co
day1  57.1  13.9
day2  57.7  14.3
day3  57.8  14.3
"

DF <- read.table(textConnection(Lines.raw), header = TRUE)


par.settings <- list(
    layout.widths = list(left.padding = 10, right.padding = 20),
    layout.heights = list(bottom.padding = 10, top.padding = 10)
)

barchart(Co ~ Date, DF, default.scales = list(y = list(relation = "free")),
    ylab = "C", par.settings = par.settings)

trellis.focus("panel", 1, 1, clip.off = TRUE)
  pr <- pretty(DF$Fo)
  at <- 5/9 * (pr - 32)
  panel.axis("right", at = at, lab = pr, outside = TRUE)
  grid.text("F", x = 1.1, rot = 90) # right y axis label
trellis.unfocus()
-------------------------------------------------------------------------------------------------------
col.axis # there were four long pages of code before this section:

axis(1, 1:nc, labels = labCol, las = 2, line = -0.5, tick = 0, # original linecol.axis="green",   # added argumentcex.axis = cexCol)
if (!is.null(xlab)) 
        mtext(xlab, side = 1, line = margins[1] - 1.25)
axis(4, iy, labels = labRow, las = 2, line = -0.5, tick = 0, # original line col.axis="green",   # added argumentcex.axis = cexRow)
-------------------------------------------------------------------------------------------------------
value df$trimval <- pmin(df$value, 2)  
 # the range in the example below is roughly -4.5 to 4.5 contour.plot require(reshape)
  require(mapdata)
  require(mapproj)
  df <- data.frame(value=rnorm( 480*241), x=seq(0,360,length.out=480),y=seq(-90,90,length.out=241) )
df$trimval <- pmin(df$value, 2)

  dfc <- cast(df[-1], x ~ y)
  mm<-as.matrix(dfc,ncol=480,nrow=241)
  filled.contour(x=seq(0,360,length.out=480),y=seq(-90,90,length.out=241),mm,
         color.palette = colorRampPalette(c("lightblue", "blue","violet", "black")),
         xlab = "Longitude (°)", ylab = "Latitude (°)",
         plot.axes = {axis(1); axis(2);            
                      map('world2Hires',
                      xlim = c(0, 360), 
                      ylim = c(-90, 90), 
                      add = T, col = "black")}
                )
-------------------------------------------------------------------------------------------------------
axis ?axis ... ...: other graphical parameters may also be passed as arguments to
      this function, particularly, ‘cex.axis’, ‘col.axis’ and
      ‘font.axis’ for axis annotation, ‘mgp’ and ‘xaxp’ or ‘yaxp’
      for positioning, ‘tck’ or ‘tcl’ for tick mark length and
      direction, ‘las’ for vertical/horizontal label orientation,
      or ‘fg’ instead of ‘col’, and ‘xpd’ for clipping.  See ‘par’
      on these. cex.axis axis plot x1 <- runif(10)
x2 <- runif(10) * 2 + 32.5
y <- runif(10) * 300

par(mar=c(4, 4, 8, 4))    
plot(x2,y, type="l",col="darkgrey",ylim=rev(range(0,300)),las=2,xlim=(range(32.5,34.5)),xaxt='n',xlab='',font.axis=2,lwd=3,ylab="Depth [m]",font=2,font.lab=2,cex.lab=1.3,cex.axis=1.2)

# added in various font/axis labels as in above
axis(side=3, line=4,font.axis=2,font.lab=2,cex.lab=1.3,cex.axis=1.2)

par(new=TRUE)
plot(x1,y, type="l",col="black",ylim=rev(range(0,300)),las=2,xaxt='n',xlab='',lwd=3,ylab='Depth [m]',font=2,font.lab=2,cex.lab=1.3,cex.axis=1.2)
axis(side=3, line=0,font.axis=2,font.lab=2,cex.lab=1.3,cex.axis=1.2) axis plot plot axis
-------------------------------------------------------------------------------------------------------
dat <- read.table(textConnection("row.names   Collection_date temprature  col_yr  col_mnth
  1   1   4-Aug-04    27  2004    8
  2   2   9-Aug-04    26  2004    8
  3   3   4-Aug-04    27  2004    8
  4   4   9-Aug-04    26  2004    8
  5   5   9-Aug-04    26  2004    8
  6   6   9-Aug-04    26  2004    8
  1031 1031   6-Aug-06    32    2006    8")) dat$Collection_date <- strptime(dat$Collection_date,"%d-%b-%y") ax_month <- seq(min(dat$Collection_date),max(dat$Collection_date),"month")
ax_year <- seq(min(dat$Collection_date),max(dat$Collection_date),"year") plot(NA, xaxt="n",type="n", ylab="Temperature", xlab=NA,
     xlim=range(seq_along(ax_month)), ylim=range(dat$temprature))
axis(3,at=seq_along(ax_month), labels=format(ax_month,"%m"))
mtext(format(ax_year,"%Y"), side=3, line=3, at=seq(1,length(ax_month), by=12)) for(i in seq_along(ax_month)){
    sub_dat <- dat[format(dat$Collection_date, "%m-%Y") == format(ax_month[i], "%m-%Y"),]
    boxplot(sub_dat$temprature, add=TRUE, axes=FALSE, at=i)
    }
-------------------------------------------------------------------------------------------------------
log x<-1:100
y<-1:100
plot(log(x,base=10),y,axes=F)
axis(2)
axis(1,at=0:2,labels=10^(0:2))
-------------------------------------------------------------------------------------------------------
plot(x, y, log='x') xnew <- ifelse(x<10, x, x/10)
plot(xnew, y, axes=FALSE, xlab='x')
axis(1, at=c(0, 10, 20), labels=c(0, 10, 100))
axis(2)
box()
-------------------------------------------------------------------------------------------------------
par('mar') pdf(file = "ExampleOutput2.pdf",
    width = 6.61,
    height = 6.61,
    pointsize = 10
    )
set.seed(42)
catA <- factor(c("m100", "m500", "m1000", "m2000", "m3000", "m5000"))
catB <- factor(20:28)
samples <- 100
rsample <- function(v) v[ceiling(runif(samples, max=length(v)))]
Tab <- data.frame(catA = rsample(catA),
                  catB = rsample(catB),
                  valA = rnorm(samples, 150, 8),
                  valB = pmin(1,pmax(0,rnorm(samples, 0.5, 0.3))))
par(mfrow = c(2,2), mar= c(3, 4, 1, 1) + 0.1)
for (i in 0:3) {
  x <- Tab[[1 + i %% 2]]
  plot(x, Tab[[3 + i %/% 2]], mar= if(i %/%2 == 0) {c(4, 4, 1, 1) + 0.1 
                                              }else{c(1, 1, 1, 1) + 0.1},
       xlab = if (i %/% 2 == 1) "Some Categories" else NULL,
       ylab = if (i %% 2 == 0) "Some Values" else NULL,
       axes = FALSE
       )
  axis(side = 1,at=1:nlevels(x), labels = if (i %/% 2 == 1) levels(x) else FALSE)
  axis(side = 2, labels = (i %% 2 == 0))
  box(which = "plot", bty = "l")
}
par(mfrow = c(1,1))
dev.off()
-------------------------------------------------------------------------------------------------------
title() outer = TRUE op <- par(mfrow = c(2,2),
          oma = c(5,4,0,0) + 0.11, cex.axis = 1.2, col = axisCol
          mar = c(0,0,1,1) + 0.1) op 5 4 mar mar for() title(xlab = "Some Categories",
      ylab = "Some Values",
      outer = TRUE, line = 3) set.seed(42)
catA <- factor(c("m100", "m500", "m1000", "m2000", "m3000", "m5000"))
catB <- factor(20:28)
samples <- 100
rsample <- function(v) v[ceiling(runif(samples, max=length(v)))]
Tab <- data.frame(catA = rsample(catA),
                  catB = rsample(catB),
                  valA = rnorm(samples, 150, 8),
                  valB = pmin(1,pmax(0,rnorm(samples, 0.5, 0.3))))
op <- par(mfrow = c(2,2),
          oma = c(5,4,0,0) + 0.1,
          mar = c(0,0,1,1) + 0.1)
for (i in 0:3) {
  x <- Tab[[1 + i %% 2]]
  plot(x, Tab[[3 + i %/% 2]], axes = FALSE)
  axis(side = 1,at=1:nlevels(x),labels = if (i %/% 2 == 1) levels(x) else FALSE)
  axis(side = 2, labels = (i %% 2 == 0))
  box(which = "plot", bty = "l")
}
title(xlab = "Some Categories",
      ylab = "Some Values",
      outer = TRUE, line = 3)
par(op)
-------------------------------------------------------------------------------------------------------
box() frame()
plot.window(xlim=c(0,1), ylim=c(-.6, .8))
axis(1, at=c(0, .2, .4, .6, .8, 1.0), lwd=2)
axis(2, at=c(-.6, -.4, -.2, 0, .2, .4, .6, .8), lwd=2)
box(lwd = 2)
-------------------------------------------------------------------------------------------------------
plot(y, xaxt="n")
axis(1, at=1:length(x), labels=x) ?par ?axis
-------------------------------------------------------------------------------------------------------
output$plot_Total <- reactivePlot(function() { 
  plot.new()
   plot.window(xlim=c(1850,2020), ylim = c(0,5000000))
   axis(1)
   axis(2)
   title(main="Numbers over the years")
   title(xlab="Year")
   title(ylab="Number of people")
   box()
   points(dat$Year, dat$Total, col="red")
   lines(dat$Year, dat$Total, col="red")
  if (input$RC) {   lines(dat$Year, dat$dat)}
  })
-------------------------------------------------------------------------------------------------------
VerticalHist <- function(x, xscale = NULL, xwidth, hist,
                         fillCol = "gray80", lineCol = "gray40") {
    ## x (required) is the x position to draw the histogram
    ## xscale (optional) is the "height" of the tallest bar (horizontally),
    ##   it has sensible default behavior
    ## xwidth (required) is the horizontal spacing between histograms
    ## hist (required) is an object of type "histogram"
    ##    (or a list / df with $breaks and $density)
    ## fillCol and lineCol... exactly what you think.
    binWidth <- hist$breaks[2] - hist$breaks[1]
    if (is.null(xscale)) xscale <- xwidth * 0.90 / max(hist$density)
    n <- length(hist$density)
    x.l <- rep(x, n)
    x.r <- x.l + hist$density * xscale
    y.b <- hist$breaks[1:n]
    y.t <- hist$breaks[2:(n + 1)]

    rect(xleft = x.l, ybottom = y.b, xright = x.r, ytop = y.t,
         col = fillCol, border = lineCol)
}



## Usage example
require(plyr) ## Just needed for the round_any() in this example
n <- 1000
numberOfHists <- 4
data <- data.frame(ReleaseDOY = rnorm(n, 110, 20),
                   bin = as.factor(rep(c(1, 2, 3, 4), n / 4)))
binWidth <- 1
binStarts <- c(1, 2, 3, 4)
binMids <- binStarts + binWidth / 2
axisCol <- "gray80"

## Data handling
DOYrange <- range(data$ReleaseDOY)
DOYrange <- c(round_any(DOYrange[1], 15, floor),
                      round_any(DOYrange[2], 15, ceiling))

## Get the histogram obects
histList <- with(data, tapply(ReleaseDOY, bin, hist, plot = FALSE,
    breaks = seq(DOYrange[1], DOYrange[2], by = 5)))
DOYmean <- with(data, tapply(ReleaseDOY, bin, mean))

## Plotting
par(mar = c(5, 5, 1, 1) + .1)
plot(c(0, 5), DOYrange, type = "n",
     ann = FALSE, axes = FALSE, xaxs = "i", yaxs = "i")

axis(1, cex.axis = 1.2, col = axisCol)
mtext(side = 1, outer = F, line = 3, "Length at tagging (mm)",
      cex = 1.2)
axis(2, cex.axis = 1.2, las = 1, line = -.7, col = "white",at = c(75, 107, 138, 169),labels = c("March", "April", "May", "June"), tck = 0)
mtext(side = 2, outer = F, line = 3.5, "Date tagged", cex = 1.2)
box(bty = "L", col = axisCol)

## Gridlines
abline(h = c(60, 92, 123, 154, 184), col = "gray80")

biggestDensity <- max(unlist(lapply(histList, function(h){max(h[[4]])})))
xscale <- binWidth * .9 / biggestDensity

## Plot the histograms
for (lengthBin in 1:numberOfHists) {
    VerticalHist(binStarts[lengthBin], xscale = xscale,
                         xwidth = binWidth, histList[[lengthBin]])
    }
-------------------------------------------------------------------------------------------------------
Heatmap<-function(data.mat,main.str="heatmap"){

     xx <<- 0:dim(data.mat)[1] 
     yy <<- 0:dim(data.mat)[2] 
     zz <<- log(data.mat+1)
     plot.call = "image( x=xx,y=yy, z=zz,col = heat.colors(30),axes = FALSE);
     axis(1,0.5:(dim(data.mat)[1]-0.5),
     labels=rownames(data.mat),
     las = 2, line = -0.5, tick = 0,cex.axis =1);
     axis(4,0.5:(dim(data.mat)[2]-0.5),
     labels=colnames(data.mat),
     las = 2, line = -0.5, tick = 0,cex.axis =.8)"
     mai.mat = matrix(c(1.5,.5,.5,1.5), ncol=4)
     mai.prc = FALSE
     xy.labels=list(nb_of_sequences=t(data.mat))
     x.labels=data.frame(City=rownames(data.mat))
     y.labels=data.frame(Order=colnames(data.mat))

     imagesend(plot.call=plot.call,
        y.pos=yy,
        x.pos=xx,
        mai.mat=mai.mat, mai.prc=mai.prc,
        xy.type="image.box",
        x.labels=x.labels,
        y.labels=y.labels,
        xy.labels = xy.labels,
        image.size="500x800",
        fname.root="exPlotImage",
        font.size=18)

  rm(xx,envir = .GlobalEnv)
  rm(yy,envir = .GlobalEnv)
  rm(zz,envir = .GlobalEnv)
  return (0)
}
-------------------------------------------------------------------------------------------------------
datf datf <- datf[order(datf$pollut, datf$lag), ] datfPlusNA <- lapply(split(datf, datf$pollut), function(x) rbind(NA, x, NA))
datf <- do.call(rbind, datfPlusNA) nr <- nrow(datf)  # find out how many rows all together
with(datf, {# this allows entering your commands more succinctly
    # first you could set up the plot so you can select the order of drawing
    plot(1:nr, or, ylim = c(0.8, 1.3), type = 'n', xaxt = 'n', xlab = '', ylab = 'Odds Ratio and 95% CI', frame.plot = TRUE, panel.first = grid(nx = NA, ny = NULL))
    # arrows(1:nr, lcl, 1:nr, ucl, length = 0.02, angle = 90, code = 3, col = factor(lag)) 
    # you could use arrows above but you don't want ends so segments is easier
    segments(1:nr, lcl, 1:nr, ucl, col = factor(lag))
    # add your points
    points(1:nr, or, pch = 19, cex = 0.6)
    xLabels <- na.omit(unique(pollut))
    axis(1, seq(4, 34, by = 6) - 0.5, xLabels)
})
abline(h = 1.0)
-------------------------------------------------------------------------------------------------------
# plot the results
boxplot(base, xlim=c(1,4), col="gray", xaxt="n", ylab="Base values", outline=FALSE)
axis(side=1,1,labels=('base'))
par(new=TRUE)
boxplot(exps, col="red", ylim=c(-200,200), outline=FALSE, axes=FALSE)
axis(4)
axis(side=1,1:3,labels=c("% exp1","% exp2","% exp3"))
grid() boxplot base exps axis(side=1,1:3,labels=c("% exp1","% exp2","% exp3")) #divide your plottin area into 2 columns with one row.
par(mfrow = c(1, 2))
# plot the results
boxplot(base, col="gray", xaxt="n", ylab="Base values", outline=FALSE,axes=FALSE)
axis(2)
axis(side=1,1,labels=('base'))
segments(0,0,1,0)
boxplot(exps,col="red", xaxt="n", ylim=c(-200,200), outline=FALSE, axes=FALSE)
axis(4)
axis(side=1,at=(1:3),labels=c("% exp1","% exp2","% exp3"))
-------------------------------------------------------------------------------------------------------
zoo xts t <- seq(ISOdatetime(2012,1,1,11,10,25), ISOdatetime(2012,03,31,11,10,25), "hours")
dx <- data.frame(t=t, Temp=runif(length(t)))
plot(dx$t, dx$Temp/10, xaxt='n')
axis(1, at=as.POSIXct(unique(format(dx$t, '%Y-%m-%d')), format='%Y-%m-%d'),
     labels=unique(format(dx$t, '%Y-%m-%d')))
-------------------------------------------------------------------------------------------------------
hist() mids sample_avg <- sample(size=10000,x=seq(1,6),replace=TRUE)
foo <- hist(sample_avg, breaks =7, ylim=c(0,2000), 
    main = 'Histogram of Sample Average for 1 Coin Flip', xlab= 'Sample Average',
    xaxt="n")
axis(side=1,at=foo$mids,labels=seq(1,5))
-------------------------------------------------------------------------------------------------------
foo <- as.matrix(structure(list(Samp1 = c(84.1, 94.2, 29.5),
    Samp2 = c(45.2, 12.4, 10.5),Samp3 = c(34.3, 68, 43.2),
    Samp4 = c(54.6, 75.3, 39.5),Samp5 = c(76.2, 24.8, 45.5)),
  .Names = c("Samp1", "Samp2","Samp3", "Samp4", "Samp5"),
  class = "data.frame", row.names = c("Gene1","Gene2", "Gene3"))) plot(seq(1,ncol(foo)),foo[1,],xlab="",ylab="",xaxt="n",
  pch=21,bg=1,ylim=c(min(foo),max(foo)))
axis(side=1,at=seq(1,ncol(foo)),labels=colnames(foo))
for ( ii in 2:nrow(foo) ) points(seq(1,ncol(foo)),foo[ii,],pch=21,col=ii,bg=ii) col=ii,bg=ii ?palette ?legend
-------------------------------------------------------------------------------------------------------
set.seed(001)    
low <- runif(10,min=10, max=50)

high <- runif(10,min=10000, max=11000)
plot(
  high,
  type="l",
  ylim=c(0,11000)
)
lines(low, type="l")


plot(high,            
     type="l",              
     col="red",              
     bty='l',                
     ylab='', xlab='',      
     las=1,                 
     cex.axis=.75)     

par(new=TRUE)                

plot(low,
     type="l", 
     col="blue", 
     bty='n',                
     xaxt="n",               
     yaxt="n",               
     xlab="", ylab="", 
     cex.axis=.75)

axis(4, las=1, cex.axis=.75) 

legend('topright', c('high', 'low'), col=c('red', 'blue'), lty=1, bty='n', cex=.75)
-------------------------------------------------------------------------------------------------------
plot(c(1,3),range(mat1),type = "n",xaxt ="n")
points(1:3,mat1[,2])
points(1:3,mat1[,1],pch = "x")
axis(1,at = 1:3,labels = rownames(mat1))
-------------------------------------------------------------------------------------------------------
matplot() matplot(y = mat1, pch = c(4,1), col = "black", xaxt ="n",
        xlab = "x-axis", ylab = "y-axis")
axis(1, at = 1:nrow(mat1), labels = rownames(mat1))             ## Thanks, Joran
-------------------------------------------------------------------------------------------------------
probability=T probability=TRUE T TRUE x <- rgamma(327, 5, 3)

tmp <- hist(x, yaxt='n',ylab='Percent')
tmp2 <- pretty( tmp$counts/sum(tmp$counts)*100 )
axis(2, at=tmp2*sum(tmp$counts)/100, labels=tmp2)
-------------------------------------------------------------------------------------------------------
pdf("sample.pdf",width = 6.6 ,height = 4.2,family= "URWHelvetica",  encoding="KOI8-R") 
x<-c(1,2,3,4,5) 
y<-c(2,3,4,5,6) 
xlable<-c("ручка","книга","часы","ложка","смотреть") 
plot(x,y,xaxt="n")
axis(1,at=1:5,labels=xlable)
dev.off()
-------------------------------------------------------------------------------------------------------
ab ab xts xtsExtra xtsExtra library(xts)

ab=structure(c(-1, 0.579760106421202, -0.693649703427259, 0.0960078627769613, 
           0.829770469089809, -0.804276208608663, 0.72574639798749, 0.977165659135716, 
           -0.880178529686181, -0.662078620277974, -1, 2.35268982675599, 
           -0.673979231663719, 0.0673890875594205, 1.46584597734824, 0.38403707067242, 
           -1.53638088345349, 0.868743976582955, -1.8394614923913, 0.246736581314485), .Dim = c(10L, 2L), .Dimnames = list(NULL, c("a", "b")), index = structure(c(1354683600, 
          1354770000, 1354856400, 1354942800, 1355029200, 1355115600, 1355202000, 
          1355288400, 1355374800, 1355461200), tzone = "", tclass = "Date"), class = c("xts", 
          "zoo"), .indexCLASS = "Date", .indexTZ = "", tclass = "Date", tzone = "")

#Set up the plot area so that multiple graphs can be crammed together
#In the "par()" statement below, the "mar=c(0.3, 0, 0, 0)" part is used to change
#the spacing between the graphs.   "mar=c(0, 0, 0, 0)" is zero spacing.
par(pty="m", plt=c(0.1, 0.9, 0.1, 0.9), omd=c(0.1, 0.9, 0.2, 0.9), mar=c(0.3, 0, 0, 0))

#Set the area up for 2 plots
par(mfrow = c(2, 1))

#Build the x values so that plot() can be used, allowing more control over the format
xval <- index(ab)

#Plot the top graph with nothing in it =========================
plot(x=xval, y=ab$a, type="n", xaxt="n", yaxt="n", main="", xlab="", ylab="")
mtext(text="ab", side=3, font=2, line=0.5, cex=1.5)

#Store the x-axis data of the top plot so it can be used on the other graphs
pardat <- par()

#Layout the x axis tick marks
xaxisdat <- index(ab)

#If you want the default plot tick mark locations, un-comment the following calculation
#xaxisdat <- seq(pardat$xaxp[1], pardat$xaxp[2], (pardat$xaxp[2]-pardat$xaxp[1])/pardat$xaxp[3])

#Get the y-axis data and add the lines and label
yaxisdat <- seq(pardat$yaxp[1], pardat$yaxp[2], (pardat$yaxp[2]-pardat$yaxp[1])/pardat$yaxp[3])
axis(side=2, at=yaxisdat, las=2, padj=0.5, cex.axis=0.8, hadj=0.5, tcl=-0.3)
abline(v=xaxisdat, col="lightgray")
abline(h=yaxisdat, col="lightgray")
mtext(text="ab$a", side=2, line=2.3)
lines(x=xval, y=ab$a, col="red")
box() #Draw an outline to make sure that any overlapping abline(v)'s or abline(h)'s are covered

#Plot the 2nd graph with nothing in it ================================
plot(x=xval, y=ab$b,  type="n", xaxt="n", yaxt="n", main="", xlab="", ylab="")

#Get the y-axis data and add the lines and label
pardat <- par()
yaxisdat <- seq(pardat$yaxp[1], pardat$yaxp[2], (pardat$yaxp[2]-pardat$yaxp[1])/pardat$yaxp[3])
axis(side=2, at=yaxisdat, las=2, padj=0.5, cex.axis=0.8, hadj=0.5, tcl=-0.3)
abline(v=xaxisdat, col="lightgray")
abline(h=yaxisdat, col="lightgray")
mtext(text="ab$b", side=2, line=2.3)
lines(x=xval, y=ab$b, col="blue")
box() #Draw an outline to make sure that any overlapping abline(v)'s or abline(h)'s are covered

#Plot the X axis =================================================
axis(side=1, label=format(as.Date(xaxisdat), "%b %d\n%Y\n") , at=xaxisdat, padj=0.4, cex.axis=0.8, hadj=0.5, tcl=-0.3)
mtext(text="Date", side=1, line=2.5)
-------------------------------------------------------------------------------------------------------
log = 'y' at axis(2, at= exp(c(-6, -3, -1, 0, 1, 3, 6)), labels=c(-6, -3, -1, 0, 1, 3, 6)) set.seed(1)
TX <- data.frame(tx = gl(2,3), y= rlnorm(600, mean = -1, sd = 3))
boxplot( y~tx, data = TX, log = 'y',yaxt="n", las=2,  cex.axis=0.7)
axis(2, at= exp(c(-6, -3, -1, 0, 1, 3, 6)), labels=c(-6, -3, -1, 0, 1, 3, 6))
-------------------------------------------------------------------------------------------------------
xaxt="n" Freq_ <- seq(1.56, 35.1, by = 1.95)
Mean_ipsi <- (0.01 * Freq_)
ProbF <- 0.0

#First Version  
plot(x = Freq_, y = Mean_ipsi, 
     pch = 20,
     ylim = c(-0.5, .9),
     col = 1 + (ProbF < .05) + (ProbF < .01),
     xaxt = 'n',
     xlab = "Frequency (MHz)", ylab = "z-in minus z-out",
     main = "Temporal, Engle 1, Epi, subjectwise",
     yaxt = 'n')
mtext(text = seq(1.56, 35.1, by = 1.95),
      side = 1, at = seq(1.56, 35.1, by = 1.95), cex = .5,line = 0.25)
axis(1, at = Freq_, tick = TRUE, labels = NA)

#=============================================

#Second Version
plot(x = Freq_, y = Mean_ipsi, 
     pch = 20,
     ylim = c(-0.5, .9),
     col = "red",
     xlab = "Frequency (MHz)", ylab = "z-in minus z-out",
     main = "Temporal, Engle 1, Epi, subjectwise 
     \n p values for difference between ipsi and contra",
     yaxt = 'n', type = 'o')  ##### <----- add xaxt="n" here #####
mtext(text = seq(1.56, 35.1, by = 1.95),
      side = 1, at = seq(1.56, 35.1, by = 1.95),
      cex = .5,line = 0.25)
axis(1, at = Freq_, tick = TRUE, labels = NA)
-------------------------------------------------------------------------------------------------------
> with(df, plot(c2,1:10, yaxt="n"))
> axis(2, at=1:10, labels=df$c1) > p <- qplot(c2, 1:nrow(df),data=df) + scale_x_date(breaks="1 month")
> p
> p + scale_y_discrete( labels=df$c1)
-------------------------------------------------------------------------------------------------------
plot((1:100)^3, log = "y", yaxt = "n")
axis(2, at=axTicks(2,log=TRUE), labels=format(axTicks(2, log=TRUE), scientific=FALSE))
-------------------------------------------------------------------------------------------------------
text df <- data.frame(Rows = letters[6:10],value=c("L","L","L","L","N"))
x <- matrix(seq(1,10,by=0.1),ncol=5,nrow=5)
colnames(x) <- letters[1:5]
rownames(x) <- letters[6:10]
plot(hclust(t(dist(x))))
axis(1,at=seq(1,length(rownames(x)),1),labels=FALSE)
text(seq(1,length(rownames(x)),1),labels="\u2594",col=c(rep("red",2),"blue",rep("red",2)),cex=25,par("usr")[3]+0.005)
legend("topright",legend=c("L","N"),col=c("red","blue"))
-------------------------------------------------------------------------------------------------------
fill legend("topright", 
       legend = c("reading/Writing", "Speaking"), 
       fill = c("darkblue", "red")) heights1 = c(5, 5, 4.5, 4, 4, 4, 4.5, 2, 4, 4) # Your data matrix dimnames mydata <- matrix(heights1, ncol = 2, byrow = TRUE,
                 dimnames = list(c("Spanish", "English", "Hindi", 
                                   "Arabic", "Body Lang"),
                                 c("Reading/Writing", "Speaking")))
mydata # Much more meaningful to look at than a simple vector
#           Reading/Writing Speaking
# Spanish               5.0        5
# English               4.5        4
# Hindi                 4.0        4
# Arabic                4.5        2
# Body Lang             4.0        4 colors <- c("darkblue", "red") # Define the colors you're using legend.text = TRUE, args.legend = list(x = "topright", bty = "n") barplot(t(mydata), beside = TRUE, col = colors, 
        ylim = c(0, 6), axes = FALSE,
        xlab = "Language starting with mostly used",
        main = "Languages (Verbal & Non-verbal)") axis(2, at = 0:5, labels = 0:5)
legend("topright", colnames(mydata), fill = colors, bty = "n")
-------------------------------------------------------------------------------------------------------
myd <- data.frame(period = c("", "Triassic", "Jurasic", 
                             "Cretaceous", "Cenzoic", ""), 
                  myears = c(260, 245, 208, 145, 65, -5), 
                  label = c(260, 226, 176,105, 32, -5))
myd2 <- data.frame(event = c("Dinosaurs_strt", "Birds", 
                             "Dinosaurs_ext", "Human"), 
                   myears = c(235, 200, 60, 0.5))
myd2$x <- 1
with(myd2, plot(x, myears, ylim = c(-5, 250), xlim = c(0, 10), 
                axes = FALSE, xlab = "", ylab = "", type = "n"))
with(myd2, text(x, myears, event, pos = 4, xpd = TRUE))
axis(side = 2, at = myd$label, labels = myd$period, las = 2)
X0 <- rep(myd2$x, 4)
Y0 <- myd2$myears
X1 <- rep(-.25, 4)
Y1 <- Y0
arrows(X0, Y0, X1, Y1) pch arrows
-------------------------------------------------------------------------------------------------------
myd <- data.frame (period = c("Triassic", "Jurasic", 


 "Cretaceous", "Cenzoic", "now"), myears = c(245, 208, 145, 65, 0), 
    label = c(226, 176,105, 32, NA ))
    myd2 <- data.frame (event = c("Diansaurs_strt", "Birds", "Diansaurs_ext", "Human"),
    myears = c(235, 200, 60, 0.5))
    myd2$x <- -0.25
    with (myd2, plot(x,myears,ylim=c(0,250), xlim = c(0, 10), 
    axes=F,xlab="",ylab="",type="p",pch=17, col = "green"))
    with (myd2, plot(x,myears,ylim=c(0,250), 
    xlim = c(0, 10), axes=F,xlab="",ylab="",type="p",pch="-", col = "green"))
    with (myd2,text(x,myears,event,pos=4,xpd=T), col = "green")
    axis(side=2,at = myd$label, labels = myd$period, tick = FALSE, las = 2, col = "green", )
    axis(side=2,at = myd$myears, labels = myd$myears,  las = 2, col = "green")
-------------------------------------------------------------------------------------------------------
ggplot2 ggplot ggplot(platelay, aes(y = factor(rown, rev(levels(rown))),x = factor(coln))) + 
     geom_point(aes(colour = colorvar), size =18)  +theme_bw() +
     labs(x=NULL, y = NULL) # plot with grey colour dictated by rank, no axes or labels
with(platelay, plot( x=as.numeric(coln), y= rev(as.numeric(rown)), pch= 19, cex = 2, 
 col = grey(rank(platelay[['colorvar']] ) / nrow(platelay)), axes = F, xlab= '', ylab = ''))
# add circular outline
with(platelay, points( x=as.numeric(coln), y= rev(as.numeric(rown)), pch= 21, cex = 2))
# add the axes
axis(3, at =1:12, labels = 1:12)
axis(2, at = 1:8, labels = LETTERS[8:1])
# the background grid
grid()
# and a box around the outside
box()
-------------------------------------------------------------------------------------------------------
d <- ggplot(platelay, aes(y=rown,x=factor(coln))) + 
  geom_point(aes(colour = colorvar), size =18) + theme_bw() data <- ggplot_build(d)$data[[1]]

 x <- data$x
 y <- data$y
 grid.newpage()
 pushViewport(plotViewport(c(4, 4, 2, 2)),
               dataViewport(x, y)) grid.ellipse(x, y,size=20,  ar = 2,angle=0,gp =gpar(fill=data$colour))
 grid.xaxis(at=c(labels=1:12,ticks=NA),gp=gpar(cex=2))
 grid.yaxis(at = 1:8,label=rev(LETTERS[1:8]),gp=gpar(cex=2))

 grid.roundrect(gp=gpar(fill=NA)) gpgrid <- gpar(col='grey',lty=2,col='white')
grid.segments(unit(1:12, "native") ,unit(0, "npc"), unit(1:12, "native"),unit(1, "npc"),gp=gpgrid)
grid.segments(unit(0, "npc"), unit(1:8, "native"), unit(1, "npc"),unit(1:8, "native"),gp=gpgrid)
upViewport()
-------------------------------------------------------------------------------------------------------
dev.new(width=6,height=4)

rown <- unique(platelay$rown)
coln <- unique(platelay$coln)

plot(NA,ylim=c(0.5,length(rown)+0.5),xlim=c(0.5,length(coln)+0.5),ann=FALSE,axes=FALSE)
box()

axis(2,at=seq_along(rown),labels=rev(rown),las=2)
axis(3,at=seq_along(coln),labels=coln)

colgrp <- findInterval(platelay$colorvar,seq(min(platelay$colorvar),max(platelay$colorvar),length.out=10))
colfunc <- colorRampPalette(c("green", "blue"))
collist <- colfunc(length(unique(colgrp))) 

symbols(platelay$coln,
        factor(platelay$rown, rev(levels(platelay$rown))),
        circles=rep(0.2,nrow(platelay)),
        add=TRUE,
        inches=FALSE,
        bg=collist[colgrp])
-------------------------------------------------------------------------------------------------------
my1 <- data.frame (company = rep(c("A", "B", "C"), each = 7), skillsDg = rep(c("Basic", "HighSc", "Undgd", "MAST", "PHD", "EXPD", "EXECT"), 3), number = c(200, 100, 40, 30, 10, 0, 0, 220, 110, 35, 10, 0, 4, 1, 140, 80, 120, 50, 52, 52, 3) )

my2 <- split(my1,my1$company) #split your dataframe into a list where each element is a company
# The next line create the layout
layout(matrix(1:(length(my2)+1), nrow=1), width=c(1,rep(4,length(my2))))
# Then we draw the x-axis:
par(mar=c(3,0,3,0))
plot(NA,axes=F, xlim=c(0,1),ylim=c(1,nlevels(my1$skillsDg)))
axis(side=4,tick=F,labels=unique(my1$skillsDg),
     at=seq_along(unique(my1$skillsDg)), las=2, line=-4)
# Then we apply a graphing function to each company:
lapply(my2,function(x){
    par(mar=c(3,0,3,0))
    plot(NA, xlim=c(-max(my1$number),max(my1$number)), 
             ylim=c(1,nlevels(my1$skillsDg)),axes=F)
    title(sub=x$company[1],line=1)
    abline(h=seq_along(x$skillsDg), col="grey80")
    polygon(x=c(x$number,rev(-1*x$number)), 
            y=c(seq_along(x$skillsDg),rev(seq_along(x$skillsDg))), 
            col=as.numeric(x$company))
    }) lapply layout(matrix(1:(length(my2)+1), nrow=1), width=c(1,rep(4,length(my2))))
par(mar=c(3,0,3,0))
plot(NA,axes=F, xlim=c(0,1),ylim=c(1,nlevels(my1$skillsDg)))
axis(side=4,tick=F,labels=unique(my1$skillsDg),
    at=seq_along(unique(my1$skillsDg)), las=2, line=-4)
lapply(my2,function(x){
    par(mar=c(3,0,3,0))
    plot(NA, xlim=c(-max(my1$number)-50,max(my1$number)+50), 
        ylim=c(1,nlevels(my1$skillsDg)),axes=F)
    title(sub=x$company[1],line=1)
    abline(h=seq_along(x$skillsDg), col="grey80")
    text(x=x$number+5, y=seq_along(x$skillsDg)+.1, label=x$number, pos=4)
    polygon(x=c(x$number,rev(-1*x$number)), 
        y=c(seq_along(x$skillsDg),rev(seq_along(x$skillsDg))), 
        col=as.numeric(x$company))
    })
-------------------------------------------------------------------------------------------------------
axis(side = 1, at = c([all the ticks you want])); 
ticks # Cumulative Distribuition
pdf("g1_3.pdf");

plot(x = f$V2, y = cumsum(f$V1), log = "x", pch = 3,
     xlab = "Frequency", ylab = "P(X <= x)", axes = FALSE);

ticks = c(1, 5, 10, 40, 150, 500, 1000);
axis(side = 1, at = ticks);
axis(side = 2);

abline(h = seq(0, 1, 0.2), v = ticks, col = "lightgray", lty = 3);
box();
-------------------------------------------------------------------------------------------------------
Data <- c(rnorm(1000,5,10),sample(-10000:10000,10))
> summary(Data)
     Min.   1st Qu.    Median      Mean   3rd Qu.      Max. 
-9669.000    -2.119     5.332    85.430    12.460  9870.000 hist(Data,
     xlim=c(-30,30),
     breaks=c(min(Data),seq(-30,30,by=5),max(Data))
     main="Center of Data"
     ) axis.break() plotrix require(plotrix)
 # rearrange data
 plotdata <- Data
 id <- plotdata < -30 | plotdata > 30
 plotdata[id] <- sign(plotdata[id])*35
 # plot histogram
 hist(plotdata,
      xlim=c(-40,40),
      breaks=c(-40,seq(-30,30,by=5),40),
      main="Untailed Data",
      xaxt='n'   # leave the X axis away
      )
 # Construct the X axis
 axis(1,at=c(-40,seq(-30,30,by=10),40),labels=c(min(Data),seq(-30,30,by=10),max(Data))
 )
 # add axis breaks
 axis.break(axis=1,breakpos=-35)
 axis.break(axis=1,breakpos=35) freq=TRUE hist()
-------------------------------------------------------------------------------------------------------
mylabd <- data.frame (company = rep(c("A", "B", "C"), each = 7),
                      skillsDg = rep(c("Basic", "HighSc", "Undgd", "MAST", "PHD", "EXPD", "EXECT"), 3),
                      number = c(200, 100, 40, 30, 10, 0, 0,
                                 220, 110, 35, 10, 0, 4, 1,
                                 140, 80, 120, 50, 52, 52, 3)
)



## to comapre we need o have the same scales for all organizations
nskills <- nlevels(mylabd$skillsDg)
ncompany <- nlevels(mylabd$company)
barYscale <- c(0,  nskills) * 1.05
barXscale <- c(0, max(mylabd$number) )* 1.05
## the global scene
vp <- plotViewport(c(5, 4, 4, 1),
                   yscale = barYscale,
                   layout = grid.layout(nrow=1,ncol=nbars))

pushViewport(vp)
grid.rect()
grid.yaxis(at=c(1:nlevels(mylabd$skillsDg)),label=unique(mylabd$skillsDg))
grid.grill()

## split data by companya
data.splitted <- split(mylabd,f=mylabd$company)
lapply(1:3,function(company){

  x <- data.splitted[[company]]
  vv <- x$number
  companyName <- unique(x$company)

  pushViewport(viewport(layout.pos.col=company,    
                        xscale = barXscale,
                        yscale = barYscale))
  grid.rect()
 # grid.xaxis(at= mean(x$number),label = companyName)
  grid.xaxis()
  grid.polygon(x  = unit.c(unit(0.5,'npc')-unit(vv/2,'native'),
                           unit(0.5,'npc')+unit(rev(vv)/2,'native')),
               y  = unit.c(unit(1:nmeasures,'native'),
                           unit(rev(1:nmeasures),'native')),
               gp=gpar(fill = rainbow(nmeasures)[company]))
  grid.polygon(x  = unit.c(unit(0.5,'npc')-unit(vv/2,'native'),
                           unit(0.5,'npc')+unit(rev(vv)/2,'native')),
               y  = unit.c(unit(1:nmeasures,'native'),
                           unit(rev(1:nmeasures),'native')),
               id = c(1:nmeasures,rev(1:nmeasures)),
               gp=gpar(fill = NA))

  grid.text( x = unit(0.5,'npc'),
             y = unit(0.5,'native'),
             label = unique(x$company))

  popViewport()

})

popViewport()
-------------------------------------------------------------------------------------------------------
?grid par(las=1,bty="l")
h <- hist(bulkdata$discovered,breaks=bins,
     col='gray',ylab="Discovered",xlab="Year",main="",
     ylim=c(0,100),axes=FALSE)
yrs <- 1989:2012
yvals <- seq(0,100,by=10)
axis(1, at=yrs)
axis(2, at=yvals)
abline(h=yvals,v=yrs,col="gray",lty=3)
hist(bulkdata$discovered,breaks=bins,
     col='gray',ylab="Discovered",xlab="Year",main="", add=TRUE)
-------------------------------------------------------------------------------------------------------
?axis axis(side = 4) boxplot(rnorm(100))
axis(side = 4)
-------------------------------------------------------------------------------------------------------
axis.text.x library(jpeg)
img <- lapply(list.files(pattern="jpg"), readJPEG )
names(img) <- c("Anaphase", "Interphase", "Metaphase", "Prophase", "Telophase")

require(ggplot2)
require(grid)

# user-level interface to the element grob
my_axis = function(img) {
    structure(
      list(img=img),
      class = c("element_custom","element_blank", "element") # inheritance test workaround
    )
  }
# returns a gTree with two children: the text label, and a rasterGrob below
element_grob.element_custom <- function(element, x,...)  {
  stopifnot(length(x) == length(element$img))
  tag <- names(element$img)
  # add vertical padding to leave space
  g1 <- textGrob(paste0(tag, "\n\n\n\n\n"), x=x,vjust=0.6)
  g2 <- mapply(rasterGrob, x=x, image = element$img[tag], 
               MoreArgs = list(vjust=0.7,interpolate=FALSE,
                               height=unit(5,"lines")),
               SIMPLIFY = FALSE)

  gTree(children=do.call(gList,c(g2,list(g1))), cl = "custom_axis")
}
# gTrees don't know their size and ggplot would squash it, so give it room
grobHeight.custom_axis = heightDetails.custom_axis = function(x, ...)
  unit(6, "lines")

ggplot(myd) +
  geom_bar(aes(y = value, x = phase, fill = cat), stat="identity", position='dodge') +
  theme_bw() +
  theme(axis.text.x = my_axis(img),
          axis.title.x = element_blank())

ggsave("test.png",p,width=10,height=8)
-------------------------------------------------------------------------------------------------------
rainfall <- c(2, 5, 4, 5, 12)
days <- c("Mon","Tue","Wed","Thu","Fri")
plot (rainfall, xaxt="n")
axis(1, at=c(1,length(days)), lab=c(days[1], days[length(days)])) xaxt="n" plot axis
-------------------------------------------------------------------------------------------------------
## dput(read.csv("barcharttest.csv"))
x <- structure(list(ID = 1:7,
  sex = structure(c(1L, 1L, 1L, 2L, 2L, 1L, 2L), .Label = c("female", "male"),
   class = "factor"),
  val = c(309L, 192L, 384L, 27L, 28L, 245L, 183L),
  stat = structure(c(1L, 2L, 2L, 1L, 2L, 1L, 1L), .Label = c("NS", "sig"),
    class = "factor")),
               .Names = c("ID", "sex", "val", "stat"),
               class = "data.frame", row.names = c(NA, -7L)) ID    sex val stat
1  1 female 309   NS
2  2 female 192  sig
3  3 female 384  sig
4  4   male  27   NS
5  5   male  28  sig
6  6 female 245   NS
7  7   male 183   NS sexcols <- c("pink","blue")
## png("barplot.png")  ## for output graph
par(las=1,bty="l")  ## I prefer these settings; see ?par
b <- with(x,barplot(val,col=sexcols[sex])) ## b saves x coords of bars
legend("topright",levels(x$sex),fill=sexcols,bty="n")
## use xpd=NA to make sure that star on tallest bar doesn't get clipped;
##   pos=3 puts the text above the (x,y) location specified
text(b,x$val,ifelse(x$stat=="sig","*",""),pos=3,cex=2,xpd=NA)
axis(side=1,at=b,label=x$ID)
## dev.off()
-------------------------------------------------------------------------------------------------------
txtlab <- c("2", "4", "6", "8", "Inf")
txtpos <- c(1.25, 2, 3, 4, 4.75)
ctlns <- contourLines(x, y, z2, levels=c(3, 5, 7, 9))
filled.contour(x,y,z2,col=rainbow(200),nlevels=200, 
     plot.axes={axis(1); axis(2); text(txtpos, txtpos, txtlab, cex=1.5);
     sapply(1:4, function(x) lines(ctlns[[x]][[2]], ctlns[[x]][[3]], lwd=2))
})
-------------------------------------------------------------------------------------------------------
set.seed (123)
xvar <- round (rnorm (100, 54, 10), 0)
xyvar <- round (rnorm (100, 54, 10), 0)
myd <- data.frame (xvar, xyvar)
valut <- as.numeric (cut(c(myd$xvar,myd$xyvar), 12))
myd$xwt <- valut[1:100]
myd$xywt <- valut[101:200]
xy.pop <- data.frame (table (myd$xywt))
xx.pop <- data.frame (table (myd$xwt))


stickBoy <- function() {
  grid.circle(x=.5, y=.8, r=.1, gp=gpar(fill="red"))
  grid.lines(c(.5,.5), c(.7,.2)) # vertical line for body
  grid.lines(c(.5,.6), c(.6,.7)) # right arm
  grid.lines(c(.5,.4), c(.6,.7)) # left arm
  grid.lines(c(.5,.65), c(.2,0)) # right leg
  grid.lines(c(.5,.35), c(.2,0)) # left leg
  grid.lines(c(.5,.5), c(.7,.2)) # vertical line for body
  grid.text(x=.5,y=-0.3,label ='Male',
            gp =gpar(col='white',fontface=2,fontsize=32)) # vertical line for body
}

stickGirl <- function() {
  grid.circle(x=.5, y=.8, r=.1, gp=gpar(fill="blue"))
  grid.lines(c(.5,.5), c(.7,.2)) # vertical line for body
  grid.lines(c(.5,.6), c(.6,.7)) # right arm
  grid.lines(c(.5,.4), c(.6,.7)) # left arm
  grid.lines(c(.5,.65), c(.2,0)) # right leg
  grid.lines(c(.5,.35), c(.2,0)) # left leg
  grid.lines(c(.35,.65), c(0,0)) # horizontal  line for body
  grid.text(x=.5,y=-0.3,label ='Female',
            gp =gpar(col='white',fontface=2,fontsize=32)) # vertical line for body
}

xscale <- c(0, max(c(xx.pop$Freq,xy.pop$Freq)))* 5
levels <- nlevels(xy.pop$Var1)
barYscale<- xy.pop$Var1
vp <- plotViewport(c(5, 4, 4, 1),
                   yscale = range(0:levels)*1.05,
                   xscale =xscale)


pushViewport(vp)

grid.yaxis(at=c(1:levels))
pushViewport(viewport(width = unit(0.5, "npc"),just='right', 
                      xscale =rev(xscale)))
grid.xaxis()
popViewport()

pushViewport(viewport(width = unit(0.5, "npc"),just='left',
                      xscale = xscale))
grid.xaxis()
popViewport()

grid.grill(gp=gpar(fill=NA,col='white',lwd=3),
           h = unit(seq(0,levels), "native"))
grid.rect(gp=gpar(fill=rgb(0,0.2,1,0.5)),
          width = unit(0.5, "npc"),just='right')

grid.rect(gp=gpar(fill=rgb(1,0.2,0.3,0.5)),
          width = unit(0.5, "npc"),just=c('left'))

vv.xy <- xy.pop$Freq
vv.xx <- c(xx.pop$Freq,0)

grid.polygon(x  = unit.c(unit(0.5,'npc')-unit(vv.xy,'native'),
                         unit(0.5,'npc')+unit(rev(vv.xx),'native')),
             y  = unit.c(unit(1:levels,'native'),
                         unit(rev(1:levels),'native')),
             gp=gpar(fill=rgb(1,1,1,0.8),col='white'))

grid.grill(gp=gpar(fill=NA,col='white',lwd=3,alpha=0.8),
           h = unit(seq(0,levels), "native"))
popViewport()

## some fun here 
vp1 <- viewport(x=0.2, y=0.75, width=0.2, height=0.2,gp=gpar(lwd=2,col='white'),angle=30)
pushViewport(vp1)
stickBoy()
popViewport()
vp1 <- viewport(x=0.9, y=0.75, width=0.2, height=0.2,,gp=gpar(lwd=2,col='white'),angle=330)
pushViewport(vp1)
stickGirl()
popViewport()
-------------------------------------------------------------------------------------------------------
base scales library(scales)
xy.poly <- data.frame(Freq=c(xy.pop$Freq, rep(0,nrow(xy.pop))), 
                      Var1=c(xy.pop$Var1, rev(xy.pop$Var1)))
xx.poly <- data.frame(Freq=c(xx.pop$Freq, rep(0,nrow(xx.pop))), 
                      Var1=c(xx.pop$Var1, rev(xx.pop$Var1)))
xrange <- range(c(xy.poly$Freq, xx.poly$Freq))
yrange <- range(c(xy.poly$Var1, xx.poly$Var1))

par(mfcol=c(1,2))
par(mar=c(5,4,4,0))
plot(xy.poly,type="n", main="Men", xlab="", ylab="", xaxs="i", 
     xlim=rev(xrange), ylim=yrange, axes=FALSE)
rect(-1,0,100,100, col="blue")
abline(h=0:15, col="white", lty=3)
polygon(xy.poly, col=alpha("grey",0.6))
axis(1, at=seq(0,20,by=5))
axis(2, las=2)
box()

par(mar=c(5,0,4,4))
plot(xx.poly,type="n", main="Women", xaxs="i", xlab="", ylab="",
     xlim=xrange, ylim=yrange, axes=FALSE)
rect(-1,0,100,100, col="red")
abline(h=0:15, col="white", lty=3)
axis(1, at=seq(5,20,by=5))
axis(4, las=2)
polygon(xx.poly, col=alpha("grey",0.6))
box()
-------------------------------------------------------------------------------------------------------
temp<-c(30.1:40.1) # y axis
doy<-c(360:365,1:5) # x axis

doy2 <- c(360:365,c(1:5)+365)

plot(temp ~ doy2, xaxt="n", xlab = "doy")
axis(1,doy,at=doy2) temp<-c(30.1:40.1) # y axis
doy<-c(360:365,1:5) # x axis

doy2 <- c(360:365,c(1:5)+365)  #we sill need this to place numbers 1:5 into a new year (i.e. 365 days later)


doy.date <- as.Date("2011-01-01")   #Set a base date (choose the year that you will start with

doy.date <- doy.date + doy2 - 1  #add the days of year to the base date and subtract one (the base date was January 1st)

plot(temp ~ doy.date, xlab = "doy")    #plot as usual

#see documentation on dates
?date

#or for date with times:
?POSIXct
-------------------------------------------------------------------------------------------------------
curve(exp(x), from=1, to=5, lwd=5)
curve(150-exp(x), from=1, to=5, lwd=5, col="darkblue",add=T)
par(new=TRUE)
par(oma=c(1,4,5,1))
par(mfcol=c(2,2), mfg=c(1,1))
par(mar=c(7,7,1,1))
curve(exp(x), from=1, to=5, lwd=7, xlab="chi", ylab="exp(x)", cex.lab=2,axes=F)
axis(1, labels=NA,at=c(0,5))
axis(2, labels=NA,at=c(0,150))
text(1,120,"Alpha",adj=c(0,0),cex=1.5)
text(4,10,"Beta",adj=c(0,0),cex=1.5) oma mar
-------------------------------------------------------------------------------------------------------
par(fig = ) par("fig") c(xmin, xmax, ymin, ymax) 0 1 grconvertX() grconvertY() "user" "ndc" "user" "ndc" par("fig") grconvert*() ## pdf("fig-in-fig.pdf", width=10, height=10)
curve(exp(x), from=1, to=5, lwd=5)
curve(150-exp(x), from=1, to=5, lwd=5, col="darkblue",add=T)

## Here's the bit I added.
par(fig = c(grconvertX(c(1, 3), from="user", to="ndc"),
            grconvertY(c(50, 125), from="user", to="ndc")),
    mar = c(4,6,1,1),
    new = TRUE)

curve(exp(x), from=1, to=5, lwd=7, xlab="chi", ylab="exp(x)", cex.lab=4,axes=F)
axis(1, labels=NA,at=c(0,5))
axis(2, labels=NA,at=c(0,150))
text(1,120,"Alpha",adj=c(0,0),cex=3)
text(3.5,10,"Beta",adj=c(0,0),cex=3)
## dev.off()
-------------------------------------------------------------------------------------------------------
image() #using image() function
x<-c(0, 5, 30, 80, 1000)
y<-c(150, 2000, 2010, 3000)
grd <- expand.grid(x=x, y=y)
z<-matrix(grd$x*2-grd$y*3, nrow=length(x), ncol=length(y), byrow=TRUE)
image(x=x, y=y, z=z, col=rainbow(20))

#another option with z-scale
source("image.scale.r") #http://menugget.blogspot.de/2011/08/adding-scale-to-image-plot.html
x11(width=5, height=4)
layout(matrix(1:2, nrow=1, ncol=2), widths=c(4,1), heights=4, respect=TRUE)
layout.show(2)
par(mar=c(4,4,1,1))
image(x=x, y=y, z=z, col=rainbow(20))
par(mar=c(4,0,1,4))
image.scale(z, col=rainbow(20), horiz=FALSE, xlab="", ylab="", xaxt="n", yaxt="n")
axis(4)
box()
-------------------------------------------------------------------------------------------------------
y=c(0.1, 0.001, 0.00001, 0.0000001, 0.000000001, 0.0000000001)
x=c(1, 2, 3, 4, 5, 6)
plot(x, y, log="y",yaxt="n")
axis(2,at=c(0.1, 0.001, 0.00001, 0.0000001, 0.000000001, 0.0000000001) ,labels=c(0.1, 0.001, 0.00001, 0.0000001, 0.000000001,"0")) plot yaxt="n" axis ticks at "0" label
-------------------------------------------------------------------------------------------------------
n n.restarts n n.restarts ... func2 <- function (lb, ub, ..., n.restarts = 5, n.sim = 10){
  writeLines(paste("Value of `n.restarts` is", n.restarts))
  arg.curve.user <- as.list(substitute(list(...)))
  output <- gosolnp(fun = func1, LB = lb, UB = ub,  n.restarts =  n.restarts, 
                    n.sim =  n.sim)$par
  func3(fun = func1, arg.curve.user = arg.curve.user)
  output
} > func2 (lb = 0, ub = 8, n.restarts = 2, n.sim = 10, n = 200,
+        from = 0, to = 8)
Value of `n.restarts` is 2          <---- Here!

Iter: 1 fn: 6.926e-15    Pars:  2.00000
Iter: 2 fn: 2.501e-15    Pars:  2.00000
solnp--> Completed in 2 iterations

Iter: 1 fn: 8.336e-16    Pars:  2.00000
Iter: 2 fn: 8.336e-16    Pars:  2.00000
solnp--> Completed in 2 iterations
[1] 2
> func2 (lb = 0, ub = 8, nrestarts = 2, n.sim = 10, n = 200,
+        from = 0, to = 8)
Value of `n.restarts` is 5          <---- Here! Default

Iter: 1 fn: 2.83e-15     Pars:  2.00000
Iter: 2 fn: 2.5e-15  Pars:  2.00000
solnp--> Completed in 2 iterations

Iter: 1 fn: 2.037e-15    Pars:  2.00000
Iter: 2 fn: 2.037e-15    Pars:  2.00000
solnp--> Completed in 2 iterations

Iter: 1 fn: 1.087e-15    Pars:  2.00000
Iter: 2 fn: 1.087e-15    Pars:  2.00000
solnp--> Completed in 2 iterations

Iter: 1 fn: 8.558e-16    Pars:  2.00000
Iter: 2 fn: 8.558e-16    Pars:  2.00000
solnp--> Completed in 2 iterations

Iter: 1 fn: 7.147e-16    Pars:  2.00000
Iter: 2 fn: 7.147e-16    Pars:  2.00000
solnp--> Completed in 2 iterations
[1] 2
Warning messages:
1: In plot.window(...) : "nrestarts" is not a graphical parameter
2: In plot.xy(xy, type, ...) : "nrestarts" is not a graphical parameter
3: In axis(side = side, at = at, labels = labels, ...) :
  "nrestarts" is not a graphical parameter
4: In axis(side = side, at = at, labels = labels, ...) :
  "nrestarts" is not a graphical parameter
5: In box(...) : "nrestarts" is not a graphical parameter
6: In title(...) : "nrestarts" is not a graphical parameter
-------------------------------------------------------------------------------------------------------
library(Rsolnp)

func1 <- function (x) (x-2)^2

func3 <- function (fun, col = "blue", n = 1000, main = "This is a test", ...){
  curve(func1, ..., n = n, col = col, main = main)
}

# optimizes func1 and call func2 to plot func1
func2 <- function (lb, ub, n.restarts = 5, n.sim = 10, ...){
  output <- gosolnp(fun = func1, LB = lb, UB = ub, n.restarts = n.restarts, 
  n.sim =  n.sim)$par
  func3(fun = func1, ...)
  return(output)
} func2 ( lb = 0, ub = 8, nrestarts = 5, n.sim = 10, n = 200, from = 0, to = 8) Warning messages:
1: In plot.window(...) : "nrestarts" is not a graphical parameter
2: In plot.xy(xy, type, ...) : "nrestarts" is not a graphical parameter
3: In axis(side = side, at = at, labels = labels, ...) :
  "nrestarts" is not a graphical parameter
4: In axis(side = side, at = at, labels = labels, ...) :
  "nrestarts" is not a graphical parameter
5: In box(...) : "nrestarts" is not a graphical parameter
6: In title(...) : "nrestarts" is not a graphical parameter
-------------------------------------------------------------------------------------------------------
def customaxis(ax, c_left='k', c_bottom='k', c_right='none', c_top='none',
               lw=3, size=20, pad=8):

    for c_spine, spine in zip([c_left, c_bottom, c_right, c_top],
                              ['left', 'bottom', 'right', 'top']):
        if c_spine != 'none':
            ax.spines[spine].set_color(c_spine)
            ax.spines[spine].set_linewidth(lw)
        else:
            ax.spines[spine].set_color('none')
    if (c_bottom == 'none') & (c_top == 'none'): # no bottom and no top
        ax.xaxis.set_ticks_position('none')
    elif (c_bottom != 'none') & (c_top != 'none'): # bottom and top
        ax.tick_params(axis='x', direction='out', width=lw, length=7,
                      color=c_bottom, labelsize=size, pad=pad)
    elif (c_bottom != 'none') & (c_top == 'none'): # bottom but not top
        ax.xaxis.set_ticks_position('bottom')
        ax.tick_params(axis='x', direction='out', width=lw, length=7,
                       color=c_bottom, labelsize=size, pad=pad)
    elif (c_bottom == 'none') & (c_top != 'none'): # no bottom but top
        ax.xaxis.set_ticks_position('top')
        ax.tick_params(axis='x', direction='out', width=lw, length=7,
                       color=c_top, labelsize=size, pad=pad)
    if (c_left == 'none') & (c_right == 'none'): # no left and no right
        ax.yaxis.set_ticks_position('none')
    elif (c_left != 'none') & (c_right != 'none'): # left and right
        ax.tick_params(axis='y', direction='out', width=lw, length=7,
                       color=c_left, labelsize=size, pad=pad)
    elif (c_left != 'none') & (c_right == 'none'): # left but not right
        ax.yaxis.set_ticks_position('left')
        ax.tick_params(axis='y', direction='out', width=lw, length=7,
                       color=c_left, labelsize=size, pad=pad)
    elif (c_left == 'none') & (c_right != 'none'): # no left but right
        ax.yaxis.set_ticks_position('right')
        ax.tick_params(axis='y', direction='out', width=lw, length=7,
                       color=c_right, labelsize=size, pad=pad) def adjust_spines(ax,spines):
    for loc, spine in ax.spines.items():
        if loc in spines:
            spine.set_position(('outward',10)) # outward by 10 points
            spine.set_smart_bounds(True)
        else:
            spine.set_color('none') # don't draw spine import numpy as np
import matplotlib.pyplot as plt

fig,(ax1,ax2) = plt.subplots(figsize=(8,5), ncols=2)
ax1.plot(np.random.rand(20), np.random.rand(20), 'ok')
ax2.plot(np.random.rand(20), np.random.rand(20), 'ok')

customaxis(ax2) # remove top and right spines, ticks out
adjust_spines(ax2, ['left', 'bottom']) # non touching spines

plt.show()
-------------------------------------------------------------------------------------------------------
ggplot2 df<-data.frame(x = rep(1:5,times=5),
               y = rep(c("A", "B", "C", "D", "E"),each=5),
               z= c(sort(sample(x=seq(0,1,0.1),size=5, replace=F)),
                    sort(sample(x=seq(0,1,0.1),size=5, replace=F)),
                    sort(sample(x=seq(0,1,0.1),size=5, replace=F)),
                    sort(sample(x=seq(0,1,0.1),size=5, replace=F)),
                    sort(sample(x=seq(0,1,0.1),size=5, replace=F)))) geom_tile() y z library(ggplot2)
ggplot(df,aes(x=x,y=y,fill=z))+geom_tile()+
  scale_x_continuous(expand = c(0, 0)) + scale_y_discrete(expand = c(0, 0)) image() z cbind() z2<-cbind(z.a,z.b,z.c,z.d,z.e)
x2<-1:5
y2<-1:5 z image() axis() image.plot() fields col= image.plot() par(mar=c(5,5,5,8)) #sets space for legend on right side
image(x2,y2,z2,axes=F,col=rainbow(10))
axis(1,at=1:5)
axis(2,at=1:5,labels=c("A", "B", "C", "D", "E"))
box()
library(fields)
image.plot(x2,y2,z2,legend.only=T,col=rainbow(10))
-------------------------------------------------------------------------------------------------------
interp akima age2100 <- read.table("temp.csv",header=TRUE,sep=",")

x <- age2100$x
y <- age2100$y
z <- age2100$z

require(akima)

fld <- interp(x,y,z)

par(mar=c(5,5,1,1))
filled.contour(fld) image image.scale source("image.scale.R") # http://menugget.blogspot.de/2011/08/adding-scale-to-image-plot.html

x11(width=5, height=6)
layout(matrix(c(1,2), nrow=1, ncol=2), widths=c(4,1), height=6, respect=TRUE)
layout.show(2)

par(mar=c(4,4,1,1))
image(fld)
contour(fld, add=TRUE)
points(age2100$x,age2100$y, pch=".", cex=2)

par(mar=c(4,0,1,4))
image.scale(fld$z, xlab="", ylab="", xaxt="n", yaxt="n", horiz=FALSE)
box()
axis(4)
mtext("text", side=4, line=2.5)
-------------------------------------------------------------------------------------------------------
set.seed(1)
x <- matrix(rnorm(1000), ncol=100)
d <- dist(x, method="euclidean")
hc <- hclust(d, method="complete")

hc$height
[1] 12.79157 13.05586 13.51490 13.54069 14.32658 14.45824 15.70899 16.44131
[9] 17.12514 plot(hc, hang=-1, ylab="Similarity", axes=FALSE)
axis(2, seq(0, 18, by=2), seq(18, 0, by=-2))
-------------------------------------------------------------------------------------------------------
lwd plot.xts(SF, type='candles',lwd=2)
Error in axis(1, at = xycoords$x[ep], labels = names(ep), las = 1, lwd = 1,  : 
  formal argument "lwd" matched by multiple actual arguments plot.xts par opar <- par(lwd=2)
plot.xts(SF, type='candles')
par(opar) # reset to original parameters
-------------------------------------------------------------------------------------------------------
predict lines(predict(fit)) # plot the existing data with space for the predicted line
plot(c(cpi,rep(NA,12)),xaxt="n",ylab="CPI",xlab="",ylim=c(162,190))

# plot the future predictions as a line using the next 3 year periods
lines(13:24,
      predict(
        fit,
        newdata=data.frame(year=rep(c(2011,2012,2013),each=4),quarter=rep(1:4,3))
             )
     )

year<-rep(2008:2013,each=4)
axis(1,labels=paste(year,quarter,sep="C"),at=1:24,las=3)
-------------------------------------------------------------------------------------------------------
?hist all(diff(breaks) == 1) hist(c(1,1,3,3 -3.5,-3.5, msum2),breaks=bins, freq= FALSE, right=FALSE) hist(msum2,breaks=bins, freq= FALSE, right=FALSE, xaxt="n")
axis(1,at=bins,labels=bins) x <- seq(-4, 4, length=100) `lines(x,dnorm(x))`
-------------------------------------------------------------------------------------------------------
set.seed(1)
x <- rnorm(1000)
hist(x, las=1)

par(new=TRUE)   
plot(density(x), col=2, yaxt="n", xaxt="n",
     bty='n', xlab="", ylab="", main='')
axis(4, las=1)
-------------------------------------------------------------------------------------------------------
hist freq=FALSE breaks set.seed(1)
f1 <- rnorm(100, mean=0, sd=1)
f2 <- rnorm(100, mean=3, sd=3)
f3 <- rnorm(100, mean=4, sd=1)
f4 <- rnorm(100, mean=7, sd=3)

breaks <- pretty(c(f1, f2, f3, f4), n=20)
x11(width=4, height=8)
op <- par(mfcol=c(4,1))
hist(f1, freq=FALSE, breaks=breaks)
hist(f2, freq=FALSE, breaks=breaks)
hist(f3, freq=FALSE, breaks=breaks)
hist(f4, freq=FALSE, breaks=breaks)
par(op) t set.seed(1)

N <- 100
M <- 7
MEAN <- c(1:M)
SD <- MEAN*0.2+1
RES <- list()

for(i in seq(M)){
    RES[[i]] <- rnorm(N, mean=MEAN[[i]], sd=SD[[i]])
}


breaks <- pretty(unlist(RES), n=20)
x11(width=4, height=10)
op <- par(mfcol=c(M,1), mar=c(1,3,0,0), oma=c(3,2,1,1))
for(i in seq(M)){
    h1 <- hist(RES[[i]], breaks=breaks, plot=FALSE)
    plot(h1$mids, h1$densit, t="n", xlab="", ylab="", xaxt="n")
    grid()
    lines(h1$mids, h1$densit, t="S")
    text(par()$usr[1], par()$usr[3]+(par()$usr[4]-par()$usr[3])*0.9, labels=paste("t", i), pos=4)
    if(i == M){
        axis(1)
    } else {
        axis(1, labels=FALSE)
    }
}
mtext("Density", outer=TRUE, side=2, line=0)
par(op)
-------------------------------------------------------------------------------------------------------
d <- data.frame(x = 2, y=1:5) 
 boxplot(d)
 boxplot(d, axes=FALSE) # add axes=FALSE to remove axes d <- data.frame(x = 2, y=1:5) 
 boxplot(d, axes=FALSE)
 axis(2, at=1:5, labels=c(rep("whatever I want",5))) boxplot(d, xaxt="n")
-------------------------------------------------------------------------------------------------------
at curve(x^2, -5, 5, axes=FALSE)
axis(1, pos=0, at=-5:5)
axis(2, pos=0) axTicks axp curve(x^2, -5, 5, axes=FALSE)
axis(1, pos=0, at=axTicks(1,axp=c(-10,10,10)))
axis(2, pos=0)
-------------------------------------------------------------------------------------------------------
base ggplot2 bandline<-function(x, low.col, high.col, axis=TRUE){
    l <- max(unlist(lapply(x, length)), na.r=TRUE)
    r <- range(unlist(x), na.rm=TRUE)
    par(mfcol=c(length(x), 1))
    for(i in 1:length(x)){
        y <- boxplot.stats(x[[i]])
        ifelse(i==1, par(mar=c(0,3,3,3)), 
                     ifelse(i==length(x), par(mar=c(3,3,0,3)), 
                                          par(mar=c(0,3,0,3))))
        plot(NA, axes=F, bty="n", xlim=c(1,l), ylim=r, xaxs="i")
        rect(1,y$stats[2], l, y$stats[1], col="grey80", border=NA)
        rect(1,y$stats[4], l, y$stats[2], col="grey60", border=NA)
        rect(1,y$stats[5], l, y$stats[4], col="grey40", border=NA)
        abline(h=y$stats[3],col="white", lwd=2)
        lines(seq_along(x[[i]]), x[[i]])
        zhigh <- zlow <- x[[i]]
        zhigh[zhigh<=y$stats[5]]<-NA
        zlow[zlow>=y$stats[1]]<-NA
        points(seq_along(x[[i]]), zlow, bg=low.col, pch=21,cex=2)
        points(seq_along(x[[i]]), zhigh, bg=high.col, pch=21, cex=2)
        if(axis==TRUE){
            axis(2, at=pretty(x[[i]]), las=2)
            ifelse(i==1, axis(3, at=seq_len(l)), 
                         ifelse(i==length(x),axis(1, at=seq_len(l)),""))
            }
        mtext(names(x)[i], side=4, srt=270, line=1)
    }
} set.seed(1)
dat<-list(a=rnorm(100), b=rnorm(100), c=rnorm(100), d=rnorm(100))
bandline(dat, "black", "white", axis=FALSE)
-------------------------------------------------------------------------------------------------------
widths = c(0.5, 0.5, 1/3,1/4,1/5, 3.5, 0.5)
heights = c(25, 10, 5,4.5,4,2,0.5) barplot ##Also specify colours
barplot(heights, widths, space=0, 
        col = colours()[1:6]) axis(1, 0:6) grid ##Look at ?grid to for more control over the grid lines
grid() arrows(1, 10, 1.2, 12, code=1)
text(1.2, 13, "A country") polygon polygon(c(4,4,5,5), c(20, 25, 25, 20), col="antiquewhite1")
text(4.3, 22.5, "Hi there", cex=0.6) par(mar=c(3,3,2,1), 
    mgp=c(2,0.4,0), tck=-.01,
    cex.axis=0.9, las=1)
-------------------------------------------------------------------------------------------------------
data <- c(298, 507, 1008, 346)
boxplot(data,pars=list(yaxt="n"))
axis(
     2,
     at=axTicks(2),
     labels=paste(axTicks(2) %/% 60,sprintf("%02d",axTicks(2) %% 60),sep=":"),
     las=2
    ) axTicks ?axTicks %% %/% x %/% y x y sprintf 0 2 02
-------------------------------------------------------------------------------------------------------
x <- rnorm(1000, mean=3, sd=2)
y <- rnorm(500, mean=3.5, sd=3)

dx <- density(x)
dy <- density(y)

plot.new()
plot.window(xlim=range(c(dx$x, dy$x)), ylim=range(c(dx$y, dy$y)))
with(dx, lines(x, y))
with(dy, lines(x, y, lty=2))
axis(1)
axis(2)
legend(topright, lty=1:2, c('x', 'y'))
mtext(side=1, line=2, 'Observed values')
mtext(side=2, line=2, 'Estimated probability mass')
title('Smoothed Density Estimates for 2-sample experiment')
-------------------------------------------------------------------------------------------------------
yaxlabels = "n" axis(4) Forest = c(1,0,1,1,1,0,1,1,0,1)
change = c(-1, 3, 1, 4, 1, 1, -1, 1, -1, 6)
mydata = data.frame(Forest,change)

x = factor(mydata$Forest)

cdplot(x~mydata$change, ylab = NA, xlab = NA, yaxlabels = "n")
axis(4)
-------------------------------------------------------------------------------------------------------
plot(x = 1:10, y = rnorm(10, 5, 2), xlim=c(1, 10), ylim=c(1, 10), panel.first=grid()) plot(x = 1:10, y = rnorm(10, 5, 2), xaxp=c(1, 10, 10), yaxp=c(1, 10, 10), axes=FALSE)
axis(1, 1:10)
axis(2, 1:10)
abline(h=1:10, v=1:10, col="gray", lty=3)
-------------------------------------------------------------------------------------------------------
apply(MSA, 2, function(x1) {
  apply(MSA, 2, function(x2) {
    t.test(x1, x2)
  })
}) cis <- apply(MSA, 2, function(x) mean(x) + c(-1, 1) * sd(x) * 1.96)
plot.new()
plot.window(xlim=c(1, ncol(cis)), ylim=range(cis))
segments(1:ncol(cis), cis[1, ], 1:ncol(cis), cis[2, ])
axis(1, at=1:ncol(cis), labels=colnames(MSA))
axis(2)
box()
abline(h=mean(MSA), lty='dashed')
title('Forest plot of 95% confidence intervals of MSA')
-------------------------------------------------------------------------------------------------------
xlim=c(0,168) plot(...,xlim=c(0,168),xaxt="n")
axis(1,at=c(1:168),rep(1:24,7))
-------------------------------------------------------------------------------------------------------
hh:mm decTime <- function(x) {
    t <- as.numeric(strsplit(x, ":")[[1]])
    t <- t[1] + t[2]/60
    return(t)
}

str <- 'n   day     tstart   tend   duration category
1   2012-10-01      13:40    14:16  36       Recreation
2   2012-10-02      10:15    10:57  42       Work
3   2012-10-02      13:23    13:47  24       Chores
4   2012-10-02      13:47    14:48  61       Work
5   2012-10-03      09:09    11:40  151      Work
6   2012-10-03      13:33    14:04  31       Recreation
7   2012-10-03      17:00    19:40  160      Recreation'

df <- read.table(textConnection(str), header=T) df$day  <- gsub('2012-10-', "", df$day)
df$day <- as.numeric(df$day)
df$starttime <- sapply(as.character(df$tstart), decTime, USE.NAMES=F)
df$endtime <- sapply(as.character(df$tend), decTime, USE.NAMES=F) df$color <- ifelse(df$category=='Recreation', 'RED', ifelse(df$category =='Chores', 'BLUE', 'GREEN')) #Plot empty graph
plot(x=unique(df$day), y=c(0,0,0), axes=F, ylim=c(0,24), xlim=c(0.5,3.5), xlab='date', ylab='time', type='n')
#Label axes properly
axis(side=1, at=c(1,2,3), labels=c('01', '02', '03'))
axis(side=2, at=seq(from=0,to=24,by=1), labels=seq(from=0,to=24,by=1))
#Draw required rectangles
rect(df$day-0.25, df$starttime, df$day+0.25, df$endtime, col=df$color)
-------------------------------------------------------------------------------------------------------
x <- 1:10
y <- c(1, 3, 5, 6, 2, 7, 11, 3, 2, 13)
z <- runif(10, min=1000, max=10000) 

par(mar = c(5, 4, 4, 4) + 0.3) 
barplot(y, col=rainbow(length(x)))
par(new = TRUE)
plot(x, z, type = "l", axes = FALSE, bty = "n", xlab = "", ylab = "")
axis(side=4, at = pretty(range(z)))
mtext("z", side=4, line=3)

library(plotrix)
twoord.plot(x,y,x,z,
    xlab="x",
    ylab="y",
    rylab="z",
    main="Main",
    type=c("bar","l"),lcol=rainbow(length(x)),rcol=4)
-------------------------------------------------------------------------------------------------------
plot(-20:-1, rnorm(20) + 1 : 20, xaxt="n")
at <- axTicks(1, usr=par("usr")[1:2])
labs <- gsub("-", "\U2212", print.default(at))
axis(1, at=at, labels=labs)
-------------------------------------------------------------------------------------------------------
panel.axis() library(lattice); trace("panel.axis", edit=TRUE) if (draw.labels && !is.null(labels)) {
    {
        labels <- gsub("-", "\U2212", labels)  ## <- My addition
        Encoding(labels) <- "UTF-8"            ## <- My addition
        just <- if (outside) 
            switch(side, bottom = if (rot[1] == 0) c("centre", at= library(lattice)

trace(what = "panel.axis",
      tracer = quote({labels <- gsub("-", "\U2212", labels)
                      Encoding(labels) <- "UTF-8"}),
      at = list(c(30,3,2,2))) xyplot(1:10 ~ -1:-10)
untrace("panel.axis")
windows()
xyplot(1:10 ~ -1:-10)
-------------------------------------------------------------------------------------------------------
geometry mesh.drectangle combn library(geometry)
## I generate some data 
set.seed(1234)
p.x <- sample(1:100,size=30,replace=T)
p.y <- sample(1:100,size=30,replace=T)
points <- cbind(p.x,p.y)

## the  algortithm
ll <- combn(1:nrow(points),2,function(x){
     x1<- p.x[x[1]]; y1 <- p.y[x[1]]
     x2<- p.x[x[2]]; y2 <- p.y[x[2]]
     p <- points[-x,]
     d <- mesh.drectangle(p,x1,y1,x2,y2)
     res <- NA
     if(length(which(d <0))){
        points.in = as.data.frame(p,ncol=2)[ d < 0 , ]
       res <- list(n = nrow(points.in), 
                    rect = list(x1=x1,x2=x2,y1=y1,y2=y2),
                    points.in = points.in)
     }
     res
},simplify=F)
ll <- ll[!is.na(ll)]

## the result
nn <- do.call(rbind,lapply(ll,'[[','n')) library(grid)
grid.newpage()
vp <- plotViewport(xscale = extendrange(p.x),
                          yscale = extendrange(p.y))
pushViewport(vp)
grid.xaxis()   
grid.yaxis()
grid.points(x=points[,'p.x'],y=points[,'p.y'],pch='*')
cols <- rainbow(length(ll))
ll <- ll[nn == 5]           ## here I plot only the rectangle with 5 points 
lapply(seq_along(ll),function(i){
            x <- ll[[i]]
            col <- sample(cols,1)
            x1<- x$rect$x1; x2<- x$rect$x2
            y1<- x$rect$y1; y2<- x$rect$y2
            grid.rect(x=(x1+x2)*.5,y=(y1+y2)*.5,
                      width= x2-x1,height = y2-y1,
                      default.units ='native',
                      gp=gpar(fill=col,col='red',alpha=0.2)
                      )
            grid.points(x=x$points.in$p.x,y=x$points.in$p.y,pch=19,
                        gp=gpar(col=rep(col,x$n))) 

 }
)
upViewport()
-------------------------------------------------------------------------------------------------------
axis(1, 1:dim(d)[2], colnames(d), las=2)
axis(2, 1:dim(d)[2], colnames(d), las=2) image(x=seq(dim(x)[2]), y=seq(dim(y)[2]), z=COR, col=rev(heat.colors(20)), xlab="x column", ylab="y column", xaxt='n')
-------------------------------------------------------------------------------------------------------
##Generate a boxplot without axes
boxplot(count ~ spray, data = InsectSprays, axes=FALSE)

##Add in a y-axis
axis(2, seq(0,25, 5), seq(0, 25, 5))

##Add in an x-axis
##las=2 changes the orientation
axis(1, 1:6, paste("Big Label", 1:6), las=2)
-------------------------------------------------------------------------------------------------------
my.symbols TeachingDemo myd <- data.frame (X = 1:5, Y = c(0.8, 0.6, 0.7, 0.75,  0.1), 
                   clockd = c(12.05, 12.25, 12.45, 1.30, 2.1))
hour <- round(myd$clockd)#takes hours by ignoring decimals
minute <- 100*(myd$clockd - trunc(myd$clockd,2))#takes decimals
#for getting the angle I'm subtracting from pi/2
#thats because pi/2 orients the arrow into 0 degree position, pointing up 
hourAngle <- pi/2 - (hour/12*2*pi)
minuteAngle <- pi/2 - (minute/60*2*pi)
#now all the plotting
plot(myd$X, myd$Y, type="l", xaxt="n", xlab="", ylab="", 
     xlim=c(0.5,5.5), ylim=c(0,1), col="gray")#standard plot, no x axis
axis(1, at=myd$X, labels=myd$X)#custom x-axis
require(TeachingDemo)
my.symbols(myd$X, myd$Y, ms.arrows, angle=hourAngle, add=T, 
           col="blue", symb.plots=TRUE, adj=0)
my.symbols(myd$X, myd$Y, ms.arrows, angle=minuteAngle, add=T, 
           col="red", symb.plots=TRUE, adj=0)
my.symbols(myd$X, myd$Y, ms.polygon, n=250, add=T, 
           r=1.1, col="gray")
-------------------------------------------------------------------------------------------------------
?as.Date as.integer(as.Date("0/1/1"))
[1] -719528

as.integer(seq(as.Date("0/1/1"),length=2,by="-10000 years"))
[1]  -719528 -4371953

seq(as.Date(-4371953,origin="1970-01-01"),Sys.Date(),by="1000 years")
# nonsense
 [1] "0000-01-01" "'000-01-01" "(000-01-01" ")000-01-01" "*000-01-01"
 [6] "+000-01-01" ",000-01-01" "-000-01-01" ".000-01-01" "/000-01-01"
[11] "0000-01-01" "1000-01-01" "2000-01-01"

> as.integer(seq(as.Date(-4371953,origin="1970-01-01"),Sys.Date(),by="1000 years"))
# also possibly nonsense
 [1] -4371953 -4006710 -3641468 -3276225 -2910983 -2545740 -2180498 -1815255
 [9] -1450013 -1084770  -719528  -354285    10957 yrs1000 <- seq(as.Date(-4371953,origin="1970-01-01"),Sys.Date(),by="1000 years")
plot(yrs1000,rep(1,length(yrs1000)),axes=FALSE,ann=FALSE)
box()
axis(2)
axis(1,at=yrs1000,labels=c(paste(seq(10000,1000,by=-1000),"BC",sep=""),"0AD","1000AD","2000AD"))
title(xlab="Year",ylab="Value")
-------------------------------------------------------------------------------------------------------
#Set alignment for tow plots. Extra zeros are needed to get space for axis at bottom.
layout(matrix(c(0,1,2,0),ncol=1),heights=c(1,3,3,1))

#Set spaces around plot (0 for bottom and top)
par(mar=c(0,5,0,5))

#1. plot
plot(df$V2~df$TIME2,type="l",xlim=c(1000,2000),axes=F,ylab="")

#Two rectangles - y coordinates are larger to ensure that all space is taken  
rect(1100,-15000,1300,15000,col="red",border="red")
rect(1800,-15000,1850,15000,col="red",border="red")

#plot again the same line (to show line over rectangle)
par(new=TRUE)
plot(df$V2~df$TIME2,type="l",xlim=c(1000,2000),axes=F,ylab="")

#set axis
axis(1,at=seq(800,2200,200),labels=NA)
axis(4,at=seq(-15000,10000,5000),las=2)


#The same for plot 2. rev() in ylim= ensures reverse axis.
plot(df$VARIABLE1~df$TIME1,type="l",ylim=rev(range(df$VARIABLE1)+c(-0.1,0.1)),xlim=c(1000,2000),axes=F,ylab="")
rect(1100,-15000,1300,15000,col="red",border="red")
rect(1800,-15000,1850,15000,col="red",border="red")
par(new=TRUE)
plot(df$VARIABLE1~df$TIME1,type="l",ylim=rev(range(df$VARIABLE1)+c(-0.1,0.1)),xlim=c(1000,2000),axes=F,ylab="")
axis(1,at=seq(800,2200,200))
axis(2,at=seq(-6.4,-8.4,-0.4),las=2) rect1<- data.frame (xmin=1100, xmax=1300, ymin=-Inf, ymax=Inf)
rect2 <- data.frame (xmin=1800, xmax=1850, ymin=-Inf, ymax=Inf) data aes geom_line() geom_rect() plot.margin= theme() -1 p1 p2 p2 library(ggplot2)
library(grid)
library(gridExtra)
p1<- ggplot() + geom_line(data=df, aes(TIME1, VARIABLE1)) + 
  scale_y_reverse() + 
  labs(x="AGE") + 
  scale_x_continuous(breaks = seq(1000,2000,200), limits = c(1000,2000)) + 
   geom_rect(data=rect1,aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymax),alpha=0.1,fill="blue")+
   geom_rect(data=rect2,aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymax),alpha=0.1,fill="blue")+
   theme(plot.margin = unit(c(-1,0.5,0.5,0.5), "lines"))

p2<- ggplot() + geom_line(data=df, aes(TIME2, V2)) + labs(x=NULL) + 
  scale_x_continuous(breaks = seq(1000,2000,200), limits = c(1000,2000)) + 
  scale_y_continuous(limits=c(-14000,10000))+
  geom_rect(data=rect1,aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymax),alpha=0.1,fill="blue")+
  geom_rect(data=rect2,aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymax),alpha=0.1,fill="blue")+
  theme(axis.text.x=element_blank(),
        axis.title.x=element_blank(),
        plot.title=element_blank(),
        axis.ticks.x=element_blank(),
        plot.margin = unit(c(0.5,0.5,-1,0.5), "lines"))


gp1<- ggplot_gtable(ggplot_build(p1))
gp2<- ggplot_gtable(ggplot_build(p2))
maxWidth = unit.pmax(gp1$widths[2:3], gp2$widths[2:3])
gp1$widths[2:3] <- maxWidth
gp2$widths[2:3] <- maxWidth
grid.arrange(gp2, gp1)
-------------------------------------------------------------------------------------------------------
data.frame c(labels) data.frame axis(1, at=3*0:59, lab=as.vector(labels$AA))
-------------------------------------------------------------------------------------------------------
lines par( mar=c(5,4,4,5)+.1 )
boxplot( t( matrix( rnorm( 100 ), nrow=10 )), xlab="Var1", ylab="Var2")
lines( 1:10, runif(10,min=-2, max=3), type='b', col='blue', pch=15 )
axis(4)
mtext("Var3", side=4, line=3 )
-------------------------------------------------------------------------------------------------------
test <- read.table(text="STM_cold STM_normal STM_hot PIC_cold PIC_normal PIC_hot
6.0 6.6 6.3 0.9 1.9 3.2
6.0 6.6 6.5 1.0 2.0 3.2
5.9 6.7 6.5 0.3 1.8 3.2
6.1 6.8 6.6 0.2 1.8 3.8
5.5 6.7 6.2 0.5 1.9 3.3
5.6 6.5 6.5 0.2 1.9 3.5
5.4 6.8 6.5 0.2 1.8 3.7
5.3 6.5 6.2 0.2 2.0 3.5
5.3 6.7 6.5 0.1 1.7 3.6
5.7 6.7 6.5 0.3 1.7 3.6
NA  NA  NA  0.1 1.8 3.8
NA  NA  NA  0.2 2.1 4.1
NA  NA  NA  0.2 1.8 3.3
NA  NA  NA  0.8 1.7 3.5
NA  NA  NA  1.7 1.6 4.0
NA  NA  NA  0.1 1.7 3.7",header=TRUE) plot(
     NA,
     ylim=c(0,max(test,na.rm=TRUE)+0.3),
     xlim=c(1-0.1,ncol(test)+0.1),
     xaxt="n",
     ann=FALSE,
     panel.first=grid()
     )

axis(1,at=seq_along(test),labels=names(test),lwd=0,lwd.ticks=1) jitter invisible(
  mapply(
        points,
        jitter(rep(seq_along(test),each=nrow(test))),
        unlist(test),
        col=rep(seq_along(test),each=nrow(test)),
        pch=19
        )
) jitter invisible(
  mapply(
        points,
        rep(seq_along(test),each=nrow(test)),
        unlist(test),
        col=rgb(0,0,0,0.1),
        pch=15,
        cex=3
        )
)
-------------------------------------------------------------------------------------------------------
axis > plot(1:10,  axes=FALSE)      ### to not plot the default ones
> axis(1,lty='dashed',lwd=3)
> axis(2,lty=3,lwd=2) old.oma <- par(oma=c(5,5,0,1))  #bottom 5 lines,left 5lines,right 1line
-------------------------------------------------------------------------------------------------------
> set.seed(1)
> DF <- data.frame(2000:2009,matrix(rnorm(50, 1000, 200), ncol=5))
> colnames(DF) <- c('Year', paste0('Country', 2:ncol(DF)))
> DF # this is how the data.frame looks like:
   Year  Country2  Country3  Country4  Country5  Country6
1  2000  874.7092 1302.3562 1183.7955 1271.7359  967.0953
2  2001 1036.7287 1077.9686 1156.4273  979.4425  949.3277
3  2002  832.8743  875.7519 1014.9130 1077.5343 1139.3927
4  2003 1319.0562  557.0600  602.1297  989.2390 1111.3326
5  2004 1065.9016 1224.9862 1123.9651  724.5881  862.2489
6  2005  835.9063  991.0133  988.7743  917.0011  858.5010
7  2006 1097.4858  996.7619  968.8409  921.1420 1072.9164
8  2007 1147.6649 1188.7672  705.8495  988.1373 1153.7066
9  2008 1115.1563 1164.2442  904.3700 1220.0051  977.5308
10 2009  938.9223 1118.7803 1083.5883 1152.6351 1176.2215
> matplot(DF[,-1], col=1:ncol(DF), type='l', lty=1, ylim=range(DF), axes=FALSE)
> axis(1, 1:nrow(DF), as.character(DF[,1]))
> axis(2)
> box() #- to make it look "as usual"
> legend('topright', names(DF), col=1:ncol(DF), lty=1, cex=.65)
-------------------------------------------------------------------------------------------------------
Ecdf(latency_targ1, group = CONDITION, lty = c(1, 2, 3, 4), 
    lwd = 4, label.curves = list(method = 'arrow', 
    keys = "lines", lwd = 2), xlim = c(0,500), 
    subtitles = FALSE, xlab = "Latency", 
    ylab = "Proportion latency <= x", 
    cex.lab=1.5, xaxt="n", yaxt="n")
axis(2, cex.axis=1.5)
axis(1, cex.axis=1.5)
-------------------------------------------------------------------------------------------------------
xlim=c(0,40) mp<-barplot(as.matrix(t(df[,2:4])),beside=TRUE,xlim=c(0,40),ann=FALSE)
mp
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
[1,]  1.5  5.5  9.5 13.5 17.5 21.5 25.5 29.5 33.5  37.5
[2,]  2.5  6.5 10.5 14.5 18.5 22.5 26.5 30.5 34.5  38.5
[3,]  3.5  7.5 11.5 15.5 19.5 23.5 27.5 31.5 35.5  39.5 par(new=TRUE) plot() lines() mp axis() par(new=TRUE)
plot(mp[2,],df$CS1,xlim=c(0,40),type="l",col="red",axes=FALSE,ylim=c(0,100),ann=FALSE)
lines(mp[2,],df$CS2,col="blue")
lines(mp[2,],df$CS3,col="green")
axis(1,at=mp[2,],labels=df$V)
axis(4,at=seq(0,100,10))
box()
-------------------------------------------------------------------------------------------------------
datasetcomb<-rbind(dataset1,dataset2) #combine datasets

#V1 is cell, V2 is another variable

boxplot(V1~factor(V2),data=datasetcomb,at=c(1,4,7,2,5),ylab="Cell",
    xlab="Category/Year",xaxt="n",col=c(3,3,3,2,2))
axis(side=1,at=c(1,4,7,2,5),labels=c(1,2,3,2000,2001))
-------------------------------------------------------------------------------------------------------
x1 <- table(cut(x, breaks = quantile(x, probs = c(0,0.15, 0.85, 1))))

png(filename="~/test.png", width = 8, height = 2.5, units="in", res = 72)
barplot(
  as.matrix(x1), horiz = TRUE, 
  col = c("lightblue", "yellow", "palegreen"),
  axes = FALSE)
axis(1, at = c(0, cumsum(x1)), labels = c(0, 15, 85, 100))
dev.off()
-------------------------------------------------------------------------------------------------------
A <- sample(0:9, 100, replace = TRUE)
stripchart(A, method = "stack", offset = .5, at = .15, pch = 19, 
           main = "Dotplot of Random Values", xlab = "Random Values",xaxt="n")
axis(1, at = 0:9, labels = 0:9)
-------------------------------------------------------------------------------------------------------
barplot() axis() set.seed(1)
x<-data.frame(v1=rnorm(10),v2=rnorm(10))
barplot(t(as.matrix(x)), col=c("cyan", "black"))
axis(1,at=1:10) barplot() at= m<-barplot(t(as.matrix(x)), col=c("cyan", "black"))
m
 [1]  0.7  1.9  3.1  4.3  5.5  6.7  7.9  9.1 10.3 11.5
axis(1, at=m,labels=1:10) m labels= m<-barplot(t(as.matrix(x)), col=c("cyan", "black"))
lab<-c("A","B","C")
axis(1, at=m[c(1,5,10)],labels=lab)
-------------------------------------------------------------------------------------------------------
mydf <- scan(textConnection("12376 167827  3454596 9676112 342102 1232103 546102  5645696 96767110 23423119  4577140  45435158 56767138 635435167 35443160 34534166 3213133 2132148 2342130 7656127 43234117 56545130  5645138 56455149"), )
plot(mydf, log="y", type="l")  # Gives you an overview of your time serie (with log axis)
gr <- diff(mydf)/mydf[-length(mydf)] # Gives you a growth rate between each of your values.
par(new=TRUE)
plot((1:(length(mydf)-1))+0.5, gr, type="l",   # Plots your growth rate
      col="red", axes=FALSE, xaxt="n", yaxt="n")
axis(4)
-------------------------------------------------------------------------------------------------------
cdplot cex.axis getS3method('cdplot','default') Axis(xorig, side = 1,cex.axis=cex.x)
 equidist <- any(diff(y1[, 1L]) < tol.ylab)
 if (equidist) 
    axis(2, at = seq.int(1/(2 * ny), 1 - 1/(2 * ny), 
                           by = 1/ny), labels = yaxlabels, tick = FALSE,cex.axis=cex.y)
 else axis(2, at = (y1[-1L, 1L] + y1[-NROW(y1), 1L])/2, 
              labels = yaxlabels, tick = FALSE,cex.axis=cex.y) my.cdplot(y=fail ,x=temperature,cex.x=2,cex.y=3)
-------------------------------------------------------------------------------------------------------
I tried something like this but that didn't work...   plot(all[1,],all[,2]) all$Date <- as.Date(all.Date) 1) My dates are written in the form "2009-01-05". I want only "2009" to appear otherwise i would have to many jumps. 2) For example the prices from the BOVESPA go from 40.000,15 to 60.000,137. How do I get nice y-labels? For instance 40.000, 45.000,...,60.000. read.csv2 3) How do i get 16 of these plots in one nice figure/plot?
-------------------------------------------------------------------------------------------------------
plot(H2S.ts,col="blue",xlab="Day",xaxt='n') #no x-axis
axis(side=1, at=seq(1,755,by=20), labels=strftime(H2S.time, 
    format="%d-%m-%Y")[seq(1,755,by=20)],cex.axis=0.8)
-------------------------------------------------------------------------------------------------------
axis() axis.Date() axis.POSIXct() ## example with axis.Date
layout(matrix(c(1,2),nrow=2,byrow=TRUE))
random.dates <- as.Date("2001/1/1") + 70*sort(stats::runif(100))
plot(random.dates, 1:100, xaxt="n",main='pretty axes dates')
axis.Date(1, at=seq(as.Date("2001/1/1"), max(random.dates)+6, "weeks"))
### example with axis.POSIXct
with(beaver1, {
  time <- strptime(paste(1990, day, time %/% 100, time %% 100),
                   "%Y %j %H %M")
  # now label every hour on the time axis
  plot(time, temp, type="l", xaxt="n",main='pretty axes times')
  r <- as.POSIXct(round(range(time), "hours"))
  axis.POSIXct(1, at=seq(r[1], r[2], by="hour"), format="%H:%M")
})
-------------------------------------------------------------------------------------------------------
axis(1,at=1:5,labels = date1$dateval) ?axis xlab date1$dateval <- as.Date(date1$dateval,format = "%d/%m/%Y")
plot(date1$dateval,date1$links, type="o", col="blue", ylim=g_range, ann=FALSE,axes = FALSE)
axis(1,at=date1$dateval,labels = date1$dateval)
-------------------------------------------------------------------------------------------------------
> mp <- barplot(rainbar$Rain,axes=F,ylim=c(0,15))
> axis(1,at=mp,labels=rainbar$DOY)
> axis(2,seq(0,15,3),c(0,3,6,9,12,15))
-------------------------------------------------------------------------------------------------------
set.seed(1)
y<-rnorm(10)
set.seed(2)
x<-rnorm(10)
plot(x,y)
text(x, y, labels=round(y,2),pos=3) ?axis plot(x,y,xaxt="n") #don't draw x-axis
 #draw x-axis by spesifying the ticks using argument at for function axis
axis(side=1,at=x,labels=round(x,2)) #this makes ticks only for values in x
text(x, y, labels=round(y,2),pos=4)
-------------------------------------------------------------------------------------------------------
A<-runif(50)
B<-runif(50)
C<-runif(50)

x<-rep(1:3,each=50) #generate x-coordinates
plot(x,y=c(A,B,C),xaxt="n",xlab="Groups",ylab="Values")
axis(side=1,at=1:3,labels=c("A","B","C")) stripchart #This needs list or data.frame as an input
stripchart(data.frame(A,B,C),vertical=TRUE,pch=1,xlab="Groups",ylab="Values")
-------------------------------------------------------------------------------------------------------
lattice require(ggplot2)
require(grid)

# user-level interface to the element grob
my_axis = function(text,rot=0) {
  structure(
    list(text=text,rot=rot),
    class = c("element_custom","element_blank", "element") # inheritance test workaround
  )
}
# returns a gTree with two children: the text label, and a rasterGrob below
element_grob.element_custom <- function(element,...)  {
  g2 <- rectGrob(gp=gpar(fill='red',alpha=0.5))
  g1 <- textGrob(element$text, x=0.5,vjust=0.5,rot  =element$rot)
  gTree(children=gList(g2,g1), cl = "custom_axis")
}
# gTrees don't know their size and ggplot would squash it, so give it room
 grobHeight.custom_axis = heightDetails.custom_axis = function(x, ...)
   unit(1, "lines")


ggplot(mtcars,aes(mpg,disp))+geom_point()+facet_grid(.~vs)+
  theme_bw() +
  theme(axis.title.x = my_axis('my custom x title'),
        axis.title.y = my_axis('my custom y title',rot=90))
-------------------------------------------------------------------------------------------------------
test <- with(df1,table(age,income))
test <- as.matrix(as.data.frame.matrix(test))
plot(
  row(test),
  col(test),
  cex=test/3,pch=20,
  xlim=c(0.5,nrow(test)+0.5),
  ylim=c(0.5,ncol(test)+0.5),
  axes=FALSE,
  ann=FALSE
)
axis(1,at=1:nrow(test),labels=rownames(test),cex.axis=0.8)
axis(2,at=1:ncol(test),labels=colnames(test),cex.axis=0.8)
title(xlab="Age Group",ylab="Income")
box()
-------------------------------------------------------------------------------------------------------
mtext axis axis col.axis #  
  axis(1, 1:nc, labels = labCol, las = 2, line = -0.5, tick = 0, cex.axis = cexCol )
mtext(side = 1, text = labCol, at = 1:nc, las = 2, line = 0.5,col = ClabColor, cex = cexCol)


#    axis(4, iy, labels = labRow, las = 2, line = -0.5, tick = 0, cex.axis = cexRow )
mtext(side = 4, text = labRow, at = iy, las = 2, line = 0.5,col = RlabColor, cex = cexCol) ClabColor = "black", RlabColor = "black"
-------------------------------------------------------------------------------------------------------
xaxt='n', ann=FALSE axis(...) mtext() x <- seq(0.5, 0.9, length = 200)
y <- dnorm(x,0.7,0.0458)
plot(x, y, type="l", xaxt='n', ann=FALSE)
axis(1, at=c(0.7, 0.8))
mtext("my_x_lab", 1, at=0.9, line=2)
-------------------------------------------------------------------------------------------------------
plot(x, y, type="l",  yaxt="n",ann=FALSE,bty="n", xaxt="n")
axis(1, at=c(0.5, 0.6, 0.7, 0.8, 0.9), labels=c("", "", 0.7, 0.8, 0.9) )
mtext("Proportions", 1, at=0.9, line=2)
-------------------------------------------------------------------------------------------------------
axis() line= line=4 plot() par(mar=...)) par(mar=c(8,3,3,3))
x <- seq(0.5, 0.9, length = 400)
y <- dnorm(x,0.7,0.0458)
plot(x, y, type="l",  yaxt="n",ann=FALSE,bty="n", xaxt="n")
#First x axis
axis(1, at=seq(0.5,0.9,by=0.1), labels=c("","",0.7, 0.8, 0.9) )
mtext("Proportions", 1, at=0.9, line=2)
#Second x axis 
axis(1, line=4,at=seq(0.5,0.9,by=0.1), labels=c("","",0, 2.18, 3) )
mtext("z score", 1, at=0.9, line=6)
-------------------------------------------------------------------------------------------------------
par(cex.lab=2) set.seed(123)
foo <- data.frame(X = rnorm(10), Y = rnorm(10))
plot(Y ~ X, data=foo,
     yaxt="n", ylab="", 
     xlab="Regular boring x", 
     pch=16,
     col="darkblue")
axis(2,cex.axis=1.2)
mtext("Awesome Y variable", side=2, line=2.2, cex=2) line=
-------------------------------------------------------------------------------------------------------
axis > axis(side=1, at=c(0:23)) plot(0:23, d, type='b', axes=FALSE)
axis(side=1, at=c(0:23))
axis(side=2, at=seq(0, 600, by=100))
box()
-------------------------------------------------------------------------------------------------------
arrows axis plot ## you call plot without axes, without box, without axes labels
plot(x, y1,type="l",frame.plot=FALSE,
     axes=FALSE,xlab='',ylab='')
## write some text
text(0.3,0.2,labels="y=x")
text(max(x),-0.1,"x")
text(-0.1,max(x),'y')
## draw axes lines with arrows
arrows(min(x), 0, max(x), 0)
arrows(0, min(x), 0, max(x))
## add axes ticks
axis(1,at=c(0,0.5,1),pos=0)
axis(2,at=c(0,0.5,1),pos=0)
-------------------------------------------------------------------------------------------------------
mtext op <- par(mar = c(5,4,4,4) + 0.1)
plot(1:10, ylab = "ylabel")
axis(side = 4)
mtext("ylabel 2", side = 4, line = 3, cex = par("cex.lab"))
par(op)
-------------------------------------------------------------------------------------------------------
plotmath par(mar=c(8, 4, 2, 4))
plot(1:5,1:5,xaxt='n',frame.plot=FALSE,xlab='')
expr1 <- expression(L[2](delta[J~S](X,W),theta))
expr2 <- expression(L[4](delta[J~S](X,W),theta))
axis(1,las=2,labels=c(expr1,expr1),at=2:3,pos=1)
arrows(0,1,5,1)
-------------------------------------------------------------------------------------------------------
wp <- structure(list(M.1990 = c(325814, 295272, 269351, 265163, 249651, 220027, 196523, 178295, 141789, 115097, 106579, 91763, 77150, 56845, 38053, 25716, 19442), M.2000 = c(319675, 317296, 317072, 290827, 262992, 256378, 241401, 212924, 188905, 169133, 131813, 103162, 90921, 72231, 53449, 32707, 25868), M.2010 = c(328759, 315119, 311456, 312831, 311077, 284258, 255596, 248575, 232217, 202633, 176241, 153494, 114194, 83129, 65266, 43761, 39223), F.1990 = c(308121, 281322, 257432, 254065, 238856, 211943, 188433, 170937, 138358, 112931, 106510, 93425, 82667, 67057, 47679, 37435, 36724), F.2000 = c(298455, 297012, 299757, 277706, 252924, 248127, 233583, 207518, 183646, 165444, 132307, 105429, 96681, 80227, 64956, 45832, 46413), F.2010 = c(307079, 293664, 290598, 293313, 295739, 273379, 247383, 241938, 226914, 201142, 176440, 156283, 121200, 92071, 77990, 56895, 66029)), .Names = c("M.1990", "M.2000", "M.2010", "F.1990", "F.2000", "F.2010"), row.names = c("0-4", "5-9", "10-14", "15-19", "20-24", "25-29", "30-34", "35-39", "40-44", "45-49", "50-54", "55-59", "60-64", "65-69", "70-74", "75-79", "80+"), class = "data.frame")

wp
      M.1990 M.2000 M.2010 F.1990 F.2000 F.2010
0-4   325814 319675 328759 308121 298455 307079
5-9   295272 317296 315119 281322 297012 293664
10-14 269351 317072 311456 257432 299757 290598
15-19 265163 290827 312831 254065 277706 293313
20-24 249651 262992 311077 238856 252924 295739
25-29 220027 256378 284258 211943 248127 273379
30-34 196523 241401 255596 188433 233583 247383
35-39 178295 212924 248575 170937 207518 241938
40-44 141789 188905 232217 138358 183646 226914
45-49 115097 169133 202633 112931 165444 201142
50-54 106579 131813 176241 106510 132307 176440
55-59  91763 103162 153494  93425 105429 156283
60-64  77150  90921 114194  82667  96681 121200
65-69  56845  72231  83129  67057  80227  92071
70-74  38053  53449  65266  47679  64956  77990
75-79  25716  32707  43761  37435  45832  56895
80+    19442  25868  39223  36724  46413  66029

xrange <- range(c(0,wp))
yrange <- range(c(0,nrow(wp))) par(mfcol=c(1,2))
par(mar=c(5,4,4,0))
plot(NA,type="n", main="Men", xlab="", ylab="", xaxs="i", 
     xlim=rev(xrange), ylim=yrange, axes=FALSE, yaxs="i")
rect(xrange[1],yrange[1],xrange[2],yrange[2], col="cadetblue")
abline(v=seq(0,xrange[2],by=1e5), col="white")
# All years with bars you want to represent filled 
# should be entered in reverse order
polygon(c(0,rep(wp$M.2000,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)),
        col="lightblue",border="lightblue")
polygon(c(0,rep(wp$M.1990,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)), 
        col="darkblue",border="darkblue")
# And those you want with just a border, afterwards:
polygon(c(0,rep(wp$M.2010,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)), 
        col=NA,border="darkred",lwd=2)
axis(1, at=c(0,1e5,2e5,3e5), labels=format(c(0,1e5,2e5,3e5),scientific=FALSE))
axis(2, at=1:nrow(wp)-0.5,labels=row.names(wp),las=2)
box()

par(mar=c(5,0,4,4))
plot(NA,type="n", main="Women", xlab="", ylab="", xaxs="i", 
     xlim=xrange, ylim=yrange, axes=FALSE, yaxs="i")
rect(xrange[1],yrange[1],xrange[2],yrange[2], col="cadetblue")
abline(v=seq(0,xrange[2],by=1e5), col="white")
polygon(c(0,rep(wp$F.2000,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)),
        col="lightblue",border="lightblue")
polygon(c(0,rep(wp$F.1990,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)), 
        col="darkblue",border="darkblue")
polygon(c(0,rep(wp$F.2010,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)), 
        col=NA,border="darkred",lwd=2)
axis(1, at=c(0,1e5,2e5,3e5), labels=format(c(0,1e5,2e5,3e5),scientific=FALSE))
axis(4, at=1:nrow(wp)-0.5,labels=row.names(wp),las=2)
box() library(scales)
[...]
polygon(c(0,rep(wp$M.1990,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)), 
        col=alpha("darkblue",0.4),border="darkblue")
[...]
polygon(c(0,rep(wp$F.1990,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)), 
        col=alpha("darkblue",0.4),border="darkblue")
[...]
-------------------------------------------------------------------------------------------------------
par(new=TRUE) (axes=FALSE) data <- matrix(rnorm(4*100),ncol=4)
 par(mar=c(5, 6, 2, 4))
 plot(1:100,data[,3], lwd=3, col="green", ann=FALSE, las=2,type='l')
 mtext("I am at left", side=2, line=3.5)
 par(new=TRUE)
 plot(1:100,data[,2], ann=FALSE, axes=FALSE,col='red',type='l')
 mtext("I am at right)", side=4, line=2)
 title("Using par(new=TRUE) \n same X and different or not Y axis ")
 axis(4)
-------------------------------------------------------------------------------------------------------
ggs <- subset(gg, count > 0)
radius <- sqrt( ggs$count / pi )

# ggs$Var1 <- as.character(ggs$Var1)

# set up your tick marks 
#  (this can all be put into a single line in `axis`, but it's placed separate here to be more readable)
#--------------
# at which values to place the x tick marks
x_at <- seq_along(levels(gg$Var1))
# the string to place at each tick mark
x_labels <-   levels(gg$Var1)


# use xaxt="n" to supress the standard axis ticks 
symbols(ggs$Var1, ggs$Var2, radius, inches=0.30, xlab="Research type", ylab="Research area", xaxt="n")
axis(side=1, at=x_at, labels=x_labels)

text(ggs$Var1, ggs$Var2, ggs$count, cex=0.5) grid gg ggs grid R
-------------------------------------------------------------------------------------------------------
vioplot() at wex add=T wex n<-c(100,1000)
size<-scale(sqrt(n),center=F)

x1<-rnorm(n[1])
x2<-rnorm(n[2])

#initialize an empty plot
plot(0:3,rep(0,4),type='l',xlim=c(0,3),ylim=c(-4,4),ylab="",xlab="",xaxt="n",lty=3)

# fill in the violins at specific x locations using the `wex` parameter for size
vioplot(x1,at=1,wex=size[1],add=T,col="darkgray")
vioplot(x2,at=2,wex=size[2],add=T,col="darkgray")
axis(1,at=1:2,labels=c("Mon","Tues"))
-------------------------------------------------------------------------------------------------------
ylim=c(0,20) hist() axis() hist(y,breaks=c(0,60,70,80,90,100),freq=TRUE,ylim=c(0,20))
axis(2,at=seq(0,20,length.out=5),labels=c(0,5,10,15,20))
-------------------------------------------------------------------------------------------------------
tmp <- tapply( iris$Petal.Length, iris$Species, function(x) hist(x, plot=FALSE) )

plot.new()
tmp.r <- do.call( range, lapply(tmp, `[[`, 'breaks') )
plot.window(xlim=c(1/2,length(tmp)+1/2), ylim=tmp.r)
abline(v=seq_along(tmp))

for( i in seq_along(tmp) ) {
    h <- tmp[[i]]
    rf <- h$counts/sum(h$counts)
    rect( i-rf/2, head(h$breaks, -1), i+rf/2, tail(h$breaks, -1) )
}

axis(1, at=seq_along(tmp), labels=names(tmp))
axis(2)
box()
-------------------------------------------------------------------------------------------------------
plot plot(c(1.2, 4, 7), col=2, xaxt="n") axis(1, at=round(x, 0)) x
-------------------------------------------------------------------------------------------------------
plot(x,y,yaxt="n") ticks<-c(100,200,300,400)
axis(2,at=ticks,labels=ticks) ylim plot(x,y,yaxt="n",ylim=c(0,500))
-------------------------------------------------------------------------------------------------------
data<-data.frame(x=c(50,100,250,400),y1=c(0.74,0.75,0.82,0.79),y2=c(0.81,0.83,0.87,0.88))

windows()
plot(data$x,data$y1,type="l",col="red", ylim=c(0.5,1),xlim= c(50,500),col.axis = "white")
axis(1, xaxp=c(50,500,9))
axis(2, yaxp=c(0.5,1,10)) 
lines(data$x, data$y2, type='l',col="blue")

for(i in c(0.55,0.6,0.65,0.7,0.75,0.8,0.85,0.9,0.95)) {
lines(c(50,500),c(i,i),type="l",lty=2,lwd=0.5, col="black")
rm(i)
}
-------------------------------------------------------------------------------------------------------
data1 <- read.table(text="
codeofhammurabi.txt crete.txt      0.570737
codeofhammurabi.txt iraqi.txt      1.13475
codeofhammurabi.txt magnacarta.txt 0.945746
codeofhammurabi.txt us.txt         1.25546
crete.txt iraqi.txt                0.329545
crete.txt magnacarta.txt           0.589786
crete.txt us.txt                   0.491903
iraqi.txt magnacarta.txt           0.834488
iraqi.txt us.txt                   1.37718
magnacarta.txt us.txt              1.09582")
par(mar=c(3,7,3.5,5), las=1)

symbols(data1[,1],data1[,2], circles=data1[,3], inches=0.55, bg="lightblue", xaxt="n", yaxt="n", ylab="")
axis(1, at=data1[,1],labels=data1[,1])
axis(2, at=data1[,2],labels=data1[,2])
text(data1[,1], data1[,2], round(data1[,3],2), cex=0.9)
-------------------------------------------------------------------------------------------------------
set.seed(1)
n = 10
x <- runif(n, min=0, max=2)
y <- runif(n, min=8, max=24)
z <- runif(n, min=0, max=100)

#z to cex function
a <- 1
b <- 0.02
z.cex <- a + b*z

example.cex <- seq(1,3,0.5)
example.z <- (example.cex - a)/b
example.z 


plot(x, y, pch=21, bg="orange", col="red", cex=z.cex, lwd=2, bty="n", xaxt="n", yaxt="n", xlab="", ylab="")
grid()
axis(1, at=seq(0,2,0.5), pos=16, col="green4", lwd=3)
axis(2, at=seq(8,24,4), pos=1, col="green4", lwd=3)
legend("topright", legend=c(example.z), pch=21, pt.bg="orange", col="red", pt.cex=example.cex, title="sales vol.", bg="white")
-------------------------------------------------------------------------------------------------------
numpy.random.multivariate_normal import numpy as np
import matplotlib.pyplot as plt


num_samples = 400

# The desired mean values of the sample.
mu = np.array([5.0, 0.0, 10.0])

# The desired covariance matrix.
r = np.array([
        [  3.40, -2.75, -2.00],
        [ -2.75,  5.50,  1.50],
        [ -2.00,  1.50,  1.25]
    ])

# Generate the random samples.
y = np.random.multivariate_normal(mu, r, size=num_samples)


# Plot various projections of the samples.
plt.subplot(2,2,1)
plt.plot(y[:,0], y[:,1], 'b.')
plt.plot(mu[0], mu[1], 'ro')
plt.ylabel('y[1]')
plt.axis('equal')
plt.grid(True)

plt.subplot(2,2,3)
plt.plot(y[:,0], y[:,2], 'b.')
plt.plot(mu[0], mu[2], 'ro')
plt.xlabel('y[0]')
plt.ylabel('y[2]')
plt.axis('equal')
plt.grid(True)

plt.subplot(2,2,4)
plt.plot(y[:,1], y[:,2], 'b.')
plt.plot(mu[1], mu[2], 'ro')
plt.xlabel('y[1]')
plt.axis('equal')
plt.grid(True)

plt.show()
-------------------------------------------------------------------------------------------------------
base brX <- seq(min(myd$X),max(myd$X),length=11)
brY <- seq(min(myd$Y),max(myd$Y),length=11)

layout(matrix(c(1,0,2,3),nrow=2),width=c(2,8),height=c(8,2))
par(mar=c(0,3,5,0))
plot(NA,ylim=range(myd$Y),xlim=c(0,1),axes=F,ann=F,xaxs="i")
rect(0,brY[-length(brY)],1,brY[-1], 
     col=colorRampPalette(c("red","yellow","green"))(length(brY)-1))

par(mar=c(0,0,5,5))
plot(NA,xlim=range(myd$X),ylim=range(myd$Y),ann=F,xaxt="n",yaxt="n")
abline(h=pretty(myd$Y),v=pretty(myd$X), col="grey95")
points(myd$X,myd$Y,pch=21)
axis(3)
axis(4)

par(mar=c(3,0,0,5))
plot(NA,xlim=range(myd$X),ylim=c(0,1),axes=F,ann=F,yaxs="i")
rect(brX[-length(brX)],0,brX[-1],1, 
     col=colorRampPalette(c("blue","white","red"))(length(brX)-1))
-------------------------------------------------------------------------------------------------------
xy.coords lines plot(beforeandafterdata[,1],type="l",col="black",xlim=c(0.9,2.1),ylim=ylimits,
     ann=FALSE,axes=FALSE) 
title(ylab=ylabel, cex.lab=1.4) 
axis(1,at=1:2,lab=c("Preop.","Postop."),cex.axis=1.5)
axis(2,labels=TRUE) 
x<-c(1*2:6) 
x 
lapply(x, function(x){
lines(xy.coords(x=c(1, 2), y=c(beforeandafterdata[,x])), type="l", col="black", 
      xlim=c(0.9,2.1),ylim=ylimits,ann=FALSE)
})
-------------------------------------------------------------------------------------------------------
axis pos xvals bargraph.CI àxis library(sciplot)
# I am using some sciplot data 
dat <- ToothGrowth
### I create along labels
labels <- c('aaaaaaaaaa\naaaaaaaaaaa\nhhhhhhhhhhhhhhh',
          'bbbbbbbbbb\nbbbbbbbbbbb\nhhhhhhhhhhhhhh',
          'cccccccccc\nccccccccccc\ngdgdgdgdgd')
## I change factor labels
dat$dose <- factor(dat$dose,labels=labels)
ll <- bargraph.CI(x.factor = dose, response = len, data = dat,axisnames=FALSE) 
## set at to xvals
axis(side=1,at=ll$xvals,labels=labels,pos=-2,tick=FALSE)
-------------------------------------------------------------------------------------------------------
ylim par(mfrow=c(2,1))
tN <- table(Ni <- stats::rpois(100, lambda = 5))
r <- barplot(tN, col = rainbow(20),ylim=c(0,50),main='long y-axis')
r <- barplot(tN, col = rainbow(20),main='short y axis') axis usr require(grDevices) # for colours
par(mfrow=c(1,1))
r <- barplot(tN, col = rainbow(20),main='short y axis',ann=FALSE,axes=FALSE)
usr <- par("usr")
par(usr=c(usr[1:2], 0, 20))
axis(2,at=seq(0,20,5))
-------------------------------------------------------------------------------------------------------
plot(1:10, axes=FALSE, frame=TRUE) tck ##The tck value should be smaller here
axis(1, 1:10, tck=-0.05) labels="" axis(1, seq(0.5, 9.5, 1), labels=rep("", 10), tck=-0.01)
-------------------------------------------------------------------------------------------------------
express <- function(char.expressions){
       return(parse(text=paste(char.expressions,collapse=";")))
    }
    par(mar=c(6,6,1,1))
    plot(0,0,xlim=sym(),ylim=sym(),xaxt="n",yaxt="n",mgp=c(4,0.2,0),
       xlab="axis(1,(-9:9)/10,tick.labels,las=2,cex.axis=0.8)",
       ylab="axis(2,(-9:9)/10,express(tick.labels),las=1,cex.axis=0.8)")
    tick.labels <- paste("x >=",(-9:9)/10)
    # this is what you get if you just use tick.labels the regular way:
    axis(1,(-9:9)/10,tick.labels,las=2,cex.axis=0.8)
    # but if you express() them... voila!
    axis(2,(-9:9)/10,express(tick.labels),las=1,cex.axis=0.8)
-------------------------------------------------------------------------------------------------------
axis x <- -5:5
y <- x

plot(x,y, t="l", xaxt="n", yaxt="n")
axis(1, pos=-1)
axis(2, pos=1, las=1) ?axis at labels axis
-------------------------------------------------------------------------------------------------------
base par ## Set pdf size to be slightly bigger than plot to take account of one line margin
pdf( "~/myplot.pdf" , width = 6.5 , height = 15.5 )

## Set graphical parameters to control the size of the plot area and the margins
## Set size of plot area to 6 inches wide by 15 inches tall
par( pin = c(6,15) )

## Remove margins around plot area
par( mai = c(0,0,0,0) )

## Remove outer margins around plot area
par( omi = c(0,0,0,0) )

## Set y-axis take use entire width of plot area (6 inches) and to have 7 tick marks (-3,-2,-1,0,1,2,3)
par( yaxp = c(0,1,7) )

## Set x-axis take use entire height of plot area (15 inches) and to have 27 tick marks (-13,-12,...,0,...11,12,13)
par( xaxp = c(0,1,27) )

## Create the plot
plot( x , y , type = "l" , frame.plot = FALSE , axes = FALSE )
axis( 1 , pos = 0 , at = seq( -3 , 3 , by = 1 ) , labels = seq( -3 , 3 , by = 1 ) )
axis( 2 , pos = 0 , at = seq( -13 , 13 , by = 1 ) , labels = seq( -13 , 13 , by = 1 ) )
text(0.5,5,expression(f(x)==frac(1,2)*x^3) )

## Turn PDF device off
dev.off()
-------------------------------------------------------------------------------------------------------
z <- rnorm(100,.3,.2)
hist(z, xlab="", ylab="", main="", yaxt="n")
par(new=TRUE)
plot(density(z), xlab="", ylab="", main="", xaxt="n", yaxt="n")
axis(2, ...) # plug in the relevant values for `at` and `labels`
axis(4, ...) # plug in the relevant values for `at` and `labels`
-------------------------------------------------------------------------------------------------------
plot(sample(100))

axis(side = 1, lwd = 2)
axis(side = 2, lwd = 2)
-------------------------------------------------------------------------------------------------------
ry <- c(0.1,0.2,0.3,0.4,0.5)
ly <- c(15,35,65,75,80)
x <- 1:5
xlabs <- c("A","B","C","D","E")
barplot(ly, xaxt="n", yaxt="n", xlab="xLabel", ylab="lyLabel", ylim=c(0,100))
axis(2, seq(0,100,by=5), seq(0,100,by=5), las=2) # you can adjust positions of ly labels
par(new=TRUE)
plot(ry~x, xaxt="n", yaxt="n", xlab="", ylab="", ylim=c(0,1))
axis(1, 1:5, xlabs)
axis(4, 1:10/10, 1:10/10, las=2) # you can adjust positions of ry labels
mtext("ryLabel", 4, line=2)
-------------------------------------------------------------------------------------------------------
matplot(com_30$date, DCCrho, xaxt = "n", type='l')
axis(1, com_30$date, format(com_30$date, "%y"), cex.axis = .7)
-------------------------------------------------------------------------------------------------------
las=2 barplot() axis() mtext axis mtext("0.95",2,.5,at=.95,las=2,cex=.75)
-------------------------------------------------------------------------------------------------------
xts:::plot.xts col lwd las mgp ... axis axis(1, at = xycoords$x, labels = FALSE, col = "#BBBBBB", ...) col axis ... col axis xtsExtra:::plot.xts ... ... axis
-------------------------------------------------------------------------------------------------------
##h specifies the heights
##Dummy bars have zero heights
h = c(0, 2, 0, 1, 0, 3)
w = c(1, 1, 2, 3, 4, 1) barplot ##For the dummy bars, remove the border
##Also set the space=0 to get the correct axis
barplot(h, width=w, border=c(NA, "black"), space=0)
axis(1, 0:14)
-------------------------------------------------------------------------------------------------------
m1 <- as.matrix(read.table(text="   reg1   reg2     reg3   reg4   reg5    reg6    reg6    reg7     reg8
1  0.2036 0.6400  -2.2647 0.5345 0.9812 -0.0390 -1.4486 -0.1340  -1.9157
2 -0.0308 0.2991  -1.8990 0.7063 0.8807 -0.0568 -1.5150 -0.8000  -1.5115
3 -0.0242 0.6358  -2.1675 0.8432 0.8149 -0.0955 -1.3789 -0.2266  -1.5513
4 -0.8990 0.5613  -2.0289 0.8544 1.1060 -0.3846 -1.4800 -0.0717  -1.4325
5 -0.6438 0.8719  -2.2708 0.6790 1.0250 -0.3035 -1.1125 -0.3746  -1.5219
6 -0.7945 0.5943  -1.8478 0.5457 0.7989 -0.1093 -2.3242  0.2995  -1.8066",header=TRUE))

m2 <- matrix(rnorm(54),nrow=6)

fun <- Vectorize(function(i,j) t.test(m1[,i],m2[,j])$p.value)
res <- outer(1:9,1:9,FUN = "fun")

image(1:9,1:9,res,axes=FALSE,xlab="m1",ylab="m2")
axis(1, at = 1:9,labels=colnames(m1))
axis(2, at = 1:9,labels=colnames(m1)) colnames(res) <- colnames(m1)
res <-as.data.frame(res)
res$group <- colnames(m1)

library(reshape2)
res <- melt(res,id="group")

library(ggplot2)
p <- ggplot(res, aes(x=group, y=variable)) + 
  geom_tile(aes(fill = value), colour =   "yellow") + 
  scale_fill_gradient(low = "yellow", high = "red", name="p-value") +
  geom_text(aes(label=format(value,digits=2))) +
  labs(x="m1",y="m2")

print(p)
-------------------------------------------------------------------------------------------------------
require(plotrix)
plotCI(1:3-0.1, m1, ui1, li1, xlab="Itens", ylab="Eta2",axes=FALSE)
axis(side=1,at=1:9,label=c(x1,x2,x3),padj=0,las=1)
axis(side=2) plotCI(1:3+.1,m2, ui2, li2,axes=FALSE,col="blue",add=TRUE)
-------------------------------------------------------------------------------------------------------
par par(cex.axis=2, las=2,mar=c(7,4,4,2)+0.1)
boxplot(Aluminum_Dissolved ~ Site,data = dat, 
        col="purple",ylab = "Dissolved Aluminum",xlab = "Dissolved Aluminum") par(cex.axis=2, las=2,mar=c(7,4,4,2)+0.1)
boxplot(Aluminum_Dissolved ~ Site,data = dat, 
        col="purple",ylab = "Dissolved Aluminum",xlab = "Dissolved Aluminum",axes = FALSE)
axis(...) points lines par par mar ?par
-------------------------------------------------------------------------------------------------------
plot(a,b, xaxt="n")
axis(side=1, at=a) axis(side=1, at=round(a,2))
-------------------------------------------------------------------------------------------------------
outer for i <- seq(from=0, to=.8, by=0.1)
j <- seq(from=0, to=0.9, by=0.1)

res <- outer(i,j,FUN=Vectorize(function(i,j) {
  require(reldist)
  a <-  i*(1+i^2-i^2*j)/((1+i)^2*(1+i^2)) 
  b <-  i*(1-j)/(1+i) 
  c <-  ((1-j)/(1+i))-i*(1+i^2-i^2*j)/((1+i)^2*(1+i^2))
  gini(c(a,b,c))
})
) image image(res, breaks = c(-1000,.25,.5,1000),col = c("green","yellow","red"),
      axes=FALSE,xlab="i",ylab="j")
axis(1, at = seq(0,1,length.out=length(i),labels=i)
axis(2, at = seq(0,1,length.out=length(j),labels=j)
-------------------------------------------------------------------------------------------------------
panel plot.zoo ax.date <-as.POSIXlt("2013-01-06")+(0:167)*3600 #Dummy date for POSIXlt method

my.panel <- function(x, y, ..., pf = parent.frame()) {
 grid(NA,NULL)
 abline(v=seq(1,168,24),col = "lightgray", lty = "dotted", lwd = par("lwd"))
 lines(x, y, ...)

 #if bottom panel
 if (with(pf, length(panel.number) == 0 ||
        panel.number %% nr == 0 || panel.number == nser)) {
      # create ticks at x values and then label every 24th tick
      axis(side = 1, at = x, labels = FALSE, tcl=-0.3) #hour ticks
      axis(side = 1, at = seq(1,168,6), labels = FALSE) #6hour ticks ticks
      axis(1,at=seq(1,168,24), labels=format(ax.date[seq(1,168,24)],"%a")) #day of the week
      axis(1,at=seq(13,168,24),labels=format(ax.date[seq(13,168,24)],"%H"), cex.axis=0.7) #noon ticks
   }
 }
 plot(z[,3:5], panel = my.panel,yax.flip=TRUE,col=1:3,xaxt="n")
-------------------------------------------------------------------------------------------------------
dput h <- hist(ts, breaks=7*24, plot=FALSE)
plot(x=h$mids, y=h$density, type="l", xaxt="n")
axis(1,at=ts,labels=format(ts,"%b-%d"))
-------------------------------------------------------------------------------------------------------
#' Plot two dimensional histogram
#'
#' @param hist matrix or two dimensional array containing the number of counts
#' in each of the bins.
#' @param borders_x the x-borders of the bins in the histogram. Should be a
#' numeric vector with lenght one longer than the number of columns of
#' \code{hist}
#' @param borders_y the y-borders of the bins in the histogram. Should be a
#' numeric vector with lenght one longer than the number of rows of
#' \code{hist}
#' @param type a character specifying the type of plot. Valid values are "text",
#' "area" and "color". See details for more information.
#' @param add add the plot to an existing one or create a new plot.
#' @param add_lines logical specifying whether or not lines should be drawn
#' between the bins.
#' @param draw_empty if \code{FALSE} empty bins (numer of counts equal to zero)
#' are not drawn. They are shown using the background color.
#' @param col for types "area" and "text" the color of the boxes and text.
#' @param line_col the color of the lines between the bins.
#' @param background_col the background color of the bins.
#' @param lty the line type of the lines between the bins.
#' @param text_cex the text size used for type "text". See \code{\link{par}} for
#' more information.
#' @param col_range the color scale used for type "color". Should be a function
#' which accepts as first argument the number of colors that should be
#' generated. The first color generated is used for the zero counts; the
#' last color for the highest number of counts in the histogram.
#' @param ... additional arguments are passed on to \code{\link{plot}}.
#'
#' @details
#' There are three plot types: "area", "text", and "color". In case of "area"
#' rectangles are drawn inside the bins with area proportional to the number of
#' counts in the bins. In case of text the number of counts is shown as text in
#' the bins. In case of color a color scale is used (by default heat.colors) to
#' show the number of counts.
#'
#' @seealso \code{\link{image}} which can be used to create plots similar to
#' type "color". \code{\link{contour}} may also be of interest.
#'
#' @examples
#' histplot2(volcano - min(volcano), type="color")
#' histplot2(volcano - min(volcano), add_lines=FALSE, type="area")
#' histplot2(volcano - min(volcano), type="text", text_cex=0.5)
#'
#' @export
histplot2 <- function(hist, borders_x=seq(0, ncol(hist)),
        borders_y=seq(0, nrow(hist)), type="area", add=FALSE, add_lines=TRUE,
        draw_empty=FALSE, col="black", line_col="#00000030",
        background_col="white", lty=1, text_cex=0.6, col_range=heat.colors, ...) {
    # create new plot
    rangex <- c(min(borders_x), max(borders_x))
    rangey <- c(min(borders_y), max(borders_y))
    if (add == FALSE) {
        plot(rangex, rangey, type='n', xaxs='i', yaxs='i', ...)
        rect(rangex[1], rangey[1], rangex[2], rangey[2], col=background_col,
            border=NA)
    }
    # prepare data
    nx <- length(borders_x)-1
    ny <- length(borders_y)-1
    wx <- rep(diff(borders_x), each=ny)
    wy <- rep(diff(borders_y), times=nx)
    sx <- 0.95*min(wx)/sqrt(max(hist))
    sy <- 0.95*min(wy)/sqrt(max(hist))
    x <- rep((borders_x[-length(borders_x)] + borders_x[-1])/2, each=ny)
    y <- rep((borders_y[-length(borders_y)] + borders_y[-1])/2, times=nx)
    h <- as.numeric(hist)
    # plot type "area"
    if (type == "area") {
        dx <- sqrt(h)*sx*0.5
        dy <- sqrt(h)*sy*0.5
        rect(x-dx, y-dy, x+dx, y+dy, col=col, border=NA)
    # plot type "text"
    } else if (type == "text") {
        if (draw_empty) {
            text(x, y, format(h), cex=text_cex, col=col)
        } else {
            text(x[h!=0], y[h!=0], format(h[h!=0]), cex=text_cex, col=col)
        }
    # plot type "color"
    } else if (type == "color" | type == "colour") {
        #h <- h/(wx*wy)
        col <- col_range(200)
        col <- col[floor(h/max(h)*200*(1-.Machine$double.eps))+1]
        sel <- rep(TRUE, length(x))
        if (!draw_empty) sel <- h > 0
        rect(x[sel]-wx[sel]/2, y[sel]-wy[sel]/2, x[sel]+wx[sel]/2,
            y[sel]+wy[sel]/2, col=col[sel], border=NA)
    } else {
        stop("Unknown plot type: options are 'area', 'text' and 'color'.")
    }
    # add_lines
    if (add_lines) {
        lines(rbind(borders_x, borders_x, NA),
            rbind(rep(rangey[1], nx+1), rep(rangey[2], nx+1), NA),
            col=line_col, lty=lty)
        lines(rbind(rep(rangex[1], ny+1), rep(rangex[2], ny+1), NA),
            rbind(borders_y, borders_y, NA), col=line_col, lty=lty)
    }
    # add border
    if (add == FALSE) box()
} X <- matrix(nrow=3, ncol=3)
X[1,] <- c(0.3, 0.4, 0.45)
X[2,] <- c(0.3, 0.7, 0.65)
X[3,] <- c(0.3, 0.4, 0.45)
centers <- c(1.5, 3, 4)

centers_to_borders <- function(centers) {
    nc <- length(centers)
    d0 <- centers[2]-centers[1]
    d1 <- centers[nc]-centers[nc-1]
    c(centers[1]-d0/2, 
      (centers[2:nc] + centers[1:(nc-1)])/2, centers[nc]+d1/2)
}

histplot2(X, centers_to_borders(centers), 
    centers_to_borders(centers), type="color") plot_range <- function(hist, col_range = heat.colors) {
    r <- range(c(0, X))
    par(cex=0.7, mar=c(8, 1, 8, 2.5))
    plot(0, 0, type='n', xlim=c(0,1), ylim=r, xaxs='i',
        yaxs='i', bty='n', xaxt='n', yaxt='n', xlab='', ylab='')
    axis(4)
    y <- seq(r[1], r[2], length.out=200)
    yc <- floor(y/max(y)*5*(1-.Machine$double.eps))+1
    col <- col_range(5)[yc]
    b <- centers_to_borders(y)
    rect(rep(0, length(y)), b[-length(b)], rep(1, length(y)), 
        b[-1], col=col, border=NA)
} layout layout(matrix(c(1,2), nrow = 1), widths = c(0.9, 0.1))
par(mar = c(5, 4, 4, 2) + 0.1)
histplot2(X, centers_to_borders(centers), 
    centers_to_borders(centers), type="color")
plot_range(X) histplot2 h <- h/(wx*wy)
-------------------------------------------------------------------------------------------------------
filled.contour filled.contour my.filled.contour <-
function (x = seq(0, 1, length.out = nrow(z)), y = seq(0, 1,
    length.out = ncol(z)), z, xlim = range(x, finite = TRUE),
    ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE),
    levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors,
    col = color.palette(length(levels) - 1), plot.title, plot.axes,
    key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1,
    axes = TRUE, frame.plot = axes, ...)
{
    if (missing(z)) {
        if (!missing(x)) {
            if (is.list(x)) {
                z <- x$z
                y <- x$y
                x <- x$x
            }
            else {
                z <- x
                x <- seq.int(0, 1, length.out = nrow(z))
            }
        }
        else stop("no 'z' matrix specified")
    }
    else if (is.list(x)) {
        y <- x$y
        x <- x$x
    }
    if (any(diff(x) <= 0) || any(diff(y) <= 0))
        stop("increasing 'x' and 'y' values expected")
    mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar
    on.exit(par(par.orig))
    w <- (3 + mar.orig[2L]) * par("csi") * 2.54
    layout(matrix(c(2, 1), ncol = 2L), widths = c(1, lcm(w)))
    par(las = las)
    mar <- mar.orig
    mar[4L] <- mar[2L]
    mar[2L] <- 1
    par(mar = mar)
    plot.new()
    plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i",
        yaxs = "i")
#    rect(0, levels[-length(levels)], 1, levels[-1L], col = col)
#    if (missing(key.axes)) {
#        if (axes)
#            axis(4)
#    }
#    else key.axes
#    box()
    if (!missing(key.title))
        key.title
    mar <- mar.orig
    mar[4L] <- 1
    par(mar = mar)
    plot.new()
    plot.window(xlim, ylim, "", xaxs = xaxs, yaxs = yaxs, asp = asp)
    if (!is.matrix(z) || nrow(z) <= 1L || ncol(z) <= 1L)
        stop("no proper 'z' matrix specified")
    if (!is.double(z))
        storage.mode(z) <- "double"
    .Internal(filledcontour(as.double(x), as.double(y), z, as.double(levels),
        col = col))
    if (missing(plot.axes)) {
        if (axes) {
            title(main = "", xlab = "", ylab = "")
            Axis(x, side = 1)
            Axis(y, side = 2)
        }
    }
    else plot.axes
    if (frame.plot)
        box()
    if (missing(plot.title))
        title(...)
    else plot.title
    invisible()
} my.filled.contour(x=x, y=y, z=z,
               levels=levels,
               col=colorpanel(length(levels) + 1, "white", "grey10"),
               xlim=rev(range(x)),
               ylim=rev(range(y)),
               plot.axes={axis(1, c(0.18, 0.01), label=TRUE, tcl=-0.5)
                          axis(2, c(0.18, 0.01), label=TRUE, tcl=-0.5)
                          draw.contour()},
               xlab="x",
               frame=FALSE)
-------------------------------------------------------------------------------------------------------
.filled.contour plot(NA,xlim=rev(range(x)),
               ylim=rev(range(y)),xlab="x",ylab="y",
               frame=FALSE,axes=F,xaxs="i",yaxs="i")

.filled.contour(x=x, y=y, z=z,
               levels=levels,
               col=colorpanel(length(levels) + 1, "white", "grey10"))
draw.contour()
axis(1, c(0.18, 0.01), label=TRUE, tcl=-0.5)
axis(2, c(0.18, 0.01), label=TRUE, tcl=-0.5, las=1)
-------------------------------------------------------------------------------------------------------
axis(side=3, col="black", at=cobs10$day, labels=cobs10$gdd) pretty at <- pretty(cobs10$day)
at
# [1]   0 100 200 300 400 lbl <- which(cobs10$day %in% at)
lbl
# [1] 100 200 300
lbl <- c(0, cobs10$gdd[lbl]

axis(side=3, at=at[-5], labels=lbl) cobs10 <- read.table('cobs10.txt',as.is=TRUE)
cobs10$date <- as.Date(cobs10$date)
plot(temp ~ date, data=cobs10, type='l') par(mfrow=c(3,1), mar=c(0.6, 5.1, 0, 0.6), oma=c(5.1, 0, 1, 0))
plot(temp ~ date, data=cobs10, type='l', ylab='Temperatur (C)')
plot(precip ~ date, data=cobs10, type='l', ylab='Precipitation (cm)')
plot(gdd ~ date, data=cobs10, type='l', ylab='Thermal units') par(mfrow=c(3,1), mar=c(0.6, 5.1, 0, 0.6), oma=c(5.1, 0, 1, 0))
plot(temp ~ date, data=cobs10, type='l', xaxt='n', ylab='Temperatur (C)')
plot(precip ~ date, data=cobs10, type='l', xaxt='n', ylab='Precipitation (cm)')
plot(gdd ~ date, data=cobs10, type='l', xaxt='n', ylab='Thermal units')

ticks <- seq(from=min(cobs10$date), by='2 months', length=7)
lbl <- strftime(ticks, '%b')
axis(side=1, outer=TRUE, at=ticks, labels=lbl)
mtext('2010', side=1, outer=TRUE, line=3, cex=0.67) lbl <- c(0, 2, 200, 1000, 2000, 3000, 4000)
thermals <-  splinefun(cobs10$gdd, cobs10$date)  # thermals is a function that returns the date (as an integer) for a requested value
thermals(lbl)
## [1] 14649.00 14686.79 14709.55 14761.28 14806.04 14847.68 14908.45
ticks <- as.Date(thermals(lbl), origin='1970-01-01') # remember to specify an origin when converting an integer to a Date. par(mfrow=c(2,1), mar=c(0.6, 5.1, 0, 0.6), oma=c(5.1, 0, 4, 0))
plot(temp ~ date, data=cobs10, type='l', xaxt='n', ylab='Temperatur (C)')
plot(precip ~ date, data=cobs10, type='l', xaxt='n', ylab='Precipitation (cm)')

usr <- par('usr')
x.pos <- (usr[2]+usr[1])/2

ticks <- seq(from=min(cobs10$date), by='2 months', length=7)
lbl <- strftime(ticks, '%b')
axis(side=1, outer=TRUE, at=ticks, labels=lbl)
mtext('2010', side=1, at=x.pos, line=3)

lbl <- c(0, 2, 200, 1000, 2000, 3000, 4000)
thermals <-  splinefun(cobs10$gdd, cobs10$date)  # thermals is a function that returns the date (as an integer) for a requested value
ticks <- as.Date(thermals(lbl), origin='1970-01-01') # remember to specify an origin when converting an integer to a Date.
axis(side=3, outer=TRUE, at=ticks, labels=lbl)
mtext('Thermal units', side=3, line=15, at=x.pos) mtext line
-------------------------------------------------------------------------------------------------------
axis y <- seq(10000, 100000, 10000) 
hist(y, xaxt="n")
axis(side=1, at=axTicks(1), 
     labels=formatC(axTicks(1), format="d", big.mark=',')) axTicks formatC
-------------------------------------------------------------------------------------------------------
d = data.frame(what=c("A","B","Difference"), 
               mean=c(75,105,30),
               lower=c(50,80,-3),
               upper = c(100,130,63))

plot(-1,-1,xlim=c(1,3),ylim=c(0,140),xaxt="n")

lines(c(1,1),c(d[1,3],d[1,4]))
points(rep(1,3),d[1,2:4],pch=4)

lines(c(1.5,1.5),c(d[2,3],d[2,4]))
points(rep(1.5,3),d[2,2:4],pch=4)

lines(c(2,2),c(d[3,3],d[3,4]))
points(rep(2,3),d[3,2:4],pch=4)

lines(c(1.5,2.2),c(d[2,2],d[2,2]),lty="dotted")

axis(1, at=c(1,1.5,2), labels=c("A","B","Difference"))
axis(4,at=c(40,80,120),labels=c(-1,0,1),pos=2.2)
-------------------------------------------------------------------------------------------------------
par(mar=c(3,5,3,5))
plot(NA, xlim=c(.5,3.5), ylim=c(0, max(d$upper[1:2])), bty="l", xaxt="n", xlab="",ylab="Mean")
points(d$mean[1:2], pch=19)
segments(1,d$mean[1],5,d$mean[1],lty=2)
segments(2,d$mean[2],5,d$mean[2],lty=2)
axis(1, 1:3, d$what)
segments(1:2,d$lower[1:2],1:2,d$upper[1:2])
axis(4, seq((d$mean[1]-30),(d$mean[1]+50),by=10), seq(-30,50,by=10), las=1)
points(3,d$mean[1]+d$mean[3],pch=17, cex=1.5)
segments(3,d$lower[3]+d$lower[2],3,d$lower[3]+d$upper[2], lwd=2)
mtext("Difference", side=4, at=d$mean[1], line=3)
-------------------------------------------------------------------------------------------------------
library(Hmisc)

with(d1,
     errbar(as.integer(what),mean,upper,lower,xlim=c(0,4),xaxt="n",xlab="",ylim=c(0,150))
     )
points(3,d1[d1$what=="Difference","mean"],pch=15)
axis(1,at=1:3,labels=d1$what)
atics <- seq(floor(d[d$what=="Difference","lower"]/10)*10,ceiling(d[d$what=="Difference","upper"]/10)*10,by=10)
axis(4,at=atics+d1[d1=="A","mean"],labels=atics,pos=3.5)
-------------------------------------------------------------------------------------------------------
d xlim <- c(0.5, 3.5)

plot(1:2, d[d$what %in% LETTERS[1:2], "mean"], xlim = xlim, ylim = c(0, 140), 
    xlab = "", ylab = "", xaxt = "n", bty = "l", yaxs = "i")
lines(c(1,1), d[1, 3:4])
lines(c(2,2), d[2, 3:4])

par(new = TRUE)
plot(3, d[d$what == "Difference", "mean"], ylim = c(-80, 130), xlim = xlim, 
    yaxt = "n", xaxt = "n", xlab = "", ylab = "", bty = "n")
lines(c(3,3), d[3, 3:4])
Axis(x = c(-20, 60), at = c(-20, 0, 20, 40, 60), side = 4)
axis(1, at = c(1:3), labels = c("A", "B", "Difference")) xlim <- c(0.5, 4)
plot(1:2, d[d$what %in% LETTERS[1:2], "mean"], xlim = xlim, ylim = c(0, 140), 
    xlab = "", ylab = "", xaxt = "n", bty = "l", yaxs = "i")
lines(c(1,1), d[1, 3:4])
lines(c(2,2), d[2, 3:4])

par(new = TRUE)
plot(3.5, d[d$what == "Difference", "mean"], ylim = c(-80, 130), xlim = xlim, 
    yaxt = "n", xaxt = "n", xlab = "", ylab = "", bty = "n")
lines(c(3.5,3.5), d[3, 3:4])
Axis(x = c(-20, 60), at = c(-20, 0, 20, 40, 60), side = 4)
axis(1, at = c(1,2,3.5), labels = c("A", "B", "Difference"))
-------------------------------------------------------------------------------------------------------
image axis imagesc grImport tiff rtiff dput(mat) ?image > image(t(volcano)[ncol(volcano):1,])   # the default axes lebeling

 image(t(volcano)[ncol(volcano):1,], axes=FALSE)
 axis(1, at=seq(0,1,.1), labels= seq(0,100,10) )
 axis(2, at=seq(0,1,.1), labels= rev( seq(0,100,10)) )
-------------------------------------------------------------------------------------------------------
offset <- 5
barplot(-mydata-offset, beside=TRUE, ylim=c(5,12), 
        space = c(0.1 , 0.9), offset=offset, axes=FALSE)
axis(2, at=5:12, labels=-12:-5)
-------------------------------------------------------------------------------------------------------
axis(3, at= c(10, 30, 70, 95) , 
  labels=c("Always", "Most of the Time", "Some of\n the Time", "Never"))
-------------------------------------------------------------------------------------------------------
add=TRUE plotCI(x,y=y2,uiw=delta,xaxt="n",gap=0,add=TRUE) ggplot2 plotCI(x,y=y1,uiw=delta,xaxt="n",gap=0)
axis(side=1,at=c(1:10),labels=rep("a",10),cex=0.7)
usr <- par("usr")
par(usr=c(usr[1:2], -1, 20))
plotCI(x,y=y2,uiw=delta,xaxt="n",gap=0,add=TRUE,col='red')
axis(4,col.ticks ='red')
-------------------------------------------------------------------------------------------------------
minor.tick my.minor.tick <-
function (nx = 2, ny = 2, tick.ratio = 0.5, side=NA)  
{ # added the side parameter
    ax <- function(w, n, tick.ratio) {
        range <- par("usr")[if (w == "x") 
            1:2
        else 3:4]
        tick.pos <- if (w == "x") 
            par("xaxp")
        else par("yaxp")
        distance.between.minor <- (tick.pos[2] - tick.pos[1])/tick.pos[3]/n
        possible.minors <- tick.pos[1] - (0:100) * distance.between.minor
        low.minor <- min(possible.minors[possible.minors >= range[1]])
        if (is.na(low.minor)) 
            low.minor <- tick.pos[1]
        possible.minors <- tick.pos[2] + (0:100) * distance.between.minor
        hi.minor <- max(possible.minors[possible.minors <= range[2]])
        if (is.na(hi.minor)) 
            hi.minor <- tick.pos[2]
        if (.R.)        # Next three lines have only the modifications
            axis(if (w == "x" & is.na(side) )
                1
            else if (!is.na(side)) side
            else 2, seq(low.minor, hi.minor, by = distance.between.minor), 
                labels = FALSE, tcl = par("tcl") * tick.ratio)
        else axis(if (w == "x") 
            1
        else 2, seq(low.minor, hi.minor, by = distance.between.minor), 
            labels = FALSE, tck = par("tck") * tick.ratio)
    }
    if (nx > 1) 
        ax("x", nx, tick.ratio = tick.ratio)
    if (ny > 1) 
        ax("y", ny, tick.ratio = tick.ratio)
    invisible()
}
-------------------------------------------------------------------------------------------------------
ll <- lapply(LETTERS[1:4],function(let){
  dat.let <- dat[,grepl(let,colnames(dat))]
  dd <- reshape(dat.let,direction ='long',
                v.names=c('TimeVariable','Variable'),
                varying=1:6)
  dd$time <- factor(dd$time)
  dd$Type <- let
  dd
}
) head(ll[[1]])
 time TimeVariable Variable id Type
1.1    1            0        0  1    A
2.1    1            0        5  2    A
3.1    1            8      110  3    A
4.1    1           16        0  4    A
5.1    1           NA       NA  5    A
6.1    1           NA       NA  6    A layout(matrix(1:4, 2, 2, byrow = TRUE))
lapply(ll,function(data){
  label1=c(0,100,200,300)
  Type <- unique(dat$Type)
  dat <- subset(data,time==2)
  x.mm <- max(dat$Variable,na.rm=TRUE)
  plot(dat$TimeVariable,dat$Variable,axes=FALSE,ylab="",xlab="",xlim=c(0,x.mm),
       ylim=c(0,2.4),xaxs="i",yaxs="i",pch=19)
  dat <- subset(data,time==2)
  lines(dat$TimeVariable,dat$Variable)
  axis(2,tick=T,at=seq(0.0,2.4,by=0.6),label= seq(0.0,2.4,by=0.6))
  axis(1,tick=T,at=seq(0,x.mm,by=6),label=seq(0,x.mm,by=6))
  mtext(Type,side=1,outer=F,line=-10,adj=0.8)
  minor.tick(nx=5,ny=5)
  par(new=TRUE)
  dat <- subset(data,time==1)
  plot(dat$TimeVariable,dat$Variable,axes=FALSE,xlab="",ylab="",type="l",
       ylim=c(800,0),xaxs="i",yaxs="i")
  axis(3,xlim=c(0,24),tick=TRUE,at= seq(0,24,by=6),label=seq(0,24,by=6),col.axis="violetred4",col="violetred4")
  axis(4,tick=TRUE,at= label1,label=label1,col.axis="violetred4",col="violetred4")
  polygon(dat$TimeVariable,dat$Variable,col='violetred4',border=NA)
}) `ggplot2 facet_wrap ## transform your data to a data.frame
 dat.l <- do.call(rbind,ll)
 library(ggplot2)
 ggplot(subset(dat.l,time !=1)) +
  geom_line(aes(x=TimeVariable,y=Variable,group=time,color=time))+
  geom_polygon(data=subset(dat.l,time ==1),
              aes(x=TimeVariable,y=60-Variable/10,fill=Type))+
  geom_line(data=subset(dat.l,time ==1),
               aes(x=TimeVariable,y=Variable,fill=Type))+
  facet_wrap(~Type,scales='free')
-------------------------------------------------------------------------------------------------------
minor.tick box() minor.tick
-------------------------------------------------------------------------------------------------------
data <- read.csv("stackfig1_2.csv")
library(Hmisc)

label1=c(0,100,200,300)
plot(data$TimeVariable2C,data$Variable2C,axes=FALSE,ylab="",xlab="",xlim=c(0,24),
     ylim=c(0,2.4),xaxs="i",yaxs="i",pch=19)
lines(data$TimeVariable3C,data$Variable3C)
axis(2,tick=T,at=seq(0.0,2.4,by=0.6),label= seq(0.0,2.4,by=0.6))
axis(1,tick=T,at=seq(0,24,by=6),label=seq(0,24,by=6))
mtext("(C)",side=1,outer=F,line=-10,adj=0.8)
minor.tick(nx=5,ny=5)

par(new=TRUE)
plot(data$TimeVariable1C,data$Variable1C,axes=FALSE,xlab="",ylab="",type="l",
     ylim=c(800,0),xaxs="i",yaxs="i")
axis(3,xlim=c(0,24),tick=TRUE,at= seq(0,24,by=6),label=seq(0,24,by=6),col.axis="violetred4",col="violetred4")
axis(4,tick=TRUE,at= label1,label=label1,col.axis="violetred4",col="violetred4")
polygon(data$TimeVariable1C,data$Variable1C,col='violetred4',border=NA)


legend("top", legend = c("Variable A","Variable B","Variable C"), col = c("black","violetred4","black"),
       ncol = 2, lwd =c("","",2),pch=c(19,15,NA),cex=1) cex
-------------------------------------------------------------------------------------------------------
dist dist nn <- paste0('row',1:5)
x <- matrix(rnorm(25), nrow = 5,dimnames=list(nn))
distObj <- dist(x)
cols <- c("#D33F6A", "#D95260", "#DE6355", "#E27449", 
            "#E6833D", "#E89331", "#E9A229", "#EAB12A", "#E9C037", 
            "#E7CE4C", "#E4DC68", "#E2E6BD")
## mandatory coercion
distObj <- as.matrix(distObj)
## hetamap
image(distObj[order(nn), order(nn)], col = cols, 
      xaxt = "n", yaxt = "n")
## axes labels
axis(1, at = seq(0, 1, length.out = dim(distObj)[1]), labels = nn, 
     las = 2)
axis(2, at = seq(0, 1, length.out = dim(distObj)[1]), labels = nn, 
     las = 2)
-------------------------------------------------------------------------------------------------------
?plot ?abline ?text d <- data.frame(Name=LETTERS, Odds_Ratio_log2=runif(26, -8, 8), 
                p_value=runif(26))
plot(d$Odds_Ratio_log2, d$p_value, pch=20, xlim=c(-8, 8), ylim=c(0, 1),
     axes=F, xlab='', ylab='', yaxs='i')
abline(v=0, lwd=3)
axis(3, lwd=3, at=seq(-8, 8, 1), cex.axis=0.8, lwd.ticks=1)
mtext('Odds (Log2)', 3, line=2.5)
text(d$Odds_Ratio_log2, d$p_value, d$Name, pos=4, cex=0.7) yaxs='i' plot axes=F ?axis mtext ylab '' plot mtext('p-value', 2) segments text segments(-0.1, seq(0, 1, 0.1), 0, seq(0, 1, 0.1), lwd=2)
text(rep(0, 10), seq(0, 1, 0.1), seq(0, 1, 0.1), cex=0.7, pos=2) opar <- par(no.readonly = TRUE)
d <- data.frame(Name=LETTERS, Odds_Ratio_log2=runif(26, -8, 8), 
                p_value=runif(26))
plot(d$Odds_Ratio_log2, d$p_value, pch=20, xlim=c(-8, 8), ylim=c(0, 1),
     axes=F, xlab='', ylab='', yaxs='i', col='gray20')
abline(v=0, lwd=3)
axis(3, lwd=3, at=seq(-8, 8, 1), cex.axis=0.8, lwd.ticks=1)
mtext('Odds (Log2)', 3, line=2.5)
text(d$Odds_Ratio_log2, d$p_value, d$Name, pos=4, offset=0.3, cex=0.7)

par(xpd=NA)
segments(-0.1, seq(0.1, 0.9, 0.1), 0, seq(0.1, 0.9, 0.1), lwd=2)
text(rep(0, 10), seq(0.1, 0.9, 0.1), seq(0.1, 0.9, 0.1), 
     cex=0.7, pos=2, offset=0.3)
par(opar)
-------------------------------------------------------------------------------------------------------
d <- rlnorm(1000, 3)
d.cut <- cut(d, c(seq(0, 120, 10), Inf))
hist(as.numeric(d.cut), breaks=0:13, xaxt='n', xlab='', 
     col=1, border=0, main='', cex.axis=0.8, las=1)
axis(1, at=0:13, labels=c(seq(0, 120, 10), '>120'), cex.axis=0.8)
box()
-------------------------------------------------------------------------------------------------------
set.seed(1)
x <- as.ts(rnorm(1:150))
# Take a look at the x-axis
plot <- plot(x) tt = seq(as.Date("1994-03-01"), by="months", length=150)
tsAxis <- function (tt) {
  ix <- seq_along(tt) # number of ticks 
  fmt <- "%b-%y"  # format of time 
  labs <- format(tt, fmt) # names or labels of dates
  # Change "at=tt[ix]" to "at=ix" here!
  axis(1, at = ix, labels = labs[ix],  tcl = -0.7, cex.axis = 0.7, las = 2)
} ix <- seq_along(tt) ix <- seq(1, length(tt), 3)
-------------------------------------------------------------------------------------------------------
barplot(c - 0.4,names.arg=name,axes = FALSE)
axis(side = 2,at = seq(0,0.6,by = 0.2),labels = as.character(seq(0.4,1.0,by = 0.2))) c
-------------------------------------------------------------------------------------------------------
dat <- data.frame(distance <- seq(-1500 ,1500 ,25),
                  A=rnorm(length(distance),mean=0,sd=0.1),
                  B=rnorm(length(distance),mean=0,sd=0.09))

plot(dat[,c(1,2)],type="l",
     col="blue",
     main="My Title",
     xlab="My X Label",
     ylab="My Y Label",
     axes=F)
lines(dat[,c(1,3)],type="l",col="red")

axis(1, pos=0,las=1)
axis(2, pos=0,las=1)

legend("topright", pch = c("-","-"), 
       col = c("blue", "red"), 
       legend = c("A", "B"))
-------------------------------------------------------------------------------------------------------
cex par() plot() # example from ?hclust
hc <- hclust(dist(USArrests), "ave")

# default label size
plot(hc, xlab="xlab", ylab="ylab", main="main", sub="")

# reduced label size
par(cex=0.3, mar=c(5, 8, 4, 1))
plot(hc, xlab="", ylab="", main="", sub="", axes=FALSE)
par(cex=1)
title(xlab="xlab", ylab="ylab", main="main")
axis(2)
-------------------------------------------------------------------------------------------------------
axis() xaxt="n" plot() plot(quantity,xaxt="n")
axis(1,at=1:3,labels=names(quantity))
-------------------------------------------------------------------------------------------------------
## Recreate the data
my.data <- c(6,6,4,5,8,9,8,6,3,3,4,5,4,2,1,5,3,3,4,2,4,8,3,1,6,5,4,3,9,8,2,6,8,3,4,5,7,6,2,2,10,9,6,8,9,4,6,7)
n.block <- 6
n.sect  <- 8
my.list <- split(my.data, rep(1:n.block, each = n.sect))
names(my.list) <- paste0("Block", 1:n.block)
sect.name <- paste0("T", 1:n.sect)

## Plot
scale.fact <- max(my.data)
plot(my.list[[1]], type = "n", axes = FALSE, ylim = c(1, n.block + 1), xlab = "", ylab = "")
for (i in seq(along = my.list)){
    lines(i + my.list[[i]]/scale.fact)
}
axis(1, at = 1:n.sect, labels = sect.name, tick = TRUE)
axis(2, at = 1:n.block + sapply(my.list, function(x) x[[1]][1])/scale.fact,
 labels = names(my.list), tick = TRUE, las = 1)
-------------------------------------------------------------------------------------------------------
lines() Change axis() at= labels= at= x<-barplot(Sales,ylim=c(0,1000))
lines(x,Change*1000,type="b")
axis(4,at=seq(0,800,200),labels=seq(0,800,200)/1000)
-------------------------------------------------------------------------------------------------------
par("usr") xaxs="i" xlim par(mar=c(5,5,2,5)) # change margins
x = barplot(Sales, ylim=c(0,1000)) # barplot, keep middle points of bars
mtext("Sales", 2, line=3) # first y-axis label
xlim = par("usr")[1:2] # get xlim from plot
par(new=TRUE) 
plot.new() # new plot
plot.window(xlim=xlim, ylim=c(0,1), xaxs="i", yaxs="i") # new plot area, same xlim
lines(x,Change,type="b") # the lines in the middle points
axis(4) # secondary y-axis
mtext("Change", 4, line=3) # secondary y-axis label
box()
-------------------------------------------------------------------------------------------------------
axis at labels las=2 plot(meanResidents, axes=FALSE, xlab="dorms")
axis(2)
axis(1, at=seq_along(meanResidents),labels=as.character(rmNumber), las=2)
box()
-------------------------------------------------------------------------------------------------------
x$MonthNum <- sapply(x$Month, function(x) which(x==month.name)) plot(NA, xaxt="n", xlab="Month", xlim=c(0,13),
    ylim=c(.96*min(x$Value),1.04*max(x$Value)), type="l")
z <- sapply(1996:1998, function(y) with(x[x$Year==y,], lines(MonthNum, Value1)))
axis(1, at=1:12, labels=month.name) xlabpos <- tapply(x$MonthNum, x$Year, max)
ylabpos <- mapply(function(mon, year) x$Value1[x$MonthNum==mon & x$Year==year],     
    xlabpos, dimnames(xlabpos)[[1]])
text(x=xlabpos+.5, y=ylabpos, labels=dimnames(xlabpos)[[1]]) layout par(mar=c(2,4,1,1))
layout(matrix(1:3))
z <- sapply(1996:1998, function(y) {
    with(x[x$Year==y,], plot(Value1 ~ MonthNum, xaxt="n", xlab="Month", ylab=y,
        xlim=c(0,13), ylim=c(.96*min(x$Value),1.04*max(x$Value)), type="l"))
    axis(1, at=1:12, labels=month.name)
})
-------------------------------------------------------------------------------------------------------
dtime <- as.POSICct(SubDateTime$DateTime)
at <- format(SubDateTime$DateTime, "%H") %in% c("00", "06", "12", "18")
axis(side = 1,at = SubDateTime$DateTime[at],labels = format(SubDateTime$DateTime[at], "%a-%H"))
 dtime <- seq(as.POSIXct("2013-06-01 00:00:00"),as.POSIXct("2013-06-02 00:00:00"), by="5 min")

dtime.lt <- as.POSIXlt(dtime)
at <- format(dtime.lt, "%H") %in% c("00", "06", "12", "18")
axis(side = 1,at = dtime.lt[at],labels = format(dtime.lt[at], "%a-%H"))

-------------------------------------------------------------------------------------------------------
scales library(scales)
x <- 10 ^ (1:10)
scientific_format(1)(x)
[1] "1e+01" "1e+02" "1e+03" "1e+04" "1e+05" "1e+06" "1e+07" "1e+08" "1e+09" "1e+10" ggplot2 library(ggplot2)
dat <- data.frame(x  = c(102, 258, 2314),                                                                     
                  y  = c(482563, 922167, 4462665))

qplot(data=dat,x=x,y=y) + 
  scale_y_continuous(label=scientific_format(digits=1))+ 
  theme(axis.text.y =element_text(size=50)) axis mtext y <- c(102, 258, 2314)                                                                         
x <- c(482563, 922167, 4462665)
plot(x,y,ylab='',yaxt='n')
mtext(expression(10^3),adj=0,padj=-1,outer=FALSE)
axis(side=2,at=y,labels=round(y/1000,2))
-------------------------------------------------------------------------------------------------------
boxplot.stats polygon boxpattern <- 
function(y, xcenter, boxwidth, angle=NULL, angle.density=10, ...) {
    # draw an individual box
    bstats <- boxplot.stats(y)
    bxmin <- bstats$stats[1]
    bxq2 <- bstats$stats[2]
    bxmedian <- bstats$stats[3]
    bxq4 <- bstats$stats[4]
    bxmax <- bstats$stats[5]
    bleft <- xcenter-(boxwidth/2)
    bright <- xcenter+(boxwidth/2)
    # boxplot
    polygon(c(bleft,bright,bright,bleft,bleft),
        c(bxq2,bxq2,bxq4,bxq4,bxq2), angle=angle[1], density=angle.density)
    polygon(c(bleft,bright,bright,bleft,bleft),
        c(bxq2,bxq2,bxq4,bxq4,bxq2), angle=angle[2], density=angle.density)
    # lines
    segments(bleft,bxmedian,bright,bxmedian,lwd=3) # median
    segments(bleft,bxmin,bright,bxmin,lwd=1) # min
    segments(xcenter,bxmin,xcenter,bxq2,lwd=1)
    segments(bleft,bxmax,bright,bxmax,lwd=1) # max
    segments(xcenter,bxq4,xcenter,bxmax,lwd=1)
    # outliers
    if(length(bstats$out)>0){
        for(i in 1:length(bstats$out))
            points(xcenter,bstats$out[i])
    }
}

drawboxplots <- function(y, x, boxwidth=1, angle=NULL, ...){
    # figure out all the boxes and start the plot
    groups <- split(y,as.factor(x))
    len <- length(groups)
    bxylim <- c((min(y)-0.04*abs(min(y))),(max(y)+0.04*max(y)))
    xcenters <- seq(1,max(2,(len*(1.4))),length.out=len)
    if(is.null(angle)){
        angle <- seq(-90,75,length.out=len)
        angle <- lapply(angle,function(x) c(x,x))
    }
    else if(!length(angle)==len)
        stop("angle must be a vector or list of two-element vectors")
    else if(!is.list(angle))
        angle <- lapply(angle,function(x) c(x,x))
    # draw plot area
    plot(0, xlim=c(.97*(min(xcenters)-1), 1.04*(max(xcenters)+1)),
        ylim=bxylim, 
        xlab="", xaxt="n",
        ylab=names(y), 
        col="white", las=1)

    axis(1, at=xcenters, labels=names(groups))
    # draw boxplots
    plots <- mapply(boxpattern, y=groups, xcenter=xcenters,
        boxwidth=boxwidth, angle=angle, ...)
} mydat <- data.frame(y=c(rnorm(200,1,4),rnorm(200,2,2)),
                    x=sort(rep(1:2,200)))
drawboxplots(mydat$y, mydat$x) mydat <- data.frame(y=c(rnorm(200,1,4),rnorm(200,2,2),
                        rnorm(200,3,3),rnorm(400,-2,8)),
                    x=sort(rep(1:5,200)))
drawboxplots(mydat$y, mydat$x) drawboxplots(mydat$y, mydat$x, boxwidth=.5, angle.density=30) drawboxplots(mydat$y, mydat$x, # specify list of two-element angle parameters
             angle=list(c(0,0),c(90,90),c(45,45),c(45,-45),c(0,90))) x <- rep(1:10,10)
y <- sort(x)
plot(y~x, xlim=c(0,11), ylim=c(0,11), pch=20)
outerbox.x <- c(2.5,0.5,10.5,10.5,0.5,0.5,2.5,7.5,7.5,2.5)
outerbox.y <- c(2.5,0.5,0.5,10.5,10.5,0.5,2.5,2.5,7.5,7.5)
polygon(outerbox.x,outerbox.y, col="white", border="white") # donut
polygon(c(2.5,2.5,7.5,7.5,2.5),c(2.5,2.5,2.5,7.5,7.5)) # inner box
-------------------------------------------------------------------------------------------------------
plot(1:4)
value<-c(10,20)
index<-c("a","b")

lab <- rep(expression(paste("n"[index], "=", value, sep="")),2)

for (i in 1:length(lab)) {
  lab[i] <- eval(substitute(substitute(expr, list(value=value[i], index=index[i])), list(expr= as.call(lab[i]))))
}

axis(3,at=c(2,3),labels=lab)
-------------------------------------------------------------------------------------------------------
meanqual 1:length(meanqual) seq() length meanqual plot plot <- plot(x=seq(5,90,5), y=meanqual, type="o", 
             xlab="% Size of Wave", ylab="Values",xaxt='n', lty=1)
legend('bottomright', c("Values"),pch=21, lty=1, cex=1)
axis(side=1, at= seq(10,90,5), labels=seq(10,90,5))
-------------------------------------------------------------------------------------------------------
axis plot(seq(1,100,10), rnorm(10),type='l',cex.axis=2,
     lwd.ticks=5)
axis(1, 1:100[-c(20,40,60,80,100)],
     1:100[-c(20,40,60,80,100)],tick=TRUE,
     cex.axis=0.8)
-------------------------------------------------------------------------------------------------------
grid = 1:100

x = rnorm(100)
plot(x,type='l')
axis(1,grid[c(-20,-40,-60,-80,-100)],grid[c(-20,-40,-60,-80,-100)],cex.axis=.5,line=-1,tick=FALSE)
-------------------------------------------------------------------------------------------------------
axis axis op <- par(mfrow = c(2,1))
set.seed(1)
rr <- rnorm(5)
plot(rr, 1:5,  frame.plot = TRUE)
plot(rr, 1:5, axes = FALSE, frame.plot = TRUE)
my.at <- round(rr,4)
axis(1, at = my.at, labels = my.at)
-------------------------------------------------------------------------------------------------------
polygon workingtime$s <- as.numeric( gsub( ":.*", "", workingtime$TIME_START ) ) + as.numeric( gsub( ".*:", "", workingtime$TIME_START ) ) / 60
workingtime$e <- as.numeric( gsub( ":.*", "", workingtime$TIME_END ) ) + as.numeric( gsub( ".*:", "", workingtime$TIME_END ) ) / 60
plot( NULL, xlim= c( 0.5, 7.5 ), ylim= c( 24, 0 ), xaxt= "n", xlab= "Week", ylab= "Hour" )
axis( 1, at=seq( 0.5, 7.5 ), labels= rep( "", 8 ) )
workingtime$day <- as.numeric( factor( workingtime$DATE ) )
for( i in 1:nrow( workingtime ) ) { 
  x <- c( -0.5, 0.5, 0.5, -0.5 ) + workingtime[i, "day"]
  y <- rep( c( workingtime[i,"s"], workingtime[i,"e"] ), each= 2 )
  polygon( x, y, col= workingtime[i,"SHIFT"]  ) 
} strptime strftime as.Date
-------------------------------------------------------------------------------------------------------
plot.title plot.axes key.title key.axes ?filled.contour ...: additional graphical parameters, currently only passed to
      ‘title()’. x=1:10
y=1:10
z=array(rnorm(100),dim=c(10,10))

filled.contour(x,y,z,las=0,
  plot.axes={
              axis(1,cex.axis=2)
              axis(2,cex.axis=2)
            },
  plot.title={
              title(xlab="x",cex.lab=2)
              mtext("y",2,cex=2,line=3,las=1)
  }
)
-------------------------------------------------------------------------------------------------------
par( mar = par( "mar" ) + c( 2, 4, 0, 0 ) )
image( x, xaxt= "n", yaxt= "n" )
axis( 1, at=seq(0,1,length.out=ncol( x ) ), labels= colnames( x ), las= 2 )
axis( 2, at=seq(0,1,length.out=nrow( x ) ), labels= rownames( x ), las= 2)
-------------------------------------------------------------------------------------------------------
plot(1:10, rnorm(10), ylim=c(0,1), ylim=c(-1,100))
Error in plot.default(1:10, rnorm(10), ylim = c(0, 1), ylim = c(-1, 100)) : 
  formal argument "ylim" matched by multiple actual arguments hist(x, prob = TRUE, main = main2, xlab = xlab2, ylim = c(0, maxy), ...) maxy <- max(max(a$density), 0.3989 * mix.object$lambda/mix.object$sigma) library(mixtools)
wait = faithful$waiting
mixmdl = normalmixEM(wait)
plot.new()
plot.window(xlim=c(25,110), ylim=c(0,0.5))
plot(mixmdl, which = 2, nclass=20, add = TRUE)
lines(density(wait), lty = 2, lwd = 2)
box(); axis(1); axis(2); title(xlab="Data", ylab="Density")
-------------------------------------------------------------------------------------------------------
library(reshape2)
m = melt(my.datamat)

s3d = scatterplot3d(m, type = "h"
              , lwd = 5, pch = " "
              , x.ticklabs = rownames(my.datamat)
              , y.ticklabs = colnames(my.datamat)
              , color = grey(150:1 / 200), main = "Northern Trust Data"
              ,lab=c(length(rownames(my.datamat)),length(colnames(my.datamat))) # defines how many ticks should appear on each axis
                    ) # regression plane
s3d$plane3d(lm(value~., data=nt.dat), lty.box="solid" ) plot(0,0, xlim=c(1,length(colnames(my.datamat)))
        ,ylim = range(my.datamat)
     , type='n'
     ,xaxt = "n")

sapply(1:length(rownames(my.datamat))
       ,function(i){lines(my.datamat[i,]
                          , col=i)} )

legend("topright"
       , legend=rownames(my.datamat)
       ,lty=rep(1,length(rownames(my.datamat)))
       ,col=c(1:length(rownames(my.datamat)))
       )

axis(1, at = 1:length(colnames(my.datamat))
      , labels=colnames(my.datamat))
-------------------------------------------------------------------------------------------------------
#Subsetting to only the vectors I want to see in the correlation, as ordered
insheet<-subset(insheet1,
    select=c("Cond", "CL", "SO4", "TN", "TP", "OrthoPhos", "DO", ...., "Rural"))

#Defining "high" and "low" colors
library(colorspace)
mycolors<-diverge_hcl(8,  h = c(8, 240), c = 80, l = c(50,100), power = 1)

#Correlating them into a matrix
sheet<-cor(insheet,use="complete.obs")

#Making it!
image(x=seq(dim(sheet)[2]), y=seq(dim(sheet)[2]), z=sheet, ann=FALSE, 
    col=mycolors,  xlab="x column", ylab="y column", xaxt='n', yaxt='n')
text(expand.grid(x=seq(dim(sheet)[2]), y=seq(dim(sheet)[2])),
    labels=round(c(sheet),2), cex=0.5)
axis(1, 1:dim(insheet2)[2], colnames(insheet2), las=2)
axis(2, 1:dim(insheet2)[2], colnames(insheet2), las=2)
par(mar=c(5.5, 5.5, 2, 1)) #Moves margins over to allow for axis labels
-------------------------------------------------------------------------------------------------------
R> foo = ts(rnorm(36), frequency = 12, start = 2001)
R> plot(foo, xaxt = "n")
R> tsp = attributes(foo)$tsp
R> dates = seq(as.Date("2001-01-01"), by = "month", along = foo)
R> axis(1, at = seq(tsp[1], tsp[2], along = foo), labels = format(dates, "%Y-%m")) R> df = data.frame(date = seq(as.POSIXct("2001-01-01"), by = "month", length.out = 36), pcp = rnorm(36))
R> library(ggplot2)
R> library(scales)
R> p = ggplot(data = df, aes(x = date, y = pcp)) + geom_line()
R> p + scale_x_datetime(labels = date_format("%Y-%m"), breaks = date_breaks("months")) + theme(axis.text.x = element_text(angle = 45))
-------------------------------------------------------------------------------------------------------
filled contour image image.scale source("image.scale.R") # http://menugget.blogspot.de/2011/08/adding-scale-to-image-plot.html

x = c(20:200/100)
y = c(20:200/100)
z = as.matrix(exp(x^2)) %*% exp(y^2)

pal <- colorRampPalette(c('green','yellow','red'))
breaks <- c(1:60/3,30,50,150,250,1000,3000)
ncolors <- length(breaks)-1
labs <- c(0.5, 1, 3,30,50,150,250,1000,3000)

#x11(width=6, height=6)
layout(matrix(1:2, nrow=1, ncol=2), widths=c(5,1), heights=c(6))
layout.show(2)

par(mar=c(5,5,1,1))
image(x=x,y=y,z=log(z), col=pal(ncolors), breaks=log(breaks))
box()

par(mar=c(5,0,1,4))
image.scale(log(z), col=pal(ncolors), breaks=log(breaks), horiz=FALSE, xlab="", ylab="", xaxt="n", yaxt="n")
axis(4, at=log(labs), labels=labs)
box()
-------------------------------------------------------------------------------------------------------
if (!horizontal) {
    if (!add) {
        plot.window(xlim = xlim, ylim = ylim)
        axis(2)
        axis(1, at = at, label = label) if (!horizontal) {
    if (!add) {
        plot.window(xlim = xlim, ylim = ylim)
        axis(2)
        axis(1, at = at, label = label , las=2)
-------------------------------------------------------------------------------------------------------
axis x = sin(1:100) + rnorm(100, 0,.125)
breaks = c(10,33,85, 96)

plot(x)
sapply(breaks, function(x){abline(v=x, lty=2)})
axis(1, breaks, as.character(breaks)) plot(x, axes=F)
sapply(breaks, function(x){abline(v=x, lty=2)})
axis(1, breaks, as.character(breaks))
axis(2)
box()
-------------------------------------------------------------------------------------------------------
seqrplot seq?plot layout withlegend = FALSE opar <- par(mfrow=c(1,2))
seqrplot(mvad.seq, dist.matrix = mvad.dist,
         criterion = "density", nrep = 1, title = "End CS qualification",
         border = NA, axes=FALSE, withlegend=F)
axis(1, at = c(1, 6, 12, 18, 24, 30, 36, 42, 48, 54, 60, 66, 70), 
     labels = c(1, 6, 12, 18, 24, 30, 36, 42, 48, 54, 60, 66, 70))
seqlegend(mvad.seq)
par(opar)
-------------------------------------------------------------------------------------------------------
plot() hist.a$count a axis() labels= hist.a$mids set.seed(5555)
a <- rlnorm(1000)
hist.a <- hist(a, plot = FALSE)

hist.a
  $breaks
  [1]  0  5 10 15 20 25 30 35 40

  $counts
  [1] 955  34   6   2   2   0   0   1

  $density
  [1] 0.1910 0.0068 0.0012 0.0004 0.0004 0.0000 0.0000 0.0002

  $mids
  [1]  2.5  7.5 12.5 17.5 22.5 27.5 32.5 37.5

  $xname
  [1] "a"

  $equidist
  [1] TRUE

  attr(,"class")
  [1] "histogram"

plot(hist.a$count, log = "xy",xaxt="n",type="h",lwd=10,lend=2)
axis(1,at=1:length(hist.a$mids),labels=hist.a$mids)
-------------------------------------------------------------------------------------------------------
layout heatmap.2 ?heatmap.2 image axis library(gplots)

 heatmap3 <- function(mat1){
  image(mat1, Rowv=F, Colv=F,col=greenred(200), scale="row",
        key=TRUE, xlab=colnames(mat1), ylab=rownames(mat1), keysize=0.8)
  axis(1, at = seq(0, 1, length.out = dim(mat1)[1]), labels = gs, 
       las = 2)
  axis(2, at = seq(0, 1, length.out = dim(mat1)[1]), labels = gs, 
       las = 2)
  }
nf <- layout(matrix(c(1,2,3),3,1), widths = lcm(5), heights = lcm(5), TRUE)
heatmap3(mat1)
heatmap3(mat2)
heatmap3(mat3)
-------------------------------------------------------------------------------------------------------
plot(NA, xlim=c(.5,5.5), ylim=c(min(df)-1,max(df)+1),
         xaxt="n", xlab="Year", ylab="Value")
axis(1,1:5,labels=gsub("X","",names(df)))
apply(df,1,function(x) if(sum(!x==0)>0) points((1:ncol(df))[!x==0],x[!x==0],type="b") )
-------------------------------------------------------------------------------------------------------
x <- c(58, 68, 60, 80)
savplot <- barplot(x,space=0,col="yellow",border=NA)
axis(1,at=0:length(x),labels=seq(0,0.8,0.2))
par(xpd=NA)
text(labels=paste0(x,"%"),savplot,x+5,cex=1.5)
par(xpd=TRUE)
-------------------------------------------------------------------------------------------------------
rbind cbind # sample data
A1 <- rnorm(100,1)
B1 <- rnorm(100,2)
C1 <- rnorm(100,3)
D1 <- rnorm(100,4)
E1 <- rnorm(100,5)
A2 <- rnorm(100,3)
B2 <- rnorm(100,4)
C2 <- rnorm(100,5)
D2 <- rnorm(100,6)
E2 <- rnorm(100,7)

dflist <- list(A1=A1,B1=B1,C1=C1,D1=D1,E1=E1,A2=A2,B2=B2,C2=C2,D2=D2,E2=E2)
out <- data.frame(test=do.call(c,dflist))
out$group1 <- rep(1:10,times=sapply(dflist,function(x) length(x)))

# plot
boxplot(test~group1, data=out, at = c(seq(1,13,by=3),seq(2,14,by=3)),
    names=NA, col=rep(c("red","blue"),each=5))
axis(1,at=seq(1.5,13.5,by=3),labels=LETTERS[1:5])
legend(x=1, y=9, legend=c("Type 1","Type 2"), fill=c("red","blue"))
-------------------------------------------------------------------------------------------------------
x <- rnorm(100,100,10) par(las = 1) # rotates the y axis values for every plot you make from now on unless otherwise specified plotH(x,x,yaxt = 'n') # no Y axis axis(2,cex.axis = 0.5) # where 2 specifies the Y axis and 0.5 is half (0.5) of the font size as before.
-------------------------------------------------------------------------------------------------------
> print(data.frame(n=2:3, x=1:6))
- n x
1 2 1
2 3 2
3 2 3
4 3 4
5 2 5
6 3 6 > print(expand.grid(x=1:5, n=2:3))
-  x n
1  1 2
2  2 2
3  3 2
4  4 2
5  5 2
6  1 3
7  2 3
8  3 3
9  4 3
10 5 3 lapply(2:3, FUN=function(n) (f(n, x=1:5)))
#[[1]]
#[1] 0.0004981910 0.0006066275 0.0007328627 0.0008786344 0.0010456478
#
#[[2]]
#[1] 0.0007464956 0.0009087272 0.0010974595 0.0013152213 0.0015644676 wrapper <- function(i, x, n, fti){
    # As was provided by OP
    g<-function(x) {do.call(paste("d",i,sep=""),c(list(x=x),fti$estimate))}

    G<-function(x) {do.call(paste("p",i,sep=""),c(list(q=x),fti$estimate))}
    # does the i in fti refer to fit of i:th distribution, i.e. should it be a list where i:th location in ft is i:th distribution estimates?

    f<-function(n,x) {n*g(x)*(1-G(x))^(n-1)}
    # was missing a '-' and a '}'

    h<- function(n) {integrate(function(x) {x*f(n,x)},0,Inf)}

    list(gres = g(x), Gres = G(x), fres = f(n,x), hres = h(n))
}

# Example data
require("fitdistrplus")
data(groundbeef)
serving <- groundbeef$serving

# Gumbel distribution
d1 <- function(x, a, b) 1/b*exp((a-x)/b)*exp(-exp((a-x)/b))
p1 <- function(q, a, b) exp(-exp((a-q)/b))
q1 <- function(p, a, b) a-b*log(-log(p))

fti1 <- fitdist(serving, "1", start=list(a=10, b=10))
#> fti1$estimate
#       a        b 
#56.95893 29.07871

# Normal distribution

# dnorm, pnorm and qnorm are available in the default environment
d2 <- dnorm
p2 <- pnorm
q2 <- qnorm

fti2 <- fitdist(serving, "2", start=list(mean=0, sd=1))
#> fti2$estimate
#    mean       sd 
#73.67743 35.92581

# Sequence of x-values
xs <- seq(-100, 100, by=1)

print((resultdist1n2 <- wrapper(i=1, x=xs, n=2, fti=fti1))$hres)
print((resultdist1n3 <- wrapper(i=1, x=xs, n=3, fti=fti1))$hres)
print((resultdist2n2 <- wrapper(i=2, x=xs, n=2, fti=fti2))$hres)
print((resultdist2n3 <- wrapper(i=2, x=xs, n=3, fti=fti2))$hres)

plot(xs, resultdist1n2$fres, col=1, type="l", ylim=c(0,0.025), xlab="x", ylab="f(n, x)")
points(xs, resultdist1n3$fres, col=2, type="l")
points(xs, resultdist2n2$fres, col=3, type="l")
points(xs, resultdist2n3$fres, col=4, type="l")
legend("topleft", legend=c("Gamma (i=1) n=2", "Gamma (i=1) n=3", "Normal (i=2) n=2", "Normal (i=2) n=3"), col=1:4, lty=1) h(n=2) for distribution i=1:
53.59385 with absolute error < 0.00022
h(n=3) for distribution i=1:
45.23146 with absolute error < 4.5e-05
h(n=2) for distribution i=2:
53.93748 with absolute error < 1.1e-05
h(n=3) for distribution i=2:
44.06331 with absolute error < 2e-05 ns <- 0:256
res1 <- lapply(ns, FUN=function(nseq) wrapper(i=1, x=xs, n=nseq, fti=fti1))
par(mfrow=c(1,2))
plot.new()
plot.window(xlim=c(-100,100), ylim=c(0, 0.05))
box(); axis(1); axis(2); 
title(xlab="x", ylab="f(n,x)", main="f(n,x) for gamma (i=1), n=0:256")
for(i in 1:length(ns)) points(xs, res1[[i]]$fres, col=rainbow(257)[i], type="l")
# perform similarly for the other distributions by calling with i=2, fti=fti2
# h as a function of n for dist i=1
plot(ns, unlist(lapply(res1, FUN=function(x) x$hres$value)), col=rainbow(257), xlab="n", ylab="h(n)", main="h(n) for gamma (i=1), n=0:256")
-------------------------------------------------------------------------------------------------------
pyramide <- function(data,laxis,raxis) {
  a <- as.character(data$A)
  m<-data$m
  f<-data$f
  ff<- -m

  par(mai=c(1,1,1,.2))
  layout(matrix(1:2,nrow=1))
  barplot(ff,
          horiz=T,main="Hommes",
          space=0,
          col="grey",
          xlim=c(-1,0),
          axes=F,
          axisnames=F,
          cex.axis =0.7,
          xaxt="n", yaxt="n")
  axis(1,at=-laxis,labels=sprintf("%1.1f",laxis),cex.axis =0.7)

  par(mai=c(1,.3,1,1))
  barplot(f,
          horiz=T,
          main="Femmes",
          space=0,col="grey",
          xlim=c(0,1),
          axes=F,axisnames=F,
          cex.axis =0.7)
  axis(1,at=laxis,labels=sprintf("%1.1f",laxis),cex.axis =0.7)
  axis(2,at=as.numeric(a),labels=a,las=1,tcl=0,lty=0, cex.axis =0.5)
}

ages <- agelabels
l <-seq(1,0,by=-0.2)
r <-seq(0,1,by=0.2)
x <- data.frame(A=ages, m=pop.M, f=pop.F)

pyramide(x,l,r)
-------------------------------------------------------------------------------------------------------
mai mar par(mai = c(1, strwidth(label, units="inches")+.25, .8, .2))
plot(1:2, axes=FALSE)
axis(side = 2, at = 1, labels = label, las = 2, tck = 0, lty = 0) mar mai inches_to_lines <- ( par("mar") / par("mai") )[1]  # 5
lab.width <- strwidth(label, units="inches") * inches_to_lines
par(mar = c(5, 1 + lab.width, 4, 2) + 0.1) 
plot(1:2, axes=FALSE)
axis(side = 2, at = 1, labels = label, las = 2, tck = 0, lty = 0)
-------------------------------------------------------------------------------------------------------
histo<-hist(yourvariable)
barplot(histo$counts/n,col="white",space=0)->bp   # n=length(yourvariable)
axis(1,at=c(bp),labels=histo$mids)
title(ylab="Relative Frequency",xlab="Your Variable Name")
-------------------------------------------------------------------------------------------------------
maraqa <- c(84.8,68.9,84.9,92.5)
aqua <- c(75,65.1,79.4,82.3)
mar <- c(84.7,68.3,84.5,77.4)

# combine data as matrix
mat<-cbind(maraqa, aqua, mar)
rownames(mat)<-c("A", "B", "C", "D")

#define colours
coll<-c("red", "blue", "black")

matplot(mat, type="l", ylim=c(60, 95), ylab="y TBA", main="TBA", xlab="x TBA", 
        axes=FALSE, frame.plot=FALSE, col=coll, lty=rep(1,3))
# axes= do you want standart axis or make your own?
# frame.plot= frame arround plot yes/no

matpoints(mat, pch=rep(17,3), col=coll, ad=TRUE)
# to add points, pch controlls for type of points

axis(side=1, 1:4, labels=rownames(mat))
axis(side=2, 60:95, labels=60:95)
legend("topleft",# position
       legend=c("maraqa", "aqua", "mar"),# names in legend,
       lty=c(1,1,1),# type of filling in this case solide line,
       col = coll,# colour of filling, 
       cex=0.7)# scaling parameter
-------------------------------------------------------------------------------------------------------
par(mfrow=c(1,2))
barplot(data2,axes=F,horiz=T,axisnames=FALSE,
        xlim=c(-8,0))

#creating a new axis with desired labels
axis(side=1,at=seq(-8,0,2),labels=c(8,6,4,2,0))
barplot(data1,horiz=T,axes=T,las=1)
-------------------------------------------------------------------------------------------------------
plot x <- c(.5, 1.5, 3.4)
plot(0, xlim = c(0, 3.5), axes=FALSE, type = "n", xlab = "", ylab = "")
axis(1, at = x, labels = x)
-------------------------------------------------------------------------------------------------------
library(grid)
grid.newpage()
grid.xaxis(at=c(0.5, 1.5, 3.4), 
           vp=vpStack(viewport(height=unit(2,"lines")),
                      viewport(y=1, xscale = c(0.4, 3.5), just="bottom")))
-------------------------------------------------------------------------------------------------------
ylim seqIplot ylim group <- mvad$gcse5eq
(nseq <- xtabs(mvad$weight ~ group))
(nmax <- max(nseq))
seqIplot(mvad.seq, group=group, withlegend=TRUE,
         border=NA, xtstep=3, sortv="from.start",
         ylim=c(0, nmax) ) yaxis = FALSE seqIplot axis axis(2, at = c(1, nseq[1])) seqIplot withlegend=FALSE layout par(mfrow=...)
-------------------------------------------------------------------------------------------------------
# suppress the x-axis and save your original plot's bar locations
bp <- barplot(data,space=c(1,0.25),legend=rownames(data),
             col=c('white','black','grey'),las=2,
             xaxt="n")

# draw a new axis using these values
axis(1,at=rowMeans(matrix(bp,ncol=2,byrow=TRUE)),
     labels=unique(colnames(data)),lty=0) legend.args barplot
-------------------------------------------------------------------------------------------------------
x <- 10*1:nrow(volcano)
  y <- 10*1:ncol(volcano)
  filled.contour(x, y, volcano,asp=1, frame.plot=F,
  plot.axes = { axis(1, pretty(x,min=0), line=-4)
                axis(2, seq(0, 600, by = 100)) })
-------------------------------------------------------------------------------------------------------
cut aggregate ?cut ?aggregate cut breaks cut boxplot xaxt=FALSE boxplot aggregate length set.seed(1)
example <- data.frame(gene=sample(paste("gene",1:10),size=500,replace=TRUE),pval=sample(seq(0.01,1,0.01),500,replace=TRUE))
example$bin <- cut(example$pval,breaks=10)
boxplot(example$pval~example$bin,xaxt="n",ylab="p value",xlab="number of genes")
ngenes <- aggregate(example$gene,by=list("bin"=example$bin),length)
axis(side=1,labels=ngenes$x,at=1:10)
-------------------------------------------------------------------------------------------------------
#Example Data
n = 6
time02H = abs(rnorm(n))
time06H = abs(rnorm(n))
time24H = abs(rnorm(n))

allPAL.DE = data.frame(time02H,time06H,time24H)

plot(0,0,xlab="Time",ylab="Values",type="n",xlim=c(0,2),ylim=c(min(allPAL.DE,0),max(allPAL.DE)),axes="FALSE")
box()
axis(1,0:2,c("time02H","time06H","time24H"))
axis(2)
abline(h=0,col="grey",lty=2,lwd=2)

for(i in 1:nrow(allPAL.DE)){
    lines(0:2,allPAL.DE[i,],col=i,lwd=2)
}
-------------------------------------------------------------------------------------------------------
dat <- read.table(text="0.2 0.8 val1
0.3 0.7 val1
0.9 0.1 val1
0.22 0.78 val2
0.30 0.70 val3
0.00 1.00 val3",header=FALSE)

bp <- barplot(t(as.matrix(dat[1:2])))
axis(1,at=tapply(bp,dat[,3],mean),labels=unique(dat[,3])) bp <- barplot(t(as.matrix(dat[1:2])))
mapply(
  function(a,b,c) axis(1,at=c(a,b,c),labels=FALSE),
  tapply(bp,dat[,3],tail,1),
  tapply(bp,dat[,3],head,1),
  tapply(bp,dat[,3],mean)
)
axis(1,at=tapply(bp,dat[,3],mean),labels=unique(dat[,3]),lwd=NA)
-------------------------------------------------------------------------------------------------------
palette(c("red","green","yellow","blue","black"))
plot.default(
  as.data.frame.table(t(mat))[1:2],
  col=findInterval(t(mat),c(0,0.2,0.4,0.6,0.9)),
  pch=19,
  axes=FALSE,ann=FALSE,
  panel.first=grid()
)
axis(2,at=1:length(rownames(mat)),labels=rownames(mat),lwd=0,lwd.ticks=1,las=1)
axis(1,at=1:length(colnames(mat)),labels=colnames(mat),lwd=0,lwd.ticks=1)
box()
palette("default")
-------------------------------------------------------------------------------------------------------
Hmisc library(Hmisc)
plot(0, 0, type = "n", xlab = "", ylab = "", xaxt = "n",
     xlim = c(min(year), max(year)),ylim = c(0, 5000))
axis(1, at = seq(min(year),max(year),1), labels = xlab.pos, tck = -0.015)
minor.tick(nx = 3, ny = 0, tick.ratio = -1/2)
-------------------------------------------------------------------------------------------------------
plot(NA,NA,type="n",xaxt="n", lwd=linewidth, xlim=c(1,24), xlab="", ylab="",ylim=c(-300,500))
axis(side = 4, tck = .05, **lwd=0, lwd.ticks=1**, line = 0, labels = NA, col= cols_border[1], col.axis = cols_black)
axis(side = 4, lwd = 0, line = -4.5, las = 1, cex.axis=axis_fontsize, col= cols_border[1], col.axis = cols_black)
mtext("Light deviations (lum/sec)",side=4, padj=-2.5, cex=title_fontsize, col="black")
-------------------------------------------------------------------------------------------------------
plot(as.zoo(x), las=1)
par(new=TRUE)               
plot(as.zoo(y),
     col=2,
     bty='n',               
     xaxt="n",               
     yaxt="n",              
     xlab="", ylab="")

axis(4, las=1)

legend("topleft",           
       legend=c("x","y"), 
       col=1:2,
       lty=1,              
       cex=0.85)
-------------------------------------------------------------------------------------------------------
heatmap library(gplots)

# need data as matrix
mm <- as.matrix(testdf, ncol = 3)

heatmap.2(x = mm, Rowv = FALSE, Colv = FALSE, dendrogram = "none",
          cellnote = mm, notecol = "black", notecex = 2,
          trace = "none", key = FALSE, margins = c(7, 11)) heatmap.2 axis heatmap.2 axis(1 side addtable2plot library(plotrix)

# while plotrix is loaded anyway:
# set colors with color.scale
# need data as matrix*
mm <- as.matrix(testdf, ncol = 3)
cols <- color.scale(mm, extremes = c("red", "yellow"))

par(mar = c(0.5, 1, 2, 0.5))
# create empty plot
plot(1:10, axes = FALSE, xlab = "", ylab = "", type = "n")

# add table
addtable2plot(x = 1, y = 1, table = testdf,
              bty = "o", display.rownames = TRUE,
              hlines = TRUE, vlines = TRUE,
              bg = cols,
              xjust = 2, yjust = 1, cex = 3)

# *According to `?color.scale`, `x` can be a data frame.
# However, when I tried with `testdf`, I got "Error in `[.data.frame`(x, segindex) : undefined columns selected". color2D.matplot library(plotrix)
par(mar = c(0.5, 8, 3.5, 0.5))
color2D.matplot(testdf, 
                show.values = TRUE,
                axes = FALSE,
                xlab = "",
                ylab = "",
                vcex = 2,
                vcol = "black",
                extremes = c("red", "yellow"))
axis(3, at = seq_len(ncol(testdf)) - 0.5,
     labels = names(testdf), tick = FALSE, cex.axis = 2)
axis(2, at = seq_len(nrow(testdf)) -0.5,
     labels = rev(rownames(testdf)), tick = FALSE, las = 1, cex.axis = 2)
-------------------------------------------------------------------------------------------------------
text par(mar=c(6, 4.1, 4.1, 2.1))

labels <- paste(c("RB-GL830-[16]-10", 
                  "RB-GL830-[16]-30",
                  "SB-GL834-[11]-10",
                  "SB-GL834-[11]-30",
                  "RB-GL843-[17]-10",
                  "RB-GL843-[17]-30"))

boxplot(count ~ spray, data = InsectSprays,
        col = "lightgray", xaxt = "n",  xlab = "")

# x axis with ticks but without labels
axis(1, labels = FALSE)

# Plot x labs at default x position
text(x =  seq_along(labels), y = par("usr")[3] - 1, srt = 45, adj = 1,
     labels = labels, xpd = TRUE) x = seq_along(labels) x text ?boxplot at at boxplot seq_along length at plot
-------------------------------------------------------------------------------------------------------
y = ts(x$Used, start=c(2011, yday("2011-11-01")), frequency=365) y decimal_date(a3) unclass(y)
# [1] 587 578 600 599 678 555 650
# attr(,"tsp")
# [1] 2011.833 2011.849  365.000
decimal_date(a3)
# [1] 2011.833 2011.836 2011.838 2011.841 2011.844 2011.847 2011.850 y = ts(df$price) decimal_date(a3) unclass(y)
# [1] 12 14 15 14 13 16
# attr(,"tsp")
# [1] 1 6 1
decimal_date(a3)
# [1] 2010.115 2010.115 2010.115 2010.115 2010.116 2010.116 decimal_date axis(1, at = seq_along(a3), labels = format(a3, "%Y-%b-%d %H:%M:%S"), cex.axis=0.6, las=2) df$day <- as.POSIXlt(df$day)

y = zoo(df$price, df$day)

axis(1, at = as.numeric(df$day), labels = format(a3, "%Y-%b-%d %H:%M:%S"), cex.axis=0.6, las=2) day
-------------------------------------------------------------------------------------------------------
ylim= mvad.seq seqmtplot(mvad.seq, title="Mean time", ylim=c(0,30)) yaxis=FALSE withlegend=F par(mfrow=c(1,2))
seqmtplot(mvad.seq, title="Mean time", yaxis=F, ylim=c(0,30), withlegend=FALSE) 
axis(2, at=seq(from=0, to=30, by=5))
seqlegend(mvad.seq) seqmeant(mvad.seq)
-------------------------------------------------------------------------------------------------------
dat <- setNames(data.frame(rbind(b,d,g,p)),c("value","low","high"))
dat
#   value    low   high
#b 12.142 12.076 12.208
#d 12.800 12.700 12.900
#g 12.100 12.000 12.200
#p 12.669 12.528 12.811 ?par # in order - margins for bottom,left,top,right
# for reference, the defaults are c(5.1,4.1,4.1,2.1)
par(mar=c(5.1,9,4.1,9)) dev.new(width=5,height=4) # set some constants
  # nominal locations of points on x-axis
xpts <- 1:nrow(dat)
  # 95CI bar width
bar <- 0.05
  # colour scheme
palette(c("red","blue"))

# make the base plot
plot(xpts, dat$value, ylim=c(min(dat),max(dat)), 
     col=1:2, pch=19, cex=2, xaxt="n")

# add the axis back with proper labels
axis(1,at=xpts,labels=rownames(dat))

# add the 95% CI bars and lines
segments(xpts,dat$low,xpts,dat$high,col=1:2,lwd=2)
segments(xpts-bar,dat$low,xpts+bar,dat$low,col=1:2,lwd=2)
segments(xpts-bar,dat$high,xpts+bar,dat$high,col=1:2,lwd=2)
-------------------------------------------------------------------------------------------------------
tab <- read.table(textConnection('
"02/01/2012 13:30:00"     10
"10/01/2012 20:30:00"      8
"15/01/2012 13:30:00"     12
"25/01/2012 20:30:00"      6
"02/02/2012 13:30:00"      5
"10/02/2012 20:30:00"      3
"15/02/2012 13:30:00"      6
"25/02/2012 20:30:00"     -1
"02/03/2012 13:30:00"      4
"10/03/2012 20:30:00"     -2
"15/03/2012 13:30:00"      7
"25/03/2012 20:30:00"      1'))
tab[, 1] <- as.POSIXct(tab[, 1], format = "%d/%m/%Y %H:%M:%S")

plot(V2 ~ V1, data=tab, xaxt="n")
tck <- axis(1, labels=FALSE)
labels <- format(as.POSIXct(tck, origin="1970-01-01"), "%b %d")
text(tck, par("usr")[3], labels=labels, srt=315,
     xpd=TRUE, adj=c(-0.2,1.2), cex=0.9)
-------------------------------------------------------------------------------------------------------
axis() bp <- barplot(...) oldpar <-par(mar=c(7,5.1,4.1,2.1))

bp <- barplot(a,
        col=c("blue","red","purple"),
        ylab="Frequency of Interpretation",
        xlab="",
        main="Frequency of BrP and AmE Interpretations \n of NPs in Neutral Environments",
        axisnames=FALSE
       ) bp line=... axis() avgpts <- tapply(bp,rep(1:3,each=2),mean)
grps <- c("Bare NP","Singular-Marked NP","Plural-Marked NP")
subgrps <- c("BrP","AmE")
axis(1,at=bp,labels=rep(subgrps,3), cex.axis=0.7)
axis(1,at=avgpts,labels=grps, cex.axis=0.7,line=1.5,lwd=0)

title(xlab="Form of NP and Native Language",line=4.5)
-------------------------------------------------------------------------------------------------------
axes=FALSE segment() plot(x, y, axes=FALSE, ylim=c(0, 8), xlim=c(-0.4, 1.2), pch=19, 
     cex.axis=0.8, cex.lab=0.9, xlab="Male/Female expression ratio (log)", 
     ylab="Z/W expression ratio in females")
axis(side=1, cex.axis=0.8, cex.lab=0.9)
axis(side=2, cex.axis=0.8, cex.lab=0.9, las=1)
segments(x,      y-sd, x,      y+sd)
segments(x-0.02, y+sd, x+0.02, y+sd)
segments(x-0.02, y-sd, x+0.02, y-sd)
-------------------------------------------------------------------------------------------------------
text mtext axis axis # original code
grid = structure(c(1:12),.Dim = c(4,3))
labs = c("A","B","C")
image(1:4,1:3,grid,axes=FALSE, xlab="", ylab = "")
axiscolors = c("black","red","black")

# new code    
Map(function(x,y,z) 
  axis(2,at=x,col.axis=y,labels=z,lwd=0,las=1),
  1:3,
  axiscolors,
  labs
)
axis(2,at=1:3,labels=FALSE)
-------------------------------------------------------------------------------------------------------
text() xpd = TRUE mtext() grid = structure(c(1:20),.Dim = c(4,5))
labs = c("A","B","C","D","E")
redlabs = c("B","D")
colorlist = c("black","red")
# one of many ways to generate the color labels
axiscolor = colorlist[labs %in% redlabs +1 ]

image(1:4,1:5,grid,axes=FALSE, xlab="", ylab = "")
axis(2,at=1:length(labs),labels=FALSE)

# This would work for sideways labels
# mtext(text=labs, side=2,at=1:length(labs),col=axiscolor,adj=.5)
text(labels=labs, col=axiscolor, x=rep(.45,length(labs)),y=1:length(labs), srt = 0, pos = 2, xpd = TRUE)
-------------------------------------------------------------------------------------------------------
pracma::plotyy graphics::axis axis(side=4,{other setup arguments}) lines(data3,...) plotyy plotyy(x1, y1, x2, y2, gridp = TRUE, box.col = "grey",
                       type = "l", lwd = 1, lty = 1,
                       xlab = "x", ylab = "y", main = "",
                       col.y1 = "navy", col.y2 = "maroon", ...)
Arguments

x1, x2  
x-coordinates for the curves

y1, y2  
the y-values, with ordinates y1 left, y2 right.

type    
type of the curves, line or points (for both data). x1,y1 x2,y2
-------------------------------------------------------------------------------------------------------
?<function name> # here I generate some example data, set.seed makes it reproducible
set.seed(33)
x <- 1:20; y0 <- 20; y1 <- 25; y2 <- 300
for(i in 2:20){
  y0 <- c(y0, y0[i-1]+rnorm(1, mean=0.25, sd=1.5))
  y1 <- c(y1, y1[i-1]+rnorm(1, mean=0,    sd=1))
  y2 <- c(y2, y2[i-1]+rnorm(1, mean=-10,  sd=5))
}
max(y0, y1)  
# [1] 35.3668
min(y0, y1)
# [1] 17.77653
# from 0 to 50 seems like a reasonable Y range for the plotting area

windows()
  plot (x, y0, pch=6,  cex=.5, col="blue", type="b", 
        xlab="Mb", ylab="Pi", ylim=c(0, 50))
  lines(x, y1, pch=18, cex=.5, col="red",  type="b")

# We need to create a new variable that will fit within this plotting area
y2new <- scale(y2)        # this makes y2 have mean 0 & sd 1
y2new <- y2new*sd(y0)     # now its sd will equal that of y0
y2new <- y2new+mean(y0)   # now its mean will also equal that of y0

  lines(x, y2new, pch=24, cex=.5, col="green", type="b")

# now y2 fits within the window, but we need an axis which must map the 
#   plotted points to the original values

summary(y0)
#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
#   17.78   20.64   24.34   25.62   30.25   35.37
summary(y2)
#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
#   125.1   178.2   222.2   220.0   266.3   300.0
sd(y0)
# [1] 5.627629
sd(y2)
#[1] 54.76167

# thus, we need an axis w/ 25.62 showing 220 instead, & where 5.63 higher
#   shows 54.76 higher instead

increments <- (mean(y0)-seq(from=0, to=50, by=10))/sd(y0)
increments
# [1]  4.5521432  2.7751960  0.9982488 -0.7786983 -2.5556455
# [6] -4.3325927
newTicks   <- mean(y2) - increments*sd(y2)
newTicks
# [1] -29.24281  68.06579 165.37438 262.68298 359.99158
# [6] 457.30017

# the bottom of the y axis in the plot is 4.55 sd's below y0's mean, 
#   thus the bottom of the new axis should be about -30, and the top of 
#   the new axis should be about 460

  axis(side=4, at=seq(0, 50, 10), labels=round(newTicks), col="green")
  legend("bottomleft", c("y0 (left axis)", "y1 (left axis)", 
         "y2 (right axis)"), pch=c(6, 18, 24), lty=1, 
         col=c("blue", "red", "green")) plotyy()
-------------------------------------------------------------------------------------------------------
par(las=1, bty = 'n')
point_colors  <- c("royalblue4", "gray")
subjects <- c("Comp. Sc.\n(17.2%)", "Physics\n(19.6%)", "Maths\n(29.4%)",
              "Pol. Sc.\n(40.4%)", "Psychology\n(69.8%)")
aVals <- c(52.36, 52.00, 55.43, 56.08, 62.89)
bVals <- c(53.57, 52.93, 56.07, 58.86, 63.87)
n <- length(aVals)
plot(1:n, aVals, ylim = c(50, 65), type = 'l', col=point_colors[1], xlab="Disciplines (% of women)", ylab = "Classification accuracy (%)", xaxt = 'n', panel.first = grid(nx = NA, ny = NULL))
lines(1:n, bVals, col = point_colors[2])
axis(1, 1:5, subjects, cex.axis = 0.85, tcl = -0.1)
text(c(3.25, 3.5), c(54, 59), c('aVals', 'bVals')) par(las=1, bty = 'n')
point_colors  <- c("royalblue4", "gray")
subjects <- c("Comp. Sc.\n(17.2%)", "Physics\n(19.6%)", "Maths\n(29.4%)",
              "Pol. Sc.\n(40.4%)", "Psychology\n(69.8%)")
xpos <- c(17.2, 19.6, 29.4, 40.4, 69.8)
aVals <- c(52.36, 52.00, 55.43, 56.08, 62.89)
bVals <- c(53.57, 52.93, 56.07, 58.86, 63.87)
n <- length(aVals)
plot(xpos, aVals, ylim = c(50, 65), type = 'l', col=point_colors[1], xlab="Disciplines (% of women)", ylab = "Classification accuracy (%)", xaxt = 'n', panel.first = grid(nx = NA, ny = NULL))
lines(xpos, bVals, col = point_colors[2])
axis(1, xpos, subjects, cex.axis = 0.85, tcl = -0.1)
text(c(3.25, 3.5), c(54, 59), c('aVals', 'bVals'))
-------------------------------------------------------------------------------------------------------
plot(x,y, xlim=c(-0.5, 1.2), axes=FALSE, pch=19, ylim=c(0,8))
axis(1, pos=0)
axis(2, pos=0, at=0:8, labels=c("",1:8) )
-------------------------------------------------------------------------------------------------------
library(plotrix)
plot(3:10,main="Axis break test")
# put a break at the default axis and position
axis.break()
# or at a certain position
axis(axis=1, breakpos=3) # on x-axis position 3
-------------------------------------------------------------------------------------------------------
barplot axis(2, at = seq(length(WebPages$CustID)), labels = WebPages$CustID)
-------------------------------------------------------------------------------------------------------
true_Y = c(1,1,1,1,2,1,2,1,2,2)
probs = c(1,0.999,0.999,0.973,0.568,0.421,0.382,0.377,0.146,0.11)

getROC_AUC = function(probs, true_Y){
    probsSort = sort(probs, decreasing = TRUE, index.return = TRUE)
    val = unlist(probsSort$x)
    idx = unlist(probsSort$ix)  

    roc_y = true_Y[idx];
    stack_x = cumsum(roc_y == 2)/sum(roc_y == 2)
    stack_y = cumsum(roc_y == 1)/sum(roc_y == 1)    

    auc = sum((stack_x[2:length(roc_y)]-stack_x[1:length(roc_y)-1])*stack_y[2:length(roc_y)])
    return(list(stack_x=stack_x, stack_y=stack_y, auc=auc))
}

aList = getROC_AUC(probs, true_Y) 

stack_x = unlist(aList$stack_x)
stack_y = unlist(aList$stack_y)
auc = unlist(aList$auc)

plot(stack_x, stack_y, type = "l", col = "blue", xlab = "False Positive Rate", ylab = "True Positive Rate", main = "ROC")
axis(1, seq(0.0,1.0,0.1))
axis(2, seq(0.0,1.0,0.1))
abline(h=seq(0.0,1.0,0.1), v=seq(0.0,1.0,0.1), col="gray", lty=3)
legend(0.7, 0.3, sprintf("%3.3f",auc), lty=c(1,1), lwd=c(2.5,2.5), col="blue", title = "AUC")
-------------------------------------------------------------------------------------------------------
# plot with suppressed x axis
# xaxt = "n"  (see ?par)
plot(Counts ~ Time, data = df, type = "l", xaxt = "n")

# add a new x axis, using 'axis' function
#  with own specifications
# argument 'at': "the points at which tick-marks are to be drawn"
# make a sequence of numbers where the tick-marks is to be places using 'seq'
# from 0 to max Time with increments ('by') of 200 000. 
at <- seq(from = 0, to = max(df$Time), by = 200000)

# argument 'side': specifies which side of the plot the axis is to be drawn on.
# 1 = x axis

# argument 'labels'
# "If labels is not specified, the numeric values supplied or calculated for 'at'
# are converted to character strings as if they were a numeric vector printed
# but note: "The code tries hard not to draw overlapping tick labels,
# and so will omit labels where they would abut or overlap previously drawn labels"

axis(side = 1, at = at)

# to make the labels fit, one can use the 'las' argument
# "numeric in {0,1,2,3}; the style of axis labels"
# where 2: always perpendicular to the axis

plot(Counts ~ Time, data = df, type = "l", xaxt = "n", xlab = "")
axis(side = 1, at = at, las = 2, hadj = 0.9)
mtext(text = "Time", side = 1, line = 4)
-------------------------------------------------------------------------------------------------------
mydata <- read.csv(file="otu_tab_L4.txt", header=T, row.names=1, sep="\t")

    #transposes it and makes a matrix
    mydata_t <- t(as.matrix(mydata))

    #makes Spearman's correlation
    cor.matrix <- cor(mydata_t, method = "spearman")

    #remove upper part of the matrix, since it gives the same informations 
    cor.matrix[upper.tri(cor.matrix )] <- NA

    #checks matrix dimensions
    dim(cor.matrix)

    #Finally, I plotted a triangular heatmap of my matrix
    ##the standard function will put the y labels on the right!! I wanted them on the         left! So ##changed the heatmap.2 function code in this way:

    ####open the code:
    fix(heatmap.2)

    ###modify it in this way:
    ##when it says: " axis(4, iy, labels = labRow, las = 2, line = -0.5, tick = 0, cex.axis = cexRow) "
    ##I put 2 in place of 4!! 

    heatmap<-      heatmap.2(cor.matrix,scale="none",Rowv=NA,Colv=NA,col=rainbow,margins(5,5),cexRow=0.5,cexCol=1.0,key=TRUE,keysize=1.5,trace="none")
-------------------------------------------------------------------------------------------------------
cspy <- chart_Series(SPY )
cspy$Env$actions[[3]]
#------------------
expression(axt <- axTicksByTime(xdata[xsubset], format.labels = format.labels), 
    axis(1, at = axt, labels = names(axt), las = 1, lwd.ticks = 1, 
        mgp = c(3, 1.5, 0), tcl = -0.4, cex.axis = 0.9))
attr(,"frame")
[1] 1
attr(,"clip")
[1] TRUE
attr(,"env")
<environment: 0x11cddc148> las ?par attrs <- attributes(cspy$Env$actions[[3]])
cspy$Env$actions[[3]] <- 
      expression(axt <- axTicksByTime(xdata[xsubset], format.labels = "%b %d"), 
         axis(1, at = axt, labels = names(axt), las = 2, lwd.ticks = 1, mgp = c(3, 1.5, 0), tcl = -0.4, cex.axis = 0.9)) 
attributes(cspy$Env$actions[[3]]) <- attrs
cspy
-------------------------------------------------------------------------------------------------------
plot.xts add plot.xts plot.xtsMODIFIED<-function (x, y = NULL, type = "l", auto.grid = TRUE, major.ticks = "auto", 
    minor.ticks = TRUE, major.format = TRUE, bar.col = "grey", 
    candle.col = "white", ann = TRUE, axes = TRUE, ...) 
{
    series.title <- deparse(substitute(x))
    ep <- axTicksByTime(x, major.ticks, format.labels = major.format)
    otype <- type
    if (is.OHLC(x) && type %in% c("candles", "bars")) {
        x <- x[, has.OHLC(x, TRUE)]
        xycoords <- list(x = .index(x), y = seq(min(x), max(x), 
            length.out = NROW(x)))
        type <- "n"
    }
    else {
        if (NCOL(x) > 1) 
            warning("only the univariate series will be plotted")
        if (is.null(y)) 
            xycoords <- xy.coords(.index(x), x[, 1])
    }
    ###The next three lines are the only modifications i made to the function####
    plot(xycoords$x, xycoords$y, type = "n", axes = FALSE, ann = FALSE) 
    rect(par("usr")[1], par("usr")[3], par("usr")[2], par("usr")[4], col ="white")
    if(type=="l"){lines(xycoords$x, xycoords$y, ...)}

    if (auto.grid) {
        abline(v = xycoords$x[ep], col = "grey", lty = 4)
        grid(NA, NULL)
    }
    if (is.OHLC(x) && otype == "candles") 
        plot.ohlc.candles(x, bar.col = bar.col, candle.col = candle.col, 
            ...)
    dots <- list(...)
    if (axes) {
        if (minor.ticks) 
            axis(1, at = xycoords$x, labels = FALSE, col = "#BBBBBB")
        axis(1, at = xycoords$x[ep], labels = names(ep), las = 1, lwd = 1, mgp = c(3, 2, 0), ...)
        axis(2, ...)
    }
    box()
    if (!"main" %in% names(dots)) 
        title(main = series.title)
    do.call("title", list(...))
    assign(".plot.xts", recordPlot(), .GlobalEnv)
} library(quantmod)
getSymbols('SPY', from='1998-01-01', to='2011-07-31', adjust=T)

GRAPH_BLUE<-rgb(43/255, 71/255,153/255)
GRAPH_BACKGROUND<-rgb(180/255, 226/255, 244/255)

par(bg=GRAPH_BACKGROUND)

plot.xtsMODIFIED(SPY, col=GRAPH_BLUE) Error in axis(1, at = xycoords$x, labels = FALSE, col = "#BBBBBB", ...) : formal argument "col" matched by multiple actual arguments. plot.xts ... col axis plot lines ...
axis(1, at = xycoords$x, labels = FALSE, col = "#BBBBBB", )
... ...
axis(1, at = xycoords$x, labels = FALSE, ...)
... plot.xts plot.xtsMODIFIED<-function (x, y = NULL, type = "l", auto.grid = TRUE, major.ticks = "auto", 
                             minor.ticks = TRUE, major.format = TRUE, bar.col = "grey", 
                             candle.col = "white", ann = TRUE, axes = TRUE, 
                             lcol, ...) 
{
...
if(type=="l"){lines(xycoords$x, xycoords$y, lcol, ...)}
...
} plot.xtsMODIFIED(SPY, lcol=GRAPH_BLUE)
-------------------------------------------------------------------------------------------------------
plot(strptime(dta$Time, format="%H:%M:%S"), dta$EcNo, xaxt="n")
axis(1, at=as.numeric(strptime(dta$Time, format="%H:%M:%S")), labels=strftime( strptime(dta$Time, format="%H:%M:%S"),format="%H:%M:%S"))
-------------------------------------------------------------------------------------------------------
plot(1:7,c(1:5,5,5),axes=F,xlab="",ylab="")
axis(1,at=1:7, labels=c("1980","1985","1990","1995","2000","2005","2010"))
axis(2,at=1:5)
-------------------------------------------------------------------------------------------------------
as.Date "Date" > as.Date(3653, origin = "1969-12-31")
[1] "1980-01-01" data2$Date <- as.Date(data2$date, origin = "1969-12-31")

plot(close ~ Date, data2, type = "o", pch = 20, xaxt = "n")

lab <- seq(1980, 2010, 5) # years
at <- as.Date(paste0(lab, "-01-01"))
axis(1, at, lab)
-------------------------------------------------------------------------------------------------------
pdf() width height colorstrip <- function(colors) {
  count <- length(colors)
  m <- matrix(1:count, count, 1)
  par(mai=c(0.2, 2, 1, 2), cex.axis=2, ann=T, tck=-1)
  image(m, col=colors, ylab="", axes=FALSE)
  axis(side=3, at=seq(from=-0.165, to=1.22, by=0.332),
       labels=letters[1:5])
}

library(igraph)
g <- graph.ring(10)

pdf("test_igraph.pdf", width=7, height=7)
layout(matrix(c(1,2), nrow=2), heights=c(2,0.5))
plot(g)
colorstrip(c("red", "mediumseagreen", "yellow", "blue"))
dev.off()
-------------------------------------------------------------------------------------------------------
las ?par barplot(bpsamplevalues, col = "#87DEE1", axes = FALSE, las = 2)
axis(side = 2, tick = FALSE, las = 1)
grid(nx = NA, ny = NULL, col = "white", lty = "solid")
-------------------------------------------------------------------------------------------------------
temp <- data.frame(temperature = c(32,33,43,37), 
                   place = paste("Place", 1:4)) temperature   place
1          32 Place 1
2          33 Place 2
3          43 Place 3
4          37 Place 4 # Create a scatterplot, with an hidden x axis
plot(temp$temperature, pch=20, ylim=c(0, 50), 
     xaxt="n", xlab="Place", ylab="Temperature")
# Plot the axis separately
axis(1, at=1:4, labels=temp$place) barplot(temp$temperature, names.arg=rownames(temp$place))
-------------------------------------------------------------------------------------------------------
?axis ?par xaxt set.seed(1)
x <- rnorm(100)
## using xaxt="n" to avoid showing the x-axis
hist(x, xlim=c(-4, 4), xaxt="n")
## draw the x-axis with user-defined tick-marks
axis(side=1, at=c(-4, 0, 4))
-------------------------------------------------------------------------------------------------------
par(mfrow = c(3, 1))
xrange <- range( c(outcome[, 11],outcome[, 17],outcome[, 23]) )
hist(outcome[, 11], main = "Heart Attack", xlim = xrange,xaxt="n", 
         xlab = "30-day Death Rate")
axis(1, at=seq(10,30,by=10), labels=seq(10,30,by=10) )
hist(outcome[, 17], main = "Heart failure", xlim = xrange,xaxt="n", 
         xlab = "30-day Death Rate")
axis(1, at=seq(10,30,by=10), labels=seq(10,30,by=10) )
hist(outcome[, 23], main = "Pneumonia", xlim = xrange, xaxt="n", 
         xlab = "30-day Death Rate")
axis(1, at=seq(10,30,by=10), labels=seq(10,30,by=10) )
-------------------------------------------------------------------------------------------------------
log10 value log10 log="y" set.seed(123)
x<-sample(100,1000,T)
var<-sample(letters[1:5],1000,T) boxplot(log10(x) ~ var,yaxt="n")
axis(side=2,labels=round(10^(seq(log10(min(x)),log10(max(x)),len=5)),2),at=seq(log10(min(x)),log10(max(x)),len=5)) boxplot(x ~ var,yaxt="n",log="y")
axis(side=2,labels=seq(min(x),max(x),len=5),at=seq(min(x),max(x),len=5)) at log="y" axis(side=2,labels=round(exp(seq(log(min(x)),log(max(x)),len=5)),2),at=exp(seq(log(min(x)),log(max(x)),len=5)))
-------------------------------------------------------------------------------------------------------
axis(side=2,labels=seq(min(mdata$value), max(mdata$value),1000),
         at=log10(seq(min(mdata$value),max(mdata$value),by=1000)))
-------------------------------------------------------------------------------------------------------
# some fake data
n <- 5
x <- y <- seq_len(n)
z <- outer(x, y, "/")*rnorm(n) # create a matrix of values

# color palette function
pal <- colorRampPalette(c("green", "red"))

# setup plotting regions
layout(matrix(1:2), heights=c(0.7,0.3))

# make an image of the matrix
# ("n" turns off the axis labeling)
image(x, y, z, xaxt="n", yaxt="n", col=pal(11), asp=1, pty="s")
axis(1, x, letters[1:5])
axis(2, y, letters[6:10])

# add a cheap colorbar...
cz <- pretty(range(z))
cx <- seq_along(cz)
image(x=cx, z=matrix(cz), xaxt="n", yaxt="n", col=pal(11))
axis(1, cx, cz) z
-------------------------------------------------------------------------------------------------------
vioplot vioplot(...,add=TRUE) ## make up data
set.seed(101)
x1 <- rlnorm(1000,meanlog=3,sdlog=1)
x2 <- rlnorm(1000,meanlog=3,sdlog=2)
x3 <- rlnorm(1000,meanlog=2,sdlog=2) library(vioplot)
par(las=1,bty="l")  ## my preferred setting
## set up empty plot
plot(0:1,0:1,type="n",xlim=c(0.5,3.5),ylim=range(log10(c(x1,x2,x3))),
     axes=FALSE,ann=FALSE)
vioplot(log10(x1),log10(x2),log10(x3),add=TRUE)
axis(side=1,at=1:3,labels=c("first","second","third"))
axis(side=2,at=-2:4,labels=10^(-2:4)) ggplot2::geom_violin() scale_y_log10()
-------------------------------------------------------------------------------------------------------
page(twoord.plot) twoord.plot plot axes FALSE axis xaxt axis(1, ... **cex** = axilsab.cex cex axis cex.axis axilslab.cex mtext mtext(axat, 2... cex = axislab.cex cex mtext twoord.plot2 cex cex.axis axis(1... twoord.plot2 axis(1,... **cex.axis** = axislab.cex) x_axislab.cex twoord.plot page(twoord.plot) twoord.plot2 twoord.plot2 <- #function (lx, ly, rx, ry, data = NULL, xlim = NULL, lylim = NULL, 
    #rylim = NULL, mar = c(5, 4, 4, 4), lcol = 1, rcol = 2, xlab = "", 
    #ylab = "", rylab = "", lpch = 1, rpch = 2, type = "b", xtickpos = NULL, 
    #xticklab = NULL, halfwidth = 0.4, axislab.cex = 1, 
   **x_axislab.cex = 1**, # do.first = NULL, 
   # ...)  #add argument `x_axislab.cex = 1` in the arguments of the original `twoord.plot`
#{
 #   if (!is.null(data)) {
 #       ly <- unlist(data[ly])

 #...everything else...

 #if (is.null(xticklab)) 
       axis(1, **cex.axis = x_axislab.cex**) #change here. it was **cex = axislab.cex**
  #  else {
 #if (is.null(xtickpos)) 
 #xtickpos <- 1:length(xticklab)
 #  if (is.null(xticklab)) 
  #     xticklab <- xtickpos
    axis(1, at = xtickpos, labels = xticklab, **cex.axis = x_axislab.cex**) #change here. it was **cex = axislab.cex**

 #.....everything else... R twoord.plot2(...other arguments..., x_axislab.cex = 0.8)
-------------------------------------------------------------------------------------------------------
require(grid)
grid.newpage()
pushViewport(plotViewport(c(5, 5, 5 ,5)))
pushViewport(dataViewport(0:10, 0:10, extension=c(0,0)))
grid.points(1:10, 1:10, default.units='native')
grid.xaxis(at=0:10)
grid.yaxis(at=0:10) plot(1:10, 1:10, xaxs="i", yaxs="i", xlim=c(0,10), ylim=c(0,10))
-------------------------------------------------------------------------------------------------------
at=1:5 axis axis(1, at = 1:5,  labels=x.labels)
-------------------------------------------------------------------------------------------------------
plot(q1, type = "l", lty = 1, lwd = 2, col = "green", xaxt = 'n', 
     xlim = c(0,30), ylim = c(0, max(q1,  na.rm = TRUE)), bty = "l") q1 <- c(1000000.0,  908364.8,  876009.1,  847892.8,  824808.3,  805416.2,  
        785266.2, 770997.1,  753908.6,  744599.9,  706777.6,  674659.9,  
        634654.4,  601440.4, 568259.7,  535361.3,  493679.9,  465526.5,  
        429766.6,  395244.7,  361483.2, 332136.6, 308574.5, 285500.6, 
        262166.2 ,237989.0 , 210766.1,  188578.1, 166762.3 , 140399.8  ,114865.5)

dev.new(width=10, height=5)
par(xaxs='i',yaxs='i')
plot(q1, type = "l", lty = 1, lwd = 2, col = "green", 
     xaxt = 'n', xlim = c(1,30), ylim = c(0, max(q1)), bty = "l")
x.ticks = seq(from = 0, to = 30, by = 5)
axis(1, at = x.ticks + 1,  labels=paste("Year", x.ticks, sep=" "))
-------------------------------------------------------------------------------------------------------
image #matrix with the part of your data 10x10 you uploaded
mat <- as.matrix(read.table(text = "0 0 0 0 0 0 0 0 0 0
41 10 2 0 0 0 0 0 0 0
75 36 20 9 4 2 1 0 0 0
91 65 47 31 20 13 8 5 3 2
97 78 64 47 35 25 18 12 8 5
99 88 76 63 50 39 29 22 16 11
99 93 85 74 63 52 42 32 25 19
99 96 91 83 73 64 53 44 35 28
99 98 94 88 81 72 64 54 46 37
99 98 96 92 87 80 72 64 55 47"))

#neccessary step to `image` the expected. read `?image`
t_mat <- t(mat[ncol(mat):1,])

#basic plot
image(t_mat, col = colorRampPalette(c("blue", "red"))(10), axes = F)

#creaty matrix with `NA`s and fill 
#only the values you want to appear yellow.
#here: say 45 to 55
yellows <- matrix(nrow = nrow(t_mat), ncol = ncol(t_mat))
yellows[which(t_mat > 45 & t_mat < 55)] <- t_mat[which(t_mat > 45 & t_mat < 55)] 

#overlay "yellows" to basic plot
image(yellows, col = rgb(1,1,0,1/2), add = T) legend title(main = "imageplot", xlab = "x axis", ylab = "y axis")
legend(x = 0.6, y = 1.15, legend = c("<45", "45-55", ">55"), 
           fill = c("blue", rgb(1,1,0,1/2), "red"), xpd = T, ncol = 3) #I guess you'll need to use `axis(1, at = seq(0,1,0.0101), labels = seq(1, 100, 1))` 
#but I'm not sure
axis(1, at = seq(0,1,0.11), labels = seq(1, 10, 1)) 
axis(2, at = seq(0,1,0.11), labels = seq(1, 10, 1))
-------------------------------------------------------------------------------------------------------
xpd barplot(LR50,ylim = c(424,426.5),xpd=FALSE)
axis(1,at=c(0,10),pos=424)
-------------------------------------------------------------------------------------------------------
xgap <- ifelse(x > 8, x-6, x)
#Possibly you'd want to check if there are values between 2 and 8.
plot(xgap, y, col='blue', pch=16, xlab= 'x', ylab='y, z', xaxt="n")
points(xgap, z, col='red', pch=17)
xat <- pretty(xgap)
xat <- xat[xat!=2]
xlab <- ifelse(xat>2, xat+6, xat)
axis(1,at=xat, labels=xlab)
library(plotrix)
axis.break(1,2,style="slash") gap.plot
-------------------------------------------------------------------------------------------------------
gap.plot library(plotrix)
par(bty="n") # deleting the box
gap.plot(x,y, gap=c(2,7.5), gap.axis="x", pch=16,
         col="blue", ylim=range(c(y,z)),
         xtics=c(0:3,8:10), xticlab=c(0:3,8:10))

gap.plot(x,z, gap=c(2,7.5), gap.axis="x", pch=17,
         col="red", ylim=range(c(y,z)), add=TRUE); axis(2)

abline(v=seq(1.99,2.09,.001), col="white")  # hiding vertical lines
axis.break(1,2,style="slash")               # plotting slashes for breakpoints
-------------------------------------------------------------------------------------------------------
log='xy' plot(log(x), log(y), axes=FALSE, xlab="X", ylab="Y")
box()
axis(side=1,     at=log(c(1,2, 10,20, 100,200)), 
             labels=c(    1,2, 10,20, 100,200))
axis(side=2,     at=log(c(125,135, 250,260, 350, 500)), 
             labels=c(    125,135, 250,260, 350, 500))
abline(model, col="red")
-------------------------------------------------------------------------------------------------------
# create positions for tick marks, one more than number of bars
at_tick <- seq_len(length(count) + 1)

# plot without axes
barplot(count, space = 0, axes = FALSE) 

# add y-axis
axis(side = 2, pos = -0.2)

# add x-axis with offset positions, with ticks, but without labels.
axis(side = 1, at = at_tick - 1, labels = FALSE)

# add x-axis with centered position, with labels, but without ticks.
axis(side = 1, at = seq_along(count) - 0.5, tick = FALSE, labels = xval)
-------------------------------------------------------------------------------------------------------
griddg Tps xvals <- seq(-10, 4, len=20)
yvals <- seq(49, 63, len=20)
griddf <- expand.grid(lon=xvals, lat=yvals)
griddg <- predict(fit, x=as.matrix(griddf) )

dat2 <- cbind(griddf, mm=griddg)
head(dat2)
fit <- Tps(cbind(dat2$lon, dat2$lat), dat2$mm, scale.type="unscaled")
surface (fit, nx=100, ny=100)
world(add=TRUE) Tps #option 2
source("matrix.poly.r") #http://menugget.blogspot.de/2012/04/create-polygons-from-matrix.html
source("val2col.R") # http://menugget.blogspot.de/2011/09/converting-values-to-color-levels.html
source("image.scale.R") # http://menugget.blogspot.de/2011/08/adding-scale-to-image-plot.html

#new grid and predition
xvals <- seq(-10, 4, len=100)
yvals <- seq(49, 63, len=100)
griddf <- expand.grid(lon=xvals, lat=yvals)
griddg <- predict(fit, x=as.matrix(griddf) )

#make polygons for new grid, calculate color levels
mat <- matrix(griddg, nrow=length(xvals), ncol=length(yvals))
poly <- matrix.poly(xvals, yvals, z=mat, n=seq(mat))
pal <- colorRampPalette(c("blue", "cyan", "yellow", "red"))
COL <- val2col(mat, col=pal(100))

#required packages
library(maps)
library(mapproj)

#plot
png("tmp.png", width=5, height=4, res=400, units="in")
layout(matrix(1:2, nrow=1, ncol=2), widths=c(4,1), heights=4)
par(mar=c(1,1,1,1))
map("world", proj="stereographic", orient=c(mean(yvals),mean(xvals),0), par=NULL, t="n", xlim=range(xvals), ylim=range(yvals))
for(i in seq(poly)){
 polygon(mapproject(poly[[i]]), col=COL[i], border=COL[i], lwd=0.3)
}
map("world", proj="stereographic", orient=c(mean(yvals),mean(xvals),0), par=NULL, add=T)
map.grid(col=rgb(0,0,0,0.5), labels=F)
box()

par(mar=c(5,0,5,4))
image.scale(mat, col=pal(100), horiz=FALSE, axes=FALSE, xlab="", ylab="")
axis(4)
mtext("mm", side=4, line=2.5)
box()

dev.off()
-------------------------------------------------------------------------------------------------------
data.table D <- data.table(d)
MaxDate <- D[, max(date)] + 10
MinDate <- D[, min(date)]
D2 <- D[, list( date, firstdate = min(date)), by = id]
D2[, plot(date, id, type='n', bty='n',axes=FALSE, xlab = "", ylab ="")]
D2[date!=firstdate, points(date, id, pch =4)]
D2[date==firstdate, points(date, id)]
D2[date==firstdate, arrows(x0=date, y0=as.numeric(id), x1=MaxDate, length=0.1)]
abline(v=MaxDate - 5)
abline(v=MinDate)
axis(side= 2, tick = FALSE, at=D[, unique(id)], labels=D[, paste0("ID = ",  as.character(unique(id)))], las=2)
axis(side = 1, tick= FALSE, at=c(MinDate, MaxDate), labels = strftime(c(MinDate, MaxDate),format="Week %W, %Y") )
-------------------------------------------------------------------------------------------------------
library(lubridate)
library(reshape2)
# simulating data...
Date  <- seq(as.Date("1953-10-01"),as.Date("2010-10-01"),by="day")
Year  <- year(Date)
Month <- month(Date)
Day <- day(Date)
set.seed(1)
Flow <- rpois(length(Date), 2000)
Data <- data.frame(Date=Date,Year=Year,Month=Month,Day=Day,Flow=Flow)

# use acast to get it in a convenient shape:
PlotData <- acast(Data,Year~Month+Day,value.var="Flow")
# apply for quantiles
Quantiles <- apply(PlotData,2,function(x){
    quantile(x,probs=c(1,.9,.75,.5,.25,.1,0),na.rm=TRUE)
  })
Mean <- colMeans(PlotData, na.rm=TRUE)
# ugly way to get month tick separators
MonthTicks <- cumsum(table(unlist(lapply(strsplit(names(Mean),split="_"),"[[",1))))

# and finally your question:
plot(1:366,seq(0,max(Flow),length=366),type="n",xlab = "Water Year",ylab="Discharge",axes=FALSE)
polygon(c(1:366,366:1),c(Quantiles["50%",],rev(Quantiles["75%",])),border=NA,col=gray(.6))
polygon(c(1:366,366:1),c(Quantiles["50%",],rev(Quantiles["25%",])),border=NA,col=gray(.4))
lines(1:366,Quantiles["90%",], col = gray(.5), lty=4)
lines(1:366,Quantiles["10%",], col = gray(.5))
lines(1:366,Quantiles["100%",], col = gray(.7))
lines(1:366,Quantiles["0%",], col = gray(.7), lty=4)
lines(1:366,Mean,lwd=3)
axis(1,at=MonthTicks, labels=NA)
text(MonthTicks-15,-100,1:12,pos=1,xpd=TRUE)
axis(2) polygon()
-------------------------------------------------------------------------------------------------------
brkvec <- c (2.5 , 5.0 , 7.5, 10.0, 12.5, 15.0, 20.0, 25.0, 35.0, 50.0, 
             Inf )
dat <- c (6.6 ,12.5 ,15.2 ,16.6 ,15.8 ,11.0 ,13.1 ,4.6 ,3.0 ,1.1 ,0.5 )

hist (dat , breaks=brkvec )
## Error in hist.default(dat, breaks = brkvec) : 
##     some 'x' not counted; maybe 'breaks' do not span range of 'x' brkvec <- c(0,brkvec)
hist(dat, brkvec) ## Error in plot.window(xlim, ylim, "") : need finite 'xlim' values brkvec2 <- brkvec
brkvec2[brkvec2==Inf] <- max(brkvec2[is.finite(brkvec2)])+1
hist(dat,breaks=brkvec2,col="gray",freq=FALSE,axes=FALSE)
par(las=1,bty="l") ## cosmetic
axis(side=2)
axis(side=1,at=brkvec2,labels=brkvec) tt <- table(cut(dat,brkvec))
barplot(tt,names=names(tt)) (50,Inf]
-------------------------------------------------------------------------------------------------------
empl_count <- sample(1:500000,50)
yourbreaks <- seq(0,500000,by=50000)
x <- hist(empl_count,breaks=yourbreaks,plot=F)
x
plot(x, freq=T, axes=F,xlab="Number of employees in thousands", ylab="Frequency",main="50 largest companies")
axis(1,at=yourbreaks,labels=yourbreaks/1000,las=2)
axis(2,at=x$counts,labels=x$counts,las=1)
-------------------------------------------------------------------------------------------------------
plot.new()
plot.window(xlim=c(0,100),ylim=c(0,100))
lines(c(0,50,100), c(50,0,0))
axis(1)
axis(2)
title(main="Graph")
title(xlab="X")
title(ylab="Y")
box()
-------------------------------------------------------------------------------------------------------
segments Draw line segments between pairs of points. plot.new()
plot.window(xlim=c(0,100),ylim=c(0,100))
#abline(a=50,b=-1)
#abline(a=0,b=0)
segments(0,50,50,0)
segments(50,0,100,0)
axis(1)
axis(2)
title(main="Graph")
title(xlab="X")
title(ylab="Y")
box()
-------------------------------------------------------------------------------------------------------
names=data$method
x = 1:13*2-1
CI.up = as.numeric(data$mean)+as.numeric(data$ci)
CI.dn = as.numeric(data$mean)-as.numeric(data$ci)
plot(data$mean~x, cex=1.5,xaxt='n',ylim=c(0.3,0.40), xlab='',ylab='lalala!', main='blahblahblah',col='blue',pch=16)
axis(1, at=x, labels=names)
arrows(x,CI.dn,x,CI.up,code=3,length=0.2,angle=90,col='red')
legend("bottomleft",paste(names,": S.E=",data$se),ncol=6,text.width=1)
-------------------------------------------------------------------------------------------------------
matplot # Create some data
df <- data.frame(ID=1:10, Test1=sample(50:100, 10), 
                 Test2=sample(50:100, 10), Test3=sample(50:100, 10))
# Plot it! We remove the ID column, which we don't need to plot
matplot(t(df)[-1,], t="l", lty=1, las=1, ylab="Score", 
        xlab="Test", xaxt="n")
# Use the column labels as axis titles
axis(1, at=1:(ncol(df)-1), labels=names(df)[-1])
-------------------------------------------------------------------------------------------------------
d plot plot.factor barplot(table(d)) barplot p <- plot(d, xaxt="n")
axis(side=1, at=p, labels=Occs, las=3, cex.axis=1) #, cex.axis=0.35
-------------------------------------------------------------------------------------------------------
df xaxt = "n" gap.barplot ?par xaxt: A character which specifies the x axis type. Specifying "n" suppresses plotting of the axis. axis labels at tick = FALSE mtext library(plotrix)
par(mar=c(6,6,5,2))

gap.barplot(df$Conc, gap = c(200,1000),
            xlab = "Samples", ylab ="", main = "C in X and Y", las = 2,
            xlim = c(0, 4), ytics = c(0, 1000, 1500, 5100), cex.lab = 1.5,
            xaxt = "n")

axis(side = 1, at = seq_along(df$Sample), labels = df$Sample, tick = FALSE)
mtext("C Concentration (pg/mL)", side = 2, line = 4)
-------------------------------------------------------------------------------------------------------
with(dat, plot(x=V1, y=V5, ylim=c(0,1) ,type='n',
      xaxt="n", ylab="Allele Frequency", xlab="Genomic Location"))
with(dat, axis(1, V1,V1, cex.axis=0.7)   )
with( dat, arrows(x0=V1,x1=V1+10, y0=V4, y1=V5) ) ?arrows
-------------------------------------------------------------------------------------------------------
barplot(hmatrix, beside = TRUE, horiz = TRUE, xlab = "Volume", ylab = "")
axis(side = 2, at = seq_along(hmatrix) + 0.5, labels = vol$Adjusted, las = 2)
mtext(text = "Price", side = 2, line = 4)
-------------------------------------------------------------------------------------------------------
B <- rlnorm(10000)
H <- hist(log10(B), freq = FALSE, col="blue", xaxt="n", xlab="B") 
at <- H$mids
axis(1,at=at,labels=round(10^at,2))
curve(dnorm(x, mean=mean(log10(B)), sd=sd(log10(B))), add=TRUE)
-------------------------------------------------------------------------------------------------------
pctable<-data.frame(expand.grid(c("monday","tuesday","wednesday","thursday","friday","saturday","sunday"),1:22))
colnames(pctable)<-c("weekday","day")
pctable$value=rnorm(nrow(pctable),15,8)
plot(pctable$day,pctable$weekday,cex=pctable$value/(max(pctable$value)/5), col=rgb(0,0,1), pch=19, yaxt="n", xaxt="n")
axis(1, at=1:22, labels=c(1:22)) 
axis(2, at=1:7, labels=c("monday","tuesday","wednesday","thursday","friday","saturday","sunday"), cex.axis=0.7)
-------------------------------------------------------------------------------------------------------
plot(solar$Year.completed, solar$Name, xlim=c(1990, 2025), yaxt="n")
axis(2, at=1:length(unique(solar$Name)), labels=unique(solar$Name), cex.axis=0.5, las=2) plot(solar$Year.completed, solar$Name, xlim=c(1990, 2025), yaxt="n", xaxt="n")
axis(2, at=1:length(unique(solar$Name)), labels=unique(solar$Name), cex.axis=0.5, las=2)
axis(1, at=1990:2025, labels=1990:2025, cex.axis=0.7, las=2)
-------------------------------------------------------------------------------------------------------
symbols() sqrt((pctable$value / max(pctable$value)) / pi) pctable <- data.frame(expand.grid(weekday=c("Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"),
                              day=1:22), value=abs(rnorm(nrow(pctable), 20, 30)))

par(list(las=1, mar=c(6,6,1,1), mgp=c(4.5,1,0)))

bubble.size <- sqrt((pctable$value / max(pctable$value)) / pi)
symbols(pctable$day, pctable$weekday, circles=bubble.size,
    inches=.2, fg="black", bg="blue", yaxt="n", xaxt="n", xlab="Day", ylab="Weekday")
axis(1, at=1:22, labels=c(1:22)) 
axis(2, at=1:7,labels=rev(c("Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday")), cex.axis=0.7)
-------------------------------------------------------------------------------------------------------
scatter_fill <- function (x, y, z,xlim=c(min(x),max(x)),ylim=c(min(y),max(y)),zlim=c(min(z),max(z)),
                          nlevels = 20, plot.title, plot.axes, 
                          key.title, key.axes, asp = NA, xaxs = "i", 
                          yaxs = "i", las = 1, 
                          axes = TRUE, frame.plot = axes, ...) 
{
  mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar
  on.exit(par(par.orig))
  w <- (3 + mar.orig[2L]) * par("csi") * 2.54
  layout(matrix(c(2, 1), ncol = 2L), widths = c(1, lcm(w)))
  par(las = las)
  mar <- mar.orig
  mar[4L] <- mar[2L]
  mar[2L] <- 1
  par(mar = mar)

# choose colors to interpolate
levels <- seq(zlim[1],zlim[2],length.out = nlevels)
col <- colorRampPalette(c("red","yellow","dark green"))(nlevels)  
colz <- col[cut(z,nlevels)]  
#   
plot.new()
plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i", yaxs = "i")

rect(0, levels[-length(levels)], 1, levels[-1L],col=col,border=col) 
if (missing(key.axes)) {if (axes){axis(4)}}
       else key.axes
   box()
   if (!missing(key.title)) 
     key.title
   mar <- mar.orig
   mar[4L] <- 1
   par(mar = mar)

   # points
   plot(x,y,type = "n",xaxt='n',yaxt='n',xlab="",ylab="",xlim=xlim,ylim=ylim,bty="n")
   points(x,y,col = colz,xaxt='n',yaxt='n',xlab="",ylab="",bty="n",...)

   ## options to make mapping more customizable

        if (missing(plot.axes)) {
          if (axes) {
            title(main = "", xlab = "", ylab = "")
            Axis(x, side = 1)
            Axis(y, side = 2)
          }
        }
        else plot.axes
        if (frame.plot) 
          box()
        if (missing(plot.title)) 
          title(...)
        else plot.title
        invisible()
 } # random vectors
vx <- rnorm(40,0,1)
vy <- rnorm(40,0,1)
vz <- rnorm(40,10,10)

scatter_fill(vx,vy,vz,nlevels=15,xlim=c(-1,1),ylim=c(-1,5),zlim=c(-10,10),main="TEST",pch=".",cex=8)
-------------------------------------------------------------------------------------------------------
mydf <- data.frame(
    SubgroupH=c('Age',NA,NA,'Sex',NA,NA),
    Subgroup=c(NA,'<70','>70',NA,'Male','Female'),
    NoOfPatients=c(NA,2815,1935,NA,3843,908),
    HazardRatio=c(NA,0.97,0.86,NA,0.93,0.81),
    HazardLower=c(NA,0.77,0.69,NA,0.78,0.59),
    HazardUpper=c(NA,1.22,1.07,NA,1.12,1.12),
    Pvalue=c(NA,0.77,0.17,NA,0.47,0.21),
    PvalueI=c(0.46,NA,NA,0.46,NA,NA),
    stringsAsFactors=FALSE
) #png('temp.png', width=8, height=4, units='in', res=400)
rowseq <- seq(nrow(mydf),1)
par(mai=c(1,0,0,0))
plot(mydf$HazardRatio, rowseq, pch=15,
    xlim=c(-10,12), ylim=c(0,7),
    xlab='', ylab='', yaxt='n', xaxt='n',
    bty='n')
axis(1, seq(-2,2,by=.4), cex.axis=.5)

segments(1,-1,1,6.25, lty=3)
segments(mydf$HazardLower, rowseq, mydf$HazardUpper, rowseq)

mtext('Off-Pump\nCABG Better',1, line=2.5, at=0, cex=.5, font=2)
mtext('On-Pump\nCABG Better',1.5, line=2.5, at=2, cex=.5, font=2)

text(-8,6.5, "Subgroup", cex=.75, font=2, pos=4)
t1h <- ifelse(!is.na(mydf$SubgroupH), mydf$SubgroupH, '')
text(-8,rowseq, t1h, cex=.75, pos=4, font=3)
t1 <- ifelse(!is.na(mydf$Subgroup), mydf$Subgroup, '')
text(-7.5,rowseq, t1, cex=.75, pos=4)

text(-5,6.5, "No. of\nPatients", cex=.75, font=2, pos=4)
t2 <- ifelse(!is.na(mydf$NoOfPatients), format(mydf$NoOfPatients,big.mark=","), '')
text(-3, rowseq, t2, cex=.75, pos=2)

text(-1,6.5, "Hazard Ratio (95%)", cex=.75, font=2, pos=4)
t3 <- ifelse(!is.na(mydf$HazardRatio), with(mydf, paste(HazardRatio,' (',HazardLower,'-',HazardUpper,')',sep='')), '')
text(3,rowseq, t3, cex=.75, pos=4)

text(7.5,6.5, "P Value", cex=.75, font=2, pos=4)
t4 <- ifelse(!is.na(mydf$Pvalue), mydf$Pvalue, '')
text(7.5,rowseq, t4, cex=.75, pos=4)

text(10,6.5, "P Value for\nInteraction", cex=.75, font=2, pos=4)
t5 <- ifelse(!is.na(mydf$PvalueI), mydf$PvalueI, '')
text(10,rowseq, t5, cex=.75, pos=4)
#dev.off()
-------------------------------------------------------------------------------------------------------
data <- as.data.frame(data)
data$dates <- as.Date(as.character(data$dates), format="%Y%m%d")
 head(data)
       dates col1 col2 col3 col4
1 2010-11-01    1   11   21   31
2 2010-11-02    2   12   22   32
3 2010-11-03    3   13   23   33
4 2010-11-04    4   14   24   34
5 2010-11-05    5   15   25   35
6 2010-11-06    6   16   26   36 graphics::matplot png("my.png")
matplot(x=data[[1]], y=data[-1], type="l", xaxt="n")
axis(1, at=data$dates,labels=as.character(data$dates))
dev.off() > p <- ggplot(data=data, aes(x=dates, y=data[,2:5]) )+geom_line()
> p
Don't know how to automatically pick scale for object of type data.frame. Defaulting to continuous
Error: Aesthetics must either be length one, or the same length as the dataProblems:data[, 2:5]
-------------------------------------------------------------------------------------------------------
> x=matrix(c(T,F,T,F,F,F,T,T,F,T,T,T,F,F,F,T),ncol=4)
> x
      [,1]  [,2]  [,3]  [,4]
[1,]  TRUE FALSE FALSE FALSE
[2,] FALSE FALSE  TRUE FALSE
[3,]  TRUE  TRUE  TRUE FALSE
[4,] FALSE  TRUE  TRUE  TRUE
> image(t(x),axes=F)
> axis(2,at=seq(0,1,(1/(nrow(x)-1))),labels=nrow(x):1)
> axis(3,at=seq(0,1,(1/(ncol(x)-1))),labels=1:ncol(x))
-------------------------------------------------------------------------------------------------------
plot(chunksVector, type="o", col="blue", xlab="Time", ylab="Wins", xaxt="n")

axis(1, at=c(2,4,6,8), labels=c('14:00', '16:00', '18:00', '20:00'))
-------------------------------------------------------------------------------------------------------
bp <- barplot(rbind(w1$normal, w1$merges), 
          main="Playing with R", xlab="Who", names.arg=rep("",4), 
          col=c("blue", "red"), ylim = c(0,30))
text(bp, rbind(w1$Commits), labels = titles, pos = 3, cex = 0.75)
axis(1, at=bp, labels= parse(text= abc ) )
-------------------------------------------------------------------------------------------------------
bquote do.call # the order in which you want the "bolding"
 xx <- expression(bold(.(x)), italic(.(x)), .(x), .(x))
 # a list of lists containing the information for bquote
 xL <- lapply(rownames(w1), function(x) list(x=x))
 # using Map and do.call and as.expression to create the list of expressions
 labs <- as.expression(Map(function(expr,where) {do.call(bquote, list(expr,where))},
   expr = xx, where =xL))

bp <- barplot(rbind(w1$normal, w1$merges), 
      main="Playing with R", xlab="Who", names.arg=rep("",4), 
      col=c("blue", "red"), ylim = c(0,30))
text(bp, rbind(w1$Commits), labels = titles, pos = 3, cex = 0.75)
axis(1, at=bp, labels= labs) substitute xs <- expression(bold(x), italic(x), x, x)
labs <- Map(function(expr,where) {do.call(substitute, list(expr,where))}, expr = xs, where =xL)
-------------------------------------------------------------------------------------------------------
plot(seq_along(x),intensity,type = "l",axes = FALSE)
axis(side = 2)
axis(side = 1,at = seq_along(x),labels = x) box()
-------------------------------------------------------------------------------------------------------
xFact<-factor(x, levels=x)
plot.default(xFact,intensity) plot plot.default plot plot.default(xFact,intensity,type="p",xaxt="n")
axis(side=1, at=xFact,labels=x)
-------------------------------------------------------------------------------------------------------
t1=c(0.5,0.5,0.1)
t2=c(89221345,87542657,90886527)
plot(1:3,t2,xaxt="n",xlab="VIN")
axis(1,at=1:3,labels=t1)
-------------------------------------------------------------------------------------------------------
library(ape)

heatmap.phylo <- function(x, Rowp, Colp, breaks, col, denscol="cyan", respect=F, ...){
    # x numeric matrix
    # Rowp: phylogenetic tree (class phylo) to be used in rows
    # Colp: phylogenetic tree (class phylo) to be used in columns
    # ... additional arguments to be passed to image function

    scale01 <- function(x, low = min(x), high = max(x)) {
        x <- (x - low)/(high - low)
        x
    }

    col.tip <- Colp$tip
    n.col <- 1
    if (is.null(col.tip)) {
        n.col <- length(Colp)
        col.tip <- unlist(lapply(Colp, function(t) t$tip))
        col.lengths <- unlist(lapply(Colp, function(t) length(t$tip)))
        col.fraction <- col.lengths / sum(col.lengths)
        col.heights <- unlist(lapply(Colp, function(t) max(node.depth.edgelength(t))))
        col.max_height <- max(col.heights)
    }

    row.tip <- Rowp$tip
    n.row <- 1
    if (is.null(row.tip)) {
        n.row <- length(Rowp)
        row.tip <- unlist(lapply(Rowp, function(t) t$tip))
        row.lengths <- unlist(lapply(Rowp, function(t) length(t$tip)))
        row.fraction <- row.lengths / sum(row.lengths)
        row.heights <- unlist(lapply(Rowp, function(t) max(node.depth.edgelength(t))))
        row.max_height <- max(row.heights)
    }

    cexRow <- min(1, 0.2 + 1/log10(n.row))
    cexCol <- min(1, 0.2 + 1/log10(n.col))

    x <- x[row.tip, col.tip]
    xl <- c(0.5, ncol(x)+0.5)
    yl <- c(0.5, nrow(x)+0.5)

    screen_matrix <- matrix( c(
        0,1,4,5,
        1,4,4,5,
        0,1,1,4,
        1,4,1,4,
        1,4,0,1,
        4,5,1,4
    ) / 5, byrow=T, ncol=4 )

    if (respect) {
        r <- grconvertX(1, from = "inches", to = "ndc") / grconvertY(1, from = "inches", to = "ndc")
        if (r < 1) {
            screen_matrix <- screen_matrix * matrix( c(r,r,1,1), nrow=6, ncol=4, byrow=T)
        } else {
            screen_matrix <- screen_matrix * matrix( c(1,1,1/r,1/r), nrow=6, ncol=4, byrow=T)
        }
    }


    split.screen( screen_matrix )

    screen(2)
    par(mar=rep(0,4))

    if (n.col == 1) {
        plot(Colp, direction="downwards", show.tip.label=FALSE,xaxs="i", x.lim=xl)
    } else {
        screens <- split.screen( as.matrix(data.frame( left=cumsum(col.fraction)-col.fraction, right=cumsum(col.fraction), bottom=0, top=1)))
        for (i in 1:n.col) {
            screen(screens[i])
            plot(Colp[[i]], direction="downwards", show.tip.label=FALSE,xaxs="i", x.lim=c(0.5,0.5+col.lengths[i]), y.lim=-col.max_height+col.heights[i]+c(0,col.max_height))
        }
    }

    screen(3)
    par(mar=rep(0,4))

    if (n.col == 1) {
        plot(Rowp, direction="rightwards", show.tip.label=FALSE,yaxs="i", y.lim=yl)
    } else {
        screens <- split.screen( as.matrix(data.frame( left=0, right=1, bottom=cumsum(row.fraction)-row.fraction, top=cumsum(row.fraction))) )
        for (i in 1:n.col) {
            screen(screens[i])
            plot(Rowp[[i]], direction="rightwards", show.tip.label=FALSE,yaxs="i", x.lim=c(0,row.max_height), y.lim=c(0.5,0.5+row.lengths[i]))
        }
    }


    screen(4)
    par(mar=rep(0,4), xpd=TRUE)
    image((1:nrow(x))-0.5, (1:ncol(x))-0.5, x, xaxs="i", yaxs="i", axes=FALSE, xlab="",ylab="", breaks=breaks, col=col, ...)

    screen(6)
    par(mar=rep(0,4))
    plot(NA, axes=FALSE, ylab="", xlab="", yaxs="i", xlim=c(0,2), ylim=yl)
    text(rep(0,nrow(x)),1:nrow(x),row.tip, pos=4, cex=cexCol)

    screen(5)
    par(mar=rep(0,4))
    plot(NA, axes=FALSE, ylab="", xlab="", xaxs="i", ylim=c(0,2), xlim=xl)
    text(1:ncol(x),rep(2,ncol(x)),col.tip, srt=90, adj=c(1,0.5), cex=cexRow)

    screen(1)
    par(mar = c(2, 2, 1, 1), cex = 0.75)

    symkey <- T
    tmpbreaks <- breaks
    if (symkey) {
        max.raw <- max(abs(c(x, breaks)), na.rm = TRUE)
        min.raw <- -max.raw
        tmpbreaks[1] <- -max(abs(x), na.rm = TRUE)
        tmpbreaks[length(tmpbreaks)] <- max(abs(x), na.rm = TRUE)
    } else {
        min.raw <- min(x, na.rm = TRUE)
        max.raw <- max(x, na.rm = TRUE)
    }
    z <- seq(min.raw, max.raw, length = length(col))

    image(z = matrix(z, ncol = 1), col = col, breaks = tmpbreaks, 
          xaxt = "n", yaxt = "n")
    par(usr = c(0, 1, 0, 1))
    lv <- pretty(breaks)
    xv <- scale01(as.numeric(lv), min.raw, max.raw)
    axis(1, at = xv, labels = lv)

    h <- hist(x, plot = FALSE, breaks = breaks)
    hx <- scale01(breaks, min.raw, max.raw)
    hy <- c(h$counts, h$counts[length(h$counts)])
    lines(hx, hy/max(hy) * 0.95, lwd = 1, type = "s", 
          col = denscol)
    axis(2, at = pretty(hy)/max(hy) * 0.95, pretty(hy))
    par(cex = 0.5)
    mtext(side = 2, "Count", line = 2)

    close.screen(all.screens = T)

}

tree <- read.tree(text = "(A:1,B:1);((C:1,D:2):2,E:1);((F:1,G:1,H:2):5,((I:1,J:2):2,K:1):1);", comment.char="")
N <- sum(unlist(lapply(tree, function(t) length(t$tip))))

set.seed(42)
m <- cor(matrix(rnorm(N*N), nrow=N))
rownames(m) <- colnames(m) <- LETTERS[1:N]
heatmap.phylo(m, tree, tree, col=bluered(10), breaks=seq(-1,1,length.out=11), respect=T)
-------------------------------------------------------------------------------------------------------
my.panel <- function(x, y, ..., pf = parent.frame()) {
  grid(NA,NULL)
  lines(x, y, ...)
  if (pf$panel.number == 3) axis(1, at = ticks, labels = format(ticks, "%b-%y"))
}

plot(zoo(Factors, ticks), 
   main = "Factors 1, 2 & 3", xlab= "Date", ylab = paste("Factor", 1:3),
   panel = my.panel,
   col = 1:3,
   xaxt = "n")
-------------------------------------------------------------------------------------------------------
cex hist() cex.axis cex.lab cex axis() cex.axis hist() mtext() cex cex=2/3 pointsize pdf()
-------------------------------------------------------------------------------------------------------
ggplot df <- data.frame(t(freqTable))        # transpose (more suitable for plotting)
df <- cbind(Response=rownames(df),df) # add row names as first column

plot(as.numeric(df$Response),df$f,type="b",col="red", 
     xaxt="n", ylab="Count",xlab="Response")
lines(as.numeric(df$Response),df$m,type="b",col="blue")
axis(1,at=c(1,2,3,4,5,6),labels=c("Str.Agr.","Sl.Agr","Neither","Sl.Disagr","Str.Disagr","NA")) df df <- data.frame(freqTable)
df <- cbind(Gender=rownames(df),df)    # append rownames (Gender)
df <- df[-3,]                          # drop unknown gender
df
#   Gender X1 X2 X3 X4 X5 X8
# m      m  5 16  3 16  5  0
# f      f 12 25  3 10  3  1

df <- df[-3,]     # remove unknown gender column

library(ggplot2)
library(reshape2)
gg=melt(df)

labels <- c("Agree\nFully","Somewhat\nAgree","Neither Agree\nnor Disagree","Somewhat\nDisagree","Disagree\nFully", "No Answer")
ggp <- ggplot(gg,aes(x=variable,y=value))
ggp <- ggp + geom_bar(aes(fill=Gender), position="dodge", stat="identity")
ggp <- ggp + scale_x_discrete(labels=labels)
ggp <- ggp + theme(axis.text.x = element_text(angle=90, vjust=0.5))
ggp <- ggp + labs(x="", y="Frequency")
ggp ggp + facet_grid(Gender~.)
-------------------------------------------------------------------------------------------------------
mat <- matrix(c(14,9,7))
barplot(mat[ ,1])
axis(1, at = c(.5,1.5,3.5), labels = 1:3, tick = FALSE, las = 2)
-------------------------------------------------------------------------------------------------------
axis(1, at=time) time time axis(1, at=..., labels=...) plot.ts 2010 2013.75 at axis time 2010, 2010.25, 2010.50 ... seq(from=2010, to=2013.25, by=0.25) plot.ts(y,axes=F) # don't plot the axes yet
axis(2) # plot the y axis
axis(1, labels=time, at=seq(from=2010, by=0.25, length.out=length(time)) )
box() # and the box around the plot
-------------------------------------------------------------------------------------------------------
xpos <- barplot(...) par('usr') axis tmp <- barplot(scores, main="my plot", xlab="my 1000 scores", names.arg=c(""))
axis(1,at=seq(min(tmp),max(tmp),len=10),lab=1:10)
-------------------------------------------------------------------------------------------------------
xaxt plot.xts() xaxt="n" plot.xts() axis() xts
-------------------------------------------------------------------------------------------------------
image.plot fields image.plot image graphics library(grid)
x=1:10
y=1:10
z=matrix(-50:49,10,10)

layout(matrix(c(1,2),ncol=2), widths=c(2,1))         
par(mar=c(5,3,5,3))
image(x,y,z,yaxt="n",xaxt="n", ylab="", xlab="",col=heat.colors(50)) 
cap <- grid.cap()
grid.newpage()
grid.raster(cap, x=unit(0.6,'npc'), #You can modify that if the plot 
            y=unit(0.5,'npc'),      #ends up outside the figure area
            vp=viewport(angle=36))
mtext("Some fancy title",side=3,cex=1.5,line=2) #Plot your title
par(mar=c(5,8,5,3))
plot(NA,ax=F,ann=F,type="n",xlim=c(0,1),ylim=c(0,50),yaxs="i")
for(i in 1:50)rect(0,i-1,1,i,col=heat.colors(50)[i],border=NA)
box()
axis(4,las=2,at=seq(0,50,by=10),labels=seq(-50,50,by=20))
-------------------------------------------------------------------------------------------------------
plot( as.numeric(na.trim(h1.zoo)), main="", xlab="Date",
      ylab="", yaxt = "n",xaxt="n", axes = F,ylim = c(-0.02,-0.01), type = 'l')
   axis(1,pos=-0.02)
   axis(2,pos=1)
-------------------------------------------------------------------------------------------------------
par(mai = c(1,2,1,0.7), xaxs='i',yaxs='i', xpd = F)
plot( na.trim(h1.zoo), main="", xlab="Date", ylab="", yaxt = "n", bty = "n", cex.axis = 0.6, ylim=c(-0.0135,-0.0128))
axis(2, las = 2, cex.axis = 0.6, at = seq(-.014,-.012,.0001))
title(ylab = "Contribution to Expected Return (in %)", line = 3) ylim= plot(...) (-0.0134,-0.0129) -0.02 to 0 axis(...) plot(...) xpd=F par(...)
-------------------------------------------------------------------------------------------------------
axis c(0:7,30) axis(2,c(0:7,30) 7 30 7 y y-gap.width y-(30-7) axis(2, labels=c(0:7,30), at=c(0:7,30-(30-7)))
-------------------------------------------------------------------------------------------------------
approx library(zoo)
my.months <-seq(as.Date("2013/1/1"), by = "month", length.out = 12)
my.zoo <-zoo(c(0,0,1,2,1,3,3,2,0,1,1,0),my.months)

plot(my.zoo,type="h",lwd=6,col="red")
par(new=T)
plot(approx(my.zoo),type="l",yaxt = "n",ylab="",xlab="") #add new graph layer
axis(4,pretty(approx(my.zoo)$y)) #add y axis on the right side spline approx 5 spline plot(spline(my.zoo, n = 5*length(my.zoo)),type="l",yaxt = "n",ylab="",xlab="") approx plot(my.zoo,type="h",lwd=6,col="red")
par(new=T)
reg <-lm(coredata(my.zoo)~poly(index(my.zoo),6))
plot(predict(reg),type="l",yaxt = "n",ylab="",xlab="")
-------------------------------------------------------------------------------------------------------
graphics species species = unique(carbon2$Species) # c("Acru", "Arte", ...)
bin.name = c("Acer rubrum", "Arundinaria tecta", "Clethra alnifolia",
             "Eupatorium rotundifolium", "Gaylussacia frondosa", 
             "Ilex glabra", "Lyonia lucida", "Oxydendrum arboreum",
             "Persea palustris")

sites = c(7,8) # sites to use
color = c("blue", "green") # colors for each site

fit.bio = list() # list to save all models

par(mfrow=c(3,3), cex=.3) 

for(isp in seq_along(species)) {

  sp.data = carbon2[carbon2$Species==species[isp], ] 

  fit.bio[[isp]] <- lm(LogRecBio ~ LogPreBiomass, data=sp.data)

  sp.label     = paste(letters[isp], ") ", bin.name[isp], sep="")
  sp.r.squared = paste("R²", "=", round(summary(fit.bio[[isp]])$adj.r.squared, 3))
  plot(LogRecBio ~ LogPreBiomass, data=sp.data, 
       font.lab=2,font.main=2, font.sub=3, ylim=c(-5,4),
       mgp=c(2.5,1,0), cex.lab=2, cex.main=1.5, 
       axes=FALSE, lwd=1.5, cex=2.5, ann=FALSE)

  for(isite in seq_along(sites)) {
    # loop for each selected site
    site.data  = sp.data[sp.data$site==sites[isite], ]
    site.model = lm(LogRecBio ~ LogPreBiomass, data=site.data)
    abline(site.model, lwd=2, col=color[isite])

  }

  abline(fit.bio[[isp]], lwd=2, col='red') # all data

  axis(1,at=c(-2,-1,0,1,2,3,4),font=2,cex.axis=3)
  axis(2,at=c(-5,-4,-3,-2,-1,0,1,2),font=2,cex.axis=3)
  box()

  mtext(sp.label, 3, line=-2.5, adj=0.05, font=3, cex=0.75)
  mtext(sp.r.squared, 3, line=-2.5, adj=0.95, cex=0.75)

}
-------------------------------------------------------------------------------------------------------
par par(font.axis = 2) # 2 means 'bold'
boxplot(1:10) axis boxplot(1:10, yaxt = "n") # suppress y axis
axis(side = 2, font = 2)  # 'side = 2' means y axis par(font.axis = 1)
-------------------------------------------------------------------------------------------------------
base points lines barplot plot par(mar=c(5,5,2,3)+0.1)
ratio<-9e6/0.14
bar.col<-'#558ED5'
vencido.col<-'#77933C'
castigos.col<-'#FE0F0F'
b<-barplot(Data$'Monto Otorgado acumulado',names.arg=Data$Month,col=bar.col,border=FALSE,main='My Plot',ylim=c(0,9e6),axes=FALSE)
lines(b,Data$'% Vencida' * ratio, col=vencido.col,lwd=2) 
points(b,Data$'% Vencida' * ratio, col=vencido.col,bg='white',pch=21) 
lines(b,Data$'% Castigos' * ratio, col=castigos.col,lwd=2)
points(b,Data$'% Castigos' * ratio, col=castigos.col,bg='white',pch=21)
left.axis.pos<-seq(0,9e6,by=1e6)
axis(2,at=left.axis.pos,labels=formatC(left.axis.pos, big.mark = ",", format = "d"),las=2)
right.axis.ticks<-0:14
axis(4,at=(right.axis.ticks/100)*ratio,labels=paste0(right.axis.ticks,'%'),las=2)
legend('topleft',legend=c('Monto Otorgado acumulado','% Vencido','% Castigos'),col=c(bar.col,vencido.col,castigos.col),lty=1,lwd=c(4,2,2),bty='n')
par(mar=c(5,4,2,2)+0.1)
-------------------------------------------------------------------------------------------------------
axisG <- function(side, ...){
  if (side == "top"){
    at <- unique(test$GROUP)
    panel.axis(side = side, outside = TRUE, at = at, labels = at, rot = 0)
  }
  else axis.default(side = side, ...) 
}

plot(hexbinplot(test$VAR1 ~ test$VAR2,
                axis = axisG,
                panel = function(...){
                  panel.hexbinplot(...)
                  panel.abline(v = test$GROUP)}
))
-------------------------------------------------------------------------------------------------------
