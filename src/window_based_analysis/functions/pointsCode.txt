cumsum() #put your data into 3 vectors
x<-c(-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10)
dat1<-c(0.0140149,0.00890835,0.00672276,0.00876399,0.00806879,0.0088366,0.00856872,0.0195384,0.0160239,0.0254455,0.0397413,0.0743316,0.0247501,0.0214285,0.0241462,0.0150943,0.0141398,0.0101515,0.0308843,0.0095504,0.00729676)
dat2<-c(0.014015,0.008918,0.006725,0.008794,0.008081,0.008851,0.008578,0.019609,0.016183,0.025785,0.040091,0.075545,0.025332,0.021778,0.024497,0.015241,0.014237,0.010295,0.031294,0.009606,0.007371)

#create a new vector called cdat1 to hold the cumulative sum
cdat1<-cumsum(dat1)
plot(x,cdat1)
points(x,dat2,col="red")
-------------------------------------------------------------------------------------------------------
A <- read.table("data.txt",header=TRUE)
attach(A)
plot(x.axis, cumsum(dat1))
points(x.axis, cumsum(dat2), col='red')
-------------------------------------------------------------------------------------------------------
plot(scale, serial) scale serial class(scale)
[1] "data.frame" points() ylim plot data <- read.csv('foo.csv', header=T)
plot(data$scale, data$serial, ylim=c(0,750))
points(data$scale, data$spawn, col='red')
points(data$scale, data$for., col='green')
points(data$scale, data$worker, col='blue')
-------------------------------------------------------------------------------------------------------
ReadImages picture <- read.jpeg("avatar.jpg")
plot(picture) points(runif(50,0, 128), runif(50,0,128))
-------------------------------------------------------------------------------------------------------
abline(h=mean(x)) points(mean(x)) pch ?boxplot boxplot(count ~ spray, data = InsectSprays, col = "lightgray")
means <- tapply(InsectSprays$count,InsectSprays$spray,mean)
points(means,col="red",pch=18) tapply function(x) mean(x,na.rm=T)
-------------------------------------------------------------------------------------------------------
lines() points() plot(x,y1,type="l",col="red")
lines(x,y2,col="green")
-------------------------------------------------------------------------------------------------------
TRUE/FALSE lm() predict() severity.lm ## Dataset from 
#  apsnet.org/education/advancedplantpath/topics/
#    RModules/doc1/04_Linear_regression.html

## Disease severity as a function of temperature

# Response variable, disease severity
diseasesev<-c(1.9,3.1,3.3,4.8,5.3,6.1,6.4,7.6,9.8,12.4)

# Predictor variable, (Centigrade)
temperature<-c(2,1,5,5,20,20,23,10,30,25)

## For convenience, the data may be formatted into a dataframe
severity <- as.data.frame(cbind(diseasesev,temperature))

## Fit a linear model for the data and summarize the output from function lm()
severity.lm <- lm(diseasesev~temperature,data=severity)

## Get datapoints predicted by best fit line and confidence bands
## at every 0.01 interval
xRange=data.frame(temperature=seq(min(temperature),max(temperature),0.01))
pred4plot <- predict(
  severity.lm,
  xRange,
  level=0.95,
  interval="confidence"
) modelConfInt <- predict(
  severity.lm,
  level = 0.95,
  interval = "confidence"
)

insideInterval <- modelConfInt[,'lwr'] < severity[['diseasesev']] &
  severity[['diseasesev']] < modelConfInt[,'upr'] plot() points() matplot() par(new=TRUE) add=TRUE par(new=TRUE) add par() # Take a look at the data- those points inside the interval
plot(
  diseasesev~temperature,
  data=severity[ insideInterval,],
  xlab="Temperature",
  ylab="% Disease Severity",
  pch=16,
  pty="s",
  xlim=c(0,30),
  ylim=c(0,30)
)
title(main="Graph of % Disease Severity vs Temperature")

# Add points outside the interval, color differently
points(
  diseasesev~temperature,
  pch = 16,
  col = 'red',
  data = severity[ !insideInterval,]
)

# Add regression line and confidence intervals
matplot(
  xRange,
  pred4plot,
  lty=c(1,2,2),   #vector of line types and widths
  type="l",       #type of plot for each column of y
  add = TRUE
)
-------------------------------------------------------------------------------------------------------
diseasesev<-c(1.9,3.1,3.3,4.8,5.3,6.1,6.4,7.6,9.8,12.4)
# Predictor variable, (Centigrade)
temperature<-c(2,1,5,5,20,20,23,10,30,25)

## For convenience, the data may be formatted into a dataframe
severity <- as.data.frame(cbind(diseasesev,temperature))

## Fit a linear model for the data and summarize the output from function lm()
severity.lm <- lm(diseasesev~temperature,data=severity)

# Function to plot the linear regression and overlay the confidence intervals   
ci.lines<-function(model,conf= .95 ,interval = "confidence"){
  x <- model[[12]][[2]]
  y <- model[[12]][[1]]
  xm<-mean(x)
  n<-length(x)
  ssx<- sum((x - mean(x))^2)
  s.t<- qt(1-(1-conf)/2,(n-2))
  xv<-seq(min(x),max(x),(max(x) - min(x))/100)
  yv<- coef(model)[1]+coef(model)[2]*xv

  se <- switch(interval,
        confidence = summary(model)[[6]] * sqrt(1/n+(xv-xm)^2/ssx),
        prediction = summary(model)[[6]] * sqrt(1+1/n+(xv-xm)^2/ssx)
              )
  # summary(model)[[6]] = 'sigma'

  ci<-s.t*se
  uyv<-yv+ci
  lyv<-yv-ci
  limits1 <- min(c(x,y))
  limits2 <- max(c(x,y))

  predictions <- predict(model, level = conf, interval = interval)

  insideCI <- predictions[,'lwr'] < y & y < predictions[,'upr']

  x_name <- rownames(attr(model[[11]],"factors"))[2]
  y_name <- rownames(attr(model[[11]],"factors"))[1]

  plot(x[insideCI],y[insideCI],
  pch=16,pty="s",xlim=c(limits1,limits2),ylim=c(limits1,limits2),
  xlab=x_name,
  ylab=y_name,
  main=paste("Graph of ", y_name, " vs ", x_name,sep=""))

  abline(model)

  points(x[!insideCI],y[!insideCI], pch = 16, col = 'red')

  lines(xv,uyv,lty=2,col=3)
  lines(xv,lyv,lty=2,col=3)
} ci.lines(severity.lm, conf= .95 , interval = "confidence")
ci.lines(severity.lm, conf= .85 , interval = "prediction")
-------------------------------------------------------------------------------------------------------
library("foreach")
library("strucchange")
data("UKDriverDeaths")
seatbelt <- log10(UKDriverDeaths)
seatbelt <- cbind(seatbelt, lag(seatbelt, k = -1), lag(seatbelt, k = -12))
colnames(seatbelt) <- c("y", "ylag1", "ylag12")
seatbelt <- window(seatbelt, start = c(1970, 1), end = c(1984,12))

# without
system.time(
for (i in 1:10) {
  print(system.time(bp.seat <- breakpoints(y ~ ylag1 + ylag12, data = seatbelt, h = 0.1)))
})
## with SNOW 
library(snow)
cl <- makeCluster(c("localhost","localhost"), type = "SOCK")
clusterApply(cl, 1:2, get("+"), 3)
system.time(
for (i in 1:10) {
  print(system.time(bp.seat <- breakpoints(y ~ ylag1 + ylag12, data = seatbelt, h = 0.1,hpc=c("foreach"))))
}
)
stopCluster(cl)
-------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------
diseasesev<-c(1.9,3.1,3.3,4.8,5.3,6.1,6.4,7.6,9.8,12.4)

# Predictor variable, (Centigrade)
temperature<-c(2,1,5,5,20,20,23,10,30,25)

## For convenience, the data may be formatted into a dataframe
severity <- as.data.frame(cbind(diseasesev,temperature))

## Fit a linear model for the data and summarize the output from function lm()
severity.lm <- lm(diseasesev~temperature,data=severity)

line1 <- severity.lm$coefficients * c(1,2)
line2 <- severity.lm$coefficients * c(1,.5)

df <- as.data.frame(severity.lm[[12]])
df2 <- adply(df,1,function(x) cbind(line1[2]*x[[2]]+line1[1], line2[2]*x[[2]]+line2[1]))

plot(
  df2[df2[,1] >= min(df2[,c(3,4)]) & df2[,1] <= max(df2[,c(3,4)]),c(2,1)],
  xlab="Temperature",
  ylab="% Disease Severity",
  pch=16,
  pty="s",
  xlim=c(0,30),
  ylim=c(0,30)
)
title(main="Graph of % Disease Severity vs Temperature")
par(new=TRUE) # don't start a new plot
abline(severity.lm, col="blue")
abline(line1, col="cyan")
abline(line2, col="cyan")
points(df2[df2[,1] < min(df2[,c(3,4)]) | df2[,1] > max(df2[,c(3,4)]),c(2,1)], pch = 16, col = 'red')
-------------------------------------------------------------------------------------------------------
set.seed(100)
Data <- rbind(matrix(rnorm(100, sd = 0.3), ncol = 2),
           matrix(rnorm(100, mean = 1, sd = 0.3), ncol = 2))
colnames(x) <- c("x", "y")

# noise <- runif(100,0,.05)
line.width <- rep(.004, dim(Data)[1])
Y <- NULL
X <- NULL
k.range <- 2:10

plot(0,0, col = "white", xlim = c(1,10), ylim = c(-.5,1.6),
    xlab = "Number of clusters", ylab = "Clusters means", main = "(Basic) Clustergram")
axis(side =1, at = k.range)
abline(v = k.range, col = "grey")

centers.points <- list()

for(k in k.range)
{
    cl <- kmeans(Data, k)

    clusters.vec <- cl$cluster
    the.centers <- apply(cl$centers,1, mean)

    noise <- unlist(tapply(line.width, clusters.vec, cumsum))[order(seq_along(clusters.vec)[order(clusters.vec)])]  
    noise <- noise - mean(range(noise))
    y <- the.centers[clusters.vec] + noise
    Y <- cbind(Y, y)
    x <- rep(k, length(y))
    X <- cbind(X, x)

    centers.points[[k]] <- data.frame(y = the.centers , x = rep(k , k)) 
#   points(the.centers ~ rep(k , k), pch = 19, col = "red", cex = 1.5)
}

require(colorspace)
COL <- rainbow_hcl(100)
matlines(t(X), t(Y), pch = 19, col = COL, lty = 1, lwd = 1.5)

# add points
lapply(centers.points, function(xx) {with(xx,points(y~x, pch = 19, col = "red", cex = 1.3))})
-------------------------------------------------------------------------------------------------------
ggplot(cars, aes(x=speed, y=dist))+
geom_point(aes(col=speed))+
geom_point(colour="white")+
theme_bw()
-------------------------------------------------------------------------------------------------------
#loess and error curves almost just like ggplot2
op <- par(las=1, mar = c(3,3,1,1))
n <- 30
x <- sort(rnorm(n)) #(varying density in predictor)
x <- x + abs(min(x))
x <- x/max(x)*2*pi 
y <- sin(x)+rnorm(n) #(curvy)
m <- loess(y~x)
xx <- seq(min(x), max(x), (max(x)-min(x))/1000) #increase density of values to predict over to increase quality of curve
f <- predict(m, xx, se = TRUE)
ci <- f$se * qt(0.975, f$df)
cih <- f$fit + ci
cil <- f$fit - ci
plot(x,y, ylim = c(min(cil,y), max(cih,y)), cex.axis = 0.85, xlab = '', ylab = '', type = 'n')
title(xlab = 'x', ylab = 'y',line = 2)
grid(col = 'gray')
points(x,y, pch = 19, cex = 0.65)
lines(xx, f$fit, col = 'blue', lwd = 1.2)
xx <- c(xx, rev(xx))
yy <- c(cil, rev(cih))
polygon(xx, yy, col=rgb(0.1,0.1,0.1,0.25), border = NA)
par(op)

#qplot(x,y, geom = 'point') + stat_smooth()
-------------------------------------------------------------------------------------------------------
pch for_y_axis <- c(0.49534,0.80796,0.93970,0.99998)
for_x_axis <- c(1,2,3,4)
count <- c(0,33,0,4)

zerocount <- function(x) {
    ifelse (x == 0, x <- 0, x <- 1)
}

pts <- sapply(count, zerocount)
plot(for_x_axis, for_y_axis, type = "n")
points(for_x_axis, for_y_axis, pch = pts)
-------------------------------------------------------------------------------------------------------
data(AirPassengers)   # time series in months (supplied w/ default R install)
AP = AirPassengers
library(xts)
X = as.xts(AP)      # need xts object to pass to xts binning method
ndx = endpoints(X, on="years")    # binning method requires indices for desired bin freq
X_yr = period.apply(x=X, INDEX=ndx, FUN=sum)   # X_yr is the binned data
-------------------------------------------------------------------------------------------------------
par(new=TRUE) plot(1,1) ## start a plot
opar <- par(new = TRUE, ## add a new layer
            mar = c(0,0,0,0)) ## with no margins margins
## set up the plotting area for this layer
plot(1,1,xlim=c(0,1),ylim=c(0,1),type='n',xlab='',ylab='') 
arrows(0.1,0.05,0.5,0.05) ## add arrow
par(opar) ## return the plot parameters to their prior values plot(1,1,xlim=0:1,ylim=0:1)
arrows(0.1,0.05,0.5,0.05)
gpar <- par()
opar <- par(new = TRUE, mar = c(0,0,0,0),xaxs='i',yaxs='i')

m1 <- (gpar$usr[2] - gpar$usr[1])/(gpar$plt[2] - gpar$plt[1])
c1 <- gpar$usr[1] - m1*gpar$plt[1]
m2 <- (gpar$usr[4] - gpar$usr[3])/(gpar$plt[4] - gpar$plt[3])
c2 <- gpar$usr[3] - m2*gpar$plt[3]
xlim <- c(c1, m1 + c1)
ylim <- c(c2, m2 + c2)

plot(1,1,xlim=xlim,ylim=ylim,type='n',xlab='',ylab='')
arrows(0.1,0.05,0.5,0.05,col='red')
points(1,1,col='red')
par(opar)
-------------------------------------------------------------------------------------------------------
> data(AirPassengers); AP = AirPassengers
> # import the package xts, which will 'auto-import' its sole dependency, 
> # the package 'zoo'
> library(xts)    

# AP is an R time series whose data points are in months
> class(AP)
[1] "ts"
> start(AP)
[1] 1949    1
> end(AP)
[1] 1960   12
> frequency(AP)
[1] 12
> AP[1:3]
[1] 112 118 132

> # step 1: convert ts object to an xts object
> X = as.xts(AP)
> class(X)
[1] "xts" "zoo"
> # step 2: create index of endpoints to pass to the aggregator function
> np = endpoints(X, on="years")
> # step 3: call the aggregator function
> X2 = period.apply(X, INDEX=np, FUN=sum)
> X2[1:3]
         [,1]
Dec 1949 1520
Dec 1950 1676
Dec 1951 2042
> # 'X2' is in years (each value is about 12X higher than the first three values for
> # AP above
-------------------------------------------------------------------------------------------------------
zoo cummax zoo > set.seed(21)
> z <- zoo(runif(10),as.chron(Sys.Date()-10:1))
> merge(z,cummax=cummax(z),diff=cummax(z)-z)
                  z    cummax      diff
08/09/10 0.66754012 0.6675401 0.0000000
08/10/10 0.93521022 0.9352102 0.0000000
08/11/10 0.05818433 0.9352102 0.8770259
08/12/10 0.61861583 0.9352102 0.3165944
08/13/10 0.17491846 0.9352102 0.7602918
08/14/10 0.03767539 0.9352102 0.8975348
08/15/10 0.52531317 0.9352102 0.4098971
08/16/10 0.28218425 0.9352102 0.6530260
08/17/10 0.49904520 0.9352102 0.4361650
08/18/10 0.63382510 0.9352102 0.3013851 > require(xts)  # for the endpoints() function
> set.seed(21)
> z <- zoo(runif(10),as.chron(Sys.Date()-seq(0.5,3,length.out=10)))
> ep <- endpoints(z,"days")
> Z <- lapply(1:(length(ep)-1), function(x) cummax(z[(ep[x]+1):ep[x+1]]))
> Z <- do.call(rbind, Z)
> merge(z,Z,Z-z)
                            z         Z     Z - z
(08/16/10 00:00:00) 0.8493961 0.8493961 0.0000000
(08/16/10 06:40:00) 0.9860037 0.9860037 0.0000000
(08/16/10 13:20:00) 0.1721917 0.9860037 0.8138120
(08/16/10 20:00:00) 0.1018046 0.9860037 0.8841991
(08/17/10 02:40:00) 0.9186834 0.9186834 0.0000000
(08/17/10 09:20:00) 0.9596138 0.9596138 0.0000000
(08/17/10 16:00:00) 0.1844608 0.9596138 0.7751531
(08/17/10 22:40:00) 0.6992523 0.9596138 0.2603615
(08/18/10 05:20:00) 0.2524456 0.2524456 0.0000000
(08/18/10 12:00:00) 0.7861149 0.7861149 0.0000000
-------------------------------------------------------------------------------------------------------
plot(x1,y1, xlim=range(x1,x2,x3), ylim=range(y1,y2,y3))
points(x2,y2, col='blue')
points(x3,y3, col='red')
-------------------------------------------------------------------------------------------------------
?par mfrow par(mfrow=c(2,2)) ?split.screen ?layout # Create 3 plots
dev.new()  # Or X11()
dev.1 <- as.integer(dev.cur())
dev.new()
dev.2 <- as.integer(dev.cur())
dev.new()
dev.3 <- as.integer(dev.cur())

x <- seq(1, 100, 0.1)

# Switch to device 1
dev.set(dev.1)
plot(x, sin(x), "l")
# Switch to device 3
dev.set(dev.3)
plot(x, cos(x), "l")
# Add something to graph #1
dev.set(dev.1)
points(x, cos(x), "l", col="red") dev.1 dev.2 dev.3 dev.cur
-------------------------------------------------------------------------------------------------------
period.apply x > period.apply(x, endpoints(x,k=3,"minutes"), mean)
-------------------------------------------------------------------------------------------------------
plot( 0:15, 0:15, type='n' )
points( (0:255)%% 16, (0:255) %/% 16, pch=0:255, font=5 )
-------------------------------------------------------------------------------------------------------
center <- apply(embed(tmp,wdw),1,weightedMedian,w=weights,na.rm=T) require(aroma.light)
# make.weights : function to make weights on basis of a normal distribution
# n is window size !!!!!!
make.weights <- function(n,
      type=c("gaussian","epanechnikov","biweight","triweight","cosinus")){
    type <- match.arg(type)
    x <- seq(-1,1,length.out=n)
    out <-switch(type,
          gaussian=(1/sqrt(2*pi)*exp(-0.5*(3*x)^2)),
          epanechnikov=0.75*(1-x^2),
          biweight=15/16*(1-x^2)^2,
          triweight=35/32*(1-x^2)^3,
          cosinus=pi/4*cos(x*pi/2),
          )
    out <- out/sum(out)*n
    return(out)
}

# score.test : function to become a p-value based on the score test
# uses normal approximation, but is still quite correct when p0 is
# pretty small.
# This test is one-sided, and tests whether the observed proportion
# is bigger than the hypothesized proportion
score.test <- function(x,p0,w){
    n <- length(x)
    if(missing(w)) w<-rep(1,n)
    w <- w[!is.na(x)]
    x <- x[!is.na(x)]

    if(sum(w)!=n) w <- w/sum(w)*n

    phat <- sum(x*w)/n
    z <- (phat-p0)/sqrt(p0*(1-p0)/n)
    p <- 1-pnorm(z)
    return(p)
}

# embed.na is a modification of embed, adding NA strings
# to the beginning and end of x. window size= 2n+1
embed.na <- function(x,n){
    extra <- rep(NA,n)
    x <- c(extra,x,extra)
    out <- embed(x,2*n+1)
    return(out)
}

# running.score : function to calculate the weighted p-value for the chance of being in
# a run of peaks. This chance is based on the weighted proportion of the neighbourhood
# the null hypothesis is calculated by taking the weighted proportion
# of detected peaks in the whole dataset.
# This lessens the need for adjusting parameters and makes the
# method more automatic.
# for a correct calculation, the weights have to sum up to n

running.score <- function(sel,n=20,w,p0){
    if(missing(w)) w<- rep(1,2*n+1)
    if(missing(p0))p0 <- sum(sel,na.rm=T)/length(sel[!is.na(sel)])   # null hypothesis
    out <- apply(embed.na(sel,n),1,score.test,p0=p0,w=w)
    return(out)
}

# running.med : function to calculate the running median and mad
# for a dataset. Window size = 2n+1
running.med <- function(x,w,n,cte=1.4826){
    wdw <- 2*n+1
    if(missing(w)) w <- rep(1,wdw)

    center <- apply(embed.na(x,n),1,weightedMedian,w=w,na.rm=T)
    mad <- median(abs(x-center))*cte
    return(list(med=center,mad=mad))
}

##############################################
#
# Create series
set.seed(100)
n = 1000
series <- diffinv(rnorm(20000),lag=1)

peaks <- apply(embed.na(series,n),1,function(x) x[n+1] < quantile(x,probs=0.05,na.rm=T))

pweight <- make.weights(0.2*n+1)
p.val <- running.score(peaks,n=n/10,w=pweight)

plot(series,type="l")
points((1:length(series))[p.val<0.05],series[p.val<0.05],col="red")
points((1:length(series))[peaks],series[peaks],col="blue") #first derivative
f.deriv <- diff(lowess(series,f=n/length(series),delta=1)$y)
#second derivative
f.sec.deriv <- diff(f.deriv)
#minima and maxima defined by where f.sec.deriv changes sign :
minmax <- cumsum(rle(sign(f.sec.deriv))$lengths)

op <- par(mfrow=c(2,1))
plot(series,type="l")
plot(f.deriv,type="l")
points((1:length(f.deriv))[minmax],f.deriv[minmax],col="red")
par(op)
-------------------------------------------------------------------------------------------------------
df <- data.frame(sort(x), ppoints(x))
colnames(df) <- c("x","y")

ggplot(df, aes(x,y)) + 
geom_point() + 
stat_smooth() + 
scale_y_continuous(limits=c(0,1),breaks=seq(from=0.05,to=1,by=0.05), formatter="percent")
-------------------------------------------------------------------------------------------------------
maps map("state")
points(longitute,latitude) segments() map_data() geom_polygon() geom_point() geom_segment() maptools mapproj mapdata
-------------------------------------------------------------------------------------------------------
data.frame > Data <- data.frame(Time=Sys.time()+1:20,x=rnorm(20))
> xData <- xts(Data[,-1], Data[,1])
> period.apply(xData, endpoints(xData, "seconds", 5), colMeans)
                           [,1]
2010-10-20 13:34:19 -0.20725660
2010-10-20 13:34:24 -0.01219346
2010-10-20 13:34:29 -0.70717312
2010-10-20 13:34:34  0.09338097
2010-10-20 13:34:38 -0.22330363 endpoints > nSeconds <- 5
> agg <- aggregate(Data[,-1], by=list(as.numeric(Data$Time) %/% nSeconds), mean)
> agg[,1] <- .POSIXct(agg[,1]*nSeconds)  # >= R-2.12.0 required for .POSIXct
-------------------------------------------------------------------------------------------------------
ggplot2 data <- as.data.frame(data)
d1 <- density(data$gest[which(data$season==1)], na.rm=TRUE)
d2 <- density(data$gest[which(data$season==2)], na.rm=TRUE)
plot(d1, ylim=c(0, max(d1$y,d2$y)), xlim=range(c(d1$x, d2$x)),
  main="Length of gestation", xlab="Length (days)", col="blue", lwd=2)
polygon(d1$x, d1$y, col=rgb(0, 0, 1, 0.5), lty=0)
points(d2, t="l", col="red", lwd=2)
polygon(d2$x, d2$y, col=rgb(1, 0, 0, 0.5), lty=0) densityplot lattice hist(data$gest[which(data$season==1)], main="Length of gestation", 
    xlab="Length (days)", col=rgb(0, 0, 1, 0.5))
# Note the add=TRUE parameter to superimpose the histograms
hist(data$gest[which(data$season==2)], col=rgb(1, 0, 0, 0.5), add=TRUE)
-------------------------------------------------------------------------------------------------------
setMethod definition where setMethod("plot", signature(x="CIR"),
  function(x) {
  plot(slot(x,"GRID"),slot(x,"PATH"),type="l")
  points(slot(x,"GRID"),slot(x,"PATH"),col="red",cex=0.5)
})
-------------------------------------------------------------------------------------------------------
plot(0, 0, xlim = c(1, 4), ylim = range(casp6), type = "n")
points(casp6 ~ trans.factor)
-------------------------------------------------------------------------------------------------------
grid.points(x=rep(0.1,9),y=1:9/10,pch=1:10,default.units="npc")
grid.text(x=rep(0.2,9),y=1:9/10,label=letters[1:9],default.units="npc")
-------------------------------------------------------------------------------------------------------
plot(), lines(), abline(), points(), polygon(), segments(), rect(), box(), arrows(), ... set.seed(100)
x <- 1:10
y <- x^2
y2 <- x^3
yse <- abs(runif(10,2,4))

plot(x,y, type = "n")  # type="n" only plots the pane, no curves or points.

# plots the area between both curves
polygon(c(x,sort(x,decreasing=T)),c(y,sort(y2,decreasing=T)),col="grey")
# plot both curves
lines(x,y,col="purple")
lines(x, y2, col = "red")
# add the points to the first curve
points(x, y, col = "black")
# adds some lines indicating the standard error
segments(x,y,x,y+yse,col="blue")
# adds some flags indicating the standard error
arrows(x,y,x,y-yse,angle=90,length=0.1,col="darkgreen")
-------------------------------------------------------------------------------------------------------
# sample data
x <- rnorm(50,0,2)
y <- x+rnorm(50,0,2)

# construct polygons
div <- quantile(y-x,c(0.25,0.75))
x1 <- min(c(x,y))
x2 <- max(c(x,y))


plot(x,y,type="n")
polygon(x=c(x1,x1,x2,x2),y=c(x1+div,(x2+div)[c(2,1)]),col="grey")
abline(0,1)
points(x,y) qplot(x,y,geom="point") + stat_smooth(method="lm") sd(y-x) sd(residuals(lm(y~x)))
-------------------------------------------------------------------------------------------------------
x<-round(rnorm(1000, 100, 15))
y<-table(x)
plot(y)
par(new=TRUE)
plot(density(x), yaxt="n", ylab="", xlab="", xaxt="n") lines(sort(x), dnorm(sort(x), 100, 15), col="red") points(x, dnorm(x, 100, 15))
-------------------------------------------------------------------------------------------------------
y runif [0,1] [-1,1] gam.object2 <- gam( yn ~ s( x ))
p2 <- predict( gam.object2, data.frame( x=201:210 ))
points( 1:211, c( fitted( gam.object2 ), p2), col="green") gam gam.object dataframe
-------------------------------------------------------------------------------------------------------
slope = 0.55
amplitude = 0.22
frequency = 3
noise = 0.75
x <- 1:200
y <- (slope * x / 100) + (amplitude * sin( frequency * x / 100 ))
ynoise <- y + (noise * runif( length( x ) ))

gam.object <- gam( ynoise ~ s( x ) )
p <- predict( gam.object, data.frame( x = 1:210 ) )

plot( p, col = rgb( 0, 0.75, 0.2 ) )
points( x, ynoise, col = rgb( 0.121, 0.247, 0.506 ) )
points( fitted( gam.object ), col = rgb( 1.0, 0.392, 0.0 ) )
-------------------------------------------------------------------------------------------------------
require(MASS) ## for mvrnorm()
set.seed(1)
dat <- mvrnorm(1000, mu = c(4,5), Sigma = matrix(c(1,0.8,1,0.8), ncol = 2))
dat <- data.frame(dat)
names(dat) <- c("X","Y")
plot(dat) res <- resid(mod <- lm(Y ~ X, data = dat)) quantile() res.qt <- quantile(res, probs = c(0.05,0.95)) want <- which(res >= res.qt[1] & res <= res.qt[2]) plot(dat, type = "n")
points(dat[-want,], col = "black", pch = 21, bg = "black", cex = 0.8)
points(dat[want,], col = "red", pch = 21, bg = "red", cex = 0.8)
abline(mod, col = "blue", lwd = 2) > cor(dat)
          X         Y
X 1.0000000 0.8935235
Y 0.8935235 1.0000000
> cor(dat[want,])
          X         Y
X 1.0000000 0.9272109
Y 0.9272109 1.0000000
> cor(dat[-want,])
         X        Y
X 1.000000 0.739972
Y 0.739972 1.000000 ares <- abs(res)
absres.qt <- quantile(ares, prob = c(.9))
abswant <- which(ares <= absres.qt)
## plot - virtually the same, but not quite
plot(dat, type = "n")
points(dat[-abswant,], col = "black", pch = 21, bg = "black", cex = 0.8)
points(dat[abswant,], col = "red", pch = 21, bg = "red", cex = 0.8)
abline(mod, col = "blue", lwd = 2) > cor(dat[abswant,])
          X         Y
X 1.0000000 0.9272032
Y 0.9272032 1.0000000 cooks.distance() mod > head(cooks.distance(mod))
           1            2            3            4            5            6 
7.738789e-04 6.056810e-04 6.375505e-04 4.338566e-04 1.163721e-05 1.740565e-03 > any(cooks.distance(mod) > 1)
[1] FALSE
> any(cooks.distance(mod) > (4 * nrow(dat)))
[1] FALSE
-------------------------------------------------------------------------------------------------------
df$count <- 1
x <- xts(df$count,as.POSIXct(paste(df$date,df$time)))

# create aggregates and plot with plot.zoo()
plot.zoo(period.apply(x, endpoints(index(x),"years"), sum), type="h")
plot.zoo(period.apply(x, endpoints(index(x),"quarters"), sum), type="h")
plot.zoo(period.apply(x, endpoints(index(x),"months"), sum), type="h")
plot.zoo(period.apply(x, endpoints(index(x),"weeks"), sum), type="h")
plot.zoo(period.apply(x, endpoints(index(x),"days"), sum), type="h")
plot.zoo(period.apply(x, endpoints(index(x),"hours"), sum), type="h")
-------------------------------------------------------------------------------------------------------
w_sp = sample(seq(0, 100, 0.01), 1000)
power = 1/(1+exp(-(rnorm(1000, mean=w_sp, sd=5) -40)/5)) power bin_incr = 5
bins = seq(0, 95, bin_incr)
y_mean = sapply(bins, function(x) mean(power[w_sp >= x & w_sp < (x+bin_incr)])) mean median plot(w_sp, power)
points(seq(2.5, 97.5, 5), y_mean, col=3, pch=16) noOutliers = function(x, power, w_sp, bin_incr) {
  d = power[w_sp >= x & w_sp < (x + bin_incr)]
  m_d = mean(d)
  d_trim = mean(d[d > (m_d - 2*sd(d)) & (d < m_d + 2*sd(d))])
  return(mean(d_trim))
}

y_no_outliers = sapply(bins, noOutliers, power, w_sp, bin_incr)
-------------------------------------------------------------------------------------------------------
library(zoo)
start <- as.POSIXct("2010-01-01") 
freq <- as.difftime(6, units = "hours") 
dayvals <- (1:4)*10 
timevals <- c(3, 1, 2, 4) 
index <- seq(from = start, by = freq, length.out = 16)
obs <- (rep(dayvals, each = 4) + rep(timevals, times = 4))
myzoo <- myzoo.orig <- zoo(obs, index)
myzoo[10] <- NA

myzoo.fixed <- na.locf(myzoo)

myarima.resid <- arima(myzoo.fixed, order = c(3, 0, 3), seasonal = list(order = c(0, 0, 0), period = 4))$residuals
myzoo.reallyfixed <- myzoo.fixed
myzoo.reallyfixed[10] <- myzoo.fixed[10] + myarima.resid[10]

plot(myzoo.reallyfixed)
points(myzoo.orig)
-------------------------------------------------------------------------------------------------------
read.jpeg() rimage anImage <- read.jpeg("anImage.jpeg")
plot(anImage)
points(my.x,my.y,col="red")
... ?par readPNG png readPNG rasterImage img <- readPNG(system.file("img", "Rlogo.png", package="png"))
r = as.raster(img[,,1:3])
r[img[,,4] == 0] = "white"

plot(1:2,type="n")
rasterImage(r,1,1,2,2) read.gif caTools Gif <- read.gif("http://www.openbsd.org/art/puffy/ppuf600X544.gif")

n <- dim(Gif$image)
image(t(Gif$image)[n[2]:1,n[1]:1],col=Gif$col,axes=F) image(t(Gif$image)[n[2]:1,n[1]:1],col=Gif$col,axes=F)
op <- par(new=T)
plot(1:100,new=T)
par(op)
-------------------------------------------------------------------------------------------------------
splancs data(bodmin)
plot(bodmin$poly,asp=1,type="n")
image(kernel2d(as.points(bodmin),bodmin$poly, h0=2,nx=100,ny=100),
        add=TRUE, col=terrain.colors(20))
pointmap(as.points(bodmin),add=TRUE)
polymap(bodmin$poly,add=TRUE)
bodmin.xy<-coordinates(bodmin[1:2])
apply(bodmin$poly,2,range)
grd1<-GridTopology(cellcentre.offset=c(-5.2,-11.5),cellsize=c(0.2,0.2),cells.dim=c(100,100))
k100<-spkernel2d(bodmin.xy,bodmin$poly,h0=1,grd1)
k150<-spkernel2d(bodmin.xy,bodmin$poly,h0=1.5,grd1)
k200<-spkernel2d(bodmin.xy,bodmin$poly,h0=2,grd1)
k250<-spkernel2d(bodmin.xy,bodmin$poly,h0=2.5,grd1)
if(.sp_lt_0.9()){
    df<-AttributeList(list(k100=k100,k150=k150,k200=k200,k250=k250))
} else{
    df<-data.frame(k100=k100,k150=k150,k200=k200,k250=k250)
}
kernels<-SpatialGridDataFrame(grd1,data=df)
spplot(kernels,checkEmptyRC=FALSE,col.regions=terrain.colors(16),cuts=15) kern.obj <- structure(c(-161.913250909479, 154.013482116162, 31.6474639061300, 
17.7340639366637, -102.170823111156, 17.6809699563749, 90.505728795223, 
143.854796792441, -70.1806511117134, 230.600354761065, 133.500211485414, 
-225.74140063979, 220.599384351733, -55.5956512970632, 128.631103577179, 
-36.9382693513206, 86.1151116370548, -67.9572171234925, 138.313636950703, 
59.4122360493993, -128.418347257186, 28.4313444162254, -253.438542232118, 
-2.62936998134802, 96.6705573949275, 126.350347596454, -76.3053490233138, 
-98.1667749493097, -132.615954657406, -239.003804126569, -32.052834858324, 
152.055005227299, -171.132473363859, -96.0272921226682, -91.4859761718545, 
172.662664785850, 92.3258005260648, -9.33884441249779, -24.4260189034222, 
-171.435971200881, 84.9052731383744, -171.768339197942, -13.5871193263486, 
-51.839925496188, -193.00283491136, 57.1126055897217, -40.890549093622, 
83.600134171797, 6.66515671609591, -261.487889322599, 138.624659821426, 
158.911075756538, 111.598989561161, 62.6150728399137, -155.366548557697, 
95.9501552130317, -32.0820888905296, -85.4929337702259, -178.010310820340, 
100.526315864149, -190.431234842843, 223.959168312304, -10.693030515916, 
-155.820490522984, 87.7527496146106, 293.991051801515, -69.1568338969259, 
77.0440461941863, -137.088789092018, -284.434533670747, -52.9437134391306, 
129.855822783810, 147.208098412254, -144.394565933009, 11.1193096498363, 
-26.6883210946328, 36.3402764034715, -27.5111672678245, 161.017920279498, 
133.961438546933, -139.924061267615, -194.861248844460, -138.902485043792, 
-59.6746738747854, -193.856125217724, 58.9319665388044, -151.870347293954, 
185.500357832384, 77.8198201646078, 217.406148533358, 125.978806993972, 
-96.8970637852723, 85.2079461295587, -71.5845844358825, 90.0263897196243, 
-3.85398693321446, -233.945188963933, -252.371240484100, -152.282817449886, 
-175.448833834566, 74.8285138048232, 218.884530197829, -65.9526397939771, 
113.776709279045, -69.4176647812128, -196.919950610027, 268.779812799767, 
119.294722331688, 272.239590017125, -161.720151454210, -16.8415614869446, 
-13.6117741931230, -96.0124779492617, 157.184316962957, 188.061125110835, 
-214.437550725415, 121.667246008292, 89.747676299885, -4.44232751615345, 
-106.699166027829, -261.718519963324, -42.1719799283892, -78.4863225650042, 
204.811030067503, 265.774235548452, 38.5583057999611, -239.476124290377, 
231.875250348821, 135.243163537234, -42.7497774828225, -59.7301519475877, 
-2.99901310354471, -240.498538082466, -109.713196987286, 172.524304641411, 
113.648047484457, -221.150079695508, 131.948393024504, 62.1528406161815, 
-8.31053741276264, -76.1619768105447, 157.933613704517, -42.225355328992, 
208.729289704934, 10.0781018380076, 98.7709498498589, -74.8700814787298, 
-215.313404565677, -87.6694556325674, -139.495075587183, -28.3679623156786, 
-76.2799751479179, -138.629644783214, -164.171522296965, 16.3864661939442, 
-109.221789333969, -49.0070185158402, -23.0688956100494, 54.3438952881843, 
-145.427243504673, -18.4494345914572, 14.391646720469, -200.727640092373, 
187.278914311901, -75.3078812733293, 4.16369824670255, -191.299003595486, 
169.710802193731, -103.791763912886, 32.9403738956898, -91.6615933645517, 
-222.505887318403, 49.3231621105224, -151.363900210708, -23.9421324804425, 
-207.101033208892, 169.309269497171, -250.131661305204, 11.1456824932247, 
-193.683278560638, -66.6569401044399, -139.672750141472, -115.024601574987, 
-198.41345124878, -205.971520487219, 104.227339709178, 162.442225730047, 
-167.216443363577, -100.033209286630, 152.823372976854, -191.260906308889, 
-234.539421927184, 213.049413822591, 130.761165590957, -234.716210095212, 
6.07512393034995, -49.286244995892, -56.5862323623151, -50.971424812451, 
-168.812829069793), .Dim = c(100L, 2L), .Dimnames = list(NULL, 
    c("x", "y")))

circpol <- structure(c(37.674311717588, 75.1999401385825, 112.428788751435, 
149.213932298913, 185.410196624968, 220.874731610807, 255.467574939044, 
289.052204461029, 321.496076987398, 352.671151375484, 382.454393849214, 
410.728263557213, 437.381176452847, 462.307945665474, 485.410196624968, 
506.596755301209, 525.784008026318, 542.896231479612, 557.865891532951, 
570.633909777092, 581.149896677179, 589.372350437213, 595.268820788687, 
598.816037056963, 600, 598.816037056963, 595.268820788687, 589.372350437213, 
581.149896677179, 570.633909777092, 557.865891532951, 542.896231479612, 
525.784008026318, 506.596755301209, 485.410196624968, 462.307945665474, 
437.381176452847, 410.728263557213, 382.454393849214, 352.671151375484, 
321.496076987398, 289.052204461029, 255.467574939043, 220.874731610807, 
185.410196624968, 149.213932298913, 112.428788751435, 75.1999401385824, 
37.6743117175879, -1.92977144680695e-13, -37.674311717588, -75.1999401385826, 
-112.428788751435, -149.213932298913, -185.410196624969, -220.874731610807, 
-255.467574939044, -289.052204461029, -321.496076987398, -352.671151375484, 
-382.454393849214, -410.728263557213, -437.381176452847, -462.307945665474, 
-485.410196624968, -506.596755301209, -525.784008026318, -542.896231479612, 
-557.865891532951, -570.633909777092, -581.149896677179, -589.372350437213, 
-595.268820788687, -598.816037056963, -600, -598.816037056963, 
-595.268820788687, -589.372350437213, -581.149896677179, -570.633909777092, 
-557.865891532951, -542.896231479612, -525.784008026318, -506.596755301209, 
-485.410196624968, -462.307945665473, -437.381176452847, -410.728263557213, 
-382.454393849214, -352.671151375484, -321.496076987398, -289.052204461029, 
-255.467574939043, -220.874731610807, -185.410196624968, -149.213932298913, 
-112.428788751435, -75.1999401385823, -37.6743117175880, -1.46952762458685e-13, 
37.674311717588, 598.816037056963, 595.268820788687, 589.372350437213, 
581.149896677179, 570.633909777092, 557.865891532951, 542.896231479612, 
525.784008026318, 506.596755301209, 485.410196624968, 462.307945665473, 
437.381176452847, 410.728263557213, 382.454393849214, 352.671151375484, 
321.496076987398, 289.052204461029, 255.467574939044, 220.874731610807, 
185.410196624968, 149.213932298913, 112.428788751435, 75.1999401385825, 
37.674311717588, -9.64885723403475e-14, -37.6743117175880, -75.1999401385826, 
-112.428788751435, -149.213932298913, -185.410196624969, -220.874731610807, 
-255.467574939044, -289.052204461029, -321.496076987398, -352.671151375484, 
-382.454393849214, -410.728263557213, -437.381176452847, -462.307945665474, 
-485.410196624968, -506.596755301209, -525.784008026318, -542.896231479612, 
-557.865891532951, -570.633909777092, -581.149896677179, -589.372350437213, 
-595.268820788687, -598.816037056963, -600, -598.816037056963, 
-595.268820788687, -589.372350437213, -581.149896677179, -570.633909777092, 
-557.865891532951, -542.896231479612, -525.784008026318, -506.596755301209, 
-485.410196624968, -462.307945665473, -437.381176452847, -410.728263557213, 
-382.454393849214, -352.671151375484, -321.496076987398, -289.052204461029, 
-255.467574939043, -220.874731610807, -185.410196624969, -149.213932298913, 
-112.428788751435, -75.1999401385822, -37.6743117175879, -1.10214571844014e-13, 
37.6743117175882, 75.1999401385825, 112.428788751435, 149.213932298913, 
185.410196624968, 220.874731610807, 255.467574939044, 289.052204461029, 
321.496076987398, 352.671151375484, 382.454393849214, 410.728263557213, 
437.381176452847, 462.307945665474, 485.410196624969, 506.596755301209, 
525.784008026318, 542.896231479612, 557.865891532951, 570.633909777092, 
581.149896677179, 589.372350437213, 595.268820788687, 598.816037056963, 
600, 598.816037056963), .Dim = c(101L, 2L), .Dimnames = list(
    NULL, c("x", "y")))

grd <- GridTopology(cellcentre.offset = c(-600, -600), cellsize = c(1, 1), cells.dim = c(1200, 1200))
obj <- kernel2d(pts = kern.obj, poly = circpol, h0 = 100, nx = 600, ny = 600, kernel='quartic')

plot(kern.obj[, "x"], kern.obj[, "y"], xlim = c(-600, 600), ylim = c(-600, 600))
image(obj, add = TRUE, col = terrain.colors(20))
-------------------------------------------------------------------------------------------------------
tikzAnnotate tikzAnnotate grid grid print gridToDevice <- function(x = 0, y = 0, units = 'native') {
  # Converts a coordinate pair from the current viewport to an "absolute
  # location" measured in device units from the lower left corner. This is done
  # by first casting to inches in the current viewport and then using the
  # current.transform() matrix to obtain inches in the device canvas.
  x <- convertX(unit(x, units), unitTo = 'inches', valueOnly = TRUE)
  y <- convertY(unit(y, units), unitTo = 'inches', valueOnly = TRUE)

  transCoords <- c(x,y,1) %*% current.transform()
  transCoords <- (transCoords / transCoords[3])

  return(
    # Finally, cast from inches to native device units
    c(
      grconvertX(transCoords[1], from = 'inches', to ='device'),
      grconvertY(transCoords[2], from = 'inches', to ='device')
    )
  )

} tikzAnnotate grid lattice require(tikzDevice)
require(grid)
options(tikzLatexPackages = c(getOption('tikzLatexPackages'),
                "\\usetikzlibrary{shapes.arrows}"))

tikz(standAlone=TRUE)

xs <- 15:20
ys <- 5:10

pushViewport(plotViewport())
pushViewport(dataViewport(xs,ys))

grobs <- gList(grid.rect(),grid.xaxis(),grid.yaxis(),grid.points(xs, ys))

coords <- gridToDevice(17, 7)
tikzAnnotate(paste('\\node[single arrow,anchor=tip,draw,fill=green,left=1em]',
  'at (', coords[1],',',coords[2],') {Look over here!};'))

dev.off() ggplot tikzDevice
-------------------------------------------------------------------------------------------------------
paris pairs pairs add points col nc <- 100
set.seed(1)
x<-rnorm(nc)
y<-rnorm(nc)
z<-rnorm(nc)
m<-cbind(x,y,z)

cols <- ifelse(x>0.7,"red","black")
pairs(m,col=cols) pairs points nc <- 100

X<-rnorm(nc)
Y<-rnorm(nc)
Z<-rnorm(nc)
m<-cbind(X,Y,Z)

panelfun <- function(x,y,foo=X,...){
    points(x[foo<0.7],y[foo<0.7],col="black",...)
    points(x[foo>0.7],y[foo>0.7],col="red",...)
}

pairs(m,panel=panelfun) ... points pairs(m,panel=panelfun,pch=16)
-------------------------------------------------------------------------------------------------------
require( xts )
require( lubridate )

## set up some example data
dataLength <- 2e6
startTime <- ymd_hms("2011-02-01-13-29-53")
fistFullOfSeconds <- 1:dataLength
date <- startTime + fistFullOfSeconds
DD1 <- rnorm( dataLength )
DD2 <- DD1 + rnorm(dataLength, 0, .1 )
DD3 <- rnorm( dataLength, 10, 2)
DD4 <- rnorm( dataLength )

myXts <- xts(matrix( c( DD1, DD2, DD3, DD4 ), ncol=4 ), date)

## now all the data are in the myXts object so let's do some
## summarizing and visualization

## grabbing just a single day from the data
## converted to data.frame to illustrate default data frame plotting
oneDay <- data.frame( myXts["2011-02-02"] ) 
plot( oneDay ) boxplot( oneDay ) ## look at the max value of each variable every minute
par(mfrow=c(4,1)) ## partitions the graph window
ep <- endpoints(myXts,'minutes')
plot(period.apply(myXts[,1],INDEX=ep,FUN=max))
plot(period.apply(myXts[,2],INDEX=ep,FUN=max))
plot(period.apply(myXts[,3],INDEX=ep,FUN=max))
plot(period.apply(myXts[,4],INDEX=ep,FUN=max))
-------------------------------------------------------------------------------------------------------
diff(scores) which(diff(scores) < 2) scores <- c(13.343, 17.998, 25.413, 27.721, 33.361, 47.263,
    52.298, 55.981, 57.851, 72.038, 72.204, 72.296, 73.472, 
    75.925, 80.748, 85.998)
spacedScores <- c(13.343, 17.998, 25.413, 27.721, 33.361, 
    47.263, 52.298, 55.981, 57.851, 67.925, 69.925, 71.925, 
    73.925, 75.925, 80.748, 85.998)

plot(scores, pch=20)
points(spacedScores, pch='x', col="red")

badPoints <- which(diff(scores) < 2)

while (length(badPoints) > 0)
  {
  scores[badPoints] <- scores[badPoints] - (2 - diff(scores)[badPoints])
  badPoints <- which(diff(scores) < 2)
  }

points(scores, pch='o', col="green")
-------------------------------------------------------------------------------------------------------
source width height X11.options(width = 8, height = 8) source x11()
plot(1:10)
points(1, 5, col='red')
dev.off() sessionInfo() R version 2.12.2 (2011-02-25)
Platform: i686-pc-linux-gnu (32-bit)

locale:
 [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
 [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
 [5] LC_MONETARY=C              LC_MESSAGES=en_US.UTF-8   
 [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
 [9] LC_ADDRESS=C               LC_TELEPHONE=C            
[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base
-------------------------------------------------------------------------------------------------------
mgcv sp::overlay in.out() library(mgcv)
data(columb.polys)
bnd <- columb.polys[[2]]
plot(bnd,type="n")
polygon(bnd)
x <- seq(7.9,8.7,length=20)
y <- seq(13.7,14.3,length=20)
gr <- as.matrix(expand.grid(x,y))
inside <- in.out(bnd,gr)
points(gr,pch=as.numeric(inside)+1)
-------------------------------------------------------------------------------------------------------
plot.window() plot.new() xlim <- c(-30,30)
ylim <- c(-5,5)
plot.new()
plot.window( xlim , ylim )
points(1,1)
points(0,0) new() window()
-------------------------------------------------------------------------------------------------------
border legend.v2('bottomright', 
        c("no box, no point","no box, no point",estNames) , 
        lty=c(rep('dotted',2),rep('solid',3)), 
        col=c('black','red',1,2,4),
        pch=c(-1,-1,rep(16,3)),
        lwd=1,
        border = c("white", "white", "black", "black", "black"),
        trace = TRUE,
        fill=c( 0, 0,
                rep( c( rgb(0.5,0.5,0.1,0.25),
                                rgb(0.5,0.1,0.1,0.25),
                                rgb(0.1,0.1,0.5,0.25)), 2)),
        inset=0,bg='white') ?rect xbox if (mfill) legend.v2 <- function (x, y = NULL, legend, fill = NULL, col = par("col"), 
        border = "black", lty, lwd, pch, angle = 45, density = NULL, 
        bty = "o", bg = par("bg"), box.lwd = par("lwd"), box.lty = par("lty"), 
        box.col = par("fg"), pt.bg = NA, cex = 1, pt.cex = cex, pt.lwd = lwd, 
        xjust = 0, yjust = 1, x.intersp = 1, y.intersp = 1, adj = c(0, 
                0.5), text.width = NULL, text.col = par("col"), merge = do.lines && 
                has.pch, trace = FALSE, plot = TRUE, ncol = 1, horiz = FALSE, 
        title = NULL, inset = 0, xpd, title.col = text.col, title.adj = 0.5, 
        seg.len = 2) 
{
    if (missing(legend) && !missing(y) && (is.character(y) || 
                is.expression(y))) {
        legend <- y
        y <- NULL
    }
    mfill <- !missing(fill) || !missing(density)
    if (!missing(xpd)) {
        op <- par("xpd")
        on.exit(par(xpd = op))
        par(xpd = xpd)
    }
    title <- as.graphicsAnnot(title)
    if (length(title) > 1) 
        stop("invalid title")
    legend <- as.graphicsAnnot(legend)
    n.leg <- if (is.call(legend)) 
                1
            else length(legend)
    if (n.leg == 0) 
        stop("'legend' is of length 0")
    auto <- if (is.character(x)) 
                match.arg(x, c("bottomright", "bottom", "bottomleft", 
                                "left", "topleft", "top", "topright", "right", "center"))
            else NA
    if (is.na(auto)) {
        xy <- xy.coords(x, y)
        x <- xy$x
        y <- xy$y
        nx <- length(x)
        if (nx < 1 || nx > 2) 
            stop("invalid coordinate lengths")
    }
    else nx <- 0
    xlog <- par("xlog")
    ylog <- par("ylog")
    rect2 <- function(left, top, dx, dy, density = NULL, angle, 
            ...) {
        r <- left + dx
        if (xlog) {
            left <- 10^left
            r <- 10^r
        }
        b <- top - dy
        if (ylog) {
            top <- 10^top
            b <- 10^b
        }
        rect(left, top, r, b, angle = angle, density = density, 
                ...)
    }
    segments2 <- function(x1, y1, dx, dy, ...) {
        x2 <- x1 + dx
        if (xlog) {
            x1 <- 10^x1
            x2 <- 10^x2
        }
        y2 <- y1 + dy
        if (ylog) {
            y1 <- 10^y1
            y2 <- 10^y2
        }
        segments(x1, y1, x2, y2, ...)
    }
    points2 <- function(x, y, ...) {
        if (xlog) 
            x <- 10^x
        if (ylog) 
            y <- 10^y
        points(x, y, ...)
    }
    text2 <- function(x, y, ...) {
        if (xlog) 
            x <- 10^x
        if (ylog) 
            y <- 10^y
        text(x, y, ...)
    }
    if (trace) 
        catn <- function(...) do.call("cat", c(lapply(list(...), 
                                    formatC), list("\n")))
    cin <- par("cin")
    Cex <- cex * par("cex")
    if (is.null(text.width)) 
        text.width <- max(abs(strwidth(legend, units = "user", 
                                cex = cex)))
    else if (!is.numeric(text.width) || text.width < 0) 
        stop("'text.width' must be numeric, >= 0")
    xc <- Cex * xinch(cin[1L], warn.log = FALSE)
    yc <- Cex * yinch(cin[2L], warn.log = FALSE)
    if (xc < 0) 
        text.width <- -text.width
    xchar <- xc
    xextra <- 0
    yextra <- yc * (y.intersp - 1)
    ymax <- yc * max(1, strheight(legend, units = "user", cex = cex)/yc)
    ychar <- yextra + ymax
    if (trace) 
        catn("  xchar=", xchar, "; (yextra,ychar)=", c(yextra, 
                        ychar))
    if (mfill) {
        xbox <- xc * 0.8
        ybox <- yc * 0.5
        dx.fill <- xbox
    }
    do.lines <- (!missing(lty) && (is.character(lty) || any(lty > 
                                    0))) || !missing(lwd)
    n.legpercol <- if (horiz) {
                if (ncol != 1) 
                    warning("horizontal specification overrides: Number of columns := ", 
                            n.leg)
                ncol <- n.leg
                1
            }
            else ceiling(n.leg/ncol)
    has.pch <- !missing(pch) && length(pch) > 0
    if (do.lines) {
        x.off <- if (merge) 
                    -0.7
                else 0
    }
    else if (merge) 
        warning("'merge = TRUE' has no effect when no line segments are drawn")
    if (has.pch) {
        if (is.character(pch) && !is.na(pch[1L]) && nchar(pch[1L], 
                type = "c") > 1) {
            if (length(pch) > 1) 
                warning("not using pch[2..] since pch[1L] has multiple chars")
            np <- nchar(pch[1L], type = "c")
            pch <- substr(rep.int(pch[1L], np), 1L:np, 1L:np)
        }
    }
    if (is.na(auto)) {
        if (xlog) 
            x <- log10(x)
        if (ylog) 
            y <- log10(y)
    }
    if (nx == 2) {
        x <- sort(x)
        y <- sort(y)
        left <- x[1L]
        top <- y[2L]
        w <- diff(x)
        h <- diff(y)
        w0 <- w/ncol
        x <- mean(x)
        y <- mean(y)
        if (missing(xjust)) 
            xjust <- 0.5
        if (missing(yjust)) 
            yjust <- 0.5
    }
    else {
        h <- (n.legpercol + (!is.null(title))) * ychar + yc
        w0 <- text.width + (x.intersp + 1) * xchar
        if (mfill) 
            w0 <- w0 + dx.fill
        if (do.lines) 
            w0 <- w0 + (seg.len + +x.off) * xchar
        w <- ncol * w0 + 0.5 * xchar
        if (!is.null(title) && (abs(tw <- strwidth(title, units = "user", 
                                    cex = cex) + 0.5 * xchar)) > abs(w)) {
            xextra <- (tw - w)/2
            w <- tw
        }
        if (is.na(auto)) {
            left <- x - xjust * w
            top <- y + (1 - yjust) * h
        }
        else {
            usr <- par("usr")
            inset <- rep(inset, length.out = 2)
            insetx <- inset[1L] * (usr[2L] - usr[1L])
            left <- switch(auto, bottomright = , topright = , 
                    right = usr[2L] - w - insetx, bottomleft = , 
                    left = , topleft = usr[1L] + insetx, bottom = , 
                    top = , center = (usr[1L] + usr[2L] - w)/2)
            insety <- inset[2L] * (usr[4L] - usr[3L])
            top <- switch(auto, bottomright = , bottom = , bottomleft = usr[3L] + 
                            h + insety, topleft = , top = , topright = usr[4L] - 
                            insety, left = , right = , center = (usr[3L] + 
                                usr[4L] + h)/2)
        }
    }
    if (plot && bty != "n") {
        if (trace) 
            catn("  rect2(", left, ",", top, ", w=", w, ", h=", 
                    h, ", ...)", sep = "")
        rect2(left, top, dx = w, dy = h, col = bg, density = NULL, 
                lwd = box.lwd, lty = box.lty, border = box.col)
    }
    xt <- left + xchar + xextra + (w0 * rep.int(0:(ncol - 1), 
                rep.int(n.legpercol, ncol)))[1L:n.leg]
    yt <- top - 0.5 * yextra - ymax - (rep.int(1L:n.legpercol, 
                        ncol)[1L:n.leg] - 1 + (!is.null(title))) * ychar
    if (mfill) {
        if (plot) {
            fill <- rep(fill, length.out = n.leg)
            rect2(left = xt, top = yt + ybox/2, dx = xbox * 3, dy = ybox, 
                    col = fill, density = density, angle = angle, 
                    border = border)
        }
        xt <- xt + dx.fill
    }
    if (plot && (has.pch || do.lines)) 
        col <- rep(col, length.out = n.leg)
    if (missing(lwd)) 
        lwd <- par("lwd")
    if (do.lines) {
        if (missing(lty)) 
            lty <- 1
        lty <- rep(lty, length.out = n.leg)
        lwd <- rep(lwd, length.out = n.leg)
        ok.l <- !is.na(lty) & (is.character(lty) | lty > 0)
        if (trace) 
            catn("  segments2(", xt[ok.l] + x.off * xchar, ",", 
                    yt[ok.l], ", dx=", seg.len * xchar, ", dy=0, ...)")
        if (plot) 
            segments2(xt[ok.l] + x.off * xchar, yt[ok.l], dx = seg.len * 
                            xchar, dy = 0, lty = lty[ok.l], lwd = lwd[ok.l], 
                    col = col[ok.l])
        xt <- xt + (seg.len + x.off) * xchar
    }
    if (has.pch) {
        pch <- rep(pch, length.out = n.leg)
        pt.bg <- rep(pt.bg, length.out = n.leg)
        pt.cex <- rep(pt.cex, length.out = n.leg)
        pt.lwd <- rep(pt.lwd, length.out = n.leg)
        ok <- !is.na(pch) & (is.character(pch) | pch >= 0)
        x1 <- (if (merge && do.lines) 
                xt - (seg.len/2) * xchar
            else xt)[ok]
        y1 <- yt[ok]
        if (trace) 
            catn("  points2(", x1, ",", y1, ", pch=", pch[ok], 
                    ", ...)")
        if (plot) 
            points2(x1, y1, pch = pch[ok], col = col[ok], cex = pt.cex[ok], 
                    bg = pt.bg[ok], lwd = pt.lwd[ok])
    }
    xt <- xt + x.intersp * xchar
    if (plot) {
        if (!is.null(title)) 
            text2(left + w * title.adj, top - ymax, labels = title, 
                    adj = c(title.adj, 0), cex = cex, col = title.col)
        text2(xt, yt, labels = legend, adj = adj, cex = cex, 
                col = text.col)
    }
    invisible(list(rect = list(w = w, h = h, left = left, top = top), 
                    text = list(x = xt, y = yt)))
}
-------------------------------------------------------------------------------------------------------
set.seed(1)
baseball <- data.frame(pitchNumber = seq_len(50),
                       outcome = factor(sample(c("B","H","S","S","X","H"), 
                                               50, replace = TRUE)))
> head(baseball)
  pitchNumber outcome
1           1       H
2           2       S
3           3       S
4           4       H
5           5       H
6           6       H ## better colours - like ggplot for the cool kids
##cols <- c("red","green","blue","yellow")
cols <- head(hcl(seq(from = 0, to = 360,
                    length.out = nlevels(with(baseball, outcome)) + 1), 
                 l = 65, c = 100), -1) pitchNumber type = "h" with(baseball, plot(pitchNumber, y = rep(1, length(pitchNumber)), type = "h", 
                    ylim = c(0, 1.2), col = cols[outcome],
                    ylab = "", xlab = "Pitch", axes = FALSE, lwd = 2))
with(baseball, points(pitchNumber, y = rep(1, length(pitchNumber)), pch = 16, 
                      col = cols[outcome])) axis(side = 1)
box()
## note: this assumes that the levels are in alphabetical order B,H,S,X...
legend("topleft", legend = c("Ball","Hit","Swinging Strike","X??"), lty = 1,
       pch = 16, col = cols, bty = "n", ncol = 2, lwd = 2)
-------------------------------------------------------------------------------------------------------
Spatial spatstat maptools library(spatstat)
library(sp)
library(maptools)
data(bei) bei Spatial ppp spPoints <- as(bei, "SpatialPoints") dummyData <- data.frame(dummy = rep(0, npoints(bei))) SpatialPoints SpatialPointsDataFrame spDF <- SpatialPointsDataFrame(spPoints, dummyData) bei WKT CRS Spatial SpatialPointsDataFrame proj4string(spDF) <- CRS("+proj=etc...") rgdal library(rgdal) writePolyShape maptools rgdal writeOGR(obj = spDF, dsn = ".", layer = "bei", driver = "ESRI Shapefile") unlink("bei.shp") list.files(pattern = "^bei")

[1] "bei.dbf" "bei.shp" "bei.shx" ppp
-------------------------------------------------------------------------------------------------------
RasterLayer ## gives an error, but still plots 
raster:::.imageplot(shrunk)
points(shrunk.coords, pch = ".") .imageplot showMethods("plot", classes = "RasterLayer", includeDefs = TRUE) raster:::.plotraster raster:::.imageplot raster:::.plotraster(shrunk, col = rev(terrain.colors(255)), maxpixels = 5e+05)
points(shrunk.coords, pch = ".") raster:::.imageplot(shrunk)
 abline(h = c(-80, 80), v = c(-80, 80)) plot(shrunk)
abline(h = c(-80, 80), v = c(-80, 80)) par() raster:::.imageplot plot(shrunk)
axis(1, pos = 1)
-------------------------------------------------------------------------------------------------------
set.seed(5)
d <- data.frame(x=c(rnorm(1000)+3, rnorm(1000)),
                g=rep(1:2, each=1000) ) x1 <- d$x[d$g==1]
x2 <- d$x[d$g==2]
y1 <- hist(x1, plot=FALSE)
y2 <- hist(x2, plot=FALSE)
plot(y1$breaks, c(y1$counts,0), type="s",col="blue",
     xlim=range(c(y1$breaks, y2$breaks)), ylim=range(c(0,y1$counts, y2$counts)))
points(y2$breaks, c(y2$counts,0), type="s", col="red") col <- c("blue", "red")
ds <- split(d$x, d$g)
hs <- lapply(ds, hist, plot=FALSE)
plot(0,0,type="n",
     ylim=range(c(0,unlist(lapply(hs, function(x) x$counts)))),
     xlim=range(unlist(lapply(hs, function(x) x$breaks))) )
for(i in seq_along(hs)) {
  points(hs[[i]]$breaks, c(hs[[i]]$counts,0), type="s", col=col[i])
} library(lattice)
densityplot(~x, group=g, data=d)
-------------------------------------------------------------------------------------------------------
plot points lines dat1 <- data.frame(Time = c(1.023, 2.564, 3.678, 5.023), Value = c(5.786, 10.675, 14.678, 17.456))
dat2 <- data.frame(Time = c(0.787, 1.567, 3.011, 4.598), Value = c(1.765, 3.456, 5.879, 7.768))
dat3 <- data.frame(Time = c(1.208, 2.478, 3.823, 5.125), Value = c(3.780, 6.890, 9.091, 12.769))

with(dat1, plot(Time, Value, xlim = c(0,6), ylim = c(0,20)))
with(dat2, points(Time, Value, col = "red"))
with(dat3, points(Time, Value, col = "green")) ?legend ggplot2 library(ggplot2)
library(reshape)
plotdata <- melt(list(dat1 = dat1, dat2 = dat2, dat3 = dat3), "Time")

qplot(Time, value, data = plotdata, colour = L1)
-------------------------------------------------------------------------------------------------------
points() plot() plot(1:10)
points(10:1,col="red") rgb() x <- rnorm(100)
y <- 0.5*x + rnorm(100)
z <- 0.5*y + rnorm(100)

dum <- (z - min(z)) / (max(z) - min(z))

plot(x,y,col=rgb(1-dum*0.4,1-dum*0.8,1-dum*0.8),pch=16) z min(z) max(z)
-------------------------------------------------------------------------------------------------------
rrp.impute install.packages("rrp")
require(rrp)
set.seed(1)
key <- 1:100
## create random values
value1 <- 10 + 2 * key + rnorm(100, 0, 10)
## make 5 values into NAs
missing <- sample( key, 5)
value1[missing] <- NA
## build a dataframe
df <- data.frame(key, value1)
## do a nearest neighbor hot deck interpolation
imputed <- rrp.impute( df )$new.data

## let's visualize this magic
plot( df)
points(missing, imputed$value1[missing], col="red")
-------------------------------------------------------------------------------------------------------
daten_fit <- lm(formula = y~x, data = daten[3:5, ])

plot(y ~ x, data = daten)
points(y ~ x, data = daten[3:5, ], col="red")
abline(reg=daten_fit, col="red") rug range #points(y ~ x, data = daten[3:5, ], col="red")
abline(reg=daten_fit, col="red")
rug(range(daten[3:5, 1]), lwd=3, col="red")
-------------------------------------------------------------------------------------------------------
x = sort( rnorm(20) )
y = 1:20
plot(x, y, main = 'function interpolation example' )
points(approx(x, y), col = 2, pch = 3 ) points( approx( x, y, xout = seq( from = min(x), to = max(x), by = 0.1 ) ), pch = 3, col = 3 ) points( approx( x, y, xout = seq( from = min(x), to = max(x), by = 0.05 ) ), pch = 3, col = 4 ) x_interp = unique( sort( c(seq( from = 0, to = 100, by = 5 ), seq( from = 0, to = 100, by = 3 ) ) ) )
x_interp
 [1]   0   3   5   6   9  10  12  15  18  20  21  24  25  27  30  33  35
[18]  36  39  40  42  45  48  50  51  54  55  57  60  63  65  66  69  70
[35]  72  75  78  80  81  84  85  87  90  93  95  96  99 100 par( mfrow = c(1,2) )
plot( x_light, y_light )
points(approx(x_light, y_light, x_out = x_interp), col = 2, pch = 3 )

plot( x_flux, y_flux )
points(approx(x_flux, y_flux, x_out = x_interp), col = 3, pch = 3 )
-------------------------------------------------------------------------------------------------------
coefplot2 <-  # the rest of the pasted function should follow voffset=0 arrows(ci1, (1:k), ci2, (1:k), lty = lty[1], lwd = lwd[1], col = col, arrows(ci1, (1:k)+voffset, ci2, (1:k)+voffset, lty = lty[1], lwd = lwd[1], col = col, points(cf , (1:k)+voffset, pch = pch, col = col) coefplot2(M2, xlim=c(-2, 6) )
par(new=TRUE)    # could not get the add=TRUE argument to work either.
coefplot2(M3, col="blue", xlim=c(-2, 6), voffset=0.4)
par(new=TRUE)
coefplot2(M1, col="red", xlim=c(-2, 6) , voffset=0.2)
-------------------------------------------------------------------------------------------------------
with(bruth, plot(p, predict(mod), type="l" )  )
 with(bruth, points(p, g,  col="red") )
 with(bruth, lines(p, predict(mod2), lty=3, lwd=2, col="red") )
 title(main="Different uses of I() and interaction")
-------------------------------------------------------------------------------------------------------
dfr <- data.frame(x = sample(100, 10, replace = TRUE), y = runif(10))
with(dfr, plot(x, y)) points(dfr$x, rep.int(0.5, 10), col = "blue")
-------------------------------------------------------------------------------------------------------
model.lm <- lm(y ~ x, data = known)

# Use predict to estimate the values for aim.
# Note that predict expects a data.frame and the col 
# names need to match
newY <- predict(model.lm, newdata = data.frame(x = aim))

#Add the predicted points to the original plot
points(aim, newY, col = "red") > cbind(aim, newY)
  aim       newY
1 0.3  2.4500000
2 0.7  6.1928571
3 2.3 21.1642857
....
-------------------------------------------------------------------------------------------------------
A A <- structure(c("A", "A", "B", "C", "D", "A", "1", "2", "3", "4", 
"2", "7"), .Dim = c(6L, 2L), .Dimnames = list(NULL, c("Observed_Letter", 
"Speed")), index = structure(c(1294769521.1, 1294769521.2, 1294769521.4, 
1294769521.8, 1294769522.2, 1294769522.2), tzone = "", tclass = c("POSIXct", 
"POSIXt")), .indexCLASS = c("POSIXct", "POSIXt"), .indexTZ = "",
class = c("xts", "zoo")) clean <- function(x) {
  # construct xts object with only Speed and convert it to numeric
  out <- xts(as.numeric(x$Speed),index(x))
  # add column names
  colnames(out) <- paste(x$Observed_Letter[1],"_Per_Second",sep="")
  out  # return object
} split.default split align.time # split by Observed_Letter, apply clean() to each list element, and merge results
combA <- do.call(merge, lapply(split.default(A, A$Observed_Letter), clean))
alignA <- align.time(combA,1)
# get the last obs for each 1-second period (for period.apply)
EPalignA <- endpoints(combA, "seconds")
# count the number of non-NA observations by column for each 1-second period
counts <- period.apply(alignA, EPalignA, function(x) colSums(!is.na(x)))
# sum the non-NA observations for each column and 1-second period
values <- period.apply(alignA, EPalignA, colSums, na.rm=TRUE)
# calculate aggregate speed
B <- counts
B$Aggregate_Speed <- rowSums(values)/rowSums(counts)
-------------------------------------------------------------------------------------------------------
y1 <- c(100, 200, 300, 400, 500)
y2 <- c(1, 2, 3, 4, 5)
x <- c(1, 2, 3, 4, 5)

# first plot
plot(x, y1,ylim = range(c(y1,y2)))

# Add points
points(x, y2) plot points ylim
-------------------------------------------------------------------------------------------------------
data <- matrix(rnorm(400), ncol=4) index <- rep(1:25, 4)
index <- index[order(index)] aggregate() aggregate(x=data, by = list(index), FUN=sum) require(xts)
test.xts <- xts(test.data$observation, order.by=test.data$time)
period.apply(test.xts, endpoints(test.xts,"minutes", 30), sum)
-------------------------------------------------------------------------------------------------------
arrowLine <- function(x, y, N=10, ...){
  lengths <- c(0, sqrt(diff(x)^2 + diff(y)^2))
  l <- cumsum(lengths)
  tl <- l[length(l)]
  el <- seq(0, to=tl, length=N+1)[-1]

  plot(x, y, t="l", ...)

  for(ii in el){

    int <- findInterval(ii, l)
    xx <- x[int:(int+1)]
    yy <- y[int:(int+1)]

    ## points(xx,yy, col="grey", cex=0.5)

    dx <- diff(xx)
    dy <- diff(yy)
    new.length <- ii - l[int]
    segment.length <- lengths[int+1]

    ratio <- new.length / segment.length

    xend <- x[int] + ratio * dx
    yend <- y[int] + ratio * dy
    points(xend,yend, col="white", pch=19)
    arrows(x[int], y[int], xend, yend, length=0.1)

}

}

set.seed(123)
x = sort(c(0, runif(200, 0,2* pi), 2*pi))
y=sin(x)

arrowLine(x, y, N=20)
-------------------------------------------------------------------------------------------------------
panel.tuftebxp <- 
function (x, y, box.ratio = 1, box.width = box.ratio/(1 + box.ratio), horizontal=FALSE,
    pch = box.dot$pch, col = box.dot$col, 
    alpha = box.dot$alpha, cex = box.dot$cex, font = box.dot$font, 
    fontfamily = box.dot$fontfamily, fontface = box.dot$fontface, 
    fill = box.rectangle$fill, varwidth = FALSE, notch = FALSE, 
    notch.frac = 0.5, ..., levels.fos = if (horizontal) sort(unique(y)) else sort(unique(x)), 
    stats = boxplot.stats, coef = 1.5, do.out = TRUE, identifier = "bwplot") 
{
    if (all(is.na(x) | is.na(y))) 
        return()
    x <- as.numeric(x)
    y <- as.numeric(y)
    box.dot <- trellis.par.get("box.dot")
    box.rectangle <- trellis.par.get("box.rectangle")
    box.umbrella <- trellis.par.get("box.umbrella")
    plot.symbol <- trellis.par.get("plot.symbol")
    fontsize.points <- trellis.par.get("fontsize")$points
    cur.limits <- current.panel.limits()
    xscale <- cur.limits$xlim
    yscale <- cur.limits$ylim
    if (!notch) 
        notch.frac <- 0
    #removed horizontal code
     blist <- tapply(y, factor(x, levels = levels.fos), stats, 
            coef = coef, do.out = do.out)
        blist.stats <- t(sapply(blist, "[[", "stats"))
        blist.out <- lapply(blist, "[[", "out")
        blist.height <- box.width
        if (varwidth) {
            maxn <- max(table(x))
            blist.n <- sapply(blist, "[[", "n")
            blist.height <- sqrt(blist.n/maxn) * blist.height
        }
        blist.conf <- if (notch) 
            sapply(blist, "[[", "conf")
        else t(blist.stats[, c(2, 4), drop = FALSE])
        ybnd <- cbind(blist.stats[, 3], blist.conf[2, ], blist.stats[, 
            4], blist.stats[, 4], blist.conf[2, ], blist.stats[, 
            3], blist.conf[1, ], blist.stats[, 2], blist.stats[, 
            2], blist.conf[1, ], blist.stats[, 3])
        xleft <- levels.fos - blist.height/2
        xright <- levels.fos + blist.height/2
        xbnd <- cbind(xleft + notch.frac * blist.height/2, xleft, 
            xleft, xright, xright, xright - notch.frac * blist.height/2, 
            xright, xright, xleft, xleft, xleft + notch.frac * 
                blist.height/2)
        xs <- cbind(xbnd, NA_real_)
        ys <- cbind(ybnd, NA_real_)
        panel.segments(rep(levels.fos, 2), c(blist.stats[, 2], 
            blist.stats[, 4]), rep(levels.fos, 2), c(blist.stats[, 
            1], blist.stats[, 5]), col = box.umbrella$col, alpha = box.umbrella$alpha, 
            lwd = box.umbrella$lwd, lty = box.umbrella$lty, identifier = paste(identifier, 
                "whisker", sep = "."))

        if (all(pch == "|")) {
            mult <- if (notch) 
                1 - notch.frac
            else 1
            panel.segments(levels.fos - mult * blist.height/2, 
                blist.stats[, 3], levels.fos + mult * blist.height/2, 
                blist.stats[, 3], lwd = box.rectangle$lwd, lty = box.rectangle$lty, 
                col = box.rectangle$col, alpha = alpha, identifier = paste(identifier, 
                  "dot", sep = "."))
        }
        else {
            panel(x = levels.fos, y = blist.stats[, 3], 
                pch = pch, col = col, alpha = alpha, cex = cex, 
                 identifier = paste(identifier, 
                  "dot", sep = "."))
        }
        panel(x = rep(levels.fos, sapply(blist.out, length)), 
            y = unlist(blist.out), pch = plot.symbol$pch, col = plot.symbol$col, 
            alpha = plot.symbol$alpha, cex = plot.symbol$cex*0.5, 
            identifier = paste(identifier, "outlier", sep = "."))

}
bwplot(weight ~ Diet + Time + Chick, data=cw, panel= 
         function(x,y, ...) panel.tuftebxp(x=x,y=y,...))
-------------------------------------------------------------------------------------------------------
curly <- function(N = 100, Tilt = 1, Long = 2, scale = 0.1, xcent = 0.5,
                  ycent = 0.5, theta = 0, col = 1, lwd = 1, grid = FALSE){

# N determines how many points in each curve
# Tilt is the ratio between the axis in the ellipse 
#  defining the curliness of each curve
# Long is the length of the straight line in the curly brackets 
#  in units of the projection of the curly brackets in this dimension
# 2*scale is the absolute size of the projection of the curly brackets 
#  in the y dimension (when theta=0)
# xcent is the location center of the x axis of the curly brackets
# ycent is the location center of the y axis of the curly brackets
# theta is the angle (in radians) of the curly brackets orientation
# col and lwd are passed to points/grid.lines

           ymin <- scale / Tilt
           y2 <- ymin * Long
           i <- seq(0, pi/2, length.out = N)

           x <- c(ymin * Tilt * (sin(i)-1),
                  seq(0,0, length.out = 2),
                  ymin * (Tilt * (1 - sin(rev(i)))),
                  ymin * (Tilt * (1 - sin(i))),
                  seq(0,0, length.out = 2),
                  ymin * Tilt * (sin(rev(i)) - 1))

           y <- c(-cos(i) * ymin,
                  c(0,y2),
                  y2 + (cos(rev(i))) * ymin,
                  y2 + (2 - cos(i)) * ymin,
                  c(y2 + 2 * ymin, 2 * y2 + 2 * ymin),
                  2 * y2 + 2 * ymin + cos(rev(i)) * ymin)

           x <- x + xcent
           y <- y + ycent - ymin - y2

           x1 <- cos(theta) * (x - xcent) - sin(theta) * (y - ycent) + xcent
           y1 <- cos(theta) * (y - ycent) + sin(theta) * (x - xcent) + ycent

           ##For grid library:
           if(grid){
              grid.lines(unit(x1,"npc"), unit(y1,"npc"),gp=gpar(col=col,lwd=lwd))
           }

           ##Uncomment for base graphics
           else{
              par(xpd=TRUE)
              points(x1,y1,type='l',col=col,lwd=lwd)
              par(xpd=FALSE)
           }

}


library(ggplot2)
x <- c(runif(10),runif(10)+2)
y <- c(runif(10),runif(10)+2)
qplot(x=x,y=y) +
  scale_x_continuous("",breaks=c(.5,2.5),labels=c("Low types","High types") )

curly(N=100,Tilt=0.4,Long=0.3,scale=0.025,xcent=0.2525,
      ycent=par()$usr[3]+0.1,theta=-pi/2,col="red",lwd=2,grid=TRUE)
curly(N=100,Tilt=0.4,Long=0.3,scale=0.025,xcent=0.8,
      ycent=par()$usr[3]+0.1,theta=-pi/2,col="red",lwd=2,grid=TRUE)
-------------------------------------------------------------------------------------------------------
points() type plot(your.data, type = "n") points
-------------------------------------------------------------------------------------------------------
npregression npplot() mfrow data(Italy)
bw <- npregbw(formula=gdp~ordered(year), data = Italy)
model <- npreg(bws = bw, gradients = TRUE)
par(mfrow = c(2, 2))
plot(model)
points(ordered(Italy$year), Italy$gdp, cex=.2, col="red")
plot(1:10)
plot(1:5)
plot(1) data(cps71)
model.par <- lm(logwage ~ age + I(age^2), data = cps71)
model.np <- npreg(logwage ~ age,
                  regtype = "ll",
                  bwmethod = "cv.aic",
                  gradients = TRUE,
                  data = cps71)
par(mfrow=c(2,2))

plot(cps71$age,cps71$logwage,xlab="age",ylab="log(wage)",cex=.1)
lines(cps71$age,fitted(model.np),lty=1,col="blue")
lines(cps71$age,fitted(model.par),lty=2,col="red")

plot(cps71$age,gradients(model.np),xlab="age",ylab="gradient",type="l",lty=1,col="blue")
lines(cps71$age,coef(model.par)[2]+2*cps71$age*coef(model.par)[3],lty=2,col="red")

plot(cps71$age,fitted(model.np),xlab="age",ylab="log(wage)",ylim=c(min(fitted(model.np)-2*model.np$merr),max(fitted(model.np)+2*model.np$merr)),type="l")
lines(cps71$age,fitted(model.np)+2*model.np$merr,lty=2,col="red")
lines(cps71$age,fitted(model.np)-2*model.np$merr,lty=2,col="red")

plot(cps71$age,gradients(model.np),xlab="age",ylab="gradient",ylim=c(min(gradients(model.np)-2*model.np$gerr),max(gradients(model.np)+2*model.np$gerr)),type="l",lty=1,col="blue")
lines(cps71$age,gradients(model.np)+2*model.np$gerr,lty=2,col="red")
lines(cps71$age,gradients(model.np)-2*model.np$gerr,lty=2,col="red")
-------------------------------------------------------------------------------------------------------
dataEllipse ellipse dataEllipse
function(x,y, ....
...
else {
        shape <- var(cbind(x, y))
        center <- c(mean(x), mean(y))
    }
    for (level in levels) {
        radius <- sqrt(dfn * qf(level, dfn, dfd) ellipse
function (center, shape, radius, ....)
....
 angles <- (0:segments) * 2 * pi/segments
    unit.circle <- cbind(cos(angles), sin(angles))
    ellipse <- t(center + radius * t(unit.circle %*% chol(shape)))
    colnames(ellipse) <- c("x", "y") getEparams <-function(x,y, level) { dfn <- 2
        dfd <- length(x) - 1
        shape <- var(cbind(x, y))
        center <- c(mean(x), mean(y))
        radius <- sqrt(dfn * qf(level, dfn, dfd))
        return(list(center=center, shape=shape, radius=radius) ) }

ellcalc <- function (center, shape, radius, segments=51){segments=segments
    angles <- (0:segments) * 2 * pi/segments
    unit.circle <- cbind(cos(angles), sin(angles))
    ellipse <- t(center + radius * t(unit.circle %*% chol(shape)))
    colnames(ellipse) <- c("x", "y")
    return(ellipse)}

evals <- getEparams(Query$X, Query$Y, 0.80)
plot(ellcalc(evals[["center"]], evals[["shape"]], evals[["radius"]]))
title(main='Output of plot(ellcalc(evals[["center"]], evals[["shape"]], 
                           evals[["radius"]]))\nStackOverflow Demonstration')
 points(Query$X, Query$Y, cex=0.3, col="red") ellcalc
-------------------------------------------------------------------------------------------------------
# First two models
df1 <- data.frame(x=1:50, y=1:50/2+rnorm(50)+10)
m1 <- lm(y~x, df1)

df2 <- data.frame(x=1:25, y=25:1*2+rnorm(25)-10)
m2 <- lm(y~x, df2)

# Plot them to show the intersection visually    
plot(df1)
points(df2)

# Now calculate it!    
a <- coef(m1)-coef(m2)
c(x=-a[[1]]/a[[2]], y=coef(m1)[[2]]*x + coef(m1)[[1]]) solve cm <- rbind(coef(m1),coef(m2)) # Coefficient matrix
c(-solve(cbind(cm[,2],-1)) %*% cm[,1])
# [1] 12.68034 16.57181
-------------------------------------------------------------------------------------------------------
# input data

x1 <- c(1,2); y1 <- c(10,10); x2 <- c(3,4,5);  y2 <- c(20,30,40) 
x  <- c(x1, x2); y <- c(y1, y2)

# segmented regression

library(segmented)
fm <- segmented.lm(lm(y ~ x), ~ x, NA, seg.control(stop.if.error = FALSE, K = 2))
summary(fm)

# plot

plot(fm)
points(y ~ x) ?lm ?segmented.lm ?seg.control
-------------------------------------------------------------------------------------------------------
cex points(x = x0, y = y0, col = "green", pch = 16, cex = 10) ?par pch pch = 1 example("points")
-------------------------------------------------------------------------------------------------------
plot(df)
rect(par("usr")[1],par("usr")[3],par("usr")[2],par("usr")[4],col = "gray")
points(df) barplot add
-------------------------------------------------------------------------------------------------------
plot() type = "n" abline() grid() points() x <- seq(0, 10)
y <- x
plot(x, y, type = "n")
abline(h = seq(0, 10, .5), col = 'lightgray', lty = 3)
abline(v = seq(0, 10, .5), col = 'lightgray', lty = 3)
points(x, y, col = 'red', type = 'o', lwd = 3, pch = 15) ## using `grid()`
plot(x, y, type = "n")
grid()
points(x, y, col = 'red', type = 'o', lwd = 3, pch = 15) ?grid abline()
-------------------------------------------------------------------------------------------------------
quantmod::getSymbols xts big.red.dot xts big.red.dot <- xts(85, as.Date("2011-05-05"))
plot(SAM['2011'])
points(  big.red.dot, col="red", pch=19, cex=5  )
-------------------------------------------------------------------------------------------------------
?legend #Construct some data and start the plot
x <- 0:64/64
y <- sin(3*pi*x)
plot(x, y, type="l", col="blue")
points(x, y, pch=21, bg="white")

#Grab the plotting region dimensions
rng <- par("usr")

#Call your legend with plot = FALSE to get its dimensions
lg <- legend(rng[1],rng[2], "sin(c x)", pch=21, 
            pt.bg="white", lty=1, col = "blue",plot = FALSE)

#Once you have the dimensions in lg, use them to adjust
# the legend position
#Note the use of xpd = NA to allow plotting outside plotting region             
legend(rng[1],rng[4] + lg$rect$h, "sin(c x)", pch=21, 
            pt.bg="white", lty=1, col = "blue",plot = TRUE, xpd = NA)
-------------------------------------------------------------------------------------------------------
body(for)<- as.call(c(as.name('{'),expression([your_updatebar], body(for)))) " ( i in seq(1,101,5) )" y[i]<- foo[i]^2 ;
 points(foo[i],y[i] forp<-function(indexer,loopbody) { pseudoparse( c("for (", indexer, ") {" ,loopbody,"}") }
-------------------------------------------------------------------------------------------------------
high recentHigh daysSince data daysSinceHigh <- function(data, days){
  highs <- days-1+which(apply(embed(data, days), 1, which.max)==1)
  recentHigh <- max(highs)
  daysSince <- nrow(data) - recentHigh
  list(
    highs=highs,
    recentHigh = recentHigh,
    daysSince = daysSince,
    data=data[highs, ])
} daysSinceHigh(Data, 200)$daysSince
[1] 90

plot(Data)
points(daysSinceHigh(Data, 200)$data, col="red")
-------------------------------------------------------------------------------------------------------
dotchart dat <- c(0.2,0.8,0.95)
names(dat) <- c("apples","bananas","tomatoes")
plot(c(1,1),range(dat),type="l",col="lightgrey",xlab="",xaxt="n")
points(rep(1,length(dat)),dat)
text(1,dat,names(dat),pos=4)
-------------------------------------------------------------------------------------------------------
set.seed(1)
t1 = rnorm(10); t2 = rnorm(10, 2)
t1_g2 = rnorm(10, 4);t2_g2 = rnorm(10)

##Don't print the axes labels
par(ann=FALSE)

##Plot first set of data.
##Need to check for sensible ranges
##Use the jitter function to spread data out.
plot(jitter(rep(0,10),amount=0.2), t1,
     xlim=range(-0.5,3.5), ylim=range(-3,8),
     axes=FALSE,frame.plot=TRUE)
points(jitter(rep(1,10), amount=0.2), t1_g2, col=2)
points(jitter(rep(2,10), amount=0.2), t2)
points(jitter(rep(3,10), amount=0.2), t2_g2, col=2)

##Add in the y-axis
axis(2, seq(-4,8,by=2))

##Add in the x-axis labels
mtext("Treatment 1", side = 1, at=0.5)
mtext("Treatment 2", side = 1, at=2.5)

##Add in the means
segments(-0.25, mean(t1), 0.25, mean(t1))
segments(0.75, mean(t1_g2), 1.25, mean(t1_g2))
segments(1.75, mean(t2), 2.25, mean(t2))
segments(2.75, mean(t2_g2), 3.25, mean(t2_g2))

##Add in the legend
legend(0, 8, c("Group 1", "Group 2"), col=1:2, pch=1)
-------------------------------------------------------------------------------------------------------
dat = as.data.frame(rbind(c("1492", "Columbus sailed the ocean blue"),
                       c("1976", "Americans listened to Styx"),
                       c("2008", "Financial meltdown")))
dat$V1 <- as.Date(dat$V1,"%Y")
dat$val <- c(-1,1,-0.5)

plot(dat$V1,dislocations, type = "n",xaxt = "n",bty = "n", 
     xlab = "Time", ylab = "Dislocations")
u <- par("usr")
arrows(u[1], 0, u[2], 0, xpd = TRUE)
points(dat$V1,dat$val,pch = 20)
segments(dat$V1,c(0,0,0),dat$V1,dat$val)
text(x=dat$V1,y=dat$val,labels=dat$V2,pos=c(4,2,2))
-------------------------------------------------------------------------------------------------------
draw_ellipse = function (mean_x, mean_y, sd_x, sd_y)
{
    ellipse <- function (x) { sin(acos(x)) }
    t = seq(-1, 1, length.out = 100)
    el_y = sd_y*ellipse(t)
    newx = mean_x + sd_x * t
    polygon(c(newx, rev(newx)), c(mean_y + el_y, rev(mean_y - el_y)), col = "grey", border = NA)
} apply() x = runif(10)
y = runif(10)
sd_x = abs(rnorm(10, 0.1, 0.02))
sd_y = abs(rnorm(10, 0.05, 0.01))
plot(x, y)
df = data.frame(x, y, sd_x, sd_y)
apply(df, 1, function (x) { draw_ellipse(x[1], x[2], x[3], x[4]) })
points(x, y, pch = 3) draw_ellipse = function (mean_x, mean_y, sd_x, sd_y, colidx)
{
    ellipse <- function (x) { sin(acos(x)) }
    t = seq(-1, 1, length.out = 100)
    el_y = sd_y*ellipse(t)
    newx = mean_x + sd_x * t
    polygon(c(newx, rev(newx)), c(mean_y + el_y, rev(mean_y - el_y)), col = as.character(colors[colidx]), border = NA)
}

x = runif(10)
y = runif(10)
sd_x = abs(rnorm(10, 0.1, 0.02))
sd_y = abs(rnorm(10, 0.05, 0.01))
plot(x, y)
colors = rainbow(length(x))
df = data.frame(x, y, sd_x, sd_y, colidx = 1:length(x))
apply(df, 1, function (x) { draw_ellipse(x[1], x[2], x[3], x["sd_y"], x["colidx"]) })
points(x, y, pch = 3)
-------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------
align.time s period.apply # align index into 3-hour blocks
a <- align.time(s, n=60*60*3)
# find the number of obs in each block
count <- period.apply(a, endpoints(a, "hours", 3), length)
# create an empty xts object with the desired index
e <- xts(,seq(start(a),end(a),by="3 hours"))
# merge the counts with the empty object and fill with zeros
out <- merge(e,count,fill=0)
-------------------------------------------------------------------------------------------------------
period.apply apply.daily apply.weekly library(quantmod)
getSymbols("SPY")
myFun <- function(x) c(Low=min(Lo(x)),Vol=sum(Vo(x)))
out <- period.apply(SPY, endpoints(SPY,"years"), myFun)
#               Low         Vol
# 2007-12-31 136.75 39313707500
# 2008-12-31  74.34 75960174800
# 2009-12-31  67.10 62061939800
# 2010-12-31 101.13 52842325500
# 2011-10-10 107.43 42314587300
-------------------------------------------------------------------------------------------------------
mat2 mat1 statSim statObs statSim list( obs = statObs , sumFit = sum(statSim > statObs)/numR) obs sumFit max(statSim) sumFit max resamplerSimAlt <- function(mat1, mat2, numR, graph = FALSE)
{
  statSim <- numeric(numR)
  mat1vcv <- cov(mat1)
  mat2vcvT <- cov(mat2)
  ltM1 <- mat1vcv[col(mat1vcv) <= row(mat1vcv)]
  ltM2T <- mat2vcvT[col(mat2vcvT) <= row(mat2vcvT)]
  statObs <- cor(ltM1, ltM2T)                           
  indice <- c(1:length(mat2))
  resamplesIndices <- lapply(1:numR, function(i) sample(indice, replace = F))
  for (i in 1:numR)
  {
    ss <- mat2[sample(resamplesIndices[[i]])]
    ss <- matrix(ss, nrow = dim(mat2)[[1]], ncol = dim(mat2)[[2]])
    mat2ss <- cov(ss)
    ltM2ss <- mat2ss[col(mat2ss) <= row(mat2ss)]
    statSim[i] <- cor(ltM1, ltM2ss)
  }
  if (graph == TRUE)
  {
    plot(1, main = "resampled data density distribution", xlim = c(0, statObs+0.1), ylim = c(0,14))
    points(density(statSim), type="l", lwd=2)
    abline(v = statObs)
    text(10, 10, "observed corelation = ")
  }
  list( obs = statObs , sumFit = sum(statSim > statObs)/numR, max=max(statSim))
} > mat1 <- matrix(runif(25),5,5)
> mat2 <- mat1+0.2
> resamplerSimAlt(mat1, mat2, 10000)
$obs
[1] 1

$sumFit
[1] 0

$max
[1] 0.94463 mat2 > mat2 <- matrix(runif(25),5,5)
> resamplerSimAlt(mat1, mat2, 10000)
$obs
[1] 0.31144

$sumFit
[1] 0.9124

$max
[1] 0.9231
-------------------------------------------------------------------------------------------------------
rgdal PATH=/Library/Frameworks/GDAL.framework/unix/bin:/Library/Frameworks/PROJ.framework/unix/bin$PATH rgdal rgdal install.packages('~/Downloads/rgdal_0.7-1.tar.gz', repos=NULL, type='source', configure.args=c('--with-proj-include=/Library/Frameworks/PROJ.framework/unix/include', '--with-proj-lib=/Library/Frameworks/PROJ.framework/unix/lib')) library(rgdal)
library(maptools)

# Load KML coordinates
coords = getKMLcoordinates('data.kml')
coords = SpatialPoints(coords, CRS('+proj=longlat'))

# Load US Maps (get from www.gadm.org)
load('USA_adm1.RData') 
hawaii = gadm[gadm$NAME_1 == 'Hawaii', ]

# Transform coordinates
hawaii.proj = spTransform(hawaii, CRS=CRS('+init=epsg:2784 +units=km'))
coords.proj = spTransform(coords, CRS=CRS('+init=epsg:2784 +units=km'))

# Plot
dev.new(width=4, height=4)
plot(hawaii.proj, axes=T, xlim=c(450,550), ylim=c(0,60))
points(coords.proj, pch=16, col='red')
-------------------------------------------------------------------------------------------------------
cal <- function(month, year) {

        if(!require(chron)) stop('Unable to load chron package')

     if(missing(year) && missing(month)) {
         tmp <- month.day.year(Sys.Date())
         year <- tmp$year
         month <- tmp$month
     }


    if(missing(year) || missing(month)){  # year calendar
        if(missing(year)) year <- month
        par(mfrow=c(4,3))
        tmp <- seq.dates( from=julian(1,1,year), to=julian(12,31,year) )
        tmp2 <- month.day.year(tmp)
        wd <- do.call(day.of.week, tmp2)
        par(mar=c(1.5,1.5,2.5,1.5))
        for(i in 1:12){
            w <- tmp2$month == i
            cs <- cumsum(wd[w]==0)
            if(cs[1] > 0) cs <- cs - 1
            nr <- max( cs ) + 1
            plot.new()
            plot.window( xlim=c(0,6), ylim=c(0,nr+1) )
            text( wd[w], nr - cs -0.5 , tmp2$day[w] )
            title( main=month.name[i] )
            text( 0:6, nr+0.5, c('S','M','T','W','T','F','S') )
        }

    } else {  # month calendar

        ld <- seq.dates( from=julian(month,1,year), length=2, by='months')[2]-1
        days <- seq.dates( from=julian(month,1,year), to=ld)
        tmp <- month.day.year(days)
        wd <- do.call(day.of.week, tmp)
        cs <- cumsum(wd == 0)
        if(cs[1] > 0) cs <- cs - 1
        nr <- max(cs) + 1
        par(oma=c(0.1,0.1,4.6,0.1))
        par(mfrow=c(nr,7))
        par(mar=c(0,0,0,0))
        for(i in seq_len(wd[1])){ 
            plot.new()
            #box()
        }
        day.name <- c('Sun','Mon','Tues','Wed','Thur','Fri','Sat')
        for(i in tmp$day){
            plot.new()
            box()
            text(0,1, i, adj=c(0,1))
            if(i < 8) mtext( day.name[wd[i]+1], line=0.5,
                at=grconvertX(0.5,to='ndc'), outer=TRUE ) 
        }
        mtext(month.name[month], line=2.5, at=0.5, cex=1.75, outer=TRUE)
        #box('inner') #optional 
    }
} par(mfg=c(r,c)) updateusr subplot TeachingDemos cal(10,2011)
par(mfg=c(3,2))  # monday oct 10
text(.5,.5, 'Some\nText', cex=2)

par(mfg=c(2,3)) #Tues oct 4
text(1,1, 'Top Right', adj=c(1,1))

par(mfg=c(2,4)) # Wed oct 5
text(0,0, 'Bottom Left', adj=c(0,0))

par(mfg=c(6,2)) # oct 31
tmp.x <- runif(25)
tmp.y <- rnorm(25,tmp.x,.1)
par(usr=c( range(tmp.x), range(tmp.y) ) )
points(tmp.x,tmp.y)
-------------------------------------------------------------------------------------------------------
splines # test data
df1 <- data.frame(x=rnorm(100), y=rpois(100, lambda=.5))
df2 <- data.frame(x=rnorm(200), y=rpois(200, lambda=.5))

tmp1 <- spline( lowess( df1[,1], df1[,2] ), n = 20 )
tmp2 <- spline( lowess( df2[,1], df2[,2] ), n = 20 )

plot( tmp1[[1]], tmp1[[2]], type="l" )
lines( tmp2[[1]], tmp2[[2]], col="red" ) plot( tmp1[[1]], tmp1[[2]], type="l", ylim=c(0,4) )
 lines( tmp2[[1]], tmp2[[2]], col="red" )
 points(jitter(df2[[1]]), df2[[2]],  cex=0.3, col="blue")
 points(jitter( df1[[1]]), df1[[2]], cex=0.3, col="red")
-------------------------------------------------------------------------------------------------------
colvec <- rgb(rbind(t(col2rgb("black")), ## this is obviously just 0, 0, 0
                    c(96,123,139),
                    c(225,64,5)),
              alpha=50,max=255)

plot(shuffled, p_val, pch=19, col=colvec[1], xlim=c(0,100), ylim=c(0,1))
points(ri, p_val, pch=19, col=colvec[2], xlim=c(0,100), ylim=c(0,1))
points(somo, p_val, pch=19, col=colvec[3], xlim=c(0,100), ylim=c(0,1))
legend("topright", c("Shuffled", "Riffled", "Somosome"), cex=1.0, bty="n",
       col=colvec)
-------------------------------------------------------------------------------------------------------
\if{html}{\figure{logo.jpg}{Our logo}}
 \if{latex}{\figure{logo.jpg}{options: width=0.5in}}
-------------------------------------------------------------------------------------------------------
set.seed(310366)

nx=5
ny=6
SOI=matrix(rnorm(nx*ny,100,50),nx,ny)

colnames(SOI)=paste("NAP_G0",sort(as.integer(runif(ny,10,99))),sep="")
rownames(SOI)=sample(2315101:(2315101+nx-1))
above150 = SOI>150
below30=SOI<30

makeRects <- function(tfMat,border){
  cAbove = expand.grid(1:nx,1:ny)[tfMat,]
  xl=cAbove[,1]-0.49
  yb=cAbove[,2]-0.49
  xr=cAbove[,1]+0.49
  yt=cAbove[,2]+0.49
  rect(xl,yb,xr,yt,border=border,lwd=3)
}

heatmap(t(SOI),Rowv = NA, Colv=NA, add.expr = {
 makeRects(above150,"red");makeRects(below30,"blue")})
-------------------------------------------------------------------------------------------------------
dat<- data.frame(t=seq(0, 2*pi, by=0.1) )
 xhrt <- function(t) 16*sin(t)^3
 yhrt <- function(t) 13*cos(t)-5*cos(2*t)-2*cos(3*t)-cos(4*t)
 dat$y=yhrt(dat$t)
 dat$x=xhrt(dat$t)
 with(dat, plot(x,y, type="l")) with(dat, polygon(x,y, col="hotpink")) help(points) TestChars 
points(c(10,-10, -15, 15), c(-10, -10, 10, 10), pch=169, font=5) library(Cairo)

clubs <- expression(symbol('\247'))
hearts <- expression(symbol('\251'))
diamonds <- expression(symbol('\250'))
spades <- expression(symbol('\252'))
csymbols <- c(clubs, hearts, diamonds, spades)

plot( 0, xlim=c(0,5), ylim=c(0,2), type="n" )
clr <- c("black", "red", "red", "black") 
for (i in 1:4) {
  hline <- function( yloc, ... ) 
         for (i in 1:length(yloc)) 
             lines( c(-1,6), c(yloc[i],yloc[i]), col="gray")  
              hline(0.9); 
                hline(1.0);
                hline(1.1);
                hline(1.2)  
 text( i, 1, csymbols[i], col=clr[i], cex=5 )  
 text( i, 0.5, csymbols[i], col=clr[i] ) }

# Also try this
plot(1,1)
text(x=1+0.2*cos(seq(0, 2*pi, by=.5)), 
     y=1+0.2*sin(seq(0, 2*pi, by=.5)), 
                  expression(symbol('\251') ) )
-------------------------------------------------------------------------------------------------------
ggplot library(png)
library(grid)
imgfile <- "http://upload.wikimedia.org/wikipedia/commons/e/e1/Tie-dye.png"   
download.file(imgfile,dest="tiedye.png")
r <- readPNG("tiedye.png")
rmat <- matrix(rgb(r[,,1],r[,,2],r[,,3],alpha=0.4),
               nrow=dim(r)[1]) shadow.points <- function(x, y, size=unit(1, "char"), default.units="native", ...) {
 if(!is.unit(x)) {x <- unit(x, default.units) } 
 if(!is.unit(y)) { y <- unit(y, default.units) }
 grid::grid.points(x+0.2*size, y-0.2*size, size=size, gp=gpar(col="black"), pch=20) 
 grid::grid.points(x, y, size=size, default.units=default.units, ...)
} grid.roundrect png("mask.png",width=ncol(r), height=nrow(r), res=1)
grid.roundrect(gp=gpar(fill="black"))
dev.off()
m <- readPNG("mask.png", native=FALSE)
mask <- matrix(rgb(m[,,1],m[,,2],m[,,3]),
               nrow=dim(m)[1])
rmat[mask == "#FFFFFF"] <- "#FFFFFF" grid.newpage()
pushViewport(plotViewport(),
             viewport(xscale=c(0, 10), yscale=c(0, 10)))

grid.raster(rmat,x=unit(0,"native"),y=unit(0,"native"),
            width=1,height=1,just=c(0,0))
grid.roundrect()  ## frame
grid.xaxis(at=seq(2,8,by=2))  ## axes -- shorter to avoid going beyond end of frame
grid.yaxis(at=seq(2,8,by=2))
shadow.points(x=rnorm(10,mean=5),y=rnorm(10,mean=5),pch=20,
            gp=gpar(col="cyan"))
-------------------------------------------------------------------------------------------------------
grid.points <- function(x, y, size=unit(1, "char"), default.units="native", ...) {
 if(!is.unit(x)) {x <- unit(x, default.units) } 
 if(!is.unit(y)) { y <- unit(y, default.units) }
 grid::grid.points(x+0.2*size, y-0.2*size, size=size, gp=gpar(col="black"), pch=20) 
 grid::grid.points(x, y, size=size, default.units=default.units, ...)
}
-------------------------------------------------------------------------------------------------------
points() plot(x,y,type="o",col="red")
points(x1,y1,type="o",col="blue")
-------------------------------------------------------------------------------------------------------
pch my.symbols() require(TeachingDemos)

bwDiamond <- function() {
    plot.new()
    polygon(c(0, 0.5, 1, 0.5, 0), c(0.5, 0, 0.5, 1, 0.5), lty=1)
    polygon(c(0.25, 0.5, 1, 0.75, 0.25), c(0.25, 0, 0.5, 0.75, 0.25), col=1)
}

data <- c(1,2,3)

dev.new(width=4, height=4)
plot(data, type='n')
points(data[1:2], pch=c(23,18), cex=c(2.5,3))
my.symbols(data[3], data[3], symb=bwDiamond, symb.plots=TRUE, inches=0.22)
-------------------------------------------------------------------------------------------------------
x <- rnorm(500, mean=0, sd=sqrt(1))
y <- rnorm(500, mean=0, sd=sqrt(16)) plot(y ~ x) plot(y, col="blue")
points(x, col="red")
-------------------------------------------------------------------------------------------------------
require(inline)
require(Rcpp)

randPoints = cxxfunction(signature(r_n='int', r_mindist='float', r_maxiter='int'), body = 
' 
  using namespace std;

  int n = as<int> (r_n);
  float mindist = as<float> (r_mindist);
  int maxiter = as<int> (r_maxiter);

  RNGScope scope;
  bool tooclose;
  int iter;
  NumericVector rands (2);
  NumericMatrix points (n, 2);
  NumericVector dist (2);

  for (int i=0; i < n; i++) {
    iter = 0;
    do {
      iter++;
      tooclose = false;
      rands = runif(2, 0, 1);
      for (int idist=0; idist < i; idist++) {
        dist = rands - points(idist, _);
        dist = dist * dist;
        if (sqrt(accumulate(dist.begin(), dist.end(), 0.0)) < mindist) {
          tooclose = true;
          break;
        }
      }
    } while (tooclose & iter < maxiter);
    if (iter == maxiter) {
      Rprintf("%d iterations reached\\nOnly %d points found\\n", maxiter, i+1);
      break;
    }
    NumericMatrix::Row target(points, i);
    target = rands;
  }

  return(wrap(points));
'
, plugin='Rcpp') > x = randPoints(1000, 0.05, 10000)
10000 iterations reached
Only 288 points found x = x[as.logical(rowMeans(x != 0)), ]
dev.new(width=4, height=4)
plot(x)
-------------------------------------------------------------------------------------------------------
for (j in 1:length(xx)){
  for (i in 1:n){
    if (xx[j]<=x[i]){
      break
    }
    yy[i] = A[i]*(xx[j] - x[i])^3 + B[i]*(xx[j] - x[i])^2 + C[i]*(xx[j] - x[i]) + D[i]

 } #spline evaluation
for (j in 1:length(xx)){
  for (i in 1:n){
    if (xx[j]<=x[i]){
      next
     }
    yy[j] = A[i]*(xx[j] - x[i])^3 + B[i]*(xx[j] - x[i])^2 + C[i]*(xx[j] - x[i]) + D[i]

 }
} > xx=seq(35,48,len=100)
> yy = myspline(x,y,xx)
> plot(xx,yy,type="l")
> points(x,y)
> myspline <- function(x,y,xx){

n = length(x)

h=0;yy=0
#determine width of intervals
for (i in 1:(n-1)){
   h[i] = (x[i+1] - x[i])
}

A = 0
B = 0
C = 0
D = 0
#determine the matrix influence coefficients for the natural spline
for (i in 2:(n-1)){
  j = i-1
  D[j] = 2*(h[i-1] + h[i])
  A[j] = h[i]
  B[j] = h[i-1] 

}

#determine the constant matrix C
for (i in 2:(n-1)){
  j = i-1
  C[j] = 6*((y[i+1] - y[i]) / h[i] - (y[i] - y[i-1]) / h[i-1])
}

#maximum TDMA length
ntdma = n - 2

#tridiagonal matrix algorithm

#upper triangularization
R = 0
for (i in 2:ntdma){
  R = B[i]/D[i-1]
  D[i] = D[i] - R * A[i-1]
  C[i] = C[i] - R * C[i-1] 
}

#set the last C
C[ntdma] = C[ntdma] / D[ntdma]

#back substitute
for (i in (ntdma-1):1){
  C[i] = (C[i] - A[i] * C[i+1]) / D[i]
}

#end of tdma

#switch from C to S
S = 0
for (i in 2:(n-1)){
  j = i - 1
  S[i] = C[j]
}
#end conditions
S[1] <- 0 -> S[n]

#Calculate cubic ai,bi,ci and di from S and h
for (i in 1:(n-1)){
 A[i] = (S[i+ 1] - S[i]) / (6 * h[i])
 B[i] = S[i] / 2
 C[i] = (y[i+1] - y[i]) / h[i] - (2 * h[i] * S[i] + h[i] * S[i + 1]) / 6
 D[i] = y[i]
}


#control points
#xx = seq(x[2],x[4],len=100)

#spline evaluation
for (j in 1:length(xx)){
  for (i in 1:n){
    if (xx[j]<=x[i]){
      next
     }
    yy[j] = A[i]*(xx[j] - x[i])^3 + B[i]*(xx[j] - x[i])^2 + C[i]*(xx[j] - x[i]) + D[i]
 }
}
return(yy)
}
-------------------------------------------------------------------------------------------------------
R-2.12.1 R-2.14.0 R-2.13.0 NEWS * plot(<formula>, data=<matrix>,..) now works in more cases;
  similarly for points(), lines() and text(). R
-------------------------------------------------------------------------------------------------------
overlay over Spatial* xy <- data.frame(x = runif(40, min = -200, max = 200),
    y = runif(40, min = -200, max = 200))
plot(xy)
my.identify <- function(data) {
    # allows you to create a polygon by clicking on map 
    region = locator(type = "o")  
    n = length(region$x)
    p = Polygon(cbind(region$x, region$y)[c(1:n,1),])
    ps = Polygons(list(p), ID="region")
    sps = SpatialPolygons(list(ps))

    # returns all data that overlaps new polygon sps
    a=data[!is.na(over(SpatialPoints(data),sps)),]
    return(a)
}
ident <- my.identify(xy)
points(ident, pch = 16)
-------------------------------------------------------------------------------------------------------
line axis() mtext() # Plot and first axis:
plot(1:10,1:10,bty="n",col="red",pch=16,axes=FALSE,xlab="",ylab="")
axis(2,0:11,las=1)
axis(1,0:11,line=1,col="red",col.ticks="red",col.axis="red")
mtext("Label 1",1,line=1,at=0.2,col="red")

# Secondary points and axis:
points(rnorm(10,50,20)/10, rnorm(10,5,2),pch=16, col="blue" )
axis(1,0:11,labels=0:11*10,line=3,col="blue",col.ticks="blue",col.axis="blue")
mtext("Label 2",1,line=3,at=0.2,col="blue")
-------------------------------------------------------------------------------------------------------
animUnit grid.newpage()
with(start, 
  grid.points(x, y, default.units = "npc", name = "points")
)
x_points <- animUnit(
  unit(c(start$x, end$x), "npc"),
  #timeid = rep(1:2, each = n_points),
  id = rep(1:20, 2)
)        
y_points <- animUnit(
  unit(c(start$y, end$y), "npc"),
  #timeid = rep(1:2, each = n_points),
  id = rep(1:20, 2)
)        
grid.animate(  #throws an error: Expecting only one value per time point
  "points", 
  x = x_points,
  y = y_points
)
-------------------------------------------------------------------------------------------------------
filled.contour scatter.fill <- function (x, y, z, 
                              nlevels = 20, plot.title, plot.axes, 
                              key.title, key.axes, asp = NA, xaxs = "i", 
                              yaxs = "i", las = 1, 
                              axes = TRUE, frame.plot = axes, ...) 
    {
        mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar
        on.exit(par(par.orig))
        w <- (3 + mar.orig[2L]) * par("csi") * 2.54
        layout(matrix(c(2, 1), ncol = 2L), widths = c(1, lcm(w)))
        par(las = las)
        mar <- mar.orig
        mar[4L] <- mar[2L]
        mar[2L] <- 1
        par(mar = mar)

        #Some simplified level/color picking
        levels <- seq(min(z),max(z),length.out = nlevels)
  col <- colorRampPalette(c("blue","red"))(nlevels)[rank(z)]

        plot.new()
        plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i", 
            yaxs = "i")
  rect(0, levels[-length(levels)], 1, levels[-1L], col = colorRampPalette(c("blue","red"))(nlevels)
        if (missing(key.axes)) {
            if (axes) 
                axis(4)
        }
        else key.axes
        box()
        if (!missing(key.title)) 
            key.title
        mar <- mar.orig
        mar[4L] <- 1
        par(mar = mar)

        #Simplified scatter plot construction
        plot(x,y,type = "n")
        points(x,y,col = col,...)

        if (missing(plot.axes)) {
            if (axes) {
                title(main = "", xlab = "", ylab = "")
                Axis(x, side = 1)
                Axis(y, side = 2)
            }
        }
        else plot.axes
        if (frame.plot) 
            box()
        if (missing(plot.title)) 
            title(...)
        else plot.title
        invisible()
    } x <- runif(40)
y <- runif(40)
z <- runif(40)
scatter.fill(x,y,z,nlevels = 40,pch = 20) filled.contour
-------------------------------------------------------------------------------------------------------
# Make some data
n <- 15
x <- rnorm(n)
y <- rnorm(n)

# Plot the data
plot(x,y)

# This lets you click on the points you want to change
# the color of.  Right click and select "stop" when
# you have clicked all the points you want
pnt <- identify(x, y, plot = F)

# This colors those points red
points(x[pnt], y[pnt], col = "red")

# identify beeps when you click.
# Adding the following line before the 'identify' line will disable that.
# options(locatorBell = FALSE)
-------------------------------------------------------------------------------------------------------
> p <- powerTransform(rlnorm(100))
> coef(p)
rlnorm(100) 
-0.05007203 
> coef(p, round=TRUE) # Recommended transform
rlnorm(100) 
          0 > p <- powerTransform(qlnorm(ppoints(100)))
> p
Estimated transformation parameters 
qlnorm(ppoints(100)) 
       -2.635191e-12
-------------------------------------------------------------------------------------------------------
latticeExtra library(latticeExtra)
p1 <- xyplot(var ~ temp | subj, data=orig, panel=function(..., subscripts) {
  fill <- my.fill[combined$trt[subscripts]] 
  panel.xyplot(..., pch=21, fill=my.fill, col="black")
})
p2 <- xyplot(var ~ temp | subj, data=model, type="l")
p1+p2 combined xyplot(var ~ temp | subj, groups=which, data = combined,
       panel = function(x, y, groups, subscripts){
         fill <- my.fill[combined$trt[subscripts]]
         g <- groups[subscripts]
         panel.points(x[g=="original"], y[g=="original"], pch = 21, fill = my.fill, col = "black")
         panel.lines(x[g=="model"], y[g=="model"], col = "black")
       },
       key = list(space = "right",
         text = list(c("trt1", "trt2"), cex = 0.8),
         points = list(pch = c(21), fill = c("black", "grey")),
         rep = FALSE)
       )
-------------------------------------------------------------------------------------------------------
# How to speedup cumulative EMA calculation
# 
###############################################################################

library(quantmod)
library(Rcpp)
library(inline)
library(rbenchmark)

do.call.rbind <- function(lst) {
    while(length(lst) > 1) {
        idxlst <- seq(from=1, to=length(lst), by=2)

        lst <- lapply(idxlst, function(i) {
                    if(i==length(lst)) { return(lst[[i]]) }

                    return(rbind(lst[[i]], lst[[i+1]]))
                })
    }
    lst[[1]]
}

to.period.cumulative <- function(x, name=NULL, period="days", numPeriods=15) {
    if(is.null(name))
        name <- deparse(substitute(x))

    cnames <- c("Open", "High", "Low", "Close")
    if (has.Vo(x)) 
        cnames <- c(cnames, "Volume")

    cnames <- paste(name, cnames, sep=".") 

    if (quantmod:::is.OHLCV(x)) {
        x <- quantmod:::OHLCV(x)
        out <- do.call.rbind( 
                lapply(split(x, f=period, k=numPeriods), 
                        function(x) cbind(rep(first(x[,1]), NROW(x[,1])), 
                                cummax(x[,2]), cummin(x[,3]), x[,4], cumsum(x[,5]))))
    } else if (quantmod:::is.OHLC(x)) {
        x <- OHLC(x)
        out <- do.call.rbind( 
                lapply(split(x, f=period, k=numPeriods), 
                        function(x) cbind(rep(first(x[,1]), NROW(x[,1])), 
                                cummax(x[,2]), cummin(x[,3]), x[,4])))
    } else {
        stop("Object does not have OHLC(V).")
    }

    colnames(out) <- cnames

    return(out)
}

EMA.cumulative<-function(cumulativeBars, nEMA = 4, period="days", numPeriods=15) {
    barsEndptCl <- Cl(cumulativeBars[endpoints(cumulativeBars, on=period, k=numPeriods)])

    # TODO: This is sloooooooooooooooooow... 
    outEMA <- do.call.rbind(
            lapply(split(Cl(cumulativeBars), period), 
                    function(x) {
                        previousFullBars <- barsEndptCl[index(barsEndptCl) < last(index(x)), ]
                        if (NROW(previousFullBars) >= (nEMA - 1)) {
                                last(EMA(last(rbind(previousFullBars, x), n=(nEMA + 1)), n=nEMA))
                        } else {
                            xts(NA, order.by=index(x))
                        }
                    }))

    colnames(outEMA) <- paste("EMA", nEMA, sep="")

    return(outEMA)
}

EMA.c.c.code <- '
    /* Initalize loop and PROTECT counters */
    int i, P=0;

    /* ensure that cumbars and fullbarsrep is double */
    if(TYPEOF(cumbars) != REALSXP) {
      PROTECT(cumbars = coerceVector(cumbars, REALSXP)); P++;
    }

    /* Pointers to function arguments */
    double *d_cumbars = REAL(cumbars);
    int i_nper = asInteger(nperiod);
    int i_n = asInteger(n);
    double d_ratio = asReal(ratio);

    /* Input object length */
    int nr = nrows(cumbars);

    /* Initalize result R object */
    SEXP result;
    PROTECT(result = allocVector(REALSXP,nr)); P++;
    double *d_result = REAL(result);

    /* Find first non-NA input value */
    int beg = i_n*i_nper - 1;
    d_result[beg] = 0;
    for(i = 0; i <= beg; i++) {
        /* Account for leading NAs in input */
        if(ISNA(d_cumbars[i])) {
            d_result[i] = NA_REAL;
            beg++;
            d_result[beg] = 0;
            continue;
        }
        /* Set leading NAs in output */
        if(i < beg) {
            d_result[i] = NA_REAL;
        }
        /* Raw mean to start EMA - but only on full bars*/
        if ((i != 0) && (i%i_nper == (i_nper - 1))) {
            d_result[beg] += d_cumbars[i] / i_n;
        }
    }

    /* Loop over non-NA input values */
    int i_lookback = 0;
    for(i = beg+1; i < nr; i++) {
        i_lookback = i%i_nper;

        if (i_lookback == 0) {
            i_lookback = 1;
        } 
        /*Previous result should be based only on full bars*/
        d_result[i] = d_cumbars[i] * d_ratio + d_result[i-i_lookback] * (1-d_ratio);
    }

    /* UNPROTECT R objects and return result */
    UNPROTECT(P);
    return(result);
'

EMA.c.c <- cfunction(signature(cumbars="numeric", nperiod="numeric", n="numeric",     ratio="numeric"), EMA.c.c.code)

EMA.cumulative.c<-function(cumulativeBars, nEMA = 4, period="days", numPeriods=15) {
    ratio <- 2/(nEMA+1)

    outEMA <- EMA.c.c(cumbars=Cl(cumulativeBars), nperiod=numPeriods, n=nEMA, ratio=ratio)  

    outEMA <- reclass(outEMA, Cl(cumulativeBars))

    colnames(outEMA) <- paste("EMA", nEMA, sep="")

    return(outEMA)
}

getSymbols("SPY", from="2010-01-01")

SPY.cumulative <- to.period.cumulative(SPY, name="SPY")

system.time(
        SPY.EMA <- EMA.cumulative(SPY.cumulative)
)

system.time(
        SPY.EMA.c <- EMA.cumulative.c(SPY.cumulative)
)


res <- benchmark(EMA.cumulative(SPY.cumulative), EMA.cumulative.c(SPY.cumulative),
        columns=c("test", "replications", "elapsed", "relative", "user.self", "sys.self"),
        order="relative",
        replications=10)

print(res) > print(res)
                              test replications elapsed relative user.self
2 EMA.cumulative.c(SPY.cumulative)           10   0.026    1.000     0.024
1   EMA.cumulative(SPY.cumulative)           10  57.732 2220.462    56.755
-------------------------------------------------------------------------------------------------------
segments > mydata
  from to values
1    5 10     34
2   10 14     45
3   14 23     46
4   23 34     54

plot(NA,xlim=c(0,40),ylim=c(0,60))
points(values~from,data=mydata)
points(values~to,data=mydata)
segments(mydata$from,mydata$values,mydata$to,mydata$values)
-------------------------------------------------------------------------------------------------------
abline png("strangeplot.png",width=800)
#extend y-axis to fit inside labels and remove box
plot(b,type="n",xaxt="n",yaxt="n",ylab="",xlab="",ylim=c(min(b)-30,max(b)),bty="n"))
#use 'mpg' to get labels inside
axis(1,time(b)[ind], format(time(b)[ind]), las=2, cex.axis=0.6,tick=F,mgp=c(0,-2.5,0))
axis(2,tick=F,las=1)
#you locate lines slightly to the left of label...
abline(h=seq(0,200,by=50),v=time(b)[ind]-0.5,col=gray(0.9))
#...so you need to add extra single line in the end 
abline(v=max(time(b)[ind])+0.5,col=gray(0.9))
#plot at the end to get it above grid
points(b,type="l")
dev.off()
-------------------------------------------------------------------------------------------------------
### some sample data
require(vegan)
data(dune)

# kmeans
kclus <- kmeans(dune,centers= 4, iter.max=1000, nstart=10000)

# distance matrix
dune_dist <- dist(dune)

# Multidimensional scaling
cmd <- cmdscale(dune_dist)

# plot MDS, with colors by groups from kmeans
groups <- levels(factor(kclus$cluster))
ordiplot(cmd, type = "n")
cols <- c("steelblue", "darkred", "darkgreen", "pink")
for(i in seq_along(groups)){
  points(cmd[factor(kclus$cluster) == groups[i], ], col = cols[i], pch = 16)
}

# add spider and hull
ordispider(cmd, factor(kclus$cluster), label = TRUE)
ordihull(cmd, factor(kclus$cluster), lty = "dotted")
-------------------------------------------------------------------------------------------------------
find_peaks <- function (x, y, n.fine = length(x), interval = range(x), ...) {
  maxdif <- max(diff(x)) # longest distance between successive points

  ## selected interval for the search
  range.ind <- seq(which.min(abs(x - interval[1])),
                   which.min(abs(x - interval[2])))
  x <- x[range.ind]
  y <- y[range.ind]

  ## smooth the data
  spl <- smooth.spline(x, y, ...)
  ## finer x positions
  x.fine <- seq(range(x)[1], range(x)[2], length = n.fine)
  ## predicted y positions
  y.spl <- predict(spl, x.fine, der = 0)$y
  ## testing numerically the second derivative
  test <- diff(diff((y.spl), 1) > 0, 1)
  maxima <- which(test == -1) + 1

  ## according to this criterion, we found rough positions
  guess <- data.frame(x=x.fine[maxima], y=y.spl[maxima])

  ## cost function to maximize 
  obj <- function(x) predict(spl, x)$y

  ## optimize the peak position around each guess
  fit <- data.frame(do.call(rbind,
          lapply(guess$x, function(g) {
            fit <- optimize(obj, interval = g + c(-1,1) * maxdif, maximum=TRUE)
            data.frame(x=fit$maximum,y=fit$objective)
          })))

  ## return both guesses and fits
  invisible(list(guess=guess, fit=fit))
}

set.seed(123)
x <- seq(1, 15, length=100)
y <- jitter(cos(x), a=0.2)

plot(x,y)
res <- find_peaks(x,y)
points(res$guess,col="blue")
points(res$fit,col="red")
-------------------------------------------------------------------------------------------------------
n <- 40
d <- data.frame(
  x = rnorm(n),
  y = rnorm(n)
)
# We want the "extreme" points in the following plot
par(mar=c(1,1,1,1))
plot(d, axes=FALSE, xlab="", ylab="")
for(i in 1:n) {
  polygon( c(-10,d$x[i],d$x[i],-10), c(-10,-10,d$y[i],d$y[i]), 
  col=rgb(.9,.9,.9,.2))
} d <- d[ order(d$x, decreasing=TRUE), ]
result <- d[1,]
for(i in seq_len(nrow(d))[-1] ) {
  if( d$y[i] > result$y[nrow(result)] ) {
    result <- rbind(result, d[i,])  # inefficient
  } 
}
points(result, cex=3, pch=15)
-------------------------------------------------------------------------------------------------------
?grid abline(h = ., v = .) plot(x,y)
abline(v = pretty(extendrange(z$x)), 
       h = pretty(extendrange(z$y)),
       col = 'lightgrey', lty = "dotted")
points(x,y, pch=16)
-------------------------------------------------------------------------------------------------------
lwd rect shape polygon bc x = c(bc$x + dx, rev(bc$x - dx), y = c(bc$y + dy, rev(bc$y - dy) points(..., type = "l") lines(...)
-------------------------------------------------------------------------------------------------------
distanceFromPoints() maxValue() Which() xyFromCell() raster # Load required libraries
library(sp)
library(rgdal)
library(raster)

# Create a SpatialPoints object with 10 points randomly sampled from
# the area lying between longitudes 0 and 1 and latitudes 0 and 1
bbox <- matrix(c(0,0,1,1), ncol=2, dimnames = list(NULL, c("min", "max")))
PRJ4 <- CRS("+proj=longlat +datum=WGS84 +ellps=WGS84")
S <- Spatial(bbox = bbox, proj4string = PRJ4)
SP <- spsample(S, 10, type="random")

# Create a raster object covering the same area
R <- raster(extent(bbox), nrow=100, ncol=100, crs=PRJ4)

# Find the coordinates of the cell that is farthest from all of the points
D <- distanceFromPoints(object = R, xy = SP) 
IDmaxD <- Which(D == maxValue(D), cells=TRUE)
(XY <- xyFromCell(D, IDmaxD))
#          x     y
# [1,] 0.005 0.795

# Plot the results
plot(D, main = "Distance map, with most distant cell in red")
points(SP)
points(XY, col="red", pch=16, cex=2)
-------------------------------------------------------------------------------------------------------
df<-data.frame(x=sort(x),y=qnorm(ppoints(length(x)))) 
probs <- c(0.01, 0.05, seq(0.1, 0.9, by = 0.1), 0.95, 0.99)
qprobs<-qnorm(probs)

xl <- quantile(x, c(0.25, 0.75))
yl <-  qnorm(c(0.25, 0.75))
slope <- diff(yl)/diff(xl)
int <- yl[1] - slope * xl[1]
ggplot(data = df, aes(x = x, y = y)) + geom_point() + geom_abline(intercept = int,slope = slope)+scale_y_continuous(limits=range(qprobs), breaks=qprobs, labels = 100*probs)+labs(y ="Percent" , x="Data") fd<-fitdistr(x, "normal") #Maximum-likelihood Fitting of Univariate Dist from MASS 
xp_hat<-fd$estimate[1]+qprobs*fd$estimate[2]  #estimated perc. for the fitted normal
v_xp_hat<- fd$sd[1]^2+qprobs^2*fd$sd[2]^2+2*qprobs*fd$vcov[1,2] #var. of estimated perc
xpl<-xp_hat + qnorm(0.025)*sqrt(v_xp_hat)  #lower bound
xpu<-xp_hat + qnorm(0.975)*sqrt(v_xp_hat)  #upper bound

df.bound<-data.frame(xp=xp_hat,xpl=xpl, xpu = xpu,nquant=qprobs) geom_line(data=df.bound,aes(x = xp, y = qprobs))+
geom_line(data=df.bound,aes(x = xpl, y = qprobs))+
geom_line(data=df.bound,aes(x = xpu, y = qprobs))
-------------------------------------------------------------------------------------------------------
maxnodes r <- randomForest(Y~.,data=mat, maxnodes=10)
plot(x,predict(r,mat),col="green")
points(x,y)
-------------------------------------------------------------------------------------------------------
# Example data and plot
x <- y <- 1:100
alpha <- 44
plot(x,y, log="x", type="l")    

# Add point
points(x = 10^(par("usr")[1]), y = alpha, pch = 16, cex=1.3, col = "red", las = 1,xpd = TRUE) 
# controls whether or not pts straddling the axis are clipped ?par par("usr") ‘usr’ A vector of the form ‘c(x1, x2, y1, y2)’ giving the extremes
      of the user coordinates of the plotting region.  When a
      logarithmic scale is in use (i.e., ‘par("xlog")’ is true, see
      below), then the x-limits will be ‘10 ^ par("usr")[1:2]’.
      Similarly for the y-axis. usr par("usr")[1] 10^(par("usr")[1]
-------------------------------------------------------------------------------------------------------
grid library(jpeg)
library(grid)

d = data.frame(x=rnorm(100, 10), y=rnorm(100, -100))
utils::download.file("http://i.imgur.com/5MexD.jpg", "img.jpg")
img = readJPEG("img.jpg")


w <- convertUnit(unit(ncol(img),"pt"), "in", value=TRUE)
h <- convertUnit(unit(nrow(img),"pt"), "in", value=TRUE)

dev.new(width=w, height=h)    
grid.raster(img, width=unit(1,"npc"), height=unit(1,"npc"))

 v = dataViewport(xData=d$x, yData=d$y)
 grid.points(d$x,d$y, default.units="native", vp=v, gp=gpar(col="white"), pch=8)
-------------------------------------------------------------------------------------------------------
plot points axis axis ?axis ?plot ?points # make a data frame similar to yours
mydf <- data.frame( Name=LETTERS, 
        Up=sample.int(15,size=26,replace=T), 
        Down=-sample.int(15,size=26,replace=T) ) # set up a plot: x axis goes from 1 to 26,
# y limit goes from -15 to 15 (picked manually, you can work yours out
#   programmatically)
# Disable plotting of axes (axes=FALSE)
# Put in some x and y labels and a plot title (see ?plot...)
plot(0,xlim=c(1,26),ylim=c(-15,15),type='n',
     axes=FALSE,                 # don't draw axis -- we'll put it in later.
     xlab='Name',ylab='Change',  # x and y labels
     main='Ups and Downs')       #,frame.plot=T -- try if you like. ?plot.default
# Plot the 'Up' column in green (see ?points)
points(Up~Name,mydf,col='green')
# Plot the 'Down' column in red
points(Down~Name,mydf,col='red')
# ***Draw the x axis, with labels being A-Z 
#  (type in 'LETTERS' to the prompt to see what they are)
# see also ?axis
axis(1,at=1:26,labels=LETTERS)
# Draw the y axis
axis(2) ?points ?par ?axis
-------------------------------------------------------------------------------------------------------
plot(pupil_data$PupilLeft, type = "o") plot(iris[,1], type = "o") points PupilLeft <- c(3.553479 ,3.539469 ,3.527239 ,3.613131 ,3.649437 ,3.632779 ,3.614373
               ,3.605981 ,3.595985 ,3.630766 ,3.590724 ,3.626535 ,3.62386 ,3.619688
               ,3.595711 ,3.627841 ,3.623596 ,3.650569 ,3.64876)

plot(PupilLeft, type = 'o') makeaddpoint <- function(firstpoint){
  ## firstpoint is the y value of the first point in the series

  lastpt <- firstpoint
  lastptind <- 1

  addpoint <- function(nextpt, ...){
    pts <- rbind(c(lastptind, lastpt), c(lastptind + 1, nextpt))
    points(pts, ... )
    lastpt <<- nextpt
    lastptind <<- lastptind + 1
  }

  return(addpoint)

}

myaddpoint <- makeaddpoint(PupilLeft[1])

plot(NA,NA,xlim=c(0,length(PupilLeft)), ylim=c(2,max(PupilLeft)))

for (i in 2:(length(PupilLeft))) 
{
    myaddpoint(PupilLeft[i], type = "o")
} myaddpoint makeaddpoint
-------------------------------------------------------------------------------------------------------
match approx points den.PA <- density(dat$PA)
cols <- data.frame(Species=c('EQUUSCABALLUS', 'HOMOSAPIENS', 'MUSMUSCULUS', 'BOSTAURUS'),
                   col=c('red', 'blue', 'green', 'purple'), stringsAsFactors=FALSE)
plot(den.PA)
points(approx(den.PA$x, den.PA$y, dat$PA), type="h", col=cols$col[match(dat$Species, cols$Species)])
-------------------------------------------------------------------------------------------------------
starts = seq(1, length(inputseq)-windowsize, by = windowsize) starts = seq(1, nchar(inputseq)-windowsize, by = windowsize) slidingwindowplotATGC(3, "ATAGACGATACGATACCCCGAGGGTAGGTA") windowsize[starts[i]:(starts[i]+9999)] substr(inputseq, start, stop) starts[i]+9999 starts[i]+windowsize library(zoo)

slidingwindowplotATGC = function(windowsize, inputseq) 
{
    print(nchar(inputseq)-windowsize)
    s = strsplit(inputseq, "")[[1]]
    starts = seq(1, nchar(inputseq)-windowsize, by = windowsize)
    n = length(starts)
    letters = c("a", "c", "g", "t")
    colors = c("green", "black", "red", "blue")
    counts = t(sapply(letters, function(l) rollapply(s, windowsize, function(x) mean(x == l))))
    plot(counts[1, ], type="l", col=colors[1])
    for (i in 2:4) {
        points(counts[i, ], type="l", col=colors[i])
    }
    print(counts)
}

slidingwindowplotATGC(10, "aagaaaagatcaaagaccagccgccccaccccccagagccccccc")
-------------------------------------------------------------------------------------------------------
lattice raster rasterVis vectorplot() spplot() levelplot() base graphics plot() "RasterLayer" levelplot() require(raster)
require(rasterVis)

## Create a raster and a SpatialPoints object.
r <- raster()
r[] <- 1:ncell(r)
SP <- spsample(Spatial(bbox=bbox(r)), 10, type="random")

## Then plot them    
levelplot(r, col.regions = rev(terrain.colors(255)), cuts=254, margin=FALSE) +
layer(sp.points(SP, col = "red"))

## Or use this, which produces the same plot.
# spplot(r, scales = list(draw=TRUE), 
#        col.regions = rev(terrain.colors(255)), cuts=254) +
# layer(sp.points(SP, col = "red")) SpatialPoints ## A function to test whether points fall within a raster's extent
inExtent <- function(SP_obj, r_obj) {
    crds <- SP_obj@coord
    ext  <- extent(r_obj)
    crds[,1] >= ext@xmin  &  crds[,1] <= ext@xmax &
    crds[,2] >= ext@ymin  &  crds[,2] <= ext@ymax
}
## Remove any points in SP that don't fall within the extent of the raster 'r'
SP <- SP[inExtent(SP, r), ] plot(r) plot raster rasterImage() image() useRaster plot() useRaster=TRUE ## Chain of functions dispatched by `plot(r, useRaster=TRUE)`
getMethod("plot", c("RasterLayer", "missing"))
raster:::.plotraster2
raster:::.rasterImagePlot

## Call within .rasterImagePlot() that sets up the plotting region
plot(NA, NA, xlim = e[1:2], ylim = e[3:4], type = "n",
           , xaxs = "i", yaxs = "i", asp = asp, ...)

## Example showing why the above call produces the 'wrong' y-axis limits
plot(c(-180,180), c(-90,90), 
     xlim = c(-180,180), ylim = c(-90,90), pch = 16,
     asp = 1,
     main = "plot(r, useRaster=TRUE) -> \nincorrect y-axis limits") useRaster=FALSE ## Chain of functions dispatched by `plot(r, useRaster=FALSE)`
getMethod("plot", c("RasterLayer", "missing"))
raster:::.plotraster2
raster:::.imageplot
image.default

## Call within image.default() that sets up the plotting region
plot(NA, NA, xlim = xlim, ylim = ylim, type = "n", xaxs = xaxs, 
     yaxs = yaxs, xlab = xlab, ylab = ylab, ...)

## Example showing that the above call produces the wrong aspect ratio
plot(c(-180,180), c(-90,90), 
     xlim = c(-180,180), ylim = c(-90,90), pch = 16,
     main = "plot(r,useRaster=FALSE) -> \nincorrect aspect ratio")
-------------------------------------------------------------------------------------------------------
dat <- matrix(runif(1000*99),99,1000)
#Combine with "special" point
dat <- rbind(rep(0.1,1000),dat)

out <- cmdscale(dist(dat),k = 2)

#Plot everything, highlighting our "special" point
plot(out)
points(out[1,1],out[1,2],col = "red") isoMDS sammon
-------------------------------------------------------------------------------------------------------
plot ggplot ggplot base ggplot threshold <- 2.2
set.seed(123)
stackOne=data.frame(id=rep(c(1,2,3),each=3),
                y=rnorm(9,2,1),
                x=rep(c(1,2,3),3))
# create a second df to hold segment data
d <- stackOne 
d$y2 <- c(d$y[-1], NA)
d$x2 <- c(d$x[-1], NA) 
d <- d[-findInterval(unique(d$id), d$id), ] # remove last row for each group

plot(stackOne[, 3:2], pch=20)
# clip to region above the threshold
clip(min(stackOne$x), max(stackOne$x), threshold, max(stackOne$y))
segments(d$x, d$y, d$x2, d$y2, lwd=2)
# clip to region below the threshold
clip(min(stackOne$x), max(stackOne$x), min(stackOne$y), threshold)
segments(d$x, d$y, d$x2, d$y2, lwd=2, col='red')
points(stackOne[, 3:2], pch=20) # plot points again so they lie over lines ggplot geom_line(aes(group=id, color = y < 2.2)) color = y < 2.2 threshold <- 2.2 # set colour-transition threshold
yres <- 0.01 # y-resolution (accuracy of colour change location)

d <- stackOne # for code simplification
# new cols for point coordinates of line end
d$y2 <- c(d$y[-1], NA)
d$x2 <- c(d$x[-1], NA) 
d <- d[-findInterval(unique(d$id), d$id), ] # remove last row for each group
# new high-resolution y coordinates between each pair within each group
y.new <- apply(d, 1, function(x) {
  seq(x['y'], x['y2'], yres*sign(x['y2'] - x['y']))
})
d$len <- sapply(y.new, length) # length of each series of points
# new high-resolution x coordinates corresponding with new y-coords
x.new <- apply(d, 1, function(x) {
  seq(x['x'], x['x2'], length.out=x['len'])
})
id <- rep(seq_along(y.new), d$len) # new group id vector
y.new <- unlist(y.new)
x.new <- unlist(x.new)
d.new <- data.frame(id=id, x=x.new, y=y.new)

p <- ggplot(d.new, aes(x=x,y=y)) +
  geom_line(aes(group=d.new$id, color=d.new$y < threshold))+
  geom_point(data=stackOne)+
  scale_color_discrete(sprintf('Below %s', threshold))
p ggplotGrob viewport
-------------------------------------------------------------------------------------------------------
segments() polygons() points() apply()
-------------------------------------------------------------------------------------------------------
segments(out[1,1],out[1,2],out[,1],out[,2]) dat <- matrix(runif(1000*99),99,1000)
dat <- rbind(rep(0.1,1000),dat)
out <- cmdscale(dist(dat),k = 2)
plot(out,type="n")
segments(out[1,1],out[1,2],out[,1],out[,2],col="#cccccc")
points(out,col="black",pch=20)
points(out[1,1],out[1,2],col = "red",pch=20)
-------------------------------------------------------------------------------------------------------
plot(1:4)
clip(-0.5, 4.1, -0.5, 4.1)
points(0.85, 1, col = 'red', cex = 2)
-------------------------------------------------------------------------------------------------------
PLOT <- FALSE
pdf('anna.pdf', paper='a4')
for (chr in paste('chr',c(seq(1,22),'X','Y'),sep='')){
    if(!PLOT){
      plot(exp,control,xlim=c(0,400),ylim=c(0,400),   
       pch=20,col='black',main='Tiles',xlab='exp',ylab 'Control')
       PLOT <- TRUE
    } else {
       points(exp,control, ...)
    }
}
dev.off()
-------------------------------------------------------------------------------------------------------
library(grid)

N <- 1e7 # Warning: slow
d <- data.frame(x1=rnorm(N),
                x2=rnorm(N, 0.8, 0.9),
                y=rnorm(N, 0.8, 0.2),
                z=rnorm(N, 0.2, 0.4))

v <- with(d, dataViewport(c(x1,x2),c(y, z)))

png("layer1.png", bg="transparent")
with(d, grid.points(x1,y, vp=v,default="native",pch=".",gp=gpar(col="blue")))
dev.off()
png("layer2.png", bg="transparent")
with(d, grid.points(x2,z, vp=v,default="native",pch=".",gp=gpar(col="red")))
dev.off()

library(png)
i1 <- readPNG("layer1.png", native=FALSE)
i2 <- readPNG("layer2.png", native=FALSE)

ghostize <- function(r, alpha=0.5)
  matrix(adjustcolor(rgb(r[,,1],r[,,2],r[,,3],r[,,4]), alpha.f=alpha), nrow=dim(r)[1])

grid.newpage()
grid.rect(gp=gpar(fill="white"))
grid.raster(ghostize(i1))
grid.raster(ghostize(i2)) ggplot2
-------------------------------------------------------------------------------------------------------
gDistance rgeos SpatialLines/DataFrame SpatialPoints/DataFrame require(rgeos)
## untested code
shortest.dists <- numeric(nrow(sp.pts))
for (i in seq_len(nrow(sp.pts)) {
    shortest.dists[i] <- gDistance(sp.pts[i,], sp.lns)
} sp.pts sp.lns sp.pts sp.lns gDistance spDistsN1 sp longlat = TRUE library(maptools)

## simple global data set, which we coerce to Lines
data(wrld_simpl)

wrld_lines <- as(wrld_simpl, "SpatialLinesDataFrame")

## get every coordinate as a simple matrix (scary but quick)
wrld_coords <- do.call("rbind", lapply(wrld_lines@lines, function(x1) do.call("rbind", lapply(x1@Lines, function(x2) x2@coords[-nrow(x2@coords), ])))) ## no out of bounds clicking . . .
par(mar = c(0, 0, 0, 0), xaxs = "i", yaxs = "i") 

plot(wrld_lines, asp = "")

n <- 5

for (i in seq_len(n)) {
xy <- matrix(unlist(locator(1)), ncol = 2)
    all.dists <- spDistsN1(wrld_coords, xy, longlat = TRUE)
    min.index <- which.min(all.dists)
    points(xy, pch = "X")
lines(rbind(xy, wrld_coords[min.index, , drop = FALSE]), col = "green", lwd = 2)
}
-------------------------------------------------------------------------------------------------------
# make a data series
my.stat <- rnorm(100,sd=2.5)
# get its standard dev:
my.sd <- sd(my.stat)
# convert series to distance in sd:
my.lj.stat <- (my.stat - mean(my.stat)) / my.sd

plot(1:100, my.lj.stat, type = "o", pch = 19, col = "blue", ylab = "sd", xlab = "observation",
    main = paste("mean value of", round(mean(my.stat),3),"\nstandard deviation of",round(my.sd,3)))

# a low tech L-J chart function:
LJchart <- function(series, ...){
    xbar        <- mean(series)
    se          <- sd(series)
    conv.series <- (my.stat - xbar) / se

    plot(1:length(series), conv.series, type = "o", pch = 19, col = "blue", ylab = "sd", xlab = "observation",
        main = paste("mean value of", round(xbar,3), "\nstandard deviation of", round(se,3)), ...)
}

LJchart(rnorm(100,sd=2.5)) ... ... LJchart <- function(series, ...){
    xbar        <- mean(series)
    se          <- sd(series)
    conv.series <- (my.stat - xbar) / se

    plot(1:length(series), conv.series, type = "n", ...)
    rect(0, -1, length(series)+1, 1, col = gray(.9), border = NA)
    lines(1:length(series), conv.series, ...)
    points(1:length(series), conv.series, ...)
    if (! "main" %in% names(list(...))) {
        title(paste("mean value of", round(xbar,3), "\nstandard deviation of", round(se,3)))
    }
}

LJchart(rnorm(100,sd=2.5), xlab = "observations", ylab = "sd", col = "blue", pch = 19)
-------------------------------------------------------------------------------------------------------
solve.QP b (1/2) * t(b) %*% Dmat %*% b - t(dvec) %*% b t(Amat) %*% b >= bvec. b sum( (b-betas)^2 ) = sum(b^2) - 2 * sum(b*betas) + sum(beta^2)
                   = t(b) %*% t(b) - 2 * t(b) %*% betas + sum(beta^2). sum(beta^2) Dmat = diag(n)
dvec = betas. b[1] <= b[2]
b[2] <= b[3]
...
b[n-1] <= b[n] -b[1] + b[2]                       >= 0
      - b[2] + b[3]                >= 0
               ...
                   - b[n-1] + b[n] >= 0 t(Amat) [ -1  1                ]
[    -1  1             ]
[       -1  1          ]
[             ...      ]
[                -1  1 ] bvec # Sample data
betas <- c(1.2, 1.3, 1.6, 1.4, 2.2)

# Optimization
n <- length(betas)
Dmat <- diag(n)
dvec <- betas
Amat <- matrix(0,nr=n,nc=n-1)
Amat[cbind(1:(n-1), 1:(n-1))] <- -1
Amat[cbind(2:n,     1:(n-1))] <-  1
t(Amat)  # Check that it looks as it should
bvec <- rep(0,n-1)
library(quadprog)
r <- solve.QP(Dmat, dvec, Amat, bvec)

# Check the result, graphically
plot(betas)
points(r$solution, pch=16) constrOptim optim b[1] = exp(x[1])
b[2] = b[1] + exp(x[2])
...
b[n] = b[n-1] + exp(x[n-1]).
-------------------------------------------------------------------------------------------------------
require(circular)
x <- circular(runif(50, 0, 2*pi))
rose.diag(x, bins = 18, main = 'Uniform Data',col=2)
points(x)
-------------------------------------------------------------------------------------------------------
x <- strptime(20120101:20120105,'%Y%m%d')
y1 <- c(11,22,33,44,55)
y2 <- c(15,23,33,45,57)

r <- range(c(y1, y2)) 

plot(c(x, x), c(y1, y2), type="n", xlab="Date", ylab="y")
points(x, y1, pch=18)
points(x, y2, pch=18)
segments(as.numeric(x), y0=y1, y1=y2)
-------------------------------------------------------------------------------------------------------
library(grid)
epsilon <- 1e-4
grid.newpage()
grid.points(x=c(0.5-epsilon,0.5+epsilon), y=c(0.5,0.5), pch="+", gp=gpar(cex=2), def="npc")
grid.segments(0.5-epsilon, 0.5, 0.5+epsilon, 0.5, gp=gpar(lineend="square",lwd=50, alpha=0.2))
grid.segments(0.5-epsilon, 0.5, 0.5+epsilon, 0.5, gp=gpar(lineend="round",lwd=50, alpha=0.2))
grid.segments(0.5-epsilon, 0.5, 0.5+epsilon, 0.5, gp=gpar(lineend="butt",lwd=50, alpha=0.2)) grid.newpage()
grid.rect(x=0.5, y=0.5, width=0.01, height=0, gp=gpar(fill="black", col="red", lwd=10, linejoin="mitre"))
-------------------------------------------------------------------------------------------------------
order colnames (zx) <- seq_len (ncol (zx))
boxplot(zx [, order (zx_means)], horizontal = FALSE, outline = FALSE)
points(zx_means [ order (zx_means)], pch = 22, col = "darkgrey", lwd = 7)
-------------------------------------------------------------------------------------------------------
points(zx_means[order (zx_means)], seq_along(zx_means), 
       pch = 22, col = "darkgrey", lwd = 7) points(zx_means, order (zx_means), pch = 22, col = "darkgrey", lwd = 7)
-------------------------------------------------------------------------------------------------------
legend() x1 y1 body(legend)[[46]] legend2 <- legend
body(legend2)[[49]] <- quote(
  invisible(list(rect = list(w = w, h = h, left = left, top = top),
  text = list(x = xt, y = yt), points = list(x = x1, y = y1)))
) plot(-100:100, -100:100, type = "b") pch = 21 pt.bg = 'white' legend2() pt.lwd pt.cex myLegend <- legend2(1, .8, bty = 'n', c('sugar','citrus','none'), pch = 21,
  pt.bg = 'white', pt.lwd = 0, lty = c(1, 2, 3), lwd = 1.5, title = "Condition",
  pt.cex = c(1.8), cex = 1.5) points() myLegend points(myLegend$points$x, myLegend$points$y, pch = c('s','c','u'), cex = 1.5)
-------------------------------------------------------------------------------------------------------
?plot ?points pch=21 bg cex lwd y <- sample(10)
plot(y, lwd=6, type='l')
points(y, bg='tomato2', pch=21, cex=3, lwd=3) # tomato2 is a personal fave lwd cex col plot(y, lwd=6, type='l')
points(y, bg=rainbow(10), pch=21, cex=seq(1, by=0.2, length.out=10), 
       lwd=seq(2, by=1, length.out=10))
-------------------------------------------------------------------------------------------------------
as.data.frame(cbind(.)) > data1
   subject post pre
1      S01  100  45
10     S10  100  40
9      S09  110  35
4      S04  120  75
3      S03   75  80
2      S02   80  60
5      S05   85  45
6      S06   90  60
8      S08   90  50
7      S07   95  55 data1 = data.frame(subject=subject, post=post, pre=pre)
data1 = data1[order(data1$post),]; 
plot(data1$pre,type="p",ylim=range(data1$pre,data1$post), 
      xaxt="n", ylab="Pre/Post Scores: black=Pre, red=Post")
points(data1$post,col='red')
axis(1, at=1:10, labels=levels(data1$subject)[order(post)]) axis(1, at=1:10, labels=as.character(data1$subject))) # since the set was sorted by `post`
-------------------------------------------------------------------------------------------------------
zx <- replicate (5, rnorm(50))
zx_means <- (colMeans(zx, na.rm = TRUE))
boxplot(zx, horizontal = FALSE, outline = FALSE)
points(zx_means, pch = 22, col = "darkgrey", lwd = 7)
-------------------------------------------------------------------------------------------------------
# Example data
library(xts)
data(sample_matrix)
x <- as.xts(sample_matrix)
# Example function
# Calculate the mean of the last 5 days of each month, returning
# an xts object indexed at the endpoint
myFunction <- function(i, y) xts(t(colMeans(y[(i-4):i,])), index(y)[i])
# Use lapply to call your function at each endpoint
# (removing first endpoint, since it equals zero) 
do.call(rbind, lapply(endpoints(x, 'months')[-1], FUN=myFunction, y=x))
-------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------
?legend plot(1:10,type = "n")
abline(v=seq(1,10,1), col='grey', lty='dotted')
legend(1, 5, "This legend text should not be disturbed by the dotted grey lines,\nbut the plotted dots should still be visible",box.lwd = 0,box.col = "white",bg = "white")
points(1:10,1:10) \n
-------------------------------------------------------------------------------------------------------
x = runif(100, min=-1, max=1)
y = runif(100, min=-1, max=1)
points(x,y) rndCircle <- function(n = 100, r=1) {
    scale <- 1.15 # Generate 15% more values than requested
    m <- matrix(0, 0, 2, dimnames=list(NULL, c('x','y')))
    lst <- list(m)
    nMore <- n
    while (nMore > 0) {
      #cat("nMore=", nMore, "\n") # uncomment to see how many iterations are needed

      m <- matrix(runif(floor(nMore*scale)*2, min=-1, max=1), ncol=2)
      m <- m[rowSums(m*m) <= 1, , drop=FALSE]
      nMore <- nMore - nrow(m)
      lst[[length(lst)+1L]] <- m
    }

    # Combine and truncate to desired length
    do.call(rbind, lst)[seq_len(n),]*r
}
# Measure performance
set.seed(42); system.time( rndCircle(1e6) ) # 0.19

# Compare to @Hans Werner's solution
set.seed(42); system.time( randp(1e6) )     # 0.26
-------------------------------------------------------------------------------------------------------
library(grid)

pdf("points.pdf", width=5, height=3)
grid.points(x <- runif(10), y <- runif(10), vp=dataViewport(x, y, extension = 0))
dev.off()
-------------------------------------------------------------------------------------------------------
i <- 1

x <- rep(NA, 20)
y <- rep(NA, 20)
q <- rep(NA, 20)
p <- rep(NA, 20)

while (i <= 20) {

repeat{
    z1=((runif(1,0,1)*2)-1)
    z2=((runif(1,0,1)*2)-1)
    h=z1**2+z2**2
if((h > 0) & (h <= 1)){break}
 }
x[i] <- z1
y[i] <- z2
q[i] <- h

i <- i + 1
} 

j <- 1
while (j <= 20) {

h=sqrt((-2*log(q[j]))/q[j])

p[j] <- h

j <- j + 1
}

a=x*p
b=y*p
plot(a,b)
points(a,b, pch=c(20,20),col=c("dark green","red"),cex=0.6)
-------------------------------------------------------------------------------------------------------
value<-rnorm(100,1000,200) ##create list of numbers, "scan()" may be used for real observations
nmbrs<-length(value) ## determine the length of vector
obrv<-1:length(value) ## create list of observations
par(xpd=FALSE)
sd1<-sd(value[1:20])*1 ## 1 standart deviation
sd2<-sd(value[1:20])*2 ## 2 standart deviations
sd3<-sd(value[1:20])*3 ## 3 standart deviations
usd1<-mean(value)+sd1 ## upper limit
lsd1<-mean(value)-sd1 ## lower limit
lsd2<-mean(value)-sd2 ## lower limit
usd2<-mean(value)+sd2 ## upper limit
usd3<-mean(value)+sd3 ## upper limit
lsd3<-mean(value)-sd3 ## lower limit

## ploting the grid
plot(obrv,value,type="n",xlab="Observations",ylab="Value",ylim=c(lsd3-sd1,usd3+sd1))
abline(h=mean(value),col=2,lty=1)
abline(h=usd1,col=3,lty=3)
abline(h=lsd1,col=3,lty=3)
abline(h=usd2,col=4,lty=2)
abline(h=lsd2,col=4,lty=2)
abline(h=usd3,col=6,lty=1)
abline(h=lsd3,col=6,lty=1)


## 20 first values for L-G chart for QC limits
for (i in 1:20) 
{
points(obrv[i],value[i],col="black")
}
lines(obrv[1:20],value[1:20],col="red")


## if over mean - "red", under mean - "blue"
for (i in 21:nmbrs) 
{
points(obrv[i],value[i],col="blue")
segments(obrv[i-1],value[i-1],obrv[i],value[i],col="blue")
}

# 1s points - blue; 2s points - red
#if (value[i]<usd1 || value[i]>lsd1) points(obrv[i],value[i],col="blue")
#if (value[i]>usd1 || value[i]<lsd1) points(obrv[i],value[i],col="red")

#12s violation rule
#if (value[i]>usd1 || value[i]<usd1) text(30, usd3, "12s violation")
#if (value[i]>usd1 || value[i]<usd1) text(30, usd3, "12s violation")
#segments(obrv[i-1],value[i-1],obrv[i],value[i],col="blue")
#if (value[i]>usd1) break
#}


#legend placement - might be omited
#legend(1,min(value)-sd1*0.2,bg=8,c("mean","sd1","sd2","sd3"),lty=c(1,3,2,1),lwd=c(2.5,2.5,2.5,2.5),col=c(2,3,4,6),cex=0.8)
-------------------------------------------------------------------------------------------------------
setwd("your working directory")

name <- "example" # Change this if you want

x <- data.frame(sapply(lx, "[", seq(max(sapply(lx, length)))))
len <- ncol(x)
colnames(x)[colnames(x) %in% names(which.min(apply(x, 2, function(x) length(na.omit(x)))))] <- "main.x"
colnames(x)[colnames(x) %in% names(which.max(apply(x, 2, function(x) length(na.omit(x)))))] <- "h.x"
colnames(x)[!colnames(x) %in% c("h.x", "main.x")]  <- c(paste("l", seq(1,len-2),".x", sep = ""))

y <- data.frame(sapply(ly, "[", seq(max(sapply(ly, length)))))
len <- ncol(y)
colnames(y)[colnames(y) %in% names(which.min(apply(y, 2, function(y) length(na.omit(y)))))] <- "main.y"
colnames(y)[colnames(y) %in% names(which.max(apply(y, 2, function(y) length(na.omit(y)))))] <- "h.y"
colnames(y)[!colnames(y) %in% c("h.y", "main.y")]  <- c(paste("l", seq(1,len-2),".y", sep = ""))

tab <- cbind(x,y)

write.table(tab, paste(name, ".txt", sep = ""), sep = "\t", row.names = F) df <- structure(list(h.x = c(1145L, 1095L, 1052L, 1004L, 958L, 909L, 
865L, 820L, 777L, 730L, 680L, 638L, 587L, 546L, 496L, 452L, 407L, 
359L, 312L, 265L, 219L, 174L, 140L, 99L, 61L, 27L), l1.x = c(1081L, 
1060L, 1047L, 1017L, 966L, 854L, 679L, NA, NA, NA, NA, NA, NA, 
NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA), l2.x = c(906L, 
865L, 807L, 735L, 668L, 509L, 360L, NA, NA, NA, NA, NA, NA, NA, 
NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA), l3.x = c(436L, 
407L, 341L, 298L, 215L, 56L, NA, NA, NA, NA, NA, NA, NA, NA, 
NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA), l4.x = c(391L, 
345L, 285L, 228L, 179L, 136L, 4L, NA, NA, NA, NA, NA, NA, NA, 
NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA), main.x = c(1169L, 
3L, 0L, 0L, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 
NA, NA, NA, NA, NA, NA, NA, NA, NA), l5.x = c(1158L, 1165L, 1167L, 
1165L, 1137L, 1106L, 1025L, 927L, 737L, 625L, 330L, 151L, 5L, 
NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA), l6.x = c(721L, 
594L, 531L, 398L, 270L, 205L, 135L, NA, NA, NA, NA, NA, NA, NA, 
NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA), h.y = c(267L, 
267L, 267L, 262L, 259L, 244L, 233L, 221L, 209L, 201L, 192L, 183L, 
180L, 173L, 168L, 164L, 162L, 159L, 157L, 162L, 161L, 177L, 217L, 
259L, 292L, 326L), l1.y = c(305L, 283L, 274L, 255L, 240L, 199L, 
128L, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 
NA, NA, NA, NA, NA), l2.y = c(293L, 268L, 248L, 221L, 199L, 135L, 
94L, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 
NA, NA, NA, NA, NA), l3.y = c(284L, 262L, 224L, 207L, 180L, 146L, 
NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 
NA, NA, NA, NA), l4.y = c(304L, 281L, 260L, 241L, 234L, 225L, 
218L, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 
NA, NA, NA, NA, NA), main.y = c(307L, 304L, 0L, 0L, NA, NA, NA, 
NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 
NA, NA, NA), l5.y = c(296L, 279L, 260L, 254L, 237L, 226L, 215L, 
179L, 109L, 77L, 53L, 49L, 60L, NA, NA, NA, NA, NA, NA, NA, NA, 
NA, NA, NA, NA, NA), l6.y = c(285L, 236L, 215L, 168L, 119L, 107L, 
98L, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 
NA, NA, NA, NA, NA)), .Names = c("h.x", "l1.x", "l2.x", "l3.x", 
"l4.x", "main.x", "l5.x", "l6.x", "h.y", "l1.y", "l2.y", "l3.y", 
"l4.y", "main.y", "l5.y", "l6.y"), class = "data.frame", row.names = c(NA, 
-26L)) ## Measurement of holes in relation to subannual lines

# List of packages needed to run the script

library(plyr)
library(reshape)
library(spatstat)

# Define magnification!

magnification <- 1 # µm/px. I use 1 in this example, because this was taken from jpg, which breaks the relationship. It's wrong to use jpg images in this type of work.

# Open the file

#df <- read.delim("example.txt") Untick this, if you didn't copy the example data frame

df <- data.frame(sapply(df, function(x){replace(x, x == 0, NA)}))  # Replace 0's with NA's since they're some weird relics)

df <- df*(1/magnification) # Convert the unit from pixel to µm

range.x <- c(0, max(df[,grep("x", colnames(df))], na.rm = T))
range.y <- c(0, max(df[,grep("y", colnames(df))], na.rm = T))
x.lim <- c(round_any(min(df[,grep("x", colnames(df))], na.rm = T), 10, floor), round_any(max(df[,grep("x", colnames(df))], na.rm = T), 10, ceiling))
y.lim <- c(round_any(min(df[,grep("y", colnames(df))], na.rm = T), 10, floor), round_any(max(df[,grep("y", colnames(df))], na.rm = T), 10, ceiling))

# Holes

x <- df$h.x
y <- df$h.y

owin <- owin(range.x, range.y, unitname = list("µm", "µm"))
holes <- ppp(x, y, marks = as.factor(seq(1, length(x))), window = owin)

#Lines

x <- df[,grep("x", grep("l", colnames(df), value = T), value = T)]
y <- df[,grep("y", grep("l", colnames(df), value = T), value = T)]
nlines <- ncol(x)
lines <- paste("l", seq(1, nlines), sep = "")

for(j in 1:nlines){
xx <- x[,j][!is.na(x[,j])]
yy <- y[,j][!is.na(y[,j])]
assign(paste("l", j, sep = ""), psp(x0 = xx[1:(length(xx)-1)], x1 = xx[2:length(xx)], y0 = yy[1:(length(yy)-1)], y1 = yy[2:length(yy)], marks =  rep(paste("l", j, sep = ""), (length(xx)-1)), window = owin))
}

a <- l1
for(j in 2:nlines){
a <- superimpose(a, get(lines[j]))}
l.all <- a

# Main axis

x <- df[,grep("x", grep("main", colnames(df), value = T), value = T)]
x <- x[!is.na(x)]
y <- df[,grep("y", grep("main", colnames(df), value = T), value = T)]
y <- y[!is.na(y)]

main <- psp(x0 = x[1], x1 = x[2], y0 = y[1], y1 = y[2], marks = c("main"), window = owin)

start <- ppp(x[1], y[1], marks = c("start"), window = owin)
end <- ppp(x[2], y[2], marks = c("end"), window = owin)

# Calculate the distance of lines from the main axis


tmp <- endpoints.psp(get(lines[1]))
tmp <- superimpose(tmp[1], tmp[npoints(tmp)])
pnt <- tmp[apply(nncross(tmp, main)[1],2, function(x) which.min(x))]
marks(pnt) <- lines[1]

for(j in 2:nlines){
tmp <- endpoints.psp(get(lines[j]))
tmp <- superimpose(tmp[1], tmp[npoints(tmp)])
pnt2 <- tmp[apply(nncross(tmp, main)[1],2, function(x) which.min(x))]
marks(pnt2) <- lines[j]
pnt <- superimpose(pnt, pnt2)}

int <- project2segment(pnt, main)$Xproj

tmp <- t(crossdist(int, start)) 
colnames(tmp) <- int$marks

p.1st <- int[int$marks == apply(tmp, 1, function(x) names(which.min(x)))] # First line is and origo for the main axis is...
l.1st <- l.all[l.all$marks == apply(tmp, 1, function(x) names(which.min(x)))] # First line means actually the line when the clam died

dist.lines <- data.frame(line = int$marks, dist0 = crossdist(int, p.1st))
dist.lines <- dist.lines[order(dist.lines$dist0),]

# Calculate shortest distance from a hole to 1st subaanual line

d <- data.frame(hole = holes$marks)
for(j in 1:nlines){
temp <- nncross(holes, get(lines[j]))
colnames(temp) <- c(lines[j], "which")
d <- cbind(d, temp[1])}

tp <- d[!colnames(d) %in% colnames(d)[1]]

d <- cbind(d, close1 = apply(tp, 1, function(x) names(which.min(x))))
d <- cbind(d, c.dist = apply(tp, 1, function(x) (min(x))))

d <- d[!colnames(d) %in% lines]

# Calculate if holes are occuring after or before a subannual line

d$dist.1st <- nncross(holes, l.1st)[,1] # Calculate distance of holes from the last growth line (when the clam died). 

tmp <- c()
for(j in 1:npoints(holes)){
tmp <- append(tmp, nncross(project2segment(holes[j], l.all[l.all$marks == d$close1[j]])$Xproj, l.1st)[,1])
}

d$dist.cross <- tmp # Distance from 1st line (see above) to a closest point from a hole along the closest line
d$location <- as.factor(ifelse(d$dist.1st >= d$dist.cross, "aft", "bef")) # Before / after subannual line

dat <- d

# Calculate points where the hole axis crosses subannual lines. This is needed for defining in which gap the holes lay

x <- coords(holes)$x
y <- coords(holes)$y
hole.line <- psp(x0 = x[1:length(x)-1], x1 = x[-1], y0 = y[1:length(y)-1], y1 = y[-1], window = owin)
line.cross <- crossing.psp(hole.line, get(lines[1]))
marks(line.cross) <- lines[1]

for(j in 2:nlines){
tmp <- crossing.psp(hole.line, get(lines[j]))
marks(tmp) <- lines[j]
line.cross <- superimpose(line.cross, tmp)}

lp.closestto.h1 <- project2segment(holes[1], get(unique(l.1st$marks)))$Xproj # 1st point
marks(lp.closestto.h1) <- unique(l.1st$marks)
line.cross <- superimpose(line.cross, lp.closestto.h1)

last <- holes[holes$marks==npoints(holes)] # Last point 
p.last <- project2segment(last, l.all[l.all$marks==dist.lines$line[which.max(dist.lines[,"dist0"])]])$Xproj
marks(p.last) <- dist.lines$line[which.max(dist.lines[,"dist0"])]
line.cross <- superimpose(line.cross, p.last)

# Calculate distance between line crossing points

dist <- data.frame()
for(j in 1:(nlines-1)){
p1 <- line.cross[line.cross$marks == as.character(dist.lines$line)[j]]
p2 <- line.cross[line.cross$marks == as.character(dist.lines$line)[j+1]]
if(all(npoints(p1)!=0, npoints(p2)!=0)){
tmp <- nncross(p1,p2)
tmp$points <- paste(as.character(dist.lines$line)[j], as.character(dist.lines$line)[j+1], sep = "-")
dist <- rbind(dist, tmp)}} # Along the hole axis

dist <- dist[!colnames(dist) %in% "which"]
colnames(dist) <- c("dist.gap", "gap")

dist2 <- data.frame()
for(j in 1:(nlines-1)){
p1 <- int[int$marks == as.character(dist.lines$line)[j]]
p2 <- int[int$marks == as.character(dist.lines$line)[j+1]]
if(all(npoints(p1)!=0, npoints(p2)!=0)){
tmp <- nncross(p1,p2)
tmp$points <- paste(as.character(dist.lines$line)[j], as.character(dist.lines$line)[j+1], sep = "-")
dist2 <- rbind(dist2, tmp)}} # Along the main axis

dist2 <- dist2[!colnames(dist2) %in% "which"]
colnames(dist2) <- c("dist.main", "gap.main")

dist <- merge(dist, dist2, by.x = "gap", by.y = "gap.main", all = T, sort = F) 
tmp <- merge(data.frame(gap = dist$gap, line = unlist(lapply(strsplit(dist$gap, "-"), function(x) x[1]))), dist.lines, by = "line", all.x = T, sort = F)
dist <- merge(dist, tmp, by = "gap", all.x = T, sort = F)
dist <- dist[!colnames(dist) %in% "line"]

# Calculate the gap where a hole is located

tmp <- c()
for(j in 1:length(dat$close1)){
tmp <- append(tmp, ifelse(dat$location[j] == "aft", grep(paste("\\", as.character(dat$close1[j]), "\\-", sep = ""), dist$gap, value = T), grep(paste("\\-", as.character(dat$close1[j]), sep = ""), dist$gap, value = T)))}
tmp[is.na(tmp)] <- "after"

dat$gap <- tmp

dat <- merge(dat, dist, by = "gap", all.x = T, sort = F)
dat <- dat[order(dat$hole),]

# Shortest distance to the 2nd subannual line

scnd <- c()
for(j in 1:length(dat$gap)){
scnd <- append(scnd, gsub("-", "", gsub(as.character(dat$close1)[j], "", dat$gap[j])))}

dat$close2 <- scnd

tmp <- data.frame()
for(j in 1:npoints(holes)){
if(as.character(dat$close2[j]) != "after") {tmp1 <- cbind(hole = j, c2 = nncross(holes[j], get(as.character(dat$close2[j]))))}
if(as.character(dat$close2[j]) == "after") {tmp1 <- cbind(hole = j, c2 = nncross(holes[j], last))}
tmp <- rbind(tmp, tmp1)}

tmp <- tmp[!colnames(tmp) %in% "c2.which"]

dat <- merge(dat, tmp, by = "hole", all.x = T, sort = F)
dat <- dat[order(dat$hole),]

# Calculate the distance of holes from crossing points

d <- data.frame()
for(j in 1:npoints(holes)){
temp <- data.frame(hole = j, nncross(holes[holes$marks==dat$hole[j]], line.cross[line.cross$marks==dat$close1[j]]))
d <- rbind(d, temp[c(1:2)])}
colnames(d) <- c("hole", "c1.dist.cross")

d2 <- data.frame()
for(j in 1:npoints(holes)){
temp <- data.frame(hole = j, nncross(holes[holes$marks==dat$hole[j]], line.cross[line.cross$marks==dat$close2[j]]))
d2 <- rbind(d2, temp[c(1:2)])}
colnames(d2) <- c("hole", "c2.dist.cross")

d <- merge(d,d2, by = "hole", sort = F)
dat <- merge(dat, d, by = "hole", sort = F)

dat$dist.ratio.cross <- ifelse(dat$location == "aft", dat$c1.dist.cross/(dat$c1.dist.cross + dat$c2.dist.cross), dat$c2.dist.cross/(dat$c1.dist.cross + dat$c2.dist.cross))
dat$dist.ratio.closest <- ifelse(dat$location == "aft", dat$c.dist/(dat$c.dist + dat$c2.dist), dat$c2.dist/(dat$c.dist + dat$c2.dist))

dat$distance.paral <- ifelse(dat$gap=="after", dat$dist0 + dat$c.dist, dat$dist0 + dat$dist.main*dat$dist.ratio.cross)

print <- dat[c("hole", "distance.paral")]
print 

# Plot

plot(coords(holes)[,1], coords(holes)[,2], main = gsub(".txt", "", files[i]), cex = 3, asp = 1,
axes = F, xlab = "x (µm)", ylab = "y (µm)", xlim = x.lim, ylim = y.lim)
plot(line.cross, chars = 19, col = "blue", add = T)
text(coords(holes)[,1], coords(holes)[,2], seq(1, npoints(holes)))
plot(l.all, col = "red", add = T)
plot(main, add = T, col = "purple")
text(coords(int)[,1], coords(int)[,2], int$marks, col = "blue")
text(coords(start)[,1], coords(start)[,2], start$marks, col = "dark green", cex = 1.2)
text(coords(end)[,1], coords(end)[,2], end$marks, col = "dark green", cex = 1.2)
x.new <- (print[,2]/crossdist(p.1st,end))* coords(end)$x + (1-(print[,2]/crossdist(p.1st,end)))* coords(p.1st)$x
y.new <- (print[,2]/crossdist(p.1st,end))* coords(end)$y + (1-(print[,2]/crossdist(p.1st,end)))* coords(p.1st)$y
text(x.new, y.new, print[,1], adj=c(0,0), font = 2, col = "purple")
axis(1)
axis(2, las = 2)
-------------------------------------------------------------------------------------------------------
fun <- function(i, d) {
  idx <- seq(d$start[i],d$end[i],1)    # create sequence for index
  dat <- rep(d$birate[i],length(idx))  # create data over sequence
  xts(dat, idx, dimnames=list(NULL,d$username[i]))  # xts object
}

# loop over each row and put each row into its own xts object
xl <- lapply(1:NROW(df), fun, d=df)
# merge all the xts objects
xx <- do.call(merge, xl)
# apply a function (e.g. colMeans) to each 15-minute period
xa <- period.apply(xx, endpoints(xx, 'minutes', 15), colMeans, na.rm=TRUE)
-------------------------------------------------------------------------------------------------------
my.data <- seq(0,5)
my.points <- seq(5,9)
plot(my.data, ylim=c(0,max(my.data,my.points)))
points(my.points) my.data <- seq(0,5)
my.points <- seq(5,9)
plot(my.data, ylim=c(min(my.data,my.points),max(my.data,my.points)))
points(my.points)
-------------------------------------------------------------------------------------------------------
rgeos gIsValid library(rgeos)
p4 = readWKT("POLYGON ((0 40, 0 0, 40 40, 40 0, 0 40))")
gIsValid(p4, reason = TRUE)
[1] "Self-intersection[20 20]" reason gIsValid(p4)
[1] FALSE
Warning message:
In RGEOSUnaryPredFunc(spgeom, byid, "rgeos_isvalid") :
  Self-intersection at or near point 20 20 plot(p4, col = "grey")
points(20, 20, pch = 3, cex = 3, col = "red")
axis(1);axis(2);box() byid library(maptools)
xx <- readShapePoly(system.file("shapes/sids.shp", package="maptools")[1],
  IDvar="FIPSNO", proj4string=CRS("+proj=longlat +ellps=clrk66"))
gIsValid(xx, byid = TRUE)
37001 37003 37005 37007 37009 37011 
 TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
...
-------------------------------------------------------------------------------------------------------
inset legend "topright" # Random data to plot:
A <- data.frame(x=rnorm(100, 20, 2), y=rnorm(100, 20, 2))
B <- data.frame(x=rnorm(100, 21, 1), y=rnorm(100, 21, 1))

# Add extra space to right of plot area; change clipping to figure
par(mar=c(5.1, 4.1, 4.1, 8.1), xpd=TRUE)

# Plot both groups
plot(y ~ x, A, ylim=range(c(A$y, B$y)), xlim=range(c(A$x, B$x)), pch=1,
               main="Scatter plot of two groups")
points(y ~ x, B, pch=3)

# Add legend to top right, outside plot region
legend("topright", inset=c(-0.2,0), legend=c("A","B"), pch=c(1,3), title="Group") inset=c(-0.2,0)
-------------------------------------------------------------------------------------------------------
par(new=TRUE) plot(bodysize,survive,xlab="Body size",ylab="Probability of survival") 
g=glm(survive~bodysize,family=binomial,dat)
curve(predict(g,data.frame(bodysize=x),type="resp"),add=TRUE)
points(bodysize,fitted(g),pch=20)
#then
par(new=TRUE)
#
plot(AggBd$Group.1,AggBd$x,pch=30) plot(AggBd$Group.1,AggBd$x,pch=30,xaxt="n",yaxt="n",xlab="",ylab="")
-------------------------------------------------------------------------------------------------------
par("mar")
par(mar = c(par("mar")[1:3], 5.1))

plot(x,y, type="n", lwd=4, ylab="", xlab="threshold", xaxt="n",yaxt="n")

axis(1,lwd=4)
axis(2,lwd=4)

points(x, y, col="red", cex=2, pch=19)
abline(h=w, col="red", lwd=4)

par("usr")
par(usr = c(par("usr")[1:2], 80,90))

axis(4, lwd=4)
points(x, z, col="blue", cex=2, pch=19)
points(x, z, type="l", lwd=4)
abline(h=v, col="blue", lwd=4)

mtext("Your text", side = 4, col = "blue",line=3)
mtext("seconds", side = 2, col = "red",line=3)
-------------------------------------------------------------------------------------------------------
plot gcFitSpline str(growth) plot.gcFitSpline growth = gcFitSpline(grofit$year, grofit$ipen)

plot (grofit$year, grofit$ipen, pch=20, cex=0.8, col="gray", ylim=c(0, 100),
     ylab="Growth", xlab="Year", las=1)
points(growth$fit.time, growth$fit.data, t="l", lwd=2)
-------------------------------------------------------------------------------------------------------
par(mar=c(4,5,1,1))
 plot(rnorm(30), xlab= "Big font", ylab = "Big font", cex.lab = 2, cex.axis = 1.5) par(mar=c(5,5,4,1))
plot(rnorm(30), xlab= "Big font", ylab = "Big font", 
    cex.lab = 2, cex.axis = 1.5, cex.main=3, main="Big Font") a = rnorm(30)
par(mar=c(5,5,4,1))
plot(a, xlab= "Big font", ylab = "Big font", type="n",
     cex.lab = 2, cex.axis = 1.5, cex.main=3, main="Big Font")
x <- par("usr")
rect(x[1], x[3], x[2], x[4], col = "grey")
points(a, pch=19)
-------------------------------------------------------------------------------------------------------
library(xts)
tab <-read.table(text="UploadDateGMT,UserFileSize,TotalBusinessUnits
'2012-01-01 00:00:38',1223,1
'2012-01-01 00:01:16',1302,1
'2012-01-01 00:08:10',1302,1", header=TRUE, as.is=TRUE,sep = ",")

tab2<-xts(tab$UserFileSize,order.by=as.POSIXct(tab$UploadDateGMT) ) #create xts object
endp <-endpoints(tab2, on="mins", k=5) #5 minutes endpoints
fivemin <-period.apply(tab2,endp,sum) #sum per 5-minute period
fivemin

                    [,1]
2012-01-01 00:01:16 2525
2012-01-01 00:08:10 1302 res<- align.time( fivemin[endpoints(fivemin, on="mins", k=5)], n=60*5)
-------------------------------------------------------------------------------------------------------
endp <- endpoints(tab2, on="mins", k=1) # 1 minute endpoints
onemin <- period.apply(tab2,endp,sum)   # sum per 1-minute period
onemin <- align.time(onemin)            # align to end-of-period times
# all one-minute increments from start--end of onemin
allonemin <- seq(start(onemin), end(onemin), by="1 min")
onemin <- merge(onemin, xts(,allonemin))
fivemin <-  rollapplyr(onemin, 5, sum, na.rm=TRUE, fill=NA)
-------------------------------------------------------------------------------------------------------
library(lattice)
d = data.frame(x=c(rnorm(90),20*runif(16)),group=letters[1:2])
cols = list(col=c("red","blue"),pch=c(1,16,13))
bwplot(group~x,data=d,  
       par.settings = list(
                           plot.symbol=cols,
                           box.rectangle = cols,
                           box.dot = cols,
                           box.umbrella=cols 
                           )) panel.points(x = rep(levels.fos, sapply(blist.out, length)), 
             y = unlist(blist.out), pch = plot.symbol$pch, col = plot.symbol$col, 
             alpha = plot.symbol$alpha, cex = plot.symbol$cex, 
             fontfamily = plot.symbol$fontfamily, ......
-------------------------------------------------------------------------------------------------------
trip tripGrid SpatialGridDataFrame sp rgdal speedfilter sp tripGrid pixellate.psp trip ?trip library(trip)
d <- data.frame(x = 1:10, y = rnorm(10), tms = Sys.time() + 1:10, id = gl(1, 5))
coordinates(d) <- ~x+y
tr <- trip(d, c("tms", "id"))
g <- tripGrid(tr)

pt <- coordinates(g)[which.max(g$z), ]
image(g, col = c("transparent", heat.colors(16)))
lines(tr, col = "black")
points(pt[1], pt[2], pch = "+", cex = 2)
-------------------------------------------------------------------------------------------------------
points(ztest[ztest$group=="g",]$x,ztest[ztest$group=="g",]$y,col=ztest$color, ... points(ztest[ztest$group=="g",]$x,ztest[ztest$group=="g",]$y,col=as.character(ztest[ztest$group=="g",]$color), ....
-------------------------------------------------------------------------------------------------------
split(dxts, "days") lapply set.seed(123)
full <- .xts(rnorm(2880), 1:2880*5*60)
mrv <- lapply(split(full, "days"), function(x) {
    #return an xts-object, which requires a timeBased index
    xts(MedRV(x), end(x)) #use the last timestamp of the day
}) rbind do.call(rbind, mrv)
#                         [,1]
# 1969-12-31 23:55:00  58.2340
# 1970-01-01 23:55:00 268.5672
# 1970-01-02 23:55:00 260.3016
# 1970-01-03 23:55:00 310.5664
# 1970-01-04 23:55:00 302.1562
# 1970-01-05 23:55:00 272.9567
# 1970-01-06 23:55:00 291.0333
# 1970-01-07 23:55:00 309.7571
# 1970-01-08 23:55:00 229.9853
# 1970-01-09 23:55:00 298.3878
# 1970-01-10 18:00:00 215.6014 mrv <- lapply(split(full, "days"), MedRV)
names(mrv) <- index(full)[endpoints(full, on="days")]
as.xts(do.call(rbind, mrv))
-------------------------------------------------------------------------------------------------------
period.apply apply.daily period.apply sapply lapply set.seed(123)
full <- .xts(rnorm(2880), 1:2880*5*60)
ddx.f = endpoints(full, on="days")
period.apply(full, ddx.f, MedRV)

apply.daily(full, MedRV) # same as period.apply but, endpoints are created for you
#                         [,1]
# 1969-12-31 23:55:00  58.2340
# 1970-01-01 23:55:00 268.5672
# 1970-01-02 23:55:00 260.3016
# 1970-01-03 23:55:00 310.5664
# 1970-01-04 23:55:00 302.1562
# 1970-01-05 23:55:00 272.9567
# 1970-01-06 23:55:00 291.0333
# 1970-01-07 23:55:00 309.7571
# 1970-01-08 23:55:00 229.9853
# 1970-01-09 23:55:00 298.3878
# 1970-01-10 18:00:00 215.6014
-------------------------------------------------------------------------------------------------------
jitter plot(b1$dist1, b1$e1, col="blue",type="p", pch=20, cex=.5)
points(b1$dist2, jitter(b1$e2), col="blue", pch=22)
-------------------------------------------------------------------------------------------------------
data.frame getSymbols("SPY", src='yahoo', from='2012-05-01', to='2012-06-15',
           return.class='data.frame')
#"SPY" apply.weekly apply.weekly(SPY, mean) apply mean apply.weekly(SPY, function(x) apply(x, 2, mean))
#           SPY.Open SPY.High SPY.Low SPY.Close SPY.Volume SPY.Adjusted
#2012-05-04 139.6425 140.4675 138.750  139.3275  149400050     138.6075
#2012-05-11 135.9480 136.9320 135.338  136.2040  173105700     135.5020
#2012-05-18 133.3000 133.9180 132.036  132.1760  229282720     131.4960
#2012-05-25 131.7660 132.6800 130.896  132.2140  176634780     131.5340
#2012-06-01 131.7100 132.8925 130.290  131.2725  191170200     130.5950
#2012-06-08 130.2780 131.3380 129.584  130.8580  175917220     130.1820
#2012-06-15 132.8420 133.7760 131.828  132.8020  184751180     132.2540 apply.weekly period.apply period.apply(SPY, endpoints(SPY, "weeks"), FUN=function(x) apply(x, 2, mean))
-------------------------------------------------------------------------------------------------------
points(Var$Lon, Var$Lat, col="grey25")
-------------------------------------------------------------------------------------------------------
plot(x=rep(x_mean, 3), y=c(y_mean, y_max, y_min), bty='n', type="n" )
rect(2,-4,4,4,col = rgb(0.5,0.5,0.5,1/4))
arrows(x0=x_mean, y0=y_min, x1=x_mean, y1=y_max, length=0)
points( x=x_mean, y=y_mean, pch=16) rgb rect
-------------------------------------------------------------------------------------------------------
.index(x) <- .index(x) - 1
align.time(period.sum(x, endpoints(x,"mins",k=5)))
                [,1]
2011-12-15 05:15:00  0.0
2011-12-15 05:20:00  0.0
2011-12-15 05:25:00  0.1
2011-12-15 05:30:00  1.2
2011-12-15 05:35:00  1.0
2011-12-15 05:40:00  0.6
2011-12-15 05:45:00  0.0
2011-12-15 05:50:00  0.1 sum(data_prec)  # the sample data you gave (well, not really gave in reproducible form)
[1] 3.0

# your addition
0.1 + 1.2 + 1 + 0.7 + .1
[1] 3.1
-------------------------------------------------------------------------------------------------------
xts dat <- read.table(text="2011-10-24 01:00:00                  12
2011-10-24 02:00:00                  4
2011-10-24 19:00:00                  18
2011-10-24 20:00:00                  7
2011-10-24 21:00:00                  4
2011-10-24 22:00:00                  2
2011-10-25 00:00:00                  4
2011-10-25 01:00:00                  2
2011-10-25 02:00:00                  2
2011-10-25 15:00:00                  12
2011-10-25 18:00:00                  2
2011-10-25 19:00:00                  3
2011-10-25 21:00:00                  2
2011-10-25 23:00:00                  9
2011-10-26 00:00:00                  13
2011-10-26 01:00:00                  11", header=FALSE, stringsAsFactors=FALSE)

xobj <- xts(dat[, 3], as.POSIXct(paste(dat[, 1], dat[, 2]))) xobj["2011-10-25"]
#                    [,1]
#2011-10-25 00:00:00    4
#2011-10-25 01:00:00    2
#2011-10-25 02:00:00    2
#2011-10-25 15:00:00   12
#2011-10-25 18:00:00    2
#2011-10-25 19:00:00    3
#2011-10-25 21:00:00    2
#2011-10-25 23:00:00    9 xobj["2011-10-24/2011-10-25"] xobj["2011-10"] xobj['T19:00:00/T20:00:00']
#                    [,1]
#2011-10-24 19:00:00   18
#2011-10-24 20:00:00    7
#2011-10-25 19:00:00    3 endpoints endpoints(xobj, "days")
[1]  0  6 14 16 to.weekly(xobj)
#           xobj.Open xobj.High xobj.Low xobj.Close
#2011-10-26        12        18        2         11
to.daily(xobj)
#           xobj.Open xobj.High xobj.Low xobj.Close
#2011-10-25        12        18        2          2
#2011-10-26         4        12        2          9
#2011-10-26        13        13       11         11 OHLC=FALSE to.daily(xobj, OHLC=FALSE)
#           [,1]
#2011-10-25    2
#2011-10-26    9
#2011-10-26   11 split.xts split(xobj, 'days') #create a list where each element is the data for a different day
#[[1]]
#                    [,1]
#2011-10-24 01:00:00   12
#2011-10-24 02:00:00    4
#2011-10-24 19:00:00   18
#2011-10-24 20:00:00    7
#2011-10-24 21:00:00    4
#2011-10-24 22:00:00    2
#
#[[2]]
#                    [,1]
#2011-10-25 00:00:00    4
#2011-10-25 01:00:00    2
#2011-10-25 02:00:00    2
#2011-10-25 15:00:00   12
#2011-10-25 18:00:00    2
#2011-10-25 19:00:00    3
#2011-10-25 21:00:00    2
#2011-10-25 23:00:00    9
#
#[[3]]
#                    [,1]
#2011-10-26 00:00:00   13
#2011-10-26 01:00:00   11 split lapply first rbind do.call(rbind, lapply(split(xobj, 'days'), first))
#                    [,1]
#2011-10-24 01:00:00   12
#2011-10-25 00:00:00    4
#2011-10-26 00:00:00   13
-------------------------------------------------------------------------------------------------------
> par(xpd=TRUE)
> x = c(1:10)
> y = c(1:10)
> plot(x,y)
> points(11, 7, pch = 8)
-------------------------------------------------------------------------------------------------------
x=c(61,610,1037,2074,3050,4087,5002,6100,7015)
y=c(0.974206,1.16716,1.19879,1.28192,1.30739,1.32019,1.35494,1.36941,1.37505)

Estimate = lm(y ~ x)
logEstimate = lm(y ~ log(x))

plot(x,predict(Estimate),type='l',col='blue')
lines(x,predict(logEstimate),col='red')
points(x,y) log y = log(x) exp(y) = x x y
-------------------------------------------------------------------------------------------------------
plot(info$lon, info$lat, xlim=c(0,30), ylim=c(30,60)) temp1 <- info$lon
temp2 <- info$lat
for (i in c(1:length(allDates))){
        filename=paste(sprintf('%05d', i), ".png", sep="")  
        png(filename=fileName)
        plot(temp1, temp2, xlim=c(0,30), ylim=c(30,60))
        # (code that gets the data for a particular date via a database query)
        points(info$lon, info$lat, cex=0.1)
        dev.off()
        temp1 <- c(temp1,info$lon)
        temp2 <- c(temp2,info$lat)
}
-------------------------------------------------------------------------------------------------------
x = seq(0, 20, 0.1)

par(mfrow=c(2, 1))

plot(x, x^2, pch=1, main="Before")
points(x, x*10, pch=2)

plot(x, x^2, pch=c(1, rep(NA, 9)), main="After")
points(x, x*10, pch=c(2, rep(NA, 9)))
-------------------------------------------------------------------------------------------------------
to.minute() k=60
...
bars=to.period(x,k,period="secs")
colnames(bars)=c("Open","High","Low","Close")
ep=endpoints(x,"secs",k)
bars$Volume=period.apply(x,ep,length)
bars$mean=period.apply(x,ep,mean)
bars$sd=period.apply(x,ep, function(x){apply(x,2,sd)})
align.time(bars,k)  #Do this last align.time align.time.down align.time.down=function(x,n){index(x)=index(x)-n;align.time(x,n)} full_index=do.call("c",mapply(
    seq.exclude_final_period.POSIXt,period_from,period_to,by=k,SIMPLIFY=F
    ))
bars=merge(bars,xts(,full_index),all=TRUE) seq.exclude_final_period.POSIXt #' Helper for process_one_day_of_ticks(); intended as a
#' replacement for seq.POSIXt (which will not exclude the final period).
#' @internal Use from=from+by instead of to=to-by to exclude the
#      first period instead.
seq.exclude_final_period.POSIXt=function(from,to,by){
to=to-by    #Make the final entry exclusive
seq(from,to,by)
} period_from period_to POSIXct
-------------------------------------------------------------------------------------------------------
color_foo <- colorRampPalette(c('lightblue','darkblue'))
colors <- color_foo(3)

plot(range(data.df[,3]), range(data.df[,4]),
        xlab="Axis 1",ylab="Axis 2",type = "n")
points(data.df$Axis1,data.df$Axis2,pch=c(3,4)[data.df$Plant],col = colors[data.df$Type])
legend("topright",legend=c("Plant1","Plant2"),pch = 3:4)
legend("bottomright",legend=c("Type1","Type2","Type3"),
        pch = 20,col = colors)
-------------------------------------------------------------------------------------------------------
ternaryplot a<- c (0.1, 0.5, 0.5, 0.6, 0.2, 0, 0, 0.004166667, 0.45) 
b<- c (0.75,0.5,0,0.1,0.2,0.951612903,0.918103448,0.7875,0.45)
c<- c (0.15,0,0.5,0.3,0.6,0.048387097,0.081896552,0.208333333,0.1) 
d<- c (500,2324.90,2551.44,1244.50, 551.22,-644.20,-377.17,-100, 2493.04) 
df<- data.frame (a, b, c)


# First create the limit of the ternary plot:
plot(NA,NA,xlim=c(0,1),ylim=c(0,sqrt(3)/2),asp=1,bty="n",axes=F,xlab="",ylab="")
segments(0,0,0.5,sqrt(3)/2)
segments(0.5,sqrt(3)/2,1,0)
segments(1,0,0,0)
text(0.5,(sqrt(3)/2),"c", pos=3)
text(0,0,"a", pos=1)
text(1,0,"b", pos=1)

# The biggest difficulty in the making of a ternary plot is to transform triangular coordinates into cartesian coordinates, here is a small function to do so:
tern2cart <- function(coord){
    coord[1]->x
    coord[2]->y
    coord[3]->z
    x+y+z -> tot
    x/tot -> x  # First normalize the values of x, y and z
    y/tot -> y
    z/tot -> z
    (2*y + z)/(2*(x+y+z)) -> x1 # Then transform into cartesian coordinates
    sqrt(3)*z/(2*(x+y+z)) -> y1
    return(c(x1,y1))
    }

# Apply this equation to each set of coordinates
t(apply(df,1,tern2cart)) -> tern

# Intrapolate the value to create the contour plot
resolution <- 0.001
require(akima)
interp(tern[,1],tern[,2],z=d, xo=seq(0,1,by=resolution), yo=seq(0,1,by=resolution)) -> tern.grid

# And then plot:
image(tern.grid,breaks=c(-1000,0,500,1000,1500,2000,3000),col=rev(heat.colors(6)),add=T)
contour(tern.grid,levels=c(-1000,0,500,1000,1500,2000,3000),add=T)
points(tern,pch=19)
-------------------------------------------------------------------------------------------------------
triplot #First draw the empty ternary diagram:
plot(NA,NA,xlim=c(0,1),ylim=c(0,sqrt(3)/2),asp=1,bty="n",axes=F,xlab="",ylab="")
segments(0,0,0.5,sqrt(3)/2)
segments(0.5,sqrt(3)/2,1,0)
segments(1,0,0,0)

text(0,0,labels="1, 2 or 3",pos=1)
text(1,0,labels="6",pos=1)
text(0.5,sqrt(3)/2,labels="4 or 5",pos=3)

#The following function is for transforming ternary coordinates into cartesian coordinates:
tern2cart <- function(coord){
    coord[1]->x
    coord[2]->y
    coord[3]->z
    x+y+z->tot
    x/tot -> x
    y/tot -> y
    z/tot -> z
    (2*y + z)/(2*(x+y+z)) -> x1
    sqrt(3)*z/(2*(x+y+z)) -> y1
    return(c(x1,y1))
    }

#Here are your zones:
green.zone<-matrix(c(0,0,100,40,0,60,0,40,60,0,0,100),nrow=4,byrow=TRUE)
blue.zone<-matrix(c(30,10,60,30,40,30,0,70,30,0,40,60,30,10,60),nrow=5,byrow=TRUE)
purple.zone<-matrix(c(90,0,10,100,0,0,30,70,0,30,40,30,50,40,10,90,0,10),nrow=6,byrow=TRUE)
red.zone<-matrix(c(30,40,30,30,70,0,0,100,0,0,70,30,30,40,30),nrow=5,byrow=TRUE)
yellow.zone<-matrix(c(90,0,10,40,0,60,30,10,60,30,40,30,50,40,10,90,0,10),nrow=6,byrow=TRUE)

#Then transformed into cartesian coordinates:
t(apply(green.zone,1,tern2cart))->green
t(apply(blue.zone,1,tern2cart))->blue
t(apply(purple.zone,1,tern2cart))->purple
t(apply(red.zone,1,tern2cart))->red
t(apply(yellow.zone,1,tern2cart))->yellow

#And plotted:
polygon(green,col="green",border=NULL)
polygon(blue,col="blue",border=NULL)
polygon(purple,col="purple",border=NULL)
polygon(red,col="red",border=NULL)
polygon(yellow,col="yellow",border=NULL)

#And finally the grid:
a<-seq(0.9,0.1, by=-0.1)
b<-rep(0,9)
c<-seq(0.1,0.9,by=0.1)
grid<-data.frame(x=c(a, b, c, a, c, b),y=c(b, c, a, c, b, a),z=c(c, a, b, b, a, c))
t(apply(grid,1,tern2cart)) -> grid.tern
cbind(grid.tern[1:27,],grid.tern[28:54,])->grid
apply(grid,1,function(x){segments(x0=x[1],y0=x[2],x1=x[3],y1=x[4],lty=2,col="grey80")}) paste(seq(10,90,by=10),"%")->lab
text(grid.tern[9:1,],paste(lab,"\n(1, 2 or 3)"),col="grey80",cex=0.7, pos=2)
text(grid.tern[18:10,],paste(lab,"\n(4 or 5)"),col="grey80",cex=0.7, pos=4)
text(grid.tern[27:19,],paste(lab,"\n(6)"),col="grey80",cex=0.7, pos=1) df<-data.frame('1, 2 or 3'=c(10,33.3,50,100), '6'=c(0,33.3,50,0), '4 or 5'=c(90,33.3,0,0))
df
  X1..2.or.3   X6 X4.or.5
1       10.0  0.0    90.0
2       33.3 33.3    33.3
3       50.0 50.0     0.0
4      100.0  0.0     0.0

t(apply(df, 1, tern2cart)) -> df.tern
points(df.tern, pch="*", cex=3)
-------------------------------------------------------------------------------------------------------
#required function from www.menugget.blogspot.com
matrix.poly <- function(x, y, z=mat, n=NULL){
 if(missing(z)) stop("Must define matrix 'z'")
 if(missing(n)) stop("Must define at least 1 grid location 'n'")
 if(missing(x)) x <- seq(0,1,,dim(z)[1])
 if(missing(y)) y <- seq(0,1,,dim(z)[2])
 poly <- vector(mode="list", length(n))
 for(i in seq(n)){
  ROW <- ((n[i]-1) %% dim(z)[1]) +1
  COL <- ((n[i]-1) %/% dim(z)[1]) +1

  dist.left <- (x[ROW]-x[ROW-1])/2
  dist.right <- (x[ROW+1]-x[ROW])/2
  if(ROW==1) dist.left <- dist.right
  if(ROW==dim(z)[1]) dist.right <- dist.left

  dist.down <- (y[COL]-y[COL-1])/2
  dist.up <- (y[COL+1]-y[COL])/2
  if(COL==1) dist.down <- dist.up
  if(COL==dim(z)[2]) dist.up <- dist.down

  xs <- c(x[ROW]-dist.left, x[ROW]-dist.left, x[ROW]+dist.right, x[ROW]+dist.right)
  ys <- c(y[COL]-dist.down, y[COL]+dist.up, y[COL]+dist.up, y[COL]-dist.down)
  poly[[i]] <- data.frame(x=xs, y=ys)
 }
 return(poly)
}

#make vector of grids for hatching
incl <- which(over==1)

#make polygons for each grid for hatching
polys <- matrix.poly(1:12, 1:6, z=over, n=incl)

    #plot
png("hatched_image.png")
image(1:12, 1:6, data)
for(i in seq(polys)){
    polygon(polys[[i]], density=10, angle=45, border=NA)
    polygon(polys[[i]], density=10, angle=-45, border=NA)
}
box()
dev.off() png("hatched_image2.png")
image(1:12, 1:6, data)
for(i in seq(polys)){
    xran <- range(polys[[i]]$x)
    yran <- range(polys[[i]]$y)
    xs <- seq(xran[1], xran[2],,5)
    ys <- seq(yran[1], yran[2],,5)
    grd <- expand.grid(xs,ys)
    points(grd, pch=19, cex=0.5)
}
box()
dev.off()
-------------------------------------------------------------------------------------------------------
?image data(volcano)
m <- volcano
dimx <- nrow(m)
dimy <- ncol(m)

d1 <- list(x = seq(0, 1, length = dimx), y = seq(0, 1, length = dimy), z = m) image() d2 <- d1
d2$z <- d2$z > 155 pts <- expand.grid(x = d2$x, y = d2$y)
pts$over <- as.vector(d2$z) op <- par(mfcol = c(2, 1))
image(d1)

image(d1)
points(pts$x[pts$over], pts$y[pts$over], cex = 0.7)

par(op) pch = "."
-------------------------------------------------------------------------------------------------------
library(grid)

d <- data.frame(x=c(0.5,0.52),y=c(0.6,0.6), fill=c("blue","red"),
                stringsAsFactors=FALSE)

grid.newpage()
with(d,grid.points(x,y,def='npc', pch=21,gp=gpar(cex=5, fill=fill)))
with(d[c(2,1),], 
grid.points(x,y-0.2,def='npc', pch=21,gp=gpar(cex=5, fill=fill))) library(ggplot2)
library(plyr)
df <- diamonds[order(diamonds$price, decreasing=TRUE), ]
# alternative with plyr
df <- arrange(diamonds, desc(price))
last_plot() %+% df
-------------------------------------------------------------------------------------------------------
plot(NA,NA,xlim=c(0,1),ylim=c(0,1),asp=1,bty="n",axes=F,xlab="",ylab="")
segments(0,0,0.5,sqrt(3)/2)
segments(0.5,sqrt(3)/2,1,0)
segments(1,0,0,0)
# sm - how smooth the plot is. Higher values will plot very slowly
sm <- 500
for (y in 1:(sm*sqrt(3)/2)/sm){
    for (x in (y*sm/sqrt(3)):(sm-y*sm/sqrt(3))/sm){
        ## distance from base line:
        d.red = y
        ## distance from line y = sqrt(3) * x:
        d.green = abs(sqrt(3) * x - y) / sqrt(3 + 1)
        ## distance from line y = - sqrt(3) * x + sqrt(3):
        d.blue = abs(- sqrt(3) * x - y + sqrt(3)) / sqrt(3 + 1)
        points(x, y, col=rgb(1-d.red,1 - d.green,1 - d.blue), pch=19)
    }
} d.red d.green d.blue colorRamp sm plot(NA,NA,xlim=c(0,1),ylim=c(0,1),asp=1,bty="n",axes=F,xlab="",ylab="")
sm <- 500
x <- do.call(c, sapply(1:(sm*sqrt(3)/2)/sm, 
                       function(i) (i*sm/sqrt(3)):(sm-i*sm/sqrt(3))/sm))
y <- do.call(c, sapply(1:(sm*sqrt(3)/2)/sm, 
                       function(i) rep(i, length((i*sm/sqrt(3)):(sm-i*sm/sqrt(3))))))
d.red = y
d.green = abs(sqrt(3) * x - y) / sqrt(3 + 1)
d.blue = abs(- sqrt(3) * x - y + sqrt(3)) / sqrt(3 + 1)
points(x, y, col=rgb(1-d.red,1 - d.green,1 - d.blue), pch=19)
-------------------------------------------------------------------------------------------------------
plot(1:5, df$var1, pch=19, col="blue", ylim=c(0,80))
points(1:5, df$var2, pch=19, col="red")
-------------------------------------------------------------------------------------------------------
grDevices recordPlot() replayPlot() require(animation)
x <- seq(-1,1,length=20)
y <- x^2
plot(x,y,type="l")
oopts <- ani.opts(interval=0.25)
p <- recordPlot()   # <== Record plot here =============
ani.record(reset=TRUE)
t <- seq(0,4*pi,by=pi/30)

for (i in 1:length(t)) {
  replayPlot(p)     # <== Replay plot here =============
  points(sin(t[i]),sin(t[i])^2,pch=19,cex=2)
}
ani.replay()
-------------------------------------------------------------------------------------------------------
draw.ellipse plotrix RSiteSearch("ellipse", restrict="functions") ellipse <- function(xf1, yf1, xf2, yf2, k, new=TRUE,...){
    # xf1 and yf1 are the coordinates of your focus F1
    # xf2 and yf2 are the coordinates of your focus F2
    # k is your constant (sum of distances to F1 and F2 of any points on the ellipse)
    # new is a logical saying if the function needs to create a new plot or add an ellipse to an existing plot.
    # ... is any arguments you can pass to functions plot or lines (col, lwd, lty, etc.)
    t <- seq(0, 2*pi, by=pi/100)  # Change the by parameters to change resolution
    k/2 -> a  # Major axis
    xc <- (xf1+xf2)/2
    yc <- (yf1+yf2)/2  # Coordinates of the center
    dc <- sqrt((xf1-xf2)^2 + (yf1-yf2)^2)/2  # Distance of the foci to the center
    b <- sqrt(a^2 - dc^2)  # Minor axis
    phi <- atan(abs(yf1-yf2)/abs(xf1-xf2))  # Angle between the major axis and the x-axis
    xt <- xc + a*cos(t)*cos(phi) - b*sin(t)*sin(phi)
    yt <- yc + a*cos(t)*sin(phi) + b*sin(t)*cos(phi)
    if(new){ plot(xt,yt,type="l",...) }
    if(!new){ lines(xt,yt,...) }
    } F1 <- c(2,3)
F2 <- c(1,2)
plot(rbind(F1, F2), xlim=c(-1,5), ylim=c(-1, 5), pch=19)
abline(h=0, v=0, col="grey90")
ellipse(F1[1], F1[2], F2[1], F2[2], k=2, new=FALSE, col="red", lwd=2)
points((F1[1]+F2[1])/2, (F1[2]+F2[2])/2, pch=3)
-------------------------------------------------------------------------------------------------------
txta txtb text set.seed(1)
tmp <- matrix(replicate(4, rnorm(50)), ncol=4)
panel.cor <- function(x, y, digits=2, prefix="", cex.cor, ...)
{
  usr <- par("usr"); on.exit(par(usr))
  par(usr = c(0, 1, 0, 1))
  rp <- cor(x, y, method="pearson", use="pairwise.complete.obs")
  rs <- cor(x, y, method="spearman", use="pairwise.complete.obs")
  rp <- format(rp, digits=digits)
  rs <- format(rs, digits=digits)
  txt <- substitute(list(R[p] == rp, R[s] == rs), list(rp=rp, rs=rs))
  txta <- substitute(R[p] == rp, list(rp=rp))
  txtb <- substitute(R[s] == rs, list(rs=rs))
  if(missing(cex.cor)) cex.cor <- 0.8/strwidth(txt)
  text(0.5, 0.6, txta, cex = 1.5)
  text(0.5, 0.4, txtb, cex = 1.5)
}
panel.my.points <- function(x, y) {
  points(x, y)
  abline(0, 1)
}
pairs(tmp, 
      lower.panel=panel.cor, 
      upper.panel=panel.my.points, 
      labels=c("model 1\nD1", "model 2\nD1", "model 1\nD2", "model 2\nD2"))
-------------------------------------------------------------------------------------------------------
lapply for rollapply getSymbols("SPY", src='yahoo', from='2012-01-01', to='2012-08-01')
idx <- index(SPY)[endpoints(SPY, 'months')]
out <- lapply(idx, function(i) {
  as.xts(rollapplyr(as.zoo(SPY[paste0("/", i)]), 5, 
                    function(x) coef(lm(x[, 4] ~ x[, 1]))[2], by.column=FALSE))
})
sapply(out, NROW)
#[1]  16  36  58  78 100 121 142 143 zoo rollapplyr rollapply.zoo rollapply.xts xts
-------------------------------------------------------------------------------------------------------
radarchart require(fmsb)
x = c(rep(4.5,7),rep(0,7), 
      3.34, 3.28, 1.37, 1.12, 3.52, 4.07, 3.66)
a = as.data.frame(matrix(x,nrow=3, ncol=7,byrow=T))
radarchart(a, axistype = 4, seg = 3, cglty = 3, 
           pty = 32, cglcol = 1, plwd = 3, pcol = 1, axislabcol = 1,
           labels = seq(from = min(x), to = max(x), length = 4)) radarchart = function (df, axistype = 0, seg = 4, pty = 16, pcol = 1:8, plty = 1:6, 
          plwd = 1, cglty = 3, cglwd = 1, cglcol = "navy", axislabcol = "blue", 
          title = "", maxmin = TRUE, na.itp = TRUE, labels = NULL, ...) 
{
  if (!is.data.frame(df)) {
    cat("The data must be given as dataframe.\n")
    return()
  }
  if ((n <- length(df)) < 3) 
    return()
  if (maxmin == FALSE) {
    dfmax <- apply(df, 2, max)
    dfmin <- apply(df, 2, min)
    df <- rbind(dfmax, dfmin, df)
  }
  plot(c(-1.2, 1.2), c(-1.2, 1.2), type = "n", frame.plot = FALSE, 
       axes = FALSE, xlab = "", ylab = "", main = title, asp = 1, 
       ...)
  theta <- seq(90, 450, length = n + 1) * pi/180
  theta <- theta[1:n]
  xx <- cos(theta)
  yy <- sin(theta)
  for (i in 0:seg) {
    polygon(xx * (i + 1)/(seg + 1), yy * (i + 1)/(seg + 1), 
            lty = cglty, lwd = cglwd, border = cglcol)
    if (axistype == 1 | axistype == 3) 
     ## Changes by me  
     if(is.null(labels)) labels = paste(i/seg * 100, 
                                         "(%)")
      text(-0.05, (i + 1)/(seg + 1), labels[i+1], col = axislabcol)
    if (axistype == 4 | axistype == 5) 
      ## Changes by me
      if(is.null(labels)) labels = sprintf("%3.2f", i/seg)
      text(-0.05, (i + 1)/(seg + 1), labels[i+1], 
           col = axislabcol)
  }
  arrows(xx/(seg + 1), yy/(seg + 1), xx * 1, yy * 1, lwd = cglwd, 
         lty = cglty, length = 0, col = cglcol)
  if (axistype == 2 | axistype == 3 | axistype == 5) {
    text(xx[1:n], yy[1:n], df[1, 1:n], col = axislabcol)
  }
  text(xx * 1.2, yy * 1.2, colnames(df))
  series <- length(df[[1]])
  if (length(pty) < (series - 2)) {
    ptys <- rep(pty, series - 2)
    pcols <- rep(pcol, series - 2)
    pltys <- rep(plty, series - 2)
    plwds <- rep(plwd, series - 2)
  }
  else {
    ptys <- pty
    pcols <- pcol
    pltys <- plty
    plwds <- plwd
  }
  for (i in 3:series) {
    xxs <- xx
    yys <- yy
    scale <- 1/(seg + 1) + (df[i, ] - df[2, ])/(df[1, ] - 
      df[2, ]) * seg/(seg + 1)
    if (sum(!is.na(df[i, ])) < 3) {
      cat(sprintf("[DATA NOT ENOUGH] at %d\n%g\n", i, df[i, 
                                                         ]))
    }
    else {
      for (j in 1:n) {
        if (is.na(df[i, j])) {
          if (na.itp) {
            left <- ifelse(j > 1, j - 1, n)
            while (is.na(df[i, left])) {
              left <- ifelse(left > 1, left - 1, n)
            }
            right <- ifelse(j < n, j + 1, 1)
            while (is.na(df[i, right])) {
              right <- ifelse(right < n, right + 1, 1)
            }
            xxleft <- xx[left] * (1/(seg + 1) + (df[i, 
                                                    left] - df[2, left])/(df[1, left] - df[2, 
                                                                                           left]) * seg/(seg + 1))
            yyleft <- yy[left] * (1/(seg + 1) + (df[i, 
                                                    left] - df[2, left])/(df[1, left] - df[2, 
                                                                                           left]) * seg/(seg + 1))
            xxright <- xx[right] * (1/(seg + 1) + (df[i, 
                                                      right] - df[2, right])/(df[1, right] - 
                                                        df[2, right]) * seg/(seg + 1))
            yyright <- yy[right] * (1/(seg + 1) + (df[i, 
                                                      right] - df[2, right])/(df[1, right] - 
                                                        df[2, right]) * seg/(seg + 1))
            if (xxleft > xxright) {
              xxtmp <- xxleft
              yytmp <- yyleft
              xxleft <- xxright
              yyleft <- yyright
              xxright <- xxtmp
              yyright <- yytmp
            }
            xxs[j] <- xx[j] * (yyleft * xxright - yyright * 
              xxleft)/(yy[j] * (xxright - xxleft) - xx[j] * 
              (yyright - yyleft))
            yys[j] <- (yy[j]/xx[j]) * xxs[j]
          }
          else {
            xxs[j] <- 0
            yys[j] <- 0
          }
        }
        else {
          xxs[j] <- xx[j] * (1/(seg + 1) + (df[i, j] - 
            df[2, j])/(df[1, j] - df[2, j]) * seg/(seg + 
            1))
          yys[j] <- yy[j] * (1/(seg + 1) + (df[i, j] - 
            df[2, j])/(df[1, j] - df[2, j]) * seg/(seg + 
            1))
        }
      }
      polygon(xxs, yys, lty = pltys[i - 2], lwd = plwds[i - 
        2], border = pcols[i - 2])
      points(xx * scale, yy * scale, pch = ptys[i - 2], col = pcols[i - 2])
    }
  }
}
-------------------------------------------------------------------------------------------------------
y=a+b*x x=(y-a)/b cc <- coef(model)
(xnew <- (ynew-cc[1])/cc[2])
# [1]  31.43007 104.76689 178.10372

plot(x,y
abline(model)
points(xnew,ynew,col=2)
-------------------------------------------------------------------------------------------------------
chemCal inverse.predict x <- c(0, 40, 80, 120, 160, 200)
y <- c(6.52, 5.10, 4.43, 3.99, 3.75, 3.60)
plot(x,y)
model <- lm(y ~ x)
abline(model)
require(chemCal)
ynew <- c(5.5, 4.5, 3.5)
xpred<-t(sapply(ynew,function(y) inverse.predict(model,y)[1:2]))
#  Prediction Standard Error
#[1,] 31.43007   -38.97289     
#[2,] 104.7669   -36.45131     
#[3,] 178.1037   -39.69539
points(xpred[,1],ynew,col="red")
-------------------------------------------------------------------------------------------------------
x2=x
index(x2)=index(x2)+(7*3600)
indexTZ(x2)='America/New_York' rollapply_chunks.FX.xts=function(data,width,FUN,...,on="days",k=1){
data <- try.xts(data)

x2 <- data
index(x2) <- index(x2)+(7*3600)
indexTZ(x2) <- 'America/New_York'

ep <- endpoints(x2,on=on,k=k)    #The end point of each calendar day (when on="days").
    #Each entry points to the final bar of the day. ep[1]==0.

if(length(ep)<2){
    stop("Cannot divide data up")
}else if(length(ep)==2){  #Can only fit one chunk in.
    sp <- 1;ep <- ep[-1]
}else{
    sp <- ep[1:(length(ep)-width)]+1
    ep <- ep[(width+1):length(ep)]
}

xx <- lapply(1:length(ep), function(ix) FUN(.subset_xts(data,sp[ix]:ep[ix]),...) )
xx <- do.call(rbind,xx)   #Join them up as one big matrix/data.frame.

tt <- index(data)[ep]  #Implicit align="right". Use sp for align="left"
res <- xts(xx, tt)
return (res)
}
-------------------------------------------------------------------------------------------------------
lapply(split(xts.data,"weeks"), f) period.apply period.apply(xts.data, endpoints(xts.data,"weeks"), range)
period.apply(xts.data, endpoints(xts.data,"weeks"), colMeans)
-------------------------------------------------------------------------------------------------------
Spatial* k K B k C1 C2 C2





                            K


                  k----------------------B






                                       C1 # Example inputs
r <- 40
known.pair <- structure(c(-46.9531139599816, -62.1874917150412, 
25.9011462171242, 16.7441676243879), .Dim = c(2L, 2L), 
.Dimnames = list(NULL, c("x", "y")))

## Distance and angle (/_KkB) between the two known points
d1 <- sqrt(sum(diff(known.pair)^2))
theta1 <- atan(do.call("/", as.list(rev(diff(known.pair)))))

## Calculate magnitude of /_KkC1 and /_KkC2
theta2 <- acos((d1/2)/r)

## Find center of one circle (using /_BkC1)
dx1 <- cos(theta1 + theta2)*r
dy1 <- sin(theta1 + theta2)*r
p1 <- known.pair[2,] + c(dx1, dy1)

## Find center of other circle (using /_BkC2)
dx2 <- cos(theta1 - theta2)*r
dy2 <- sin(theta1 - theta2)*r
p2 <- known.pair[2,] + c(dx2, dy2)

## Showing that it worked
library(sp)
library(rgeos)
plot(0,0, xlim = c(-200, 200), ylim = c(-200, 200), type = "n", asp = 1)
points(known.pair)
found.pt <- SpatialPoints(matrix(slvd$par, nrow = 1))
points(p1[1], p1[2], col="blue", pch=16)
points(p2[1], p2[2], col="green", pch=16)
-------------------------------------------------------------------------------------------------------
radius=40 plot(known.pair,xlim=100*c(-1,1),ylim=100*c(-1,1),asp=1,pch=c("a","b"),cex=0.8) c ab de AB.bisect=known.pair[2,,drop=F]/2+known.pair[1,,drop=F]/2
C=AB.bisect
points(AB.bisect,pch="c",cex=0.5) ab AB.vector=known.pair[2,,drop=F]-known.pair[1,,drop=F]
AB.len=sqrt(sum(AB.vector^2))
AB.angle=atan2(AB.vector[2],AB.vector[1])
names(AB.angle)<-NULL c CD.len=sqrt(diff(c(AB.len/2,radius)^2))
CD.angle=AB.angle-pi/2 d e ab center1=C+CD.len*c(x=cos(CD.angle),y=sin(CD.angle))
center2=C-CD.len*c(x=cos(CD.angle),y=sin(CD.angle))
points(center1[1],center1[2],col="blue",cex=0.8,pch="d")
points(center2[1],center2[2],col="blue",cex=0.8,pch="e")
-------------------------------------------------------------------------------------------------------
density.ppp NA library(maptools)
library(sp)
library(spatstat)

xx <- readShapePoly(system.file("shapes/sids.shp", package="maptools")[1],
      IDvar="FIPSNO", proj4string=CRS("+proj=longlat +ellps=clrk66"))

x <- rnorm(25, -80, 2)
y <- rnorm(25, 35, 1 )

tmp <- density( ppp(x,y, xrange=range(x), yrange=range(y)) )
plot(tmp)
plot(xx, add=TRUE)
points(x,y)

tmp2 <- SpatialPoints( expand.grid( tmp$yrow, tmp$xcol )[,2:1],
    proj4string=CRS(proj4string(xx)) )

tmp3 <- over( tmp2, xx )

tmp$v[ is.na( tmp3[[1]] ) ] <- NA

plot(tmp)
plot(xx, add=TRUE)
-------------------------------------------------------------------------------------------------------
grid.points() grid.lines() "native" "npc" args(grid.lines)
# function (x = unit(c(0, 1), "npc"), y = unit(c(0, 1), "npc"), 
#     default.units = "npc", arrow = NULL, name = NULL, gp = gpar(), 
#     draw = TRUE, vp = NULL)     
args(grid.points)
# function (x = stats::runif(10), y = stats::runif(10), pch = 1, 
#     size = unit(1, "char"), default.units = "native", name = NULL, 
#     gp = gpar(), draw = TRUE, vp = NULL) grid.lines() grid.points() grid.lines(x, y, gp = gpar(col = "red"), default.units = "native")
-------------------------------------------------------------------------------------------------------
require(vegan)
data(dune) dij <- vegdist(dune) ## bray curtis dissimilarity
clu <- hclust(dij, method = "average")
grp <- cutree(clu, 3) grp R> grp
 2 13  4 16  6  1  8  5 17 15 10 11  9 18  3 20 14 19 12  7 
 1  1  1  2  1  1  1  1  3  2  1  1  1  1  1  2  2  3  1  1 set.seed(2) ## setting a seed to make this reproducible
ord <- metaMDS(dune) col <- c("red2", "green4", "mediumblue") grp col col grp R> col[grp]
 [1] "red2"       "red2"       "red2"       "green4"     "red2"      
 [6] "red2"       "red2"       "red2"       "mediumblue" "green4"    
[11] "red2"       "red2"       "red2"       "red2"       "red2"      
[16] "green4"     "green4"     "mediumblue" "red2"       "red2" plot() plot(ord, type = "n", display = "sites")
points(ord, col = col[grp], bg = col[grp], pch = 21)
legend("topright", legend = paste("Cluster", 1:3),
       col = col, pt.bg = col, bty = "n", pch = 21) ordihull() ordihull(ord, groups = grp, display = "sites") plot() points()
-------------------------------------------------------------------------------------------------------
x > library(xts)
> x[endpoints(x$dates, on = "months"), ]
        dates V1 V2 V3 V4 V5 V6 V7 V8 V9 V10
1  1999-05-31 66 65 64 63 62 61 60 59 58  57
15 1999-06-30 88 87 86 85 84 83 82 81 80  79
-------------------------------------------------------------------------------------------------------
Make.Funny.Plot <- function(x){
    unique.vals <- length(unique(x))
    N <- length(x)
    N.val <- min(N/20,unique.vals)

    if(unique.vals>N.val){
      x <- ave(x,cut(x,N.val),FUN=min)
      x <- signif(x,4)
    }
    # construct the outline of the plot
    outline <- as.vector(table(x))
    outline <- outline/max(outline)

    # determine some correction to make the V shape,
    # based on the range
    y.corr <- diff(range(x))*0.05

    # Get the unique values
    yval <- sort(unique(x))

    plot(c(-1,1),c(min(yval),max(yval)),
        type="n",xaxt="n",xlab="")

    for(i in 1:length(yval)){
        n <- sum(x==yval[i])
        x.plot <- seq(-outline[i],outline[i],length=n)
        y.plot <- yval[i]+abs(x.plot)*y.corr
        points(x.plot,y.plot,pch=19,cex=0.5)
    }
}

N <- 500
x <- rpois(N,4)+abs(rnorm(N))
Make.Funny.Plot(x)
-------------------------------------------------------------------------------------------------------
Y Y pch Y banknote pairs(banknote[,-c(1,7)], 
  panel = function(x,y,...){
    points(x,y,pch = ifelse(as.logical(banknote$Y), 0,15))}) data.frame $ with(banknote, ...) R banknote with(banknote, pairs(list(Left = Left, Right = Right, Bottom = Bottom, 
        Top = Top, Diagonal = Diagonal), 
      panel = function(x,y) points(x,y, pch= ifelse(as.logical(Y),0,15)))
-------------------------------------------------------------------------------------------------------
period.apply() endpoints() library(zoo)                                # for zoo objects
library(xts)                                # for period.apply

gcdata <- read.table("http://bernd.eckenfels.net/view/gc1001.ygc.csv",
                     header=TRUE, sep=",", dec=".")
timestamps <- gcdata$Timestamp + 
              as.POSIXct(strptime("2012-01-01 00:00:00", 
                         format="%Y-%m-%d %H:%M:%S"))
gcdatazoo <- zoo(gcdata[-1], order.by=timestamps)    # as zoo object zoo plotAreaCorridor <- function(x, y, col.poly1="lightgray", col.poly2="gray",...) {
    x.pol <- c(x, rev(x), x[1])
    y.pol <- c(y[,1], rev(y[,5]),y[,1][1])
    plot(x, y[,6]+1, type="n", ...) 
    polygon(x.pol, y.pol, col=col.poly1, lty=0)

    x.pol <- c(x, rev(x), x[1])
    y.pol <- c(y[,2], rev(y[,4]), y[,1][1])
    polygon(x.pol, y.pol, col=col.poly2, lty=0)

    lines(x, y[,3], col="blue") # median
    lines(x, y[,6], col="red")  # max

    invisible(NULL)
} agg <- period.apply(gcdatazoo[,"Pause.s."],               # to which data
                    INDEX=endpoints(gcdatazoo, "hours", k=2), # every 2 hours
                    FUN=function(x) quantile(x,               # what fun.
                                             probs=c(5,20,50,80,95,100)/100)) 

#v99 = q99(gcdata$Pause.s.)        # what is q99 ?
v99 <- mean(agg[,5])                  # mean of 95-th percentile?
plotAreaCorridor(index(agg),          # use time index as x axis
                 coredata(agg),       # and matrix part of zoo object as data
                 ylim=c(0,max(agg[,5])*1.5),
                 ylab="Quantiles of GC events",
                 main="NewPar Collection Activity")
abline(h=median(gcdatazoo[,"Pause.s."]), col="lightblue")
abline(h=v99, col="grey")
labeltxt <- paste("99%=",round(v99,digits=3),"s n=", nrow(gcdatazoo),sep="")
text(x=index(agg)[20], y=1.5*v99, labeltxt, col="grey", pos=3)  # or legend()
-------------------------------------------------------------------------------------------------------
z dotplot(factor(z) ~ ... jitter.x=TRUE jitter.y=TRUE z z horizontal=TRUE useOuterStrips(dotplot(z ~ factor(sample.size) | 
                             as.factor(effect.size)*as.factor(true.dose),
                  groups=as.factor(type), data=df.dose,  
                  as.table=TRUE, horizontal=FALSE, jitter.x=TRUE)) panel.groups panel df.dose$se <- 200
df.dose$type <- factor(df.dose$type)
df.dose$sample.size <- factor(df.dose$sample.size)

panel.groups.mydotplot <- function(x, y, subscripts, up, lo, 
                                   col=NA, col.line=NA, ...) {
  panel.points(x, y, ...)
  panel.segments(x, lo[subscripts], x, up[subscripts], col=col.line, ...)
}
panel.mydotplot <- function(x, y, subscripts, groups, ..., jitter=0.1) {
  jitter <- seq(-1,1,len=nlevels(groups))*jitter
  xx <- as.numeric(x) + jitter[as.numeric(groups[subscripts])]
  panel.dotplot(x, y, groups=groups, subscripts=subscripts, pch=NA, ...)
  panel.superpose(xx, y, groups=groups, subscripts=subscripts,  
                  panel.groups=panel.groups.mydotplot, ...)
}
pp <- dotplot(z ~ sample.size | as.factor(effect.size)*as.factor(true.dose),
              groups=type, data=df.dose, as.table=TRUE, horizontal=FALSE,
              up=df.dose$z + df.dose$se, lo=df.dose$z - df.dose$se,
              panel=panel.mydotplot, auto.key=list(space="right"))
useOuterStrips(pp)
-------------------------------------------------------------------------------------------------------
library( zipcode ) ; library( maps ) map( "usa" ) data( "zipcode" ) selected <- zipcode[ zipcode$zip %in% c( "90001", "46243", "32920" ), ] points( selected$longitude, selected$latitude, pch= 19, cex= 2 )
text( selected$longitude, selected$latitude, selected$zip, pos=3, cex= 2 )
-------------------------------------------------------------------------------------------------------
library( maps )
map( "world" )
points(  -0.11832, 51.50939, pch= 19, col= "red" )
text(  -0.11832, 51.50939, "London", pos=3, col= "red" )
abline( h= 0 )
text( -150, 0, "Equator", pos= 3 )
abline( v= 0 )
-------------------------------------------------------------------------------------------------------
plot(1:length(sample.list),ylim=c(0,max(unlist(sample.list))),xaxt="n",ann=FALSE)
axis(1,at=1:length(sample.list),labels=1:length(sample.list))

invisible(
  sapply(
      1:length(sample.list),
      function(x) {
        tmp2plot <- sample.list[[x]]
        points(rep(x,length(tmp2plot)),unlist(tmp2plot),col=1:length(tmp2plot),pch=19)
      }
  )
)

title(xlab="Index",ylab="Value")
-------------------------------------------------------------------------------------------------------
plot(x1, y)
points(x2, y) plot(x1, y, xlim = range(c(x1, x2)))
points(x2, y, col = "red", pch = 2) k++ k <- k + 1
-------------------------------------------------------------------------------------------------------
approx approxfun approx approxfun dat <- data.frame(x=1:10, y=(1:10)^2) approx approxfun > approx(dat$x, dat$y)
$x
 [1]  1.000000  1.183673  1.367347  1.551020  1.734694  1.918367  2.102041
 [8]  2.285714  2.469388  2.653061  2.836735  3.020408  3.204082  3.387755
[15]  3.571429  3.755102  3.938776  4.122449  4.306122  4.489796  4.673469
[22]  4.857143  5.040816  5.224490  5.408163  5.591837  5.775510  5.959184
[29]  6.142857  6.326531  6.510204  6.693878  6.877551  7.061224  7.244898
[36]  7.428571  7.612245  7.795918  7.979592  8.163265  8.346939  8.530612
[43]  8.714286  8.897959  9.081633  9.265306  9.448980  9.632653  9.816327
[50] 10.000000

$y
 [1]   1.000000   1.551020   2.102041   2.653061   3.204082   3.755102
 [7]   4.510204   5.428571   6.346939   7.265306   8.183673   9.142857
[13]  10.428571  11.714286  13.000000  14.285714  15.571429  17.102041
[19]  18.755102  20.408163  22.061224  23.714286  25.448980  27.469388
[25]  29.489796  31.510204  33.530612  35.551020  37.857143  40.244898
[31]  42.632653  45.020408  47.408163  49.918367  52.673469  55.428571
[37]  58.183673  60.938776  63.693878  66.775510  69.897959  73.020408
[43]  76.142857  79.265306  82.551020  86.040816  89.530612  93.020408
[49]  96.510204 100.000000

> approxfun(dat$x, dat$y)
function (v) 
.C(C_R_approxfun, as.double(x), as.double(y), as.integer(n), 
    xout = as.double(v), as.integer(length(v)), as.integer(method), 
    as.double(yleft), as.double(yright), as.double(f), NAOK = TRUE, 
    PACKAGE = "stats")$xout
<bytecode: 0x05244854>
<environment: 0x030632fc> a <- approx(dat$x, dat$y)
af <- approxfun(dat$x, dat$y)

plot(dat)
points(a, pch=2) plot(dat)
curve(af, add=TRUE) > uniroot(function(x) {af(x)-4}, interval=c(1,10))
$root
[1] 1.999994

$f.root
[1] -1.736297e-05

$iter
[1] 24

$estim.prec
[1] 6.103516e-05
-------------------------------------------------------------------------------------------------------
library(spatstat)
library(sp)
library(plotKML)
library(maptools) x<-rnorm(100,3)
y<-rnorm(100,3)
plot(x,y)
xy<-cbind(x,y)
xy<-as.data.frame(xy) coordinates(xy)=c("x","y")
pnts<-vect2rast(xy)
summary(pnts) conv<-convexhull.xy(x,y)
SpP<-as(conv,  "SpatialPolygons")
plot(SpP)
points(x,y)
attr  =  data.frame(a=1,  b=1)
SrDf  =  SpatialPolygonsDataFrame(SpP,  attr) rast <- vect2rast(SrDf,cell.size=0.085) plot(rast)
image(rast)
points(x,y)
-------------------------------------------------------------------------------------------------------
plot(x1, y1,col='red')

points(x2,y2,col='blue')
-------------------------------------------------------------------------------------------------------
plot(1:10, col=rgb(1, 0, 0, 0.5), pch=16)
points((1:10)+0.05, col=rgb(0, 0, 1, 0.5), pch=16) ?rgb
-------------------------------------------------------------------------------------------------------
plot( cntdens <- table(f[['cnt']])/length(f[['cnt']]),
       xlim=range(f[['cnt']]), ylim=c(0, 0.8)  )

# And then plot the theoretic distribution for the VGAM fit 
# ... extending the example on ?VGAM::zipf:

require(VGAM)
zdata <- data.frame( y=1:max( f[['cnt']] ),  ofreq= table( f[['cnt']] ) )
fit = vglm(y ~ 1, zipf, zdata, trace = TRUE, weight = ofreq, crit = "coef")
proby = dzipf(1:max(f[['cnt']]), N =max(f[['cnt']]), s = Coef(fit) )
points((1:5)+0.05, proby,  col="red")
-------------------------------------------------------------------------------------------------------
zoomplot TeachingDemos fplot <- function(x, y = NULL, type = "l", new = NULL, xlim, ylim, zoom = TRUE,...){
   require(TeachingDemos)
   if (is.null(y)){
if (length(dim(x)) == 2){
    y = x[,2]
    x = x[,1]
} else {
       y = x
       x = 1:length(y)
     } 
}

   if ( is.null(new) ){
   #determine whether to make a new plot or not
   new = FALSE
   if (is.null(recordPlot()[[1]])) new = TRUE
   }
   if (missing(xlim)) xlim = range(x)
   if (missing(ylim)) ylim = range(y)

   if (new){
   plot(x, y, type = type, xlim = xlim, ylim = ylim, ...)
   } else {
    if (type == "p"){
        points(x,y, ...)
    } else {
        lines(x,y, type = type, ...)
    }
    if (zoom){
    #rescale plot
    xcur = par("usr")[1:2]
    ycur = par("usr")[3:4]
    #shrink coordinates and pick biggest
    xcur = (xcur - mean(xcur)) /1.08 + mean(xcur)
    ycur = (ycur - mean(ycur)) /1.08 + mean(ycur)
    xlim = c(min(xlim[1], xcur[1]), max(xlim[2], xcur[2]))
    ylim = c(min(ylim[1], ycur[1]), max(ylim[2], ycur[2]))
    #zoom plot
    zoomplot(xlim, ylim)
    }
   }
 } dev.new()
fplot(1:4)
fplot(1:4 +1, col = 2)
fplot(0:400/100 + 1, sin(0:400/10), type = "p")
dev.new()
for (k in 1:20) fplot(sort(rnorm(20)), type = "b", new = (k==1) )
-------------------------------------------------------------------------------------------------------
polygon() polygon(c(myd$xvar[20:40], myd$xvar[40:20]),c(myd$yvarL[20:40],
 myd$yvarU[40:20]), col="gray") points(myd$xvar,myd$yvar,pch=19,cex=.75,col="blue")
points(myd$xvar,myd$yvarL,col="gray", pch=19,cex=.5)
points(myd$xvar,myd$yvarU,col="gray", pch=19,cex=.5) index <- which(myd$xvar>=200 & myd$xvar<=400) polygon(c(myd$xvar[index], myd$xvar[rev(index)]),c(myd$yvarL[index], 
 myd$yvarU[rev(index)]), col="gray") lines(myd$xvar[index],myd$yvar[index],pch=19,cex=.75,col="blue",type="o")
points(myd$xvar,myd$yvarL,col="gray", pch=19,cex=.5)
points(myd$xvar,myd$yvarU,col="gray", pch=19,cex=.5)
-------------------------------------------------------------------------------------------------------
plot(myd$xvar,myd$yvar,pch=19,cex=.75,col="blue")
points(myd$xvar,myd$yvarL,col="gray", pch=19,cex=.5)
points(myd$xvar,myd$yvarU,col="gray", pch=19,cex=.5)
polygon(c(smyd$xvar[1:nrow(smyd)], smyd$xvar[nrow(smyd):1]), 
 c(smyd$yvarL[1:nrow(smyd)], smyd$yvarU[nrow(smyd):1]), col="gray", border = NA)
points(smyd$xvar,smyd$yvar,col="red", pch=19,cex=1.5)
lines (smyd$xvar,smyd$yvar,col="red", pch=19,cex=1.5)

polygon(c(smyd1$xvar[1:nrow(smyd1)], smyd1$xvar[nrow(smyd1):1]),
c(smyd1$yvarL[1:nrow(smyd1)], smyd1$yvarU[nrow(smyd1):1]), col="yellow", border = NA)
points(smyd1$xvar,smyd1$yvar,col="green4", pch=19,cex=1.5)
lines (smyd1$xvar,smyd1$yvar,col="green4", pch=19,cex=1.5)
-------------------------------------------------------------------------------------------------------
interp akima set.seed(1)
x <- runif(20)
y <- runif(20)
z <- x^3 + sin(y)

require(akima)
F <- interp(x,y,z)
image(F)
points(x,y) F <- interp(x,y,z, linear=FALSE, extrap=TRUE)
image(F)
points(x,y)
-------------------------------------------------------------------------------------------------------
X11() win() plot(1:10);for(i in 1:10){points(10-i,i);Sys.sleep(1)}
-------------------------------------------------------------------------------------------------------
DF MeansByNum <- tapply(DF$Percent, DF$Num, mean) #Create an array of means by Num
NewDF <- data.frame(cbind(Num = as.numeric(as.vector(names(MeansByNum))),
                          Percent = as.numeric(MeansByNum)))
plot(Percent~Num, DF)
points(NewDF$Num, NewDF$Percent, col="red")
abline(lm(Percent~Num, NewDF))
-------------------------------------------------------------------------------------------------------
Sys.sleep(0) W N <- 1000
x <- rep(NA,N)
plot(c(0,1)~c(0,N), col=NA)
for(i in seq(N)) {
  Sys.sleep(.01)
  x[i] <- runif(1)
  iseq <- seq(i-99,i)
  points( x[i]~i )
  Sys.sleep(0)
} N <- 1000
x <- rep(NA,N)
plot(c(0,1)~c(0,N), col=NA)
for(i in seq(N)) {
  Sys.sleep(.01)
  x[i] <- runif(1)
  iseq <- seq(i-99,i)
  if(i%%100==0) {
    points( x[iseq]~iseq )
    Sys.sleep(0)
  }
} plot
-------------------------------------------------------------------------------------------------------
ggplot plot rgeos library(rgeos)
library(RColorBrewer)

# Get centroids of countries
theCents <- coordinates(world.map)

# extract the polygons objects
pl <- slot(world.map, "polygons")

# Create square polygons that cover the east (left) half of each country's bbox
lpolys <- lapply(seq_along(pl), function(x) {
  lbox <- bbox(pl[[x]])
  lbox[1, 2] <- theCents[x, 1]
  Polygon(expand.grid(lbox[1,], lbox[2,])[c(1,3,4,2,1),])
})

# Slightly different data handling
wmRN <- row.names(world.map)

n <- nrow(world.map@data)
world.map@data[, c("growth", "category")] <- list(growth = 4*runif(n),
                 category = factor(sample(1:5, n, replace=TRUE)))

# Determine the intersection of each country with the respective "left polygon"
lPolys <- lapply(seq_along(lpolys), function(x) {
  curLPol <- SpatialPolygons(list(Polygons(lpolys[x], wmRN[x])),
    proj4string=CRS(proj4string(world.map)))
  curPl <- SpatialPolygons(pl[x], proj4string=CRS(proj4string(world.map)))
  theInt <- gIntersection(curLPol, curPl, id = wmRN[x])
  theInt
})

# Create a SpatialPolygonDataFrame of the intersections
lSPDF <- SpatialPolygonsDataFrame(SpatialPolygons(unlist(lapply(lPolys,
  slot, "polygons")), proj4string = CRS(proj4string(world.map))),
  world.map@data)

##########
## EDIT ##
##########
# Create a slightly less harsh color set
s_growth <- scale(world.map@data$growth,
  center = min(world.map@data$growth), scale = max(world.map@data$growth))
growthRGB <- colorRamp(c("red", "blue"))(s_growth)
growthCols <- apply(growthRGB, 1, function(x) rgb(x[1], x[2], x[3],
  maxColorValue = 255))
catCols <- brewer.pal(nlevels(lSPDF@data$category), "Pastel2")

# and plot
plot(world.map, col = growthCols, bg = "grey90")

plot(lSPDF, col = catCols[lSPDF@data$category], add = TRUE) ggplot2 ggplot2 coordinates(lSPDF) rSPDF # Create square polygons that cover west (right) half of each country's bbox
rpolys <- lapply(seq_along(pl), function(x) {
  rbox <- bbox(pl[[x]])
  rbox[1, 1] <- theCents[x, 1]
  Polygon(expand.grid(rbox[1,], rbox[2,])[c(1,3,4,2,1),])
})

# Determine the intersection of each country with the respective "right polygon"
rPolys <- lapply(seq_along(rpolys), function(x) {
  curRPol <- SpatialPolygons(list(Polygons(rpolys[x], wmRN[x])),
    proj4string=CRS(proj4string(world.map)))
  curPl <- SpatialPolygons(pl[x], proj4string=CRS(proj4string(world.map)))
  theInt <- gIntersection(curRPol, curPl, id = wmRN[x])
  theInt
})

# Create a SpatialPolygonDataFrame of the western (right) intersections
rSPDF <- SpatialPolygonsDataFrame(SpatialPolygons(unlist(lapply(rPolys,
  slot, "polygons")), proj4string = CRS(proj4string(world.map))),
  world.map@data) lSPDF rSPDF points(coordinates(rSPDF), col = factor(rSPDF@data$REGION))
# or
text(coordinates(lSPDF), labels = lSPDF@data$FIPS, cex = .7)
-------------------------------------------------------------------------------------------------------
ylim plot() ylim ylims set.seed(1)
df <- data.frame(f.delta = runif(10, min = -7, max = 0),
                 g.delta = runif(10, min = 0, max = 10),
                 x = rnorm(10))

ylim <- with(df, range(f.delta, g.delta)) ## compute y axis limits

plot(f.delta ~ x, data = df, pch = 20, col = "blue", ylim = ylim)
points(g.delta ~ x, data = df, pch = 20, col = "red")
-------------------------------------------------------------------------------------------------------
points lines with(df,plot(range(x),range(f.delta,g.delta),type = "n"))
points(f.delta~x, data = df, pch=20, col="blue")
points(g.delta~x, data = df, pch=20, col="red") type = "n" plot points
-------------------------------------------------------------------------------------------------------
grDevices::devAskNewPage(ask = TRUE) readline abline plot(y) myFun <- function() {
     x = rnorm(20)
        y = 7*x^2 - 0.5*x + rnorm(20)
    y.0 = lm(y ~ 1)
    plot(y)
       # We'd get the same constant by just doing mean(y), but fitting it as a
       # regression model means functions like residuals() and predict() are
       # available for use later, the same as our other models
    abline(h=y.0$coefficients[1])
    # Get evenly spaced points for pretty plotting of other models
    d = seq(min(x),max(x),length.out=200)
    # Fit polynomials of order 1 to 9
    # It would be nicer if we let this run from 0 to 9, but R doesn't allow us to do a polynomial of degree 0
    for (degree in 1:9) {
        fm = lm(y ~ poly(x,degree))
        # Store the results in models called y.1, y.2, through y.9
        # The assign/paste trick here is often useful for storing results
            # which do not fit well into arrays!
            # check: y.1; y.2;...
        assign(paste("y",degree,sep="."), fm)
        # Plot them, with different line types
        readline('Press return to see the next line added')
        lines(d, predict(fm, data.frame(x=d)), lty=(degree+1))
    }

        x.new = rnorm(2e4)
        y.new = 7*x.new^2 - 0.5*x.new + rnorm(2e4)
        plot(x.new,y.new,xlab="x",ylab="y",pch=24,cex=0.1,col="blue")
        curve(7*x^2-0.5*x,col="grey",add=TRUE)  # the old curve
        abline(h=y.0$coefficients[1])
        d = seq(from=min(x.new),to=max(x.new),length.out=200)
        for (degree in 1:9) {
           fm = get(paste("y",degree,sep="."))
           readline('Press return to see the next line added')
           lines(d, predict(fm,data.frame(x=d)),lty=(degree+1))
        }
        points(x,y,col="red")
}
myFun()
-------------------------------------------------------------------------------------------------------
output$plot_Total <- reactivePlot(function() { 
  plot.new()
   plot.window(xlim=c(1850,2020), ylim = c(0,5000000))
   axis(1)
   axis(2)
   title(main="Numbers over the years")
   title(xlab="Year")
   title(ylab="Number of people")
   box()
   points(dat$Year, dat$Total, col="red")
   lines(dat$Year, dat$Total, col="red")
  if (input$RC) {   lines(dat$Year, dat$dat)}
  })
-------------------------------------------------------------------------------------------------------
k library(xts)
 x <- xts(1:10000, order.by=seq(from=as.Date("1970-01-01"), by=1, len=10000))
 index(x)[endpoints(x, on="months", k=6)[c(T,F)]] "1970-12-31" "1971-12-31" "1972-12-31"... "1995-12-31" "1996-12-31" x <- xts(1:10000, order.by=seq(from=as.Date("1970-07-01"), by=1, len=10000)) "1971-06-30" "1972-06-30" "1973-06-30" ... dates <- index(x)[endpoints(x, on="months", k=6)]
dates[ as.POSIXlt(dates)$mon==11 ] endpoints(x, on="years") index(x)[.indexmon(x)==11 & .indexmday(x)==31]
-------------------------------------------------------------------------------------------------------
> head(xts.data[z])
       [,1]
1970-12-31  365
1971-12-31  730
1972-12-31 1096
1973-12-31 1461
1974-12-31 1826
1975-12-31 2191

> head(xts.data[endpoints(xts.data, on="months", k=1)])
           [,1]
1970-01-31   31
1970-02-28   59
1970-03-31   90
1970-04-30  120
1970-05-31  151
1970-06-30  181
> head(xts.data[endpoints(xts.data, on="months", k=2)])
           [,1]
1970-02-28   59
1970-04-30  120
1970-06-30  181
1970-08-31  243
1970-10-31  304
1970-12-31  365
> head(xts.data[endpoints(xts.data, on="months", k=3)])
           [,1]
1970-03-31   90
1970-06-30  181
1970-09-30  273
1970-12-31  365
1971-03-31  455
1971-06-30  546
> head(xts.data[endpoints(xts.data, on="months", k=4)])
           [,1]
1970-04-30  120
1970-08-31  243
1970-12-31  365
1971-04-30  485
1971-08-31  608
1971-12-31  730
> head(xts.data[endpoints(xts.data, on="months", k=6)])
           [,1]
1970-06-30  181
1970-12-31  365
1971-06-30  546
1971-12-31  730
1972-06-30  912
1972-12-31 1096
> head(xts.data[endpoints(xts.data, on="months", k=7)])
           [,1]
1970-07-31  212
1971-02-28  424
1971-09-30  638
1972-04-30  851
1972-11-30 1065
1973-06-30 1277
-------------------------------------------------------------------------------------------------------
library(np)

coord <- coordinates(xline)[[1]][[1]] 
nLines <- nrow(coord) - 1
#lengths <- sapply(seq_len(nLines), function(x) LineLength(coord[c(x, x + 1), ]))
lengths <- LineLength(coord, sum = FALSE) findme <- 11 # the distance of the new coordinates

distances <- cumsum(lengths) - findme         # distances from the nodes
segment <- which(distances >= 0)[1]           # the segment of interest
distToNode <- distances[segment]
ratio <- distToNode / lengths[segment]
segCoord <- coord[c(segment, segment + 1), ]
newCoord <- (1 - ratio) * segCoord[2 , ] + ratio * segCoord[1 , ] points(newCoord[1], newCoord[2])
-------------------------------------------------------------------------------------------------------
mytest = data.frame(
              x =  rep(1:3, each = 2),
              groupcd= rep(c(1,2),3),
              y=   c(22,8,11,4,7,5)
              )
mytest = rbind(mytest,c(2,3,15),c(3,3,17))

plottables <- split(mytest,mytest$groupcd)
plot(y~x,dat=plottables[[1]],type="l",xlim=range(mytest$x),ylim=range(mytest$y))
lapply(plottables,function(z)points(y~x,dat=z,type="l"))
-------------------------------------------------------------------------------------------------------
datf datf <- datf[order(datf$pollut, datf$lag), ] datfPlusNA <- lapply(split(datf, datf$pollut), function(x) rbind(NA, x, NA))
datf <- do.call(rbind, datfPlusNA) nr <- nrow(datf)  # find out how many rows all together
with(datf, {# this allows entering your commands more succinctly
    # first you could set up the plot so you can select the order of drawing
    plot(1:nr, or, ylim = c(0.8, 1.3), type = 'n', xaxt = 'n', xlab = '', ylab = 'Odds Ratio and 95% CI', frame.plot = TRUE, panel.first = grid(nx = NA, ny = NULL))
    # arrows(1:nr, lcl, 1:nr, ucl, length = 0.02, angle = 90, code = 3, col = factor(lag)) 
    # you could use arrows above but you don't want ends so segments is easier
    segments(1:nr, lcl, 1:nr, ucl, col = factor(lag))
    # add your points
    points(1:nr, or, pch = 19, cex = 0.6)
    xLabels <- na.omit(unique(pollut))
    axis(1, seq(4, 34, by = 6) - 0.5, xLabels)
})
abline(h = 1.0)
-------------------------------------------------------------------------------------------------------
layout(matrix(1:2,nrow=1),widths=c(0.8,0.2))
colfunc <- colorRampPalette(c("white","black"))

par(mar=c(5.1,4.1,4.1,2.1))
plot(1:10,ann=FALSE,type="n")
grid()
points(1:10,col=colfunc(10),pch=19,cex=1.5)

xl <- 1
yb <- 1
xr <- 1.5
yt <- 2

par(mar=c(5.1,0.5,4.1,0.5))
plot(NA,type="n",ann=FALSE,xlim=c(1,2),ylim=c(1,2),xaxt="n",yaxt="n",bty="n")
rect(
     xl,
     head(seq(yb,yt,(yt-yb)/10),-1),
     xr,
     tail(seq(yb,yt,(yt-yb)/10),-1),
     col=colfunc(10)
    )

mtext(1:10,side=2,at=tail(seq(yb,yt,(yt-yb)/10),-1)-0.05,las=2,cex=0.7)
-------------------------------------------------------------------------------------------------------
xx <- runif(100,min=0,max=1)
yy <- runif(100,min=0,max=1) points(xx,yy) ?points
-------------------------------------------------------------------------------------------------------
x<-seq(-4,4,0.1)
    y<-2*x^2-3*x
    plot(x,y)
    points(x, rnorm(length(x), 20, 10), col="red")
-------------------------------------------------------------------------------------------------------
curve f = function(x) x^2 + 1   
curve(f(x), -2,2, ylim=c(0, 5)) points points(runif(100, -2, 2), runif(100, 0, 6)) N = 100000
sum(f(runif(N, -2, 2)) > runif(N, 0, 6))/N * (4*6)
-------------------------------------------------------------------------------------------------------
freq = FALSE points lines hist(expRandom, freq = FALSE)
points(x,y) y curve hist(expRandom, freq = FALSE)
curve(dexp, from = 0, to  = 10, add = TRUE)
-------------------------------------------------------------------------------------------------------
plot(x=c(2,4,8),y=c(5,4,2),pch=16)
points(x=c(3,5),y=c(2,4),pch="+")
legend(7,4.5,pch=c(NA,16),legend=c("A","B")) # NA means don't plot pt. character 
legend(7,4.5,pch=c("+",NA),legend=c("A","B")) pdf() bmp() png()
-------------------------------------------------------------------------------------------------------
foo <- as.matrix(structure(list(Samp1 = c(84.1, 94.2, 29.5),
    Samp2 = c(45.2, 12.4, 10.5),Samp3 = c(34.3, 68, 43.2),
    Samp4 = c(54.6, 75.3, 39.5),Samp5 = c(76.2, 24.8, 45.5)),
  .Names = c("Samp1", "Samp2","Samp3", "Samp4", "Samp5"),
  class = "data.frame", row.names = c("Gene1","Gene2", "Gene3"))) plot(seq(1,ncol(foo)),foo[1,],xlab="",ylab="",xaxt="n",
  pch=21,bg=1,ylim=c(min(foo),max(foo)))
axis(side=1,at=seq(1,ncol(foo)),labels=colnames(foo))
for ( ii in 2:nrow(foo) ) points(seq(1,ncol(foo)),foo[ii,],pch=21,col=ii,bg=ii) col=ii,bg=ii ?palette ?legend
-------------------------------------------------------------------------------------------------------
mix2normal1 require(VGAM)
set.seed(12345)

# Create a binormal distribution with means 10 and 20
data <- c(rnorm(100, 10, 1.5), rnorm(200, 20, 3))

# Initial parameters for minimization algorithm
# You may want to create some logic to estimate this a priori... not always easy but possible
# m, m2: Means - s, s2: SDs - w: relative weight of the first distribution (the second is 1-w)
init.params <- list(m=5, m2=8, s=1, s2=1, w=0.5)

fit <<- vglm(data ~ 1, mix2normal1(equalsd=FALSE), 
                iphi=init.params$w, imu=init.params$m, imu2=init.params$m2, 
                isd1=init.params$s, isd2=init.params$s2)

# Calculated parameters
pars = as.vector(coef(fit))
w = logit(pars[1], inverse=TRUE)
m1 = pars[2]
sd1 = exp(pars[3])
m2 = pars[4]
sd2 = exp(pars[5])

# Plot an histogram of the data
hist(data, 30, col="black", freq=F)
# Superimpose the fitted distribution
x <- seq(0, 30, 0.1)
points(x, w*dnorm(x, m1, sd1)+(1-w)*dnorm(x,m2,sd2), "l", col="red", lwd=2) > m1
[1] 10.49236
> m2
[1] 20.06296
> sd1
[1] 1.792519
> sd2
[1] 2.877999
-------------------------------------------------------------------------------------------------------
plot(c(1,3),range(mat1),type = "n",xaxt ="n")
points(1:3,mat1[,2])
points(1:3,mat1[,1],pch = "x")
axis(1,at = 1:3,labels = rownames(mat1))
-------------------------------------------------------------------------------------------------------
spline.poly testpts <- 
structure(list(x = c(4.9, 4.2, 4, 4.1, 4.4, 5.8, 5.8, 5.8, 5.8, 
5.5, 4.9, 3.2, 3.2, 3.3, 5.4, 5.4, 5.7, 6.4, 6.7, 6.7, 6, 4.8, 
3.6, 2.8, 3.5, 4.4, 5.1, 4, 3.7, 4.5, 4.9, 5.7), y = c(6.9, 6.2, 
5.3, 4.1, 3.1, 2.9, 2.9, 3.5, 4.2, 4.9, 5.1, 4.9, 4.9, 5.2, 6.9, 
6.9, 5.3, 3.8, 4.2, 5.6, 6.9, 5.8, 1.2, 2.5, 5.3, 6.4, 6.8, 7.6, 
6.9, 5.4, 4.8, 4.4)), .Names = c("x", "y")) plot(NA,xlim=c(0,10),ylim=c(0,10))
points(testpts,pch=19)
chuld <- lapply(testpts,"[",chull(testpts))
polygon(chuld,lty=2,border="gray")
polygon(spline.poly(as.matrix(as.data.frame(chuld)),100),border="red",lwd=2) alphahull # load the required library
library(alphahull)

plot(NA,xlim=c(0,10),ylim=c(0,10))
points(testpts,pch=19)
# remove duplicate points so the ahull function doesn't error out
testptsnodup <- lapply(testpts,"[",which(!duplicated(as.matrix(as.data.frame(testpts))))) ahull.obj <- ahull(testptsnodup,alpha=2)
plot(ahull.obj,add=TRUE,col="red",wpoints=FALSE)
-------------------------------------------------------------------------------------------------------
# some data
require(vegan)
data(dune)
data(dune.env)

# vector holding the colors
cols <- c("red", "blue", "pink", "green")

# NMDS with bray-curtis distance
nmds <- metaMDS(dune, "bray", 2)

# empty plot
plot(nmds, type = "n")

# Add points colored by Environmental Variable Management
points(nmds, col = cols[dune.env$Management], pch = 16)

# add legend
legend("topright", legend=levels(dune.env$Management), col=cols, pch = 16)
-------------------------------------------------------------------------------------------------------
?identify ?zoomInPlot rxlim rylim /20 identify() par(mfrow = c(1,2))
plot(1:10) # 1
plot(1:10) # 2
identifyPch(1:10) identifyPch() ?identify par(mfg=c(1, 1)) zoom <- function (x, y, xlim, ylim, xd, yd) 
{
  rxlim <- x + c(-1, 1) * (diff(range(xd))/20)
  rylim <- y + c(-1, 1) * (diff(range(yd))/20)
  par(mfrow = c(1, 2))
  plot(xd, yd, xlab = "mean", ylab = "sd")
  xext <- yext <- rxext <- ryext <- 0
  if (par("xaxs") == "r") {
    xext <- diff(xlim) * 0.04
    rxext <- diff(rxlim) * 0.04
  }
  if (par("yaxs") == "r") {
    yext <- diff(ylim) * 0.04
    ryext <- diff(rylim) * 0.04
  }
  rect(rxlim[1] - rxext, rylim[1] - ryext, rxlim[2] + rxext, 
       rylim[2] + ryext)
  xylim <- par("usr")
  xypin <- par("pin")
  rxi0 <- xypin[1] * (xylim[2] - (rxlim[1] - rxext))/diff(xylim[1:2])
  rxi1 <- xypin[1] * (xylim[2] - (rxlim[2] + rxext))/diff(xylim[1:2])
  y01i <- xypin[2] * (xylim[4] - (rylim[2] + ryext))/diff(xylim[3:4])
  y02i <- xypin[2] * ((rylim[1] - ryext) - xylim[3])/diff(xylim[3:4])
  mu <- x
  curve(dnorm(x, mean = mu, sd = y), from = -4 * y + mu, to = 4 * y + mu, 
        xlab = paste("mean:", round(mu, 2), ", sd: ", round(y, 2)), ylab = "")
  xypin <- par("pin")
  par(xpd = NA)
  xylim <- par("usr")
  xymai <- par("mai")
  x0 <- xylim[1] - diff(xylim[1:2]) * (xymai[2] + xymai[4] + 
                                         rxi0)/xypin[1]
  x1 <- xylim[1] - diff(xylim[1:2]) * (xymai[2] + xymai[4] + 
                                         rxi1)/xypin[1]
  y01 <- xylim[4] - diff(xylim[3:4]) * y01i/xypin[2]
  y02 <- xylim[3] + diff(xylim[3:4]) * y02i/xypin[2]
  par(xpd = TRUE)
  xend <- xylim[1] - diff(xylim[1:2]) * xymai[2]/(2 * xypin[1])
  xprop0 <- (xylim[1] - xend)/(xylim[1] - x0)
  xprop1 <- (xylim[2] - xend)/(xylim[2] - x1)
  par(xpd = NA)
  segments(c(x0, x0, x1, x1), 
           c(y01, y02, y01, y02), 
           c(xend, xend, xend, xend), 
           c(xylim[4] - (xylim[4] - y01) * xprop0, 
             xylim[3] + (y02 - xylim[3]) * xprop0, 
             xylim[4] - (xylim[4] - y01) * xprop1, 
             xylim[3] + (y02 - xylim[3]) * xprop1))
  par(mfg = c(1, 1))
  plot(xd, yd, xlab = "mean", ylab = "sd")
}

ident <- function(x, y, ...)
{
  ans <- identify(x, y, n = 1, plot = FALSE, ...)
  if(length(ans)) {
    zoom(x[ans], y[ans], range(x), range(y), x, y)
    points(x[ans], y[ans], pch = 19)
    ident(x, y)
  }
}

x <- rnorm(10)
y <- rnorm(10, mean = 5)
par(mfrow = c(1, 2))
plot(x, y, xlab = "mean", ylab = "sd")
ident(x, y)
-------------------------------------------------------------------------------------------------------
strucchange changepoint bcp strucchange breakpoints() changepoint bcp library(bcp)
changefit <- bcp(data1)
plot(changefit) split() data2 <- data.frame(data=data1, prob = changefit$posterior.prob)
threshold <- 0.90
split(data2,c(0, cumsum( ifelse (data2$prob > threshold, 1, 0))))
#split will warn about unequal lengths
-------------------------------------------------------------------------------------------------------
mytest = data.frame(
              x =  rep(1:3, each = 2),
              groupcd= rep(c(1,2),3),
              y=   c(22,8,11,4,7,5)
              )
mytest = rbind(mytest,c(2,3,15),c(3,3,17))

    plottables <- split(mytest,mytest$groupcd)
plot(y~x,dat=plottables[[1]],type="n",xlim=range(mytest$x),ylim=range(mytest$y))
lapply(plottables,function(z)points(z$x, z$y))
lapply(plottables,function(z)lines(z$x, predict(lm(z$y ~ z$x), list(z$x)))) xvals <- tapply(mytest$x, mytest$groupcd, function(x) return(x))
    yvals <- tapply(mytest$y, mytest$groupcd, function(x) return(x))

    plot(1:max(unlist(xvals)),ylim=(c(0,max(unlist(yvals)))),type="n")
    mapply(points, xvals, yvals, bg=c(1:3),pch=21,type="p")
    mapply(lines(xvals, predict(lm(yvals ~ xvals), list(xvals)), col = c(1:3)))
-------------------------------------------------------------------------------------------------------
plot segmented segmented data.frame d linear2  <- segmented (linear1, seg.Z = ~ X, psi = 2, data = d)
plot(linear2)
points(Y~X, data = d) fudgedmodel <- linear2
fudgedmodel$coefficients[3] <- - fudgedmodel$coefficients[2]
plot(fudgedmodel)
points(Y~X, data = d)
-------------------------------------------------------------------------------------------------------
set.seed(101)
d <- data.frame(X=rlnorm(100),Y=runif(100))
thisfit=nls(Y ~ a*X^b,data=d, start = list(a = .1, b = .1)) 
library(nlstools)
a=nlsBoot (thisfit, niter = 999)
cr= nlsConfRegions(thisfit, exp = 2, length = 200) 
## 100%
##  Confidence regions array returned 
res= data.frame(X, pred = predict(thisfit)) ## points(res[order(X),], type='l', col="grey40", lty=1) 
## Error in plot.xy(xy.coords(x, y), type = type, ...) : 
##    plot.new has not been called yet plot(cr) plot(res[order(X),])
-------------------------------------------------------------------------------------------------------
library(maps)
map("state","California") map mappts dput(mappts)
structure(list(x = c(-121.837504273717, -119.288648121568, -116.37566966197
), y = c(40.0189660554, 36.8188807085794, 34.5400320525101)), .Names = c("x", 
"y"), row.names = c(NA, -3L), class = "data.frame")
mappts$z <- c(1,2,3)

> mappts
          x        y
1 -121.8375 40.01897
2 -119.2886 36.81888
3 -116.3757 34.54003 z mappts$z <- c(1,2,3)
points(mappts,col=mappts$z,pch=19) z palette palette(c("blue","pink","green")) palette("default")
-------------------------------------------------------------------------------------------------------
fmt=persp(x, y, z, col = color[facetcol], phi = 15, theta = -50, xlab="x", ylab="y", zlab="Empirical Joint Density", border=NA)
pt = Sample[1,]
points(trans3d(pt[1],pt[2],.001,fmt),pch=20, col="Red")
lines(trans3d(c(pt[1],pt[1]), c(pt[2],pt[2]), c(0,.001),fmt),col="Red",cex=2)
-------------------------------------------------------------------------------------------------------
head(dat)
     V2         V3       V4
2 -1.52 2007-09-29 00:00:08
3 -1.48 2007-09-29 00:02:08
4 -1.46 2007-09-29 00:04:08
5 -1.56 2007-09-29 00:06:08
6 -1.64 2007-09-29 00:08:08
7 -1.75 2007-09-29 00:10:08 library(xts)
  dat.xts <- xts(x = dat$V2,as.POSIXct(paste(dat$V3,dat$V4)))


 head(dat.xts)
                     [,1]
2007-09-29 00:00:08 -1.52
2007-09-29 00:02:08 -1.48
2007-09-29 00:04:08 -1.46
2007-09-29 00:06:08 -1.56
2007-09-29 00:08:08 -1.64
2007-09-29 00:10:08 -1.75 period.apply ep <- endpoints(dat.xts,'hours')
period.apply(dat.xts,ep,mean)
                         [,1]
2007-09-29 00:58:08 -1.744333
2007-09-29 01:58:08 -1.586000
2007-09-29 02:58:08 -1.751667
2007-09-29 03:00:08 -1.820000 ep <- endpoints(dat.xts,'weeks')
period.apply(dat.xts,ep,mean)

                    [,1]
2007-09-29 03:00:08 -1.695385
-------------------------------------------------------------------------------------------------------
?endpoints apply.weekly apply.weekly
function (x, FUN, ...) 
{
    ep <- endpoints(x, "weeks")
    period.apply(x, ep, FUN, ...)
}
<environment: namespace:xts>
-------------------------------------------------------------------------------------------------------
ep <- endpoints(myTs,'weeks') 

myTs[ep]
           [,1]
2012-12-02    2
2012-12-09    9
2012-12-10   10 ts.weeks <- apply.weekly(myTs, colSums)
ts.weeks[length(ts.weeks)] <- last(index(myTs)) + 7-last(floor(diff(ep)))
-------------------------------------------------------------------------------------------------------
require(clue)
sol <- solve_LSAP(t(distances)) mean(dist_min[,3])
# [1] 0.05696033
mean(sqrt(
  (x2y2.data[,1] - x1y1.data[sol, 1])^2 +  
    (x2y2.data[,2] - x1y1.data[sol, 2])^2))
#[1] 0.05194625 plot(x1y1.data,col="blue")       
points(x2y2.data,col="red")
segments(x2y2.data[,1], x2y2.data[,2], x1y1.data[sol, 1], x1y1.data[sol, 2])
-------------------------------------------------------------------------------------------------------
ggplot2 ggplot ggplot(platelay, aes(y = factor(rown, rev(levels(rown))),x = factor(coln))) + 
     geom_point(aes(colour = colorvar), size =18)  +theme_bw() +
     labs(x=NULL, y = NULL) # plot with grey colour dictated by rank, no axes or labels
with(platelay, plot( x=as.numeric(coln), y= rev(as.numeric(rown)), pch= 19, cex = 2, 
 col = grey(rank(platelay[['colorvar']] ) / nrow(platelay)), axes = F, xlab= '', ylab = ''))
# add circular outline
with(platelay, points( x=as.numeric(coln), y= rev(as.numeric(rown)), pch= 21, cex = 2))
# add the axes
axis(3, at =1:12, labels = 1:12)
axis(2, at = 1:8, labels = LETTERS[8:1])
# the background grid
grid()
# and a box around the outside
box()
-------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------
lines() plot type = "l" Col.rar1<-c(rgb(1,0,0,0.7), rgb(0,0,1,0.7), rgb(0,1,1,0.7),rgb(0.6,0,0.8,0.7),rgb(1,0.8,0,0.7),rgb(0.4,0.5,0.6,0.7),rgb(0.2,0.3,0.2,0.7),rgb(1,0.3,0,0.7))

x <-  seq(0, 5000, length.out=10)
y <- matrix(sort(rnorm(10*length(Col.rar1))), ncol=length(Col.rar1))
plot(x, y[,1], ylim=range(y), ann=FALSE, axes=T,type="l", col=Col.rar1[1])

lapply(seq_along(Col.rar1),function(i){
  lines(x, y[,i], col=Col.rar1[i])
  points(x, y[,i])  # this is optional
})
-------------------------------------------------------------------------------------------------------
R> library(quantmod)                             ## for getSymbols()
R> SPY <- getSymbols("SPY", auto.assign=FALSE)   ## SPY is now of class xts R> summary(SPY)
     Index               SPY.Open      SPY.High      SPY.Low     
 Min.   :2007-01-03   Min.   : 68   Min.   : 70   Min.   : 67.1  
 1st Qu.:2008-07-03   1st Qu.:111   1st Qu.:112   1st Qu.:110.0  
 Median :2010-01-04   Median :128   Median :129   Median :127.5  
 Mean   :2010-01-02   Mean   :124   Mean   :125   Mean   :123.0  
 3rd Qu.:2011-07-05   3rd Qu.:140   3rd Qu.:140   3rd Qu.:139.0  
 Max.   :2013-01-04   Max.   :157   Max.   :158   Max.   :155.4  
   SPY.Close       SPY.Volume        SPY.Adjusted  
 Min.   : 68.1   Min.   :3.87e+07   Min.   : 62.6  
 1st Qu.:110.8   1st Qu.:1.38e+08   1st Qu.:104.1  
 Median :128.4   Median :1.86e+08   Median :121.1  
 Mean   :124.0   Mean   :2.12e+08   Mean   :116.1  
 3rd Qu.:139.7   3rd Qu.:2.57e+08   3rd Qu.:130.0  
 Max.   :156.5   Max.   :8.71e+08   Max.   :146.4  

R> R> tail(SPY[ endpoints(SPY) ])
           SPY.Open SPY.High SPY.Low SPY.Close SPY.Volume
2012-08-31   141.29   141.82  140.36    141.16  151970400
2012-09-28   144.09   144.56  143.46    143.97  150696100
2012-10-31   141.85   142.03  140.68    141.35  103438500
2012-11-30   142.14   142.42  141.66    142.15  136568300
2012-12-31   139.66   142.56  139.54    142.41  243935200
2013-01-04   145.97   146.61  145.67    146.37  116790800
           SPY.Adjusted
2012-08-31       139.42
2012-09-28       142.96
2012-10-31       140.35
2012-11-30       141.15
2012-12-31       142.41
2013-01-04       146.37 endpoints() R> SPY[ endpoints(SPY, "years") ]
           SPY.Open SPY.High SPY.Low SPY.Close SPY.Volume
2007-12-31   147.10   147.61  146.06    146.21  108126800
2008-12-31    89.08    90.97   88.87     90.24  193987200
2009-12-31   112.77   112.80  111.39    111.44   90637900
2010-12-31   125.53   125.87  125.33    125.75   91218900
2011-12-30   126.02   126.33  125.50    125.50   95599000
2012-12-31   139.66   142.56  139.54    142.41  243935200
2013-01-04   145.97   146.61  145.67    146.37  116790800
           SPY.Adjusted
2007-12-31       131.14
2008-12-31        82.88
2009-12-31       104.73
2010-12-31       120.49
2011-12-30       122.78
2012-12-31       142.41
2013-01-04       146.37
R>
-------------------------------------------------------------------------------------------------------
xts library(xts)
ts.dat <- read.zoo(text ='Date              amount
24/03/2001  -3.927020472
25/03/2001  -6.4427004
26/03/2001  -5.477592528
27/03/2001  -6.09462162
28/03/2001  -7.45666902
29/03/2001  -6.731540928
30/03/2001  -6.855206184
31/03/2001  -6.807210228
1/04/2001   -5.40278802',header=TRUE,format = '%d/%m/%Y') ep <- endpoints(ts.dat,'days',k=8) period.apply(x=ts.dat,ep,FUN=sum )
2001-03-29 2001-04-01 
-36.13014  -19.06520
-------------------------------------------------------------------------------------------------------
> boxplot(myd$myv, col = "lightgreen", ylim=c(-10,18))s > col2rgb("purple")
#      [,1]
#red    160
#green   32
#blue   240
> rect(0.7, 4.5, 1.3, 8.2, col= rgb( red=160/255, green=32/255, blu=240/255, 0.4) ) points > points(x=rep(1, sum( myd$myv > 8.2 | myd$myv < 4.5 )), 
         y= myd$myv[   myd$myv > 8.2 | myd$myv < 4.5 ] , 
         col="orange", pch=19, bg="orange")
-------------------------------------------------------------------------------------------------------
gridBase set.seed(1234)
myd <- data.frame (SN = 1:100, myv = round (rnorm(100, 5, 5), 2))
boxplot(myd$myv, col = "lightgreen")
sp <- baseViewports()
pushViewport(sp$plot)
grid.rect(default.units='native', width= 1,height=8.2-4.5 ,
            gp=gpar(fill=rgb(1,0,0,0.5)), y = 3)
grid.points(x = rep(1,6) ,y=c(-4,-2,3,9,10,11),
         gp=gpar(col=rgb(1,1,0,0.5),default.units='native'))
-------------------------------------------------------------------------------------------------------
foo <- boxplot(x,horizontal=TRUE,axes=FALSE,outline=FALSE)
points(foo$stats[c(1,5),1],c(1,1),pch=21,bg="red")
-------------------------------------------------------------------------------------------------------
plot(rnorm(120), rnorm(120), col="darkblue", pch=16, xlim=c(-3,3), ylim=c(-4,4))
points(rnorm(120,-1,1), rnorm(120,2,1), col="darkred", pch=16)
points(c(-1,-1.5,-3), c(4,2,0), pch=3, cex=3) xspline dd <- xspline(c(-1,-1.5,-3), c(4,2,0), shape = -1,draw=FALSE) panel.lines library(lattice)
xyplot(y ~ x,
       data=dat,
       groups=l,
       col=c("darkblue", "darkred"),
       pch=16,
       panel = function(x, y, ...) {
         panel.xyplot(x=spl$x, y=spl$y, pch=3, cex=3)
         panel.lines(dd$x,dd$y)
         panel.superpose(x, y, ...,
                         panel.groups = function(x, y, ...) {
                           panel.xyplot(x, y, ...)
                         }
         )
       },
       xlim=c(-3,3), ylim=c(-4,4)
)
-------------------------------------------------------------------------------------------------------
+ ?layer grid.xspline() xspline() library(lattice)
library(grid)
library(latticeExtra)

xyplot(rnorm(120)~rnorm(120), pch=16, col="darkblue", 
       xlim = c(-3.1, 3.1), ylim = c(-4.1, 4.1)) +
xyplot(rnorm(120,2,1) ~ rnorm(120,-1,1), pch=16, col="darkred") +
xyplot(c(4,2,0) ~ c(-1,-1.5,-3), pch=3, cex=3) +
layer(grid.xspline(c(-1,-1.5,-3), c(4,2,0), shape = -1, default.units="native")) grid.xspline() "npc" "native" grid.points() grid.*()
-------------------------------------------------------------------------------------------------------
ff <- function (xx) ifelse(xx<3,xx,xx+1) curve(expr=ff,from=0,to=2.999,xlim=c(0,6),ylim=c(0,7),xlab="",ylab="") curve(expr=ff,from=3,to=6,add=TRUE) points(3,ff(3),pch=21,bg="black")
-------------------------------------------------------------------------------------------------------
group map <- function(){
  geom_polygon(data=lon.df,aes(x=long,y=lat,group=piece),colour="black",fill="grey80",size=1)
}

points <- function(){
  geom_point(data=age2100,aes(x=x,y=y),size=0.1)
}

density <- function(){
  geom_density2d(data=age2100,aes(x=x,y=y),colour="red")
}

ggplot()+map() +points() +density()
-------------------------------------------------------------------------------------------------------
interp akima age2100 <- read.table("temp.csv",header=TRUE,sep=",")

x <- age2100$x
y <- age2100$y
z <- age2100$z

require(akima)

fld <- interp(x,y,z)

par(mar=c(5,5,1,1))
filled.contour(fld) image image.scale source("image.scale.R") # http://menugget.blogspot.de/2011/08/adding-scale-to-image-plot.html

x11(width=5, height=6)
layout(matrix(c(1,2), nrow=1, ncol=2), widths=c(4,1), height=6, respect=TRUE)
layout.show(2)

par(mar=c(4,4,1,1))
image(fld)
contour(fld, add=TRUE)
points(age2100$x,age2100$y, pch=".", cex=2)

par(mar=c(4,0,1,4))
image.scale(fld$z, xlab="", ylab="", xaxt="n", yaxt="n", horiz=FALSE)
box()
axis(4)
mtext("text", side=4, line=2.5)
-------------------------------------------------------------------------------------------------------
library(png)
# use the URL from your post, or construct on-the-fly
url = "http://pulse.blogs.yandex.net/?size=small&charset=utf8&period=20120116-20130116&query0=%D0%BF%D1%83%D1%82%D0%B8%D0%BD"
download.file(url,destfile='/tmp/test.png',mode='wb')
xvals=rnorm(10)
yvals=rnorm(10)
# just set up an "empty" plot
plot(xvals,yvals,type='n')
r = readPNG('/tmp/test.png')
# read the help for rasterImage for details
rasterImage(r,-1,-1,1,1)
# plot the points over the image
points(xvals,yvals)
-------------------------------------------------------------------------------------------------------
> data.xts <- as.xts(df[,2:14], as.POSIXct(strptime(df[,1], '%m/%d/%Y %H:%S')))
> data.xts
                        P    WS  WD    AT    FT  H    B   FM  GD     MG   SR   WS2 WD2
2012-01-01 11:00:00 992.4 4.023 212 16.11 17.22 50 1029 14.9 204  8.047  522 2.235 200
2012-01-01 12:00:00 992.4 3.576 200 18.89 22.22 38 1027 14.4 220  9.835  603 3.576 201
2012-01-01 13:00:00 992.4 4.023 215 20.00 22.78 38 1026 14.0 227 10.280  604 4.470 206
2012-01-01 14:00:00 992.4 6.259 213 20.00 22.78 39 1024 13.7 222 13.410  526 4.470 210
2012-01-01 15:00:00 992.4 4.470 204 19.44 20.00 48 1023 13.6 216 11.180  248 5.364 211
2012-01-02 11:00:00 992.4 3.576 304 10.56 11.11 24 1026 13.1 338  9.388  569 4.023 319
2012-01-02 12:00:00 992.4 3.576 276 11.11 15.56 19 1025 12.8 311  8.941  653 2.682 315
2012-01-02 13:00:00 992.4 2.682 273 11.67 17.22 18 1024 12.3 326  8.494  671 3.576 311
2012-01-02 14:00:00 992.4 4.023 307 12.22 17.78 16 1023 12.0 310  9.835  616 3.576 302
2012-01-02 15:00:00 992.4 3.576 270 11.11 15.56 18 1023 11.7 273 10.730  487 4.023 290
2012-04-07 11:00:00 239.0 2.682  54 17.22 24.44 23 1034 12.8  62  6.706  972 3.129  49
2012-04-07 12:00:00 239.0 3.129  24 18.33 25.56 20 1033 12.0  13  7.153 1053 3.129  39
2012-04-07 13:00:00 239.0 2.682 304 19.44 29.44 18 1032 11.4 312  8.047 1061 3.576  15
2012-04-07 14:00:00 239.0 2.235 320 20.56 30.56 17 1031 10.9 272  8.047 1002 2.682 348
2012-04-07 15:00:00 239.0 2.682 321 21.11 29.44 15 1030 10.4 281  7.600  865 3.129 329
> data.xts['T12:00:00/T16:00:00']
                        P    WS  WD    AT    FT  H    B   FM  GD     MG   SR   WS2 WD2
2012-01-01 12:00:00 992.4 3.576 200 18.89 22.22 38 1027 14.4 220  9.835  603 3.576 201
2012-01-01 13:00:00 992.4 4.023 215 20.00 22.78 38 1026 14.0 227 10.280  604 4.470 206
2012-01-01 14:00:00 992.4 6.259 213 20.00 22.78 39 1024 13.7 222 13.410  526 4.470 210
2012-01-01 15:00:00 992.4 4.470 204 19.44 20.00 48 1023 13.6 216 11.180  248 5.364 211
2012-01-02 12:00:00 992.4 3.576 276 11.11 15.56 19 1025 12.8 311  8.941  653 2.682 315
2012-01-02 13:00:00 992.4 2.682 273 11.67 17.22 18 1024 12.3 326  8.494  671 3.576 311
2012-01-02 14:00:00 992.4 4.023 307 12.22 17.78 16 1023 12.0 310  9.835  616 3.576 302
2012-01-02 15:00:00 992.4 3.576 270 11.11 15.56 18 1023 11.7 273 10.730  487 4.023 290
2012-04-07 12:00:00 239.0 3.129  24 18.33 25.56 20 1033 12.0  13  7.153 1053 3.129  39
2012-04-07 13:00:00 239.0 2.682 304 19.44 29.44 18 1032 11.4 312  8.047 1061 3.576  15
2012-04-07 14:00:00 239.0 2.235 320 20.56 30.56 17 1031 10.9 272  8.047 1002 2.682 348
2012-04-07 15:00:00 239.0 2.682 321 21.11 29.44 15 1030 10.4 281  7.600  865 3.129 329 period.apply > head(EURUSD);tail(EURUSD)
                       Open    High     Low   Close
2009-05-01 00:10:00 1.32436 1.32600 1.32436 1.32587
2009-05-01 00:20:00 1.32589 1.32597 1.32430 1.32431
2009-05-01 00:30:00 1.32441 1.32543 1.32432 1.32479
2009-05-01 00:40:00 1.32484 1.32554 1.32482 1.32543
2009-05-01 00:50:00 1.32551 1.32610 1.32532 1.32538
2009-05-01 01:00:00 1.32538 1.32618 1.32462 1.32462
                       Open    High     Low   Close
2009-05-31 23:10:00 1.41175 1.41281 1.41129 1.41262
2009-05-31 23:20:00 1.41258 1.41259 1.41205 1.41215
2009-05-31 23:30:00 1.41206 1.41210 1.41128 1.41132
2009-05-31 23:40:00 1.41132 1.41147 1.41062 1.41093
2009-05-31 23:50:00 1.41102 1.41102 1.41032 1.41077
2009-06-01 00:00:00 1.41077 1.41099 1.41002 1.41052 > EURUSDfiltered <- EURUSD['T12:00:00/T16:00:00']

> tail(EURUSDfiltered,60)
                       Open    High     Low   Close
2009-05-27 14:30:00 1.39063 1.39121 1.38873 1.39094
2009-05-27 14:40:00 1.39098 1.39120 1.38863 1.39075
2009-05-27 14:50:00 1.39079 1.39107 1.38935 1.39020
2009-05-27 15:00:00 1.39016 1.39343 1.38986 1.39286
2009-05-27 15:10:00 1.39286 1.39293 1.38711 1.38898
2009-05-27 15:20:00 1.38898 1.38961 1.38744 1.38824
2009-05-27 15:30:00 1.38824 1.39157 1.38814 1.39148
2009-05-27 15:40:00 1.39145 1.39281 1.39064 1.39248
2009-05-27 15:50:00 1.39245 1.39276 1.39123 1.39143
2009-05-27 16:00:00 1.39145 1.39251 1.39140 1.39231
2009-05-28 12:00:00 1.38708 1.38715 1.38524 1.38565
2009-05-28 12:10:00 1.38563 1.38633 1.38540 1.38594
2009-05-28 12:20:00 1.38596 1.38750 1.38528 1.38691
2009-05-28 12:30:00 1.38691 1.38754 1.38646 1.38710
2009-05-28 12:40:00 1.38721 1.38976 1.38668 1.38910
2009-05-28 12:50:00 1.38913 1.38962 1.38761 1.38775
2009-05-28 13:00:00 1.38777 1.38811 1.38629 1.38680
....
2009-05-28 15:30:00 1.39660 1.39691 1.39584 1.39643
2009-05-28 15:40:00 1.39646 1.39802 1.39616 1.39643
2009-05-28 15:50:00 1.39643 1.39704 1.39574 1.39668
2009-05-28 16:00:00 1.39666 1.39684 1.39423 1.39467
2009-05-29 12:00:00 1.41076 1.41076 1.40890 1.40967
2009-05-29 12:10:00 1.40965 1.41010 1.40870 1.40874
2009-05-29 12:20:00 1.40874 1.41062 1.40870 1.41010
2009-05-29 12:30:00 1.41008 1.41013 1.40844 1.40940
2009-05-29 12:40:00 1.40933 1.41140 1.40886 1.40985
2009-05-29 12:50:00 1.40985 1.41075 1.40887 1.41073
.... preiod.apply endpoints > ep <- endpoints(EURUSDfiltered, on='days')
> aggValues <- period.apply(EURUSDfiltered, INDEX=ep, FUN=mean)
> aggValues
                        Open     High      Low    Close
2009-05-01 16:00:00 1.326569 1.327338 1.325839 1.326445
2009-05-04 16:00:00 1.329267 1.330415 1.328654 1.329759
2009-05-05 16:00:00 1.338648 1.339428 1.337636 1.338623
2009-05-06 16:00:00 1.331870 1.332957 1.330978 1.331909
2009-05-07 16:00:00 1.339542 1.341126 1.337957 1.339760
2009-05-08 16:00:00 1.347692 1.348982 1.346786 1.347995
2009-05-11 16:00:00 1.359852 1.360683 1.359177 1.359987
2009-05-12 16:00:00 1.365657 1.366473 1.364534 1.365473
2009-05-13 16:00:00 1.360978 1.361865 1.359939 1.360888
2009-05-14 16:00:00 1.358187 1.359207 1.357512 1.358386
2009-05-15 16:00:00 1.356786 1.357672 1.355668 1.356690
2009-05-18 16:00:00 1.349660 1.350412 1.349085 1.349679
2009-05-19 16:00:00 1.360091 1.360750 1.359121 1.360065
2009-05-20 16:00:00 1.373703 1.374888 1.373062 1.373990
2009-05-22 16:00:00 1.399224 1.400354 1.398262 1.399429
2009-05-25 16:00:00 1.399991 1.400309 1.399607 1.399976
2009-05-26 16:00:00 1.393970 1.395064 1.393425 1.394333
2009-05-27 16:00:00 1.392505 1.393589 1.391215 1.392552
2009-05-28 16:00:00 1.391658 1.392870 1.390735 1.391952
2009-05-29 16:00:00 1.411398 1.412516 1.410404 1.411468 ?.subset.xts When a raw character vector is used for the i subset argument, it is processed as if it was ISO-8601 compliant. T
-------------------------------------------------------------------------------------------------------
f <- function(x)  {
  1/30 * (x+3.5)*(x+2)*(x+1)*(x-1)*(x-3)*(x-4) + 2
}
vec <- seq(-4,4, .01)
plot( f(vec) ~ vec, type="l" )

for( startX in c(-3.5,-.5,3) ) {
  opt <- optim( list(x=startX), fn=f )
  points( x=opt$par, y=opt$value, pch="x", col="red"  )
}
-------------------------------------------------------------------------------------------------------
function(x) x^2 + x x^2 + x foo <- function(math_fun, var){

   curve(math_fun, -5, 5)  #plot the mathematical function
   y = math_fun(var)       #compute the function based on a user provided x value
   points(x=var, y=y)      #plot the value from the last step.
}

#A user can use the function defined above in a way as shown below:
Function <- function(x) x^2 + x
foo(Function, var = 2)
-------------------------------------------------------------------------------------------------------
density x = rnorm(100)
d = density(x, from=-5, to = 5, n = 1000)
d$x
d$y z x z = c(-2, -1, 2)
x = seq(-5, 5, 0.01) plot(0, 0, xlim=c(-5, 5), ylim=c(-0.02, 0.8), 
     pch=NA, ylab="", xlab="z")
for(i in 1:length(z)) {
   points(z[i], 0, pch="X", col=2)
}
 abline(h=0) ## Now we combine the kernels,
x_total = numeric(length(x))
for(i in 1:length(x_total)) {
  for(j in 1:length(z)) {
    x_total[i] = x_total[i] + 
      dnorm(x[i], z[j], sd=1)
  }
} lines(x, x_total, col=4, lty=2) ## Just as a histogram is the sum of the boxes, 
## the kernel density estimate is just the sum of the bumps. 
## All that's left to do, is ensure that the estimate has the
## correct area, i.e. in this case we divide by $n=3$:

plot(x, x_total/3, 
       xlim=c(-5, 5), ylim=c(-0.02, 0.8), 
       ylab="", xlab="z", type="l")
abline(h=0) density(z, adjust=1, bw=1)
-------------------------------------------------------------------------------------------------------
base ggplot2 bandline<-function(x, low.col, high.col, axis=TRUE){
    l <- max(unlist(lapply(x, length)), na.r=TRUE)
    r <- range(unlist(x), na.rm=TRUE)
    par(mfcol=c(length(x), 1))
    for(i in 1:length(x)){
        y <- boxplot.stats(x[[i]])
        ifelse(i==1, par(mar=c(0,3,3,3)), 
                     ifelse(i==length(x), par(mar=c(3,3,0,3)), 
                                          par(mar=c(0,3,0,3))))
        plot(NA, axes=F, bty="n", xlim=c(1,l), ylim=r, xaxs="i")
        rect(1,y$stats[2], l, y$stats[1], col="grey80", border=NA)
        rect(1,y$stats[4], l, y$stats[2], col="grey60", border=NA)
        rect(1,y$stats[5], l, y$stats[4], col="grey40", border=NA)
        abline(h=y$stats[3],col="white", lwd=2)
        lines(seq_along(x[[i]]), x[[i]])
        zhigh <- zlow <- x[[i]]
        zhigh[zhigh<=y$stats[5]]<-NA
        zlow[zlow>=y$stats[1]]<-NA
        points(seq_along(x[[i]]), zlow, bg=low.col, pch=21,cex=2)
        points(seq_along(x[[i]]), zhigh, bg=high.col, pch=21, cex=2)
        if(axis==TRUE){
            axis(2, at=pretty(x[[i]]), las=2)
            ifelse(i==1, axis(3, at=seq_len(l)), 
                         ifelse(i==length(x),axis(1, at=seq_len(l)),""))
            }
        mtext(names(x)[i], side=4, srt=270, line=1)
    }
} set.seed(1)
dat<-list(a=rnorm(100), b=rnorm(100), c=rnorm(100), d=rnorm(100))
bandline(dat, "black", "white", axis=FALSE)
-------------------------------------------------------------------------------------------------------
species <- levels(raw$SpCode)
for(i in 1:length(species))  
            {
            #open the file for writing
             pdf(paste0(species[i],".pdf"),width=5,height=4)
             plot (wrld_simpl, xlim=c(-100,-55), ylim=c(23,63), axes=TRUE, col='light grey')
             box() #adds box around map
             title(main=species[i]) #adds main title to map which should be the species name associated with the data
             points(raw$longitude[raw$SpCode == species[i]],raw$latitude[raw$SpCode == species[i]], col='black', pch=21, bg="red", cex=0.85)
             dev.off()
             }
-------------------------------------------------------------------------------------------------------
data$lx=log(data$x)
plot(data$lx,data$y) # needs at least a cubic polynomial 
m1 = lm(y~poly(lx,3),data=data) # fit a cubic
points(data$lx,fitted(m1),pch=19)
-------------------------------------------------------------------------------------------------------
xts library(xts)
dat.ts <- xts(x=data[,-1],                   ## create an xts object 
              order.by=as.Date(data[,1]))    ## coerce the index to date
dat.quart <- apply.quarterly(dat.ts,mean)    ## apply for each quarter rbind(head(dat.quart),tail(dat.quart))
               tmpd pm10median  so2median
1987-03-31 33.60556         NA         NA
1987-06-30 62.19231         NA -0.3283393
1987-09-30 71.31522         NA -1.9137842
1987-12-31 41.09783         NA         NA
1988-03-31 27.06593         NA         NA
1988-06-30 60.48352         NA         NA
1999-09-30 71.01087   2.697414 -0.4532943
1999-12-31 42.86957   1.565251 -0.4035715
2000-03-31 34.74725  -4.704813  0.2392453
2000-06-30 59.07692         NA -0.5426823
2000-09-30 69.67391         NA -1.9221470
2000-12-31 36.59783         NA -0.2387025 dat.ts <- xts(x=data[,-1],                   ## create an xts object 
              order.by=as.Date(data[,1]))    ## coerce the index to date
dat.m <- rollmean(dat.ts,k=2)                ## compute the MA
ep <- endpoints(dat.m, "quarters")           ## create an index
## this split the seriers by quarter
xx <- sapply(1:(length(ep) - 1), function(y) { 
  dat.m[(ep[y] + 1):ep[y + 1]]
})
-------------------------------------------------------------------------------------------------------
raster ## S4 method for signature 'matrix'
raster(x, xmn=0, xmx=1, ymn=0, ymx=1, crs=NA, template=NULL) xmn xmx ymn ymx xmn xmx ymn ymx tempMap <- raster(temp_matrix, xmn = 1, xmx = 11, ymn = 1, ymx=11)
plot(tempMap,axes = FALSE,legend=FALSE)
points(c(10,9,1), c(10,10,10))
-------------------------------------------------------------------------------------------------------
plot(rnorm(50), pch=c(15:17), col=1:2)
# Plot legend text, inset could be used to shift legend text to the right
pos <- legend('topleft', legend=c("a","b","c"), cex=1.5)
# Plot symbols in two columns, shifted to the left by 3 and 1 respectively
points(x=rep(pos$text$x, times=2) - c(3,1), 
    y=rep(pos$text$y, times=2), 
    pch=rep(c(15:17), times=2), col=rep(1:2, times=3))
-------------------------------------------------------------------------------------------------------
library(sos)
???"non-metric"
???"Voronoi" # Sample data: a distance matrix
d <- dist( matrix( rnorm(200), nc=10 ) )

# Dimension reduction, via non-metric multidimensional scaling
library(MASS)
r <- sammon( d )

# Plot the Voronoi tessellation
library(tripack)
x <- r$points
plot( voronoi.mosaic(x[,1], x[,2]) )
points(x, pch=13) prcomp MASS::isoMDS MASS:sammon vegan::isomap lle::lle tsne::tsne
-------------------------------------------------------------------------------------------------------
panel.groups panel.superpose group.number panelfun <- function(...,type,group.number) {
    if (group.number==3) {
        panel.points(...)
        panel.lines(...)
    } else {
        panel.points(...,type="s")
    }
}

xyplot(lower.lim+upper.lim+observed ~ time, data=my.df,
    panel=function(...) panel.superpose(...,panel.groups=panelfun),
       col=c(1,1,2))
-------------------------------------------------------------------------------------------------------
lattice segments set.seed(12345)

# Generate some data
num.points <- 10
x <- sort(sample(1:100, num.points))
y <- sample(1:40, num.points, replace=T)


# Plot the data with style = "s" and "S"
par(mfrow=c(1,3))

plot(x, y, "s", col="red", lwd=2, las=1, 
     main="Style: 's'", xlim=c(0, 100))
points(x, y, pch=19, col="red", cex=0.8)

plot(x, y, "S", col="blue", lwd=2, las=1, 
     main="Style: 'S'", xlim=c(0, 100))
points(x, y, pch=19, col="blue", cex=0.8)

# Now plot our points
plot(x, y, pch=19, col="orange", cex=0.8, las=1, 
     main="Centered steps", xlim=c(0, 100))

# Calculate the starting and ending points of the
# horizontal segments, by shifting the x coordinates
# by half the difference with the next point
# Note we leave the first and last point as starting and
# ending points
x.start <- x - (c(0, diff(x)/2))
x.end <- x + (c(diff(x)/2, 0))

# Now draw the horizontal segments
segments(x.start, y, x.end, y, col="orange", lwd=2)
# and the vertical ones (no need to draw the last one)
segments(x.end[-length(x.end)], y[1:(length(y)-1)], 
         x.end[-length(x.end)], y[-1], col="orange", lwd=2)
-------------------------------------------------------------------------------------------------------
state.mean.interest <- data.frame("State" = c("AZ", "ID", "SC", "TX", "NJ"),
                                  "Mean.Interest.Rate" = c(10, 12, 14, 11, 9)) library(maps)
data(state) state.location <- data.frame ("State" = state.abb,
                              "Longitude" = state.center$x,
                              "Latitude" = state.center$y) state.mean.interest <- merge(state.mean.interest, state.location) map("state")
points(state.mean.interest$Longitude,state.mean.interest$Latitude,pch = 19,col = "blue",cex = 2* state.mean.interest$Mean.Interest.Rate/max(state.mean.interest$Mean.Interest.Rate))
-------------------------------------------------------------------------------------------------------
geometry mesh.drectangle combn library(geometry)
## I generate some data 
set.seed(1234)
p.x <- sample(1:100,size=30,replace=T)
p.y <- sample(1:100,size=30,replace=T)
points <- cbind(p.x,p.y)

## the  algortithm
ll <- combn(1:nrow(points),2,function(x){
     x1<- p.x[x[1]]; y1 <- p.y[x[1]]
     x2<- p.x[x[2]]; y2 <- p.y[x[2]]
     p <- points[-x,]
     d <- mesh.drectangle(p,x1,y1,x2,y2)
     res <- NA
     if(length(which(d <0))){
        points.in = as.data.frame(p,ncol=2)[ d < 0 , ]
       res <- list(n = nrow(points.in), 
                    rect = list(x1=x1,x2=x2,y1=y1,y2=y2),
                    points.in = points.in)
     }
     res
},simplify=F)
ll <- ll[!is.na(ll)]

## the result
nn <- do.call(rbind,lapply(ll,'[[','n')) library(grid)
grid.newpage()
vp <- plotViewport(xscale = extendrange(p.x),
                          yscale = extendrange(p.y))
pushViewport(vp)
grid.xaxis()   
grid.yaxis()
grid.points(x=points[,'p.x'],y=points[,'p.y'],pch='*')
cols <- rainbow(length(ll))
ll <- ll[nn == 5]           ## here I plot only the rectangle with 5 points 
lapply(seq_along(ll),function(i){
            x <- ll[[i]]
            col <- sample(cols,1)
            x1<- x$rect$x1; x2<- x$rect$x2
            y1<- x$rect$y1; y2<- x$rect$y2
            grid.rect(x=(x1+x2)*.5,y=(y1+y2)*.5,
                      width= x2-x1,height = y2-y1,
                      default.units ='native',
                      gp=gpar(fill=col,col='red',alpha=0.2)
                      )
            grid.points(x=x$points.in$p.x,y=x$points.in$p.y,pch=19,gp=gpar(col=rep(col,x$n))) 

 }
)
upViewport()
-------------------------------------------------------------------------------------------------------
points plot(x2, y2, ...) points(x2, y2, pch="*", col= 'red')
-------------------------------------------------------------------------------------------------------
tile.list secr::pointsInPolygon # Sample data
x <- matrix( rnorm(20), nc = 2 )
y <- matrix( rnorm(1000), nc=2 )

# Tessellation
library(deldir)
d <- deldir(x[,1], x[,2])
plot(d, wlines="tess")

# Pick a cell at random 
cell <- sample( tile.list(d), 1 )[[1]]
points( cell$pt[1], cell$pt[2], pch=16 )
polygon( cell$x, cell$y, lwd=3 )

# Select the points inside that cell
library(secr)
i <- pointsInPolygon(
  y, 
  cbind( 
    c(cell$x,cell$x[1]), 
    c(cell$y,cell$y[1])
  )
)
points(y[!i,], pch=".")
points(y[i,], pch="+")

# Compute a tessellation of those points
dd <- deldir(y[i,1], y[i,2])
plot(dd, wlines="tess", add=TRUE) distance_to_segment <- function(M, A, B) {
  norm <- function(u) sqrt(sum(u^2))
  lambda <- sum( (B-A) * (M-A) ) / norm(B-A)^2
  if( lambda <= 0 ) {
    norm(M-A)
  } else if( lambda >= 1 ) {
    norm(M-B)
  } else {
    N <- A + lambda * (B-A)
    norm(M-N)
  }
}
A <- c(-.5,0)
B <- c(.5,.5)
x <- seq(-1,1,length=100)
y <- seq(-1,1,length=100)
z <- apply(
  expand.grid(x,y), 
  1, 
  function(u) distance_to_segment( u, A, B )
)
par(las=1)
image(x, y, matrix(z,nr=length(x)))
box()
segments(A[1],A[2],B[1],B[2],lwd=3)

library(secr)
distance_to_polygon <- function(x, poly) {
  closed_polygon <- rbind(poly, poly[1,])
  if( pointsInPolygon( t(x), closed_polygon ) )
    return(0)
  d <- rep(Inf, nrow(poly))
  for(i in 1:nrow(poly)) {
    A <- closed_polygon[i,]
    B <- closed_polygon[i+1,]
    d[i] <- distance_to_segment(x,A,B)
  }
  min(d)
}
x <- matrix(rnorm(20),nc=2)
poly <- x[chull(x),]
x <- seq(-5,5,length=100)
y <- seq(-5,5,length=100)
z <- apply(
  expand.grid(x,y), 
  1, 
  function(u) distance_to_polygon( u, poly )
)
par(las=1)
image(x, y, matrix(z,nr=length(x)))
box()
polygon(poly, lwd=3) x --> lambda * x + a
y --> lambda * y + b # Sample data 
x <- matrix(rnorm(20),nc=2)
x <- x[chull(x),]
y <- matrix( c(1,2) + 5*rnorm(20), nc=2 )
plot(y, axes=FALSE, xlab="", ylab="")
polygon(x)

# Function to minimize:
# either the sum of the squares of the distances to the polygon, 
# if at least one point is outside, 
# or minus the square of the scaling factor.
# It is not continuous, but (surprisingly) that does not seem to be a problem.
f <- function( p ) {
  lambda <- log( 1 + exp(p[1]) )
  a <- p[2:3]
  y0 <- colMeans(y)
  transformed_points <- t( lambda * (t(y)-y0) + a )
  distances <- apply(
    transformed_points, 
    1, 
    function(u) distance_to_polygon(u, x)
  )
  if( all(distances == 0) ) - lambda^2
  else                      sum( distances^2 )
}
# Minimize this function
p <- optim(c(1,0,0), f)$par
# Compute the optimal parameters
lambda <- log( 1 + exp(p[1]) )
a <- p[2:3]
y0 <- colMeans(y)
# Compute the new coordinates
transformed_points <- t( lambda * (t(y)-y0) + a )
# Plot them
segments( y[,1], y[,2], transformed_points[,1], transformed_points[,2], lty=3 )
points( transformed_points, pch=3 )
library(deldir)
plot( 
  deldir( transformed_points[,1], transformed_points[,2] ), 
  wlines="tess", add=TRUE 
)
-------------------------------------------------------------------------------------------------------
set.seed(47)
n <- 1e4
xx <- runif(n)
yy <- rexp(n)
colors <- rep("black", n)
colors[which.max(yy)] <- "red"
plot(xx, yy, col = colors, pch = 16) plot(xx, yy, pch = 16)
points(xx[which.max(yy)], yy[which.max(yy)], col = "red", pch = 17, cex = 2)
-------------------------------------------------------------------------------------------------------
plot(density(Data$X1),col="red") points(density(Data$X2),col="green") xlim ylim foo <- density(Data$X1) bar <- density(Data$X2) plot(foo,col="red", xlim=c(min(foo$x,bar$x),max(foo$x,bar$x)) ylim=c(min(foo$y,bar$y),max(foo$y,bar$y)) points(bar,col="green")
-------------------------------------------------------------------------------------------------------
bacteria bacteria.glm <- glm(cbind(Bacteria_count, 126 - Bacteria_count) ~ Time, 
                    data=bacteria, family=binomial(logit))

plot(Bacteria_count/126 ~ Time, data=bacteria)
lines(bacteria$Time, bacteria.glm$fitted, col="red") bacteria_intervals <- seq(0, 173.44, 30)
bac_predict<-data.frame(Time=bacteria_intervals, 
                        Bacteria_count=predict(bacteria.glm, data.frame(Time=bacteria_intervals), 
                                               type="response")*126)

plot(bacteria)
points(Bacteria_count~Time, data=bac_predict, col="red", pch=16) bac_predict
##   Time Bacteria_count
## 1    0       12.39587
## 2   30       76.11856
## 3   60      120.36021
## 4   90      125.57925
## 5  120      125.96982
## 6  150      125.99784 bacteria_linear <- approx(bacteria, xout=seq(0, 173.44, 30))
setNames(as.data.frame(bacteria_linear), c("Time", "Bacteria_count"))
##   Time Bacteria_count
## 1    0             NA
## 2   30        84.1200
## 3   60       118.5902
## 4   90       126.0000
## 5  120       126.0000
## 6  150       126.0000 bacteria_spline <- spline(bacteria, xout=seq(0, 173.44, 30))
setNames(as.data.frame(bacteria_spline), c("Time", "Bacteria_count"))
##   Time Bacteria_count
## 1    0      -1.672644
## 2   30      84.110483
## 3   60     118.854542
## 4   90     126.000000
## 5  120     126.000000
## 6  150     126.000000
-------------------------------------------------------------------------------------------------------
require(mvtnorm)
l=3
sigma <- matrix(c(l,2,2,2*l), ncol=2)
C2 <- rmvnorm(n=15, mean=c(1,3), sigma=sigma)
C1 <- rmvnorm(n=10, mean=c(0,0), sigma=sigma)

 plot(C1, xlim=range( c(C1[,1],C2[,1]) ) , ylim=range( c(C1[,2],C2[,2]) ) , col="red")
 points(C2,  col="blue")
-------------------------------------------------------------------------------------------------------
panel.level.plot latticeExtra calendarHeat date.seq value dotw woty   yr month seq
1 2012-01-01    NA    0    2 2012     1   1
2 2012-01-02    NA    1    2 2012     1   2
3 2012-01-03    NA    2    2 2012     1   3
4 2012-01-04    NA    3    2 2012     1   4
5 2012-01-05    NA    4    2 2012     1   5
6 2012-01-06    NA    5    2 2012     1   6 dat <- transformdata(stock.data$Date, stock.data$by) levelplot sacles theme panel' function library(latticeExtra)
levelplot(value~woty*dotw | yr, data=dat, border = "black",
          layout = c(1, nyr%%7),
          col.regions = (calendar.pal(ncolors)),
          aspect='iso',
          between = list(x=0, y=c(1,1)),
          strip=TRUE,
          panel = function(...) {
            panel.levelplot(...)
            calendar.division(...)  
            panel.levelplot.points(...,na.rm=T,
                                   col='blue',alpha=0.5,
                                   ## you can play with cex and pch here to get the pattern you      
                                   ## like
                                   cex =dat$value/max(dat$value,na.rm=T)*3
                                   pch=ifelse(is.na(dat$value),NA,20),
                                   type = c("p"))

          },
          scales= scales,
          xlim =extendrange(dat$woty,f=0.01),
          ylim=extendrange(dat$dotw,f=0.1),
          cuts= ncolors - 1,
          colorkey= list(col = calendar.pal(ncolors), width = 0.6, height = 0.5),
          subscripts=TRUE,
          par.settings = calendar.theme) scales = list(
   x = list( at= c(seq(2.9, 52, by=4.42)),
             labels = month.abb,
             alternating = c(1, rep(0, (nyr-1))),
             tck=0,
             cex =1),
   y=list(
     at = c(0, 1, 2, 3, 4, 5, 6),
     labels = c("Sunday", "Monday", "Tuesday", "Wednesday", "Thursday",
                "Friday", "Saturday"),
     alternating = 1,
     cex =1,
     tck=0)) calendar.theme <- list(
   xlab=NULL,ylab=NULL,
   strip.background = list(col = "transparent"),
   strip.border = list(col = "transparent"),
   axis.line = list(col="transparent"),
   par.strip.text=list(cex=2)) grid
-------------------------------------------------------------------------------------------------------
lines set.seed(1)
x1 = ceiling(rlnorm(1000, 4)) m = displ$new(x1) plot(m) xmin alpha lines m$setXmin(100)
p_100 = estimate_pars(m)
m$setPars(p_100)
lines(m, col=2, lwd=2)

##Line 2    
m$setXmin(202)
p_200 = estimate_pars(m)
m$setPars(p_200)
lines(m, col=3, lwd=2) set.seed(1)
x1 = ceiling(rlnorm(1000, 4))
x2 = ceiling(rlnorm(1000, 5)) m1 = displ$new(x1)
m1$setXmin(estimate_xmin(m1))

m2 = displ$new(x2)
m2$setXmin(estimate_xmin(m2)) pts2 pts2 = plot(m2) plot(m1)
points(pts2$x, pts2$y, col=3)
lines(m1, col=2)
lines(m2, col=4)
-------------------------------------------------------------------------------------------------------
period.apply data.frame xts set.seed(1)
temp <- data.frame(date = seq(as.POSIXct("2012-10-22 12:10:21 EDT", tz="EDT"), 
                              length.out = 100, by = "11 min"),
                   values = rnorm(100))
library(xts)
x.temp <- xts(temp[-1], temp[, 1])
head(x.temp)
#                         values
# 2012-10-22 12:10:21 -0.6264538
# 2012-10-22 12:21:21  0.1836433
# 2012-10-22 12:32:21 -0.8356286
# 2012-10-22 12:43:21  1.5952808
# 2012-10-22 12:54:21  0.3295078
# 2012-10-22 13:05:21 -0.8204684 my93minAgg <- period.apply(x.temp, 
                           INDEX = endpoints(x.temp, on = "mins", k = 93), 
                           FUN = sum)
my93minAgg
#                         values
# 2012-10-22 13:16:21  0.3133101
# 2012-10-22 14:55:21  1.1543989
# 2012-10-22 16:23:21  2.1290954
# 2012-10-22 18:02:21  0.5205041
# 2012-10-22 19:30:21 -0.6007850
# 2012-10-22 21:09:21  1.5058904
# 2012-10-22 22:37:21  0.9999036
# 2012-10-23 00:16:21  1.1553448
# 2012-10-23 01:44:21  1.9799783
# 2012-10-23 03:23:21 -1.7152471
# 2012-10-23 04:51:21  2.9882778
# 2012-10-23 06:19:21  0.4580653 plot(my93minAgg, main = "My 93 Minute Aggregation")
-------------------------------------------------------------------------------------------------------
xts endpoints sapply CADaily <- read.table(text ='     Climate_Division       Date      Rain
      885                1 1948-07-01 0.8750000
      892                1 1948-07-02 2.9166667
      894                1 1948-07-03 0.7916667
      895                1 1948-07-04 0.4305556
      898                1 1948-07-05 0.8262061
      901                1 1948-07-06 0.5972222
      904                1 1948-07-17 0.04166667
      905                1 1948-07-18 0.08333333
      907                1 1948-07-20 0.04166667
      909                1 1948-07-22 0.12500000',head=T)
dat.xts <- xts(CADaily[,-2], order.by= as.POSIXct(CADaily[,2]))
INDEX <- endpoints(dat.xts, 'weeks')

lapply(1:(length(INDEX) - 1), function(y) {
    y <- dat.xts[(INDEX[y] + 1):INDEX[y + 1]]
    data.frame(y$Climate_Division,mean(y$Rain))

  }) [[1]]
           Climate_Division mean.y.Rain.
1948-07-01                1     1.168019
1948-07-02                1     1.168019
1948-07-03                1     1.168019
1948-07-04                1     1.168019
1948-07-05                1     1.168019

[[2]]
           Climate_Division mean.y.Rain.
1948-07-06                1    0.5972222

[[3]]
           Climate_Division mean.y.Rain.
1948-07-17                1       0.0625
1948-07-18                1       0.0625

[[4]]
           Climate_Division mean.y.Rain.
1948-07-20                1   0.08333334
1948-07-22                1   0.08333334
-------------------------------------------------------------------------------------------------------
y = Xb + Zu + e library(lme4)
fm1 <- lmer(Reaction ~ Days + (Days|Subject), sleepstudy)

# Xb 
fix <- getME(fm1,'X') %*% fixef(fm1)
# Zu
ran <- t(as.matrix(getME(fm1,'Zt'))) %*% unlist(ranef(fm1))
# Xb + Zu
fixran <- fix + ran > head(cbind(fix, ran, fixran, fitted(fm1)))
         [,1]      [,2]     [,3]     [,4]
[1,] 251.4051  2.257187 253.6623 253.6623
[2,] 261.8724 11.456439 273.3288 273.3288
[3,] 272.3397 20.655691 292.9954 292.9954
[4,] 282.8070 29.854944 312.6619 312.6619
[5,] 293.2742 39.054196 332.3284 332.3284
[6,] 303.7415 48.253449 351.9950 351.9950

# Xb + Zu
> all(round((fixran),6) == round(fitted(fm1),6))
[1] TRUE

# e = y - (Xb + Zu)
> all(round(resid(fm1),6) == round(sleepstudy[,"Reaction"]-(fixran),6))
[1] TRUE

nobs <- 10 # 10 observations per subject
legend = list(text=list(c("y", "Xb + Zu", "Xb")), lines = list(col=c("blue", "red", "black"), pch=c(1,1,1), lwd=c(1,1,1), type=c("b","b","b")))
require(lattice)
xyplot(
    Reaction ~ Days | Subject, data = sleepstudy,
    panel = function(x, y, ...){
        panel.points(x, y, type='b', col='blue')
        panel.points(x, fix[(1+nobs*(panel.number()-1)):(nobs*(panel.number()))], type='b', col='black')
        panel.points(x, fixran[(1+nobs*(panel.number()-1)):(nobs*(panel.number()))], type='b', col='red')
    },
    key = legend
)
-------------------------------------------------------------------------------------------------------
boxplot plot plot TRUE stats matpoints matplot(..., type = 'p') matpoints(t(boxplot(test, plot = FALSE)$stats), pch = 19, col = 'black')
-------------------------------------------------------------------------------------------------------
tree.text='(((XXX:4.2,ZZZ:4.2):3.1,HHH:7.3):6.3,AAA:13.6);' ape library(ape)
tree <- read.tree(text='(((XXX:4.2,ZZZ:4.2):3.1,HHH:7.3):6.3,AAA:13.6);')
is.ultrametric(tree)
hc <- as.hclust.phylo(tree) latticeExtra levelplot lattice library(latticeExtra)
dd.col <- as.dendrogram(hc)
col.ord <- order.dendrogram(dd.col)
mat <- matrix(rnorm(4*4),nrow=4)
colnames(mat) <- tree$tip.label
rownames(mat) <- tree$tip.label
levelplot(mat[tree$tip,tree$tip],type=c('g','p'),
          aspect = "fill",
          colorkey = list(space = "left"),
          legend =
            list(right =
                   list(fun = dendrogramGrob,
                        args =
                          list(x = dd.col, 
                               side = "right",
                               size = 10))),
          panel=function(...){
            panel.fill('black',alpha=0.2)
            panel.levelplot.points(...,cex=12,pch=23)
          }
)
-------------------------------------------------------------------------------------------------------
PCH <- 0
plot(c(142,169), c(0,11), type="n")
for(i in unique(DATA$x)) {
  for(j in unique(DATA$y)) {
    PCH <- PCH+1
    select <- DATA$x == i & DATA$y == j
    X <- DATA[select,"a"] 
    Y <- DATA[select,"z"]
    points(X,Y,pch=PCH)
  }  
} <- = = ;
-------------------------------------------------------------------------------------------------------
plot(c(142,169),c(0,11),type="n")
  for(i in unique(DATA$x)) {
    for(j in unique(DATA$y)) {
      PCH=PCH+1
      X = DATA[(DATA$x==i) & (DATA$y==j),"a"]; 
      Y = DATA[(DATA$x==i) & (DATA$y==j),"z"]
     (points(X,Y,pch=PCH))
    }  
  }
-------------------------------------------------------------------------------------------------------
pushViewport(viewport(x=0, y=1, xscale=c(1, 10), yscale=c(0, 100), width=0.25, height=0.25, default.units="npc", just=c("left","bottom"), clip="off")) library(grid)

# Specify general chart options.
chart_Fill = "lemonchiffon"
chart_Col = "snow3"
space_Background = "white"
title_CEX = 0.8
axis_CEX = 0.6
chart_Width <- 3/3
chart_Height <- 2/5

# Function to initialize a plotting area.
init_Plot <- function(
    .df,
    .x_Loc, 
    .y_Loc, 
    .justify, 
    .width, 
    .height
    ){

    # Initialize plotting area to fit data.
    # We have to turn off clipping to make it
    # easy to plot the labels around the plot.
    pushViewport(viewport(xscale=c(min(.df[,1]), max(.df[,1])), yscale=c(min(0,min(.df[,-1])), max(.df[,-1])), x=.x_Loc, y=.y_Loc, width=.width, height=.height, just=.justify, clip="off", default.units="native"))

    # Color behind text.
    grid.rect(x=0, y=0, width=unit(axis_CEX, "lines"), height=1, default.units="npc", just=c("right", "bottom"), gp=gpar(fill=space_Background, col=space_Background))
    grid.rect(x=0, y=1, width=1, height=unit(title_CEX, "lines"), default.units="npc", just=c("left", "bottom"), gp=gpar(fill=space_Background, col=space_Background))

    # Color in the space.
    grid.rect(gp=gpar(fill=chart_Fill, col=chart_Col))
}

# Function to finalize and label a plotting area.
finalize_Plot <- function(
    .df, 
    .plot_Title
    ){

    # Label plot using the internal reference
    # system, instead of the parent window, so
    # we always have perfect placement.
    grid.text(.plot_Title, x=0.5, y=1.05, just=c("center","bottom"), rot=0, default.units="npc", gp=gpar(cex=title_CEX))
    grid.text(paste(names(.df)[-1], collapse=" & "), x=-0.05, y=0.5, just=c("center","bottom"), rot=90, default.units="npc", gp=gpar(cex=axis_CEX))
    grid.text(names(.df)[1], x=0.5, y=-0.05, just=c("center","top"), rot=0, default.units="npc", gp=gpar(cex=axis_CEX))

    # Finalize plotting area.
    popViewport()
}

# Function to plot a filled line chart of
# the data in a data frame.  The first column
# of the data frame is assumed to be the
# plotting index, with each column being a
# set of y-data to plot.  All data is assumed
# to be numeric.
plot_Line_Chart <- function(
    .df,
    .x_Loc,
    .y_Loc,
    .justify,
    .width,
    .height,
    .colors,
    .plot_Title
    ){

    # Initialize plot.
    init_Plot(.df, .x_Loc, .y_Loc, .justify, .width, .height)

    # Calculate what value to use as the
    # return for the polygons.
    y_Axis_Min <- min(0, min(.df[,-1]))

    # Plot each set of data as a polygon,
    # so we can fill it in with color to
    # make it easier to read.
    for (i in 2:ncol(.df)){
        grid.polygon(x=c(min(.df[,1]),.df[,1], max(.df[,1])), y=c(y_Axis_Min,.df[,i], y_Axis_Min), default.units="native", gp=gpar(fill=.colors[i-1], col=.colors[i-1], alpha=1/ncol(.df)))
    }

    # Draw plot axes.
    grid.lines(x=0, y=c(0,1), default.units="npc")
    grid.lines(x=c(0,1), y=0, default.units="npc")

    # Finalize plot.
    finalize_Plot(.df, .plot_Title)

}

# Function to plot a scatterplot of
# the data in a data frame.  The
# assumptions are the same as 'plot_Line_Chart'.
plot_Scatterplot <- function(
    .df,
    .x_Loc,
    .y_Loc,
    .justify,
    .width,
    .height,
    .colors,
    .plot_Title
    ){

    # Initialize plot.
    init_Plot(.df, .x_Loc, .y_Loc, .justify, .width, .height)

    # Plot each set of data as colored points.
    for (i in 2:ncol(.df)){
        grid.points(x=.df[,1], y=.df[,i], pch=19, size=unit(1, "native"), default.units="native", gp=gpar(col=.colors[i-1], alpha=1/ncol(.df)))
    }

    # Draw plot axes.
    grid.lines(x=0, y=c(0,1), default.units="npc")
    grid.lines(x=c(0,1), y=0, default.units="npc")

    # Finalize plot.
    finalize_Plot(.df, .plot_Title)

}

# Function to plot a histogram of
# all the columns in a data frame,
# except the first, which is assumed to
# be an index.
plot_Histogram <- function(
    .df,
    .x_Loc,
    .y_Loc,
    .justify,
    .width,
    .height,
    .colors,
    .plot_Title,
    ...
    ){

    # Create a list containing the histogram
    # data for each data column and calculate
    # data ranges.  Any extra parameters
    # specified will pass to the 'hist' function.
    hist_Data <- list()
    hist_Count_Range <- c(0,NA)
    hist_Breaks_Range <- c(NA,NA)
    for (i in 2:ncol(.df)){
        hist_Data[[i]] <- hist(.df[,i], plot=FALSE, ...)
        hist_Count_Range[2] <- max(max(hist_Data[[i]]$counts), hist_Count_Range[2], na.rm=TRUE)
        hist_Breaks_Range <- c(min(min(hist_Data[[i]]$breaks), hist_Breaks_Range[1], na.rm=TRUE), max(max(hist_Data[[i]]$breaks), hist_Breaks_Range[2], na.rm=TRUE))
    }


    # Initialize plotting area to fit data.
    # We are doing this in a custom way to
    # allow more flexibility than built into
    # the 'init_Plot' function.
    # We have to turn off clipping to make it
    # easy to plot the labels around the plot.
    pushViewport(viewport(xscale=hist_Breaks_Range, yscale=hist_Count_Range, x=.x_Loc, y=.y_Loc, width=.width, height=.height, just=.justify, clip="off", default.units="native"))

    # Color behind text.
    grid.rect(x=0, y=0, width=unit(axis_CEX, "lines"), height=1, default.units="npc", just=c("right", "bottom"), gp=gpar(fill=space_Background, col=space_Background))
    grid.rect(x=0, y=1, width=1, height=unit(title_CEX, "lines"), default.units="npc", just=c("left", "bottom"), gp=gpar(fill=space_Background, col=space_Background))

    # Color in the space.
    grid.rect(gp=gpar(fill=chart_Fill, col=chart_Col))


    # Draw x axis.
    grid.lines(x=c(0,1), y=0, default.units="npc")

    # Plot each set of data as a histogram.
    for (i in 2:ncol(.df)){
        grid.rect(x=hist_Data[[i]]$mids, y=0, width=diff(hist_Data[[i]]$mids[1:2]), height=hist_Data[[i]]$counts, default.units="native", just=c("center","bottom"), gp=gpar(fill=.colors[i-1], col=.colors[i-1], alpha=1/ncol(.df)))
    }

    # Label plot using the internal reference
    # system, instead of the parent window, so
    # we always have perfect placement.
    grid.text(.plot_Title, x=0.5, y=1.05, just=c("center","bottom"), rot=0, default.units="npc", gp=gpar(cex=title_CEX))
    grid.text(paste(names(.df)[-1], collapse=" & "), x=-0.05, y=0.5, just=c("center","bottom"), rot=90, default.units="npc", gp=gpar(cex=axis_CEX))

    # Finalize plotting area.
    popViewport()
}

draw_Sample_Box <- function(
    .x_Loc,
    .y_Loc,
    .x_Scale,
    .y_Scale,
    .justify,
    .width,
    .height,
    .colors,
    .box_X,
    .box_Y,
    .plot_Title
    ){

    pushViewport(viewport(xscale=.x_Scale, yscale=.y_Scale, x=.x_Loc, y=.y_Loc, width=chart_Width, height=chart_Height, just=.justify, clip="off", default.units="native"))

    # Color behind text.
    grid.rect(x=0, y=1, width=1, height=unit(title_CEX, "lines"), default.units="npc", just=c("left", "bottom"), gp=gpar(fill=space_Background, col=space_Background))

    # Color in the space.
    grid.rect(gp=gpar(fill=chart_Fill, col=chart_Col))

    # Label plot.
    grid.text(.plot_Title, x=0.5, y=1.05, just=c("center","bottom"), rot=0, default.units="npc", gp=gpar(cex=title_CEX))

    # Draw box and label points.
    grid.polygon(x=.box_X, y=.box_Y, default.units="native", gp=gpar(fill=.colors[1], col=.colors[2]))
    grid.text(paste(.plot_Title, 1, sep=""), x=min(.box_X), y=min(.box_Y), default.units="native", just=c("right","top"), gp=gpar(cex=0.5))
    grid.text(paste(.plot_Title, 2, sep=""), x=max(.box_X), y=min(.box_Y), default.units="native", just=c("left","top"), gp=gpar(cex=0.5))

    # Finalize plot.
    popViewport()
} # Draw twelve independent charts as
# a demo and connect with lines similar
# to a heiritage chart.
grid.newpage()

# Initialize a viewport to make our locations
# easier to map.
pushViewport(viewport(x=0, y=0, width=1, height=1, just=c("left","bottom"), xscale=c(0,10), yscale=c(0,4)))

# Color background of overall plot.
grid.rect(gp=gpar(fill=space_Background, col=space_Background))

# Store plot locations for convenience.
plot_Loc <- data.frame(x=c(2,4,6,8,1,3,7,9,2,4,6,8), y=c(3,3,3,3,2,2,2,2,1,1,1,1))

# Draw connecting lines.
connections <- data.frame(a=c(1, 3, 5, 6, 7, 1, 3, 5, 7, 6), b=c(2, 4, 6, 7, 8, 2, 4, 6, 8, 7), c=c(NA, NA, NA, NA, NA, 6, 7, 9, 12, 10), d=c(NA, NA, NA, NA, NA, NA, NA, NA, NA, 11))
for (i in 1:nrow(connections)){
    if (is.na(connections$c[i])){
        grid.lines(x=plot_Loc$x[unlist(connections[i,1:2])], y=plot_Loc$y[unlist(connections[i,1:2])], default.units="native")
    } else if (is.na(connections$d[i])) {
        grid.lines(x=median(plot_Loc$x[unlist(connections[i,1:2])]), y=plot_Loc$y[unlist(connections[i,2:3])], default.units="native")
    } else {
        grid.lines(x=median(plot_Loc$x[unlist(connections[i,1:2])]), y=c(plot_Loc$y[connections[i,2]], median(plot_Loc$y[unlist(connections[i,2:3])])), default.units="native")
        grid.lines(x=plot_Loc$x[unlist(connections[i,3:4])], y=median(plot_Loc$y[unlist(connections[i,2:3])]), default.units="native")
        grid.lines(x=plot_Loc$x[connections[i,3]], y=c(median(plot_Loc$y[unlist(connections[i,2:3])]), plot_Loc$y[connections[i,3]]), default.units="native")
        grid.lines(x=plot_Loc$x[connections[i,4]], y=c(median(plot_Loc$y[unlist(connections[i,2:3])]), plot_Loc$y[connections[i,4]]), default.units="native")
    }
}


# Draw four independent line charts.
p <- 1
plot_Line_Chart(data.frame(time=1:1860, EuStockMarkets)[1:3], .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("dodgerblue", "deeppink"), "EU Stocks")
p <- 2
plot_Line_Chart(data.frame(time=1:1860, EuStockMarkets)[c(1,4,5)], .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("green", "purple"), "EU Stocks")
p <- 3
plot_Line_Chart(data.frame(time=1:(12*20), sunspots=sunspot.month[(171*12+1):(171*12+12*20)]), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("darkgoldenrod"), "Sunspots")
p <- 4
plot_Line_Chart(data.frame(time=1:(12*20), temp=nottem), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("red"), "Nottem")

# Draw four independent scatterplots.
p <- 5
plot_Scatterplot(data.frame(time=1:(1860 + 1 - 1000), DAX=rowMeans(embed(EuStockMarkets[,1], 1000)), FTSE=rowMeans(embed(EuStockMarkets[,4], 1000))), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("deeppink", "purple"), "Smooth")
p <- 6
plot_Scatterplot(data.frame(time=1:1860, EuStockMarkets)[c(1,2,5)], .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("deeppink", "purple"), "EU Stocks")
p <- 9
plot_Scatterplot(data.frame(time=1:(1860 + 1 - 20), DAX=rowMeans(embed(EuStockMarkets[,1], 20)), FTSE=rowMeans(embed(EuStockMarkets[,4], 20))), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("deeppink", "purple"), "Smooth*20")
p <- 10
plot_Scatterplot(data.frame(time=1:(1860 + 1 - 100), DAX=rowMeans(embed(EuStockMarkets[,1], 100)), FTSE=rowMeans(embed(EuStockMarkets[,4], 100))), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("deeppink", "purple"), "Smooth*100")


# Draw two independent histograms.
p <- 7
plot_Histogram(data.frame(time=1:(12*20), sunspots=sunspot.month[(171*12+1):(171*12+12*20)]), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("darkgoldenrod"), "Sunspots", breaks=6)
p <- 8
plot_Histogram(data.frame(time=1:(12*20), temp=nottem), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("red"), "Nottem", breaks=6)

# Draw sample objects in two charts spaces.
p <- 11
draw_Sample_Box(.x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .x_Scale=c(0,10), .y_Scale=c(-10,0), .justify=c("center","center"), .width=chart_Width, .height=chart_Height, .colors=c("dodgerblue","blue"), .box_X=c(4,6,6,4), .box_Y=c(-4,-4,-5,-5), .plot_Title="K")
p <- 12
draw_Sample_Box(.x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .x_Scale=c(-1,1), .y_Scale=c(0,1), .justify=c("center","center"), .width=chart_Width, .height=chart_Height, .colors=c("dodgerblue","blue"), .box_X=c(-0.5,0,0,-0.5), .box_Y=c(0.8,0.8,0.7,0.7), .plot_Title="L")
-------------------------------------------------------------------------------------------------------
N <- 1000000
R <- 1
x <- runif(N, min= -R, max= R)
y <- runif(N, min= -R, max= R)
is.inside <- (x^2 + y^2) <= R^2
pi.estimate <- 4 * sum(is.inside) / N
pi.estimate
# [1] 3.141472 plot.new()
plot.window(xlim = 1.1 * R * c(-1, 1), ylim = 1.1 * R * c(-1, 1))
points(x[ is.inside], y[ is.inside], pch = '.', col = "blue")
points(x[!is.inside], y[!is.inside], pch = '.', col = "red") N
-------------------------------------------------------------------------------------------------------
> dat
  freq1 freq2 gain
1   2.0   6.0   43
2   6.0  18.0   40
3   8.5  10.5   50
4   8.5   9.3   52

> attach(dat)

#Don't actually need to calculate the midpoint but since you suggested it
#that's the way I did it
midpoint = (freq1+freq2)/2
plot(midpoint,gain,xlim=c(min(freq1),max(freq2)),col="white",xlab="")

points(freq1,gain,col=1:length(gain),pch=19)
points(freq2,gain,col=1:length(gain),pch=19)

for(i in 1:length(gain)){
    lines(c(freq1[i],freq2[i]),c(gain[i],gain[i]),col=i)
}
-------------------------------------------------------------------------------------------------------
levelplot.points latticeExtra mm <- rbind(
  c(NA,0,1,1),
  c(0,NA,4,2),
  c(1,4,NA,3),
  c(1,2,3,NA))
dat <- expand.grid(x=1:ncol(mm),y=1:nrow(mm))
dat$z <- as.vector(mm)

library(latticeExtra)
levelplot(z~x*y,data=dat,
       panel=function(...)
       {
         panel.levelplot.points(...,cex=10,pch=22)
         panel.grid()
       },par.settings=ggplot2like())
-------------------------------------------------------------------------------------------------------
pairs() panel.cor() panel.cor <- function(x, y, digits=2, cex.cor)
{
  usr <- par("usr"); on.exit(par(usr))
  par(usr = c(0, 1, 0, 1))
  r <- abs(cor(x, y))
  txt <- format(c(r, 0.123456789), digits=digits)[1]
  test <- cor.test(x,y)
  Signif <- ifelse(round(test$p.value,3)<0.001,"p<0.001",paste("p=",round(test$p.value,3)))  
  text(0.5, 0.25, paste("r=",txt))
  text(.5, .75, Signif)
} panel.smooth() cex= col= pch= panel.smooth<-function (x, y, col = "blue", bg = NA, pch = 18, 
                        cex = 0.8, col.smooth = "red", span = 2/3, iter = 3, ...) 
{
  points(x, y, pch = pch, col = col, bg = bg, cex = cex)
  ok <- is.finite(x) & is.finite(y)
  if (any(ok)) 
    lines(stats::lowess(x[ok], y[ok], f = span, iter = iter), 
          col = col.smooth, ...)
} panel.hist() pairs() panel.hist <- function(x, ...)
{
  usr <- par("usr"); on.exit(par(usr))
  par(usr = c(usr[1:2], 0, 1.5) )
  h <- hist(x, plot = FALSE)
  breaks <- h$breaks; nB <- length(breaks)
  y <- h$counts; y <- y/max(y)
  rect(breaks[-nB], 0, breaks[-1], y, col="cyan", ...)
} pairs(USJudgeRatings[,c(2:3,6,1,7)],
          lower.panel=panel.smooth, upper.panel=panel.cor,diag.panel=panel.hist)
-------------------------------------------------------------------------------------------------------
cat ("Press [enter] to continue")
line <- readline() readkey <- function()
{
    cat ("Press [enter] to continue")
    line <- readline()
} Console.ReadKey() print ("Press [enter] to continue")
number <- scan(n=1) readkey <- function()
{
    cat("[press [enter] to continue]")
    number <- scan(n=1)
} readkeygraph <- function(prompt)
{
    getGraphicsEvent(prompt = prompt, 
                 onMouseDown = NULL, onMouseMove = NULL,
                 onMouseUp = NULL, onKeybd = onKeybd,
                 consolePrompt = "[click on graph then follow top prompt to continue]")
    Sys.sleep(0.01)
    return(keyPressed)
}

onKeybd <- function(key)
{
    keyPressed <<- key
}

xaxis=c(1:10) # Set up the x-axis.
yaxis=runif(10,min=0,max=1) # Set up the y-axis.
plot(xaxis,yaxis)

for (i in xaxis)
{
    # On each keypress, color the points on the graph in red, one by one.
    points(i,yaxis[i],col="red", pch=19)
    keyPressed = readkeygraph("[press any key to continue]")
}
-------------------------------------------------------------------------------------------------------
library(grid)

myplot <- function(){

  pushViewport(viewport(x=0.5,width=1, just=0.5))
  grid.rect(gp=gpar(fill=grey(runif(1, 0.2, 0.8))))
  grid.points()
  popViewport()

}

p1 <- grid.grabExpr(myplot())
p2 <- grid.grabExpr(myplot())

library(gridExtra)

grid.arrange(p1, p2, ncol=2)
-------------------------------------------------------------------------------------------------------
taylor.diagram text points text(sd.f * R, sd.f * sin(acos(R)), labels=text, pos=3) taylor.diagram.modified <- function (ref, model, add = FALSE, col = "red", 
                                    pch = 19, pos.cor = TRUE, xlab = "", ylab = "", 
                                    main = "Taylor Diagram", show.gamma = TRUE, 
                                    ngamma = 3, gamma.col = 8, sd.arcs = 0, ref.sd = FALSE, 
                                    grad.corr.lines = c(0.2, 0.4, 0.6, 0.8, 0.9), pcex = 1, 
                                    cex.axis = 1, normalize = FALSE, mar = c(5, 4, 6, 6),
                                    text, ...) #the added parameter
{
    grad.corr.full <- c(0, 0.2, 0.4, 0.6, 0.8, 0.9, 0.95, 0.99,1)
    R <- cor(ref, model, use = "pairwise")
    sd.r <- sd(ref)
    sd.f <- sd(model)
    if (normalize) {

    ... #I didn't copy here the full function because it's quite long: to obtain it
    ... #simply call `taylor.diagram` in the console or `edit(taylor.diagram)`.

            }
            S <- (2 * (1 + R))/(sd.f + (1/sd.f))^2
        }
    }
    points(sd.f * R, sd.f * sin(acos(R)), pch = pch, col = col, 
           cex = pcex)
    text(sd.f * R, sd.f * sin(acos(R)),  #the line to add
         labels=text, cex = pcex, pos=3) #You can change the pos argument to your liking
    invisible(oldpar)
} text require(plotrix)
set.seed(10)
data  <- sort(runif(100, 8,12))
model <- sort(rnorm(100, 10, 4))
taylor.diagram.modified(data, model, text="Model 1")
model2 <- sort(rnorm(100, 10,2))
taylor.diagram.modified(data, model2, add = TRUE, text="Model 2")
-------------------------------------------------------------------------------------------------------
Xi i paste ref[["X3"]] ref$X3 for (i in 1:14){
        name <- paste('X',i,sep='')
        result1 = (mean(ref[[name]]) - ((sd(ref[[name]])/sd(sour1[[name]]))*mean(sour1[[name]]))+ ((sd(ref[[name]])/sd(sour1[[name]])*sour1[[name]]))) # calculate using ref and sour1
        result2 = ((mean(ref[[name]]) - ((sd(ref[[name]])/sd(sour2[[name]],na.rm=TRUE))*mean(sour2[[name]],na.rm=TRUE))+((sd(ref[[name]])/sd(sour2[[name]],na.rm=TRUE)*sour2[[name]]))))  # calculate using ref and sour2
        plot(ref[[name]],result1,ylab="Weight in pounds",xlab="Weight in pounds",col=2)
        points(ref[[name]],ref$X1, col = 'green')
        points(ref[[name]],result2, col = 'blue')
}
-------------------------------------------------------------------------------------------------------
period.apply zoo.data <- xts(rnorm(31)+10,as.Date(13514:13744,origin="1970-01-01"))
ep <- endpoints(zoo.data,'months')
period.apply(zoo.data, INDEX=ep, FUN=function(x) mean(x)) period.apply(zoo.data, INDEX=ep[1:6], FUN=function(x) mean(x)) apply.daily(x, FUN, ...)
apply.weekly(x, FUN, ...)
apply.monthly(x, FUN, ...)
apply.quarterly(x, FUN, ...)
apply.yearly(x, FUN, ...
-------------------------------------------------------------------------------------------------------
lapply for result1 result2 columns <- paste0("X", 1:14)
lapply(
  columns,
  function(column)
  {
    result1 <- (
      mean(ref[[column]]) - 
      ((sd(ref[[column]]) / sd(sour1[[column]])) * mean(sour1[[column]])) + 
      ((sd(ref[[column]]) / sd(sour1[[column]]) * sour1[[column]]))
    )   # calculate using ref and sour1
    result2 <- ((  
      mean(ref[[column]]) - 
      ((sd(ref[[column]]) / sd(sour2[[column]], na.rm=TRUE)) * mean(sour2[[column]], na.rm=TRUE)) + 
      ((sd(ref[[column]]) / sd(sour2[[column]], na.rm=TRUE) * sour2[[column]])) 
    ))  # calculate using ref and sour2
    plot(
      ref[[column]],
      result1,
      ylab = "Weight in pounds",
      xlab = "Weight in pounds",
      col  = 2
    )
    points(ref[[column]], ref[[column]], col = 'green')
    points(ref[[column]], result2, col = 'blue') 
  }
)
-------------------------------------------------------------------------------------------------------
xts period.apply dat.xts <- xts(dat[,-ncol(dat)],dat$datetime)
## here I take every minutes because I don't have enouhgt data
## I think in your case 5 rows is equal to 5*12 mintues = 1 hour
pts <- endpoints(dat.xts,on='mins')
period.apply(dat.xts,pts,mean)

                   Year Day Hour Min   Sec.  E1.S1  E1.S2 E1.S3 E1.S4 E1.S5 E1.S6  E1.S7  E1.S8 E2.S1  E2.S2  E2.S3  E2.S4 E2.S5 E2.S6
2000-05-01 00:01:50 2000 122    0   1 44.055 2.6450 1.9860 1.321 2.315  1.65 0.660 3.9700 1.3200 1.650 1.3210 0.3310 1.6550 0.660 0.660
2000-05-01 00:02:38 2000 122    0   2 20.330 2.8125 2.4805 2.648 2.645  2.15 2.148 2.9755 2.8125 1.158 0.4955 1.4855 1.3235 0.661 1.485 xts data.frame ggplot2 dat <- data.frame(date=index(dat.xts),coredata(dat.xts)) library(ggplot2)
ggplot(data=dat)+ 
 geom_line(aes(x=date,y=E1.S1))
-------------------------------------------------------------------------------------------------------
points() text() points(mod, display = "bp") with(data) require(vegan)
data(varespec)
data(varechem)
ord <- cca(varespec ~ ., data = varechem)
plot(ord, type = "n", display = "sites")
points(ord, display = "sites")
points(ord, display = "bp")
-------------------------------------------------------------------------------------------------------
base sp rgdal maptools library(sp)
library(maptools)
library(rgdal)
xy <- data.frame(lon=c(-130,110,3,45),lat=c(60,-10,50,30)) #Some coordinates
value <- data.frame(value=c(1.5,0.8,2.3,2)) #Some values for the point size
df <- SpatialPointsDataFrame(xy,value,proj4string=CRS("+proj=latlon"))
dfMoll <- spTransform(df, CRS("+proj=moll")) #Mollweide projection of the data
data(wrld_simpl) # A base world map
wrld_moll <- spTransform(wrld_simpl, CRS("+proj=moll")) # ... that we projects as well
plot(wrld_moll) #... and plot
points(dfMoll, cex=dfMoll$value, pch=20, col="red") #...with our data points
-------------------------------------------------------------------------------------------------------
(a, b) z^2 + a z + b == 0 |z|<=1 (-a +- sqrt(d))/2 d = a^2 - 4b d = 0 b = a^2 / 4 a vs. b |z|<=1 -a/2 -1 <= a/2 <=1 -2 <= a <= 2 a vs. b b < a^2/4 |z| = |(-a +- sqrt(d))/2| <= 1 -1 <= (-a +- sqrt(d))/2 <= 1 +- a-2 <= sqrt(d) <= a+2 a-2 <= -sqrt(d) <= a+2 sqrt(d) -sqrt(d) [a-2, a+2] d > 0 -2 < a < 2 a-2 <= -sqrt(d) < 0 < sqrt(d) <= a+2 (a-2)^2 >= d d <= (a+2)^2 d <= a^2 - 4a + 4 d <= a^2 + 4a + 4 -4b <= -4a + 4 -4b <= +4a + 4 b >= a-1 b >= -a-1 b b = a-1 b=-a-1 a [-2,2] b < a^2/4 d < 0 -a/2 +- i * sqrt(-d)/2 a^2/4 - d/4 b b <= 1 b test <- function(x=2, n=10000)
{
    plot(c(-x,x), c(-x,x), type="n")

    plot(function(a) (a^2)/4, from=-x, to=x, add=T)

    plot(function(a) a-1, from=-x, to=x, add=T)

    plot(function(a) -a-1, from=-x, to=x, add=T)

    a <- runif(n, -x, x)

    b <- runif(n, -x, x)

    for( i in 1:n )
    {
        if( all(abs(polyroot(c(b[i],a[i],1))) <= 1) )
        {
            col <- ifelse(b[i] < 0.25*a[i]^2, "blue", "red")

            points(a[i], b[i], pch=".", col=col)
        }
    }
} polyroot polyroot(c(C, B, A)) Ax^2 + Bx + C
-------------------------------------------------------------------------------------------------------
xts library(xts)
dat.ts <- xts(dat[,-1],as.POSIXct(dat$Date))
dat.ts[endpoints(dat.ts,'weeks')]

           dax_data.csv nikkei_data.csv spx_data.csv
1984-01-06           NA            9961           NA
2013-03-11           NA              NA      1556.22
2013-03-15           NA              NA      1560.70
-------------------------------------------------------------------------------------------------------
qqline ?qqline #highlight first and third quartiles
points(quantile(chi_scores,c(.25,.75)),
       quantile(mah_scores,c(.25,.75)),col="blue",cex=2,bg="blue",pch=21)
-------------------------------------------------------------------------------------------------------
#read in X and Y as vectors
M <- cbind(X,Y)
#plot data
plot(M[,1],M[,2],xlim=c(0,1200),ylim=c(0,1200))
#calculate rotation angle
alpha <- -atan((M[1,2]-tail(M,1)[,2])/(M[1,1]-tail(M,1)[,1]))
#rotation matrix
rotm <- matrix(c(cos(alpha),sin(alpha),-sin(alpha),cos(alpha)),ncol=2)
#shift, rotate, shift back
M2 <- t(rotm %*% (
  t(M)-c(M[1,1],M[1,2])
  )+c(M[1,1],M[1,2]))
#plot
plot(M2[,1],M2[,2],xlim=c(0,1200),ylim=c(0,1200)) plot(M,xlim=c(-300,1200),ylim=c(-300,1200))
#shift points, so that turning point is (0,0)
M2.1 <- t(t(M)-c(M[1,1],M[1,2]))
points(M2.1,col="blue")
#rotate
M2.2 <- t(rotm %*% (t(M2.1)))
points(M2.2,col="green")
#shift back
M2.3 <- t(t(M2.2)+c(M[1,1],M[1,2]))
points(M2.3,col="red")
-------------------------------------------------------------------------------------------------------
ow <- expand.grid(c(1.5,2.5),c(1.5,2.5))
row.names(ow)<-letters[1:4]
pw <- expand.grid(1:3,1:3)
row.names(pw)<-LETTERS[1:9]
B <- rbind(expand.grid("a",row.names(pw)[c(1,2,4,5)]),
           expand.grid("b",row.names(pw)[c(2,3,5,6)]),
           expand.grid("c",row.names(pw)[c(4,5,7,8)]),
           expand.grid("d",row.names(pw)[c(5,6,8,9)]))
B <- cbind(B,abs(rnorm(16))) # The location of your oil wells:
ow
   Var1 Var2
a  1.5  1.5
b  2.5  1.5
c  1.5  2.5
d  2.5  2.5
# Of your production wells:
pw
  Var1 Var2
A    1    1
B    2    1
C    3    1
D    1    2
E    2    2
F    3    2
G    1    3
H    2    3
I    3    3
#And a b value for each pairs of neighbouring oil/production wells:
   Var1 Var2 abs(rnorm(16))
1     a    A     1.78527757
2     a    B     1.61794028
3     a    D     1.80234599
4     a    E     0.04202002
5     b    B     0.90265280
6     b    C     1.05214769
7     b    E     0.67932237
8     b    F     0.11497430
9     c    D     0.26288589
10    c    E     0.50745137
11    c    G     0.74102529
12    c    H     1.43919338
13    d    E     1.04111278
14    d    F     0.49372216
15    d    H     0.21500663
16    d    I     0.20156929 weirdplot <- function(ow_loc, pw_loc, B, 
                     pch_ow=19, pch_pw=17, 
                     col_ow="green", col_pw="blue", col_b="red", breaks){
    # with ow_loc and pw_loc the locations of your wells
    # B the correspondance table
    # pch_ow and pch_pw the point type for the wells
    # col_b, col_ow and col_pw the colors for the arrows and the wells
    # and breaks a vector of size categories for b values
    plot(pw_loc,type="n")
    b<-cut(B[,3], breaks=breaks)
    for(i in 1:nrow(B)){
        start=ow_loc[row.names(ow)==B[i,1],]
        end=pw_loc[row.names(pw)==B[i,2],]
        arrows(x0=start[,1],y0=start[,2], 
               x1=end[,1], y1=end[,2], lwd=b[i], col=col_b)
        }
    points(pw_loc, pch=pch_pw, col=col_pw)
    points(ow_loc, pch=pch_ow, col=col_ow)
    } weirdplot(ow, pw, B, breaks=c(0,0.5,1,1.5,2))
-------------------------------------------------------------------------------------------------------
lattice y x xyplot(foodexp~income , data =engel, 
       type = c("g"),
       auto.key=list(x=.8,y=.35,cex=.8,cex.title=.8, title="", points=TRUE), 
       scales=list(tck=-1),ylab=list("Food Expenditure",font=3),
       xlab=list("Household Income",font=3),
       panel=function(x,y,...){
         panel.xyplot(x,y)
         panel.grid()
         panel.abline(rq(y ~ x, tau = 0.5))
         panel.points(x, y, cex = 0.5, col = "blue")
         panel.abline(rq(y ~ x, tau = 0.5), col = "blue")
         panel.abline(lm(y ~ x), lty = 2, col = "red")
         taus <- c(0.05, 0.1, 0.25, 0.75, 0.9, 0.95)
         for (i in 1:length(taus)) {
           panel.abline(rq(y ~ x, tau = taus[i]),
                  col = "gray")
         }

       }
)
-------------------------------------------------------------------------------------------------------
segments first <- 1:10
second <- 2:11
boxplot(first,second, boxwex=0.3)
points(rep(c(1.2,1.8),each=10),c(first,second),pch=19)
segments(rep(1.2,10),first,rep(1.8,10),second,col="gray")
-------------------------------------------------------------------------------------------------------
R matpoints matlines boxplot dd <- data.frame(x=rnorm(15), y= rnorm(15))

boxplot(dd, boxwex = 0.3)
# note that you need to transpose `dd`
matpoints(y= t(dd), x= c(1.17,1.83),pch=19, col='black')
matlines(y= t(dd), x= c(1.2,1.8), lty=1, col = 'black')
-------------------------------------------------------------------------------------------------------
DistrictID head(data.sim)
##    GovernorateID DistrictID Year National_gdp National_life_exp
## 1:            11       1101 1990           NA                NA
## 2:            11       1101 1991           NA                NA
## 3:            11       1101 1992     1988.746                NA
## 4:            11       1101 1993     2527.619          54.70739
## 5:            11       1101 1994     3854.210          44.21809
## 6:            11       1102 1990           NA                NA

dd <- copy(data.sim) # Make a copy for later. NA data.sim[, National_life_exp := ifelse(is.na(National_life_exp), 
                                       predict(lm(National_life_exp ~ Year, data=.SD), .SD),
                                       National_life_exp)
         , by=DistrictID
         ][, National_gdp := ifelse(is.na(National_gdp),
                                    predict(lm(National_gdp ~ Year, data=.SD), .SD),
                                    National_gdp) 
           , by=DistrictID
        ]


head(data.sim)
##    GovernorateID DistrictID Year National_gdp National_life_exp
## 1:            11       1101 1990    -8.004377          86.17531
## 2:            11       1101 1991   924.727559          75.68601
## 3:            11       1101 1992  1988.745871          65.19670
## 4:            11       1101 1993  2527.618676          54.70739
## 5:            11       1101 1994  3854.209743          44.21809
## 6:            11       1102 1990  1008.886661          70.45643 DistrictID plot(data.sim$National_life_exp)
points(dd$National_life_exp, col='red') # The copy from before.
-------------------------------------------------------------------------------------------------------
lattice #load packages
library(lattice)
library(latticeExtra)

#example data
B <- subset(OrchardSprays, treatment == "B")
D <- subset(OrchardSprays, treatment == "D")
BD <- rbind(B,D)

#create three separate plots
nobox = list(axis.line=list(col="transparent"))#to remove box around plots
boxplotB <- bwplot(decrease ~ treatment, B, ylab = NULL, ylim=c(0,70), 
                   par.settings=nobox)
boxplotD <- bwplot(decrease ~ treatment, D, ylab = NULL, ylim=c(0,70), 
                   par.settings=nobox)
plotBD <- xyplot(decrease ~ treatment, BD, col=1, ylim=c(0,70), pch=16,  
                 par.settings=nobox, panel=function(x, y, ...) {
                   panel.xyplot(x, y, ...)
                   panel.points(x, y, ...)
                   #this loop is required to create connections between points
                   for(i in 1:nrow(B)) 
                        panel.lines(1:2, c(y[i], y[i+nrow(B)]), alpha=0.5, ...)
                   }
                 )

#combine three plots
comb <- c(boxplotB, plotBD, boxplotD, layout = c(3,1), y.same = F)
update(comb, scales = list(at = list(NA, NA, NA), y = list(draw = FALSE)))
-------------------------------------------------------------------------------------------------------
foo.upper <- function(x,y,ind.upper,col.upper,ind.lower,col.lower,...){
    points(x[ind.upper],y[ind.upper],col = col.upper,...)
}

foo.lower <- function(x,y,ind.lower,col.lower,ind.upper,col.upper,...){
    points(x[ind.lower],y[ind.lower],col = col.lower,...)
}

pairs(dat[,-5],
        lower.panel = foo.lower,
        upper.panel = foo.upper,
        ind.upper = dat$type == 'brain',
        ind.lower = dat$type == 'heart',
        col.upper = 'blue',
        col.lower = 'red') ... dat <- as.data.frame(do.call(rbind,data))
dat$type <- rep(c('brain','heart'),each = 100)

foo.upper <- function(x,y,...){
    points(x[dat$type == 'brain'],y[dat$type == 'brain'],col = 'red',...)
}

foo.lower <- function(x,y,...){
    points(x[dat$type == 'heart'],y[dat$type == 'heart'],col = 'blue',...)
}

pairs(dat[,-5],lower.panel = foo.lower,upper.panel = foo.upper) layout dat <- do.call(rbind,data)
dat <- as.data.frame(dat)
dat$grp <- rep(letters[1:2],each = 100)

plower <- function(x,y,grp,...){
    panel.xyplot(x[grp == 'a'],y[grp == 'a'],col = 'red',...)
}

pupper <- function(x,y,grp,...){
    panel.xyplot(x[grp == 'b'],y[grp == 'b'],...)
}

splom(~dat[,1:4],
        data = dat,
        lower.panel = plower,
        upper.panel = pupper,
        grp = dat$grp)
-------------------------------------------------------------------------------------------------------
points # set the frequency with which to plot points
plotfreq <- 10

# set the x and y limits of the graph
x.limits <- c(1,100)
y.limits <- c(0,100)

# initialise a vector and open a plot
result <- vector(mode="numeric",length=100)
plot(result,ylim=y.limits,xlim=x.limits,type="n")

# do the plotting
plot.iterations <- seq(plotfreq,length(result),by=plotfreq)
for (i in seq_along(result)) {
  result[i] <- result[i] + i

  # only plot if the data is at the specified interval
  if (i %in% plot.iterations) {
    points(i,result[i])
  }

}
-------------------------------------------------------------------------------------------------------
library(grid)
library(lubridate)
library(plyr) set.seed(1)

#############################################
# User settings for the data generation.    #
#############################################

# Set number of hours to generate data for.
time_Periods <- 100

# Set starting datetime in m/d/yyyy hh:mm format.
start_Datetime <- "2/24/2013 00:00"

# Specify a list of websites along with a
# Poisson lambda to represent the average
# number of hits in a given time period.
df_Websites <- read.table(text="
url lambda
http://www.asitenoonereallyvisits.com 1
http://www.asitesomepeoplevisit.com 10
http://www.asitesomemorepeoplevisit.com 20
http://www.asiteevenmorepeoplevisit.com 40
http://www.asiteeveryonevisits.com 80
", header=TRUE, sep=" ")

#############################################
# Generate the data.                        #
#############################################

# Initialize lists to hold hit data and
# website names.
hits <- list()
websites <- list()

# For each time period and for each website,
# flip a coin to see if any visitors come.  If
# visitors come, use a Poisson distribution to
# see how many come.
# Also initialize the list of website names.
for (i in 1:nrow(df_Websites)){
    hits[[i]] <- rbinom(time_Periods, 1, 0.5) * rpois(time_Periods, df_Websites$lambda[i])
    websites[[i]] <- rep(df_Websites$url[i], time_Periods)
}

# Initialize list of time periods.
datetimes <- mdy_hm(start_Datetime) + hours(1:time_Periods)

# Tie the data into a data frame and erase rows with no hits.
# This is what the real data is more likely to look like
# after import and cleaning.
df_Hits <- data.frame(datetime=rep(datetimes, nrow(df_Websites)), hits=unlist(hits), website=unlist(websites))
df_Hits <- df_Hits[df_Hits$hits > 0,]

# Clean up data-generation variables.
rm(list=ls()[ls()!="df_Hits"]) unit(1, "lines") #############################################
# User settings for the graphic.            #
#############################################

# Specify the window width and height and
# pixels per inch.
device_Width=12
device_Height=4.5
pixels_Per_Inch <- 100

# Specify the bin width (in hours) of the
# upper histogram.
bin_Width <- 2

# Specify a padding size for separating text
# from other plot elements.
padding <- unit(1, "strwidth", "W")

# Specify the bin cut-off values for the hit
# counts and the corresponding colors.  The
# cutoff should be the maximum value to be
# contained in the bin.
bin_Settings <- read.table(text="
cutoff color
10 'darkblue'
20 'deepskyblue'
40 'purple'
80 'magenta'
160 'red'
", header=TRUE, sep=" ")

# Specify the size of the histogram plots 
# in 'grid' units.  Override only if necessary.
# histogram_Size <- unit(6, "lines")
histogram_Size <- unit(nrow(bin_Settings) + 1, "lines")

# Set the background color for distinguishing
# between rows of data.
row_Background <- "gray90"

# Set the color for the date lines.
date_Color <- "gray40"

# Set the color for marker lines on histograms.
marker_Color <- "gray80"

# Set the fontsize for labels.
label_Size <- 10 #############################################
# Make the graphic.                         #
#############################################

# Make sure bin cutoffs are in increasing order.
# This way, we can make assumptions later.
bin_Settings <- bin_Settings[order(bin_Settings$cutoff),]

# Initialize plot window.
# Make sure you always specify the pixels per
# inch, so you have an appropriately scaled
# graphic for output.
windows(
    width=device_Width,
    height=device_Height,
    xpinch=pixels_Per_Inch,
    ypinch=pixels_Per_Inch)
grid.newpage()

# Push an initial viewport, so we can set the
# font size to use in calculating label widths.
pushViewport(viewport(gp=gpar(fontsize=label_Size)))

# Find the list of websites in the data.
unique_Urls <- as.character(unique(df_Hits$website))

# Calculate the width of the website
# urls once printed on the screen.
label_Width <- list()
for (i in 1:length(unique_Urls)){
    label_Width[[i]] <- convertWidth(unit(1, "strwidth", unique_Urls[i]), "npc")
}
# Use the maximum url width plus two padding.
x_Label_Margin <- unit(max(unlist(label_Width)), "npc") + padding * 2

# Calculate a height for the date labels plus two padding.
y_Label_Margin <- unit(1, "strwidth", "99/99/9999") + padding * 2

# Calculate size of main plot after making
# room for histogram and label margins.
main_Width <- unit(1, "npc") - histogram_Size - x_Label_Margin
main_Height <- unit(1, "npc") - histogram_Size - y_Label_Margin

# Calculate x values, using the minimum datetime
# as zero, and counting the hours between each
# datetime and the minimum.
x_Values <- as.integer((df_Hits$datetime - min(df_Hits$datetime)))/60^2

# Initialize main plotting area
pushViewport(viewport(
    x=x_Label_Margin,
    y=y_Label_Margin,
    width=main_Width,
    height=main_Height,
    xscale=c(-1, max(x_Values) + 1),
    yscale=c(0, length(unique_Urls) + 1),
    just=c("left", "bottom"),
    gp=gpar(fontsize=label_Size)))

# Put grey background behind every other website
# to make data easier to read, and write urls as
# y-labels.
for (i in 1:length(unique_Urls)){
    if (i%%2==0){
        grid.rect(
            x=unit(-1, "npc"),
            y=i,
            width=unit(2, "npc"),
            height=1,
            default.units="native",
            just=c("left", "center"),
            gp=gpar(col=row_Background, fill=row_Background))
    }

    grid.text(
        unique_Urls[i],
        x=unit(0, "npc") - padding,
        y=i,
        default.units="native",
        just=c("right", "center"))
}

# Find the hour offset of the minimum date value.
time_Offset <- as.integer(format(min(df_Hits$datetime), "%H"))

# Find the dates in the data.
x_Labels <- unique(format(df_Hits$datetime, "%m/%d/%Y"))

# Find where the days begin in the data.
midnight_Locations <- (0:max(x_Values))[(0:max(x_Values)+time_Offset)%%24==0]

# Write the appropriate date labels on the x-axis
# where the days begin.
grid.text(
    x_Labels,
    x=midnight_Locations,
    y=unit(0, "npc") - padding,
    default.units="native",
    just=c("right", "center"),
    rot=90)

# Draw lines to vertically mark when days begin.
grid.polyline(
    x=c(midnight_Locations, midnight_Locations),
    y=unit(c(rep(0, length(midnight_Locations)), rep(1, length(midnight_Locations))), "npc"),
    default.units="native",
    id=rep(midnight_Locations, 2),
    gp=gpar(lty=2, col=date_Color))

# Initialize bin assignment variable.
bin_Assignment <- 1

# Calculate which bin each hit value belongs in.
for (i in 1:nrow(bin_Settings)){
    bin_Assignment <- bin_Assignment + ifelse(df_Hits$hits>bin_Settings$cutoff[i], 1, 0)
}

# Draw points, coloring according to the bin settings.
grid.points(
    x=x_Values,
    y=match(df_Hits$website, unique_Urls),
    pch=19,
    size=unit(1, "native"),
    gp=gpar(col=as.character(bin_Settings$color[bin_Assignment]), alpha=0.5))

# Finalize the main plotting area.
popViewport()

# Create the bins for the upper histogram.
bins <- ddply(
    data.frame(df_Hits, bin_Assignment, mid=floor(x_Values/bin_Width)*bin_Width+bin_Width/2),
    .(bin_Assignment, mid),
    summarize,
    freq=length(hits))

# Initialize upper histogram area
pushViewport(viewport(
    x=x_Label_Margin,
    y=y_Label_Margin + main_Height,
    width=main_Width,
    height=histogram_Size,
    xscale=c(-1, max(x_Values) + 1),
    yscale=c(0, max(bins$freq) * 1.05),
    just=c("left", "bottom"),
    gp=gpar(fontsize=label_Size)))


# Calculate where to put four value markers.
marker_Interval <- floor(max(bins$freq)/4)
digits <- nchar(marker_Interval)
marker_Interval <- round(marker_Interval, -digits+1)

# Draw horizontal lines to mark values.
grid.polyline(
    x=unit(c(rep(0,4), rep(1,4)), "npc"),
    y=c(1:4 * marker_Interval, 1:4 * marker_Interval),
    default.units="native",
    id=rep(1:4, 2),
    gp=gpar(lty=2, col=marker_Color))

# Write value labels for each marker.
grid.text(
    1:4 * marker_Interval,
    x=unit(0, "npc") - padding,
    y=1:4 * marker_Interval,
    default.units="native",
    just=c("right", "center"))

# Finalize upper histogram area, so we
# can turn it back on but with clipping.
popViewport()

# Initialize upper histogram area again,
# but with clipping turned on.
pushViewport(viewport(
    x=x_Label_Margin,
    y=y_Label_Margin + main_Height,
    width=main_Width,
    height=histogram_Size,
    xscale=c(-1, max(x_Values) + 1),
    yscale=c(0, max(bins$freq) * 1.05),
    just=c("left", "bottom"),
    gp=gpar(fontsize=label_Size),
    clip="on"))

# Draw bars for each bin.
for (i in 1:nrow(bin_Settings)){
    active_Bin <- bins[bins$bin_Assignment==i,]
    if (nrow(active_Bin)>0){
        for (j in 1:nrow(active_Bin)){
            grid.rect(
                x=active_Bin$mid[j],
                y=0,
                width=bin_Width,
                height=active_Bin$freq[j],
                default.units="native",
                just=c("center","bottom"),
                gp=gpar(col=as.character(bin_Settings$color[i]), fill=as.character(bin_Settings$color[i]), alpha=1/nrow(bin_Settings)))
        }
    }
}

# Draw x-axis.
grid.lines(x=unit(c(0, 1), "npc"), y=0, default.units="native")

# Finalize upper histogram area.
popViewport()

# Calculate the frequencies for each website and bin.
freq_Data <- ddply(
    data.frame(df_Hits, bin_Assignment),
    .(website, bin_Assignment),
    summarize,
    freq=length(hits))

# Create the line data for the side histogram.
line_Data <- matrix(0, nrow=length(unique_Urls)+2, ncol=nrow(bin_Settings))
for (i in 1:nrow(freq_Data)){
    line_Data[match(freq_Data$website[i], unique_Urls)+1,freq_Data$bin_Assignment[i]] <- freq_Data$freq[i]
}


# Initialize side histogram area
pushViewport(viewport(
    x=x_Label_Margin + main_Width,
    y=y_Label_Margin,
    width=histogram_Size,
    height=main_Height,
    xscale=c(0, max(line_Data) * 1.05),
    yscale=c(0, length(unique_Urls) + 1),
    just=c("left", "bottom"),
    gp=gpar(fontsize=label_Size)))

# Calculate where to put four value markers.
marker_Interval <- floor(max(line_Data)/4)
digits <- nchar(marker_Interval)
marker_Interval <- round(marker_Interval, -digits+1)

# Draw vertical lines to mark values.
grid.polyline(
    x=c(1:4 * marker_Interval, 1:4 * marker_Interval),
    y=unit(c(rep(0,4), rep(1,4)), "npc"),
    default.units="native",
    id=rep(1:4, 2),
    gp=gpar(lty=2, col=marker_Color))

# Write value labels for each marker.
grid.text(
    1:4 * marker_Interval,
    x=1:4 * marker_Interval,
    y=unit(0, "npc") - padding,
    default.units="native",
    just=c("center", "top"))

# Draw lines for each bin setting.
grid.polyline(
    x=array(line_Data),
    y=rep(0:(length(unique_Urls)+1), nrow(bin_Settings)),
    default.units="native",
    id=array(t(matrix(1:nrow(bin_Settings), nrow=nrow(bin_Settings), ncol=length(unique_Urls)+2))),
    gp=gpar(col=as.character(bin_Settings$color)))

# Draw vertical line for the y-axis.
grid.lines(x=0, y=c(0, length(unique_Urls)+1), default.units="native")

# Finalize side histogram area.
popViewport()

# Draw legend.
# Draw box behind legend headers.
grid.rect(
    x=0,
    y=1,
    width=unit(1, "strwidth", names(bin_Settings)[1]) + unit(1, "strwidth", names(bin_Settings)[2]) + 3 * padding,
    height=unit(1, "lines"),
    default.units="npc",
    just=c("left","top"),
    gp=gpar(col=row_Background, fill=row_Background))

# Draw legend headers from bin_Settings variable.
grid.text(
    names(bin_Settings)[1],
    x=padding,
    y=1,
    default.units="npc",
    just=c("left","top"))

grid.text(
    names(bin_Settings)[2],
    x=unit(1, "strwidth", names(bin_Settings)[1]) + 2 * padding,
    y=1,
    default.units="npc",
    just=c("left","top"))

# For each row in the bin_Settings variable,
# write the cutoff values and the color associated.
# Write the color name in the color it specifies.
for (i in 1:nrow(bin_Settings)){
    grid.text(
        bin_Settings$cutoff[i],
        x=unit(1, "strwidth", names(bin_Settings)[1]) + padding,
        y=unit(1, "npc") - i * unit(1, "lines"),
        default.units="npc",
        just=c("right","top"))

    grid.text(
        bin_Settings$color[i],
        x=unit(1, "strwidth", names(bin_Settings)[1]) + 2 * padding,
        y=unit(1, "npc") - i * unit(1, "lines"),
        default.units="npc",
        just=c("left","top"),
        gp=gpar(col=as.character(bin_Settings$color[i])))
}
-------------------------------------------------------------------------------------------------------
> DATA_mean <- data.frame(Group ="A", Measure = DATA) #Make a data.frame first
> attach(DATA_mean)                                   #Attach the data
> boxplot( Measure ~ Group)                           #Draw your boxplot as above
> means <- by(Measure, Group, mean)                   #Calculate mean and assign
> points(1, means, pch = 21, cex =1.5, bg = "blue")   #Label mean on boxplot


#The default center is 1 for the boxplots, if you have more than one, it would be 1:2:3...etc
-------------------------------------------------------------------------------------------------------
xts period.apply library(xts)
zoo.data <- zoo(rnorm(31)+10,as.Date(13514:13744,origin="1970-01-01"))
ep <- endpoints(zoo.data,'days')
## daily mean 
period.apply(zoo.data, INDEX=ep, FUN=function(x) mean(x)) apply.daily(x, FUN, ...)
apply.weekly(x, FUN, ...)
apply.monthly(x, FUN, ...)
apply.quarterly(x, FUN, ...)
apply.yearly(x, FUN, ...)
-------------------------------------------------------------------------------------------------------
upper.panel= panel.points cex= panel.points<-function(x,y)
{
  points(x,y,cex=3)
}

pairs(iris[,1:4],lower.panel=panel.Kendall,upper.panel=panel.points)
-------------------------------------------------------------------------------------------------------
panel.number() x df <- data.frame(var1=rnorm(20), cat=rep("Z",20), cat2=rep(c("M","F"), 10))

bwplot(var1 ~ cat | cat2, data=df, pch="|", 
           panel=function(...){
             panel.bwplot(...)
             panel.points(x=c(.5,-.5)[panel.number()], 
                          pch="x", cex=2)
           }
          ) panel.number panel.mean panel.mean <- function(x, y, ...) {
    tmp <- tapply(y, factor(x), FUN = mean)
    panel.points(tmp, pch = 20, ...)
}

bwplot(var1 ~ cat | cat2, data=df,
       panel=function(...){
           panel.bwplot(..., pch='|')
           panel.mean(...)
           }
)
-------------------------------------------------------------------------------------------------------
require(tcltk); require(tkrplot)
require(gWidgets2)                      # require(devtools); install_github(c("gWidgets2", "gWidgets2tcltk"), "jverzani")
options(guiToolkit="tcltk")
source(system.file("examples", "manipulate.R", package="gWidgets2"))

w <- gwindow("Manipulate example", visible=FALSE)

manipulate({
  y <- get(distribution)(size)
  plot(density(y, bw=bandwidth/100, kernel=kernel))
  points(y, rep(0, size))
},
           ##
           distribution=picker("Normal"="rnorm", "Exponential"="rexp"),
           kernel=picker("gaussian", "epanechnikov", "rectangular",
             "triangular", "cosine"),
           size=picker(5, 50, 100, 200, 300),
           bandwidth=slider(0.05 * 100, 2.00 * 100, step=0.05 * 100, initial=1* 100), # integers needed
           button=button("Refresh"),

           container=w
           )
visible(w) <- TRUE
-------------------------------------------------------------------------------------------------------
<<>> <<non.finished.plotting, echo=FALSE>> echo ```{r add.layer, fig.width=5, fig.height=5, echo=-1}
<<non.finished.plotting>>
points(x=rnorm(100,1,0.1), y=rnorm(100,0.8,0.1) )
``` echo=-1
-------------------------------------------------------------------------------------------------------
levelplot latticeExtra library(latticeExtra)
levelplot(count~Var1*Var2,data=dat,
          panel=function(x,y,z,...)
          {
            panel.abline(h=x,v=y,lty=2)
            cex <- scale(z)*3
            panel.levelplot.points(x,y,z,...,cex=5)
            panel.text(x,y,label=z,cex=0.8)
          },scales=(x=list(abbreviate=TRUE))) ## to get short labels library(latticeExtra)
levelplot(count~Var1*Var2,data=dat,
          panel=function(x,y,z,...)
          {
            panel.abline(h=x,v=y,lty=2)
            cex <- scale(z)*3
            panel.levelplot.points(x,y,z,...,cex=5)
            panel.text(x,y,label=z,cex=0.8)

          })
-------------------------------------------------------------------------------------------------------
x <- seq(0, 1, by=0.2)
plot(  x, x,   type="l" )
lines( x, x^2, col="red" )
xx1 <- c(0,x[x<1  & x>0 ],1,x[x<1  & x>0 ],0)
yy1 <- c(0,x[x<1  & x>0 ],1,x[x<1  & x>0 ]^2,0)
polygon(xx1, yy1, lwd=3, col="wheat")
points(xx1, yy1) xx1 plot(  x, x,   type="l" )
lines( x, x^2, col="red" )
xx1 <- c(x, rev(x))
yy1 <- c(x, rev(x)^2)
polygon(xx1, yy1, lwd=3, col="wheat")
-------------------------------------------------------------------------------------------------------
predict x <- runif(20, 0, 100)
y <- 5*x + rnorm(20, 0, 10)
df <- data.frame(x, y)
df
plot(df)

mod <- lm(y ~ x, data = df)

x_new <- 1:100
pred <- predict(mod, newdata=data.frame(x = x_new))
plot(df)
points(x_new, pred)
-------------------------------------------------------------------------------------------------------
contour contourLines polygon plot(datax[,1], datax[,2],axes=FALSE,ann=FALSE, type="n")
box()
cL <- contourLines(xp, yp, zM,nlevels = 1)
lapply(cL,function(x)polygon(x$x,x$y,col="red"))
points(datax[,1], datax[,2],pch = datay+1) library(splancs)
ord <- sapply(lapply(cL,function(x)datay[inout(datax,cbind(x$x,x$y))]),
              median) #Check what values are present in the polygon and 
                      #take the most common one
plot(datax[,1], datax[,2],axes=FALSE,ann=FALSE, type="n")
box()
lapply(cL[ord==1],function(x)polygon(x$x,x$y,col="blue"))
lapply(cL[ord==0],function(x)polygon(x$x,x$y,col="white"))
points(datax[,1], datax[,2],pch = datay+1) image image(xp, yp, zM, col=c("transparent","blue"))
points(datax[,1], datax[,2],pch = datay+1)
-------------------------------------------------------------------------------------------------------
par(new=TRUE); points(.........) ?pch
-------------------------------------------------------------------------------------------------------
library(xts)
x <- as.xts(read.zoo(text="Time,Volume    
1996-02-05 00:34:00,0.01
1996-02-05 00:51:00,0.01
1996-02-05 00:52:00,0.01
1996-02-05 01:04:00,0.01
1996-02-05 01:19:00,0.01
1996-02-05 05:00:00,0.01
1996-02-05 05:07:00,0.01
1996-02-05 05:08:00,0.01
1996-02-05 05:14:00,0.01",
sep=",", FUN=as.POSIXct, header=TRUE, drop=FALSE))

# 1) Create POSIXct sequence from midnight of the first day
#    until the end of the last day    
midnightDay1 <- as.POSIXct(format(start(x),"%Y-%m-%d"))
timesteps <- seq(midnightDay1, end(x), by="30 min")
# 2) Make a copy of your object and set all values for Volume to 1
y <- x
y$Volume <- 1
# 3) Merge the copy with a zero-column xts object that has an index
#    with all the values you want.  Fill missing values with 0.
m <- merge(y, xts(,timesteps), fill=0)
# 4) Align all index values to 30-minute intervals
a <- align.time(m, 60*30)
# 5) Sum the values for Volume in each period
half_hour <- period.apply(a, endpoints(a, "minutes", 30), sum)
-------------------------------------------------------------------------------------------------------
xrange <- c(starttime, endtime) xrange <- seq(from=as.Date(starttime), to=as.Date(endtime), by=1) points ref= data.frame(matrix(runif(477*4),ncol=4))    #dummy random data
sour1 = data.frame(matrix(runif(477*4),ncol=4)) #dummy random data
sour2= data.frame(matrix(runif(477*4),ncol=4))  #dummy random data
starttime <- strptime("20100903", "%Y%m%d")
endtime <- strptime("20111223 ", "%Y%m%d")
xrange <-  seq(from=as.Date(starttime), to=as.Date(endtime), by=1) #create date vector
columns <- paste0("X", 1:4)
par(mfrow=c(2,2))
lapply(
 columns,
  function(column)
  {
   plot(xrange,
   ref[[column]],

   ylab = "Unit of the y data",    #more descriptive label
   xlab = "Date",                   #more descriptive label
   col  = 2 , main = paste(column)
   )
points(xrange, sour1[[column]], col = 'green') #add date range
points(xrange, sour2[[column]], col = 'blue') #add date range
 }
)
-------------------------------------------------------------------------------------------------------
write.table(do.call(rbind,df2),file='test.csv') read.zoo library(zoo)
## you replace text= here by file=temp2.csv
dat <- read.zoo(text='nodeId,battery,date,idHistoric,temperature,longitude,latitude
3,78.00,2013-04-01 00:13:59,30163676,13.74,-3.80176,43.46192
3,78.00,2013-04-01 00:28:54,30163676,13.74,-3.80176,43.46192
4,78.00,2013-04-01 00:13:07,30164278,13.67,-3.80176,43.46192
4,78.00,2013-04-01 00:28:01,30163676,13.74,-3.80176,43.46192
5,78.00,2013-04-01 00:13:31,30163676,13.74,-3.80176,43.46192
5,78.00,2013-04-01 00:28:26,30164875,13.67,-3.80176,43.46192
6,78.00,2013-04-01 00:12:52,30164875,13.67,-3.80176,43.46192
6,78.00,2013-04-01 00:28:52,30164875,13.67,-3.80176,43.46192',header=TRUE,
                tz='',sep=',',index=3) library(xts)
df2 <- by(dat,dat$nodeId,function(x){
  ends <- endpoints(x, on = "minutes", k = 1)
  xx    <- period.apply(x, ends, mean)
})

write.table(do.call(rbind,df2),file='test.csv') read.table('test.csv')
                      nodeId battery idHistoric temperature longitude latitude
3.2013-04-01 00:13:59      3      78   30163676       13.74  -3.80176 43.46192
3.2013-04-01 00:28:54      3      78   30163676       13.74  -3.80176 43.46192
4.2013-04-01 00:13:07      4      78   30164278       13.67  -3.80176 43.46192
4.2013-04-01 00:28:01      4      78   30163676       13.74  -3.80176 43.46192
5.2013-04-01 00:13:31      5      78   30163676       13.74  -3.80176 43.46192
5.2013-04-01 00:28:26      5      78   30164875       13.67  -3.80176 43.46192
6.2013-04-01 00:12:52      6      78   30164875       13.67  -3.80176 43.46192
6.2013-04-01 00:28:52      6      78   30164875       13.67  -3.80176 43.46192 dd <- do.call(rbind,df2)
rownames(dd) <- gsub('*.[.]','',rownames(dd))
write.table(dd,file='test.csv') read.zoo('test.csv',index=0,tz='')
                    nodeId battery idHistoric temperature longitude latitude
2013-04-01 00:12:52      6      78   30164875       13.67  -3.80176 43.46192
2013-04-01 00:13:07      4      78   30164278       13.67  -3.80176 43.46192
2013-04-01 00:13:31      5      78   30163676       13.74  -3.80176 43.46192
2013-04-01 00:13:59      3      78   30163676       13.74  -3.80176 43.46192
2013-04-01 00:28:01      4      78   30163676       13.74  -3.80176 43.46192
2013-04-01 00:28:26      5      78   30164875       13.67  -3.80176 43.46192
2013-04-01 00:28:52      6      78   30164875       13.67  -3.80176 43.46192
2013-04-01 00:28:54      3      78   30163676       13.74  -3.80176 43.46192 do.call(rbind, unname(df2))
-------------------------------------------------------------------------------------------------------
df2 <- by(df,df$nodeId,function(x){
   ends <- endpoints(x, on = "minutes", k = 15)
   xx    <- period.apply(x, ends, mean)
})

i <- 1

total <- length(df2)

while( i <= total ){
    write.csv(df2[i],paste("lights_2013-04-0102/out_",i,".csv",sep = ""))
    i <- i + 1
}
-------------------------------------------------------------------------------------------------------
lines circleFun lines() par(mfrow=c(1, 2))

plot(x=c(-1, 0, 1), y=c(-1, 1, -1), xlim=c(-2, 2), ylim=c(-2, 2),
     type="l", asp=1)
points(x=c(-1, 1), y=c(-1, -1))

plot(x=c(-1, 0, 1, -1), y=c(-1, 1, -1, -1), xlim=c(-2, 2), ylim=c(-2, 2),
     type="l", asp=1)
points(x=c(-1, 1), y=c(-1, -1))
-------------------------------------------------------------------------------------------------------
period.apply(X2, endpoints(X2, "hours"), mean) apply.daily > apply.daily
function (x, FUN, ...)
{
    ep <- endpoints(x, "days")
    period.apply(x, ep, FUN, ...)
}
-------------------------------------------------------------------------------------------------------
base brX <- seq(min(myd$X),max(myd$X),length=11)
brY <- seq(min(myd$Y),max(myd$Y),length=11)

layout(matrix(c(1,0,2,3),nrow=2),width=c(2,8),height=c(8,2))
par(mar=c(0,3,5,0))
plot(NA,ylim=range(myd$Y),xlim=c(0,1),axes=F,ann=F,xaxs="i")
rect(0,brY[-length(brY)],1,brY[-1], 
     col=colorRampPalette(c("red","yellow","green"))(length(brY)-1))

par(mar=c(0,0,5,5))
plot(NA,xlim=range(myd$X),ylim=range(myd$Y),ann=F,xaxt="n",yaxt="n")
abline(h=pretty(myd$Y),v=pretty(myd$X), col="grey95")
points(myd$X,myd$Y,pch=21)
axis(3)
axis(4)

par(mar=c(3,0,0,5))
plot(NA,xlim=range(myd$X),ylim=c(0,1),axes=F,ann=F,yaxs="i")
rect(brX[-length(brX)],0,brX[-1],1, 
     col=colorRampPalette(c("blue","white","red"))(length(brX)-1))
-------------------------------------------------------------------------------------------------------
... central.simul <- function(N, ns,type = c("runif", "rnorm", "rbinom"),...){
        type <- match.arg(type)
        msample <- rep(NA,N)  ## EDIT here: intialisation
        for(i in 1:N){
          sam <- switch(type,
                        runif = runif(ns)*10,
                        rnorm = rnorm(ns)*10,
                        rbinom = rbinom(ns,...))
          msample[i] <- mean(sam) # save mean of sample
          add.hist <- i > 1
          h <- hist(msample, breaks=seq(0,10, len=50), # histogram of all means
                    xlim=c(0,10), col=grey(.9),
                    xlab="", main="Central Limit Theorem", border="blue", las=1,add=add.hist)
          points(sam, rep(max(h$count), length(sam)),
                 pch=16, col=grey(.2)) # add sampled values
          points(msample[i], max(h$count), # add sample mean value
                 col="red", pch=15)
          text(10, max(h$count), paste0("sample no ", i))
          hist(msample[i], breaks=seq(0,10, len=50), # ovelay sample mean 
               xlim=c(0,10), col="red", add=T, # in histogram
               xlab="", border="white", las=1)
          Sys.sleep(.1)
        }
    } central.simul(10,3,'runif')
central.simul(10,3,'rbinom',size=2,prob=0.5)
-------------------------------------------------------------------------------------------------------
library(rootSolve) # for the uniroot.all function
pfind<-function(k=3,gamma=7) 
{
pdiff <-function(p0) p0-plogis(-k + gamma * p0) 
uniroot.all(p.diff,c(0,1))
}
> fps= pfind()
> fps
[1] 0.08036917 0.32257992 0.97925817 pseq =seq(0,1,length=100)
plot(x=pseq ,y= plogis(-k + gamma *pseq),type= 'l')
abline(0,1,col='grey')
points(matrix(rep(fps,each=2), ncol=2, byrow=TRUE),pch=19,col='red')
-------------------------------------------------------------------------------------------------------
gen_xy() points(x,y,col="red") x=runif(1000,0,5)
     y=runif(1000,0,0.5) points(x,y) y < fx(x)
-------------------------------------------------------------------------------------------------------
#create A
x <- sample(1:10, 3, replace=TRUE)
y <- sample(1:10, 3, replace=TRUE)
A <- cbind(x,y)

#create B
x <- sample(1:10, 4, replace=TRUE)
y <- sample(1:10, 4, replace=TRUE)
B <- cbind(x,y)

plot(A, pch=11) # this will plot the points in A as stars of David
points(B, pch=14) # this will add the points in B as triangles inside squares
-------------------------------------------------------------------------------------------------------
regio data colvec <- c("red","blue")
plot(y, type = "n")
points(y, display = "sites", col = colvec[data$regio])
## or
text(y, display = "sites", col = colvec[data$regio])
## depending on how you want to represent the sample scores
-------------------------------------------------------------------------------------------------------
n <- 100
x <- rnorm(n)
x <- ( x - mean(x) ) / sd(x)
mean(x)   # 0, up to machine precision
sd(x)     # 1 ppoints x <- qnorm( ppoints(n) )
x <- ( x - mean(x) ) / sd(x)
mean(x)
sd(x) x C %*% x V = CC' C V # Desired variance matrix
V <- matrix( c(1,.2,.2, .2,1,.2, .2,.2,1), 3, 3 )

# Random data
n <- 100
k <- 3
x <- matrix( rnorm(k*n), nc=3 )

# Set the mean to 0, and the variance to the identity
x <- t( t(x) - colMeans(x) )
colMeans(x)   # 0
C1 <- chol(var(x))
x <- x %*% solve(C1)
var(x)   # identity matrix

# Set the variance to the desired value
C2 <- chol(V)
x <- x %*% C2
var(x) - V   # zero
-------------------------------------------------------------------------------------------------------
# say you have xts object name 'dat'
ep <- endpoints(dat, on = 'weeks')                          # 
period.apply(x = dat, INDEX = ep, FUN = mean)
-------------------------------------------------------------------------------------------------------
rollapply.right data data endpoints endpoints rollapply_chunks.FX.xts=function(data,width,FUN,...,on="days",k=1){
data <- try.xts(data)

x2 <- data
index(x2) <- index(x2)+(7*3600)
indexTZ(x2) <- 'America/New_York'

ep <- endpoints(x2,on=on,k=k)    #The end point of each calendar day (when on="days").
    #Each entry points to the final bar of the day. ep[1]==0.

if(length(ep)<2){
    stop("Cannot divide data up")
}else if(length(ep)==2){  #Can only fit one chunk in.
    sp <- 1;ep <- ep[-1]
}else{
    sp <- ep[1:(length(ep)-width)]+1
    ep <- ep[(width+1):length(ep)]
}

xx <- lapply(1:length(ep), function(ix) FUN(.subset_xts(data,sp[ix]:ep[ix]),...) )
xx <- do.call(rbind,xx)   #Join them up as one big matrix/data.frame.

tt <- index(data)[ep]  #Implicit align="right". Use sp for align="left"
res <- xts(xx, tt)
return (res)
}
-------------------------------------------------------------------------------------------------------
library(xts)
(z <- period.apply(zoo.object, endpoints(zoo.object, "quarters"), 
                    function(x) first(na.locf(x, fromLast=TRUE))))
#           stock1 stock2
#2013-03-12      1      7
#2013-06-25      5     10 yearqtr index(z) <- as.yearqtr(index(z))
z
#         stock1 stock2
#2013 Q1       1      7
#2013 Q2       5     10 index(z) <- as.Date(as.yearqtr(index(z)))
z
#           stock1 stock2
#2013-01-01      1      7
#2013-04-01      5     10
-------------------------------------------------------------------------------------------------------
xts library(xts)

mydata <- structure(list(DATE = structure(c(1362114023, 1362114053, 1362114083, 
1362114113, 1362114143, 1362114150, 1362114173, 1362114180, 1362114203, 
1362114210, 1362114233, 1362114240, 1362114263, 1362114270, 1362114293, 
1362114300, 1362114330, 1362114360, 1362114390, 1362114420, 1362114450, 
1362114480, 1362114510, 1362114540, 1362114570, 1362114600, 1362114630, 
1362114660, 1362114690, 1362114720, 1362114750, 1362114780, 1362114810, 
1362114840, 1362114870, 1362114900, 1362114930, 1362114960, 1362114990, 
1362115020, 1362115050, 1362115080, 1362115111, 1362115141, 1362115171, 
1362115201, 1362115231, 1362115261, 1362115291, 1362115321), class = c("POSIXct", 
"POSIXt"), tzone = ""), CPU = c(30L, 29L, 28L, 29L, 27L, 10L, 
25L, 11L, 23L, 9L, 22L, 8L, 22L, 7L, 19L, 7L, 7L, 8L, 6L, 7L, 
6L, 7L, 8L, 8L, 7L, 6L, 8L, 8L, 9L, 8L, 9L, 10L, 9L, 8L, 8L, 
6L, 8L, 7L, 9L, 10L, 11L, 11L, 9L, 9L, 8L, 9L, 11L, 8L, 6L, 8L
)), .Names = c("DATE", "CPU"), row.names = c(132611L, 132612L, 
132613L, 132614L, 132615L, 131428L, 132616L, 131429L, 132617L, 
131430L, 132618L, 131431L, 132619L, 131432L, 132620L, 131433L, 
131434L, 131435L, 131436L, 131437L, 131438L, 131439L, 131440L, 
131441L, 131442L, 131443L, 131444L, 131445L, 131446L, 131447L, 
131448L, 131449L, 131450L, 131451L, 131452L, 131453L, 131454L, 
131455L, 131456L, 131457L, 131458L, 131459L, 131460L, 131461L, 
131462L, 131463L, 131464L, 131465L, 131466L, 131467L), class = "data.frame")

mydata.xts <- xts(mydata$CPU, order.by = mydata$DATE) period.apply apply.periodly <- function (x, FUN, period, k=1, ...) 
{
  if (!require("xts")) {
    stop("Need 'xts'")
  }
  ep <- endpoints(x, on=period, k=k)
  period.apply(x, ep, FUN, ...)
} mydata.10m <- apply.periodly(x = mydata.xts, FUN = mean, period = "minutes", k = 10)
mydata.5m <- apply.periodly(x = mydata.xts, FUN = mean, period = "minutes", k = 5) mydata.10m
                     [,1]
2013-03-01 00:09:30 14.80
2013-03-01 00:19:31  8.55
2013-03-01 00:22:01  8.40

mydata.5m
                        [,1]
2013-03-01 00:04:53 19.93333
2013-03-01 00:09:30  7.10000
2013-03-01 00:14:30  8.30000
2013-03-01 00:19:31  8.80000
2013-03-01 00:22:01  8.40000
-------------------------------------------------------------------------------------------------------
help("openproj") # base R plot method
mapLL <- openproj(map)
plot(mapLL)
points(d)
-------------------------------------------------------------------------------------------------------
xts period.apply period.apply(SPY$PRICE, endpoints(SPY, "minutes", 5), mean)
-------------------------------------------------------------------------------------------------------
R> zzz <- xts(100+cumsum(rnorm(10)), Sys.time() + cumsum(runif(10))/1e3)
R> zzz
                               [,1]
2013-04-30 10:15:15.588007  98.9827
2013-04-30 10:15:15.588615 100.0029
2013-04-30 10:15:15.589559 100.6558
2013-04-30 10:15:15.590063  98.7353
2013-04-30 10:15:15.590466 100.0204
2013-04-30 10:15:15.590787 100.5416
2013-04-30 10:15:15.591345 100.5990
2013-04-30 10:15:15.591624 100.7908
2013-04-30 10:15:15.592415 101.8566
2013-04-30 10:15:15.592915 102.4576
R> plot(zzz)
Error in if (on == "years") { : missing value where TRUE/FALSE needed
R> traceback()
4: endpoints(x, cl, ck)
3: axTicksByTime(x, major.ticks, format.labels = major.format)
2: plot.xts(zzz)
1: plot(zzz)
R> R> plot(as.zoo(zzz))
-------------------------------------------------------------------------------------------------------
apply.periodly <- function (x, FUN, period, k=1, ...) 
{
  if (!require("xts")) {
    stop("Need 'xts'")
  }
  ep <- endpoints(x, on=period, k=k)
  period.apply(x, ep, FUN, ...)
}

total_df <- data.frame(DATE=as.POSIXct(character()), CPU=as.numeric(character()),  SERVER=character())


for(i in 1:length(servers)) {

    y<-subset(x, SERVER= c(servers[i]))
    mydata.xts <- xts(y$CPU, order.by = y$DATE)
    mydata.15M <- apply.periodly(x = mydata.xts, FUN = mean, period = "minutes", k = 15)

    new_df<-data.frame(date=index(mydata.15M), coredata(mydata.15M))
    colnames(new_df)<-c("DATE", "CPU")
    new_df$SERVER<-as.character(servers[i])

    total_df<-rbind(total_df, new_df)
-------------------------------------------------------------------------------------------------------
library(EMD)
x <- as.vector(sunspots)
r <- emd(x)
# Keep 5 components -- you may need more, or less.
y <- apply( r$imf[,5:10], 1, sum ) + mean(r$residue)
plot(x, type="l", col="grey")
lines( y, type="l", lwd=2)
n <- length(y)
i <- y[2:(n-1)] > y[1:(n-2)] & y[2:(n-1)] > y[3:n]
points( which(i), y[i], pch=15 )
-------------------------------------------------------------------------------------------------------
PeakCycle <- function(Data=as.vector(sunspots), SearchFrac=0.02){
    # using package "wmtsa"
    #the SearchFrac parameter just controls how much to look to either side 
    #of wavCWTPeaks()'s estimated maxima for a bigger value
    #see dRange
    Wave <- wavCWT(Data)
    WaveTree <- wavCWTTree(Wave)
    WavePeaks <- wavCWTPeaks(WaveTree, snr.min=5)
    WavePeaks_Times <- attr(WavePeaks, which="peaks")[,"iendtime"]

    NewPeakTimes <- c()
    dRange <- round(SearchFrac*length(Data))
    for(i in 1:length(WavePeaks_Times)){
        NewRange <- max(c(WavePeaks_Times[i]-dRange, 1)):min(c(WavePeaks_Times[i]+dRange, length(Data)))
        NewPeakTimes[i] <- which.max(Data[NewRange])+NewRange[1]-1
    }

    return(matrix(c(NewPeakTimes, Data[NewPeakTimes]), ncol=2, dimnames=list(NULL, c("PeakIndices", "Peaks"))))
}

dev.new(width=6, height=4)
par(mar=c(4,4,0.5,0.5))
plot(seq_along(as.vector(sunspots)), as.vector(sunspots), type="l")
Sunspot_Ext <- PeakCycle()
points(Sunspot_Ext, col="blue", pch=20)
-------------------------------------------------------------------------------------------------------
ddply() V1 library(plyr)
df<-ddply(Pair_Colours,.(Male,Female),nrow)
df
   Male Female V1
1     3      5  1
2     3      6  1
3     4      2  1
4     4      4  3

points(df$Male, df$Female, pch = 21, cex = df$V1, bg = "darkgray", col = "black", lwd = 1) aggregate() N aggregate() N Male Female Pair_Colours$N<-1
aggregate(N~Male+Female,data=Pair_Colours,FUN=sum)

   Male Female N
1     4      2 1
2     6      3 1
3     7      3 1
4     8      3 1
5     4      4 3
-------------------------------------------------------------------------------------------------------
EURUSD # calculate the desired endpoints
ep <- endpoints(EURUSD,"minutes")
# construct an xts object with a diff of the endpoints,
# using the index values of EURUSD at the endpoints, and
# merge it with the original data
Data <- merge(EURUSD, freq=xts(diff(ep), index(EURUSD)[ep]))
# back-fill NA, if desired
Data$freq <- na.locf(Data$freq, fromLast=TRUE)
-------------------------------------------------------------------------------------------------------
pchs grps require("vegan")
data(dune)

set.seed(123)
sol <- metaMDS(dune)

pchs <- 1:11
grps <- factor(sample(LETTERS[1:11], nrow(dune), replace = TRUE))
## note that not all 11 groups are included in this sample
## but this is just for show - you will have a variable containing
## the group membership data

plot(sol, type = "n", display = "sites")
points(sol, display = "sites", pch = pchs[grps]) require("ggvegan")
scrs <- fortify(sol)
scrs <- subset(scrs, subset = Score == "sites")
## ggplot doesn't like more than 6 groups for shape
grps <- factor(sample(LETTERS[1:6], nrow(dune), replace = TRUE))
scrs <- cbind(scrs, Group = grps) ## add on the group variable

## do the plot
ggplot(scrs, aes(x = Dim1, y = Dim2, shape = Group, colour = Group)) + 
  geom_point() + coord_fixed() scale fortify
-------------------------------------------------------------------------------------------------------
qqmath.ranef.mer() dotplot.ranef.mer() qqmath() dotplot() qqmath() require(lme4)                            ## for lmer(), sleepstudy
fit <- lmer(Reaction ~ Days + (Days|Subject), sleepstudy)
ggCaterpillar(ranef(fit, postVar=TRUE))  ## using ggplot2
qqmath(ranef(fit, postVar=TRUE))         ## for comparison dotplot() ggCaterpillar(ranef(fit, postVar=TRUE), QQ=FALSE)
dotplot(ranef(fit, postVar=TRUE)) dotplot() ggCaterpillar(ranef(fit, postVar=TRUE), QQ=FALSE, likeDotplot=FALSE) ## re = object of class ranef.mer
ggCaterpillar <- function(re, QQ=TRUE, likeDotplot=TRUE) {
    require(ggplot2)
    f <- function(x) {
        pv   <- attr(x, "postVar")
        cols <- 1:(dim(pv)[1])
        se   <- unlist(lapply(cols, function(i) sqrt(pv[i, i, ])))
        ord  <- unlist(lapply(x, order)) + rep((0:(ncol(x) - 1)) * nrow(x), each=nrow(x))
        pDf  <- data.frame(y=unlist(x)[ord],
                           ci=1.96*se[ord],
                           nQQ=rep(qnorm(ppoints(nrow(x))), ncol(x)),
                           ID=factor(rep(rownames(x), ncol(x))[ord], levels=rownames(x)[ord]),
                           ind=gl(ncol(x), nrow(x), labels=names(x)))

        if(QQ) {  ## normal QQ-plot
            p <- ggplot(pDf, aes(nQQ, y))
            p <- p + facet_wrap(~ ind, scales="free")
            p <- p + xlab("Standard normal quantiles") + ylab("Random effect quantiles")
        } else {  ## caterpillar dotplot
            p <- ggplot(pDf, aes(ID, y)) + coord_flip()
            if(likeDotplot) {  ## imitate dotplot() -> same scales for random effects
                p <- p + facet_wrap(~ ind)
            } else {           ## different scales for random effects
                p <- p + facet_grid(ind ~ ., scales="free_y")
            }
            p <- p + xlab("Levels") + ylab("Random effects")
        }

        p <- p + theme(legend.position="none")
        p <- p + geom_hline(yintercept=0)
        p <- p + geom_errorbar(aes(ymin=y-ci, ymax=y+ci), width=0, colour="black")
        p <- p + geom_point(aes(size=1.2), colour="blue") 
        return(p)
    }

    lapply(re, f)
}
-------------------------------------------------------------------------------------------------------
library(xts)
ex <- structure(c(NA, -63L, NA, NA, NA, NA, NA, 0L, NA, NA, NA, NA, 
NA, 1L, NA, NA, NA, NA), .Dim = c(6L, 3L), .Dimnames = list(NULL, 
    c("V2", "V3", "V4")), index = structure(c(1366088402.46, 
1366088402.46, 1366088402.463, 1366088402.463, 1366088469.697, 
1366088469.697), tzone = "", tclass = c("POSIXct", "POSIXt")),
class = c("xts", "zoo"), .indexCLASS = c("POSIXct", "POSIXt"),
tclass = c("POSIXct", "POSIXt"), .indexTZ = "", tzone = "")

options(digits.secs=6)

# endpoints() doesn't support sub-second resolution on Windows,
# so do what it does using only R code.
ep <- c(0,which(diff(.index(ex)%/%0.1%/%1+1) != 0),NROW(ex))
x <- period.apply(ex, ep, colSums, na.rm=TRUE)
x <- align.time(x, 0.1)
-------------------------------------------------------------------------------------------------------
panel.xyplot(x,y,...) lpoints() points() plot1<-xyplot(Percent ~ Distance, key = mykey, cex = dat$Pixels / 15000000, 
       col = dat$Forest_type+1,
       xlab="Distance", ylab="Percent of pixels",
       data = dat, 
       panel = function(x,y,...){
           panel.xyplot(x,y,...)
           lpoints(x, y, col="black", pch=16, cex=0.01)
      }) 

print(plot1, position=c(0, .5, 1, 1))
-------------------------------------------------------------------------------------------------------
lower.bound + mean + upper.bound groups= panel.superpose() mean subscripts upper.bound lower.bound LABS <- LETTERS[1:4]
with(df,
     dotplot(mean ~ code | problem * topic,
             lb=lower.bound, ub=upper.bound, mpch = c(3,1)[consistent+1],
             ylim = extendrange(c(0,100)),
             panel = function(x, y, lb, ub, mpch, ..., subscripts) {
                 panel.dotplot(x, y, ..., pch=mpch[subscripts])
                 lpoints(x, lb[subscripts], pch=6)
                 lpoints(x, ub[subscripts], pch=2)
                 lsegments(x,lb[subscripts],x,ub[subscripts],col="grey60")
                 ltext(x=x[3], y=95, LABS[panel.number()], col="red",fontface=2)
             },
             scales = list(x = list(draw = FALSE)), as.table = TRUE)
     )
-------------------------------------------------------------------------------------------------------
orditkplot() ordispider() ordispider() require("vegan")
data(dune)
data(dune.env)

mod <- decorana(dune)

plot(mod, display = "sites", type = "n")

## colour & shape according to Management
col <- c("red","orange","forestgreen","navy")
pch <- 1:4
## add the points
with(dune.env,
     points(mod, display = "sites", col = col[Management],pch = pch[Management]))
## add a legend
legend("topright",
       legend = with(dune.env, levels(Management)),
       col = col, pch = pch, title = "Management",
       bty = "n") locator() plot(mod, display = "sites", type = "p")
with(dune.env, ordispider(mod, groups = Management, col = "red"))
## select 4 locations
coords <- locator(with(dune.env, length(levels(Management))))

## now you have to click on the plot where you want the labels
## automagically finishes after you click the 4th label in this case

## draw labels
text(coords, labels = with(dune.env, levels(Management)))
-------------------------------------------------------------------------------------------------------
lapply i VaR modified method="historical" apply.monthly apply.monthly(ldr_sp500, VaR, method="historical") library(quantmod)
library(PerformanceAnalytics)
getSymbols("^GSPC", from = "2012-01-01" )
x <- Return.calculate( Ad(GSPC), method = "log" )
idx <- index(x)[endpoints(x, 'months')]
result <- sapply( idx,
  function(i) VaR( x[paste0("/",i)], method = "historical" )
)
xts( result, idx )
-------------------------------------------------------------------------------------------------------
plot.default() panel.first ## Your example
plot(x=1, y=2, 
     panel.first={points(0, 0, pch=16, cex=1e6, col="grey90")grid(col="white", lty=1)})

## Or, for repeated use, make it a function:
ggbg <- function() {
    points(0, 0, pch=16, cex=1e6, col="grey90")
    grid(col="white", lty=1)
}
plot(x=1, y=2, panel.first=ggbg()) ## Also works for plots running out to 1e300 in each direction
plot(x=-1e300, y=1e300, panel.first=ggbg())
-------------------------------------------------------------------------------------------------------
?points with(data.cold,plot(date,death,pch=".", ylab= expression("Mortality Count"), main = "Daily Mortality in cold season"))
with(data.warm ,points(date,death,pch=".", ylab= expression("Mortality Count"), main = "Daily Mortality in warm season", col="red"))
legend("topright", c("cold", "warm"), fill=c("black", "red"))
-------------------------------------------------------------------------------------------------------
approx ll <- lapply(1:5,function(i)
  data.frame(x=seq(i,length.out=10,by=i),y=rnorm(10))) approx big.df <- do.call(rbind,ll) plot(approx(big.df$x,big.df$y),type='l')
lapply(seq_along(ll), 
       function(i) points(ll[[i]]$x,ll[[i]]$y,col=i))
-------------------------------------------------------------------------------------------------------
mydf plot(mydf) points(mydf[mydf$Y==16,], col="red")
-------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------
## lonlat points
n <- 100
d <- cbind(runif(n, -180, 180), runif(n, -90, 90))


library(sp)
## distances on WGS84 ellipsoid
x <- spDists(d, longlat = TRUE)

## row, then column index of furthest points
ind <- c(row(x)[which.max(x)], col(x)[which.max(x)])

## maps
library(maptools)
data(wrld_simpl)
plot(as(wrld_simpl, "SpatialLines"), col = "grey")

points(d, pch = 16, cex = 0.5)

## draw the points and a line between  on the page
points(d[ind, ], pch = 16)
lines(d[ind, ], lwd = 2)


## for extra credit, draw the great circle on which the furthest points lie
library(geosphere)


lines(greatCircle(d[ind[1], ], d[ind[2], ]), col = "firebrick") geosphere ?spDists sp
-------------------------------------------------------------------------------------------------------
f(input) = Asym/(1+exp((xmid-input)/scal)) # as in ?SSlogis # Just for loading the data, we will use lme4 for model fitting, not nlme
library(nlme)
library(lme4)
# Careful when loading both nlme and lme4 as they have overlap, strange behaviour may occur

# A more generalized form could be taken e.g. from http://en.wikipedia.org/wiki/Generalised_logistic_curve
# A custom model structure:
Model <- function(age, Asym, Asym2, xmid, scal, Gender) 
{
    # Taken from ?SSlogis, standard form:
    #Asym/(1+exp((xmid-input)/scal))
    # Add gender-specific term to Asym2
    (Asym+Asym2*Gender)/(1+exp((xmid-age)/scal))
    # Evaluation of above form is returned by this function
}

# Model gradient, notice that we include all 
# estimated fixed effects like 'Asym', 'Asym2', 'xmid' and 'scal' here,
# but not covariates from the data: 'age' and 'Gender'
ModelGradient <- deriv(
    body(Model)[[2]], 
    namevec = c("Asym", "Asym2", "xmid", "scal"), 
    function.arg=Model
) # Binary coding for the gender
Orthodont2 <- data.frame(Orthodont, Gender = as.numeric(Orthodont[,"Sex"])-1)
#> table(Orthodont2[,"Gender"])
# 0  1 
#64 44 
# Ordering data based on factor levels so they don't mix up paneling in lattice later on
Orthodont2 <- Orthodont2[order(Orthodont2[,"Subject"]),] # Fit the non-linear mixed effects model
fit <- nlmer(
    # Response
    distance ~ 
    # Fixed effects
    ModelGradient(age = age, Asym, Asym2, xmid, scal, Gender = Gender) ~ 
    # replaces: SSlogis(age,Asym, xmid, scal) ~ 
    # Random effects
    (Asym | Subject) + (xmid | Subject), 
    # Data
    data = Orthodont2, 
    start = c(Asym = 25, Asym2 = 15, xmid = 11, scal = 3)) (Asym+Asym2*0)/(1+exp((xmid-age)/scal)) = (Asym)/(1+exp((xmid-age)/scal)) (Asym+Asym2)/(1+exp((xmid-age)/scal)) > summary(fit)
Nonlinear mixed model fit by the Laplace approximation 
Formula: distance ~ ModelGradient(age = age, Asym, Asym2, xmid, scal,      Gender = Gender) ~ (Asym | Subject) + (xmid | Subject) 
   Data: Orthodont2 
   AIC   BIC logLik deviance
 268.7 287.5 -127.4    254.7
Random effects:
 Groups   Name Variance Std.Dev.
 Subject  Asym 7.0499   2.6552  
 Subject  xmid 4.4285   2.1044  
 Residual      1.5354   1.2391  
Number of obs: 108, groups: Subject, 27

Fixed effects:
      Estimate Std. Error t value
Asym    29.882      1.947  15.350
Asym2   -3.493      1.222  -2.859
xmid     1.240      1.068   1.161
scal     5.532      1.782   3.104

Correlation of Fixed Effects:
      Asym   Asym2  xmid  
Asym2 -0.471              
xmid  -0.584  0.167       
scal   0.901 -0.239 -0.773 # Extracting fixed effects components by calling the model function, a bit messy but it works
# I like to do this for visualizing the model fit
fixefmat <- matrix(rep(fixef(fit), times=dim(Orthodont2)[1]), ncol=length(fixef(fit)), byrow=TRUE)
colnames(fixefmat) <- names(fixef(fit))
Orthtemp <- data.frame(fixefmat, Orthodont2)
attach(Orthtemp)
# see str(Orthtemp)
# Evaluate the function for rows of the attached data.frame to extract fixed effects corresponding to observations
fix = as.vector(as.formula(body(Model)[[2]]))
detach(Orthtemp)

nobs <- 4 # 4 observations per subject
legend = list(text=list(c("y", "Xb + Zu", "Xb")), lines = list(col=c("blue", "red", "black"), pch=c(1,1,1), lwd=c(1,1,1), type=c("b","b","b")))
require(lattice)
xyplot(
    distance ~ age | Subject, 
    data = Orthodont2,
    panel = function(x, y, ...){
        panel.points(x, y, type='b', col='blue')
        panel.points(x, fix[(1+nobs*(panel.number()-1)):(nobs*(panel.number()))], type='b', col='black')
        panel.points(x, fitted(fit)[(1+nobs*(panel.number()-1)):(nobs*(panel.number()))], type='b', col='red')
    },
    key = legend
)

# Residuals
plot(Orthodont2[,"distance"], resid(fit), xlab="y", ylab="e")

# Distribution of random effects
par(mfrow=c(1,2))
hist(ranef(fit)[[1]][,1], xlab="Random 'Asym'", main="")
hist(ranef(fit)[[1]][,2], xlab="Random 'xmid'", main="")
# Random 'xmid' seems a bit skewed to the right and may violate normal distribution assumption
# This is due to M13 having a bit abnormal growth curve (random effects):
#           Asym       xmid
#M13  3.07301310  3.9077583
-------------------------------------------------------------------------------------------------------
d = data.frame(what=c("A","B","Difference"), 
               mean=c(75,105,30),
               lower=c(50,80,-3),
               upper = c(100,130,63))

plot(-1,-1,xlim=c(1,3),ylim=c(0,140),xaxt="n")

lines(c(1,1),c(d[1,3],d[1,4]))
points(rep(1,3),d[1,2:4],pch=4)

lines(c(1.5,1.5),c(d[2,3],d[2,4]))
points(rep(1.5,3),d[2,2:4],pch=4)

lines(c(2,2),c(d[3,3],d[3,4]))
points(rep(2,3),d[3,2:4],pch=4)

lines(c(1.5,2.2),c(d[2,2],d[2,2]),lty="dotted")

axis(1, at=c(1,1.5,2), labels=c("A","B","Difference"))
axis(4,at=c(40,80,120),labels=c(-1,0,1),pos=2.2)
-------------------------------------------------------------------------------------------------------
par(mar=c(3,5,3,5))
plot(NA, xlim=c(.5,3.5), ylim=c(0, max(d$upper[1:2])), bty="l", xaxt="n", xlab="",ylab="Mean")
points(d$mean[1:2], pch=19)
segments(1,d$mean[1],5,d$mean[1],lty=2)
segments(2,d$mean[2],5,d$mean[2],lty=2)
axis(1, 1:3, d$what)
segments(1:2,d$lower[1:2],1:2,d$upper[1:2])
axis(4, seq((d$mean[1]-30),(d$mean[1]+50),by=10), seq(-30,50,by=10), las=1)
points(3,d$mean[1]+d$mean[3],pch=17, cex=1.5)
segments(3,d$lower[3]+d$lower[2],3,d$lower[3]+d$upper[2], lwd=2)
mtext("Difference", side=4, at=d$mean[1], line=3)
-------------------------------------------------------------------------------------------------------
library(Hmisc)

with(d1,
     errbar(as.integer(what),mean,upper,lower,xlim=c(0,4),xaxt="n",xlab="",ylim=c(0,150))
     )
points(3,d1[d1$what=="Difference","mean"],pch=15)
axis(1,at=1:3,labels=d1$what)
atics <- seq(floor(d[d$what=="Difference","lower"]/10)*10,ceiling(d[d$what=="Difference","upper"]/10)*10,by=10)
axis(4,at=atics+d1[d1=="A","mean"],labels=atics,pos=3.5)
-------------------------------------------------------------------------------------------------------
places mapproj() map(database="worldHires", projection="mercator", 
    xlim=c(-12,50), ylim=c(35, 70), 
    resolution=1, mar=c(0, 0, 0, 0))
points(mapproject(places$lon, places$lat), col="red")
-------------------------------------------------------------------------------------------------------
filled.contour(z=dat1,col=Contourcolors,
      plot.axes=points( x=seq(0, 1, length.out = nrow(dat1)),
                        y=rep(.5,20), 
                        col=PointColors,cex=5,pch=19)
               )
-------------------------------------------------------------------------------------------------------
#Example from help page ("works")

fit <- survfit(Surv(time, status==2) ~ sex, pbc,subset=1:312)
 plot(fit, mark.time=FALSE, xscale=365.25,
         xlab='Years', ylab='Survival')
 lines(fit[1], lwd=2, col="black", xscale=365.24)    
 points(fit[1], lwd=2, col="red", xscale=365.24)
-------------------------------------------------------------------------------------------------------
par(mar=c(5,5,2,5), xpd=TRUE)

x <- seq(0,5,0.5)
y <- seq(0,5,0.5)
plot(x,y, xlab="", ylab="")


text(-1,2.5,"y axis text", cex=1.25, adj=0, srt=90)
points(-1,2.4)
-------------------------------------------------------------------------------------------------------
points points points(1:10,1:10) # plot.new error
plot(1:10,1:10) # no error, starts a new plot
points(10:1,1:10) # adds extra points, no error. ggplot
-------------------------------------------------------------------------------------------------------
lm newdata ?predict ?predict.lm y <- c(0.040, 0.073, 0.87)
x <- c(10.0, 15.0, 20.0)
poly.lm <- lm(y ~ poly(x, 2))

# As DWin noted, predict() will compute fitted y-values using an lm object alone:
all.equal(predict(poly.lm), poly.lm$fitted)
# [1] TRUE

# To predict y for new x-values, make a data.frame: 
new.x <- seq(0, 20, 1.0)
new.df <- data.frame(x=new.x)
new.y <- predict(poly.lm, newdata=new.df)


# Unsolicited visualization.
par(mfrow=c(1, 2))
plot(x, y, pch=16, cex=1.6, xlim=c(0, 20), ylim=c(0, 3))
plot(new.x, new.y, col="skyblue", pch=16, cex=1.6, xlim=c(0, 20), ylim=c(0, 3))
points(x, y, cex=1.6)
-------------------------------------------------------------------------------------------------------
turnpoints pastecs library(pastecs)
data <- read.table("Untitled.txt")
tp <- turnpoints(data[,2])

dist_from_middle <- function(x, middle) {
    sqrt((x-middle)^2)
}
peaks = extract(tp, pit=0)
distances = sapply(data[,1], dist_from_middle, middle=46813621)
data <- data.frame(data, peak = peaks, distance = distances)

peaks <- data[which(data$peak==1),]
#         V1  V2 peak distance
#7  46813531   3    1       90
#27 46813731 104    1      110
#42 46813881   5    1      260
#58 46814061   2    1      440
closest_peak <- peaks[which(peaks$distance==min(peaks$distance)),]
#        V1 V2 peak distance
#7 46813531  3    1       90 turnpoints sig_extrema <- data[tp$tppos[which(tp$proba < 0.05)],]
sig_maxima <- sig_extrema[which(sig_extrema$peak==1),]
closest_maxima <- sig_maxima[which(
    sig_maxima$distance==min(sig_maxima$distance)),]
#         V1  V2 peak distance
#27 46813731 104    1      110
-------------------------------------------------------------------------------------------------------
bg par base plot(d0)
subplot(fun = {plot(d0_inset, mgp = c(1,0.4,0), ann = F, cex.axis=0.5);
               rect(par("usr")[1],par("usr")[3],par("usr")[2],par("usr")[4],col = "blue");
               points(d0_inset, col=2, pch=".") }, 
        x = grconvertX(c(0.75,1), from='npc'), 
        y = grconvertY(c(0,0.25), from='npc'), 
        pars = list(mar = c(1.5,1.5,0,0) + 0.1), type="fig") plot(d0)
rect(grconvertX(0.75, from='npc'), grconvertY(0, from='npc'),
     grconvertX(1, from='npc'), grconvertY(0.25, from='npc'), 
     col="blue", border=NA)
subplot(fun = plot(d0_inset, mgp = c(1,0.4,0), ann = F, 
                    cex.axis=0.5,col=2, pch=".") , 
        x = grconvertX(c(0.75,1), from='npc'), 
        y = grconvertY(c(0,0.25), from='npc'), 
        pars = list(mar = c(1.5,1.5,0,0) + 0.1), type="fig")
-------------------------------------------------------------------------------------------------------
for (j in (1:2218)*2) {
 x <- unlist(e_web_clear[2*j-1,])
 y <- unlist(e_web_clear[2*j,])
 lines(x,y,'l',lwd=.00000000001, col="black")
 points(x[358], y[358], lwd = 1.5, cex = .1, col = "lightblue")
 }
-------------------------------------------------------------------------------------------------------
plot > plot(male,pch=16,col="red")
> lines(male, pch=16, col = "red")
> lines(female, pch=16, col = "green")
> points(female, pch=16, col = "green")
-------------------------------------------------------------------------------------------------------
legend(...expression(""<="1.0"),col="gray"...) ?plotmath expression() x <- 0:64/64
y <- sin(3*pi*x)
plot(x, y, type= "l", col= "blue",
     main= expression("How to add the symbol"<="to a legend"))
points(x, y, pch= 1, bg= "white")
legend(.4,1, expression(""<= "1.0"), pch= 1, pt.bg= "white", lty= 1, col= "blue")
-------------------------------------------------------------------------------------------------------
points(inter, pch='.')
-------------------------------------------------------------------------------------------------------
xts hourly.apply library(xts)
 dat.xts <- xts(Total_Solar_Gesamt$TotalSolar_MW,
                as.POSIXct(otal_Solar_Gesamt$Timedate))
 hourly.apply(dat.xts,sum) period.apply lapply ends <- endpoints(zoo.data,'hours',2) 
 period.apply(dat.xts,ends ,sum)
-------------------------------------------------------------------------------------------------------
par(mfg= pars <- c('plt','usr')

par(mfrow=c(2,2))

plot(anscombe$x1, anscombe$y1, type='n')
par1 <- c(list(mfg=c(1,1,2,2)), par(pars))
plot(anscombe$x2, anscombe$y2, type='n')
par2 <- c(list(mfg=c(1,2,2,2)), par(pars))
plot(anscombe$x3, anscombe$y3, type='n')
par3 <- c(list(mfg=c(2,1,2,2)), par(pars))
plot(anscombe$x4, anscombe$y4, type='n')
par4 <- c(list(mfg=c(2,2,2,2)), par(pars))

for( i in 1:11 ) {
    par(par1)
    points(anscombe$x1[i], anscombe$y1[i])
    Sys.sleep(0.5)
    par(par2)
    points(anscombe$x2[i], anscombe$y2[i])
    Sys.sleep(0.5)
    par(par3)
    points(anscombe$x3[i], anscombe$y3[i])
    Sys.sleep(0.5)
    par(par4)
    points(anscombe$x4[i], anscombe$y4[i])
    Sys.sleep(0.5)
}
-------------------------------------------------------------------------------------------------------
boxplot.stats polygon boxpattern <- 
function(y, xcenter, boxwidth, angle=NULL, angle.density=10, ...) {
    # draw an individual box
    bstats <- boxplot.stats(y)
    bxmin <- bstats$stats[1]
    bxq2 <- bstats$stats[2]
    bxmedian <- bstats$stats[3]
    bxq4 <- bstats$stats[4]
    bxmax <- bstats$stats[5]
    bleft <- xcenter-(boxwidth/2)
    bright <- xcenter+(boxwidth/2)
    # boxplot
    polygon(c(bleft,bright,bright,bleft,bleft),
        c(bxq2,bxq2,bxq4,bxq4,bxq2), angle=angle[1], density=angle.density)
    polygon(c(bleft,bright,bright,bleft,bleft),
        c(bxq2,bxq2,bxq4,bxq4,bxq2), angle=angle[2], density=angle.density)
    # lines
    segments(bleft,bxmedian,bright,bxmedian,lwd=3) # median
    segments(bleft,bxmin,bright,bxmin,lwd=1) # min
    segments(xcenter,bxmin,xcenter,bxq2,lwd=1)
    segments(bleft,bxmax,bright,bxmax,lwd=1) # max
    segments(xcenter,bxq4,xcenter,bxmax,lwd=1)
    # outliers
    if(length(bstats$out)>0){
        for(i in 1:length(bstats$out))
            points(xcenter,bstats$out[i])
    }
}

drawboxplots <- function(y, x, boxwidth=1, angle=NULL, ...){
    # figure out all the boxes and start the plot
    groups <- split(y,as.factor(x))
    len <- length(groups)
    bxylim <- c((min(y)-0.04*abs(min(y))),(max(y)+0.04*max(y)))
    xcenters <- seq(1,max(2,(len*(1.4))),length.out=len)
    if(is.null(angle)){
        angle <- seq(-90,75,length.out=len)
        angle <- lapply(angle,function(x) c(x,x))
    }
    else if(!length(angle)==len)
        stop("angle must be a vector or list of two-element vectors")
    else if(!is.list(angle))
        angle <- lapply(angle,function(x) c(x,x))
    # draw plot area
    plot(0, xlim=c(.97*(min(xcenters)-1), 1.04*(max(xcenters)+1)),
        ylim=bxylim, 
        xlab="", xaxt="n",
        ylab=names(y), 
        col="white", las=1)

    axis(1, at=xcenters, labels=names(groups))
    # draw boxplots
    plots <- mapply(boxpattern, y=groups, xcenter=xcenters,
        boxwidth=boxwidth, angle=angle, ...)
} mydat <- data.frame(y=c(rnorm(200,1,4),rnorm(200,2,2)),
                    x=sort(rep(1:2,200)))
drawboxplots(mydat$y, mydat$x) mydat <- data.frame(y=c(rnorm(200,1,4),rnorm(200,2,2),
                        rnorm(200,3,3),rnorm(400,-2,8)),
                    x=sort(rep(1:5,200)))
drawboxplots(mydat$y, mydat$x) drawboxplots(mydat$y, mydat$x, boxwidth=.5, angle.density=30) drawboxplots(mydat$y, mydat$x, # specify list of two-element angle parameters
             angle=list(c(0,0),c(90,90),c(45,45),c(45,-45),c(0,90))) x <- rep(1:10,10)
y <- sort(x)
plot(y~x, xlim=c(0,11), ylim=c(0,11), pch=20)
outerbox.x <- c(2.5,0.5,10.5,10.5,0.5,0.5,2.5,7.5,7.5,2.5)
outerbox.y <- c(2.5,0.5,0.5,10.5,10.5,0.5,2.5,2.5,7.5,7.5)
polygon(outerbox.x,outerbox.y, col="white", border="white") # donut
polygon(c(2.5,2.5,7.5,7.5,2.5),c(2.5,2.5,2.5,7.5,7.5)) # inner box
-------------------------------------------------------------------------------------------------------
x <- structure(c(28.2, 28.2, 28.2, 28.2, 28.1, 28.1, 28.1, 28.1, 28.1, 28.2,
  28.3, 28.2, 28.2, 28.1, 28.1, 28.1, 28.1, 28.1, 28, 28, 28, 28, 28, 28, 28,
  28, 28, 28, 28, 28, 27.9, 27.9, 27.9, 27.9, 27.9, 27.9, 27.8, 27.8, 27.8,
  27.8, 27.8, 27.8, 27.8, 27.8, 27.8, 27.8, 27.8, 27.8, 27.8, 27.8, 27.8, 27.8,
  27.8, 27.8, 27.8, 27.8, 27.7, 27.7, 27.7, 27.8), class = c("xts", "zoo"),
  .indexCLASS = c("POSIXct", "POSIXt"), tclass = c("POSIXct", "POSIXt"),
  .indexTZ = "", tzone = "", index = structure(c(1356998400, 1356998460,
  1356998520, 1356998580, 1356998640, 1356998700, 1356998760, 1356998880,
  1356998940, 1356999000, 1356999060, 1356999120, 1356999180, 1356999240,
  1356999300, 1356999360, 1356999420, 1356999480, 1356999540, 1356999600,
  1356999660, 1356999720, 1356999780, 1356999840, 1356999900, 1356999960,
  1357000020, 1357000080, 1357000140, 1357000200, 1357000260, 1357000320,
  1357000380, 1357000440, 1357000500, 1357000560, 1357000620, 1357000680,
  1357000740, 1357000800, 1357000860, 1357000920, 1357000980, 1357001040,
  1357001100, 1357001160, 1357001220, 1357001280, 1357001340, 1357001400,
  1357001460, 1357001520, 1357001580, 1357001640, 1357001700, 1357001760,
  1357001820, 1357001880, 1357001940, 1357002000), tzone = "",
  tclass = c("POSIXct", "POSIXt")), .Dim = c(60L, 1L))
y <- cbind(x, c(0,diff(.index(x))))
f <- function(z) weighted.mean(z[,1],z[,2])
period.apply(y, endpoints(y, "minutes", 10), f)
#                         [,1]
# 2012-12-31 18:09:00 28.13333
# 2012-12-31 18:19:00 28.14000
# 2012-12-31 18:29:00 28.00000
# 2012-12-31 18:39:00 27.88000
# 2012-12-31 18:49:00 27.80000
# 2012-12-31 18:59:00 27.77000
# 2012-12-31 19:00:00 27.80000
-------------------------------------------------------------------------------------------------------
plot(x, p1.at.x, col="red",ylab='p',ylim=range(p0.at.x,p1.at.x))   
par(new=TRUE)  
plot(x, p0.at.x, col="blue",ylab='p', ylim=range(p0.at.x,p1.at.x)) plot(x, p1.at.x, col="red",ylab='p',ylim=range(p0.at.x,p1.at.x))    
points(x, p0.at.x, col="blue",ylab='p', ylim=range(p0.at.x,p1.at.x))
-------------------------------------------------------------------------------------------------------
speed <- structure(list(A = c(3.59e-05, 3.75e-05, 9.67e-05, 3.92e-05,
  2.14e-05, 9.8e-05, 0.000228481, 0.000228481, 0.000415583, 0.000859052,  
0.002014948, 0.004079371, 0.00406138, 0.004353728, 0.008455587,     
0.007780939, 0.018260469, NA, NA, NA, NA, NA, NA), B = c(4.76, 6.28, 10.5,
 10.6, 12.3, 12.8, 16, 16.8, 20.7, 25.2, 34.4, 36.4, 37.7, 43.6, 48.7, 49.2,
 66.5, NA, NA, NA, NA, NA, NA), C = c(1.734691244, 2.016976959, 1.707373272, 
1.461511521, 0.805880184, 0.417509677, 0.427070968, 0.220364977, 0.21763318, 
0.170282028, 0.169826728, 0.095612903, 0.094247005, 0.048717051, 0.044072995, 
0.034921475,  0.023721106, 0.022901567, 0.018485161, 0.015252535, 0.008240922, 
 0.003942894, 0.002868387), D = c(176, 175, 169, 169, 169, 162, 161, 146, 146,
 143, 143, 121, 117, 90, 90, 77.7, 70.3, 69.2, 67, 59.6, 50.4, 36.1, 33.7), 
E = c(0.0235, 0.044636324, 0.075155479, 0.072909589, 0.09736484, 0.0988621, 
0.199428082, 0.202422603, 0.362878995, 0.370365297, 0.355392694, 1.438410959, 
0.727212329,  0.722221461, 1.40597032, NA, NA, NA, NA, NA, NA, NA, NA), 
F = c(69L, 90L, 111L, 114L, 114L, 116L, 143L, 146L, 161L, 163L, 164L, 170L, 
172L, 175L, 180L, NA, NA, NA, NA, NA, NA, NA, NA), G = c(35.29300714, 
17.47300714, 4.351007143, 3.182292857, 3.182292857, 1.411864286, 1.435007143,
 NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,  NA, NA, NA, NA), H = c(180L, 180L, 180L, 180L, 177L, 175L, 171L,  NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,
 NA, NA, NA, NA, NA, NA ), I = c(0.021, 0.0258, 0.029929032, 0.034574194, 
0.064612903,   0.088870968, 0.17816129, 0.163967742, NA, NA, NA, NA, NA, 
NA,NA, NA, NA, NA, NA, NA, NA, NA, NA), J = c(67, 68.7, 75.2, 84.6,  115,
 121, 152, 155, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA)), 
.Names = c("A", "B", "C", "D", "E", "F", "G", "H", "I", "J"),
 class = "data.frame", row.names = c(NA, -23L)) plot(speed$A,speed$B,xlim=range(1e-5:100),ylim=range(0:200),xlab="Time",ylab="Distance",pch=19,log="x")
points(speed$C,speed$D,col="red",pch=21)
points(speed$E,speed$F,col="blue",pch=18)
points(speed$G,speed$H,col="yellow",pch=19)
points(speed$I,speed$J,col="green",pch=20)
legend("top", legend = c("Car 1","Car 2","Car 3","Car 4","Car 5"), col = c("black","red","blue","yellow","green"),
       ncol = 2,pch=c(19,21,18,19,20)) library(ggplot2)
ggplot(speed,aes(A,B))+geom_point()+xlim(1e-5,100)+ylim(0,200)+scale_x_log10()+
  geom_point(data=speed,aes(C,D),col="red")+geom_point(data=speed,aes(E,F),col="blue")+
  geom_point(data=speed,aes(G,H),col="green")+geom_point(data=speed,aes(I,J),col="orange",shape=2)+
  xlab("Distance")+ylab("Distance") ## Separate the data by cars
car1 <- speed[,c(1,2)]
car1$id <- "Car1"
car2 <- speed[,c(3,4)]
car2$id <- "Car2"
car3 <- speed[,c(5,6)]
car3$id <- "Car3"
car4 <- speed[,c(7,8)]
car4$id <- "Car4"
car5 <- speed[,c(9,10)]
car5$id <- "Car5"
names(car1)<- names(car2) <- names(car3) <- names(car4) <- names(car5)<- c("distance","speed","id") myspeed <- rbind(car1,car2,car3,car4,car5) ggplot(myspeed,aes(distance,speed))+geom_point(aes(color=id))+xlim(1e-5,100)+ylim(0,200)+scale_x_log10()
-------------------------------------------------------------------------------------------------------
text(x=fit[, 2], y=fit[, 3], labels=fit[, 1])
points(x=fit[fit$ID==10, 2], y=fit[fit$ID==10, 3], col="red")
-------------------------------------------------------------------------------------------------------
points(cl$centers, col = 1:5, pch = 8, cex = 2) plot pairs() pairs() panel lower.panel upper.panel pairs() # I use the variable name "x" elsewhere, 
# renaming it here explicitly for clarity  
x.mat=x

# I moved the "jitter" into this submethod, so you won't see it
# in the main 'pairs()' call. I needed to do this to identify the source
# column the data came from in low.panelfun.
up.panelfun <- function(x,y,clust=cl$cluster,...){
  # this plots the main pairs plot
  sapply(unique(clust), function(c){ points(jitter(x[clust==c]),jitter(y[clust==c]), col=c)}) 
}

low.panelfun <- function(x,y,clust=cl$cluster,...){
  # this plots the main pairs plot
  up.panelfun(x,y,clust)

  # this finds the appropriate column the panel is related
  # to and plots the centroids.
  xi=which(length(x)==apply(x.mat, 2, function(v){sum(v==x)}))
  yi=which(length(y)==apply(x.mat, 2, function(v){sum(v==y)}))
  points(cl$centers[xi,],cl$centers[yi,], col = 1:5, pch = 8, cex = 2)
}

pairs(x.mat, col = cl$cluster
      ,lower.panel=low.panelfun
      ,upper.panel=up.panelfun
) # amplify clusters by replicating data a few times
pairs(rbind(x.mat, x.mat, x.mat, x.mat), col = cl$cluster
      ,lower.panel=low.panelfun
      ,upper.panel=up.panelfun
) plot();points()
-------------------------------------------------------------------------------------------------------
# Precision of factorial calculation (very important for the Fisher's Exact Test)
library(gmp)
perfectprecision<-list()
singleprecision<-c()
doubleprecision<-c()
for (x in 1:100){
    perfectprecision[x][[1]]<-factorialZ(x)
    singleprecision<-c(singleprecision,factorial(x))
    doubleprecision<-c(doubleprecision,prod(1:x))
}


plot(0,col="white",xlim=c(1,100),ylim=c(0,log10(abs(doubleprecision[100]-singleprecision[100])+1)),
        ,ylab="Log10 Absolute Difference from Big Integer",xlab="x!")
for(x in 1:100) {
    points(x,log10(abs(perfectprecision[x][[1]]-singleprecision[x])+1),pch=16,col="blue")
    points(x,log10(abs(perfectprecision[x][[1]]-doubleprecision[x])+1),pch=20,col="red")
}
legend("topleft",col=c("blue","red"),legend=c("factorial(x)","prod(1:x)"),pch=c(16,20))
-------------------------------------------------------------------------------------------------------
require(maps) # save the world
png("world.png", width=500, height=200)
map("world", col="grey90", fill=TRUE, border="grey90",  mar=c(0,0,0,0))
dev.off()

library(png); library(grid)
img = readPNG("world.png") 

animation::saveGIF( {
  for( ii in 1:100) {
    grid.newpage()
    grid.raster(img)
    grid.points(default.units="npc")
  }
  }, ani.height=200, ani.width=500)
-------------------------------------------------------------------------------------------------------
plot.spei plot.spei <- 
function (x, ...) 
{
    ## label <- ifelse(as.character(x$call)[1] == "spei", "SPEI", 
    ##     "SPI")

    ser <- ts(as.matrix(x$fitted[-c(1:x$scale), ]), end = end(x$fitted), 
        frequency = frequency(x$fitted))
    ser[is.nan(ser - ser)] <- 0
    se <- ifelse(ser == 0, ser, NA)
    tit <- dimnames(x$coefficients)[2][[1]]
    if (start(ser)[2] == 1) {
        ns <- c(start(ser)[1] - 1, 12)
    }
    else {
        ns <- c(start(ser)[1], start(ser)[2] - 1)
    }
    if (end(ser)[2] == 12) {
        ne <- c(end(ser)[1] + 1, 1)
    }
    else {
        ne <- c(end(ser)[1], end(ser)[2] + 1)
    }
    n <- ncol(ser)
    if (is.null(n)) 
        n <- 1
    par(mar = c(4, 4, 2, 1) + 0.1)
    if (n > 1 & n < 5) 
        par(mfrow = c(n, 1))
    if (n > 1 & n >= 5) 
        par(mfrow = c({
            n + 1
        }%/%2, 2))
    for (i in 1:n) {
        datt <- ts(c(0, ser[, i], 0), frequency = frequency(ser), 
            start = ns, end = ne)
        datt.pos <- ifelse(datt > 0, datt, 0)
        datt.neg <- ifelse(datt <= 0, datt, 0)
        plot(datt, type = "n", xlab = "", main = tit[i], ...)
        if (!is.null(x$ref.period)) {
            k <- ts(5, start = x$ref.period[1, ], end = x$ref.period[2, 
                ], frequency = 12)
            k[1] <- k[length(k)] <- -5
            polygon(k, col = "light grey", border = NA, density = 20)
            abline(v = x$ref.period[1, 1] + (x$ref.period[1, 
                2] - 1)/12, col = "grey")
            abline(v = x$ref.period[2, 1] + (x$ref.period[2, 
                2] - 1)/12, col = "grey")
        }
        grid(col = "black")
        polygon(datt.pos, col = "blue", border = NA)
        polygon(datt.neg, col = "red", border = NA)
        lines(datt, col = "dark grey")
        abline(h = 0)
        points(se, pch = 21, col = "white", bg = "black")
    }
} ylab plot(spi1, ylab = "SPI") ts par(mfrow = c(3, 4))
listofmonths <- split(fitted(spi1), cycle(fitted(spi1)))
names(listofmonths) <- month.abb

require(plyr)
l_ply(seq_along(listofmonths), function(x) {
       plot(x = seq_along(listofmonths[[x]]), y = listofmonths[[x]],
            type = "l", xlab = "", ylab = "SPI")
       title(names(listofmonths)[x])
   }) monthplot(fitted(spi1), labels = month.abb, cex.axis = 0.8)
boxplot(fitted(spi1) ~ cycle(fitted(spi1)), names = month.abb, cex.axis = 0.8)
-------------------------------------------------------------------------------------------------------
my_line <- function(x,y,...){
    points(x,y,...)
    abline(a = 0,b = 1,...)
}
pairs(USJudgeRatings, lower.panel = my_line, upper.panel = panel.cor)
-------------------------------------------------------------------------------------------------------
# generate data points
points <- data.frame(long=runif(100,-122.4154,-122.3491))
points$lat <- runif(100,37.5976,37.6425)
points$long2 <- runif(100,-122.4154,-122.3491)
points$lat2 <- runif(100,37.5976,37.6425)

# function returns a data frame with interpolated points in between start and end point
interp_points <- function (data) {

  df <- data.frame(line_id=c(),long=c(),lat=c())

  for (i in 1:nrow(data)) { 

    line <- data[i,]

    # interpolate lats and longs in between the two
    longseq <- seq(
                    as.numeric(line["long"]),
                    as.numeric(line["long2"]),
                    as.numeric((line["long2"] - line["long"])/10)
                  )
    latseq <- seq(
                    as.numeric(line["lat"]),
                    as.numeric(line["lat2"]),
                    as.numeric(line["lat2"] - line["lat"])/10
                  )

    for (j in 1:10) {
      df <- rbind(df,data.frame(line_id=i,long=longseq[j],lat=latseq[j],seg_num=j))
    }
  }

  df
}

# run data through function
output <- interp_points(points)

# plot the output
ggplot(output,aes(x=long,y=lat,group=line_id,color=seg_num)) + 
  geom_path(alpha=0.4,size=1) +
  scale_color_gradient(high="red",low="blue")
-------------------------------------------------------------------------------------------------------
tabo['AGO',] tabo['AFG',] tabo['ABW',] tabo[tabo$code_o == 'AGO',]
tabo[tabo$code_o == 'AFG',]
tabo[tabo$code_o == 'ABW',] bp.inf tabo = tabo[b,] tabo data bp.inf <- breakpoints(year ~ tradevaluein1000usd, data = tabo[tabo$code_o == 'AGO',], h = 8) {
-------------------------------------------------------------------------------------------------------
period.apply endpoints # create sample data
library(xts)
set.seed(21)
N <- 1e6
events <- cbind(sample(2000, N, replace=TRUE),
  as.POSIXct("2012-01-01")+sample(1e7,N))
colnames(events) <- c("type","times")
# create xts object
xevents <- xts(events[,"type"], .POSIXct(events[,"times"]))
# find the last row of each non-overlapping 5-minute interval
ep <- endpoints(xevents, "minutes", 5)
# count the number of occurrences of each "type"
counts <- period.apply(xevents, ep, tabulate, nbins=2000)
# set colnames
colnames(counts) <- paste0("a",1:ncol(counts))
# calculate correlation
#cc <- cor(counts) # Create a sequence of 5-minute steps, from the actual start of the data
m5 <- seq(round(start(xevents),'mins'), end(xevents), by='5 mins')
# Create a sequence of 5-minute steps, from the start of 2012-01-01
m5 <- seq(as.POSIXct("2012-01-01"), end(xevents), by='5 mins')
# merge xevents with empty 5-minute xts object, and
# subtract 1 second, so endpoints are at end of each 5-minute interval
xevents5 <- merge(xevents, xts(,m5-1))
ep5 <- endpoints(xevents5, "minutes", 5)
counts5 <- period.apply(xevents5, ep5, tabulate, nbins=2000)
colnames(counts5) <- paste0("a",1:ncol(counts5))
# align to the beginning of each 5-minute interval, if you want
counts5 <- align.time(counts5,60*5)
-------------------------------------------------------------------------------------------------------
pch dat <- data.frame(x=rnorm(100), y1=rnorm(100)-1, y2=rnorm(100), y3=rnorm(100)+1)
plot(y1 ~ x, data=dat, pch="0", ylim=c(-4, 4))
points(y2 ~ x, data=dat, pch="3")
points(y3 ~ x, data=dat, pch="6") pch dat <- data.frame(x=rnorm(300), y=rnorm(300) + c(0,3,6), depth=rep(c(0,3,6), 100))
plot(x ~ y, data=dat, pch=as.character(dat$depth))
-------------------------------------------------------------------------------------------------------
d1 <- data.frame(x=runif(20),y=runif(20))
d2 <- data.frame(x=rnorm(10),y=rnorm(10))
d3 <- data.frame(x=rpois(5,5),y=rpois(5,5))
allD <- rbind(d1,d2,d3)
plot(y~x,data=d1,xlim=range(allD$x),ylim=range(allD$y))
with(d2,points(x,y,col=2))
with(d3,points(x,y,col=4)) plot(y~x,data=d1,xlim=range(allD$x),ylim=range(allD$y),type="n")
mapply(function(x,c) with(x,points(x,y,col=c)),
       list(d1,d2,d3),c(1,2,4)) allD$group <- rep(1:3,c(20,10,5))
plot(y~x,data=allD,col=allD$group) library(lattice)
xyplot(y~x,groups=group,data=allD) library(ggplot2)
ggplot(allD,aes(x,y,colour=factor(group)))+geom_point()
-------------------------------------------------------------------------------------------------------
autos_data = read.table(text="car    1
car    2 
car    3 
car2   1 
car2   2 
car2   3", header=F)

aData2 = autos_data[!duplicated(autos_data[,1]),]

dotchart(aData2[,2], labels=aData2[,1], 
         xlim=c(min(autos_data[,2]), max(autos_data[,2])))
points(autos_data[,2] , autos_data[,1])
-------------------------------------------------------------------------------------------------------
read.zoo read.csv # get list of all files (change pattern to match your actual filenames)
files <- list.files(pattern="file.*csv")
# loop over each file name and read data into an xts object
xtsList <- lapply(files, function(f) {
  d <- as.xts(read.zoo(f, sep=",", header=TRUE, FUN=as.POSIXct))
  d <- align.time(d, 15*60)
  ep <- endpoints(d, "minutes", 15)
  period.apply(d, ep, mean)
})
# set the list names to the file names
names(xtsList) <- files
# merge all the file data into one object, filling in NA with na.locf
x <- do.call(merge, c(xtsList, fill=na.locf))
# write out merged data
write.zoo(x, "path.csv", sep=",")
-------------------------------------------------------------------------------------------------------
plot(NA, xlim=c(.5,5.5), ylim=c(min(df)-1,max(df)+1),
         xaxt="n", xlab="Year", ylab="Value")
axis(1,1:5,labels=gsub("X","",names(df)))
apply(df,1,function(x) if(sum(!x==0)>0) points((1:ncol(df))[!x==0],x[!x==0],type="b") )
-------------------------------------------------------------------------------------------------------
findInterval table library(fields)
library(akima)

x1 <- floor(runif(20) * 100)
y1 <- floor(runif(20) * 100)
z1 <- floor(runif(20) * 100)

# Corners of the cells, to count the observations
x0 <- seq(0,100,20)
y0 <- seq(0,100,20)

# Centers of the cells, for the interpolation
x00 <- x0[-length(x0)] + diff(x0) / 2
y00 <- y0[-length(y0)] + diff(y0) / 2

s <- interp(x1,y1,z1, xo=x00, yo=y00)
image.plot(x=x0, y=y0, z=s$z)

counts <- table( 
  findInterval(x1, x0),
  findInterval(y1, y0)
)
# Plot the observations, to check that I have not confused rows and columns
points( x1, y1 )
# Number of observations
text(x=x00[row(counts)], y=y00[col(counts)], labels=counts)
-------------------------------------------------------------------------------------------------------
xts period.apply endpoints sapply library(xts)
## creating the `xts` objects.
x.z <- xts(data$volts,
           as.POSIXct(strptime(data$time,format='%H:%M:%S')))

INDEX <- endpoints(x.z,'secs',30)
xx <- sapply(1:(length(INDEX) - 1), function(y) {
  x <- x.z[(INDEX[y] + 1):INDEX[y + 1]]
  data.frame(period=y,
             duration=diff(range(index(x))),
             mm = mean(x),
             len = length(x))
})


t(xx)
     period duration mm       len
[1,] 1      5        4        6  
[2,] 2      5        3.666667 6 endpoints ## creating xts object index
ii <- as.POSIXct(strptime(data$time,format='%H:%M:%S'))
## here I add  day to simulate day boundary
ii[6]  <- as.POSIXct(ii[6] + as.difftime(1,units='days')) x.z
                    [,1]
2013-07-31 04:01:50    2
2013-07-31 04:01:51    3
2013-07-31 04:01:52    4
2013-07-31 04:01:53    5
2013-07-31 04:01:54    5
2013-07-31 04:01:55    5
2013-07-31 23:59:55    2
2013-07-31 23:59:56    3
2013-07-31 23:59:57    4
2013-07-31 23:59:58    5
2013-07-31 23:59:59    6
2013-08-01 00:00:02    2   ## day boundaries here t(xx)
     period duration mm len
[1,] 1      5        4  6  
[2,] 2      4        4  5  
[3,] 3      0        2  1    ## 2013-08-01 00:00:02    2
-------------------------------------------------------------------------------------------------------
> print(data.frame(n=2:3, x=1:6))
- n x
1 2 1
2 3 2
3 2 3
4 3 4
5 2 5
6 3 6 > print(expand.grid(x=1:5, n=2:3))
-  x n
1  1 2
2  2 2
3  3 2
4  4 2
5  5 2
6  1 3
7  2 3
8  3 3
9  4 3
10 5 3 lapply(2:3, FUN=function(n) (f(n, x=1:5)))
#[[1]]
#[1] 0.0004981910 0.0006066275 0.0007328627 0.0008786344 0.0010456478
#
#[[2]]
#[1] 0.0007464956 0.0009087272 0.0010974595 0.0013152213 0.0015644676 wrapper <- function(i, x, n, fti){
    # As was provided by OP
    g<-function(x) {do.call(paste("d",i,sep=""),c(list(x=x),fti$estimate))}

    G<-function(x) {do.call(paste("p",i,sep=""),c(list(q=x),fti$estimate))}
    # does the i in fti refer to fit of i:th distribution, i.e. should it be a list where i:th location in ft is i:th distribution estimates?

    f<-function(n,x) {n*g(x)*(1-G(x))^(n-1)}
    # was missing a '-' and a '}'

    h<- function(n) {integrate(function(x) {x*f(n,x)},0,Inf)}

    list(gres = g(x), Gres = G(x), fres = f(n,x), hres = h(n))
}

# Example data
require("fitdistrplus")
data(groundbeef)
serving <- groundbeef$serving

# Gumbel distribution
d1 <- function(x, a, b) 1/b*exp((a-x)/b)*exp(-exp((a-x)/b))
p1 <- function(q, a, b) exp(-exp((a-q)/b))
q1 <- function(p, a, b) a-b*log(-log(p))

fti1 <- fitdist(serving, "1", start=list(a=10, b=10))
#> fti1$estimate
#       a        b 
#56.95893 29.07871

# Normal distribution

# dnorm, pnorm and qnorm are available in the default environment
d2 <- dnorm
p2 <- pnorm
q2 <- qnorm

fti2 <- fitdist(serving, "2", start=list(mean=0, sd=1))
#> fti2$estimate
#    mean       sd 
#73.67743 35.92581

# Sequence of x-values
xs <- seq(-100, 100, by=1)

print((resultdist1n2 <- wrapper(i=1, x=xs, n=2, fti=fti1))$hres)
print((resultdist1n3 <- wrapper(i=1, x=xs, n=3, fti=fti1))$hres)
print((resultdist2n2 <- wrapper(i=2, x=xs, n=2, fti=fti2))$hres)
print((resultdist2n3 <- wrapper(i=2, x=xs, n=3, fti=fti2))$hres)

plot(xs, resultdist1n2$fres, col=1, type="l", ylim=c(0,0.025), xlab="x", ylab="f(n, x)")
points(xs, resultdist1n3$fres, col=2, type="l")
points(xs, resultdist2n2$fres, col=3, type="l")
points(xs, resultdist2n3$fres, col=4, type="l")
legend("topleft", legend=c("Gamma (i=1) n=2", "Gamma (i=1) n=3", "Normal (i=2) n=2", "Normal (i=2) n=3"), col=1:4, lty=1) h(n=2) for distribution i=1:
53.59385 with absolute error < 0.00022
h(n=3) for distribution i=1:
45.23146 with absolute error < 4.5e-05
h(n=2) for distribution i=2:
53.93748 with absolute error < 1.1e-05
h(n=3) for distribution i=2:
44.06331 with absolute error < 2e-05 ns <- 0:256
res1 <- lapply(ns, FUN=function(nseq) wrapper(i=1, x=xs, n=nseq, fti=fti1))
par(mfrow=c(1,2))
plot.new()
plot.window(xlim=c(-100,100), ylim=c(0, 0.05))
box(); axis(1); axis(2); title(xlab="x", ylab="f(n,x)", main="f(n,x) for gamma (i=1), n=0:256")
for(i in 1:length(ns)) points(xs, res1[[i]]$fres, col=rainbow(257)[i], type="l")
# perform similarly for the other distributions by calling with i=2, fti=fti2
# h as a function of n for dist i=1
plot(ns, unlist(lapply(res1, FUN=function(x) x$hres$value)), col=rainbow(257), xlab="n", ylab="h(n)", main="h(n) for gamma (i=1), n=0:256")
-------------------------------------------------------------------------------------------------------
points() points(vare.dca, display = "sites", col = "red") text() orditorp() display = "sites" ?orditorp ordipointlabel()
-------------------------------------------------------------------------------------------------------
B <- 10
ind <- replicate(B,sample(seq(1:n),n,replace=TRUE))

#you need to pass a function to apply
bst.sample <- apply(ind,2, 
                function(i) lda(Species~Petal.Length+Petal.Width,data=Iris[i,]))
#extract means
bst.means <- lapply(bst.sample,function(x) x$means)

#bind means into array
library(abind)
bst.means <- do.call(function(...) abind(..., along=3), bst.means)

#you need to make sure that alle points are inside the axis limits
plot(bst.means[1,1,],bst.means[1,2,], 
     xlim=range(bst.means[,1,]), ylim=range(bst.means[,2,]), 
     xlab=dimnames(bst.means)[[2]][1],ylab=dimnames(bst.means)[[2]][2],
     col=1)
points(bst.means[2,1,],bst.means[2,2,], col=2)
points(bst.means[3,1,],bst.means[3,2,], col=3)
legend("topleft", legend=dimnames(bst.means)[[1]], col=1:3, pch=1)
-------------------------------------------------------------------------------------------------------
tapply(bikecounts$Northbound, as.Date(bikecounts$Date, format="%m/%d/%Y"), sum) split tapply(bikecounts$Northbound, month(mdy_hms(bikecounts$Date)), sum) as.Date split.xts period.apply xts endpoints endpoints x endpoints(x, "months") split.xts split(x, "months") split.xts() endpoints() xts endpoints() > split.xts(as.Date("1970-01-01") + 1:10, "weeks")
[[1]]
[1] "1970-01-02" "1970-01-03" "1970-01-04"

[[2]]
[1] "1970-01-05" "1970-01-06" "1970-01-07" "1970-01-08" "1970-01-09"
[6] "1970-01-10" "1970-01-11"

> endpoints(as.Date("1970-01-01") + 1:10, "weeks")
[1]  0  3 10 mdy_hms xts lubridate x <- xts(bikecounts[, -1], mdy_hms(bikecounts$Date))
period.apply(x, endpoints(x, "days"), sum)
apply.daily(x, sum) # identical to above xts period.sum period.sum(x, endpoints(x, "days"))
-------------------------------------------------------------------------------------------------------
plot(x=c(2,4,8),y=c(5,4,2),pch=16)
points(x=c(3,5),y=c(2,4),pch="+")
legend(7,4.5,pch=c(43,16),legend=c("A","B"))
-------------------------------------------------------------------------------------------------------
maraqa <- c(84.8,68.9,84.9,92.5)
aqua <- c(75,65.1,79.4,82.3)
mar <- c(84.7,68.3,84.5,77.4)

# combine data as matrix
mat<-cbind(maraqa, aqua, mar)
rownames(mat)<-c("A", "B", "C", "D")

#define colours
coll<-c("red", "blue", "black")

matplot(mat, type="l", ylim=c(60, 95), ylab="y TBA", main="TBA", xlab="x TBA", 
        axes=FALSE, frame.plot=FALSE, col=coll, lty=rep(1,3))
# axes= do you want standart axis or make your own?
# frame.plot= frame arround plot yes/no

matpoints(mat, pch=rep(17,3), col=coll, ad=TRUE)
# to add points, pch controlls for type of points

axis(side=1, 1:4, labels=rownames(mat))
axis(side=2, 60:95, labels=60:95)
legend("topleft",# position
       legend=c("maraqa", "aqua", "mar"),# names in legend,
       lty=c(1,1,1),# type of filling in this case solide line,
       col = coll,# colour of filling, 
       cex=0.7)# scaling parameter
-------------------------------------------------------------------------------------------------------
DF <- data.frame(Date=seq(from=as.POSIXct("2013-07-03 16:05:00", tz="GMT"),
                          to=as.POSIXct("2013-07-04 16:05:00", tz="GMT"),
                          by="5 min"),
                 Value1=1:289)

library(xts)
myTS <- zoo(DF[,2], DF[,1])

ep <- endpoints(myTS, "hours")
period.apply(myTS, INDEX=ep, FUN=mean)
-------------------------------------------------------------------------------------------------------
lm fit.temp$terms attr(,"term.labels")
[1] "ns(x, knots = seq(0.01, 2, by = 0.1))" predict x lm lm.predict df <- data.frame(x,y)
 # My n.s fit:
 fit.temp <- lm(y ~ ns(x, knots = seq(0.01, 2, by = 0.1)) , data=df)
 predict(fit.temp, newdata=list(x =c(0.275, 0.375, 0.475, 0.575, 1.345) )  )
#        1         2         3         4         5 
#0.9264572 1.6549046 2.0743470 1.9507962 0.8220687 
points(x.new, predict(fit.temp, newdata=list(x =c(0.275, 0.375, 0.475, 0.575, 1.345) )), 
       col="red", cex=2)
-------------------------------------------------------------------------------------------------------
require(MASS)
dens <- with(dat, MASS::kde2d(Age, Value))
str(dens)
#-------------
List of 3
 $ x: num [1:25] 1657 1671 1686 1700 1715 ...
 $ y: num [1:25] -0.267 -0.249 -0.232 -0.214 -0.197 ...
 $ z: num [1:25, 1:25] 0.00152 0.00187 0.00226 0.00267 0.00312 ...
#--------------
# kde2d is designed for contour display: x-vector, y-vector, z-Matrix
 contour(dens) points(dat$Age, dat$Value, cex=0.3, col="red")
-------------------------------------------------------------------------------------------------------
plot.default add > args(plot.default)
function (x, y = NULL, type = "p", xlim = NULL, ylim = NULL, 
    log = "", main = NULL, sub = NULL, xlab = NULL, ylab = NULL, 
    ann = par("ann"), axes = TRUE, frame.plot = axes, panel.first = NULL, 
    panel.last = NULL, asp = NA, ...) 
NULL plot add points() lines() plot add plot.default add plot.default points() lines() plot.default add
-------------------------------------------------------------------------------------------------------
exy <- predict(ellipsoidhull(d)) ## the ellipsoid boundary
me <- colMeans((exy))            ## center of the ellipse dist2center <- sqrt(rowSums((t(t(exy)-me))^2))
max(dist2center)     ## major axis
[1] 1.264351
> min(dist2center)   ## minor axis
[1] 0.1537401 plot(exy,type='l',asp=1)
points(d,col='blue')
points(me,col='red')
lines(rbind(me,exy[dist2center == min(dist2center),]))
lines(exy[dist2center == max(dist2center),])
-------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------
plot(NORM, TEE, ylim = c(-4, 5), main = "NORM and TEE plot") points(NORM[NORM^2 -1> TEE], TEE[ TEE + 1< NORM^2], col = "blue")
legend(legend = c("TEE > NORM^2 - 1 ", "TEE < NORM^2 - 1" ), col = c(1, 4), x = "topright", pch = 1) par(mfrow = c(1, 2))
plot(NORM, TEE, ylim = c(-4, 5), main = "NORM and TEE plot")
plot(NORM, TEE, ylim = c(-4, 5), main = "NORM and TEE plot")
points(NORM[NORM^2 -1> TEE], TEE[ TEE + 1< NORM^2], col = "blue") screen.split(2,2)
#[1] 1 2 3 4
screen(1) # what follows goes in slot (1,1)
hist(RandomNormal, seq(-3.2, 3.2, .2), prob = TRUE)
curve(dnorm(x), add = TRUE, col = "red");
screen(2) # what follows goes in slot (1,2);
boxplot(DATA.oner);
screen(3) # similarly for (2,1);
plot(NORM, TEE, ylim = c(-4, 5), main = "NORM and TEE plot");
screen(4) # similarly for (2,2);
plot(NORM, TEE, ylim = c(-4, 5), main = "NORM and TEE plot");
points(NORM[NORM^2 - 1 > TEE], TEE[TEE + 1 < NORM^2], col = "blue"); screen(1) # Watch the screen (1,1) go blank
boxplot(DATA.oner, main = "Box Plots of DATA.oner")

screen(2) # again for slot (1,2)
hist(RandomNormal, seq(-3.2, 3.2, .2), prob = TRUE)
curve(dnorm(x), add = TRUE, col = "red") split.screen(c(2,1)) # The screen is now split in two
# [1] 1 2
split.screen(c(1,2), screen = 2) # splits the second into 2
# [1] 3 4
screen(1) # note screen 2 is now refered to as 3 and 4
hist(RandomNormal, seq(-3.2, 3.2, .2), prob = TRUE)
curve(dnorm(x), add = TRUE, col = "red")
legend(legend = c("Theoretical N(0, 1)"), col = c(2, 3), x = "topright", lty = 1)

screen(3) # We call on screen 3 and 4, not 2
boxplot(DATA.oner, main = "Box Plot of DATA.oner")

screen(4)
plot(NORM, TEE, ylim = c(-4, 5), main = "NORM and TEE plot")
-------------------------------------------------------------------------------------------------------
?plotmath
?points # to which plotmath sends you for mapping of 'symbol' characters

# And I do not like the plotmath-paste function, 
# so translated to 'pure' expressions.
# The number arguments to symbol are numbers in octal.

plot(1, 1, pch = "")
text(1, 1.2, 
       expression(low ~italic(P)*"("*italic(p)~
                                   symbol("\332")~ italic(q)* 
                                  "), -1 SD"), 
       cex = 1.2)
text(1, 0.8, 
   expression(low~italic(P)* 
               "("*symbol("\330")*italic(p)~symbol("\331")~ italic(q)*
               "), -1 SD"),
    cex = 1.2 ) > as.octmode(216)
[1] "330"

TestChars <- function(sign = 1, font = 1, ...)
{
   MB <- l10n_info()$MBCS
   r <- if(font == 5) { sign <- 1; c(32:126, 160:254)
       } else if(MB) 32:126 else 32:255
   if (sign == -1) r <- c(32:126, 160:255)
   par(pty = "s")
   plot(c(-1,16), c(-1,16), type = "n", xlab = "", ylab = "",
        xaxs = "i", yaxs = "i",
        main = "Symbol Font, Decimal Indices")
   grid(17, 17, lty = 1) ; mtext(paste("MBCS:", MB))
   for(i in r) try(points(i%%16, i%/%16, pch = sign*i, font = font,...))

   for(i in r) try(text(x=i%%16, y=(i%/%16)-0.4, i, cex=0.5 , font = font,...))
}

TestChars(font = 5)
-------------------------------------------------------------------------------------------------------
dmat[dmat=="A"]<-0
dmat[dmat=="B"]<-1
dmat[is.na(dmat)]<-2
mycolors<-c('red','black','grey')
# initial plot area
plot(c(1,nrow(dmat)),c(1,ncol(dmat)),t='n')

for (i in 1:nrow(dmat)){
   for(j in 1:ncol(dmat)) {
       points(i,j,col=mycolors[dmat[i,j]])
       }
   }
-------------------------------------------------------------------------------------------------------
I() y <- rep(1,10)
for (i in 1:10) {
          if (i == 1) {
                    plot(y[i]~I(i-1),pch = 14,
                         ylim = c(0,2),
                         xlim=c(0,11))
          }
          else {points(y[i]~I(i-1), pch = 14)
          }
} ?I plot plot(i-1,y[i],...)
-------------------------------------------------------------------------------------------------------
x1<-replicate(300,rbinom(k,n,p1[1,])) 
x2<-replicate(300,rbinom(k,n,p1[2,])) k=1 rbinom(k,n,p1[1,]) p1[1,] rate1 rate2 p1 p1 x1<-replicate(300,rbinom(k,n,p1[1,])) 
x2<-replicate(300,rbinom(k,n,p1[2,]))

rate1<-x1/60  # Estimated p's
rate2<-x2/60
library(car)
plot.new()
ell <- dataEllipse(rate1, rate2, levels=c(0.05, 0.95), plot.points=T, pch=NA)
library(sp)
within<-point.in.polygon(p1[1,], p1[2,], ell$`0.95`[,1], ell$`0.95`[,2])
mean(within)  

plot(p1[1,which(within==1)], p1[2,which(within==1)], col="blue", ylim=c(0,1),xlim=c(0,1))
points(p1[1,which(within==0)], p1[2,which(within==0)], col="green")

ell <- dataEllipse(rate1, rate2, levels=c(0.05, 0.95), plot.points=T, pch=NA, add=T) x1<-rbinom(300,n,p1[1,])
x2<-rbinom(300,n,p1[2,])
rate1<-x1/60  # Estimated p's
rate2<-x2/60
library(car)
plot.new()
ell <- dataEllipse(rate1, rate2, levels=c(0.05, 0.95), plot.points=T, pch=NA)
library(sp)
within<-point.in.polygon(p1[1,], p1[2,], ell$`0.95`[,1], ell$`0.95`[,2])
mean(within)  

plot(p1[1,which(within==1)], p1[2,which(within==1)], col="blue", ylim=c(0,1),xlim=c(0,1))
points(p1[1,which(within==0)], p1[2,which(within==0)], col="green")
ell <- dataEllipse(rate1, rate2, levels=c(0.05, 0.95), plot.points=T, pch=NA, add=T)
-------------------------------------------------------------------------------------------------------
i_j i_{j-1} + 1, …, i_j 1:5 6:10 library(strucchange)
y <- c( rep(0,5), rep(1,5) )
breakpoints(Fstats(y ~ 1))
# ...
# Breakpoints at observation number:
# 5
-------------------------------------------------------------------------------------------------------
plyr Val_A<-dataframe[dataframe$Something=="A",]
Val_B<-dataframe[dataframe$Something=="B",]
Val_C<-dataframe[dataframe$Something=="C",] plot(Val_A$Date,Val_A$Values)
points(Val_B$Date,Val_B$Values,col='red')
points(Val_C$Date,Val_C$Values,col='green')
-------------------------------------------------------------------------------------------------------
barplot() bp <- barplot(y)
bp
     [,1]
[1,]  0.7
[2,]  1.9
[3,]  3.1
[4,]  4.3
[5,]  5.5 x plot(bp) y x 1,2,3,4,5 y bp <- barplot(y)
points(bp,c(10,20,30,40,50))
-------------------------------------------------------------------------------------------------------
plot ?plot.area plot(hr, colpol=c('red', 'blue', 'green',' brown') ) as.numeric colors() ?colors mcp 
points(xy[,1], xy[,2],col = c("red", "green", "blue", "orange", "sandybrown")[as.numeric(factor(dd[,"ID"]))])
-------------------------------------------------------------------------------------------------------
dat <- structure(list(x = c(1.6, 1.6, 4.4, 4.5, 6.1, 6.7, 7.3, 8, 9.5, 
9.5, 10.7), y = c(2.2, 4.5, 1.6, 4.3, NA, NA, 4.8, 7.3, 8.7, 6.3, 12.3)),
.Names = c("x", "y"), row.names = c(NA, -11L), class = "data.frame") plot(dat,type="o",pch=19) NA smoo <- with(dat[!is.na(dat$y),],smooth.spline(x,y)) y x y NA result <- with(dat,predict(smoo,x[is.na(y)]))
points(result,pch=19,col="red") dat[is.na(dat$y),] <- result
-------------------------------------------------------------------------------------------------------
my.symbols library(TeachingDemos)
ms.Cleveland <- function(num.pt = 1, cex=2, ...) {
    funs <- list(
        open = function(cex, ...) 
            points(0,0, pch=1, lwd=2, cex=cex, ...),
        filled = function(cex, ...)
            points(0,0, pch=16, cex=cex, ...),
        half = function(cex, ...)
            points(0,0, pch=1, lwd=5, cex=cex, ...),
        vert = function(cex, ...) {
            points(0,0, pch=1, lwd=2, cex=cex, ...)
            points(0,0, pch='|', lwd=2, cex=cex/2, ...)
          },
        dot = function(....) {
            points(0,0, pch=1, lwd=2, cex=cex, ...)
            points(0,0, pch=16, cex=cex/3, ...)
          }
    )
    funs[[num.pt]](cex, ...)
}

### create size variable for mtcars
sz <- findInterval( mtcars$wt, quantile( mtcars$wt, c(0.2, 0.4, 0.6, 0.8) ) ) + 1

with(mtcars, my.symbols(wt, mpg, ms.Cleveland, num.pt=sz, add=FALSE, 
    symb.plots=TRUE))
tmp <- legend('topright', pch=1, col=NA, pt.cex=2,
    legend=c('Small', 'SMed', 'Medium', 'LMed', 'Large'))

my.symbols( (tmp$rect$left + tmp$text$x)/2, tmp$text$y, ms.Cleveland, num.pt=1:5,
    symb.plots=TRUE) ms.Cleveland col=NA my.symbols
-------------------------------------------------------------------------------------------------------
d<-rnorm(30)
boxplot(d)
points(rep(1,length(d)),d)
-------------------------------------------------------------------------------------------------------
plot points() lines() text() NewDay <- gam (INI~s(day), family = gaussian, data = INI_New_Day)

plot(NewDay)
points(INI_New_Day3$day, INI_New_Day$INI)) plot new = TRUE points lines ?par new
-------------------------------------------------------------------------------------------------------
residues2 df1 <- data.frame(r1=seq(4), r2=rep(1,4),
                  c1=c(0.99613318, 0.98771518,  0.98681384, 0.99225447) )
### give order (for plotting)
df1 <- within(df1, c2 <- rank(c1))
### create blank plot
with(df1, plot(r1,r2, xlab="residues_1", ylab="residues_2", cex.lab=1.5))
### strongest red to largest color
with(df1, points(r1, r2, cex=15, pch=19, col = rev(heat.colors(4))[c2] ))
### make legend
l1 <- as.matrix(df1[ ,"c1"])
graphics::legend("topright", legend=l1, lty=1, title="covariance", lwd=3,
                 col = rev(heat.colors(4))[df1$c2], cex=2) .png
-------------------------------------------------------------------------------------------------------
persp() trans3d # data
arv = data.frame(axis_x = rnorm(n=300, mean=-0.20, sd=1.01),
             axis_y = rnorm(n=300, mean=-0.45, sd=0.97),
             elevation = rnorm(n=300, mean=-813.2, sd=13.89))
# fit             
model = lm(formula = elevation ~ (axis_x + axis_y)^2 + I(axis_x^2) + I(axis_y^2), data = arv)

# grid for plotting function
x <- seq(min(arv$axis_x), max(arv$axis_x), length.out = 20)
y <- seq(min(arv$axis_y), max(arv$axis_y), length.out = 20)

# function for predicted surface from model
f <- function(x, y) { cbind(1,x,y,x^2,y^2,x*y) %*% coef(model) }

# predicted values in form that persp() can use
z <- outer(x, y, f)

# 3d plot of surface with persp()
ele_3d <- persp(x=x,y=y,z=z, theta=40, phi=15, zlim=c(min(arv$elevation), max(arv$elevation)) )

# transform observed values into 2d space
elevation_points <- trans3d(arv$axis_x, arv$axis_y, arv$elevation, pmat=ele_3d)

# plot observed values
points(elevation_points)

# add dotted lines from surface to observed values
fit_vals <- trans3d(arv$axis_x, arv$axis_y, fitted(model), pmat = ele_3d)
segments(fit_vals$x, fit_vals$y, elevation_points$x, elevation_points$y, lty = 3) wireframe()
-------------------------------------------------------------------------------------------------------
d <- density(connectivity)
top10 <- sort(connectivity, decreasing=TRUE)[1:10]

# get the height of the density for each of the top10 nodes:
top10y <- sapply(top10, function(node) {
  diffs <- abs(node - d$x)
  yloc <- which(diffs == min(diffs))[1] # in case more than one match
  d$y[yloc]
})

# now plot
plot(d)
points(top10, top10y, col="red")
-------------------------------------------------------------------------------------------------------
> end = Sys.Date()
> start = end - 365

> class

> # create the index array comprised of date objects
> ndx = seq(start, end, by='weeks')
> class(ndx)
  [1] "Date"
> length(ndx)
  [1] 53

> # create a fake data array
> x = 1:length(ndx)
> mydata = sin(x/2)

> # import a time series library 
> require(xts)

> # create the time series
> myts = xts(mydata, order.by=ndx)

> myts[1:5]
               [,1]
  2012-09-19 3.479426
  2012-09-26 3.841471
  2012-10-03 3.997495
  2012-10-10 3.909297
  2012-10-17 3.598472

> class(myts)
  [1] "xts" "zoo"

> periodicity(myts)
  Weekly periodicity from 2012-09-19 to 2013-09-18 > ndx = seq(start, end, by='days')

> x = 1:length(ndx)
> mydata = sin(x/2) + 3
> myts = xts(mydata, order.by=ndx)

> myts[1:5]  
             [,1]
2012-09-19 3.479426
2012-09-20 3.841471
2012-09-21 3.997495
2012-09-22 3.909297
2012-09-23 3.598472

> periodicity(myts)
    Daily periodicity from 2012-09-19 to 2013-09-19 

> # now roll-up this daily series to weeks

> require(xts)

> # first create the endpoints
> np = endpoints(myts, on='weeks')


> myts_weeks = period.apply(x=myts, INDEX=np, FUN=sum, na.rm=TRUE)
> myts_weeks[1:5]
               [,1]
  2012-09-23 18.82616
  2012-09-30 17.11212
  2012-10-07 24.93492
  2012-10-14 17.51811
  2012-10-21 23.58635

> periodicity(myts_weeks)
  Weekly periodicity from 2012-09-23 to 2013-09-19
-------------------------------------------------------------------------------------------------------
legend plot( 0, type="n", xlim=c(0,5), ylim=c(0,5) )
A <- matrix( c( c(1,2,3,4), c(2,1,2,4)), ncol=2 )
B <- matrix( c( c(1,2,3,4), c(1,3,3,2)), ncol=2 )
lines( A, col="red" )
points( A, col="blue", pch=15 )
lines( B, col="green" )
points( B, col="purple", pch=17 )

legend( x="topleft", 
        legend=c("Red line, blue points","Green line, purple points"),
        col=c("red","green"), lwd=1, lty=c(1,2), 
        pch=c(NA,NA) )

legend( x="topleft", 
        legend=c("Red line, blue points","Green line, purple points"),
        col=c("blue","purple"), lwd=1, lty=c(0,0), 
        pch=c(15,17) ) legend legend( x="topleft", 
        legend=c("",""),
        col=c("blue","purple"), lwd=1, lty=c(0,0), 
        pch=c(15,17), bty='n' ) legend
-------------------------------------------------------------------------------------------------------
sample y <- sample(c(-1,1), 100, replace=TRUE)
plot(cumsum(y), type="s") plot(2^cumsum(y)*start_money, type="s", log="y", xlab="Round", ylab="Winnings") rle table(rle(y)$len) plot(table(rle(y)$len) / length(y))
points(1:15, dnbinom(1:15, 1, 0.5), col=2)
-------------------------------------------------------------------------------------------------------
points plot(a1)
points(a2, col=2)
points(a3, col=3) plot(1:length(a1), a1)
points(1:length(a2), a2, col=2)
points(1:length(a3), a3, col=3) plot(a1, xlim=c(1, max(length(a1), length(a2), length(a3))))
-------------------------------------------------------------------------------------------------------
matrices data<-do.call(rbind,matrices)
colors<-c(mapply(rep,1:length(matrices),sapply(matrices,nrow)),recursive=T)  
plot(data,col=colors) xrange<-range(sapply(matrices,function(x)x[,1]))
yrange<-range(sapply(matrices,function(x)x[,2]))
plot(0,xlim=xrange,ylim=yrange,type="n")
for(i in 1:length(matrices))
  points(matrices[[i]],col=i)
-------------------------------------------------------------------------------------------------------
C D E A <- rnorm(500)
B <- rnorm(500)

## Set the indices, as written in question
Ci <- c(1:10,20:30,60:75,90,100) ### to be coloured in blue
Di <- c(25:60)                   ### to be coloured in blue
Ei <- c(100:150,120:125)         ### to be coloured in red.

## Plot the original scatterplot, then plot over the points of interest with colour
## Use the "points" function from base graphics to plot points on existing plot
## Grab the relevant points from vectors A and B by accessing them at indices 
## Ci, Di, Ei using `[]`
plot(A, B, cex=0.5, col="grey")
points(A[Ci], B[Ci], cex=0.5, col="blue")
points(A[Di], B[Di], cex=0.5, col="blue")
points(A[Ei], B[Ei], cex=0.5, col="red")
-------------------------------------------------------------------------------------------------------
ggplot2 subset t<=Ti par(mfrow=c(2,2))
for (Ti in 1:4){  
    plot(x[t <= Ti], y[t <= Ti])
} points lines par(mfrow=c(4,1))
for (Ti in 1:4){  
  plot(x, y, type="n")
  points(x[t <= Ti], y[t <= Ti])
}
-------------------------------------------------------------------------------------------------------
plot(One, xlab = "Beta Values", ylab = "Frequency", col = "blue")
points(Two, col = 'green')
points(Three, col = 'red') plot points lines
-------------------------------------------------------------------------------------------------------
to.period .toPeriod endpoints(x, period, k) xx <- .Call("toPeriod", x, endpoints(x, period, k), has.Vo(x), 
        has.Vo(x, which = TRUE), has.Ad(x) && is.OHLC(x), 
        index_at, cnames, PACKAGE = "xts") endpoints > wednesdayRows<-which(as.POSIXlt(index(SPY))$wday==3)
> head(SPY[wednesdayRows,])
           SPY.Open SPY.High SPY.Low SPY.Close SPY.Volume SPY.Adjusted
2013-01-02   145.11   146.15  144.73    146.06  192059000       143.95
2013-01-09   145.87   146.32  145.64    145.92   90745600       143.81
2013-01-16   146.77   147.28  146.61    147.05  104849500       144.92
2013-01-23   149.13   149.50  148.86    149.37  104596100       147.21
2013-01-30   150.64   150.94  149.93    150.07  137447700       147.90
2013-02-06   150.52   151.26  150.41    151.16  138762800       148.97
-------------------------------------------------------------------------------------------------------
rJava x <- rbind(matrix(rnorm(100, sd = 0.3), ncol = 2),
           matrix(rnorm(100, mean = 1, sd = 0.3), ncol = 2))
colnames(x) <- c("x", "y")
(cl <- kmeans(x, 2))  ## you replace kmeans by your call to java function
plot(x, col = cl$cluster)
points(cl$centers, col = 1:2, pch = 8, cex = 2) kmeans library(rJava)
.jinit(PATH-TO_YOUR_CLASS_BIN_OR_JAR) # this starts the JVM
 ## I call a the Cluster constructor giving  it the imput data 
 ## Obvsiouly you should create this constructor
 javaCluster <- .jnew("Cluster",.jarray(x,dispatch=TRUE))
 ## call th clustering function which returns a vector of integers
 cl <- .jcall(javaCluster ,"[I",method="doClustering")
-------------------------------------------------------------------------------------------------------
library(MASS)
library(coda)
HPDregionplot(mcmc(data.matrix(df)), prob=0.8)
with(df, points(x,y))
-------------------------------------------------------------------------------------------------------
y <- dd$d1

# indices of pits and peaks
pit <- which(diff(sign(diff(y))) == 2) + 1
peak <- which(diff(sign(diff(y))) == -2) + 1

# distance between peak and pit -> length of increase
len_incr <- peak - pit

# index of first pit from which a consecutive increase in 20 'steps' starts
idx <- pit[(len_incr > 20) == TRUE][1]

# corresponding x-value
dd$d2[idx]
# [1] 489.4895    


# similar approach but let 'turnpoint' find pits and peaks.
library(pastecs)
tp <- turnpoints(y)
pit <- which(tp$pits == TRUE)
peak <- which(tp$peaks == TRUE)
len_incr <- peak - pit
idx <- pit[(len_incr > 20) == TRUE][1]
dd$d2[idx]
# [1] 489.4895
-------------------------------------------------------------------------------------------------------
filled.contour points plot.axes filled.contour(x,y,z, col=rev(heat.colors(n=20, alpha=0.7)), nlevels=15,
               plot.axes={points(0,0)})
-------------------------------------------------------------------------------------------------------
ksmooth plot(Height,Counts)
smoothCounts<-ksmooth(Height,Counts,kernel="normal",bandwidth=2)
dsmooth<-diff(smoothCounts$y)
locmax<-sign(c(0,dsmooth))>0 & sign(c(dsmooth,0))<0
lines(smoothCounts)
points(smoothCounts$x[locmax],smoothCounts$y[locmax],cex=3,c=2)
-------------------------------------------------------------------------------------------------------
library(rworldmap)
newmap <- getMap(resolution = "coarse") #'low' or even 'coarse' resolution map may be sufficient

#example data for 2 years 6 months each
month <- c(1:6,1:6)
year <- c(rep(2012,6),rep(2013,6))
lon <- c(120:131)
lat <- c(-35:-24)
p1 <- data.frame(month=month,year=year,lon=lon,lat=lat)

months <- unique(p1$month)
years <- unique(p1$year)

oldPar <- par(mar=c(2, 0, 0, 2)) #margins top,bottom,left,right

#use layout to create multiple panels including space at top for a title
nPanels <- layout( cbind(c(0,1:6),c(0,7:12))
                   , heights=c(lcm(1),rep(1,6))
                   , respect=F )


for( yrNum in 1:length(years) )
{
  yr <- years[yrNum]
  for( moNum in 1:length(months) )
  {
    mo <- months[moNum]

    cat(yr,mo,"\n")

    plot(newmap, xlim = c(110, 155), ylim = c(-35, -20), asp = 1)
    mtext( paste(yr,"month",mo), cex=0.7) #add titile to subplot

    pMoYr <- p1[ p1$year==yr & p1$month==mo, ]

    points(pMoYr$lon, pMoYr$lat, col = "red", cex = 3)
  }
}

mtext("rworldmap layout demo",outer=TRUE,line=-2)

par(oldPar)
-------------------------------------------------------------------------------------------------------
f which.min d <- cbind(x,y)[ z >= 1, ]
i <- which.min( apply(d, 1, f) )
points( d[i,,drop=FALSE], pch=3, cex=3 ) constrOptim
-------------------------------------------------------------------------------------------------------
graphicalBMI <- function(meter, kg, showPlot=TRUE){

  BMI <- kg/(meter^2)

  if(showPlot){
    x <- seq(1.5, 1.9, by = 0.001)
    y <- seq(30, 200, by = 0.5)

    # here we call graphicalBMI by setting showPlot=F to avoid infinite recursion
    z <- outer(x, y, FUN = function(x, y) {graphicalBMI(x, y, FALSE)})
    contour(x, y, z, nlevels = 10, method = "edge", main = "BMI")
    abline(h = kg, v= meter, col="darkgrey") 
    points(meter, kg, col="red", cex=2, pch=16, bg="red")
  }
  return(BMI)
}


# usage example:
graphicalBMI(1.8,70) # plot produced

graphicalBMI(1.8,70,FALSE) # no plot produced
-------------------------------------------------------------------------------------------------------
require(grid)
grid.newpage()
pushViewport(plotViewport(c(5, 5, 5 ,5)))
pushViewport(dataViewport(0:10, 0:10, extension=c(0,0)))
grid.points(1:10, 1:10, default.units='native')
grid.xaxis(at=0:10)
grid.yaxis(at=0:10) plot(1:10, 1:10, xaxs="i", yaxs="i", xlim=c(0,10), ylim=c(0,10))
-------------------------------------------------------------------------------------------------------
data(varespec)
data(varechem)

ord <- rda(varespec)

set.seed(1)
(fit <- envfit(ord, varechem, perm = 999))

## make up a fake `status`
status <- factor(rep(c("Class1","Class2"), times = nrow(varespec) / 2))

> head(status)
[1] Class1 Class2 Class1 Class2 Class1 Class2 layout(matrix(1:2, ncol = 2))
## auto version
plot(fit, add = FALSE)

## manual version with extra things
colvec <-  c("red","green")
scl <- -1
plot(ord, type = "n", scaling = scl)
points(ord, display = "sites", col = colvec[status], pch = (1:2)[status])
points(ord, display = "species", pch = "+")
plot(fit, add = TRUE, col = "black")
layout(1) envfit
-------------------------------------------------------------------------------------------------------
a = paste0("Starting portfolio value: $", prettyNum(1000000,big.mark=",",scientific=F))
b = "Inflation assumptions of 3% annually"
c = "Average annual returns: 6%"
d ="Average annual volatility: 7%"

pdf('out.pdf',width=5,height=5)
plot(NA, xlim=c(0,5), ylim=c(0,5), bty='n',
     xaxt='n', yaxt='n', xlab='', ylab='')
text(1,4,a, pos=4)
text(1,3,b, pos=4)
text(1,2,c, pos=4)
text(1,1,d, pos=4)
points(rep(1,4),1:4, pch=15)
dev.off()
-------------------------------------------------------------------------------------------------------
##Generate some data
heights = runif(15)
heights = heights/sum(heights)
dd = data.frame(heights, type=1:3)
m_heights = tapply(dd$heights, dd$type, mean) ##rep(0, 5) is used to pad
h = c(rep(0,5), heights[1:5], rep(0,5), heights[6:10], rep(0,5), heights[11:15])
barplot(m_heights, width=1, space=1,  ylim=c(0, max(dd$heights)), xlim=c(0, 6))
barplot(h, width=0.2,space=0,add=T,  col="white", border=NULL) plot(dd$type, dd$heights) points(1:3, m_heights, col=2, pch="X")
-------------------------------------------------------------------------------------------------------
points(20, q[21])
-------------------------------------------------------------------------------------------------------
pch=3 lwd plot(1:10,1:10,type="l")
points(1:10,rep(5,10),pch=3,lwd=5)
-------------------------------------------------------------------------------------------------------
dotPlot image identify dotPlot seq2 <- seq1 <- paste(sample(c("A","G","T","C"), 100, repl=TRUE), collapse="")
for ( i in sample(1:100, 20) ) { seq2 <- 
  paste0(substr(seq2, 1, i-1), "Z", substr(seq2, i+1, nchar(seq2) ) )}
plot(NA, xlim=c(0,100), ylim=c(0,100)); 
for ( i in 1:100 ) { 
           if(substr(seq1,i,i)==substr(seq2, i,i) ){ points(i,i)}
pts <- identify(1:100, 1:100, n=5)
-------------------------------------------------------------------------------------------------------
dnorminv<-function(y) sqrt(-2*log(sqrt(2*pi)*y))

plot(x, y)
points(dnorminv(y),y,pch=3)
-------------------------------------------------------------------------------------------------------
seq1 <- paste(sample(c("A","G","T","C"), 100, repl=TRUE), collapse="")
seq2 <- paste(sample(c("A","G","T","C"), 100, repl=TRUE), collapse="")

plot(NA, xlim=c(0,100), ylim=c(0,100),type="p"); 
for ( i in 1:100 ) 
    {  for ( j in 1:100 ) 
    {  if(substr(seq1,i,i)==substr(seq2, j,j) ) points(j,i)
       }}
pts <- identify(1:100, 1:100, n=5) l=100
seq1 <- paste(sample(c("A","G","T","C"), l, repl=TRUE)) 
seq2 <- paste(sample(c("A","G","T","C"), l, repl=TRUE)) 
plot(NA, xlim=c(0,100), ylim=c(0,100),type="p"); 
for (i in 1:l) for (j in i:l) if(seq1[i]==seq2[j]) points(j,i)
pts <- identify(1:100, 1:100, n=5)
-------------------------------------------------------------------------------------------------------
#your data
library(scatterplot3d)
x <- seq(-1,1,.1)
y <- seq(-1,1,.1)
z <- x^2 + y^2

ang = 60 #angle of the 3D plot. experiment with different values

#your 3D plot, with extended xx', yy' limits
sp3d <- scatterplot3d(x, y, z, pch=19, color="royalblue4", 
           xlim = c(-1, 3), ylim = c(-3, 3), angle = ang)

#to use parametric equations of circles
f <- seq(-2*pi, 2*pi, 0.1)

#circle1
sp3d$points(x = 1 + 1*cos(f), y = 1 + 1*sin(f), z = rep(0, length(f)), type = "l")
#circle2
sp3d$points(x = 1 + 1*cos(f), y = -1 + 1*sin(f), z = rep(0, length(f)), type = "l")
-------------------------------------------------------------------------------------------------------
actiontype$lastAction 'reset' actiontype$lastAction 'draw' else temp xval yval NULL input$coords input$coords input$coords NULL #server.R
library(shiny)
N = 30
x = sort(runif(N, 0, 10)); y = x + rnorm(N)
xval=NULL
yval=NULL
checker <- 1 #### CHANGE

shinyServer(function(input, output) {
get.coords <- reactive({
    data.frame(x=input$coords$x, y=input$coords$y)
})

actiontype <- reactiveValues()
actiontype$lastAction <- 'draw'

observe({
    if (input$reset != 0)
        actiontype$lastAction <- 'reset'
})
observe({
    if (input$closepolygon != 0)
        actiontype$lastAction <- 'closepolygon'
})

output$diagPlot = renderPlot({
    plot(x, y, xlim = range(x), ylim = range(y))
    grid()

    if (identical(actiontype$lastAction, 'reset')) {
        xval <<- NULL
        yval <<- NULL
        checker <<- 0 ####CHANGE
        actiontype$lastAction <- 'draw'

    } else if (identical(actiontype$lastAction, 'draw')){
        temp <- get.coords()
        xval <<- c(xval,temp$x)
        yval <<- c(yval,temp$y)

        ########### CHANGE...
        if(identical(checker, 0))
         {
           points(xval, yval, pch = 19, col = rgb(1,0,0,0), cex = 1.5)
           xval <<- NULL
           yval <<- NULL
           checker <<- 1
         }else
         {
          points(xval, yval, pch = 19, col = 'red', cex = 1.5)
         }
        ############# ...CHANGE

        for (i in 1:(length(xval)-1))
             lines(c(xval[i],xval[i+1]),c(yval[i],yval[i+1]),type="l",col="blue")
        if(identical(actiontype$lastAction, 'closepolygon'))
       lines(c(xval[1],xval[length(xval)]),c(yval[1],yval[length(yval)]),
              type="l",col="blue")
    }
}, width = 700, height = 600)
}) input$coords input$coords checker 1 0
-------------------------------------------------------------------------------------------------------
xgap <- ifelse(x > 8, x-6, x)
#Possibly you'd want to check if there are values between 2 and 8.
plot(xgap, y, col='blue', pch=16, xlab= 'x', ylab='y, z', xaxt="n")
points(xgap, z, col='red', pch=17)
xat <- pretty(xgap)
xat <- xat[xat!=2]
xlab <- ifelse(xat>2, xat+6, xat)
axis(1,at=xat, labels=xlab)
library(plotrix)
axis.break(1,2,style="slash") gap.plot
-------------------------------------------------------------------------------------------------------
data.table D <- data.table(d)
MaxDate <- D[, max(date)] + 10
MinDate <- D[, min(date)]
D2 <- D[, list( date, firstdate = min(date)), by = id]
D2[, plot(date, id, type='n', bty='n',axes=FALSE, xlab = "", ylab ="")]
D2[date!=firstdate, points(date, id, pch =4)]
D2[date==firstdate, points(date, id)]
D2[date==firstdate, arrows(x0=date, y0=as.numeric(id), x1=MaxDate, length=0.1)]
abline(v=MaxDate - 5)
abline(v=MinDate)
axis(side= 2, tick = FALSE, at=D[, unique(id)], labels=D[, paste0("ID = ",  as.character(unique(id)))], las=2)
axis(side = 1, tick= FALSE, at=c(MinDate, MaxDate), labels = strftime(c(MinDate, MaxDate),format="Week %W, %Y") )
-------------------------------------------------------------------------------------------------------
require(tseries)
# if you dont have above package, please install it
# it can be done by running following code
# install.packages('tseries')

########### function that simulates 100 times for hetro- 
test_gen=function(n,m){
  esp=0
  saved=0
  for(i in 1:m){   # simulate  100 times
    X=rnorm(n,25,1)
    for(j in 1:length(X)){
    eps[j]=rnorm(1,0,sqrt((X[j])^2)[1])
    }
    Y=1.5*X+eps

    temp=white.test(X,Y)

    saved[i]=temp$p.value
  }
  return(saved)
}

#red dots are the values less than 0.05
#n controls the size of sample
#m controls numbers of simulation
n=20
m=100
out=test_gen(n,m)
plot(c(1:length(out)),out,main="p-value(whitetest) for each simulated data") 
ind=out<0.05
points(c(1:length(out))[ind],out[ind],col='red',pch=16) out2=0
#simulate 100 times for each specific data size 
for(i in 20:100){
  k=i-19
  temp=test_gen(i,100)
  out2[k]=sum(temp<0.5)/100
}

plot(20:100,out2,main="error rate",xlab="sample size") # error rate
-------------------------------------------------------------------------------------------------------
library(plotrix)
library(MASS)

# create fake data
df <- data.frame(X=runif(1000, 0, 1000), Y=runif(1000, 0, 600))

# define the center and radii of the circles
center <- c(455, 351)
radii <- seq(112, 336, 112)

# calculate the distance to the center for each row of object df
distcenter <- apply(df[, c("X", "Y")], 1, function(rowi) dist(rbind(rowi, center)))
# assign each row of object df to a group based on distcenter
group <- cut(distcenter, c(-1, radii, 2*max(radii)), labels=FALSE)

# to ensure that circles are drawn in x,y coordinate space, you need to use the eqscplot() function from package MASS
eqscplot(0, 0, type="n", xlim=range(df$X, center[1]+c(-1, 1)*max(radii)), ylim=range(df$Y, center[2]+c(-1, 1)*max(radii)))
draw.circle(center[1], center[2], radii)
points(df$X, df$Y, col=group)

# to subset all of the rows of a given group, you can use something like this
df[group==2, ] draw.circle()
-------------------------------------------------------------------------------------------------------
period.apply.ohlc <- function(x,FUN= 'mean',INDEX=endpoints(x,"mins",k=1)){
  ll <- sapply(1:(length(INDEX) - 1), function(y) {
    xi <- x[(INDEX[y] + 1):INDEX[y + 1]]
    sapply(xi,FUN)
  })
  xts(t(ll),order.by=index(dat.xts[INDEX]))
}

period.apply.ohlc(dat.xts)
#                     price volume price_volume
# 2013-11-10 14:55:57 31.190    5.5      17154.5
# 2013-11-10 14:56:42 31.157   44.3     138151.5 dat.xts dat.xts <- read.zoo(text='time            price   volume  price_volume
14:56:42    31.15   173 540327
14:56:36    31.15   100 311500
14:56:27    31.16   4   12464
14:56:24    31.16   1   3116
14:56:21    31.16   46  143336
14:56:18    31.15   32  99680
14:56:15    31.16   6   18696
14:56:12    31.16   12  37392
14:56:06    31.16   15  46740
14:56:03    31.16   54  168264
14:55:57    31.19   1   3119
14:55:54    31.19   10  31190',tz="",index=1,format="%H:%M:%S",header=TRUE)
-------------------------------------------------------------------------------------------------------
dat.xts <- as.xts(dat.xts)   ## otherwise you get an error align.time 
                             ## since (dat.xts is a zoo object)
bars <- period.apply(dat.xts, 
                    endpoints(dat.xts,"secs",60),
                    function(xx){
                      ticks=coredata(xx$price)
                      c( first(ticks),max(ticks), min(ticks),
                         last(ticks), sum(xx$volume), sum(xx$price_volume) )
                    })
colnames(bars) <- c("Open","High","Low","Close","Volume","Price*Volume")
align.time(bars,60) period.apply() first max min last coredata Open  High   Low Close Volume Price*Volume
2013-11-11 14:56:00 31.19 31.19 31.19 31.19     11        34309
2013-11-11 14:57:00 31.16 31.16 31.15 31.15    443      1381515
-------------------------------------------------------------------------------------------------------
plot_one plot_one <- function(d){
  with(d, plot(Days, Count, t="n", tck=1, main=unique(d$ID), cex.main = 0.8, ylab = "", yaxt = 'n', xlab = "", xaxt="n",  xlim=c(0,1000), ylim=c(0,1200))) # set limits
  grid(lwd = 0.3, lty = 7)
  with(d[d$Treat == 0,], points(Days, Count, col = 1)) 
  with(d[d$Treat == 1,], points(Days, Count, col = 2))
  mod = lm(Count ~ Days, data = d[d$Treat == 0,])
  abline(reg = mod)
  text(x=500, y=800, mod$coefficients[2])
}
-------------------------------------------------------------------------------------------------------
plot(x,lty=2,lwd=2,col="red", ylim = c(min(x,y),max(x,y)))
points(y,lty=3,col="green")
-------------------------------------------------------------------------------------------------------
count.sp <- function(sample.vec, dataset){
   sample.presence <- dataset[sample.vec, grep("sp.", names(dataset))] != 0
   overall.presence <- apply(sample.presence, 2, sum) != 0
   n.species <- sum(overall.presence)
   return(n.species)
}

# Sampling effort = number of sample
plot(c(0, nrow(dataset) - 1), c(0, 1.5*length(grep("sp.", names(dataset)))), type="n",
     xlab="Sampling effort", ylab="Species richness")
for (i in 1:(nrow(dataset) - 1)){
    sample.vec <- sample(seq(along=dataset$Sample_ID), i)
    points(i, count.sp(sample.vec, dataset), pch=19, cex=0.5)
}

# Sampling effort = number of hooks
plot(c(0, sum(dataset$Nhooks)), c(0, 1.5*length(grep("sp.", names(dataset)))), type="n",
     xlab="Sampling effort", ylab="Species richness")
for (i in 1:(nrow(dataset) - 1)){
    sample.vec <- sample(seq(along=dataset$Sample_ID), i)
    points(sum(dataset$Nhooks[sample.vec]), count.sp(sample.vec, dataset), pch=19, cex=0.5)
}
-------------------------------------------------------------------------------------------------------
x <- log(seq(1,11,1))
y <- seq(0,1,0.1)

# set the margins and 'xpd' allows to plot outside the range
par(mar=c(5,5,5,7), xpd=T)

# plot the data within the range
plot(x,y, type="l", col="blue", frame=F, xlim=c(0,2.5))
points(x[3],y[3], col="blue", pch=3, cex=2)

# add the outlier by specifying the coordinate x and/or y outside the range
points(2.9, 1, col='blue', pch=20, cex=2)
-------------------------------------------------------------------------------------------------------
scatter_fill <- function (x, y, z,xlim=c(min(x),max(x)),ylim=c(min(y),max(y)),zlim=c(min(z),max(z)),
                          nlevels = 20, plot.title, plot.axes, 
                          key.title, key.axes, asp = NA, xaxs = "i", 
                          yaxs = "i", las = 1, 
                          axes = TRUE, frame.plot = axes, ...) 
{
  mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar
  on.exit(par(par.orig))
  w <- (3 + mar.orig[2L]) * par("csi") * 2.54
  layout(matrix(c(2, 1), ncol = 2L), widths = c(1, lcm(w)))
  par(las = las)
  mar <- mar.orig
  mar[4L] <- mar[2L]
  mar[2L] <- 1
  par(mar = mar)

# choose colors to interpolate
levels <- seq(zlim[1],zlim[2],length.out = nlevels)
col <- colorRampPalette(c("red","yellow","dark green"))(nlevels)  
colz <- col[cut(z,nlevels)]  
#   
plot.new()
plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i", yaxs = "i")

rect(0, levels[-length(levels)], 1, levels[-1L],col=col,border=col) 
if (missing(key.axes)) {if (axes){axis(4)}}
       else key.axes
   box()
   if (!missing(key.title)) 
     key.title
   mar <- mar.orig
   mar[4L] <- 1
   par(mar = mar)

   # points
   plot(x,y,type = "n",xaxt='n',yaxt='n',xlab="",ylab="",xlim=xlim,ylim=ylim,bty="n")
   points(x,y,col = colz,xaxt='n',yaxt='n',xlab="",ylab="",bty="n",...)

   ## options to make mapping more customizable

        if (missing(plot.axes)) {
          if (axes) {
            title(main = "", xlab = "", ylab = "")
            Axis(x, side = 1)
            Axis(y, side = 2)
          }
        }
        else plot.axes
        if (frame.plot) 
          box()
        if (missing(plot.title)) 
          title(...)
        else plot.title
        invisible()
 } # random vectors
vx <- rnorm(40,0,1)
vy <- rnorm(40,0,1)
vz <- rnorm(40,10,10)

scatter_fill(vx,vy,vz,nlevels=15,xlim=c(-1,1),ylim=c(-1,5),zlim=c(-10,10),main="TEST",pch=".",cex=8)
-------------------------------------------------------------------------------------------------------
text library(MASS)
ldaobject <- lda(Species~., data=iris)
plot(ldaobject, 
     panel = function(x, y, ...) {
       points(x, y, ...)
       text(x,y,labels=seq_along(x),...) ## You change labels here 
      }
      ,
     col = as.integer(iris$Species), pch = 20)
-------------------------------------------------------------------------------------------------------
plot(spa, asp = 1, type = "n", main = "Brown trout", 
     xlab = "x coordinate (km)", ylab = "y coordinate (km)")
lines(spa, col="light blue")
points(spa, col = "brown", cex = spe$TRU)
points(spa, col = "green", cex = spe$OMB)
legend("topright", legend = c("Brown Trout", "Grayling"),
       col = c("brown","green"), pch = 1, bty = "n") points() lines() points()
-------------------------------------------------------------------------------------------------------
plot_robots <- function(rob1, rob2){
  plot(1, xlim = c(-20, 20), ylim =c(-20, 20), type = "n", xaxs = "i", yaxs = "i")
  abline(h =-20:20, v = -20:20)
  points(c(rob1[1], rob2[1]), c(rob2[2], rob2[2]), pch = 21, cex = 2, bg = c("red", "blue"))
}

rob1 <- c(0, 0)
rob2 <- c(10, 0)

plot_robots(rob1, rob2)

for(i in 1:15000){
 rob1 <- rob1 + sample(list(c(0, 1), c(1, 0), c(-1, 0), c(0, -1)), 1)[[1]]
 rob2 <- rob2 + sample(list(c(0, 1), c(1, 0), c(-1, 0), c(0, -1)), 1)[[1]]
 plot_robots(rob1, rob2)
 Sys.sleep(.1)
}
-------------------------------------------------------------------------------------------------------
stkhat splancs > require(splancs)
> xyt=matrix(runif(3000),ncol=3)
> poly=bboxx(spoints(c(0,1,0,1)))
> tlim=c(0,1)
> s=seq(0,.3,len=51)[-1]
> t=s
> stk = stkhat(xyt[,1:2], xyt[,3], poly, tlim, s,t)
> image(str$kst)
> require(lattice)
> image(x=stk$s, y=stk$t,z = stk$kst)
-------------------------------------------------------------------------------------------------------
data(iris)
require(vegan)

# PCA
iris_c <- scale(iris[ ,1:4])
pca <- rda(iris_c)

# plot
plot(pca, type = 'n', display = 'sites')
cols <- c('red', 'blue', 'green')
points(pca, display='sites', col = cols[iris$Species], pch = 16)
ordihull(pca, groups=iris$Species)
ordispider(pca, groups = iris$Species, label = TRUE)

# PerMANOVA - partitioning the euclidean distance matrix by species
adonis(iris_c ~ Species, data = iris, method='eu')
-------------------------------------------------------------------------------------------------------
dfP <- data.frame(Pareto_n=1:10,Pareto_z=1:10) lines points plot(dfP$Pareto_n,dfP$Pareto_z,xlim=c(1,max(dfP$Pareto_n)),
  ylim=c(min(dfP$Pareto_z),max(dfP$Pareto_z)),xlab="n",ylab="z(n)",type="n")

lines(dfP$Pareto_n,dfP$Pareto_z,lwd=2,col="blue")
points(dfP$Pareto_n,dfP$Pareto_z,lwd=2,pch=23,col="red",bg="red")
-------------------------------------------------------------------------------------------------------
import numpy as np
def ppoints(n, a):
    """ numpy analogue or `R`'s `ppoints` function
        see details at http://stat.ethz.ch/R-manual/R-patched/library/stats/html/ppoints.html 
        :param n: array type or number"""
    try:
        n = np.float(len(n))
    except TypeError:
        n = np.float(n)
    return (np.arange(n) + 1 - a)/(n + 1 - 2*a) >>> ppoints(5, 1./2)
array([ 0.1,  0.3,  0.5,  0.7,  0.9])
>>> ppoints(5, 1./4)
array([ 0.13636364,  0.31818182,  0.5       ,  0.68181818,  0.86363636])
>>> n = 10
>>> a = 3./8. if n <= 10 else 1./2
>>> ppoints(n, a)
array([ 0.06097561,  0.15853659,  0.25609756,  0.35365854,  0.45121951,
        0.54878049,  0.64634146,  0.74390244,  0.84146341,  0.93902439])
-------------------------------------------------------------------------------------------------------
set.seed(10)
dat <- data.frame(A = rnorm(20), B = rnorm(20), C = rnorm(20)) # create a QQ-plot of B as a function of A
qqplot(dat$A, dat$B, xlim = range(dat), ylim = range(dat), 
       xlab = "A", ylab = "B/C")
# create a diagonal line
abline(a = 0, b = 1)
# add the points of C
points(sort(dat$A), sort(dat$C), col = "red")
# create a legend
legend("bottomright", legend = c("B", "C"), pch = 1, col = c("black", "red"))
-------------------------------------------------------------------------------------------------------
max <- c(175523.9, 33026.97, 21823.36, 12607.78, 9577.648, 9474.148, 4553.296, 3876.221, 2646.405, 2295.504)
min <- c(175523.9, 33026.97, 13098.45, 5246.146, 3251.847, 2282.869, 1695.64, 1204.969, 852.1595, 653.7845)
w <- c(175523.947, 33026.971, 21823.364, 5246.146, 3354.839, 2767.610, 2748.689,   1593.822, 1101.469, 1850.013) plot(1:10,max,type='b',xlab='Number',ylab='groups',col=3)
points(1:10,min,type='b', col=2)
points(1:10,w,type='b',col=1) ggplot2 # ggplot likes a long table, rather than a wide one, so reshape the data, and add the 'time' variable explicitly (ie. my_time = 1:10)
require(reshape2)
df <- melt(data.frame(max, min, w, my_time = 1:10), id.var = 'my_time')

# now plot, with some minor customisations...
require(ggplot2); require(scales)
ggplot(df, aes(colour = variable, x = my_time, y = value)) +
  geom_point(size = 3) +
  geom_line() +
  scale_y_continuous(labels = comma) +
  theme_minimal() library(cluster)
require(ggplot2)
require(scales)
require(reshape2)

data(ruspini)
x <- as.matrix(ruspini[-1])

wss <- NULL
W=matrix(data=NA,ncol=10,nrow=100)

for(j in 1:100){
  k=10  
  for(i in 1: k){
    wss[i]=kmeans(x,i)$tot.withinss    
  }
  W[j,]=as.matrix(wss)
}

max_Wmk <- matrix(data=NA, nrow=1,ncol=10)

for(i in 1:10){
  max_Wmk[,i]=max(W[,i],na.rm=TRUE)
}

min_Wmk <- matrix(data=NA, nrow=1,ncol=10)
for(i in 1:10){
  min_Wmk[,i]=min(W[,i],na.rm=TRUE)
}

w <- matrix(W[4,]) max_Wmk <- as.numeric(max_Wmk)
min_Wmk <- as.numeric(min_Wmk)
w <- as.numeric(w) df <- melt(data.frame(max_Wmk, min_Wmk, w, my_time = 1:10), id.var = 'my_time')

ggplot(df, aes(colour = variable, x = my_time, y = value)) +
  geom_point(size = 3) +
  geom_line() +
  scale_y_continuous(labels = comma) +
  theme_minimal()
-------------------------------------------------------------------------------------------------------
sim.res <- sim.geometric(100)
sim.rgeom <- rgeom(100, 0.3)
qqplot(sim.res, sim.rgeom) png("QQ.png")
qqplot(qgeom(ppoints(100),prob=0.3), sim.res,
       main = expression("Q-Q plot for" ~~ {G}[n == 100]))
dev.off() sim.res <- sim.geometric(500)
qqplot(jitter(qgeom(ppoints(500),prob=0.3)), jitter(sim.res),
       main = expression("Q-Q plot for" ~~ {G}[n == 100]), ylim=c(0,max( qgeom(ppoints(500),prob=0.3),sim.res )),
xlim=c(0,max( qgeom(ppoints(500),prob=0.3),sim.res )))
 qqline(sim.res, distribution = function(p) qgeom(p, 0.3),
       prob = c(0.25, 0.75), col = "red")
-------------------------------------------------------------------------------------------------------
# gen data
x <- 1:30
y <- 1:30
hello <- matrix(0:1, nrow=30, ncol=30)

# make basic plot of hello matrix
image(  1:ncol(hello), 1:nrow(hello), 
        t(hello), col=ifelse(t(hello)==1,"yellow","white"),
        ylab="rows",xlab="columns"      )
box()

# now let's decide whether or not a coordinate should be plotted, 
# depending on the value of hello for this coordinate ...
# by cycling through each pair of coordinates and saving T/F in iffer
iffer <- NULL
for(i in seq_along(x)) iffer <- c( iffer, hello[ y[i] , x[i] ]==1 )

# plotting of the adequate subset of points that had a hello value of 1 
points( x[iffer] , y[iffer], col="green")
-------------------------------------------------------------------------------------------------------
getpoint<-function(obs,exp){
  ceiling(max(obs,exp))
}
df$nextpoint<-apply(df,1,FUN=function(x)getpoint(x["OBSERVED"],x["EXPECTED"]))
require(plyr) # for count function
count(df$nextpoint) # note e.g. nextpoint = 4 means points below 4,4

x freq
1 1 9000
2 2  900
3 3   90
4 4    9
5 6    1 lobs lexp df<-df[df$OBSERVED<df$EXPECTED,] #data frame with p-value column labeled p-vals)
PVAL<-runif(10000)
pvals<-as.data.frame(PVAL)

#sort the p-values in PVAL and take the negative log
observed <- sort(pvals$PVAL)
lobs <- -(log10(observed))

#generate expected pvalue vector
expected <- c(1:length(observed))
lexp <- -(log10(expected / (length(expected)+1)))

#generate QQ plot
#plot red reference line and observed vs expected pvalues
plot(c(0,7), c(0,7), col="red", lwd=3, type="l", xlab="Expected (-logP)", ylab="Observed (-logP)", xlim=c(0,7), ylim=c(0,7), las=1, xaxs="i", yaxs="i", bty="l")
points(lexp, lobs, pch=23, cex=.4, bg="black") 

###########################################################
### DATA FRAME CREATED AND PLOTTED HERE                 ###
###########################################################

df<-data.frame(PVAL=PVAL)
df$OBSERVED<-lobs
df$EXPECTED<-lexp
df$RED_REFERENCE_LINE_Y<-df$EXPECTED

plot(c(df$RED_REFERENCE_LINE_Y,7), c(df$RED_REFERENCE_LINE_Y,7), col="red", lwd=3, type="l", xlab="Expected (-logP)", ylab="Observed (-logP)", xlim=c(0,7), ylim=c(0,7), las=1, xaxs="i", yaxs="i", bty="l")
points(df$EXPECTED, df$OBSERVED, pch=23, cex=.4, bg="black")
-------------------------------------------------------------------------------------------------------
G.fit <- goodfit(x, type = "nbinomial", par = list(size = 1)) sim.geometric <- function(nvals)
{
    p <- 0.3
    u <- runif(nvals)
    ceiling(log(u)/log(1-p))
} png("QQ.png")
qqplot(qgeom(ppoints(100),prob=0.3), sim.res,
       main = expression("Q-Q plot for" ~~ {G}[n == 100]))
dev.off() sim.res <- sim.geometric(500)
qqplot(jitter(qgeom(ppoints(500),prob=0.3)), jitter(sim.res),
       main = expression("Q-Q plot for" ~~ {G}[n == 100]), ylim=c(0,max( qgeom(ppoints(500),prob=0.3),sim.res )),
xlim=c(0,max( qgeom(ppoints(500),prob=0.3),sim.res )))
 qqline(sim.res, distribution = function(p) qgeom(p, 0.3),
       prob = c(0.25, 0.75), col = "red")
-------------------------------------------------------------------------------------------------------
k > sink("mykmeans.R")
> kmeans
> sink() > source("mykmeans.R")
> start.kmeans <- proc.time()[3]
> ans.kmeans <- mykmeans(x, 4, nstart = 3, iter.max = 10, algorithm = "Lloyd")
JJJ statement 1: 0 elapsed time.
JJJ statement 5: 2.424 elapsed time.
JJJ statement 6: 2.425 elapsed time.
JJJ statement 7: 2.52 elapsed time.
JJJ statement 6: 2.52 elapsed time.
JJJ statement 7: 2.563 elapsed time. #######################################################################
# kmeans()

N <- 100000
x <- matrix(0, N, 2)
x[seq(1,N,by=4),] <- rnorm(N/2)
x[seq(2,N,by=4),] <- rnorm(N/2, 3, 1)
x[seq(3,N,by=4),] <- rnorm(N/2, -3, 1)
x[seq(4,N,by=4),1] <- rnorm(N/4, 2, 1)
x[seq(4,N,by=4),2] <- rnorm(N/4, -2.5, 1)
start.kmeans <- proc.time()[3]
ans.kmeans <- kmeans(x, 4, nstart=3, iter.max=10, algorithm="Lloyd")
ans.kmeans$centers
end.kmeans <- proc.time()[3]
end.kmeans - start.kmeans

these <- sample(1:nrow(x), 10000)
plot(x[these,1], x[these,2], pch=".")
points(ans.kmeans$centers, pch=19, cex=2, col=1:4)

library(foreach)
library(doMC)
registerDoMC(3)
start.kmeans <- proc.time()[3]
ans.kmeans.par <- foreach(i=1:3) %dopar% {
  return(kmeans(x, 4, nstart=1, iter.max=10, algorithm="Lloyd"))
}
TSS <- sapply(ans.kmeans.par, function(a) return(sum(a$withinss)))
ans.kmeans.par <- ans.kmeans.par[[which.min(TSS)]]
ans.kmeans.par$centers
end.kmeans <- proc.time()[3]
end.kmeans - start.kmeans

sink("mykmeans.Rfake")
kmeans
sink()

source("mykmeans.R")
start.kmeans <- proc.time()[3]
ans.kmeans <- mykmeans(x, 4, nstart=3, iter.max=10, algorithm="Lloyd")
ans.kmeans$centers
end.kmeans <- proc.time()[3]
end.kmeans - start.kmeans

#######################################################################
# Diving

x <- read.csv("Diving2000.csv", header=TRUE, as.is=TRUE)
library(YaleToolkit)
whatis(x)

x[1:14,c(3,6:9)]

meancol <- function(scores) {
  temp <- matrix(scores, length(scores)/7, ncol=7)
  means <- apply(temp, 1, mean)
  ans <- rep(means,7)
  return(ans)
}
x$panelmean <- meancol(x$JScore)

x[1:14,c(3,6:9,11)]

meancol <- function(scores) {
  browser()
  temp <- matrix(scores, length(scores)/7, ncol=7)
  means <- apply(temp, 1, mean)
  ans <- rep(means,7)
  return(ans)
}

x$panelmean <- meancol(x$JScore) Number of cases: 10,787 scores from 1,541 dives (7 judges score each
dive) performed in four events at the 2000 Olympic Games in Sydney,
Australia.

Number of variables: 10.

Description: A full description and analysis is available in an
article in The American Statistician (publication details to be
announced).

Variables:

Event       Four events, men's and women's 3M and 10m.
Round       Preliminary, semifinal, and final rounds.
Diver       The name of the diver.
Country     The country of the diver.
Rank        The final rank of the diver in the event.
DiveNo      The number of the dive in sequence within round.
Difficulty  The degree of difficulty of the dive.
JScore      The score provided for the judge on this dive.
Judge       The name of the judge.
JCountry    The country of the judge.
-------------------------------------------------------------------------------------------------------
endpoints which.i=TRUE y <- x*NA                   # pre-allocate result
ep <- endpoints(x,"weeks")  # time points where parameters change

set.seed(1.23456789)
for(i in seq_along(ep)[-(1:2)]) {
  rng1 <- ep[i-1]:ep[i]          # obs to calc weights
  rng2 <- ep[i-2]:ep[i]          # "prime" obs
  wgts <- calc_weights(x[rng1])
  # calc smooth_days on rng2, but only keep rng1 results
  y[rng1] <- smooth_days(x[rng2], wgts)[index(x[rng1])]
}
-------------------------------------------------------------------------------------------------------
period.apply ROC Test <- period.apply(AAPL, endpoints(AAPL,on="weeks",k=10),
  function(x) log(last(x)/coredata(first(x))))
-------------------------------------------------------------------------------------------------------
# Set a seed to get a reproducible example
set.seed(12345)

num.points <- 100

# Create some data
x.vals <- 1:num.points
values <- rnorm(n=num.points, mean=0, sd=10)

# Plot the graph
plot(x.vals, values, t="o", pch=20, xlab="", ylab="", las=1)
abline(h=0, col="darkgray", lwd=2)

# We need to find the intersections of the curve with the x axis
# Those lie between positive and negative points
# When the sign changes the product between subsequent elements
# will be negative
crossings <- values[-length(values)] * values[-1]
crossings <- which(crossings < 0)

# You can draw the points to check (uncomment following line)
# points(x.vals[crossings], values[crossings], col="red", pch="X")

# We now find the exact intersections using a proportion
# See? Those high school geometry problems finally come in handy
intersections <- NULL
for (cr in crossings)
  {
  new.int <- cr + abs(values[cr])/(abs(values[cr])+abs(values[cr+1]))
  intersections <- c(intersections, new.int)
  }

# Again, let's check the intersections
# points(intersections, rep(0, length(intersections)), pch=20, col="red", cex=0.7)

last.intersection <- 0
for (i in intersections)
  {
  ids <- which(x.vals<=i & x.vals>last.intersection)
  poly.x <- c(last.intersection, x.vals[ids], i)
  poly.y <- c(0, values[ids], 0)
  if (max(poly.y) > 0)
    {
    col="green"
    }
  else
    {
    col="red"
    }
  polygon(x=poly.x, y=poly.y, col=col)

  last.intersection <- i
  }
-------------------------------------------------------------------------------------------------------
x1 x2 set.seed(1)
x1=rnorm(100,0,1)
x2=rnorm(100,1,1)
# Find points where x1 is above x2.
above<-x1>x2
# Points always intersect when above=TRUE, then FALSE or reverse
intersect.points<-which(diff(above)!=0)
# Find the slopes for each line segment.
x1.slopes<-x1[intersect.points+1]-x1[intersect.points]
x2.slopes<-x2[intersect.points+1]-x2[intersect.points]
# Find the intersection for each segment.
x.points<-intersect.points + ((x2[intersect.points] - x1[intersect.points]) / (x1.slopes-x2.slopes))
y.points<-x1[intersect.points] + (x1.slopes*(x.points-intersect.points))
# Plot.
plot(x1,type='l')
lines(x2,type='l',col='red')
points(x.points,y.points,col='blue')
-------------------------------------------------------------------------------------------------------
panel cl <- kmeans(iris[1:4],3)
idx <- subset(expand.grid(x=1:4,y=1:4),x!=y)
i <- 1
pairs(iris[1:4],bg=cl$cluster,pch=21,
            panel=function(x, y,bg, ...) {
                points(x, y, pch=21,bg=bg)
                points(cl$center[,idx[i,'x']],cl$center[,idx[i,'y']],cex=4,pch=10,col='blue')
                i <<- i +1
            }) lattice splom library(lattice)
splom(iris[1:4],groups=cl$cluster,pch=21,
            panel=function(x, y,i,j,groups, ...) {
                panel.points(x, y, pch=21,col=groups)
                panel.points(cl$center[,j],cl$center[,i],pch=10,col='blue')
            },auto.key=TRUE)
-------------------------------------------------------------------------------------------------------
p <- ggplot(data=newdat, mapping=aes(x=v0, y=dv280, colour=treatment)) +
  geom_point() +
  geom_smooth(data=nd, method='lm', se=TRUE) +
  scale_colour_discrete(guide=guide_legend(title.position='left', title.hjust=1)) newdat geom_points(...) nd geom_smooth(...) nd nd p <- ggplot(data=nd, mapping=aes(x=v0, y=dv280, colour=treatment)) +
  geom_point() +
  geom_smooth(data=nd, method='lm', se=TRUE) +
  scale_colour_discrete(guide=guide_legend(title.position='left', title.hjust=1)) nd se=0 nd lm geom_smooth(...) lm dv280 > 5 p <- ggplot(data=newdat, mapping=aes(x=v0, y=dv280, colour=treatment)) +
  geom_point() +
  geom_smooth(data=subset(newdat,dv280>5), method='lm', se=TRUE) +
  scale_colour_discrete(guide=guide_legend(title.position='left', title.hjust=1)) lme model dat$dv280 dat newdat$dv280 v0 treatment cse nd$dv280 v0 treatment cse=0 nd$dv280 v0 treatment ggplot dat$dv280 cse
-------------------------------------------------------------------------------------------------------
hxb<-hexbin(x=c(-15,-15,75,75),
            y=c(-15,-15,75,75),
            xbins=12)

hxb@xcm    #gives the x co-ordinates of each hex tile
hxb@ycm    #gives the y co-ordinates of each hex tile
hxb@count  #gives the cell size for each hex tile

points(x=hxb@xcm, y=hxb@ycm, pch=hxb@count)
-------------------------------------------------------------------------------------------------------
par(mfcol=c(ncol(obs),1))
for(i in 1:ncol(obs)){
    plot(t,obs[,i],pch=19)
    points(t,mod[,i])
    } par mfg ?par
-------------------------------------------------------------------------------------------------------
predict library("flexclust")
data("Nclus")

set.seed(1)
dat <- as.data.frame(Nclus)
ind <- sample(nrow(dat), 50)

dat[["train"]] <- TRUE
dat[["train"]][ind] <- FALSE

cl1 = kcca(dat[dat[["train"]]==TRUE, 1:2], k=4, kccaFamily("kmeans"))
cl1    
#
# call:
# kcca(x = dat[dat[["train"]] == TRUE, 1:2], k = 4)
#
# cluster sizes:
#
#  1   2   3   4 
#130 181  98  91 

pred_train <- predict(cl1)
pred_test <- predict(cl1, newdata=dat[dat[["train"]]==FALSE, 1:2])

image(cl1)
points(dat[dat[["train"]]==TRUE, 1:2], col=pred_train, pch=19, cex=0.3)
points(dat[dat[["train"]]==FALSE, 1:2], col=pred_test, pch=22, bg="orange") stats::kmeans cluster::pam kcca as.kcca(cl, data=x)
# kcca object of family ‘kmeans’ 
#
# call:
# as.kcca(object = cl, data = x)
#
# cluster sizes:
#
#  1  2 
#  50 50
-------------------------------------------------------------------------------------------------------
require(vegan)
data(dune)
data(dune.env)

mds <- cmdscale(vegdist(dune, method='bray'))


# set colors and shapes
cols = c('red', 'blue', 'black', 'steelblue')
shps = c(15, 16, 17)
# empty plot
plot(mds, type = 'n')
# add points
points(mds, col = cols[dune.env$Management], pch = shps[dune.env$Use])
# add legend
legend('topright', col=cols, legend=levels(dune.env$Management), pch = 16, cex = 0.7)
legend('bottomright', legend=levels(dune.env$Use), pch = shps, cex = 0.7) > levels(dune.env$Management)
[1] "BF" "HF" "NM" "SF" cols[dune.env$Management] cols
-------------------------------------------------------------------------------------------------------
scaling normalizing norm.fun = function(x){ 
  (x - min(x))/(max(x) - min(x)) 
}

require(ggplot2) # load mpg dataset
require(neuralnet)

data = mpg[, c('cty', 'displ', 'year', 'cyl', 'hwy')]
data.norm = apply(data, 2, norm.fun)

net = neuralnet(cty ~ displ + year + cyl + hwy, data.norm, hidden = 2) # restore data 
y.net = min(data[, 'cty']) + net$net.result[[1]] * range(data[, 'cty'])
plot(data[, 'cty'], col = 'red')
points(y.net) data.scaled = scale(data)
net = neuralnet(cty ~ displ + year + cyl + hwy, data.scaled, hidden = 2)

# restore data 
y.sd = sd(data[, 'cty'])
y.mean = mean(data[, 'cty'])

y.net = net$net.result[[1]] * y.sd + y.mean
plot(data[, 'cty'], col = 'red')
points(y.net) require(nnet)

data2 = mpg
data2$year = scale(data2$year)
fit = nnet(cty ~ displ + year + cyl + hwy, size = 10, data = data2, linout = TRUE)
plot(mpg$cty)
points(fit$fitted.values, col = 'red')
-------------------------------------------------------------------------------------------------------
df$YM <- as.Date(paste0("01",df$YearMonth), format="%d%Y%m")
rangeYM <- range(df$YM)

plot(NA,ylim=c(-1,1),xlim=rangeYM,ann=FALSE,axes=FALSE)
abline(h=0,lwd=2,col="#5B7FA3")

ypts <- rep_len(c(-1,1), length.out=nrow(df))
txtpts <- rep_len(c(1,3), length.out=nrow(df))
segments(df$YM,0,df$YM,ypts,col="gray80")

axis.Date(
 1,
 at=seq.Date(rangeYM[1],rangeYM[2],by="month"),
 format="%Y-%m",
 cex.axis=0.6,
 pos=0,
 lwd=0,
 lwd.tick=2,
 col="#5B7FA3",
 font=2
)

points(df$YM,y=ypts, pch="-", cex=1.5, col="#5B7FA3")
par(xpd=NA)
text(
  df$YM, y=ypts,
  labels=paste(df$Person1,df$Person2,df$Event,sep="\n"), cex=0.7, pos=txtpts
)
par(xpd=FALSE)
-------------------------------------------------------------------------------------------------------
set.seed(1234)
x= sample(1:100,50)
y= sample(1:100,50)
M=cbind(x,y)
plot(M) which arr.ind DM= as.matrix(dist(M))
neighbors=which(DM < 5, arr.ind=T)
neighbors= neighbors[neighbors[,1]!=neighbors[,2]] points(M[neighbors,], col="red" )
-------------------------------------------------------------------------------------------------------
x <- seq(0,10,by=2)
y <- seq(0, 30, by=10)
grid <- expand.grid(x, y)
N <- 100
points <- cbind(runif(N, 0, 10), runif(N, 0, 30))

plot(grid, t="n", xaxs="i", yaxs="i")
points(points, col="blue", pch="+") 
abline(v=x, h=y)

binxy <- data.frame(x=findInterval(points[,1], x),
                    y=findInterval(points[,2], y))

(results <- table(binxy))
d <- as.data.frame.table(results)
xx <- x[-length(x)] + 0.5*diff(x)
d$x <- xx[d$x]
yy <- y[-length(y)] + 0.5*diff(y)
d$y <- yy[d$y]
with(d, text(x, y, label=Freq))
-------------------------------------------------------------------------------------------------------
myplot() myPlot <- function(myTitle="Fig. 1. The effect of anomalous levels of sea surface temperature on coral bleaching") {
  plot(temp.a~Response,data=sst.brazil.bleach,pch=15, col="red", ylim=c(0,6),xlim=c(0,30), 
       main=mytitle,
       xlab="Bleaching response index",ylab=" Total annual sea surface temperature anomalies\n(°C)") 
  points(temp.a~Response,data=sst.seychelles.bleach,pch=16, col="blue") 
  points(temp.a~Response,data=sst.indo.bleach,pch=17, col="orange") 
  legend("bottomright", bty= "n", c("Brazil","Seychelles","Indonesia"),
         col=c('red', 'blue', 'orange'),
         pch=c(15,16,17))
}

myplot()
myPlot("I want another title for this one") myplot.r source("myplot.r")
-------------------------------------------------------------------------------------------------------
animation points library(animation)
saveGIF({
  ani.options(interval = 0.2, nmax = 10)
  t = seq(0,2*pi,.01)
  x = cos(2*t)*(cos(t)^2)
  y = sin(2*t)*(sin(t)^2)
  idx = seq(1,length(x),10)
  for (i in seq_along(idx)) {
    plot(x,y,type='n')
    points(x[seq(idx[i])],y[seq(idx[i])],pch=20,col='red')
    ani.pause()  ## pause for a while ('interval')
  }
}, interval = 0.05, movie.name = "comet_demo.gif", 
        outdir = "/usr/temp",ani.width = 600, ani.height = 600)
-------------------------------------------------------------------------------------------------------
<<- par(mfrow=c(3,3),pty="s")             # a 3 by 3 graphic
set.seed(1001)
x <- 1:10                             # with 1 to 54 along the x axis
dims <- c(10,6,3,2)
y <- array(rexp(prod(dims)), dim=c(10,6,3,2)) # and the y axis coming 
ymax <- c(1,0.1,0.3)

lapply(1:3, function(counter, arr) {
  apply(
    arr[ ,counter + 2, , ], 2, 
    function(ii) {
      plot(x, ii[,1], col="blue", ylim=c(0,ymax[counter]))
      points(x, ii[,2], col="red") 
    } )
  },
  arr=y
)
-------------------------------------------------------------------------------------------------------
base points lines barplot plot par(mar=c(5,5,2,3)+0.1)
ratio<-9e6/0.14
bar.col<-'#558ED5'
vencido.col<-'#77933C'
castigos.col<-'#FE0F0F'
b<-barplot(Data$'Monto Otorgado acumulado',names.arg=Data$Month,col=bar.col,border=FALSE,main='My Plot',ylim=c(0,9e6),axes=FALSE)
lines(b,Data$'% Vencida' * ratio, col=vencido.col,lwd=2) 
points(b,Data$'% Vencida' * ratio, col=vencido.col,bg='white',pch=21) 
lines(b,Data$'% Castigos' * ratio, col=castigos.col,lwd=2)
points(b,Data$'% Castigos' * ratio, col=castigos.col,bg='white',pch=21)
left.axis.pos<-seq(0,9e6,by=1e6)
axis(2,at=left.axis.pos,labels=formatC(left.axis.pos, big.mark = ",", format = "d"),las=2)
right.axis.ticks<-0:14
axis(4,at=(right.axis.ticks/100)*ratio,labels=paste0(right.axis.ticks,'%'),las=2)
legend('topleft',legend=c('Monto Otorgado acumulado','% Vencido','% Castigos'),col=c(bar.col,vencido.col,castigos.col),lty=1,lwd=c(4,2,2),bty='n')
par(mar=c(5,4,2,2)+0.1)
-------------------------------------------------------------------------------------------------------
bcea BCEA evi.plot k evi > evi.plot
function (he) 
{
    options(scipen = 10)
    plot(he$k, he$evi, t = "l", xlab = "Willingness to pay", 
        ylab = "EVPI", main = "Expected Value of Information")
    if (length(he$kstar) > 0) {
        points(rep(he$kstar, 3), c(-10000, he$evi[he$k == he$kstar]/2, 
            he$evi[he$k == he$kstar]), t = "l", lty = 2, col = "dark grey")
        points(c(-10000, he$kstar/2, he$kstar), rep(he$evi[he$k == 
            he$kstar], 3), t = "l", lty = 2, col = "dark grey")
    }
}
<environment: namespace:BCEA> res <- cbind(m$k, m$evi)
write.table(res, file="bcea.csv", sep=',', row.names=FALSE, col.names=FALSE )
-------------------------------------------------------------------------------------------------------
N      <- 1000
D      <- 1
path.1 <- matrix(NA,N,2)
path.2 <- matrix(NA,N,2)
path.1[1,] <- c(40,40)
path.2[1,] <- c(50,50)
set.seed(1)
system.time({
for (i in 2:N){
  path.1[i,] <- path.1[i-1,] + sample(-D:D,2)
  path.2[i,] <- path.2[i-1,] + sample(-D:D,2)
  cross <- sapply(2:i,function(k){seg.intersect(path.2[(k-1):k,],path.1[(i-1):i,])})
  if (any(cross)) break
  cross <- sapply(2:i,function(k){seg.intersect(path.1[(k-1):k,],path.2[(i-1):i,])})
  if (any(cross)) break
}
})
#    user  system elapsed 
#  296.25    0.00  296.83 
plot(0:70,0:70, type="n", xlab="X", ylab="Y")
points(path.1[1,1],path.1[1,2], pch=16, col="red", cex=1.5)
points(path.2[1,1],path.2[1,2], pch=16, col="green", cex=1.5)
lines(path.1[1:i,])
lines(path.2[1:i,],col="red") i 2*(i-1) k 2*k*(k+1) k ~O(10000) seg.intersect(...) seg.intersect <- function(l1,l2){
  is.between <- function(x,vec) {  # test if x is between values in vec
    return(x>=range(vec)[1] & x<=range(vec)[2])
  }
  get.line <- function(l) {        # returns slope and intercept 
    if (diff(l)[1]==0) return(c(Inf,NA))
    m <- diff(l)[2]/diff(l)[1]
    b <- l[1,2]-m*l[1,1]
    return(c(m,b))
  }
  special.cases = function(l1,l2) {
    pts   <- list(l1,l2)
    coeff <- do.call(rbind,lapply(pts,get.line))
    # points coincide: not a line segment!
    if (rowSums(diff(l1)^2)==0 | rowSums(diff(l2)^2)==0) return(c(NA,FALSE))
    # both lines vertical
    if (is.infinite(coeff[1,1]) & is.infinite(coeff[2,1])) {
      if (l1[1,1]!=l2[1,1]) return(c(NA,FALSE))
      t1 <- is.between(l1[1,2],l2[,2]) | is.between(l1[2,2],l2[,2])
      t2 <- is.between(l2[1,2],l1[,2]) | is.between(l2[2,2],l1[,2])
      return(c(NA,t1|t2))
    }
    # only l1 is vertical
    if (is.infinite(coeff[1,1]) & is.finite(coeff[2,1])) {
      x <- l1[1,1]
      y <- c(x,1) %*% coeff[2,]
      return(c(x,y))
    }
    # only l2 is vertical
    if (is.finite(coeff[1,1]) & is.infinite(coeff[2,1])) {
      x <- l2[1,1]
      y <- c(x,1) %*% coeff[1,]
      return(c(x,y))
    }
    # parallel, non-coincident lines
    if (diff(coeff[,1])==0 & diff(coeff[,2])!=0) return(c(NA,FALSE))
    # parallel, coincident lines
    if (diff(coeff[,1])==0 & diff(coeff[,2])==0) {
      x <- l1[1,1]
      y <- l1[1,2]
      return(c(x,y))
    }
    # base case: finite slopes, not parallel
    x <- -diff(coeff[,2])/diff(coeff[,1])
    y <- c(x,1) %*% coeff[1,]
    return(c(x,y))   
  }
  z <- special.cases(l1,l2)
  if (is.na(z[1])) return (z[2])
#  print(coeff)
#  print(z)
  found <- do.call("&",lapply(pts,function(x){is.between(z[1],x[,1]) & is.between(z[2],x[,2])}))
  return(found)
}
-------------------------------------------------------------------------------------------------------
