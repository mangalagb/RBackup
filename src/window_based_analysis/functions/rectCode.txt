x <- seq(as.POSIXct("1949-01-01", tz="GMT"), length=36, by="months")
y <- rnorm(length(x))

plot(x, y, type="l", xaxt="n")
rect(xleft=as.POSIXct("1950-01-01", tz="GMT"),
     xright=as.POSIXct("1950-12-01", tz="GMT"),
     ybottom=-4, ytop=4, col="#123456A0") # use alpha value in col
idx <- seq(1, length(x), by=6)
axis(side=1, at=x[idx], labels=format(x[idx], "%Y-%m")) plot(x, y, type="n", xaxt="n")
rect(xleft=as.POSIXct("1950-01-01", tz="GMT"),
     xright=as.POSIXct("1950-12-01", tz="GMT"),
     ybottom=-4, ytop=4, col="lightblue")
lines(x, y)
idx <- seq(1, length(x), by=6)
axis(side=1, at=x[idx], labels=format(x[idx], "%Y-%m"))
box()
-------------------------------------------------------------------------------------------------------
## create a long monthly sequence and a sub-sequence
months <- seq( as.Date("1950-01-01"), as.Date("2009-12-12"), by="month")
subset <- seq( as.Date("1970-01-01"), as.Date("1979-12-31"), by="month")

## generate some random values
set.seed(42)
values <- cumsum(rnorm(length(months)))

## plot as a zoo object, overlay a gray background and overplot a line in red
library(zoo)
Z <- zoo(values, months)
plot(Z)
rect(xleft=head(subset,1), xright=tail(subset,1),
     ybottom=par("usr")[3], ytop=par("usr")[4],
     density=NA, col="lightgray")
lines(Z[subset], col='red')
box() par("usr") zoo
-------------------------------------------------------------------------------------------------------
p + opts(legend.background = theme_rect(col = 0))
-------------------------------------------------------------------------------------------------------
Week = c(rep(1:8,4))
Total = rnorm(32,1000,600)
Alarm = c(  rep("BELTWEIGHER HIGH HIGH",8), 
        rep("MICROWAVE LHS",8),
        rep("HI PRESS FILTER 2 CLOG SW",8),
        rep("LOW PRESS FILTER 2 CLOG SW",8))        )
spark <- data.frame(Week, Alarm, Total)

s <- ggplot(spark, aes(Week, Total)) +         
     opts(
        panel.background = theme_rect(size = 1, colour = "lightgray"),
        panel.grid.major = theme_blank(),
        panel.grid.minor = theme_blank(),
        axis.line = theme_blank(),
        axis.text.x = theme_blank(),
        axis.text.y = theme_blank(),
        axis.title.x = theme_blank(),
        axis.title.y = theme_blank(), 
        axis.ticks = theme_blank(),
        strip.background = theme_blank(),
        strip.text.y = theme_blank()
        #strip.text.y = theme_text(size = 7, colour = "red", angle = 90)
    )

s + facet_grid(Alarm ~.) + geom_line()
-------------------------------------------------------------------------------------------------------
polycirc min max require(pgirmess)
circle <- polycirc(20, c(10, 20))
plot(circle, type = "l")
rect(min(circle[,1]), min(circle[,2]), max(circle[,1]), max(circle[,2]))
-------------------------------------------------------------------------------------------------------
dark geom_rect(data = dark.subset, aes(xmin = phase_start, xmax = phase_end), 
              ymin = -Inf,
              xmax = Inf,
              fill = alpha("#000000", 0.2)) light dark ggplot(...)+
  geom_rect(...)+
  geom_area(...)
-------------------------------------------------------------------------------------------------------
fft plotFFT getFFTFreqs plotFFT # Gets the frequencies returned by the FFT function
getFFTFreqs <- function(Nyq.Freq, data)
    {
    if ((length(data) %% 2) == 1) # Odd number of samples
        {
        FFTFreqs <- c(seq(0, Nyq.Freq, length.out=(length(data)+1)/2), 
               seq(-Nyq.Freq, 0, length.out=(length(data)-1)/2))
        }
    else # Even number
        {
        FFTFreqs <- c(seq(0, Nyq.Freq, length.out=length(data)/2), 
               seq(-Nyq.Freq, 0, length.out=length(data)/2))
        }

    return (FFTFreqs)
    }

# FFT plot
# Params:
# x,y -> the data for which we want to plot the FFT 
# samplingFreq -> the sampling frequency
# shadeNyq -> if true the region in [0;Nyquist frequency] will be shaded
# showPeriod -> if true the period will be shown on the top
# Returns a list with:
# freq -> the frequencies
# FFT -> the FFT values
# modFFT -> the modulus of the FFT
plotFFT <- function(x, y, samplingFreq, shadeNyq=TRUE, showPeriod = TRUE)
    {
    Nyq.Freq <- samplingFreq/2
    FFTFreqs <- getFFTFreqs(Nyq.Freq, y)

    FFT <- fft(y)
    modFFT <- Mod(FFT)
    FFTdata <- cbind(FFTFreqs, modFFT)
    plot(FFTdata[1:nrow(FFTdata)/2,], t="l", pch=20, lwd=2, cex=0.8, main="",
        xlab="Frequency (Hz)", ylab="Power")
    if (showPeriod == TRUE)
        {
        # Period axis on top        
        a <- axis(3, lty=0, labels=FALSE)
        axis(3, cex.axis=0.6, labels=format(1/a, digits=2), at=a)
        }
    if (shadeNyq == TRUE)
        {
        # Gray out lower frequencies
        rect(0, 0, 2/max(x), max(FFTdata[,2])*2, col="gray", density=30)
        }

    ret <- list("freq"=FFTFreqs, "FFT"=FFT, "modFFT"=modFFT)
    return (ret)
    } # A sum of 3 sine waves + noise
x <- seq(0, 8*pi, 0.01)
sine <- sin(2*pi*5*x) + 0.5 * sin(2*pi*12*x) + 0.1*sin(2*pi*20*x) + 1.5*runif(length(x))
par(mfrow=c(2,1))
plot(x, sine, "l")
res <- plotFFT(x, sine, 100) linearChirp <- function(fr=0.01, k=0.01, len=100, samplingFreq=100)
    {
    x <- seq(0, len, 1/samplingFreq)
    chirp <- sin(2*pi*(fr+k/2*x)*x) 

    ret <- list("x"=x, "y"=chirp)
    return(ret)
    }

chirp <- linearChirp(1, .02, 100, 500)
par(mfrow=c(2,1))
plot(chirp, t="l")
res <- plotFFT(chirp$x, chirp$y, 500, xlim=c(0, 4))
-------------------------------------------------------------------------------------------------------
filled.contour plot.axes filled.contour(x = seq(from=-1.5,to=1.5,length=20),
      y = seq(from=1,to=3.75,length=25), z = mypredict,
      col = hsv(h=seq(from=2/3,to=0,length=20),s=1,v=1),
      plot.axes = {axis(1); axis(2); rect(left, bottom, right, top);}) lines rect
-------------------------------------------------------------------------------------------------------
aes aes aes_string aes_now <- function(...) {
  structure(list(...),  class = "uneval")
} bottom <- bottom + geom_rect(aes_now(xmin=lims[1], xmax=lims[2]),
 ymin=-Inf, ymax=Inf, fill="grey80", alpha=0.01)
-------------------------------------------------------------------------------------------------------
computeHotspots = function(xyz, thresh, minsize=1, margin=1){
### given a list(x,y,z), return a data frame where each row
### is a (xmin,xmax,ymin,ymax) of bounding box of a contiguous area
### over the given threshhold.
### or approximately. lets use the clustering tools in R...

  overs <- which(xyz$z>thresh,arr.ind=T)

  if(length(overs)==0){
    ## found no hotspots
    return(NULL)
  }

  if(length(overs)==2){
    ## found one hotspot
    xRange <- cbind(xyz$x[overs[,1]],xyz$x[overs[,1]])
    yRange <- cbind(xyz$y[overs[,2]],xyz$y[overs[,2]])
  }else{

    oTree <- hclust(dist(overs),method="single")
    oCut <- cutree(oTree,h=10)

    oXYc <- data.frame(x=xyz$x[overs[,1]],y=xyz$y[overs[,2]],oCut)

    xRange <- do.call("rbind",tapply(oXYc[,1],oCut,range))
    yRange <- do.call("rbind",tapply(oXYc[,2],oCut,range))

  }

### add user-margins
 xRange[,1] <- xRange[,1]-margin
 xRange[,2] <- xRange[,2]+margin
 yRange[,1] <- yRange[,1]-margin
 yRange[,2] <- yRange[,2]+margin

## put it all together
 xr <- apply(xRange,1,diff)
 xm <- apply(xRange,1,mean)
 xRange[xr<minsize,1] <- xm[xr<minsize]-(minsize/2)
 xRange[xr<minsize,2] <- xm[xr<minsize]+(minsize/2)

 yr <- apply(yRange,1,diff)
 ym <- apply(yRange,1,mean)
 yRange[yr<minsize,1] <- ym[yr<minsize]-(minsize/2)
 yRange[yr<minsize,2] <- ym[yr<minsize]+(minsize/2)

  cbind(xRange,yRange)

} x=1:23
y=7:34
m1=list(x=x,y=y,z=outer(x,y,function(x,y){sin(x/3)*cos(y/3)}))
image(m1)
hs = computeHotspots(m1,0.95) > hs
  [,1] [,2] [,3] [,4]
1   13   15    8   11
2    3    6   17   20
3   22   24   18   20
4   13   16   27   30 image(m1)
rect(hs[,1],hs[,3],hs[,2],hs[,4]) image(list(x=m1$x,y=m1$y,z=m1$z>0.95))
rect(hs[,1],hs[,3],hs[,2],hs[,4])
-------------------------------------------------------------------------------------------------------
bigmacprice <- data.frame(
    country = c("Switzerland", "Brazil", "Euro area",
        "Canada", "Japan", "United States",
        "Britain", "Singapore", "South Korea",
        "South Africa", "Mexico", "Thailand",
        "Russia", "Malaysia", "China"),
    price = c(6.78, 5.26, 4.79, 4.18, 3.91, 3.71,
              3.63, 3.46, 3.03, 2.79, 2.58, 2.44,
              2.39, 2.25, 2.18)
)


plotbigmac <- function(mac, base = "United States", xlim = c(-40, 100)) {
    mac <- mac[order(mac$price),]
    base = which(mac$country == base)
    height <- (mac$price / mac[base, "price"] - 1) * 100
    par(bg = "#d0e0e7", col.main = "#262324", col.axis = "#393E46",
        mar = c(8, 8, 6, 6), las = 1)
    barplot(height, width = .1, space = .4,
        names.arg = mac$country, #cex.names = .8,
        col = "#01516c", border = "#7199a8", # border = "#577784",
        horiz = TRUE, xlim = c(-40, 100), axes = FALSE)
    axis(3, lty = 0)
    title(main = "Bunfight\nBig Mac index", col = "#393E46")

    abline(v = seq(-100, 100, 10), col = "white", lwd = 2)
    abline(v = 0, col = "#c8454e", lwd = 2)
    par(xpd = TRUE)
    for (i in 1:nrow(mac)) {
        rect(105, (i - 1) / 7, 118, i / 7 - 0.05,
        col = "white", border = "#7199a8")
        text(112, (i - 1) / 7 + 0.05, mac$price[i], cex = 0.8, col = "#393E46")
    }
    rect(-120, 2.5, -90, 3, col = "#c8454e", border = "#c8454e")
    text(-68, -.2, "Sources:", col = "#393E46")
    text(-64, -.3, "McDonald's;", col = "#393E46")
    text(-60, -.4, "The Economist", col = "#393E46")
}

plotbigmac(bigmacprice) barplot barplot plotBigMac <- function(mac, base = "United States") {
    old.par <- par(no.readonly = TRUE)
    on.exit(par(old.par))
    # Create data:
    mac <- mac[order(mac$price),]
    base = which(mac$country == base)
    height <- (mac$price / mac[base, "price"] - 1) * 100
    # Costume 'barplot'
    NN <- length(height)
    width <- rep(1, length.out = NN)
    delta <- width / 2
    w.r <- cumsum(width + 0.5)
    w.m <- w.r - delta
    w.l <- w.m - delta
    xlim <- c(range(-.01 * height, height)[1], 100)
    ylim <- c(min(w.l), max(w.r))
    par(bg = "#d0e0e7", col.main = "#262324", col.axis = "#393E46",
        mar = c(8, 8, 6, 6), las = 1, cex = 0.9)
    plot.new()
    plot.window(xlim, ylim)
    abline(v = seq(-100, 100, 20), col = "white", lwd = 2)
    rect(0, w.l, height, w.r, col = "#01516c", border = "#7199a8", lwd = 1)

    # Lines and axis
    abline(v = 0, col = "#c8454e", lwd = 2)
    axis(3, axTicks(3), abs(axTicks(3)), lty = 0)
    axis(2, labels = mac$country, at = w.m, lty = 0)

    # Move outside of plot area
    par(xpd = TRUE)

    # Text misc.
    text(5, (w.l[base] + w.r[base]) / 2, "nil", font = 3)
    text(8, w.r[NN] + 2.3, "+")
    text(-8, w.r[NN] + 2.3, "-")

    # Create price boxes:
    rect(105, w.l, 125, w.r,col = "white", border = "#7199a8", lwd = 1)
    text(115, (w.r + w.l)/2, mac$price, cex = 0.8, col = "#393E46")

}
-------------------------------------------------------------------------------------------------------
theme_min = function (size=10, font=NA, face='plain', 
    panelColor=backgroundColor, axisColor='#999999', 
    gridColor=gridLinesColor, textColor='black') 
{
    theme_text = function(...)
        ggplot2::theme_text(family=font, face=face, colour=textColor, 
            size=size, ...)

opts(
    axis.text.x = theme_text(),
    axis.text.y = theme_text(),
    axis.line = theme_blank(),
    axis.ticks = theme_segment(colour=axisColor, size=0.25),
    panel.border = theme_rect(colour=backgroundColor),
    legend.background = theme_blank(),
    legend.key = theme_blank(),
    legend.key.size = unit(1.5, 'lines'),
    legend.text = theme_text(hjust=0),
    legend.title = theme_text(hjust=0),
    panel.background = theme_rect(fill=panelColor, colour=NA),
    panel.grid.major = theme_line(colour=gridColor, size=0.33),
    panel.grid.minor = theme_blank(),
    strip.background = theme_rect(fill=NA, colour=NA),
    strip.text.x = theme_text(hjust=0),
    strip.text.y = theme_text(angle=-90),
    plot.title = theme_text(hjust=0),
    plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), 'lines'))
}

##Create a custom font type. Could be 'F', 'TEST', whatever
windowsFonts(F = windowsFont('Wide Latin'))

##and insert this line of code into the original code I list above: 
+ theme_min(font='F', size=10) grid.gedit("GRID.text",gp=gpar(fontfamily="F"))
-------------------------------------------------------------------------------------------------------
plot(), lines(), abline(), points(), polygon(), segments(), rect(), box(), arrows(), ... set.seed(100)
x <- 1:10
y <- x^2
y2 <- x^3
yse <- abs(runif(10,2,4))

plot(x,y, type = "n")  # type="n" only plots the pane, no curves or points.

# plots the area between both curves
polygon(c(x,sort(x,decreasing=T)),c(y,sort(y2,decreasing=T)),col="grey")
# plot both curves
lines(x,y,col="purple")
lines(x, y2, col = "red")
# add the points to the first curve
points(x, y, col = "black")
# adds some lines indicating the standard error
segments(x,y,x,y+yse,col="blue")
# adds some flags indicating the standard error
arrows(x,y,x,y-yse,angle=90,length=0.1,col="darkgreen")
-------------------------------------------------------------------------------------------------------
grid.newpage()
pushViewport(viewport(layout=grid.layout(2, 2)))
grid.rect(gp=gpar(fill=1),vp=viewport(layout.pos.col=1,layout.pos.row=1))
grid.rect(gp=gpar(fill=2),vp=viewport(layout.pos.col=1,layout.pos.row=2))
grid.rect(gp=gpar(fill=3),vp=viewport(layout.pos.col=2,layout.pos.row=1))
grid.rect(gp=gpar(fill=4),vp=viewport(layout.pos.col=2,layout.pos.row=2))

pushViewport(viewport(x=unit(0.5, "npc"), width=unit(0.5, "npc"), 
  y=unit(0.75, "npc"), height=unit(0.5, "npc")))
grid.rect(gp=gpar(fill="white")) vpvp <- function(pos.col, pos.row){
  cvp <- current.viewport()
  nrow <- cvp$layout$nrow
  ncol <- cvp$layout$ncol
  w <- unit(1/ncol, "npc")
  h <- unit(1/nrow, "npc")
  x <- unit((pos.col-0.5)/ncol, "npc")
  y <- unit(1-(pos.row-0.5)/nrow, "npc")
  viewport(x=x, y=y, width=w, height=h)
}

grid.newpage()
pushViewport(viewport(layout=grid.layout(2, 3)))
grid.rect(gp=gpar(fill=1),vp=viewport(layout.pos.col=1,layout.pos.row=1))
grid.rect(gp=gpar(fill=2),vp=viewport(layout.pos.col=1,layout.pos.row=2))
grid.rect(gp=gpar(fill=3),vp=viewport(layout.pos.col=2,layout.pos.row=1))
grid.rect(gp=gpar(fill=4),vp=viewport(layout.pos.col=2,layout.pos.row=2))
grid.rect(gp=gpar(fill=5),vp=viewport(layout.pos.col=3,layout.pos.row=1))
grid.rect(gp=gpar(fill=6),vp=viewport(layout.pos.col=3,layout.pos.row=2))

pushViewport(vpvp(pos.col=2.5, pos.row=1.5))
grid.rect(gp=gpar(fill="white"))
-------------------------------------------------------------------------------------------------------
k <- 3 # number of branches to identify
labels.to.identify <- c('1','2','3')
required.density <- 10 # the density of shading lines, in lines per inch 
rect.hclust.nice(tree, k, labels=labels.to.identify, density=density.required) rect.hclust.nice = function (tree, k = NULL, which = NULL, x = NULL, h = NULL, border = 2, 
    cluster = NULL,  density = NULL,labels = NULL, ...) 
{
    if (length(h) > 1 | length(k) > 1) 
        stop("'k' and 'h' must be a scalar")
    if (!is.null(h)) {
        if (!is.null(k)) 
            stop("specify exactly one of 'k' and 'h'")
        k <- min(which(rev(tree$height) < h))
        k <- max(k, 2)
    }
    else if (is.null(k)) 
        stop("specify exactly one of 'k' and 'h'")
    if (k < 2 | k > length(tree$height)) 
        stop(gettextf("k must be between 2 and %d", length(tree$height)), 
            domain = NA)
    if (is.null(cluster)) 
        cluster <- cutree(tree, k = k)
    clustab <- table(cluster)[unique(cluster[tree$order])]
    m <- c(0, cumsum(clustab))
    if (!is.null(x)) {
        if (!is.null(which)) 
            stop("specify exactly one of 'which' and 'x'")
        which <- x
        for (n in 1L:length(x)) which[n] <- max(which(m < x[n]))
    }
    else if (is.null(which)) 
        which <- 1L:k
    if (any(which > k)) 
        stop(gettextf("all elements of 'which' must be between 1 and %d", 
            k), domain = NA)
    border <- rep(border, length.out = length(which))
    labels <- rep(labels, length.out = length(which))
    retval <- list()
    for (n in 1L:length(which)) {
        rect(m[which[n]] + 0.66, par("usr")[3L], m[which[n] + 1] + 0.33, mean(rev(tree$height)[(k - 1):k]), border = border[n], col = border[n], density = density, ...)
        text((m[which[n]] + m[which[n] + 1]+1)/2, grconvertY(grconvertY(par("usr")[3L],"user","ndc")+0.02,"ndc","user"),labels[n])
        retval[[n]] <- which(cluster == as.integer(names(clustab)[which[n]]))
    }
    invisible(retval)
}
-------------------------------------------------------------------------------------------------------
alpha=0.5 fill.alpha=0.5 inherit.aes = FALSE geom_rect() p <- ggplot(data=diamonds, aes(x=price, y=carat)) + geom_line(aes(color=color))
rect <- data.frame (xmin=5000, xmax=10000, ymin=-Inf, ymax=Inf)
p + geom_rect(data=rect, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax), color="grey20", alpha=0.5, inherit.aes = FALSE) ymin ymax -Inf Inf
-------------------------------------------------------------------------------------------------------
tikzAnnotate tikzAnnotate grid grid print gridToDevice <- function(x = 0, y = 0, units = 'native') {
  # Converts a coordinate pair from the current viewport to an "absolute
  # location" measured in device units from the lower left corner. This is done
  # by first casting to inches in the current viewport and then using the
  # current.transform() matrix to obtain inches in the device canvas.
  x <- convertX(unit(x, units), unitTo = 'inches', valueOnly = TRUE)
  y <- convertY(unit(y, units), unitTo = 'inches', valueOnly = TRUE)

  transCoords <- c(x,y,1) %*% current.transform()
  transCoords <- (transCoords / transCoords[3])

  return(
    # Finally, cast from inches to native device units
    c(
      grconvertX(transCoords[1], from = 'inches', to ='device'),
      grconvertY(transCoords[2], from = 'inches', to ='device')
    )
  )

} tikzAnnotate grid lattice require(tikzDevice)
require(grid)
options(tikzLatexPackages = c(getOption('tikzLatexPackages'),
                "\\usetikzlibrary{shapes.arrows}"))

tikz(standAlone=TRUE)

xs <- 15:20
ys <- 5:10

pushViewport(plotViewport())
pushViewport(dataViewport(xs,ys))

grobs <- gList(grid.rect(),grid.xaxis(),grid.yaxis(),grid.points(xs, ys))

coords <- gridToDevice(17, 7)
tikzAnnotate(paste('\\node[single arrow,anchor=tip,draw,fill=green,left=1em]',
  'at (', coords[1],',',coords[2],') {Look over here!};'))

dev.off() ggplot tikzDevice
-------------------------------------------------------------------------------------------------------
+ opts(strip.background = theme_rect(colour = 'purple')) + opts(strip.background = theme_rect(fill = 'purple'))
-------------------------------------------------------------------------------------------------------
require(plotrix)
require(grid)

plot(c(-1, 1), c(-1,1), type = "n", asp=1)
rect( -.5, -.5, .5, .5) 
draw.circle( 0, 0, .5 )
-------------------------------------------------------------------------------------------------------
border legend.v2('bottomright', 
        c("no box, no point","no box, no point",estNames) , 
        lty=c(rep('dotted',2),rep('solid',3)), 
        col=c('black','red',1,2,4),
        pch=c(-1,-1,rep(16,3)),
        lwd=1,
        border = c("white", "white", "black", "black", "black"),
        trace = TRUE,
        fill=c( 0, 0,
                rep( c( rgb(0.5,0.5,0.1,0.25),
                                rgb(0.5,0.1,0.1,0.25),
                                rgb(0.1,0.1,0.5,0.25)), 2)),
        inset=0,bg='white') ?rect xbox if (mfill) legend.v2 <- function (x, y = NULL, legend, fill = NULL, col = par("col"), 
        border = "black", lty, lwd, pch, angle = 45, density = NULL, 
        bty = "o", bg = par("bg"), box.lwd = par("lwd"), box.lty = par("lty"), 
        box.col = par("fg"), pt.bg = NA, cex = 1, pt.cex = cex, pt.lwd = lwd, 
        xjust = 0, yjust = 1, x.intersp = 1, y.intersp = 1, adj = c(0, 
                0.5), text.width = NULL, text.col = par("col"), merge = do.lines && 
                has.pch, trace = FALSE, plot = TRUE, ncol = 1, horiz = FALSE, 
        title = NULL, inset = 0, xpd, title.col = text.col, title.adj = 0.5, 
        seg.len = 2) 
{
    if (missing(legend) && !missing(y) && (is.character(y) || 
                is.expression(y))) {
        legend <- y
        y <- NULL
    }
    mfill <- !missing(fill) || !missing(density)
    if (!missing(xpd)) {
        op <- par("xpd")
        on.exit(par(xpd = op))
        par(xpd = xpd)
    }
    title <- as.graphicsAnnot(title)
    if (length(title) > 1) 
        stop("invalid title")
    legend <- as.graphicsAnnot(legend)
    n.leg <- if (is.call(legend)) 
                1
            else length(legend)
    if (n.leg == 0) 
        stop("'legend' is of length 0")
    auto <- if (is.character(x)) 
                match.arg(x, c("bottomright", "bottom", "bottomleft", 
                                "left", "topleft", "top", "topright", "right", "center"))
            else NA
    if (is.na(auto)) {
        xy <- xy.coords(x, y)
        x <- xy$x
        y <- xy$y
        nx <- length(x)
        if (nx < 1 || nx > 2) 
            stop("invalid coordinate lengths")
    }
    else nx <- 0
    xlog <- par("xlog")
    ylog <- par("ylog")
    rect2 <- function(left, top, dx, dy, density = NULL, angle, 
            ...) {
        r <- left + dx
        if (xlog) {
            left <- 10^left
            r <- 10^r
        }
        b <- top - dy
        if (ylog) {
            top <- 10^top
            b <- 10^b
        }
        rect(left, top, r, b, angle = angle, density = density, ...)
    }
    segments2 <- function(x1, y1, dx, dy, ...) {
        x2 <- x1 + dx
        if (xlog) {
            x1 <- 10^x1
            x2 <- 10^x2
        }
        y2 <- y1 + dy
        if (ylog) {
            y1 <- 10^y1
            y2 <- 10^y2
        }
        segments(x1, y1, x2, y2, ...)
    }
    points2 <- function(x, y, ...) {
        if (xlog) 
            x <- 10^x
        if (ylog) 
            y <- 10^y
        points(x, y, ...)
    }
    text2 <- function(x, y, ...) {
        if (xlog) 
            x <- 10^x
        if (ylog) 
            y <- 10^y
        text(x, y, ...)
    }
    if (trace) 
        catn <- function(...) do.call("cat", c(lapply(list(...), 
                                    formatC), list("\n")))
    cin <- par("cin")
    Cex <- cex * par("cex")
    if (is.null(text.width)) 
        text.width <- max(abs(strwidth(legend, units = "user", 
                                cex = cex)))
    else if (!is.numeric(text.width) || text.width < 0) 
        stop("'text.width' must be numeric, >= 0")
    xc <- Cex * xinch(cin[1L], warn.log = FALSE)
    yc <- Cex * yinch(cin[2L], warn.log = FALSE)
    if (xc < 0) 
        text.width <- -text.width
    xchar <- xc
    xextra <- 0
    yextra <- yc * (y.intersp - 1)
    ymax <- yc * max(1, strheight(legend, units = "user", cex = cex)/yc)
    ychar <- yextra + ymax
    if (trace) 
        catn("  xchar=", xchar, "; (yextra,ychar)=", c(yextra, 
                        ychar))
    if (mfill) {
        xbox <- xc * 0.8
        ybox <- yc * 0.5
        dx.fill <- xbox
    }
    do.lines <- (!missing(lty) && (is.character(lty) || any(lty > 
                                    0))) || !missing(lwd)
    n.legpercol <- if (horiz) {
                if (ncol != 1) 
                    warning("horizontal specification overrides: Number of columns := ", 
                            n.leg)
                ncol <- n.leg
                1
            }
            else ceiling(n.leg/ncol)
    has.pch <- !missing(pch) && length(pch) > 0
    if (do.lines) {
        x.off <- if (merge) 
                    -0.7
                else 0
    }
    else if (merge) 
        warning("'merge = TRUE' has no effect when no line segments are drawn")
    if (has.pch) {
        if (is.character(pch) && !is.na(pch[1L]) && nchar(pch[1L], 
                type = "c") > 1) {
            if (length(pch) > 1) 
                warning("not using pch[2..] since pch[1L] has multiple chars")
            np <- nchar(pch[1L], type = "c")
            pch <- substr(rep.int(pch[1L], np), 1L:np, 1L:np)
        }
    }
    if (is.na(auto)) {
        if (xlog) 
            x <- log10(x)
        if (ylog) 
            y <- log10(y)
    }
    if (nx == 2) {
        x <- sort(x)
        y <- sort(y)
        left <- x[1L]
        top <- y[2L]
        w <- diff(x)
        h <- diff(y)
        w0 <- w/ncol
        x <- mean(x)
        y <- mean(y)
        if (missing(xjust)) 
            xjust <- 0.5
        if (missing(yjust)) 
            yjust <- 0.5
    }
    else {
        h <- (n.legpercol + (!is.null(title))) * ychar + yc
        w0 <- text.width + (x.intersp + 1) * xchar
        if (mfill) 
            w0 <- w0 + dx.fill
        if (do.lines) 
            w0 <- w0 + (seg.len + +x.off) * xchar
        w <- ncol * w0 + 0.5 * xchar
        if (!is.null(title) && (abs(tw <- strwidth(title, units = "user", 
                                    cex = cex) + 0.5 * xchar)) > abs(w)) {
            xextra <- (tw - w)/2
            w <- tw
        }
        if (is.na(auto)) {
            left <- x - xjust * w
            top <- y + (1 - yjust) * h
        }
        else {
            usr <- par("usr")
            inset <- rep(inset, length.out = 2)
            insetx <- inset[1L] * (usr[2L] - usr[1L])
            left <- switch(auto, bottomright = , topright = , 
                    right = usr[2L] - w - insetx, bottomleft = , 
                    left = , topleft = usr[1L] + insetx, bottom = , 
                    top = , center = (usr[1L] + usr[2L] - w)/2)
            insety <- inset[2L] * (usr[4L] - usr[3L])
            top <- switch(auto, bottomright = , bottom = , bottomleft = usr[3L] + 
                            h + insety, topleft = , top = , topright = usr[4L] - 
                            insety, left = , right = , center = (usr[3L] + 
                                usr[4L] + h)/2)
        }
    }
    if (plot && bty != "n") {
        if (trace) 
            catn("  rect2(", left, ",", top, ", w=", w, ", h=", 
                    h, ", ...)", sep = "")
        rect2(left, top, dx = w, dy = h, col = bg, density = NULL, 
                lwd = box.lwd, lty = box.lty, border = box.col)
    }
    xt <- left + xchar + xextra + (w0 * rep.int(0:(ncol - 1), 
                rep.int(n.legpercol, ncol)))[1L:n.leg]
    yt <- top - 0.5 * yextra - ymax - (rep.int(1L:n.legpercol, 
                        ncol)[1L:n.leg] - 1 + (!is.null(title))) * ychar
    if (mfill) {
        if (plot) {
            fill <- rep(fill, length.out = n.leg)
            rect2(left = xt, top = yt + ybox/2, dx = xbox * 3, dy = ybox, 
                    col = fill, density = density, angle = angle, 
                    border = border)
        }
        xt <- xt + dx.fill
    }
    if (plot && (has.pch || do.lines)) 
        col <- rep(col, length.out = n.leg)
    if (missing(lwd)) 
        lwd <- par("lwd")
    if (do.lines) {
        if (missing(lty)) 
            lty <- 1
        lty <- rep(lty, length.out = n.leg)
        lwd <- rep(lwd, length.out = n.leg)
        ok.l <- !is.na(lty) & (is.character(lty) | lty > 0)
        if (trace) 
            catn("  segments2(", xt[ok.l] + x.off * xchar, ",", 
                    yt[ok.l], ", dx=", seg.len * xchar, ", dy=0, ...)")
        if (plot) 
            segments2(xt[ok.l] + x.off * xchar, yt[ok.l], dx = seg.len * 
                            xchar, dy = 0, lty = lty[ok.l], lwd = lwd[ok.l], 
                    col = col[ok.l])
        xt <- xt + (seg.len + x.off) * xchar
    }
    if (has.pch) {
        pch <- rep(pch, length.out = n.leg)
        pt.bg <- rep(pt.bg, length.out = n.leg)
        pt.cex <- rep(pt.cex, length.out = n.leg)
        pt.lwd <- rep(pt.lwd, length.out = n.leg)
        ok <- !is.na(pch) & (is.character(pch) | pch >= 0)
        x1 <- (if (merge && do.lines) 
                xt - (seg.len/2) * xchar
            else xt)[ok]
        y1 <- yt[ok]
        if (trace) 
            catn("  points2(", x1, ",", y1, ", pch=", pch[ok], 
                    ", ...)")
        if (plot) 
            points2(x1, y1, pch = pch[ok], col = col[ok], cex = pt.cex[ok], 
                    bg = pt.bg[ok], lwd = pt.lwd[ok])
    }
    xt <- xt + x.intersp * xchar
    if (plot) {
        if (!is.null(title)) 
            text2(left + w * title.adj, top - ymax, labels = title, 
                    adj = c(title.adj, 0), cex = cex, col = title.col)
        text2(xt, yt, labels = legend, adj = adj, cex = cex, 
                col = text.col)
    }
    invisible(list(rect = list(w = w, h = h, left = left, top = top), 
                    text = list(x = xt, y = yt)))
}
-------------------------------------------------------------------------------------------------------
p <- ggplot(dfr) + 
  geom_point(aes(x, y)) +       
  geom_point(
    aes(
      x = mean(x), 
      y = mean(y)
    ), 
    colour = "blue",
    size = 5
  ) +
  geom_rect(
    aes(
      xmin = mean(x) - sd(x),
      xmax = mean(x) + sd(x), 
      ymin = mean(y) - sd(y),
      ymax = mean(y) + sd(y)
    ),
    alpha = 0.2
  ) 
p p +
  scale_x_log10() + 
  scale_y_log10()
-------------------------------------------------------------------------------------------------------
grid.layout() label <- textGrob("A page number! ",
                  x=0.5, y = 1.0, just="centre")
x <- seq(0.1, 0.9, length=50)
y <- runif(50, 0.1, 0.9)
gplot <- 
  gTree(
    children=gList(rectGrob(gp=gpar(col="grey60",
                                    fill="white")),
                   linesGrob(x, y), 
                   pointsGrob(x, y, pch=16, 
                              size=unit(1.5, "mm"))),
    vp=viewport(width=unit(1, "npc") - unit(5, "mm"), 
                height=unit(1, "npc") - unit(10, "mm")))



layout <- grid.layout(2, 1,
                      widths=unit(c(1, 1), 
                                  c("null", "grobwidth"),
                                  list(NULL, label)),
                      heights = unit(c(1, 1),
                                     c("null", "grobheight"),
                                     list(NULL, label)))

grid.rect(gp=gpar(col="grey60", fill="grey90"))
pushViewport(viewport(layout=layout))
pushViewport(viewport(layout.pos.row=2))
grid.draw(label)
popViewport()
pushViewport(viewport(layout.pos.col=1))
grid.draw(gplot)
popViewport(2)
-------------------------------------------------------------------------------------------------------
df <- data.frame(A=sort(runif(20)), B=sort(runif(20)))
df <- rbind(df, c(1,1)) df_rect <- data.frame(xmin=c(0, median(df$A), -0.01, -0.01), xmax=c(median(df$A), 1, 0, 0), ymin=c(-0.01, -0.01, 0, median(df$B)), ymax=c(0, 0, median(df$B), 1), color=grey(c(0.7, 0.2)), alpha=c(0.8, 0.4, 0.8, 0.4)) df_text <- data.frame(x=c(median(df$A)/2, median(df$A) + (1-median(df$A))/2, 0.05, 0.05), y=c(0.02, 0.02, median(df$B)/2, median(df$B) + (1-median(df$B))/2), label=rep('50%', 4)) ggplot(df, aes(A, B)) + geom_point() +
    geom_line() +
    geom_rect(data=df_rect, aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymax, fill=color, alpha=alpha), inherit.aes = FALSE) + scale_fill_grey() +
    geom_text(data=df_text, aes(x=x, y=y, label=label), inherit.aes = FALSE) + 
    theme_bw() + scale_y_continuous(limits=c(-0.01, 1), formatter='percent') + scale_x_continuous(limits=c(-0.01, 1), formatter='percent') + opts(legend.position="none") geom_point geom_line geom_rect geom_text df_rext df_text theme_bw scale_continous formatter
-------------------------------------------------------------------------------------------------------
opts(panel.background=theme_rect(colour="white"),...) opts theme theme(panel.background = element_rect(colour = "white"))
-------------------------------------------------------------------------------------------------------
library(reshape2)
finalregstack$trade.date <- as.Date(rownames(finalregstack))
fm <- melt(finalregstack,id.var="trade.date")

library(ggplot2)
qplot(trade.date,value,data=fm,geom="line")+
  facet_grid(variable~.,scale="free_y")+
  labs(x="Trading date",y="")+
  theme_bw() ## cosmetic reshape2 scale="free_y" align.plot align.plots heights library(ggExtra)

theme_set(theme_bw())
theme_update(panel.background=theme_rect(),
              panel.grid.major=theme_blank(),
             panel.grid.minor=theme_blank())

kurth.plot <- qplot(x=trade.date, y=kurth,
                    data=finalregstack, geom='line')+
  scale_y_continuous(name='kurth')+
  scale_x_date(name='',expand=c(0,0))+
  opts(plot.margin = unit(c(1,0,0,0), "lines"))

skewh.plot <- qplot(x=trade.date, y=skewh,
                    data=finalregstack, geom='line')+
  scale_y_continuous(name='skewh')+
  scale_x_date(name='', expand=c(0,0))+
  opts(plot.margin = unit(c(-1,0,0,0), "lines"))


logpremh.plot <- qplot(x=trade.date, y=logpremh,
                       data=finalregstack, geom='line')+
  scale_y_continuous(name='logpremh')+
  scale_x_date(name='Trading date', expand=c(0,0))+
  opts(plot.margin = unit(c(-1,0,0,0), "lines"))


source(url("http://ggextra.googlecode.com/svn/trunk/R/align.r"))
grid.newpage()
align.plots(kurth.plot, skewh.plot, logpremh.plot,
            heights=unit(c(0.33,0.33,0.33),"null")) x grid.arrange align.plots
-------------------------------------------------------------------------------------------------------
myplot set.seed(3)
dat <- data.frame(x = runif(10), y = rnorm(10), group = gl(2,5),
                  mylabel = paste(1:10, "foo"))

require(ggplot2)
myplot <- ggplot(data=dat, aes(x, y, group = group, colour = group, 
                 label = mylabel)) + geom_line(size = 1.5)

myplot + geom_text(color = "black") + 
    opts(panel.background = theme_rect(fill = "white", colour = NA)) myplot myplot
-------------------------------------------------------------------------------------------------------
tsc.p1 <- tsc.p + geom_rect(colour = I("grey")) +
          facet_grid(helmet~.) +
          geom_text(aes(x = c(9.0, 22.0, 33.0, 46.0, 72.0, 98.0),
                        y = 125,
                        label = c("C", "DS", "S", "ST", "Std", "T")),
                        size = 3) +
          scale_fill_brewer(palette = "Greys") +
          opts(title="Mosaic Plot of Helmet Type Use",
               legend.position="none") +
          scale_x_continuous("Percentage of Sample", expand = c(0, 0)) +
          scale_y_continuous("Percentage Responded", expand = c(0, 125)) +
          cood_cartesian(ylim = c(0, 101))
-------------------------------------------------------------------------------------------------------
tsc.p <- ggplot(tsc, 
                aes(ymin = ymin, ymax = ymax,
                    xmin = xmin, xmax = xmax,
                    fill = variable))
tsc.p1 <- tsc.p + geom_rect(colour = I("grey")) +
          facet_grid(helmet~.) +
          geom_text(aes(x = c(9.0, 22.0, 33.0),
                        y = 25,
                        label = ifelse(helmet == "FF",
                                       c("Cru", "DualSp", "Sport"),
                                       "")),
                        size = 3) +
          geom_text(aes(x = c(45.0, 72.0, 97.0),
                        y = 25,
                        label = ifelse(helmet == "FF",
                                       c("SptTour", "Std", "Tour"),
                                       "")),
                        size = 3) +
          scale_fill_brewer("Frequency of Helmet Use", palette = "Greys") +
          xlab("Percentage of Sample") +
          ylab("Percentage Responded") +
          opts(title="Mosaic Plot of Helmet Use by Helmet Type") +
          scale_x_continuous(expand = c(0, 0)) +
          scale_y_continuous(expand = c(0, 101)) +
          ylim(0, 101)
-------------------------------------------------------------------------------------------------------
dat = data.frame(x=rnorm(1000))  
ggplot(dat,aes(x=x)) + 
    geom_histogram(aes(y=..density..,fill="Histogram"),binwidth=0.5) + 
    stat_function(fun = dnorm, aes(colour= "Density")) +
    scale_x_continuous('x', limits = c(-4, 4)) + 
    opts(title = "Histogram with Overlay") +
    scale_fill_manual(name="",value="blue") + 
    scale_colour_manual(name="",value="red") + 
    scale_y_continuous('Frequency')+
    opts(legend.key=theme_rect(fill="white",colour="white"))+
    opts(legend.background = theme_blank()) opts theme theme(legend.key = element_rect(fill = "white",colour = "white")) + 
theme(legend.background = element_blank())
-------------------------------------------------------------------------------------------------------
myplot + opts(panel.background = theme_rect(fill='green', colour='red')) myplot + opts(plot.background = theme_rect(fill='green', colour='red'))
-------------------------------------------------------------------------------------------------------
ggplot() + geom_rect(aes(xmin=-1,ymin=-1,xmax=1,ymax=1), fill=NA) + coord_polar()
-------------------------------------------------------------------------------------------------------
+ opts(plot.background = theme_rect(colour = "blue") geom_rect
-------------------------------------------------------------------------------------------------------
fv.colors = colorRampPalette(c("white","tan4","green")) ## define the color ramp
colorlut = fv.colors(100)[c(1,seq(50,100,length.out=99))] ## select colors to use
plot(0:1,0:1,type='n',xaxs='i',yaxs='i') ## define the plotting area
## illustrate the vector of colors using rectangles
rect(seq(0,0.99,0.01),rep(0,100),seq(0.01,1,0.01),rep(1,100),col = colorlut,border = NA)
box() ## make sure that the graph's frame is not covered up
-------------------------------------------------------------------------------------------------------
scales = "free" expand = c(0,0) ggplot(mydata) +
  aes(x=x,y=y) +
  stat_density2d(geom="tile", aes(fill = ..density..), contour = FALSE) +
  facet_wrap(~ groupvar,scales = "free") + 
  scale_x_continuous(expand = c(0,0)) + 
  scale_y_continuous(expand = c(0,0)) ggplot(mydata) +
  aes(x=x,y=y) +
  stat_density2d(geom="tile", aes(fill = ..density..), contour = FALSE) +
  facet_wrap(~ groupvar) + 
  scale_fill_gradient(low = "blue", high = "red") + 
  opts(panel.background = theme_rect(fill = "blue"),panel.grid.major = theme_blank(),
       panel.grid.minor = theme_blank())
-------------------------------------------------------------------------------------------------------
plot(df)
rect(par("usr")[1],par("usr")[3],par("usr")[2],par("usr")[4],col = "gray")
points(df) barplot add
-------------------------------------------------------------------------------------------------------
profr Rprof profr ddply profr library(profr)
p <- profr(
    ddply(baseball, .(year), "nrow"),
    0.01
)
plot(p) ddply ldply llply loop_apply loop_apply .Call loop_apply > plyr:::loop_apply
function (n, f, env = parent.frame()) 
{
    .Call("loop_apply", as.integer(n), f, env)
}
<environment: namespace:plyr> ggplot.profr ggplot.profr <- function (data, ..., minlabel = 0.1, angle = 0){
  if (!require("ggplot2", quiet = TRUE)) 
    stop("Please install ggplot2 to use this plotting method")
  data$range <- diff(range(data$time))
  ggplot(as.data.frame(data), aes(y=level)) + 
      geom_rect(
          #aes(xmin=(level), xmax=factor(level)+1, ymin=start, ymax=end),  
          aes(ymin=level-0.5, ymax=level+0.5, xmin=start, xmax=end),  
          #position = "identity", stat = "identity", width = 1, 
          fill = "grey95", 
          colour = "black", size = 0.5) + 
      geom_text(aes(label = f, x = start + range/60), 
          data = subset(data, time > max(time) * minlabel), size = 4, angle = angle, vjust=0.5, hjust = 0) + 
      scale_x_continuous("time") + 
      scale_y_continuous("level")
}
-------------------------------------------------------------------------------------------------------
p p + opts(
  legend.position = c(0.9, 0.6), 
  legend.background = theme_rect(fill = "white", colour = NA)
) fill "#ffffffaa"
-------------------------------------------------------------------------------------------------------
reshape numbet <- 32
numtri <- 1e5
prob=5/6
#Fill a matrix 
xcum <- matrix(NA, nrow=numtri, ncol=numbet+1)
for (i in 1:numtri) {
  x <- sample(c(0,1), numbet, prob=c(prob, 1-prob), replace = TRUE)
  xcum[i, ] <- c(i, cumsum(x)/cumsum(1:numbet))
}
colnames(xcum) <- c("trial", paste("bet", 1:numbet, sep=""))

mxcum <- reshape(data.frame(xcum), varying=1+1:numbet, 
  idvar="trial", v.names="outcome", direction="long", timevar="bet")


library(plyr)
mxcum2 <- ddply(mxcum, .(bet, outcome), nrow)
mxcum3 <- ddply(mxcum2, .(bet), summarize, 
                ymin=c(0, head(seq_along(V1)/length(V1), -1)), 
                ymax=seq_along(V1)/length(V1),
                fill=(V1/sum(V1)))
head(mxcum3)

library(ggplot2)

p <- ggplot(mxcum3, aes(xmin=bet-0.5, xmax=bet+0.5, ymin=ymin, ymax=ymax)) + 
    geom_rect(aes(fill=fill), colour="grey80") + 
    scale_fill_gradient("Outcome", formatter="percent", low="red", high="blue") +
    scale_y_continuous(formatter="percent") +
    xlab("Bet")

print(p)
-------------------------------------------------------------------------------------------------------
plot.background panel.background df <- data.frame(y=d,x=1)
p <- ggplot(df) + stat_boxplot(aes(x = x,y=y)) 
p <- p + opts(
    panel.background = theme_rect(fill = "transparent",colour = NA), # or theme_blank()
    panel.grid.minor = theme_blank(), 
    panel.grid.major = theme_blank(),
    plot.background = theme_rect(fill = "transparent",colour = NA)
)
#returns white background
png('tr_tst2.png',width=300,height=300,units="px",bg = "transparent")
print(p)
dev.off() opts() theme() opts() element_rect() theme_rect()
-------------------------------------------------------------------------------------------------------
theme_new <- theme_set(theme_bw())
theme_new <- theme_update(
    panel.background = theme_rect(fill="lightblue")
)
ggplot(mtcars, aes(factor(cyl)))  + geom_bar()
-------------------------------------------------------------------------------------------------------
layout(matrix(c(1,2,5,6,3,4,7,8,9,10,13,14,11,12,15,16), 4, 4, byrow=TRUE))
replicate(16, hist(rnorm(100)))
par(xpd=NA)
rect( grconvertX(0.005, from='ndc'), grconvertY(0.505, from='ndc'),
     grconvertX(0.495, from='ndc'), grconvertY(0.995, from='ndc'))
rect( grconvertX(0.005, from='ndc'), grconvertY(0.005, from='ndc'),
     grconvertX(0.495, from='ndc'), grconvertY(0.495, from='ndc'))
rect( grconvertX(0.505, from='ndc'), grconvertY(0.505, from='ndc'),
     grconvertX(0.995, from='ndc'), grconvertY(0.995, from='ndc'))
rect( grconvertX(0.505, from='ndc'), grconvertY(0.005, from='ndc'),
     grconvertX(0.995, from='ndc'), grconvertY(0.495, from='ndc'))
-------------------------------------------------------------------------------------------------------
library(maps)
map("world", interior=TRUE, fill=TRUE, boundary=FALSE, col="white", bg="lightblue")
map("world", interior=TRUE, boundary=TRUE, col="red", add=TRUE) ggplot ggplot library(ggplot2)
library(maps)
mapWorld <- borders("world", colour="red", fill="white")
ggplot() + 
  mapWorld + 
  geom_path() + 
  opts(
    plot.background=theme_rect(fill="lightblue"),
    panel.background=theme_rect(fill="lightblue")
    )
-------------------------------------------------------------------------------------------------------
x <- c(126,162,233,304,375,446,517,588,659,730,801,839)
p <- c(0.06,0.06,0.1,0.08,0.12,0.16,0.14,0.14,0.08,0.02,0.04)
plot(x,c(p,0),type="s")
lines(x,c(0,p),type="S")
rect(x[-1],0,x[-length(x)],p,col="lightblue") rect lines plot(x,p,type="n") par(bty="l",lty=1) ?plot b <- barplot(p,width=diff(x),space=0)
-------------------------------------------------------------------------------------------------------
white Plot <- Plot + 
  geom_text(data = TextFrame, aes(x = X, y = Y, label = LAB), colour = 'white') alpha geom_point Plot <- Plot + geom_point(size = 20, alpha = 0.5) width height Labels <- c("Alabama", "Alaska", "Arizona", "Arkansas", 
    "Pennsylvania + California")
TextFrame <- data.frame(X = 4:8, Y = 4:8, LAB = Labels)
TextFrame <- transform(TextFrame,
    w = strwidth(LAB, 'inches') + 0.25,
    h = strheight(LAB, 'inches') + 0.25
)

ggplot(data = SampleFrame,aes(x = X, y = Y)) + 
  geom_point(size = 20) +
  geom_rect(data = TextFrame, aes(xmin = X - w/2, xmax = X + w/2, 
    ymin = Y - h/2, ymax = Y + h/2), fill = "grey80") +
  geom_text(data = TextFrame,aes(x = X, y = Y, label = LAB), size = 4)
-------------------------------------------------------------------------------------------------------
geom_rect geom_text library(ggplot2)
ggplot(data = SampleFrame,aes(x = X, y = Y)) + 
  geom_point(size = 20) +
  geom_rect(data = TextFrame, aes(xmin = X -.4, xmax = X + .4, ymin = Y - .4, ymax = Y + .4), fill = "grey80") +
  geom_text(data = TextFrame,aes(x = X, y = Y, label = LAB), size = 4)
-------------------------------------------------------------------------------------------------------
strheight strwidht strheight strwidth png(); plot(...); dev.off() x <- 1:300
y <- 1:300
plot(x, y, type="l")

txt <- "A note about this plot!"
rwidth <- strwidth(txt, font=2, cex=2)
rheight <- strheight(txt, font=2, cex=2)

tx <- 150
ty <- 100

text(tx, ty,txt, font=2, cex=2, col="blue", offset=1)

rect(tx-0.5*rwidth, ty-0.5*rheight, tx+0.5*rwidth, ty+0.5*rheight)
-------------------------------------------------------------------------------------------------------
grid gridBase drawDetails library(gridBase)
 library(gridExtra)

 par(oma=rep(1, 4), mfrow=c(1, 2), xpd=NA)
 plot(1:10, 1:10)
 vps <- baseViewports()
 pushViewport(vps$inner)
 pushViewport(vps$figure)
 pushViewport(vps$plot)
 ## grid.rect(gp=gpar(lwd=3, col="blue"))
 grid.table(expression("this is an expression"*integral(f(x)*dx, alpha, beta)),
            parse=TRUE, theme=theme.white(show.box=TRUE, separator = "red",
                          show.rownames = FALSE, show.colnames = FALSE))
 upViewport(0)
-------------------------------------------------------------------------------------------------------
library(grid)
 stextGrob <- function (label, r=0.02, x = unit(0.5, "npc"), y = unit(0.5, "npc"), 
                        just = "centre", hjust = NULL, vjust = NULL, rot = 0, check.overlap = FALSE, 
                        default.units = "npc", name = NULL, gp = gpar(), vp = NULL){

   let <- textGrob("a", gp=gp, vp=vp)
   wlet <- grobWidth(let)
   hlet <- grobHeight(let)

   tg <- textGrob(label=label, x=x, y=y, gp=gpar(col="red"),
                  just = just, hjust = hjust, vjust = vjust, rot = rot,
                  check.overlap = check.overlap, 
                  default.units = default.units)

   tgl <- c(lapply(seq(0, 2*pi, length=36), function(theta){

     textGrob(label=label,x=x+cos(theta)*r*wlet,
              y=y+sin(theta)*r*hlet, gp=gpar(col="white"),
              just = just, hjust = hjust, vjust = vjust, rot = rot,
              check.overlap = check.overlap, 
              default.units = default.units)

     }), list(tg))


   g <- gTree(children=do.call(gList, tgl), vp=vp, name=name, gp=gp)

 }

 grid.stext <- function(...){
   g <- stextGrob(...)
   grid.draw(g)
   invisible(g)
 }

 grid.newpage()
 grid.rect(gp=gpar(fill="grey"))
 grid.stext("Yeah", gp=gpar(cex=4))
-------------------------------------------------------------------------------------------------------
ggplot library(ggplot2)

blocks <- expand.grid(
  x = 1:ncol(mydes),
  y = 1:nrow(mydes)
)

blocks$label <- unname(rapply(mydes, as.character))

ggplot(blocks) + 
  geom_rect(aes(xmin=x-0.4, xmax=x+0.4, ymin=y-0.4, ymax=y+0.4), fill="cyan") +
  geom_text(aes(label=label, x=x, y=y)) +
  xlab("Blocks") + ylab("Treatments") ggplot(blocks) + 
  geom_rect(aes(xmin=x-0.4, xmax=x+0.4, ymin=y-0.4, ymax=y+0.4, fill=label)) +
  geom_text(aes(label=label, x=x, y=y)) +
  xlab("Blocks") + ylab("Treatments") +
  scale_fill_hue("Treatment", h=c(90, 150))
-------------------------------------------------------------------------------------------------------
grImport library(grImport)

 cat("%!PS 
 /Times-Roman findfont 
 10 scalefont 
 setfont 
 newpath 
 0 0 moveto 
 (hello) show", file="hello.ps")

 PostScriptTrace("hello.ps", "hello.xml")
 hello <- readPicture("hello.xml")
 grid.rect(gp=gpar(fill="grey"))
 grid.picture(hello,use.gc = FALSE, gp=gpar(fill="red", lwd=5, col="white"))
-------------------------------------------------------------------------------------------------------
library(lattice)
library(gridBase)

plot.new()
pushViewport(viewport())
xvars <- rnorm(25)
yvars <- rnorm(25)
xyplot(yvars~xvars)
pushViewport(viewport(x=.6,y=.8,width=.25,height=.25,just=c("left","top")))
grid.rect()
par(plt = gridPLT(), new=TRUE)
plot(xvars,yvars)
popViewport(2)
-------------------------------------------------------------------------------------------------------
geom_bin2d() dat <- data.frame(x=c(0,0,10,10), y=c(0,10,0,10), freq=c(1,0,1,3))

ggplot(dat) +
  geom_bin2d(aes(xmin=x, ymin=y, xmax=x+10, ymax=y+10, fill=freq), stat="identity")

ggplot(dat) +
  geom_rect(aes(xmin=x, ymin=y, xmax=x+10, ymax=y+10, fill=freq))
-------------------------------------------------------------------------------------------------------
set.seed(310366)

nx=5
ny=6
SOI=matrix(rnorm(nx*ny,100,50),nx,ny)

colnames(SOI)=paste("NAP_G0",sort(as.integer(runif(ny,10,99))),sep="")
rownames(SOI)=sample(2315101:(2315101+nx-1))
above150 = SOI>150
below30=SOI<30

makeRects <- function(tfMat,border){
  cAbove = expand.grid(1:nx,1:ny)[tfMat,]
  xl=cAbove[,1]-0.49
  yb=cAbove[,2]-0.49
  xr=cAbove[,1]+0.49
  yt=cAbove[,2]+0.49
  rect(xl,yb,xr,yt,border=border,lwd=3)
}

heatmap(t(SOI),Rowv = NA, Colv=NA, add.expr = {
 makeRects(above150,"red");makeRects(below30,"blue")})
-------------------------------------------------------------------------------------------------------
filled.contour rect(0, levels[-length(levels)], 1, levels[-1L], col = col) rect border NA rect(0, levels[-length(levels)], 1, levels[-1L], col = col, border = NA)
-------------------------------------------------------------------------------------------------------
ggplot library(png)
library(grid)
imgfile <- "http://upload.wikimedia.org/wikipedia/commons/e/e1/Tie-dye.png"   
download.file(imgfile,dest="tiedye.png")
r <- readPNG("tiedye.png")
rmat <- matrix(rgb(r[,,1],r[,,2],r[,,3],alpha=0.4),
               nrow=dim(r)[1]) shadow.points <- function(x, y, size=unit(1, "char"), default.units="native", ...) {
 if(!is.unit(x)) {x <- unit(x, default.units) } 
 if(!is.unit(y)) { y <- unit(y, default.units) }
 grid::grid.points(x+0.2*size, y-0.2*size, size=size, gp=gpar(col="black"), pch=20) 
 grid::grid.points(x, y, size=size, default.units=default.units, ...)
} grid.roundrect png("mask.png",width=ncol(r), height=nrow(r), res=1)
grid.roundrect(gp=gpar(fill="black"))
dev.off()
m <- readPNG("mask.png", native=FALSE)
mask <- matrix(rgb(m[,,1],m[,,2],m[,,3]),
               nrow=dim(m)[1])
rmat[mask == "#FFFFFF"] <- "#FFFFFF" grid.newpage()
pushViewport(plotViewport(),
             viewport(xscale=c(0, 10), yscale=c(0, 10)))

grid.raster(rmat,x=unit(0,"native"),y=unit(0,"native"),
            width=1,height=1,just=c(0,0))
grid.roundrect()  ## frame
grid.xaxis(at=seq(2,8,by=2))  ## axes -- shorter to avoid going beyond end of frame
grid.yaxis(at=seq(2,8,by=2))
shadow.points(x=rnorm(10,mean=5),y=rnorm(10,mean=5),pch=20,
            gp=gpar(col="cyan"))
-------------------------------------------------------------------------------------------------------
png("mask.png",width=ncol(r), height=nrow(r), res=1); grid.roundrect(gp=gpar(fill="black")); dev.off()
m <- readPNG("mask.png", native=FALSE)

mask <- matrix(rgb(m[,,1],m[,,2],m[,,3]),
               nrow=dim(m)[1])

rmat[mask == "#FFFFFF"] <- "#FFFFFF"
grid.raster(rmat)
grid.roundrect()
-------------------------------------------------------------------------------------------------------
pupilplot <- function (wf, cp = NULL, col = topo.colors(256), addContours = FALSE, 
cscale = TRUE, ...) 
 {
     if (cscale) {
         mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar
        on.exit(par(par.orig))
        w <- (3 + mar.orig[2]) * par("csi") * 2.54
        layout(matrix(c(2, 1), ncol = 2), widths = c(1, lcm(w)))
        par(las = 1)
        mar <- mar.orig
        mar[4] <- mar[2]
        mar[2] <- 1
        par(mar = mar) 
    thelist <- list(...)  
    findz <- which(names(thelist) == 'zlim')  
    if (length(findz) > 0 ) {   
        zlim <- thelist$zlim  
        }else{  
                zlim <- range(wf, finite = TRUE) #the original line  
        } 
 # end of my hack  
        levels <- seq(zlim[1], zlim[2], length = length(col))
        plot.new()
        plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i", yaxs = "i")
        rect(0, levels[-length(levels)], 1, levels[-1], col = col,  density = NA)
        axis(4)
         box()
        mar <- mar.orig
        mar[4] <- 0
        par(mar = mar)
    }
    if (is.null(cp)) {
        axis1 <- 1:nrow(wf)
        axis2 <- 1:ncol(wf)
    }
    else {
         axis1 <- ((1:nrow(wf)) - cp$xc)/cp$rx
        axis2 <- ((1:ncol(wf)) - cp$yc)/cp$ry
    }
    image(axis1, axis2, wf, col = col, asp = 1, xlab = "X", ylab = "Y",  ...)
     if (addContours) 
        contour(axis1, axis2, wf, add = TRUE)
}
-------------------------------------------------------------------------------------------------------
stackbox <- function(x,y,n,size,maxheight=5){ stackbox <- function(x,y,n,size,maxheight=5,...){
  stackheight = seq(0,n,by=maxheight)
  stackheight=diff(unique(c(stackheight,n)))

  for(col in 1:length(stackheight)){
    xl=rep(x+(col-1)*size,stackheight[col]) - (length(stackheight)/2)*size
    yb=y+size*((1:stackheight[col])-1) - (max(stackheight)/2)*size
    xr=xl+size
    yt=yb+size
    rect(xl,yb,xr,yt,...)
  }
} plot(1:10)
for(i in 1:10){
 stackbox(i,i,i,3,size=.1,col="red",border="white")
} africa=readShapeSpatial(file.path(mapLib,"africa.shp"))
plot(africa,border="gray")
coords=coordinates(africa)
for(i in 1:nrow(africa)){
  if(cases[i]>0){
    stackbox(coords[i,1],coords[i,2],africa$cases[i],1,border="#606060",col="#0083FE")
  }
}
-------------------------------------------------------------------------------------------------------
library(ggplot2)

# Load data.
postH = read.table("~/Downloads/postH.dat")
names(postH) = paste("item", 1:35, sep="") # add column names.
postH$item_id_x = paste("item", 1:35, sep="") # add id column.

# Convert data.frame to long form.
data_long = melt(postH, id.var="item_id_x", variable_name="item_id_y")

# Convert to factor, controlling the order of the factor levels.
data_long$item_id_y = factor(as.character(data_long$item_id_y), 
                        levels=paste("item", 1:35, sep=""))
data_long$item_id_x = factor(as.character(data_long$item_id_x), 
                        levels=paste("item", 1:35, sep=""))

# Create critical value labels in a new column.
data_long$critical_level = ifelse(data_long$value >= 5.45, "high",
                             ifelse(data_long$value <= -5.65, "low", "middle"))

# Convert to labels to factor, controlling the order of the factor levels.
data_long$critical_level = factor(data_long$critical_level,
                                  levels=c("high", "middle", "low"))

# Named vector for ggplot's scale_fill_manual
critical_level_colors = c(high="black", middle="grey80", low="white")

# Calculate grid line positions manually.
x_grid_lines = seq(0.5, length(levels(data_long$item_id_x)), 1)
y_grid_lines = seq(0.5, length(levels(data_long$item_id_y)), 1)

# Create plot.
plot_1 = ggplot(data_long, aes(xmin=as.integer(item_id_x) - 0.5,
                               xmax=as.integer(item_id_x) + 0.5,
                               ymin=as.integer(item_id_y) - 0.5,
                               ymax=as.integer(item_id_y) + 0.5,
                               fill=critical_level)) +
     theme_bw() +
     opts(panel.grid.minor=theme_blank(), panel.grid.major=theme_blank()) +
     coord_cartesian(xlim=c(min(x_grid_lines), max(x_grid_lines)),
                     ylim=c(min(y_grid_lines), max(y_grid_lines))) +
     scale_x_continuous(breaks=seq(1, length(levels(data_long$item_id_x))),
                        labels=levels(data_long$item_id_x)) +
     scale_y_continuous(breaks=seq(1, length(levels(data_long$item_id_x))),
                        labels=levels(data_long$item_id_y)) +
     scale_fill_manual(name="Critical Values", values=critical_level_colors) +
     geom_rect() +
     geom_hline(yintercept=y_grid_lines, colour="grey40", size=0.15) +
     geom_vline(xintercept=x_grid_lines, colour="grey40", size=0.15) +
     opts(axis.text.y=theme_text(size=9)) +
     opts(axis.text.x=theme_text(size=9, angle=90)) +
     opts(title="Critical Values Matrix")

# Save to pdf file.
pdf("plot_1.pdf", height=8.5, width=8.5)
print(plot_1)
dev.off()
-------------------------------------------------------------------------------------------------------
z$x = with(z, factor(x, rev(levels(x)))) legend.position p + opts(legend.position = c(0.85,0.85), 
         legend.background = theme_rect("white"))
-------------------------------------------------------------------------------------------------------
AdjPrices50AvgPercent <-
structure(list(SPY.Adjusted = 3.12, IWM.Adjusted = 4.61, DIA.Adjusted = 4.39, 
    XLI.Adjusted = 4.49, XLB.Adjusted = 2.32, XLF.Adjusted = 2.84, 
    XLE.Adjusted = 3.8, XOP.Adjusted = 5.45, OIH.Adjusted = 0.45, 
    XLY.Adjusted = 3.1, XLP.Adjusted = 3.41, XLV.Adjusted = 2.63, 
    XLU.Adjusted = 1.86, SMH.Adjusted = 1.99, QQQ.Adjusted = 1.2, 
    XHB.Adjusted = 9.46, PPH.Adjusted = 4.41, XME.Adjusted = 3.73, 
    GDX.Adjusted = -0.02, GLD.Adjusted = 0.15, SLV.Adjusted = -1.24, 
    USO.Adjusted = 7.46, MOO.Adjusted = 0.11, KRE.Adjusted = 5.78, 
    KBE.Adjusted = 2.84, XRT.Adjusted = 4.32, VNQ.Adjusted = 3.12, 
    JNK.Adjusted = 2.08, HYG.Adjusted = 2.35, LQD.Adjusted = -0.35, 
    TLT.Adjusted = -0.27, TIP.Adjusted = 0.25, IEF.Adjusted = 0.45, 
    VXX.Adjusted = -9.27), .Names = c("SPY.Adjusted", "IWM.Adjusted", 
"DIA.Adjusted", "XLI.Adjusted", "XLB.Adjusted", "XLF.Adjusted", 
"XLE.Adjusted", "XOP.Adjusted", "OIH.Adjusted", "XLY.Adjusted", 
"XLP.Adjusted", "XLV.Adjusted", "XLU.Adjusted", "SMH.Adjusted", 
"QQQ.Adjusted", "XHB.Adjusted", "PPH.Adjusted", "XME.Adjusted", 
"GDX.Adjusted", "GLD.Adjusted", "SLV.Adjusted", "USO.Adjusted", 
"MOO.Adjusted", "KRE.Adjusted", "KBE.Adjusted", "XRT.Adjusted", 
"VNQ.Adjusted", "JNK.Adjusted", "HYG.Adjusted", "LQD.Adjusted", 
"TLT.Adjusted", "TIP.Adjusted", "IEF.Adjusted", "VXX.Adjusted"
), class = "data.frame", row.names = "2011-12-09") library("reshape2")
ap <- melt(data=AdjPrices50AvgPercent)
ap <- ap[rev(order(ap$value)),]
ap$variable <- factor(ap$variable, levels=ap$variable) ggplot(ap) +
    geom_rect(aes(xmin=0, xmax=1, ymin=0, ymax=1, fill=value)) +
    geom_text(aes(label=variable), x=0.5, y=0.6, size=3) +
    geom_text(aes(label=paste(value,"%",sep="")), x=0.5, y=0.4, size=3) +
    scale_x_continuous(expand=c(0,0)) +
    scale_y_continuous(expand=c(0,0)) +
    scale_fill_gradient2(low="blue", mid="green", high="red", 
                         limits=c(-1,1)*max(abs(ap$value)), breaks=(-9):9) +
    coord_equal() +
    facet_wrap(~variable) +
    opts(axis.text.x = theme_blank(),
         axis.text.y = theme_blank(),
         axis.title.x = theme_blank(),
         axis.title.y = theme_blank(),
         axis.ticks = theme_blank(),
         axis.ticks.margin = unit(0, "mm"),
         strip.background = theme_blank(),
         strip.text.x = theme_blank(),
         panel.margin = unit(0, "mm"),
         panel.background = theme_blank())
-------------------------------------------------------------------------------------------------------
myStripStyle() strip= xyplot() which.panel factor.levels browser() myStripStyle() bgColors <- c("black", "green4", "blue", "red", "purple", "yellow")
txtColors <- c("white", "yellow", "white", "white", "green", "red")

# Create a function to be passes to "strip=" argument of xyplot
myStripStyle <- function(which.panel, factor.levels, ...) {
    panel.rect(0, 0, 1, 1,col = bgColors[which.panel],border = 1)
    panel.text(x = 0.5, y = 0.5,
               font=2,
               lab = factor.levels[which.panel],
               col = txtColors[which.panel])
}    
xyplot(yield ~ year | site, data = barley, strip=myStripStyle)
-------------------------------------------------------------------------------------------------------
rect par(mfrow=c(2, 2))

for(i in unique(ind)) {
  plot(0, col=0, bty="n", xaxt="n", yaxt="n", xlab = i, ylab = "", xlim=c(0, 5), ylim=c(-6, -1))
  for(j in 1:4) {
    for(k in 1:5) {
      rect(j-0.4, -k-1, j+0.4, -k, col = which(unique(mark)==matrix(mark[ind==i], 5, 4)[k,j])+1, border = rgb(0,0,0,0))
      text(j, -k-0.5, labels = matrix(mark[ind==i], 5, 4)[k,j])
    }
    rect(j-0.4, -6, j+0.4, -1)
  }
}
-------------------------------------------------------------------------------------------------------
df <- data.frame(
  xmin = breaks,
  xmax = c(breaks[-1], Inf),
  ymin = 0,
  ymax = density)

ggplot(df, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax)) + 
  geom_rect(colour = "grey80")
-------------------------------------------------------------------------------------------------------
# Some data
x <- 1:1000
y <- rnorm(1000)
z <- 1:1000

# colorRamp produces custom palettes, but needs values between 0 and 1
colorFunction <- colorRamp(c("darkblue", "black", "red"))
zScaled <- (z - min(z)) / (max(z) - min(z))

# Apply colorRamp and switch to hexadecimal representation
zMatrix <- colorFunction(zScaled)
zColors <- rgb(zMatrix, maxColorValue=255)

# Let's plot
plot(x=x, y=y, col=zColors, pch="+") layout # Resolution of the legend
n <- 10

# colorRampPalette produces colors in the same way than colorRamp
plot(x=NA, y=NA, xlim=c(0,n), ylim=0:1, xaxt="n", yaxt="n", xlab="z", ylab="")
pal <- colorRampPalette(c("darkblue", "black", "red"))(n)
rect(xleft=0:(n-1), xright=1:n, ybottom=0, ytop=1, col=pal)

# Custom axis ticks (consider pretty() for an automated generation)
lab <- c(1, 500, 1000)
at <- (lab - min(z)) / (max(z) - min(z)) * n
axis(side=1, at=at, labels=lab)
-------------------------------------------------------------------------------------------------------
filled.contour scatter.fill <- function (x, y, z, 
                              nlevels = 20, plot.title, plot.axes, 
                              key.title, key.axes, asp = NA, xaxs = "i", 
                              yaxs = "i", las = 1, 
                              axes = TRUE, frame.plot = axes, ...) 
    {
        mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar
        on.exit(par(par.orig))
        w <- (3 + mar.orig[2L]) * par("csi") * 2.54
        layout(matrix(c(2, 1), ncol = 2L), widths = c(1, lcm(w)))
        par(las = las)
        mar <- mar.orig
        mar[4L] <- mar[2L]
        mar[2L] <- 1
        par(mar = mar)

        #Some simplified level/color picking
        levels <- seq(min(z),max(z),length.out = nlevels)
  col <- colorRampPalette(c("blue","red"))(nlevels)[rank(z)]

        plot.new()
        plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i", 
            yaxs = "i")
  rect(0, levels[-length(levels)], 1, levels[-1L], col = colorRampPalette(c("blue","red"))(nlevels)
        if (missing(key.axes)) {
            if (axes) 
                axis(4)
        }
        else key.axes
        box()
        if (!missing(key.title)) 
            key.title
        mar <- mar.orig
        mar[4L] <- 1
        par(mar = mar)

        #Simplified scatter plot construction
        plot(x,y,type = "n")
        points(x,y,col = col,...)

        if (missing(plot.axes)) {
            if (axes) {
                title(main = "", xlab = "", ylab = "")
                Axis(x, side = 1)
                Axis(y, side = 2)
            }
        }
        else plot.axes
        if (frame.plot) 
            box()
        if (missing(plot.title)) 
            title(...)
        else plot.title
        invisible()
    } x <- runif(40)
y <- runif(40)
z <- runif(40)
scatter.fill(x,y,z,nlevels = 40,pch = 20) filled.contour
-------------------------------------------------------------------------------------------------------
rect d <- as.matrix(read.table("http://dl.dropbox.com/u/2505196/postH.dat"))
#remove upper half of the values (as they are mirrored values)
d[upper.tri(d)] <- NA
dat <- within(as.data.frame(as.table(d)),{
Var1 <- as.numeric(Var1)
Var2 <- as.numeric(Var2)})
par(mar=c(6,3,3,6))
colPh=c("gray50","gray90","black")
plot(dat$Var1,dat$Var2,bg = colPh[1+findInterval(dat$Freq, c(-5.45,5.45))],
    col="white",cex=1.2,pch = 21,axes=F,xlab="",ylab="")
labDis <- rep(c("A","B","C","D","E"),times=7)
labChar <- c(1:7)
axis(1,at=1:35,labels=labDis,cex.axis=0.5,tick=F,line=-1.4)
axis(1,at=seq(3,33,5),labels=labChar, tick=F)
#drawing lines above axis for better identification
rect(1,0,5,0,angle=90);rect(6,0,10,0,angle=90);rect(11,0,15,0,angle=90);
rect(16,0,20,0,angle=90);rect(21,0,25,0,angle=90);rect(26,0,30,0,angle=90);
rect(31,0,35,0,angle=90)
axis(4,at=1:35,labels=labDis,cex.axis=0.5,tick=F,line=-1.4)
axis(4,at=seq(3,33,5),labels=labChar,tick=F)
#drawing lines above axis for better identification
rect(36,1,36,5,angle=90);rect(36,6,36,10,angle=90);rect(36,11,36,15,angle=90);
rect(36,16,36,20,angle=90);rect(36,21,36,25,angle=90);rect(36,26,36,30,angle=90);
rect(36,31,36,35,angle=90)
legend("topleft",legend=c("not significant","p<0.01","p<0.05"),pch=16,
col=c("gray90","gray50","black"),cex=0.7,bty="n")
-------------------------------------------------------------------------------------------------------
# top panel
ggplot(mydf, aes(position, factor(group), size = barheight)) + 
  geom_point() + opts(legend.position = "none")

# bottom panel
ggplot(mydf, aes(y = factor(group), 
                 xmin = position - 0.1, 
                 xmax = position + 0.1, 
                 ymin = group - barheight/2,
                 ymax = group + barheight/2)) + 
  geom_rect() # arbitral bar length
bar <- data.frame(y = c(1, 1, 2, 2), x = c(0, 10, 1, 9))

ggplot() +
  geom_line(aes(x, factor(y), group = factor(y)), 
            bar, size = 2, colour = "skyblue") +
  geom_rect(aes(y = factor(group),
                xmin = position - 0.1, 
                xmax = position + 0.1, 
                ymin = group - barheight/2,
                ymax = group + barheight/2),
            mydf)

# bar length is from data range
ggplot(mydf) +
  geom_line(aes(position, factor(group), group = factor(group)),
            size = 2, colour = "skyblue") +
  geom_rect(aes(y = factor(group),
                xmin = position - 0.1, 
                xmax = position + 0.1, 
                ymin = group - barheight/2,
                ymax = group + barheight/2)) geom_tile ggplot(mydf, aes(position, factor(group), group = factor(group))) +
   geom_line(size = 2, colour = "skyblue") +
   geom_tile(aes(height = barheight)) ggplot(mydf, aes(position, factor(group), group = factor(group))) +
   geom_line(size = 2, colour = "skyblue") +
   geom_tile(aes(height = barheight)) +
   geom_point(aes(x, y, group = NULL), data.frame(x = c(5, 5), y = c(1, 2)),
     size = 5, colour = "cyan")
-------------------------------------------------------------------------------------------------------
rect() usr plot(1:10, 1:10, type = "n", axes = FALSE) ## no axes
lim <- par("usr")
rect(2, lim[3]-1, 4, lim[4]+1, border = "red", col = "red")
axis(1) ## add axes back
axis(2)
box()   ## and the plot frame rect() X <- c(1,3)
Y <- c(2,4)
plot(1:10, 1:10, type = "n", axes = FALSE) ## no axes
lim <- par("usr")
rect(X[1], Y[1], X[2], Y[2], border = "red", col = "red")
axis(1) ## add axes back
axis(2)
box()   ## and the plot frame botleft <- c(1,2)
topright <- c(3,4)
plot(1:10, 1:10, type = "n", axes = FALSE) ## no axes
lim <- par("usr")
rect(botleft[1], botleft[2], topright[1], topright[2], border = "red",col = "red")
axis(1) ## add axes back
axis(2)
box()   ## and the plot frame
-------------------------------------------------------------------------------------------------------
x <- seq(-10, 10, 0.1)
df <- data.frame(x, y1 = pnorm(x), y2 = pnorm(x) * 2)
df$t <- df$y2 - df$y1
dfm <- melt(df, id = "x")

ggplot(NULL, aes(x, value)) + 
  geom_line(aes(colour = variable), 
            droplevels(subset(dfm, variable %in% c("y1", "y2")))) +
  geom_rect(aes(xmin = x - 0.05, xmax = x + 0.05, ymin = -0.5, ymax = -0.4, fill = value),
            subset(dfm, variable == "t")) scale_fill_XXX jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan","#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))

# panel on the left side
p <- ggplot(NULL, aes(x, value)) + 
  geom_line(aes(colour = variable), 
            droplevels(subset(dfm, variable %in% c("y1", "y2")))) +
  geom_rect(aes(xmin = x - 0.05, xmax = x + 0.05, ymin = -0.5, ymax = -0.4, fill = value),
            subset(dfm, variable == "t")) + 
  scale_fill_gradientn(colours = jet.colors(7))
p # panel on the right side
  p + guides(fill = "colourbar")
-------------------------------------------------------------------------------------------------------
words library(wordcloud)

colored.wordcloud <- function(words,freq,scale=c(4,.5),min.freq=3,max.words=Inf,random.order=TRUE,random.color=FALSE,
        rot.per=.1,colors="black",ordered.colors=FALSE,use.r.layout=FALSE,...) { 
    tails <- "g|j|p|q|y"
    last <- 1
    nc<- length(colors)

    if (ordered.colors) {
        if (length(colors) != 1 && length(colors) != length(words)) {
            stop(paste("Length of colors does not match length of words",
                       "vector"))
        }
    }

    overlap <- function(x1, y1, sw1, sh1) {
        if(!use.r.layout)
            return(.overlap(x1,y1,sw1,sh1,boxes))
        s <- 0
        if (length(boxes) == 0) 
            return(FALSE)
        for (i in c(last,1:length(boxes))) {
            bnds <- boxes[[i]]
            x2 <- bnds[1]
            y2 <- bnds[2]
            sw2 <- bnds[3]
            sh2 <- bnds[4]
            if (x1 < x2) 
                overlap <- x1 + sw1 > x2-s
            else 
                overlap <- x2 + sw2 > x1-s

            if (y1 < y2) 
                overlap <- overlap && (y1 + sh1 > y2-s)
            else 
                overlap <- overlap && (y2 + sh2 > y1-s)
            if(overlap){
                last <<- i
                return(TRUE)
            }
        }
        FALSE
    }

    ord <- rank(-freq, ties.method = "random")
    words <- words[ord<=max.words]
    freq <- freq[ord<=max.words]
    if (ordered.colors) {
        colors <- colors[ord<=max.words]
    }

    if(random.order)
        ord <- sample.int(length(words))
    else
        ord <- order(freq,decreasing=TRUE)
    words <- words[ord]
    freq <- freq[ord]
    words <- words[freq>=min.freq]
    freq <- freq[freq>=min.freq]
    if (ordered.colors) {
        colors <- colors[ord][freq>=min.freq]
    }

    thetaStep <- .1
    rStep <- .05
    plot.new()
    op <- par("mar")
    par(mar=c(0,0,0,0))
    plot.window(c(0,1),c(0,1),asp=1)
    normedFreq <- freq/max(freq)
    size <- (scale[1]-scale[2])*normedFreq + scale[2]
    boxes <- list()



    for(i in 1:length(words)){
        rotWord <- runif(1)<rot.per
        r <-0
        theta <- runif(1,0,2*pi)
        x1<-.5
        y1<-.5
        wid <- strwidth(words[i],cex=size[i],...)
        ht <- strheight(words[i],cex=size[i],...)
        #mind your ps and qs
        if(grepl(tails,words[i]))
            ht <- ht + ht*.2
        if(rotWord){
            tmp <- ht
            ht <- wid
            wid <- tmp  
        }
        isOverlaped <- TRUE
        while(isOverlaped){
            if(!overlap(x1-.5*wid,y1-.5*ht,wid,ht) &&
                    x1-.5*wid>0 && y1-.5*ht>0 &&
                    x1+.5*wid<1 && y1+.5*ht<1){
        if (!random.color) {
                if (ordered.colors) {
                    cc <- colors[i]
                }
                else {
                    cc <- ceiling(nc*normedFreq[i])
                    cc <- colors[cc]
                }
        } else {
         cc <- colors[sample(1:nc,1)]
        }
                text(x1,y1,words[i],cex=size[i],offset=0,srt=rotWord*90,
                        col=cc,...)
                #rec(x1-.5*wid,y1-.5*ht,x1+.5*wid,y1+.5*ht)
                boxes[[length(boxes)+1]] <- c(x1-.5*wid,y1-.5*ht,wid,ht)
                isOverlaped <- FALSE
            }else{
                if(r>sqrt(.5)){
                    warning(paste(words[i],
                                    "could not be fit on page. It will not be plotted."))
                    isOverlaped <- FALSE
                }
                theta <- theta+thetaStep
                r <- r + rStep*thetaStep/(2*pi)
                x1 <- .5+r*cos(theta)
                y1 <- .5+r*sin(theta)
            }
        }
    }
    par(mar=op)
    invisible()
} colors = c("blue", "red", "orange", "green")
colored.wordcloud(colors, c(10, 5, 3, 9), colors=colors)
-------------------------------------------------------------------------------------------------------
barp plotrix barp barplot(...,beside=TRUE) barplot(...,beside=FALSE) rect % mybarplot( x, col=heat.colors(255), space=0.2, labels=NULL )
% makes a stacked bar plot with ncol(x) bars, each containing nrow(x)
%  stacks. Coloured according to a *global* colour scale (by value of top edge
%  of the box within the stack). This is as opposed to the same colour 
%  per category across all bars.
%
% PARAMETERS
% ----------
% x     : a matrix. COLUMNS are the categories, ROWS contain the data.
% col   : colour scheme to use. e.g. heat.colors, rainbow, ...
% space : space between bars as a fraction of bar width.
% labels: labels for each category (column) of x, default colnames(x)
%
% EXAMPLE
% -------
% bar plot with 3 categories/bars, 4 stacks in each bar.
% data <- matrix(runif(12),ncol=3,nrow=4)
% colnames(data)<-c('group a','group b','group c')
% mybarplot(data,col=heat.colors(20))
%
mybarplot <- function( x, col=heat.colors(255), space=0.2, labels=colnames(x) )
{
 maxy <- max(x)
 miny <- 0
 n    <- ncol(x)
 m    <- nrow(x)
 wid  <- 1

 # work out boundaries of each rectangle
 # note: sort the y's ascending to draw properly.
 xsort  <- apply(x,2,sort)
 xright <- rep(1:n, m) * (wid+space) - space
 ybottom <- as.vector(t(rbind(miny,xsort)))

 # work out colour of each rectangle,
 # being (y/maxy) along the colour scale.
 fracs<-as.vector(t(xsort))/maxy
 cols <- col[round(fracs*(length(col)-1))+1]

 # plot: set up grid and then draw rectangles
 plot(0, 0, type="n", 
      ylim=c(miny,maxy), xlim=c(0,max(xright)),
      xaxt='n',yaxt='n',xlab=NA,ylab=NA)
 rect(xright-wid, ybottom[1:(length(ybottom)-n)], xright, ybottom[-(1:n)],
      col=cols)

 # draw labels
 axis(1, cex.axis=0.5, las=2, at=xright[1:n]-(space+wid)/2, labels=labels)
 axis(2, cex.axis=0.5, pos=-0.5)
} mybarplot(test) fracs axis xright[1:n]-(space+wid)/2 mybarplot xLabLocs <- mybarplot(test) axis
-------------------------------------------------------------------------------------------------------
chart_high_mom <- function(fontsize, titlesize, geomtextsize, ftitle,
    x = NULL, # a data frame containing the data to plot
    datecol, # name of column holding yyyy-mm-dd date series
    valcol, # name of column holding value to use for calculation
    fstartdate, # date in yyyy-mm-dd format specifying first date to plot
    fenddate # date in yyyy-mm-dd format specifying last date to plot
                         ) {


    # strip the data frame down
    x <- subset(x,select = c(datecol,valcol))
    colnames(x) <- c('mydate','myval')
    # create year and month columns
    x$year <- as.numeric(format(as.Date(x$mydate), format="%Y"))
    x$month <- as.numeric(format(as.Date(x$mydate), format="%m"))
    # create month-on-month change column
    mydata.xts <- xts(x$myval,order.by=x$mydate)
    x$myvalmom <- diff(mydata.xts,lag=1)/lag(mydata.xts,1)

    plotlist <- list()


        print(paste("i = ",i," and fontsize = ",fontsize," and titlesize = ",titlesize,sep=""))

        thisplot <- ggplot(x[x$mydate>=fstartdate &
                                             x$mydate<=fenddate,], 
            aes(x=month(mydate,label=TRUE),y=year(mydate), 
             fill = myvalmom, label = sprintf("%1.1f%%", 100*myvalmom))) + 
                    scale_y_date(major="years", format="%Y") +
                    geom_tile() + 
                    geom_text(data=x[x$mydate>=fstartdate &
                         x$mydate<=fenddate,],size = geomtextsize, 
                         colour = "black") +
          scale_fill_gradient2(low = "blue", high = "red",midpoint=0) +
          scale_x_discrete(expand=c(0,0)) +
      scale_y_reverse(breaks=1980:2012, labels=1980:2012, expand=c(0,0) ) +
          force(opts(axis.text.y = 
                  theme_text(size = force(fontsize), colour = "grey50"),
               axis.text.x = theme_text(size = force(fontsize), colour = "grey50"),
          plot.title = theme_text(size = titlesize),
          title = ftitle,
          panel.grid.minor = theme_blank(),
          axis.ticks = theme_blank(),
          panel.grid.major = theme_blank(),
          axis.title.y = theme_blank(),
          axis.title.x = theme_blank(),
          panel.background = theme_rect(fill = "transparent",colour = NA),
          legend.position = "none"
          ))
return(thisplot)

    } set.seed(12345)
mydf <- data.frame(passdate=seq(as.Date("1995/1/1"), by="month", length.out=204),passval=runif(204, min=25, max=100),ignoreval=runif(204, min=-21, max=-2))

myplots <- list()

for (i in 1:2) { # loop to create plot with two different sets of font sizes
              if (i == 1) {
            print(fontsize <- 8)
            print(titlesize <- 32)
            print(geomtextsize <- 4)
            print(ftitle <- "medium");  
     myplots[[1]] <-chart_high_mom(fontsize= fontsize , titlesize= titlesize , geomtextsize= geomtextsize , ftitle= ftitle , x=mydf, 'passdate', 'passval', '1995-02-01', '2011-12-31')
      png(filename = "chart1.png", width = 700, height = 600, units = "px", res = NA)
print(myplots[[1]])
dev.off()             }
        if (i == 2) {
            fontsize <- 24
            titlesize <- 12
            geomtextsize <- 5
            ftitle <- "large"; 
     myplots[[2]] <-chart_high_mom(fontsize= fontsize , titlesize= titlesize , geomtextsize= geomtextsize , ftitle= ftitle , x=mydf, 'passdate', 'passval', '1995-02-01', '2011-12-31')
      png(filename = "chart2.png", width = 700, height = 600, units = "px", res = NA)
print(myplots[[2]])
dev.off()      }       }
# end of calling code
-------------------------------------------------------------------------------------------------------
rect par("usr") library(quantmod)
getSymbols("A")
plot( index(A), coredata(Ad(A)), type="n" )
# This example uses calendar years: adapt as needed
dates <- c( 
  ISOdate( year(min(index(A))),     1, 1 ),
  ISOdate( year(max(index(A))) + 1, 1, 1 )
)
dates <- as.Date(dates)
dates <- seq.Date(dates[1], dates[2], by="2 year")
rect( 
  dates, 
  par("usr")[3], 
  as.Date( ISOdate( year(dates) + 1, 1, 1 ) ),
  par("usr")[4], 
  col="grey",
  border=NA
)
lines(index(A), coredata(Ad(A)), lwd=3)
-------------------------------------------------------------------------------------------------------
geom_rect ... + geom_rect(aes(xmin=159683.438, xmax=159684.186, ymin=0, ymax=Inf)) geom_vline ymin=0 ymax=Inf ymin=-Inf aes alpha
-------------------------------------------------------------------------------------------------------
rect zoo zoo library(zoo)
#random data combined with time series that starts in 2009-01
v <- zooreg(rnorm(37), start = as.yearmon("2009-1"), freq=12)
plot(v, type = "n",xlab="",xaxt="n")
#this will catch some min and max values for y-axis points in rect
u <- par("usr")
#plot green rect - notice that x-coordinates are defined by date points
rect(as.yearmon("2009-6-30"), u[3], as.yearmon("2010-7-1"), u[4], 
        border = 0, col = "lightgreen")
lines(v)
axis(1, floor(time(v)))
#customized x-axis labels based on dates values
axis(1,at=c(2009.4, 2010.5),padj=-2,lty=0,labels=c("start","end"),cex.axis=0.8)
-------------------------------------------------------------------------------------------------------
# Function to plot color bar
color.bar <- function(lut, min, max=-min, nticks=11, ticks=seq(min, max, len=nticks), title='') {
    scale = (length(lut)-1)/(max-min)

    dev.new(width=1.75, height=5)
    plot(c(0,10), c(min,max), type='n', bty='n', xaxt='n', xlab='', yaxt='n', ylab='', main=title)
    axis(2, ticks, las=1)
    for (i in 1:(length(lut)-1)) {
     y = (i-1)/scale + min
     rect(0,y,10,y+1/scale, col=lut[i], border=NA)
    }
} > color.bar(colorRampPalette(c("light green", "yellow", "orange", "red"))(100), -1)
-------------------------------------------------------------------------------------------------------
library(ggplot2)

dat <- data.frame(
    x = 1:20,
    y = c(0.5, 1.4, 2.3, 3.4, 4.5, 3.3, 3.0, 2.1, 1.5, 0, 0, 3.4, 4.5, 6.7, 5.3, 2.8, 0.5, 3.4, 3.5,  3.7)
) getRange <- function(x, a=1, b=2){
  maxy <- max(x)
  xMax <- which.max(x)
  x2 <- max(which(x[1:xMax] <= (maxy-a)))
  x1 <- max(which(x[1:x2] <= (maxy-b)))
  x3 <- xMax + min(which(x[-(1:xMax)] < (maxy+a)))
  x4 <- x3 + min(which(x[-(1:x3)] < (maxy+b)))
  data.frame(x1=x1, x2=x2, max=xMax, x3=x3, x4=x4)
} rr <- getRange(dat$y, 1, 3)

ggplot(dat, aes(x, y)) + geom_line() + geom_point() +
    
-------------------------------------------------------------------------------------------------------
position_dodge() ToothGrowth$dose.cat <- factor(ToothGrowth$dose, labels=paste("d", 1:3, sep=""))
df <- with(ToothGrowth , aggregate(len, list(supp=supp, dose=dose.cat), mean))
df$se <- with(ToothGrowth , aggregate(len, list(supp=supp, dose=dose.cat), 
              function(x) sd(x)/sqrt(10)))[,3]

opar <- theme_update(panel.grid.major = theme_blank(),
                     panel.grid.minor = theme_blank(),
                     panel.background = theme_rect(colour = "black"))

xgap <- position_dodge(0.2)
gp <- ggplot(df, aes(x=dose, y=x, colour=supp, group=supp))
gp + geom_line(aes(linetype=supp), size=.6, position=xgap) + 
     geom_point(aes(shape=supp), size=3, position=xgap) + 
     geom_errorbar(aes(ymax=x+se, ymin=x-se), width=.1, position=xgap)
theme_set(opar)
-------------------------------------------------------------------------------------------------------
par.strip.text par.strip.text bgColors <- c("black", "green4", "blue", "red", "purple", "yellow")
txtColors <- c("white", "yellow", "white", "white", "green", "red")

# Create a function to be passes to "strip=" argument of xyplot
myStripStyle <- function(which.panel, factor.levels, par.strip.text,
                     custBgCol=par.strip.text$custBgCol,
                     custTxtCol=par.strip.text$custTxtCol,...)     {
    panel.rect(0, 0, 1, 1,col = custBgCol[which.panel],border = 1)
    panel.text(x = 0.5, y = 0.5,
            font=2,
            lab = factor.levels[which.panel],
            col = custTxtCol[which.panel])
}
xyplot(yield ~ year | site, data = barley,
        par.strip.text=list(custBgCol=bgColors,
                            custTxtCol=txtColors),
        strip=myStripStyle)
-------------------------------------------------------------------------------------------------------
fields:::image.plot par("fg" = NA)
    plot(r, xlim = c(xmin(r), xmax(r)), ylim = c(ymin(r), ymax(r)), axes = FALSE)
    par(new = TRUE,"fg" = "black")
    plot(r, xlim = c(xmin(r), xmax(r)), ylim = c(ymin(r), ymax(r)), axes = FALSE, legend.only = TRUE)
    axis(1, pos = -90, xpd = TRUE)
    rect(-180,-90,180,90,xpd = TRUE)
    ticks <- (ymin(r):ymax(r))[(ymin(r):ymax(r)) %% 20 == 0]
    segments(xmin(r),ticks,xmin(r)-5,ticks, xpd = TRUE)
    text(xmin(r),ticks,ticks,xpd=TRUE,pos=2)
        title("sorry, this could probably be done in some more elegant way")
-------------------------------------------------------------------------------------------------------
plot(pos, type = 'n', xlim = range(c(start, end)), ylim = c(13,0))
grid()
segments(start, pos, end, pos) r <- par('usr') 
plot(pos, type = 'n', xlim = range(c(start, end)), ylim = c(13.5,0.5), xlab = '', 
    xaxt = 'n', yaxt = 'n', panel.first = rect(r[1], r[3], r[2], r[4], col = 'goldenrod'))
# abline(h = 1:13, col = 'white')
# abline(v = 1:13, col = 'white')
grid(lty = 1, col = 'white')
axis(1, 1:13, 1:13, cex.axis = 0.8)
axis(2, 1:13, 1:13, las = 1, cex.axis = 0.8)
segments(start, pos + 0.5, end, pos + 0.5, lwd = 2)
-------------------------------------------------------------------------------------------------------
last_plot() + theme_bw() last_plot() + 
   opts(panel.background = theme_rect(fill=NA, col="black")) opts theme last_plot() + 
   theme(panel.background = element_rect(fill=NA, col="black"))
-------------------------------------------------------------------------------------------------------
library(grid)

N <- 1e7 # Warning: slow
d <- data.frame(x1=rnorm(N),
                x2=rnorm(N, 0.8, 0.9),
                y=rnorm(N, 0.8, 0.2),
                z=rnorm(N, 0.2, 0.4))

v <- with(d, dataViewport(c(x1,x2),c(y, z)))

png("layer1.png", bg="transparent")
with(d, grid.points(x1,y, vp=v,default="native",pch=".",gp=gpar(col="blue")))
dev.off()
png("layer2.png", bg="transparent")
with(d, grid.points(x2,z, vp=v,default="native",pch=".",gp=gpar(col="red")))
dev.off()

library(png)
i1 <- readPNG("layer1.png", native=FALSE)
i2 <- readPNG("layer2.png", native=FALSE)

ghostize <- function(r, alpha=0.5)
  matrix(adjustcolor(rgb(r[,,1],r[,,2],r[,,3],r[,,4]), alpha.f=alpha), nrow=dim(r)[1])

grid.newpage()
grid.rect(gp=gpar(fill="white"))
grid.raster(ghostize(i1))
grid.raster(ghostize(i2)) ggplot2
-------------------------------------------------------------------------------------------------------
useOuterStrips() bwplot() # Create a function to be passes to "strip=" argument of xyplot
myStripStyle <- function(which.panel, factor.levels, ...) {
    panel.rect(0, 0, 1, 1,col = bgColors[which.panel], border = 1)
    ## This call to panel.text() commented out because it does not
    ## work as I would have expected/hoped it to
    # panel.text(x = 0.5, y = 0.5,
    #            font=2,
    #            lab = factor.levels[which.panel],
    #            col = "black")
}

mycola <- rainbow(6)
bgColors <- mycola

useOuterStrips(bwplot(~B$ylab|B$g1*B$g2,ylab="",xlab="",as.table=TRUE,
                      panel=function(...,bg){
                          panel.fill(col=mycol[panel.number()])
                      },
                      scale=list(draw=FALSE)),
               strip = myStripStyle,
               strip.left = myStripStyle)
-------------------------------------------------------------------------------------------------------
# make a data series
my.stat <- rnorm(100,sd=2.5)
# get its standard dev:
my.sd <- sd(my.stat)
# convert series to distance in sd:
my.lj.stat <- (my.stat - mean(my.stat)) / my.sd

plot(1:100, my.lj.stat, type = "o", pch = 19, col = "blue", ylab = "sd", xlab = "observation",
    main = paste("mean value of", round(mean(my.stat),3),"\nstandard deviation of",round(my.sd,3)))

# a low tech L-J chart function:
LJchart <- function(series, ...){
    xbar        <- mean(series)
    se          <- sd(series)
    conv.series <- (my.stat - xbar) / se

    plot(1:length(series), conv.series, type = "o", pch = 19, col = "blue", ylab = "sd", xlab = "observation",
        main = paste("mean value of", round(xbar,3), "\nstandard deviation of", round(se,3)), ...)
}

LJchart(rnorm(100,sd=2.5)) ... ... LJchart <- function(series, ...){
    xbar        <- mean(series)
    se          <- sd(series)
    conv.series <- (my.stat - xbar) / se

    plot(1:length(series), conv.series, type = "n", ...)
    rect(0, -1, length(series)+1, 1, col = gray(.9), border = NA)
    lines(1:length(series), conv.series, ...)
    points(1:length(series), conv.series, ...)
    if (! "main" %in% names(list(...))) {
        title(paste("mean value of", round(xbar,3), "\nstandard deviation of", round(se,3)))
    }
}

LJchart(rnorm(100,sd=2.5), xlab = "observations", ylab = "sd", col = "blue", pch = 19)
-------------------------------------------------------------------------------------------------------
#Create a data frame with the faceting variables
# and some dummy data (that will be overwritten)
tp <- unique(tips[,c('sex','day')])
tp$total_bill <- tp$tip <- 1

#Just Fri
ggplot(tips,aes(x=total_bill, y = tip/total_bill)) + 
        geom_rect(data = subset(tp,day == 'Fri'),aes(fill = day),xmin = -Inf,xmax = Inf,ymin = -Inf,ymax = Inf,alpha = 0.3) +
        geom_point(shape=1) + 
        facet_grid(sex ~ day) #Each panel
ggplot(tips,aes(x=total_bill, y = tip/total_bill)) + 
        geom_rect(data = tp,aes(fill = day),xmin = -Inf,xmax = Inf,ymin = -Inf,ymax = Inf,alpha = 0.3) +
        geom_point(shape=1) + 
        facet_grid(sex ~ day)
-------------------------------------------------------------------------------------------------------
plotGantt <- function(data, res.col='resources', 
                      start.col='start', end.col='end', res.colors=rainbow(30))
{
  #slightly enlarge Y axis margin to make space for labels
  op <- par('mar')
  par(mar = op + c(0,1.2,0,0)) 

  minval <- min(data[,start.col])
  maxval <- max(data[,end.col])

  res.colors <- rev(res.colors)
  resources <- sort(unique(data[,res.col]),decreasing=T)

  plot(c(minval,maxval),
       c(0.5,length(resources)+0.5),
       type='n', xlab='Duration',ylab=NA,yaxt='n' )
  axis(side=2,at=1:length(resources),labels=resources,las=1)
  for(i in 1:length(resources))
  {
    yTop <- i+0.1
    yBottom <- i-0.1
    subset <- data[data[,res.col] == resources[i],]
    for(r in 1:nrow(subset))
    {
      color <- res.colors[((i-1)%%length(res.colors))+1]
      start <- subset[r,start.col]
      end <- subset[r,end.col]
      rect(start,yBottom,end,yTop,col=color)
    }
  }
  par(op) # reset the plotting margins
} data <- read.table(text=
'"person","n","start","end"
"sam",6,0,6
"greg",5,6,11
"teacher",4,11,15
"sam",4,15,19
"greg",5,19,24
"sally",5,24,29
"greg",4,29,33
"sam",3,33,36
"sally",5,36,41
"researcher",6,41,47
"greg",6,47,53',sep=',',header=T)

plotGantt(data, res.col='person',start.col='start',end.col='end',
          res.colors=c('green','blue','brown','red','yellow'))
-------------------------------------------------------------------------------------------------------
library(grid)
epsilon <- 1e-4
grid.newpage()
grid.points(x=c(0.5-epsilon,0.5+epsilon), y=c(0.5,0.5), pch="+", gp=gpar(cex=2), def="npc")
grid.segments(0.5-epsilon, 0.5, 0.5+epsilon, 0.5, gp=gpar(lineend="square",lwd=50, alpha=0.2))
grid.segments(0.5-epsilon, 0.5, 0.5+epsilon, 0.5, gp=gpar(lineend="round",lwd=50, alpha=0.2))
grid.segments(0.5-epsilon, 0.5, 0.5+epsilon, 0.5, gp=gpar(lineend="butt",lwd=50, alpha=0.2)) grid.newpage()
grid.rect(x=0.5, y=0.5, width=0.01, height=0, gp=gpar(fill="black", col="red", lwd=10, linejoin="mitre"))
-------------------------------------------------------------------------------------------------------
xdiff <- max(as.numeric(z)) - min(as.numeric(z))
segwidth <- xdiff/50

plot(z,x,type='n')
rect(z-segwidth/2, x, z+segwidth/2, y, col="black")
-------------------------------------------------------------------------------------------------------
for if (i == 1 & j == 2){
   mtext("This title should be centered according to the plot matrix", side=3,
        line=2, outer=FALSE, adj=0.5, at=0.5)
} outer = FALSE d <- 4
d2 <- d*d
layout.mat <- matrix(1:d2, byrow=TRUE, ncol=d) # plot matrix
layout.mat <- cbind(layout.mat, rep(0, d)) # space
layout.mat <- cbind(layout.mat, rep(d2+1, d)) # column on the right side
layout.mat <- rbind(c(rep(18,d),0,0),layout.mat) #Add row on top
wspace <- 6*par("csi")*2.54 # width of the space in character height in cm
wside <- 3*par("csi")*2.54 # width of the right side in character height in cm
#Note adjustments to heights
layout(layout.mat, respect=TRUE, widths=c(rep(1, d), lcm(wspace), lcm(wside)),
       heights = c(0.25,rep(1,nrow(layout.mat)-1)))
layout.show(d2+1)
par(mar=rep(0, 4), oma=c(4,4,6,4))
for(i in 1:d){
    for(j in 1:d){
        plot.new()
        plot.window(xlim=c(0,1), ylim=c(0,1))
        ll <- par("usr")
        rect(ll[1], ll[3], ll[2], ll[4])
        text(0.5, 0.5, paste("i=",i,", j=",j,sep=""), cex=1.4)
    }
}
plot.new()
plot.window(xlim=c(0,1), ylim=c(0,1))
ll <- par("usr")
rect(ll[1], ll[3], ll[2], ll[4])
text(0.5, 0.5, "side", cex=1.4)

## title
plot.new()
plot.window(xlim=c(0,1), ylim=c(0,1))
ll <- par("usr")
#rect(ll[1], ll[3], ll[2], ll[4])
text(0.5, 0.5, "top", cex=1.4)
-------------------------------------------------------------------------------------------------------
#Fake data
dat <- data.frame(x = 1:100, y = cumsum(rnorm(100)))
#Breaks for background rectangles
rects <- data.frame(xstart = seq(0,80,20), xend = seq(20,100,20), col = letters[1:5])


#As Baptiste points out, the order of the geom's matters, so putting your data as last will 
#make sure that it is plotted "on top" of the background rectangles. Updated code, but
#did not update the JPEG...I think you'll get the point.

ggplot() + 
  geom_rect(data = rects, aes(xmin = xstart, xmax = xend, ymin = -Inf, ymax = Inf, fill = col), alpha = 0.4) +
  geom_line(data = dat, aes(x,y))
-------------------------------------------------------------------------------------------------------
+ opts(panel.background = theme_rect(), panel.grid.major = theme_line( colour = "white") ) geom_bar background <- data.frame( lower = seq( 0  , 3  , 1.5 ), 
                          upper = seq( 1.5, 4.5, 1.5 ), col = letters[1:3])
ggplot() + 
geom_bar( data = mtcars , aes( factor(cyl) ) ) + 
geom_rect( data = background , mapping = aes( xmin = lower , 
xmax = upper , ymin = 0 , ymax = 14 , fill = col ) , alpha = .5 ) + 
geom_bar( data = mtcars, aes(factor(cyl))) + opts(panel.background = theme_rect(), 
panel.grid.major = theme_line( colour = "white") )
-------------------------------------------------------------------------------------------------------
"a" "b" rects scores scores rects$col <- c("Z1","Z2","Z3","Z4","Z5") scale_fill_manual ggplot() + 
geom_rect(data = rects, aes(xmin = -Inf, xmax = Inf, ymin = ystart, 
                            ymax = yend, fill=col), alpha = 0.3) + 
opts(legend.position="none") + 
geom_bar(data=scores, aes(x=category, y=percentage, fill=type), stat="identity") +
scale_fill_manual(values=c("indianred1", "indianred4", medals)) +
scale_x_continuous(breaks = 1:4, labels = labels)
-------------------------------------------------------------------------------------------------------
map('state', plot = TRUE, fill = FALSE, col = palette()) import math
from collections import defaultdict

to_rad = math.pi / 180.0   # convert lat or lng to radians
fname = "site.tsv"        # file format: LAT\tLONG
threshhold_dist=50         # adjust to your needs
threshhold_locations=15    # minimum # of locations needed in a cluster

def dist(lat1,lng1,lat2,lng2):
    global to_rad
    earth_radius_km = 6371

    dLat = (lat2-lat1) * to_rad
    dLon = (lng2-lng1) * to_rad
    lat1_rad = lat1 * to_rad
    lat2_rad = lat2 * to_rad

    a = math.sin(dLat/2) * math.sin(dLat/2) + math.sin(dLon/2) * math.sin(dLon/2) * math.cos(lat1_rad) * math.cos(lat2_rad)
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a)); 
    dist = earth_radius_km * c
    return dist

def bounding_box(src, neighbors):
    neighbors.append(src)
    # nw = NorthWest se=SouthEast
    nw_lat = -360
    nw_lng = 360
    se_lat = 360
    se_lng = -360

    for (y,x) in neighbors:
        if y > nw_lat: nw_lat = y
        if x > se_lng: se_lng = x

        if y < se_lat: se_lat = y
        if x < nw_lng: nw_lng = x

    # add some padding
    pad = 0.5
    nw_lat += pad
    nw_lng -= pad
    se_lat -= pad
    se_lng += pad

    # sutiable for r's map() function
    return (se_lat,nw_lat,nw_lng,se_lng)

def sitesDist(site1,site2): 
    #just a helper to shorted list comprehension below 
    return dist(site1[0],site1[1], site2[0], site2[1])

def load_site_data():
    global fname
    sites = defaultdict(tuple)

    data = open(fname,encoding="latin-1")
    data.readline() # skip header
    for line in data:
        line = line[:-1]
        slots = line.split("\t")
        lat = float(slots[0])
        lng = float(slots[1])
        lat_rad = lat * math.pi / 180.0
        lng_rad = lng * math.pi / 180.0
        sites[(lat,lng)] = (lat,lng) #(lat_rad,lng_rad)
    return sites

def main():
    sites_dict = {}
    sites = load_site_data()
    for site in sites: 
        #for each site put it in a dictionary with its value being an array of neighbors 
        sites_dict[site] = [x for x in sites if x != site and sitesDist(site,x) < threshhold_dist] 

    results = {}
    for site in sites: 
        j = len(sites_dict[site])
        if j >= threshhold_locations:
            coord = bounding_box( site, sites_dict[site] )
            results[coord] = coord

    for bbox in results:
        yx="ylim=c(%s,%s), xlim=c(%s,%s)" % (results[bbox]) #(se_lat,nw_lat,nw_lng,se_lng)
        print('map("county", plot=T, fill=T, col=palette(), %s)' % yx)
        rect='rect(%s,%s, %s,%s, col=c("red"))' % (results[bbox][2], results[bbox][0], results[bbox][3], results[bbox][2])
        print(rect)
        print("")

main() LAT     LONG
36.3312 -94.1334
36.6828 -121.791
37.2307 -121.96
37.3857 -122.026
37.3857 -122.026
37.3857 -122.026
37.3895 -97.644
37.3992 -122.139
37.3992 -122.139
37.402  -122.078
37.402  -122.078
37.402  -122.078
37.402  -122.078
37.402  -122.078
37.48   -122.144
37.48   -122.144
37.55   126.967 rect(-74.989,39.7667, -73.0419,41.5209, col=c("red"))
rect(-123.005,36.8144, -121.392,38.3672, col=c("green"))
rect(-78.2422,38.2474, -76.3,39.9282, col=c("blue")) map("county", plot=T )
rect(-122.644,36.7307, -121.46,37.98, col=c("red")) ylim xlim map("county", plot=T, ylim=c(36.7307,37.98), xlim=c(-122.644,-121.46))
# or for more coloring, but choose one or the other map("country") commands
map("county", plot=T, fill=T, col=palette(), ylim=c(36.7307,37.98), xlim=c(-122.644,-121.46))
rect(-122.644,36.7307, -121.46,37.98, col=c("red")) map("world", plot=T ) threshhold_dist is the size of the bounding box, ie: the geographical area
theshhold_location is the number of lat/lng points needed with in
    the bounding box in order for it to be considered a cluster. # pyclusters.py
# May-02-2013
# -John Taylor

# latlng.tsv is located at http://pastebin.com/cyvEdx3V
# use the "RAW Paste Data" to preserve the tab characters

import math
from collections import defaultdict

# See also: http://www.geomidpoint.com/example.html
# See also: http://www.movable-type.co.uk/scripts/latlong.html

to_rad = math.pi / 180.0  # convert lat or lng to radians
fname = "latlng.tsv"      # file format: LAT\tLONG
threshhold_dist=20        # adjust to your needs
threshhold_locations=20   # minimum # of locations needed in a cluster
earth_radius_km = 6371

def coord2cart(lat,lng):
    x = math.cos(lat) * math.cos(lng)
    y = math.cos(lat) * math.sin(lng)
    z = math.sin(lat)
    return (x,y,z)

def cart2corrd(x,y,z):
    lon = math.atan2(y,x)
    hyp = math.sqrt(x*x + y*y)
    lat = math.atan2(z,hyp)
    return(lat,lng)

def dist(lat1,lng1,lat2,lng2):
    global to_rad, earth_radius_km

    dLat = (lat2-lat1) * to_rad
    dLon = (lng2-lng1) * to_rad
    lat1_rad = lat1 * to_rad
    lat2_rad = lat2 * to_rad

    a = math.sin(dLat/2) * math.sin(dLat/2) + math.sin(dLon/2) * math.sin(dLon/2) * math.cos(lat1_rad) * math.cos(lat2_rad)
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a)); 
    dist = earth_radius_km * c
    return dist

def bounding_box(src, neighbors):
    neighbors.append(src)
    # nw = NorthWest se=SouthEast
    nw_lat = -360
    nw_lng = 360
    se_lat = 360
    se_lng = -360

    for (y,x) in neighbors:
        if y > nw_lat: nw_lat = y
        if x > se_lng: se_lng = x

        if y < se_lat: se_lat = y
        if x < nw_lng: nw_lng = x

    # add some padding
    pad = 0.5
    nw_lat += pad
    nw_lng -= pad
    se_lat -= pad
    se_lng += pad

    #print("answer:")
    #print("nw lat,lng : %s %s" % (nw_lat,nw_lng))
    #print("se lat,lng : %s %s" % (se_lat,se_lng))

    # sutiable for r's map() function
    return (se_lat,nw_lat,nw_lng,se_lng)

def sitesDist(site1,site2): 
    # just a helper to shorted list comprehensioin below 
    return dist(site1[0],site1[1], site2[0], site2[1])

def load_site_data():
    global fname
    sites = defaultdict(tuple)

    data = open(fname,encoding="latin-1")
    data.readline() # skip header
    for line in data:
        line = line[:-1]
        slots = line.split("\t")
        lat = float(slots[0])
        lng = float(slots[1])
        lat_rad = lat * math.pi / 180.0
        lng_rad = lng * math.pi / 180.0
        sites[(lat,lng)] = (lat,lng) #(lat_rad,lng_rad)
    return sites

def main():
    color_list = ( "red", "blue", "green", "yellow", "orange", "brown", "pink", "purple" )
    color_idx = 0
    sites_dict = {}
    sites = load_site_data()
    for site in sites: 
        #for each site put it in a dictionarry with its value being an array of neighbors 
        sites_dict[site] = [x for x in sites if x != site and sitesDist(site,x) < threshhold_dist] 

    print("")
    print('map("state", plot=T)') # or use: county instead of state
    print("")


    results = {}
    for site in sites: 
        j = len(sites_dict[site])
        if j >= threshhold_locations:
            coord = bounding_box( site, sites_dict[site] )
            results[coord] = coord

    for bbox in results:
        yx="ylim=c(%s,%s), xlim=c(%s,%s)" % (results[bbox]) #(se_lat,nw_lat,nw_lng,se_lng)

        # important!
        # if you want an individual map for each cluster, uncomment this line
        #print('map("county", plot=T, fill=T, col=palette(), %s)' % yx)
        if len(color_list) == color_idx:
            color_idx = 0
        rect='rect(%s,%s, %s,%s, col=c("%s"))' % (results[bbox][2], results[bbox][0], results[bbox][3], results[bbox][1], color_list[color_idx])
        color_idx += 1
        print(rect)
    print("")


main()
-------------------------------------------------------------------------------------------------------
ggplot colour geom_rect p2 <- p + geom_rect(aes(NULL, NULL, xmin=From, xmax=To, colour=NULL),
               ymin=yrng[1], ymax=yrng[2],
               data=trips)
-------------------------------------------------------------------------------------------------------
ggplot() group group centroids geom_text groups=NULL geom_text ggplot(map.data2, aes(long, lat, group=group)) +  
   geom_polygon(aes(fill=level), colour=alpha('white', 1/2), size=0.2) +
   geom_polygon(data=ny, colour='black', fill=NA) + 
   scale_fill_brewer(palette='RdYlBu', guide = guide_legend(title = 
         "Percent Passing"))+
   facet_grid(.~Subject)+
   geom_text(data=centroids, aes(x=long, y=lat, 
     label=subregion, angle=angle, group=NULL), size=3) +   # THIS HAS CHANGED!
   opts(title = " 
     New York State Counties Passing Rate \non Elementary ELA Assessments") +
   opts(axis.text.x = theme_blank(), axis.text.y = theme_blank(), 
       axis.ticks = theme_blank())+
   opts(legend.background = theme_rect()) +
   scale_x_continuous('') + scale_y_continuous('') + 
   labs(title = "legend title") + theme_bw()+
    opts(axis.line=theme_blank(),axis.text.x=theme_blank(),
      axis.text.y=theme_blank(),axis.ticks=theme_blank(),
      axis.title.x=theme_blank(), legend.position="bottom",
      axis.title.y=theme_blank(),
      panel.background=theme_blank(),panel.grid.major=theme_blank(),
      panel.grid.minor=theme_blank(),plot.background=theme_blank())
-------------------------------------------------------------------------------------------------------
XXXX data x y maps ggplot(subset(df, as.character(variable) == "value"), aes(map_id = id)) +
  geom_map(aes(fill = pct), colour = "black", map = ggmap) +
  geom_polygon(data=XXXX, aes(x=XXXX, y=XXXX), colour='black', fill=NA) +
  expand_limits(x = ggmap$long, y = ggmap$lat) +
  scale_fill_gradient(low = "antiquewhite", high = "darkred") +
  opts(title = "Title", panel.background = theme_rect(fill = "grey90"))
-------------------------------------------------------------------------------------------------------
library(grid)

png("example1.png", width = 30, height = 5, units = "mm", res = 200)
g <- grid.text("testing font size", gp=gpar(fontsize=12))
width <- convertUnit(grobWidth(g), "mm")
height <- convertUnit(grobHeight(g), "mm", "y")
grid.rect(width=width, height=height, gp=gpar(lty=2, fill=NA))
dev.off()


png("example2.png", width = 60, height = 5, units = "mm", res = 500)
grid.text("testing font size", gp=gpar(fontsize=12))
grid.rect(width=width, height=height, gp=gpar(lty=2, fill=NA))
dev.off()
-------------------------------------------------------------------------------------------------------
# Generate the data
date <- c("2011-11-15", "2011-11-16", "2011-11-17", "2011-11-19")
start <- c("12:01:27", "12:01:25", "12:01:02", "12:01:12")
end <- c("12:30:15", "12:32:15", "12:39:12", "12:30:18")

# Put everything in a data frame and convert to POSIXct objects
# The times will be all converted to today's date
# but this will not influence the plot
df <- data.frame(date = as.POSIXct(date),
                 start = as.POSIXct(start, format="%H:%M:%S"), 
                 end = as.POSIXct(end, format="%H:%M:%S"))

# Get the working range for the axes in order to make them nicer (see below)
x.from <- as.POSIXct(min(date))
x.to <- as.POSIXct(max(date))
y.from <- as.POSIXct(min(start), format="%H:%M:%S")
y.to <- as.POSIXct(max(end), format="%H:%M:%S")

# Create an empty plot, as rect will not create a new one
# We put no axes on the plot
plot(0, "n", xaxt="n", yaxt="n", ylab="", xlab="Day", 
     ylim=c(from, to), xlim=range(df$date))

# Now draw the rectangles (I made them 2 hours-wide)
rect(df$date-3600, df$start, df$date+3600, df$end, col="black")

days <- seq(x.from, x.to, 24*3600)
times <- seq(y.from, y.to, 300) # 5 min (=300 s) axis ticks
# Finally add the axes
axis(1, at=days, labels=strftime(days, "%d/%m"))
axis(2, at=times, labels=strftime(times, "%H:%M"), las=1)
-------------------------------------------------------------------------------------------------------
date = c("2011-11-15", "2011-11-16", "2011-11-17", "2011-11-19")
start = c("12:01:27", "12:01:25", "12:01:02", "12:01:12")
end = c("12:30:15", "12:32:15", "12:39:12", "12:30:18") ##I've made the rectangles 2 hours wide
df = data.frame(date = as.POSIXct(date),
         ystart = as.POSIXct(start, format="%H:%M:%S"), 
         yend = as.POSIXct(end, format="%H:%M:%S"),
         xstart=as.POSIXct(paste(date, "12:00:00"), format="%Y-%m-%d %H:%M:%S"),
         xend = as.POSIXct(paste(date, "14:00:00"), format="%Y-%m-%d %H:%M:%S")) geom_rect ggplot() + geom_rect(data=df, aes(ymin=ystart, ymax=yend,
                           xmin=xend, xmax=xstart)) ##Your condition is something to do with the sd
df$isRed = c(TRUE, FALSE) ggplot() + geom_rect(data=subset(df, !isRed), aes(ymin=ystart, ymax=yend,
                           xmin=xend, xmax=xstart)) +
           geom_rect(data=subset(df, isRed), aes(ymin=ystart, ymax=yend,
                           xmin=xend, xmax=xstart), colour="red")
-------------------------------------------------------------------------------------------------------
dat <- data.frame(Name = factor(sample(letters[1:5],1000,replace = TRUE)),
                    val = runif(1000))

datSum <- ddply(dat,.(Name),summarise,q05 = quantile(val,0.05),
                                    q25 = quantile(val,0.25),
                                    q45 = quantile(val,0.45),
                                    q55 = quantile(val,0.55),
                                    q75 = quantile(val,0.75),
                                    q95 = quantile(val,0.95))
datSum$NameAlt <- 1:5 ggplot(datSum,aes(ymin = NameAlt - 0.2,ymax = NameAlt + 0.2)) + 
    geom_rect(aes(xmin = q05,xmax = q95),fill = "white",colour = "black") + 
    geom_rect(aes(xmin = q25,xmax = q75),fill = 'lightblue',colour = "black") +
    geom_rect(aes(xmin = q45,xmax = q55),fill = 'blue',colour = "black") +
    scale_y_continuous(breaks = 1:5,labels = datSum$Name)
-------------------------------------------------------------------------------------------------------
gr1 <- c(0, 5, 15, 20, 30, 40)
gr3 <- c(0, 5, 10, 25, 40, 60, 80)
gr2 <- c(0, 15, 25, 30, 40)

df2<- data.frame (pos = c(gr1, gr2, gr3), group = c(rep(1, length(gr1)),
 rep(2, length(gr2)), rep(3, length(gr3))))
df2$cpos <- cumsum (df2$pos)

cx <- ggplot(df2, aes(fill = factor(group), x = cpos))

cx + geom_bar(width = 1, colour = "black", position = "dodge")  + coord_polar() melt() reshape2 cx <- ggplot(df2, aes(y = group, x = cpos))

cx + geom_point(aes(color = factor(group))) + coord_polar() + ylim(0,3) library(ggplot2)

gr1 <- c(0, 5, 15, 20, 30, 40)
gr3 <- c(0, 5, 10, 25, 40, 60, 80)
gr2 <- c(0, 15, 25, 30, 40)

df2<- data.frame (pos = c(gr1, gr2, gr3), group = c(rep(1, length(gr1)),
 rep(2, length(gr2)), rep(3, length(gr3))), y  = c(rep(1, length(gr1)),
 rep(2, length(gr1)), rep(2, length(gr1))))

df2$cpos <- cumsum (df2$pos)

cx <- ggplot(df2, aes(y = y, x = cpos))
cx + geom_point(aes(color = factor(group)), size = 4) + geom_line(aes(x = c(0,500), y = c(1)), color = "yellow") + 
geom_line(aes(x = c(0,500), y = c(2)), color = "blue") + scale_y_continuous(limits=c(0,2), breaks = c(0,1,2)) +
scale_x_continuous(labels = df2$pos, breaks = df2$cpos, limits = c(0,500)) + coord_polar() +
opts(panel.grid.major = theme_line(colour = "grey"), 
panel.grid.minor = theme_line(colour = "grey", linetype = "dashed"), 
panel.background = theme_rect(colour = "white"))
-------------------------------------------------------------------------------------------------------
panel.barchart myPanelBarchart <- panel.barchart panel.text myPanelBarchart printVals FALSE body(myPanelBarchart)[[10]][[4]][[2]][[4]][[4]][[9]]<-substitute(for (i in unique(x)) {
    ok <- x == i
    nok <- sum(ok, na.rm = TRUE)
    panel.rect(x = (i + width * (groups[ok] - (nvals + 1)/2)), 
        y = rep(origin, nok), col = col[groups[ok]], border = border[groups[ok]], 
        lty = lty[groups[ok]], lwd = lwd[groups[ok]], width = rep(width, 
            nok), height = y[ok] - origin, just = c("centre", 
            "bottom"), identifier = identifier)
# This is the added part (adjust parameters as you see fit):
    if(!identical(printVals, FALSE)){
      panel.text(x = (i + width * (groups[ok] - (nvals + 1)/2)), y = y[ok],
        label = printVals[ok], adj = c(0.5, -1), identifier = identifier)
    }        

}) printVals formals(myPanelBarchart) <- c(formals(panel.barchart), printVals = FALSE) barchart(data=test, 
         percent~group,
         groups=subgroup,

            panel = function(x,y,...){
              myPanelBarchart(x, y, ..., printVals = test$text, )
            }
         ) body(myPanelBarchart)[[10]][[4]][[2]][[4]][[4]][[9]]
-------------------------------------------------------------------------------------------------------
annotation_custom() grid.arrange() gridExtra theme_blank() colour = NA library(ggplot2)
library(gridExtra)

test= data.frame(
  group=c(rep(1,6), rep(2,6)),
  subgroup=c( 1,1,1,2,2,2,1,1,1,2,2,2),
  category=c( rep(1:3, 4)),
  count=c( 10,80,10,5,90,5,  10,80,10,5,90,5))

# The bar plot
p1 <- qplot(factor(subgroup), count, 
      data=test, geom="bar",  stat="identity",
      fill =category,  
      facets =  .~ group,  width=0.9)+
      opts(legend.position="none",
           plot.margin = unit(c(0,0,2,0), "lines"))
p1 <- p1 + ylim(0, 100)

# The empty plot to contain the annotations
p2 = ggplot(data.frame(x = c(1,2), y = c(0,100), z = c(1,1)), aes(x,y)) + theme_bw() + facet_wrap(~ z) +
   opts(axis.title.y = theme_blank(),
        axis.title.x = theme_text(colour = NA),
        axis.text.y = theme_blank(),
        axis.text.x = theme_text(colour = NA),
        panel.grid.major = theme_blank(),
        panel.grid.minor = theme_blank(),
        axis.ticks = theme_segment(colour = NA),
        panel.border = theme_rect(colour = NA),
        strip.background = theme_rect(colour = NA, fill = NA),
        strip.text.x = theme_text(colour = NA), 
        plot.margin = unit(c(0,0,2,-1), "lines"))

# The annotations
Text1 = textGrob("Text 1")
Text2 = textGrob("Text 2")
Text4 = textGrob("Text 4")

p2 = p2 + annotation_custom(grob = Text1,  xmin = 1.4, xmax = 1.4, ymin = 85, ymax = 100) +
        annotation_custom(grob = linesGrob(), xmin = 1, xmax = 1.1, ymin = 100, ymax = 100) +
        annotation_custom(grob = linesGrob(), xmin = 1, xmax = 1.1, ymin = 85, ymax = 85) +
        annotation_custom(grob = linesGrob(), xmin = 1.1, xmax = 1.1, ymin = 85, ymax = 100)

p2 = p2 + annotation_custom(grob = Text2,  xmin = 1.4, xmax = 1.4, ymin = 20, ymax = 80) +
        annotation_custom(grob = linesGrob(), xmin = 1, xmax = 1.1, ymin = 80, ymax = 80) +
        annotation_custom(grob = linesGrob(), xmin = 1, xmax = 1.1, ymin = 20, ymax = 20) +
        annotation_custom(grob = linesGrob(), xmin = 1.1, xmax = 1.1, ymin = 20, ymax = 80)

p2 = p2 + annotation_custom(grob = Text4,  xmin = 1.4, xmax = 1.4, ymin = 0, ymax = 15) +
        annotation_custom(grob = linesGrob(), xmin = 1, xmax = 1.1, ymin = 15, ymax = 15) +
        annotation_custom(grob = linesGrob(), xmin = 1, xmax = 1.1, ymin = 0, ymax = 0) +
        annotation_custom(grob = linesGrob(), xmin = 1.1, xmax = 1.1, ymin = 0, ymax = 15)

# Putting the two plots together
plot = arrangeGrob(p1, p2, ncol = 2, widths = unit(c(10, 2), c("null", "null")))
plot
-------------------------------------------------------------------------------------------------------
library(scales)
plot_aas_wait_class <- ggplot()+
  geom_area(data=DF_AAS, aes(x = snap_time, y = aas,fill = wait_class),stat = "identity", position = "stack",alpha=.9)+
  scale_fill_brewer(palette="Paired",breaks = sort(levels(DF_AAS$wait_class)))+
  scale_y_continuous(breaks = seq(0, max(DF_AAS$aas)+(max(DF_AAS$aas)*.2), 5))+
  opts(panel.background = theme_rect(colour = "#aaaaaa")) +  
  opts(legend.position = "bottom",legend.direction = "horizontal") + 
  guides(fill = guide_legend(nrow = 2))

plot_aas_event <- ggplot()+
  geom_area(data=DF_AAS_EVENT, aes(x = snap_time, y = aas,fill = wait_class_event),stat = "identity", position = "stack")+
  scale_fill_brewer(palette="Paired",breaks = DF_AAS_EVENT$wait_class_event)+
  scale_y_continuous(breaks = seq(0, max(DF_AAS_EVENT$aas)+(max(DF_AAS_EVENT$aas)*.2), 5))+
  opts( panel.background = theme_rect(colour = "#aaaaaa")) +  
  opts(legend.position = "bottom",legend.direction = "horizontal") + 
  guides(fill = guide_legend(ncol = 2))


grid.arrange(arrangeGrob(plot_aas_wait_class, plot_aas_event),heights=c(1/2,1/2),ncol=1) + scale_x_datetime(breaks = date_breaks("2 hours")) geom_rect alpha = 0.25 Inf -Inf geom_rect
-------------------------------------------------------------------------------------------------------
alpha aes() library(ggplot2)

dat <- data.frame(my_x_series=1:192, my_y_series=5.0*runif(192))
rect_left <- c(4,52,100,148)
rectangles <- data.frame(
  xmin = rect_left,
  xmax = rect_left + 24,
  ymin = 0,
  ymax = 5
)

ggplot() +
  geom_rect(data=rectangles, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax), 
            fill='gray80', alpha=0.8) +
  geom_point(data=dat, aes(x=my_x_series, y=my_y_series))
-------------------------------------------------------------------------------------------------------
#sample data
set.seed(666)
dat <- data.frame(x = seq(as.POSIXct('2011-03-27 00:00:00'), 
len= (n=24), by="1 hour"), y = cumsum(rnorm(n)))
#Breaks for background rectangles
rects <- data.frame(xstart = as.POSIXct('2011-03-27 15:00:00'), 
xend = as.POSIXct('2011-03-27 18:00:00'))

library(ggplot2)
ggplot() + 
  geom_rect(data = rects, aes(xmin = xstart, xmax = xend, 
            ymin = -Inf, ymax = Inf), alpha = 0.4) + 
  geom_line(data = dat, aes(x,y))
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(colorRamps)
TawiTawiPop <- c(17000, 45000, 46000, 59000, 79000, 110000, 143000, 195000, 228204, 250718, 322317, 450346, 366550)
YearNames <- c("1903", "1918", "1939", "1948", "1960", "1970", "1975", "1980", "1990", "1995", "2000", "2007", "2010")

qplot(YearNames, TawiTawiPop, 
      xlab = expression(bold("Censal Year")), 
      ylab = expression(bold("Population")), 
      geom = "bar",
      stat = "identity", colour = I("red"), 
      fill = matlab.like2(13)) + theme_bw() + 
      opts(
        title = expression(bold("Tawi-Tawi Population from 1903 to 2010")),
        plot.title = theme_text(size = 18, colour = "darkblue"),
        legend.position = "none",
        panel.border = theme_rect(linetype = "dashed", colour = "red"),
        plot.title = theme_text(size = 18, colour = "darkblue"))+
     geom_text(aes(label = TawiTawiPop,angle=90,hjust=-0.1))
-------------------------------------------------------------------------------------------------------
a + geom_bar() + geom_bar(colour="black",show_guide=FALSE) +
 scale_fill_manual(values=c("white", "black")) + 
 opts(legend.key = theme_rect(fill = 'black')) colour fill a + geom_bar() + geom_bar(colour="black",show_guide=FALSE) + 
scale_fill_manual(values=c("white", "black")) + 
opts(legend.key = theme_rect(colour = 'black'))
-------------------------------------------------------------------------------------------------------
par(mar=c(4,5,1,1))
 plot(rnorm(30), xlab= "Big font", ylab = "Big font", cex.lab = 2, cex.axis = 1.5) par(mar=c(5,5,4,1))
plot(rnorm(30), xlab= "Big font", ylab = "Big font", 
    cex.lab = 2, cex.axis = 1.5, cex.main=3, main="Big Font") a = rnorm(30)
par(mar=c(5,5,4,1))
plot(a, xlab= "Big font", ylab = "Big font", type="n",
     cex.lab = 2, cex.axis = 1.5, cex.main=3, main="Big Font")
x <- par("usr")
rect(x[1], x[3], x[2], x[4], col = "grey")
points(a, pch=19)
-------------------------------------------------------------------------------------------------------
d <- diamonds[sample(nrow(diamonds), 10), ]

(p <- ggplot(d, aes(carat, price)) +
  geom_text(
    aes(label = cut, family = "mono", fontface = "bold"), 
    size = 12, 
    colour = "black"
  ) +
  geom_text(
    aes(label = cut, family = "mono"), 
    size = 12, 
    colour = "white"
  ) +
  opts(panel.background = theme_rect(fill = "green"))
)
-------------------------------------------------------------------------------------------------------
shadowtext TeachingDemos d <- diamonds[sample(nrow(diamonds), 10), ]  


p <- ggplot(d, aes(carat, price) ) 
theta <- seq(pi/8, 2*pi, length.out=16)
xo <- diff(range(d$carat))/200
yo <- diff(range(d$price))/200
for(i in theta) {
    p <- p + geom_text( 
        bquote(aes(x=carat+.(cos(i)*xo),y=price+.(sin(i)*yo),label=cut)), 
                    size=12, colour='black' )
}
p <- p + geom_text( aes(label=cut), size=12, colour='white' )
p <- p + opts( panel.background=theme_rect(fill='green' ) )
print(p)
-------------------------------------------------------------------------------------------------------
# convert to a data frame
dept_data <- as.data.frame(dept.table) # add proportions
library(plyr)
dept_data_prop <- ddply(dept_data, .(Var1), mutate, prop = Freq /sum(Freq))


library(ggplot2)
ggplot(dept_data_prop, aes(x= Var1, y = prop, colour = Var2, fill = Var2)) + 
  geom_bar() + 
  coord_flip() + 
  facet_wrap(~Var1, scales = 'free', ncol = 1) + 
  opts(strip.background =theme_blank(), strip.text.x = theme_blank(), 
       strip.text.y = theme_text(), axis.ticks = theme_blank(), 
       axis.title.x = theme_blank(), axis.text.x = theme_blank()) + xlab('') + 
  scale_fill_brewer('Student',  type = 'div', palette = 5) + 
  scale_colour_brewer('Student', type = 'div', palette = 5) + 
  scale_x_discrete(expand = c(0,0)) + 
  scale_y_continuous(expand=c(0,0)) ?opts dept_data <- as.data.frame(dept.table)
names(dept_data) <- c('department', 'student', 'count')



dept_prop <- ddply(dept_data, .(department), mutate, 
               prop_department = count / sum(count),
               max_department = cumsum(prop_department),
               min_department = max_department - prop_department,
               total_department = sum(count))


dept_prop <- mutate(dept_prop, prop_total = total_department / sum(count))

dept_prop <- ddply(dept_prop, .(student), mutate, 
   max_total = cumsum(prop_total), 
   min_total = max_total - prop_total)



ggplot(dept_prop, aes(xmin = min_department, xmax = max_department, 
                      ymin = min_total, ymax = max_total)) +
 geom_rect(aes(colour = student, fill =student)) + 
 facet_grid(department~., scales = 'free', space = 'free') +
 opts(strip.background =theme_blank(), 
   strip.text.y = theme_text(hjust = 0.05), axis.ticks = theme_blank(), 
   axis.title.x = theme_blank(), axis.text.x = theme_blank(), 
   axis.title.y = theme_blank(), axis.text.y = theme_blank(), 
   legend.position = 'bottom', legend.justification = 'left',
   panel.border = theme_blank(), panel.background = theme_blank(), 
   panel.grid.major = theme_blank(), panel.grid.minor = theme_blank()) +
   xlab('') + 
 scale_fill_brewer('Student',  palette = 'Set1') + 
 scale_colour_brewer('Student', palette = 'Set1') + 
 scale_x_continuous(expand = c(0, 0)) + 
 scale_y_continuous(expand = c(0, 0))
-------------------------------------------------------------------------------------------------------
ggplot(mtcars, aes(x=wt, y=mpg, colour=cyl)) + geom_point(aes(colour=cyl)) + 
  opts(legend.position = c(0, 1), 
       legend.justification = c(0, 1), 
       legend.background = theme_rect(colour = NA, fill = "white"),
       title="Legend placement makes me happy") p <- ggplot(mtcars, aes(x=wt, y=mpg, colour=cyl)) + geom_point(aes(colour=cyl)) + 
  opts(legend.position = c(0, 1), 
       legend.justification = c(0, 1), 
       legend.background = theme_rect(colour = "black"),
       title="Legend placement makes me happy")

gt <- ggplot_gtable(ggplot_build(p))
nr <- max(gt$layout$b)
nc <- max(gt$layout$r)
gb <- which(gt$layout$name == "guide-box")
gt$layout[gb, 1:4] <- c(1, 1, nr, nc)
grid.newpage()
grid.draw(gt)
-------------------------------------------------------------------------------------------------------
gp<-ggplot(g,aes(x=Date,y=value,group=variable)) +
    opts(
        panel.background = theme_rect(size = 1, colour = "lightgray"),
        panel.grid.minor = theme_blank(),
        strip.background = theme_blank(),
        axis.title.x = theme_blank(),
        axis.title.y = theme_blank()
        ,strip.text.y = theme_text(size = 12,angle = 0)
    )
gp<- gp + geom_line(size=1)
gp <-gp + facet_grid(variable ~ var2, scales="free")
gp<-gp+geom_smooth(data=g[g$var2=="History",],
                   method=loess,size=1,span=.35,alpha=.005)
gp
-------------------------------------------------------------------------------------------------------
map1 <- ggplot(walk2, 
        aes(x=coords.x1, y=coords.x2, colour=UD_TOTAL, size=UD_TOTAL)) + 
        scale_colour_gradient(low="#003300", high="#00FF00", space="rgb") + 
        opts(panel.background=theme_rect(fill="#404040", colour = "#404040")) +
        annotation_map(BuiltEnv, fill="#4F4F4F", colour="#4F4F4F") +
        geom_point() +
        facet_wrap(~School2, ncol=3, scales='free') +
        coord_map(project="mercator")
map1
-------------------------------------------------------------------------------------------------------
tkBrush TeachingDemos rechist <- function(x,...){
         tmp <- hist(x,plot=F)
         br <- tmp$breaks
         w <- as.numeric(cut(x,br,include.lowest=TRUE))
         sy <- unlist(lapply(tmp$counts,function(x)seq(length=x)))
         my <- max(sy)
         sy <- sy/my
         my <- 1/my
         sy <- sy[order(order(x))]
        plot.new()
        plot.window(xlim=range(br), ylim=c(0,1))
         rect(br[w], sy-my, br[w+1], sy, border=TRUE, col='grey')
         rect(br[-length(br)], 0, br[-1], tmp$counts*my)
        axis(1)
     }

rechist( iris$Petal.Length )
-------------------------------------------------------------------------------------------------------
PolarImageInterpolate <- function(x, y, z, outer.radius = 1, 
            breaks, col, nlevels = 20, contours = TRUE, legend = TRUE, 
            axes = TRUE, circle.rads = pretty(c(0,outer.radius))){

        minitics <- seq(-outer.radius, outer.radius, length.out = 1000)
        # interpolate the data
        Interp <- akima:::interp(x = x, y = y, z = z, 
                extrap = TRUE, 
                xo = minitics, 
                yo = minitics, 
                linear = FALSE)
        Mat <- Interp[[3]]

        # mark cells outside circle as NA
        markNA <- matrix(minitics, ncol = 1000, nrow = 1000) 
        Mat[!sqrt(markNA ^ 2 + t(markNA) ^ 2) < outer.radius] <- NA 

        # sort out colors and breaks:
        if (!missing(breaks) & !missing(col)){
            if (length(breaks) - length(col) != 1){
                stop("breaks must be 1 element longer than cols")
            }
        }
        if (missing(breaks) & !missing(col)){
            breaks <- seq(min(Mat,na.rm = TRUE), max(Mat, na.rm = TRUE), length = length(col) + 1)
            nlevels <- length(breaks) - 1
        }
        if (missing(col) & !missing(breaks)){
            col <- rev(heat.colors(length(breaks) - 1))
            nlevels <- length(breaks) - 1
        }
        if (missing(breaks) & missing(col)){
            breaks <- seq(min(Mat,na.rm = TRUE), max(Mat, na.rm = TRUE), length = nlevels + 1)
            col <- rev(heat.colors(nlevels))
        }

        # if legend desired, it goes on the right and some space is needed
        if (legend) {
            par(mai = c(1,1,1.5,1.5))
        }

        # begin plot
        image(x = minitics, y = minitics, t(Mat), useRaster = TRUE, asp = 1, 
            axes = FALSE, xlab = "", ylab = "", col = col, breaks = breaks)

        # add contours if desired
        if (contours){
            CL <- contourLines(x = minitics, y = minitics, t(Mat), levels = breaks)
            A <- lapply(CL, function(xy){
                        lines(xy$x, xy$y, col = gray(.2), lwd = .5)
                    })
        }

        # add radial axes if desired
        if (axes){ 
            # internals for axis markup
            RMat <- function(radians){
                matrix(c(cos(radians), sin(radians), -sin(radians), cos(radians)), ncol = 2)
            }    

            circle <- function(x, y, rad = 1, nvert = 500){
                rads <- seq(0,2*pi,length.out = nvert)
                xcoords <- cos(rads) * rad + x
                ycoords <- sin(rads) * rad + y
                cbind(xcoords, ycoords)
            }

            # draw circles
            if (missing(circle.rads)){
                circle.rads <- pretty(c(0,outer.radius))
            }

            for (i in circle.rads){
                lines(circle(0, 0, i), col = "#66666650")
            }

            # put on radial spoke axes:
            axis.rads <- c(0, pi / 6, pi / 3, pi / 2, 2 * pi / 3, 5 * pi / 6)
            r.labs <- c(90, 60, 30, 0, 330, 300)
            l.labs <- c(270, 240, 210, 180, 150, 120)

            for (i in 1:length(axis.rads)){ 
                endpoints <- zapsmall(c(RMat(axis.rads[i]) %*% matrix(c(1, 0, -1, 0) * outer.radius,ncol = 2)))
                segments(endpoints[1], endpoints[2], endpoints[3], endpoints[4], col = "#66666650")
                endpoints <- c(RMat(axis.rads[i]) %*% matrix(c(1.1, 0, -1.1, 0) * outer.radius, ncol = 2))
                lab1 <- bquote(.(r.labs[i]) * degree)
                lab2 <- bquote(.(l.labs[i]) * degree)
                text(endpoints[1], endpoints[2], lab1, xpd = TRUE)
                text(endpoints[3], endpoints[4], lab2, xpd = TRUE)
            }
            axis(2, pos = -1.2 * outer.radius, at = sort(union(circle.rads,-circle.rads)), labels = NA)
            text( -1.21 * outer.radius, sort(union(circle.rads, -circle.rads)),sort(union(circle.rads, -circle.rads)), xpd = TRUE, pos = 2)
        }

        # add legend if desired
        # this could be sloppy if there are lots of breaks, and that's why it's optional.
        # another option would be to use fields:::image.plot(), using only the legend. 
        # There's an example for how to do so in its documentation
        if (legend){
            ylevs <- seq(-outer.radius, outer.radius, length = nlevels + 1)
            rect(1.2 * outer.radius, ylevs[1:(length(ylevs) - 1)], 1.3 * outer.radius, ylevs[2:length(ylevs)], col = col, border = NA, xpd = TRUE)
            rect(1.2 * outer.radius, min(ylevs), 1.3 * outer.radius, max(ylevs), border = "#66666650", xpd = TRUE)
            text(1.3 * outer.radius, ylevs,round(breaks, 1), pos = 4, xpd = TRUE)
        }
    }

    # Example
    set.seed(10)
    x <- rnorm(20)
    y <- rnorm(20)
    z <- rnorm(20)
    PolarImageInterpolate(x,y,z, breaks = seq(-2,8,by = 1)) image() # arguments:

    # Mat, a matrix of z values as follows:
    # leftmost edge of first column = 0 degrees, rightmost edge of last column = 360 degrees
    # columns are distributed in cells equally over the range 0 to 360 degrees, like a grid prior to transform
    # first row is innermost circle, last row is outermost circle

    # outer.radius, By default everything scaled to unit circle 
    # ppa: points per cell per arc. If your matrix is little, make it larger for a nice curve
    # cols: color vector. default = rev(heat.colors(length(breaks)-1))
    # breaks: manual breaks for colors. defaults to seq(min(Mat),max(Mat),length=nbreaks)
    # nbreaks: how many color levels are desired?
    # axes: should circular and radial axes be drawn? radial axes are drawn at 30 degree intervals only- this could be made more flexible.
    # circle.rads: at which radii should circles be drawn? defaults to pretty(((0:ncol(Mat)) / ncol(Mat)) * outer.radius)

    # TODO: add color strip legend.

    PolarImagePlot <- function(Mat, outer.radius = 1, ppa = 5, cols, breaks, nbreaks = 51, axes = TRUE, circle.rads){

        # the image prep
        Mat      <- Mat[, ncol(Mat):1]
        radii    <- ((0:ncol(Mat)) / ncol(Mat)) * outer.radius

        # 5 points per arc will usually do
        Npts     <- ppa
        # all the angles for which a vertex is needed
        radians  <- 2 * pi * (0:(nrow(Mat) * Npts)) / (nrow(Mat) * Npts) + pi / 2
        # matrix where each row is the arc corresponding to a cell
        rad.mat  <- matrix(radians[-length(radians)], ncol = Npts, byrow = TRUE)[1:nrow(Mat), ]
        rad.mat  <- cbind(rad.mat, rad.mat[c(2:nrow(rad.mat), 1), 1])

        # the x and y coords assuming radius of 1
        y0 <- sin(rad.mat)
        x0 <- cos(rad.mat)

        # dimension markers
        nc <- ncol(x0)
        nr <- nrow(x0)
        nl <- length(radii)

        # make a copy for each radii, redimension in sick ways
        x1 <- aperm( x0 %o% radii, c(1, 3, 2))
        # the same, but coming back the other direction to close the polygon
        x2 <- x1[, , nc:1]
        #now stick together
        x.array <- abind:::abind(x1[, 1:(nl - 1), ], x2[, 2:nl, ], matrix(NA, ncol = (nl - 1), nrow = nr), along = 3)
        # final product, xcoords, is a single vector, in order, 
        # where all the x coordinates for a cell are arranged
        # clockwise. cells are separated by NAs- allows a single call to polygon()
        xcoords <- aperm(x.array, c(3, 1, 2))
        dim(xcoords) <- c(NULL)
        # repeat for y coordinates
        y1 <- aperm( y0 %o% radii,c(1, 3, 2))
        y2 <- y1[, , nc:1]
        y.array <- abind:::abind(y1[, 1:(length(radii) - 1), ], y2[, 2:length(radii), ], matrix(NA, ncol = (length(radii) - 1), nrow = nr), along = 3)
        ycoords <- aperm(y.array, c(3, 1, 2))
        dim(ycoords) <- c(NULL)

        # sort out colors and breaks:
        if (!missing(breaks) & !missing(cols)){
            if (length(breaks) - length(cols) != 1){
                stop("breaks must be 1 element longer than cols")
            }
        }
        if (missing(breaks) & !missing(cols)){
            breaks <- seq(min(Mat,na.rm = TRUE), max(Mat, na.rm = TRUE), length = length(cols) + 1)
        }
        if (missing(cols) & !missing(breaks)){
            cols <- rev(heat.colors(length(breaks) - 1))
        }
        if (missing(breaks) & missing(cols)){
            breaks <- seq(min(Mat,na.rm = TRUE), max(Mat, na.rm = TRUE), length = nbreaks)
            cols <- rev(heat.colors(length(breaks) - 1))
        }

        # get a color for each cell. Ugly, but it gets them in the right order
        cell.cols <- as.character(cut(as.vector(Mat[nrow(Mat):1,ncol(Mat):1]), breaks = breaks, labels = cols))

        # start empty plot
        plot(NULL, type = "n", ylim = c(-1, 1) * outer.radius, xlim = c(-1, 1) * outer.radius, asp = 1, axes = FALSE, xlab = "", ylab = "")
        # draw polygons with no borders:
        polygon(xcoords, ycoords, col = cell.cols, border = NA)

        if (axes){

            # a couple internals for axis markup.

            RMat <- function(radians){
                matrix(c(cos(radians), sin(radians), -sin(radians), cos(radians)), ncol = 2)
            }

            circle <- function(x, y, rad = 1, nvert = 500){
                rads <- seq(0,2*pi,length.out = nvert)
                xcoords <- cos(rads) * rad + x
                ycoords <- sin(rads) * rad + y
                cbind(xcoords, ycoords)
            }
            # draw circles
            if (missing(circle.rads)){
                circle.rads <- pretty(radii)
            }
            for (i in circle.rads){
                lines(circle(0, 0, i), col = "#66666650")
            }

            # put on radial spoke axes:
            axis.rads <- c(0, pi / 6, pi / 3, pi / 2, 2 * pi / 3, 5 * pi / 6)
            r.labs <- c(90, 60, 30, 0, 330, 300)
            l.labs <- c(270, 240, 210, 180, 150, 120)

            for (i in 1:length(axis.rads)){ 
                endpoints <- zapsmall(c(RMat(axis.rads[i]) %*% matrix(c(1, 0, -1, 0) * outer.radius,ncol = 2)))
                segments(endpoints[1], endpoints[2], endpoints[3], endpoints[4], col = "#66666650")
                endpoints <- c(RMat(axis.rads[i]) %*% matrix(c(1.1, 0, -1.1, 0) * outer.radius, ncol = 2))
                lab1 <- bquote(.(r.labs[i]) * degree)
                lab2 <- bquote(.(l.labs[i]) * degree)
                text(endpoints[1], endpoints[2], lab1, xpd = TRUE)
                text(endpoints[3], endpoints[4], lab2, xpd = TRUE)
            }
            axis(2, pos = -1.2 * outer.radius, at = sort(union(circle.rads,-circle.rads)))
        }
        invisible(list(breaks = breaks, col = cols))
    } image() set.seed(1)
    x <- runif(20, min = 0, max = 360)
    y <- runif(20, min = 0, max = 40)
    z <- rnorm(20)

    Interp <- akima:::interp(x = x, y = y, z = z, 
            extrap = TRUE, 
            xo = seq(0, 360, length.out = 300), 
            yo = seq(0, 40, length.out = 100), 
            linear = FALSE)
    Mat <- Interp[[3]]

    PolarImagePlot(Mat)
-------------------------------------------------------------------------------------------------------
hist() rect() vals <- rnorm(10)
    A <- hist(vals)
    A
    $breaks
    [1] -1.5 -1.0 -0.5  0.0  0.5  1.0  1.5

    $counts
    [1] 1 3 3 1 1 1

    $intensities
    [1] 0.2 0.6 0.6 0.2 0.2 0.2

    $density
    [1] 0.2 0.6 0.6 0.2 0.2 0.2

    $mids
    [1] -1.25 -0.75 -0.25  0.25  0.75  1.25

    $xname
    [1] "vals"

    $equidist
    [1] TRUE

    attr(,"class")
    [1] "histogram" plot(NULL, type = "n", ylim = c(0,max(A$counts)), xlim = c(range(A$breaks)))
    rect(A$breaks[1:(length(A$breaks) - 1)], 0, A$breaks[2:length(A$breaks)], A$counts) plot(NULL, type = "n", xlim = c(0, max(A$counts)), ylim = c(range(A$breaks)))
    rect(0, A$breaks[1:(length(A$breaks) - 1)], A$counts, A$breaks[2:length(A$breaks)]) density()
-------------------------------------------------------------------------------------------------------
fill = type scale_fill_manual guides fill = NA guides library(ggplot2)

temp = read.table(text = "
type    name    value
A john  47.6
B john  55.6
C john  57.7
A amy   13.15
B amy   23.1
C amy   24.9
A lily  14.0
B lily  18.1
C lily  21.9
A sam   38.8
B sam   44.8
C sam   45.9
A frank 63.6
B frank 64.4
C frank 64.7
A xia   52.8
B xia   54.1
C xia   56.4
A yan   53.8
B yan   56.1
C yan   58.6", header = TRUE, sep = "")


qplot(type, value, geom="bar", fill=type, data=temp, group=name, facets= .~name, stat="identity") + 
   scale_fill_manual(values = rep("salmon",3), labels = c("A - atype", "B - btype", "C - ctype")) +
   guides(fill = guide_legend(override.aes = list(fill = "white"))) +
   theme_bw() + 
   opts(axis.title.y=theme_text(size=16,angle=90),axis.title.x=theme_text(size=16,angle=0)) + 
   opts(axis.text.x=theme_text(size=10)) + 
   opts(axis.text.y=theme_text(size=14)) + 
   opts(strip.background = theme_rect(colour = 'steelblue', fill = 'white', size = 2)) + 
   opts(legend.title=theme_blank()) + 
   opts(legend.position="top") +
   opts(legend.key = theme_rect(colour = NA))
-------------------------------------------------------------------------------------------------------
dat <- data.frame(x = 1:10,y = sample(10,10,replace = TRUE)) ggplot(dat,aes(x = x,y = y)) + 
    geom_point() + 
    scale_y_continuous(breaks = seq(1,10,0.5)) ggplot(dat,aes(x = x,y = y)) + 
    geom_point() + 
    scale_y_continuous(breaks = seq(1,10,0.5)) + 
    opts(panel.background = theme_rect(fill='white', colour='gray')) theme_rect ggplot(dat,aes(x = x,y = y)) + 
    geom_point() + 
    scale_y_continuous(breaks = seq(1,10,0.5)) + 
    opts(panel.background = theme_rect(fill='white', colour='gray'),
         panel.grid.minor = theme_blank(),
         panel.grid.major = theme_line(colour = "grey80")) theme_blank
-------------------------------------------------------------------------------------------------------
ggplot(d, aes(factor(x), y)) + 
  geom_rect(aes(NULL, NULL, xmin=Start, xmax=End, fill=Level), 
            alpha = 0.2, ymin=-Inf, ymax=Inf,data=Groups) + 
  geom_boxplot() +
  scale_fill_brewer(palette="Pastel1")
-------------------------------------------------------------------------------------------------------
basicBox + geom_rect(aes(NULL, NULL, xmin=Start, xmax=End, fill=Level), ymin=0, ymax=20, data=Groups, alpha=0.2) + scale_fill_manual(values=c("red", "blue", "green", "grey", "purple")) geom_rect
-------------------------------------------------------------------------------------------------------
library(lattice)
# Create layout and viewports
masterLayout <- grid.layout(
  nrow    = 3, 
  ncol    = 1, 
  heights = unit(c(1, .5, 1), c("null", "inches", "null")),
  respect = matrix(c(0, 1, 0)))
vp1 <- viewport(layout.pos.row=1,  name="vp1")  
vp2 <- viewport(layout.pos.row=3,  name="vp2")     
vp3 <- viewport(layout.pos.row=2,  name="spacer")     

theme.novpadding <-
   list(layout.heights =
        list(top.padding = 0,
        main.key.padding = 0,
        key.axis.padding = 0,
        axis.xlab.padding = 0,
        xlab.key.padding = 0,
        key.sub.padding = 0,
        bottom.padding = 0),
        layout.widths =
        list(left.padding = 0,
        key.ylab.padding = 0,
        ylab.axis.padding = 0,
        axis.key.padding = 0,
        right.padding = 0))

# Create plots
plot1 <- xyplot(1 ~ 1, panel = function () grid.rect(gp=gpar(fill="black")),
   scales=list(axs='i',draw=FALSE),
   xlab=NULL,ylab=NULL,par.settings = theme.novpadding)
plot2 <- xyplot(1 ~ 1, panel = function () grid.rect(gp=gpar(fill="red")),
   scales=list(axs='i',draw=FALSE),
   xlab=NULL,ylab=NULL,par.settings = theme.novpadding)       

grid.newpage()
pushViewport(vpTree(viewport(layout = masterLayout,name="master"), vpList(vp1, vp2, vp3)))
seekViewport("master")
print(plot1, draw.in = "vp1")
print(plot2, draw.in = "vp2")
seekViewport("spacer")
grid.rect()
-------------------------------------------------------------------------------------------------------
data.frame geom_vline a <- c(-2.27685371,0.01661155,0.33598194,1.92426022)
vlines <- data.frame(xint = c(a,mean(a)),grp = letters[1:5]) grp colour aes qplot(x, tvalues) + 
  geom_polygon(fill = "purple", colour = "purple", alpha = 0.5) + 
  geom_point(fill = "purple", colour = "purple", alpha = 0.2, pch = 21) +
  geom_vline(data = vlines,aes(xintercept = xint,colour = grp), linetype = "dashed") + 
  theme_bw() + 
  xlab(bquote(bold('Average Tensile Strength (lb/in'^'2'*')'))) +
  ylab(expression(bold(P(x)))) +
  opts(title = expression(bold("Student t Distribution")), 
       plot.title = theme_text(size = 20, colour = "darkblue"),
       panel.border = theme_rect(size = 2, colour = "red")) qplot ggplot()
-------------------------------------------------------------------------------------------------------
#define extremes of the color ramps
rampk2r <- colorRampPalette(c(rgb(  0/255,   0/255,   0/255), rgb(218/255,   0/255,   0/255)))
rampk2g <- colorRampPalette(c(rgb(  0/255,   0/255,   0/255), rgb(  0/255, 218/255,   0/255)))

# stupid function to reduce every span of numbers to the 0,1 interval
prop <- function(x, lo=0, hi=100) {
    if (is.na(x)) {NA}
    else{
        min(lo,hi)+x*(max(lo,hi)-min(lo,hi))
    }
}

rangepropCA<-c(0,20)
rangepropCB<-c(0,20)

# define some default variables
if (!exists('alpha_default')) {alpha_default<-1} # opaque colors by default
if (!exists('palette_l')) {palette_l<-50} # how many steps in the palette
if (!exists('max_sat')) {max_sat<-200} # maximum saturation
colorpalette<-0:palette_l*(max_sat/255)/palette_l # her's finally the palette...

# first of all make an empy plot
plot(NULL, xlim=rangepropCA, ylim=rangepropCB, log='', xaxt='n', yaxt='n', xlab='prop A', ylab='prop B', bty='n', main='color field');
# then fill it up with rectangles each colored differently
for (m in 1:palette_l) {
    for (n in 1:palette_l) {
        rgbcol<-rgb(colorpalette[n],colorpalette[m],0, alpha_default);
        rect(xleft= prop(x=(n-1)/(palette_l),rangepropCA[1],rangepropCA[2]) 
            ,xright= prop(x=(n)/(palette_l),rangepropCA[1],rangepropCA[2])
            ,ytop= prop(x=(m-1)/(palette_l),rangepropCB[1],rangepropCB[2]) 
            ,ybottom= prop(x=(m)/(palette_l),rangepropCB[1],rangepropCB[2])
            ,col=rgbcol
            ,border="transparent"
        )
    }
}
# done!
-------------------------------------------------------------------------------------------------------
map geocode() geom_polygon library(maps)
library(plyr)
library(ggplot2)
library(sp)
library(ggmap)

# Get some points to plot - CRAN Mirrors
Mirrors = getCRANmirrors(all = FALSE, local.only = FALSE)

Mirrors$Place = paste(Mirrors$City, ", ", Mirrors$Country, sep = "")    # Be patient
tmp = geocode(Mirrors$Place)
Mirrors = cbind(Mirrors, tmp)

###################################################################################################
# Recentre worldmap (and Mirrors coordinates) on longitude 160
### Code by Claudia Engel  March 19, 2012, www.stanford.edu/~cengel/blog

### Recenter ####
center <- 160 # positive values only

# shift coordinates to recenter CRAN Mirrors
Mirrors$long.recenter <- ifelse(Mirrors$lon < center - 180 , Mirrors$lon + 360, Mirrors$lon)

# shift coordinates to recenter worldmap
worldmap <- map_data ("world")
worldmap$long.recenter <- ifelse(worldmap$long < center - 180 , worldmap$long + 360, worldmap$long)

### Function to regroup split lines and polygons
# Takes dataframe, column with long and unique group variable, returns df with added column named group.regroup
RegroupElements <- function(df, longcol, idcol){
  g <- rep(1, length(df[,longcol]))
  if (diff(range(df[,longcol])) > 300) { # check if longitude within group differs more than 300 deg, ie if element was split
    d <- df[,longcol] > mean(range(df[,longcol])) # we use the mean to help us separate the extreme values
    g[!d] <- 1 # some marker for parts that stay in place (we cheat here a little, as we do not take into account concave polygons)
    g[d] <- 2 # parts that are moved
  }
  g <- paste(df[, idcol], g, sep=".") # attach to id to create unique group variable for the dataset
  df$group.regroup <- g
  df
}

### Function to close regrouped polygons
# Takes dataframe, checks if 1st and last longitude value are the same, if not, inserts first as last and reassigns order variable
ClosePolygons <- function(df, longcol, ordercol){
  if (df[1,longcol] != df[nrow(df),longcol]) {
    tmp <- df[1,]
    df <- rbind(df,tmp)
  }
  o <- c(1: nrow(df)) # rassign the order variable
  df[,ordercol] <- o
  df
}

# now regroup
worldmap.rg <- ddply(worldmap, .(group), RegroupElements, "long.recenter", "group")

# close polys
worldmap.cp <- ddply(worldmap.rg, .(group.regroup), ClosePolygons, "long.recenter", "order") # use the new grouping var
#############################################################################

# Plot worldmap using data from worldmap.cp
windows(9.2, 4)
worldmap = ggplot(aes(x = long.recenter, y = lat), data = worldmap.cp) + 
  geom_polygon(aes(group = group.regroup), fill="#f9f9f9", colour = "grey65") + 
  scale_y_continuous(limits = c(-60, 85)) + 
  coord_equal() +  theme_bw() + 
  theme(legend.position = "none",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    #axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks = element_blank(), 
    panel.border = element_rect(colour = "black"))

# Plot the CRAN Mirrors
worldmap = worldmap + geom_point(data = Mirrors, aes(long.recenter, lat),
   colour = "red", pch = 19, size = 3, alpha = .4)

# Colour New Zealand
# Take care of variable names in worldmap.cp
head(worldmap.cp)
worldmap + geom_polygon(data = subset(worldmap.cp, region == "New Zealand", select = c(long.recenter, lat, group.regroup)), 
          aes(x = long.recenter, y = lat, group = group.regroup), fill = "blue")
-------------------------------------------------------------------------------------------------------
plot(x=rep(x_mean, 3), y=c(y_mean, y_max, y_min), bty='n', type="n" )
rect(2,-4,4,4,col = rgb(0.5,0.5,0.5,1/4))
arrows(x0=x_mean, y0=y_min, x1=x_mean, y1=y_max, length=0)
points( x=x_mean, y=y_mean, pch=16) rgb rect
-------------------------------------------------------------------------------------------------------
type library(plyr)
 data <- ddply(data, .( items, name), mutate, is_max = type == type[which.max(value)])

## the plot
ggplot(data, aes(x = type, y = value, fill = is_max, group = items)) + 
  facet_grid(name ~ items, scale = 'free', space = 'free') + 
  geom_bar(stat = 'identity') +  
  scale_fill_manual(values = c('black', 'red'), labels = c('other', 'maximum')) +
  opts(legend.position = "top", legend.text = theme_text(size = 15),  
       legend.title = theme_text(size = 0,colour = "white"), 
       legend.key = theme_rect(colour = NA)) ggplot(data, aes(x=type, y= value, group = items, fill = type)) +  
  facet_grid(name~items, scale = 'free', space = 'free') + 
  geom_bar(stat= 'identity')  +
  geom_bar(data = data[data$is_max,],stat = 'identity', fill = 'red' ) +
  scale_fill_manual(values = rep("grey60",4), 
                    labels = c("type-A", "type-B", "type-C", "type-D")) + 
  opts(strip.text.y = theme_text(size=14, face="bold")) + 
  opts(legend.position="top", legend.text=theme_text(size=15), 
       legend.title=theme_text(size=0,colour="white"), 
       legend.key = theme_rect(colour = NA))
-------------------------------------------------------------------------------------------------------
geom_hline(aes(yintercept=40), color="black", linetype="dashed") geom_boxplot(fill="gray") panel.background = theme_rect(colour = "black")
-------------------------------------------------------------------------------------------------------
tidy = FALSE ```{r tidy=FALSE}
ggplot2(mydata, aes(x, y)) +
  geom_point() +
  geom_line() +
  opts(panel.background = theme_rect(fill = "lightsteelblue2"),
       panel.border = theme_rect(col = "grey"),
       panel.grid.major = theme_line(col = "grey90"),
       axis.ticks = theme_blank(),
       axis.text.x  = theme_text (size = 14, vjust = 0),
       axis.text.y  = theme_text (size = 14, hjust = 1.3))
```
-------------------------------------------------------------------------------------------------------
grid # libraries
library(jpeg)
library(grid)

# a is your image
a <- readJPG("foo.jpg")

# ypos.img is at which height of the barchart you want to place the image
ypos.img <- 10

# Create a new polot
grid.newpage()
pushViewport(viewport(width=0.9, height=0.9))

# add image
pushViewport(viewport(yscale=c(0,sum(DF[,2])), xscale=c(0,1), x=0, y=0, width=0.4, height=1, just=c("left", "bottom")))
grid.raster(a, y=unit(ypos.img, "native"))

# add barplot
popViewport()
pushViewport(viewport(x=0.4, y=0, width=0.6, height=1, just=c("left", "bottom")))
pushViewport(dataViewport(xscale=c(0,2), yscale=c(0, sum(DF[,2]))))
cols <- heat.colors(length(DF[,2]))

for (i in 1:nrow(DF)) {
 start <- 0 
 if (i > 1) start <- sum(DF[1:(i-1), 2])
 grid.rect(x=0, y=start, width=1, height=DF[i, 2], default.units="native", just=c("left", "bottom"), gp=gpar(fill=cols[i]))
}

popViewport(2)

# Legend
pushViewport(viewport(x=0.75, y=0, width=0.25, height=1, just=c("left", "bottom")))
ypos <- 0.8
for (i in 1:nrow(DF)) {
 grid.rect(x=0.05, y=ypos, width=0.1, height=0.05, just=c("left", "bottom"), gp=gpar(fill=cols[i]))
 grid.text(DF[i,1], x=0.2, y=ypos, just=c("left", "bottom"))
 ypos <- ypos - 0.05
}

popViewport()
-------------------------------------------------------------------------------------------------------
party terminal_panel node_barplot R/plot.R fixInNamespace("node_barplot", pos="package:party") labels = NULL, gp = NULL grid.rect(gp = gpar(fill = "transparent")) if (!is.null(labels)) {
  labs <- as.character(labels[ctreeobj@where==node$nodeID])
  len <- length(labs)
  x <- unit(rep(0.5, len), "npc")
  y <- unit(0.5:len/len, "npc")
  for (i in 1:len) 
    grid.text(labs[i], x=x[i], y=y[i], just="center", gp=gp)
} node$nodeID where ctree if gp plot(cfit, tp_pars=list(labels=dfrm$names)) dfrm$names dfrm cfit <- ctree(young ~ age, data=a, 
              controls=ctree_control(minsplit=2, minbucket=2))
plot(cfit, tp_args=list(labels=a$names, gp=gpar(fontsize=8, col="darkgrey"))) iris
-------------------------------------------------------------------------------------------------------
bg_col <- matrix("white",nrow(deciles),ncol(deciles))
bg_col[11,] <- "grey"

# create a plot
hist(foo, freq=F, xlim=c(0,xmax), breaks=50, col="blue")
top <- max(axis(2))
rect(xleft=(.69*xmax), xright=(1.04*xmax), ybottom=(.615*top), ytop=(.665*top), col="gray91", border=NA)
addtable2plot(x=(1.04*xmax), y=(top), xjust=1, yjust=0, table=deciles, cex=0.82,
          title="Title", hlines=TRUE, vlines=TRUE, bty="o", lwd=1.5, bg= bg_col) rect ?addtable2plot
-------------------------------------------------------------------------------------------------------
geom_rect() count df3 <- data.frame(type=c(1,6,4,6,1,4,1,4,1,1,1,1,6,6,1,
                         1,3,1,4,1,4,6,4,6,4,4,6,4,6,4),
                 count=c(6,1,1,1,2,1,6,3,1,6,8,10,3,1,2,
                         2,1,2,1,1,1,1,1,1,3,3,1,17,1,12))

library(ggplot2)

df3$type <- factor(df3$type)
df3$ymin <- 0
df3$ymax <- 1
df3$xmax <- cumsum(df3$count)
df3$xmin <- c(0, head(df3$xmax, n=-1))

plot_1 <- ggplot(df3, 
              aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax, fill=type)) +
          geom_rect(colour="grey40", size=0.5)

png("plot_1.png", height=200, width=800)
print(plot_1)
dev.off()
-------------------------------------------------------------------------------------------------------
g=ggplot(myd,aes(x=xvar,y=yvar))+
    stat_density2d(aes(fill=..level..), geom="polygon") +
    scale_fill_gradient(low="blue", high="green") + theme_bw() gbig=g+geom_rect(data=myd,
        aes(  NULL,
            NULL,
            xmin=0,
            xmax=lowerp,
            ymin=-10,
            ymax=20),
        fill='red',
        alpha=.0051,
        inherit.aes=F)+
  geom_rect(aes(    NULL,
            NULL,
            xmin=upperp,
            xmax=100,
            ymin=upperp,
            ymax=130),
            fill='green',
            alpha=.0051,
            inherit.aes=F)+
  opts(legend.position = "none") dens_top <- ggplot()+geom_density(aes(x))
  dens_right <- ggplot()+geom_density(aes(x))+coord_flip() empty <- ggplot()+geom_point(aes(1,1), colour="white")+
              opts(axis.ticks=theme_blank(), 
                   panel.background=theme_blank(), 
                   axis.text.x=theme_blank(), 
                   axis.text.y=theme_blank(),           
                   axis.title.x=theme_blank(), 
                   axis.title.y=theme_blank()) library(gridExtra)

grid.arrange(dens_top,     empty     , 
             gbig,         dens_right, 
                 ncol=2, 
                 nrow=2, 
                 widths=c(4, 1), 
                 heights=c(1, 4))
-------------------------------------------------------------------------------------------------------
# data
set.seed (123)
xvar <- c(rnorm (1000, 50, 30), rnorm (1000, 40, 10), rnorm (1000, 70, 10))
yvar <-   xvar + rnorm (length (xvar), 0, 20)
myd <- data.frame (xvar, yvar)

require(ggplot2)

# density plot for xvar
upperp = 80   # upper cutoff
lowerp = 30 g=ggplot(myd,aes(x=xvar,y=yvar))+
    stat_density2d(aes(fill=..level..), geom="polygon") +
    scale_fill_gradient(low="blue", high="green") + 
  scale_x_continuous(limits = c(0, 110)) + 
   scale_y_continuous(limits = c(0, 110)) + theme_bw() gbig=g+ geom_rect(data=myd, aes(  NULL,  NULL, xmin=0,  
xmax=lowerp,ymin=0, ymax=20), fill='red', alpha=.0051,inherit.aes=F)+ 
geom_rect(aes(NULL,  NULL,   xmin=upperp,            xmax=110, 
 ymin=upperp,            ymax=110),            fill='green',            
  alpha=.0051,
            inherit.aes=F)+   
  opts(legend.position = "none", 
  plot.margin = unit(rep(0, 4), "lines")) x.dens <- density(myd$xvar)
    df.dens <- data.frame(x = x.dens$x, y = x.dens$y)

   dens_top <- ggplot()+geom_density(aes(myd$xvar, y = ..density..))
+ scale_x_continuous(limits = c(0, 110)) +
geom_area(data = subset(df.dens, x <= lowerp), aes(x=x,y=y), fill = 'red') 
 +  geom_area(data = subset(df.dens, x >= upperp), aes(x=x,y=y), fill = 'green') 
 +    opts (axis.text.x=theme_blank(), axis.title.x=theme_blank(), 
  plot.margin = unit(rep(0, 4), "lines")) + xlab ("") + ylab ("") +  theme_bw() y.dens <- density(myd$yvar)
    df.dens.y <- data.frame(x = y.dens$x, y = y.dens$y)

    dens_right <- ggplot()+geom_density(aes(myd$yvar, y = ..density..))
   + scale_x_continuous(limits = c(0, 110)) +
  geom_area(data = subset(df.dens.y, x <= lowerp), aes(x=x,y=y), 
  fill = 'red') 
  +  geom_area(data = subset(df.dens.y, x >= upperp), aes(x=x,y=y), 
  fill = 'green')
    +      coord_flip() + 


opts (axis.text.x=theme_blank(), axis.title.x=theme_blank(), 
   plot.margin = unit(rep(0, 4), "lines")) + xlab ("") + ylab ("") 
   +  theme_bw() empty <- ggplot()+geom_point(aes(1,1), colour="white")+ 
       scale_x_continuous(breaks = NA) + scale_y_continuous(breaks = NA) +
              opts(axis.ticks=theme_blank(),
                   panel.background=theme_blank(),
                   axis.text.x=theme_blank(),
                   axis.text.y=theme_blank(),
                   axis.title.x=theme_blank(),
                   axis.title.y=theme_blank()) library(gridExtra)
 grid.arrange(dens_top, empty , gbig, dens_right, ncol=2,nrow=2,
 widths=c(2, 1), heights=c(1, 2))
-------------------------------------------------------------------------------------------------------
library("reshape2")
library("ggplot2")

cor_dat <- melt(cor_matrix[-11,])
cor_dat$Var1 <- factor(cor_dat$Var1, levels=item_names)
cor_dat$Var2 <- factor(cor_dat$Var2, levels=rev(item_names))
cor_dat$pctile <- rank(cor_dat$value, na.last="keep")/sum(!is.na(cor_dat$value))

ggplot(data =  cor_dat, aes(x = Var1, y = Var2)) +
  geom_tile(aes(fill = pctile), colour = "white") +
  geom_text(aes(label = sprintf("%1.1f",value)), vjust = 1) +
  scale_fill_gradientn(colours=c("red","red","white","green","green"),
                       values=c(0,0.05,0.5,0.95,1),
                       guide = "none", na.value = "white") +
  coord_equal() +
  opts(axis.title.x = theme_blank(),
       axis.title.y = theme_blank(),
       panel.background = theme_blank()) size_dat <- melt(cor_matrix[11,,drop=FALSE])
size_dat$Var2 <- factor(size_dat$Var2, levels=item_names)
size_dat$frac <- size_dat$value / max(size_dat$value)

ggplot(data=size_dat, aes(x=Var2, y=Var1)) +
  geom_blank() +
  geom_rect(aes(xmin = as.numeric(Var2) - 0.5, 
                xmax = as.numeric(Var2) - 0.5 + frac),
            ymin = -Inf, ymax = Inf, fill="blue", color="white")  +
  coord_equal() +
  opts(axis.title.x = theme_blank(),
       axis.title.y = theme_blank(),
       panel.background = theme_blank()) geom_rect frac Inf -Inf cor_dat2 <- melt(cor_matrix[-(nrow(cor_matrix),])
cor_dat2$Var1 <- factor(cor_dat$Var1, levels=rev(c(item_names, "Size")))
cor_dat2$Var2 <- factor(cor_dat$Var2, levels=item_names)
cor_dat2$pctile <- rank(cor_dat$value, na.last="keep")/sum(!is.na(cor_dat$value))

size_dat2 <- melt(cor_matrix["Size",,drop=FALSE])
size_dat2$Var1 <- factor(size_dat$Var1, levels=rev(c(item_names, "Size")))
size_dat2$Var2 <- factor(size_dat$Var2, levels=item_names)
size_dat2$frac <- size_dat$value / max(size_dat$value)

ggplot(data = cor_dat2, aes(x = Var2, y = Var1)) +
  geom_tile(aes(fill = pctile), colour = "white") +
  geom_text(aes(label = sprintf("%1.1f",value))) +
  geom_rect(data=size_dat2,
            aes(xmin = as.numeric(Var2) - 0.5, 
                xmax = as.numeric(Var2) - 0.5 + frac,
                ymin = as.numeric(Var1) - 0.5,
                ymax = as.numeric(Var1) + 0.5),
            fill="lightblue", color="white")  +
  geom_text(data=size_dat2, 
            aes(x=Var2, y=Var1, label=sprintf("%.0f", value))) +
  scale_fill_gradientn(colours=c("red","red","white","green","green"),
                       values=c(0,0.05,0.5,0.95,1),
                       guide = "none", na.value = "white") +
  scale_y_discrete(drop = FALSE) +
  coord_equal() +
  opts(axis.title.x = theme_blank(),
       axis.title.y = theme_blank(),
       panel.background = theme_blank()) cor_matrix item_names
-------------------------------------------------------------------------------------------------------
par( mar=c(1,5,5,1) )
plot.new()
plot.window( xlim=c(0,10), ylim=c(0,11) )

quant_vals <- findInterval( cor_matrix[-11,], 
    c(-Inf, quantile(cor_matrix[-11,], c(0.05, 0.25, 0.45, 0.55, 0.75, 0.95), na.rm=TRUE ),
            Inf) )
quant_vals[ is.na(quant_vals) ] <- 4
cols <- c('#ff0000','#ff6666','#ffaaaa','#ffffff','#aaffaa','#66ff66','#00ff00')
colmat <- matrix( cols[quant_vals], ncol=10, nrow=10)

rasterImage(colmat, 0, 1, 10, 11, interpolate=FALSE)
for(i in seq_along( cor_matrix[11,] ) ) {
    rect( i-1, 0.1, i-1 + cor_matrix[11,i]/max(cor_matrix[11,]), 0.9, col='lightsteelblue3')
}

text( col( cor_matrix )-0.5, 11.5-row( cor_matrix ), cor_matrix, font=2 )
rect( 0,1,10,11 )
rect( 0,0,10,1)
axis(2, at=(11:1)-0.5, labels=rownames(cor_matrix), tick=FALSE, las=2)
axis(3, at=(1:10)-0.5, labels=colnames(cor_matrix), tick=FALSE, las=2)

rect(0,8,3,11, lwd=2)
rect(4,4,7,7, lwd=2)
rect(8,1,10,3, lwd=2)
-------------------------------------------------------------------------------------------------------
dt1[,"dt"]<-"dt1"  
dt2[,"dt"]<-"dt2"  
dt3<-rbind(dt1,dt2)  
dt3  
  >   yr      X  lower  upper  dt  
50 2004 0.6370 0.4254 0.8614 dt1  
51 2005 0.9701 0.6442 1.3200 dt1  
52 2006 0.7010 0.4699 0.9550 dt1  
53 2007 0.4535 0.2929 0.6261 dt1  
54 2008 0.5058 0.3311 0.6901 dt1  
55 2009 0.4698 0.3213 0.6276 dt1  
56 2010 0.6228 0.4276 0.8385 dt1  
8  2004 0.1753 0.1059 0.2554 dt2  
9  2005 0.2872 0.1747 0.4121 dt2  
10 2006 0.3038 0.1879 0.4319 dt2  
11 2007 0.1994 0.1174 0.2876 dt2  
12 2008 0.2486 0.1542 0.3542 dt2  
13 2009 0.2350 0.1507 0.3222 dt2  
14 2010 0.2604 0.1704 0.3588 dt2 ggplot(dt3, aes(x=yr, y=X, group=dt, ymin = lower, ymax = upper)) +  
     geom_ribbon(alpha = 0.2) +  
     geom_line() +  
     geom_point(shape=21, size=3, fill="blue") +  
     theme_gray(12) +  
     opts(panel.background = theme_rect(fill='grey80')) +  
     ylim(0,1.7) myplot<-ggplot(dt3, aes(x=yr, y=X, group=dt, colour=dt,ymin = lower, ymax = upper)) +  
geom_ribbon(alpha = 0.2, linetype=0)+ geom_line() +  
geom_point(shape=21, size=3, aes(fill=dt)) +  
theme_gray(12) +  
opts(panel.background = theme_rect(fill='grey80')) +  
ylim(0,1.7)  
myplot<-myplot+ scale_color_manual(values=c("red", "blue"))  
myplot<-myplot+ scale_fill_manual(values=c("red", "blue"))  
myplot
-------------------------------------------------------------------------------------------------------
ggplot(dt1, aes(x=yr, y=X, group=1, ymin = lower, ymax = upper)) +
    geom_ribbon(alpha = 0.2) +
    geom_line() +
    geom_point(shape=21, size=3, fill="blue") +
    theme_gray(12) +
    opts(panel.background = theme_rect(fill='grey80')) +
    ylim(0,1.7) +
    geom_path(aes(x=yr, y=X, group=1, ymin = lower, ymax = upper), data=dt2) +
    geom_ribbon(alpha = 0.2, data=dt_inh) +
    geom_point(shape=21, size=3, fill="red", data=dt2)
-------------------------------------------------------------------------------------------------------
my_hist<-ggplot(diamonds, aes(clarity, fill=cut)) + geom_bar()  
my_table<- tableGrob(head(diamonds)[,1:3],gpar.coretext = gpar(fontsize=8),gpar.coltext=gpar(fontsize=8), gpar.rowtext=gpar(fontsize=8))  
pdf("myplot.pdf")  
grid.arrange(my_hist,my_table, ncol=2)  
dev.off()
-------------------------------------------------------------------------------------------------------
scale = "free" facet_grid space = "free" data <- data.frame(ID=factor(c(rep(1,9), rep(2,6), rep(3,6), rep(4,3), rep(5,3))),
                   TYPE=factor(rep(1:3,3)),
                   TIME=factor(c(1,1,1,2,2,2,3,3,3,1,1,1,2,2,2,1,1,1,2,2,2,1,1,1,1,1,1)),
                   VAL=runif(27))

library(ggplot2)
library(plyr)

# Get the cumulative sums
data = ddply(data, .(ID, TIME), mutate, CUMSUMVAL = cumsum(VAL))

ggplot(data, aes(x=VAL, y = as.numeric(ID), fill=TYPE)) +
   geom_rect(data = subset(data, TYPE == 3), aes(xmin = 0, xmax = CUMSUMVAL, ymin = as.numeric(ID)-.2, ymax = as.numeric(ID)+.2)) +
   geom_rect(data = subset(data, TYPE == 2), aes(xmin = 0, xmax = CUMSUMVAL, ymin = as.numeric(ID)-.2, ymax = as.numeric(ID)+.2)) +
   geom_rect(data = subset(data, TYPE == 1), aes(xmin = 0, xmax = CUMSUMVAL, ymin = as.numeric(ID)-.2, ymax = as.numeric(ID)+.2)) +
   facet_grid(TIME~., space = "free", scale="free") +
   scale_y_continuous(breaks = c(1:5), expand = c(0, 0.2)) ggplot(data, aes(x=VAL, y = ID, colour=TYPE)) +
       geom_segment(data = subset(data, TYPE == 3), aes(x = 0, xend = CUMSUMVAL, y = ID, yend = ID), size = 10) +
       geom_segment(data = subset(data, TYPE == 2), aes(x = 0, xend = CUMSUMVAL, y = ID, yend = ID), size = 10) +
       geom_segment(data = subset(data, TYPE == 1), aes(x = 0, xend = CUMSUMVAL, y = ID, yend = ID), size = 10) +
       facet_grid(TIME~., space = "free", scale="free") df <- structure(list(ID = structure(c(1L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 
2L, 2L, 2L, 3L, 3L, 3L, 3L, 3L, 3L, 4L, 4L, 4L, 4L, 4L, 4L, 5L, 
5L, 5L, 5L, 5L, 5L, 6L, 6L, 6L, 6L, 6L, 6L, 7L, 7L, 7L), .Label = c("a", 
"b", "c", "d", "e", "f", "g"), class = "factor"), TYPE = structure(c(1L, 
2L, 3L, 4L, 5L, 1L, 2L, 3L, 4L, 5L, 6L, 1L, 2L, 3L, 4L, 5L, 6L, 
1L, 2L, 3L, 4L, 5L, 6L, 1L, 2L, 3L, 4L, 5L, 6L, 1L, 2L, 3L, 4L, 
5L, 6L, 1L, 2L, 3L), .Label = c("1", "2", "3", "4", "5", "6", 
"7", "8"), class = "factor"), TIME = structure(c(2L, 2L, 2L, 
2L, 2L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 2L, 2L, 
2L, 2L, 2L, 2L, 1L, 1L, 1L, 1L, 1L, 1L, 3L, 3L, 3L, 3L, 3L, 3L, 
1L, 1L, 1L), .Label = c("One", "Five", "Fifteen"), class = "factor"), VAL = c(0.937377670081332, 
0.522220720537007, 0.278690102742985, 0.967633064137772, 0.116124767344445, 
0.0544306698720902, 0.470229141646996, 0.62017166428268, 0.195459847105667, 
0.732876230962574, 0.996336271753535, 0.983087373664603, 0.666449476964772, 
0.291554537601769, 0.167933790013194, 0.860138458199799, 0.172361251665279, 
0.833266809117049, 0.620465772924945, 0.786503327777609, 0.761877260869369, 
0.425386636285111, 0.612077651312575, 0.178726130630821, 0.528709076810628, 
0.492527724476531, 0.472576208412647, 0.0702785139437765, 0.696220921119675, 
0.230852259788662, 0.359884874196723, 0.518227979075164, 0.259466265095398, 
0.149970305617899, 0.00682218233123422, 0.463400925742462, 0.924704828299582, 
0.229068386601284)), .Names = c("ID", "TYPE", "TIME", "VAL"), row.names = c(NA, 
-38L), class = "data.frame")

library(ggplot2)
library(plyr)

data = ddply(df, .(ID, TIME), mutate, CUMSUMVAL = cumsum(VAL))

ggplot(data, aes(x=VAL, y = ID, colour=TYPE)) +
           geom_segment(data = subset(data, TYPE == 6), aes(x = 0, xend = CUMSUMVAL, y = ID, yend = ID), size = 10) +
           geom_segment(data = subset(data, TYPE == 5), aes(x = 0, xend = CUMSUMVAL, y = ID, yend = ID), size = 10) +
           geom_segment(data = subset(data, TYPE == 4), aes(x = 0, xend = CUMSUMVAL, y = ID, yend = ID), size = 10) +
           geom_segment(data = subset(data, TYPE == 3), aes(x = 0, xend = CUMSUMVAL, y = ID, yend = ID), size = 10) +
           geom_segment(data = subset(data, TYPE == 2), aes(x = 0, xend = CUMSUMVAL, y = ID, yend = ID), size = 10) +
           geom_segment(data = subset(data, TYPE == 1), aes(x = 0, xend = CUMSUMVAL, y = ID, yend = ID), size = 10) +
           facet_grid(TIME~., space = "free", scale="free") +
           opts(strip.text.y = theme_text(angle = 0))
-------------------------------------------------------------------------------------------------------
fd <- data.frame(filld, ymin = 4, y =6, ymax = 4.5) geom_rect label fill colour ggplot(fd, aes(x=start,xmin = start, xmax = end, y=y)) +  
   geom_rect(aes(ymin=ymin, ymax=ymax, fill = label )) + 
   ylim (c(0,6)) + 
   coord_polar() ## calculate the midpoint for each segment
fd$xmid <- apply(fd[,1:2],1,mean)
## get the replicate id for the labels (what occurence is this)
library(plyr)
library(reshape2)
fd1 <- ddply(fd, .(label), mutate, id = 1:length(xmid))
## reshape to wide, subsetting only with more than one rep
.lines <- na.omit(dcast(fd1, label~id, value.var = 'xmid'))
## add a mid point between the mid points
.lines$mid <- apply(.lines[,2:3],1,mean)
## reshape to long, and add some y values 
ld <- data.frame(arrange(melt(.lines,value.name = 'x'), label, x), y = rep(c(4,3,4),2))

ggplot(fd) +  
  geom_rect(aes(x=start,xmin = start, xmax = end, y=y,ymin=ymin, ymax=ymax, fill = label )) + 
  ylim (c(0,6)) + 
  coord_polar() + geom_path(data = ld, aes(x=x,y=y,colour = label))
-------------------------------------------------------------------------------------------------------
filld$p <- rowMeans(subset(filld, select = c(start, end)))
ggplot(filld, aes(xmin = start, xmax = end, ymin = 4, ymax = 5, fill = label)) + 
  geom_rect() + 
  geom_segment(data = subset(filld, label %in% label[duplicated(label)]),
               aes(x = p, y = 0, xend = p, yend = 4, colour = label),
               size = 2, show_guide = FALSE) +
  geom_text(aes(x = p, y = 4.5, label = label), colour = "white", size = 10) +
  coord_polar() + 
  scale_y_continuous(limits = c(0, 5)) filld <- data.frame (start = c(1, 4, 6, 7.5, 8, 9), end = c(4, 6, 7.5, 8, 9, 10),
                     label = c("A", "B", "C", "A", "C", "D"))
filld$p <- rowMeans(subset(filld, select = c(start, end)))
filld <- merge(filld, ddply(filld, .(label), summarize, p2 = mean(p)))

lnd <- subset(filld, label %in% label[duplicated(label)])
lnd <- ddply(lnd, .(label), function(x) {
  x <- seq(x$p[1], x$p[2], length = 100)
  y <- 4.5 + ((x - mean(x))^2 - (x[1]-mean(x))^2) / (x[1]-mean(x))^2 * 3 + sin(x*3*pi) * 0.1
  data.frame(x, y)
})


p <- ggplot(filld, aes(xmin = start, xmax = end, ymin = 4, ymax = 5, colour = label, fill = label)) + 
  geom_line(aes(x, y, xmin = NULL, ymin = NULL, xmax = NULL, ymax = NULL), data = lnd, size = 2) +
  geom_rect() + 
  geom_text(aes(x = p, y = 4.5, label = label), colour = "white", size = 10) +
  coord_polar() + 
  scale_y_continuous(limits = c(0, 5))
p
-------------------------------------------------------------------------------------------------------
library(grid)

plot(0:10, 0:10, type="n", xlab="X", ylab="Y")
grid.roundrect(gp=gpar(fill="#00000000", col="grey")) plot(0:10, 0:10, xlab="X", ylab="Y")
grid.roundrect(height=0.99, width=0.99, gp=gpar(fill="#00000000", col="grey"))
-------------------------------------------------------------------------------------------------------
qplot ggplot ggplot() +
  geom_line(aes(x=date, y=unemploy, color=col), data=economics) +
  geom_rect(aes(xmin=start, xmax=end, fill=party),
            ymin = yrng[1], ymax = yrng[2], data = presidential) +
  scale_fill_manual(values = alpha(c("blue", "red"), 0.2)) +           
  xlab("") +
  ylab("No. unemployed (1000s)")
-------------------------------------------------------------------------------------------------------
par ?par dev.new( width= 16, height= 7 )
## set outer margins
par( mar=c(5, 4, 4, 4), cex= 0.9 )
plot( 1:100, type="n", xlab = "", ylab = "", axes = F, las = 2, cex = 0.7 )
axis( 4, at = c ( 0, 30, 60, 90, 120, 150, 180 ), labels = c( "0", "30", "60", "90", "120", "150", "180" ), las = 0, cex.axis = .8,col.lab = "gray80",
tck = 0.01 )
rect( 153, -5.5, 169, 185, col = "gray80", border = NA)
rect( 246, -5.5, 272, 185, col = "gray80", border = NA)
lines( 1:200, col = "gray20" )
#text("Moon phase ()", 330, 90, cex = .9 )
mtext(side = 4, text = "Moon phase ()", line = 2, cex = .9 )
mtext(side = 1, text = "Dates", line = 4, cex = .9 )

par( new = T )
plot( 1:220, type = "n", lwd= 1.2, xlab= "", ylab= "Photoperiod (h)", axes = F, cex = .8, col.lab = "red" )
axis( side= 1, at = c ( 1, 20, 51, 82, 112, 143, 173, 204, 235, 264, 295, 324 ), labels = c ( "12 Jun'07", "1 Jul'07", "1 Aug'07", "1 Sep'07", "1 Oct'07", "1 Nov'07", "1 Dec'07", "1 Jan'08", "1 Feb'08", "1 Mar'08", "1 Apr'08", "30 Apr'08" ), las = 2, cex.axis = .75 )
axis ( side = 2, at = c( 12, 13, 14, 15, 16 ), labels = c( "12", "13", "14", "15", "16" ), cex.axis = .8, las = 2)
box()
-------------------------------------------------------------------------------------------------------
paste(word_before, word, word_after) # Wrap the spell checking in a function, makes your code much more readable
word_correct = function(word) return(nrow(aspell(factor(word))) == 0)
# Merge two words
merge_word = function(word1, word2) return(paste(word1, word2, sep = ""))
# Merge two words and replace in list
merge_words_in_list = function(word_list, idx1, idx2) {
  word_list[idx1] = merge_word(word_list[idx1], word_list[idx2])
  return(word_list[-idx2])
}
# Function that recursively combines words 
combine_words = function(word_list) {
  message("Current sentence: ", paste(word_list, collapse = " "))
  words_ok = sapply(word_list, word_correct)
  if(all(words_ok)) {
    return(word_list) 
  } else {
    first_wrong_word = which(!words_ok)[1]
    combination_before = merge_word(word_list[first_wrong_word], 
                                    word_list[first_wrong_word-1])
    if(word_correct(combination_before)) {
      word_list = merge_words_in_list(word_list, first_wrong_word-1, 
                                      first_wrong_word)
    }
    combination_after = merge_word(word_list[first_wrong_word], 
                                   word_list[first_wrong_word+1])
    if(word_correct(combination_after)) {
      word_list = merge_words_in_list(word_list, first_wrong_word, 
                                      first_wrong_word+1)
    }
    return(combine_words(word_list))  # Recursive call
  }
} word5 <- "hotter the doghou se would be bec ause the col or was diffe rent"
abc1 = strsplit(word5, split = " ")[[1]]
combine_words(abc1)
Current sentence: hotter the doghou se would be bec ause the col or was diffe rent
Current sentence: hotter the doghouse would be bec ause the col or was diffe rent
Current sentence: hotter the doghouse would be because the col or was diffe rent
Current sentence: hotter the doghouse would be because the col or was different combination_before combination_after aspell
-------------------------------------------------------------------------------------------------------
annotate rect text p + annotate("rect", xmin=1.5, xmax=2.5, ymin=12500, ymax= 18000, 
             fill=NA, colour="red") +
    annotate("text", x=1.75, y=17000, label="Region A", size=8) geom_text geom_rect regions <- data.frame(
  xmin=c(1.5, 1, 0),
  xmax=c(2.5, 2, 1),
  ymin=c(12500, 5000, 0),
  ymax=c(17500, 12500, 5000),
  x   =c(2, 1.5, 0.5),
  y   =c(15000, 7500, 2500),
  lab = paste("Region", LETTERS[1:3])
)

p + 
  geom_rect(data=regions, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax), 
            fill=NA, colour="red") +
  geom_text(data=regions, aes(x=x, y=y, label=lab))
-------------------------------------------------------------------------------------------------------
library(party)
data(iris)
attach(iris)

ctree <- ctree(Species ~ Sepal.Length + Sepal.Width 
               + Petal.Length + Petal.Width, data = iris)

# getting ctree's class

> class(ctree)
[1] "BinaryTree"
attr(,"package")
[1] "party" ?'plot.BinaryTree' terminal_panel ?node_barplot plot(ctree, terminal_panel = node_barplot(ctree)) horizontal horiz node_barplot node_barplot # Note inclusion of horiz = FALSE
alt_node_barplot <- function (ctreeobj, col = "black", fill = NULL, beside = NULL, 
    ymax = NULL, ylines = NULL, widths = 1, gap = NULL, reverse = NULL, 
    id = TRUE, horiz = FALSE)
{
    getMaxPred <- function(x) {
        mp <- max(x$prediction)
        mpl <- ifelse(x$terminal, 0, getMaxPred(x$left))
        mpr <- ifelse(x$terminal, 0, getMaxPred(x$right))
        return(max(c(mp, mpl, mpr)))
    }
    y <- response(ctreeobj)[[1]]
    if (is.factor(y) || class(y) == "was_ordered") {
        ylevels <- levels(y)
        if (is.null(beside)) 
            beside <- if (length(ylevels) < 3) 
                FALSE
            else TRUE
        if (is.null(ymax)) 
            ymax <- if (beside) 
                1.1
            else 1
        if (is.null(gap)) 
            gap <- if (beside) 
                0.1
            else 0
    }
    else {
        if (is.null(beside)) 
            beside <- FALSE
        if (is.null(ymax)) 
            ymax <- getMaxPred(ctreeobj@tree) * 1.1
        ylevels <- seq(along = ctreeobj@tree$prediction)
        if (length(ylevels) < 2) 
            ylevels <- ""
        if (is.null(gap)) 
            gap <- 1
    }
    if (is.null(reverse)) 
        reverse <- !beside
    if (is.null(fill)) 
        fill <- gray.colors(length(ylevels))
    if (is.null(ylines)) 
        ylines <- if (beside) 
            c(3, 2)
        else c(1.5, 2.5)
    # My edit do not work if beside is not true
    #################################################
    if(!beside) horiz = FALSE
    #################################################

    rval <- function(node) {
        pred <- node$prediction
        if (reverse) {
            pred <- rev(pred)
            ylevels <- rev(ylevels)
        }
        np <- length(pred)
        nc <- if (beside) 
            np
        else 1
        fill <- rep(fill, length.out = np)
        widths <- rep(widths, length.out = nc)
        col <- rep(col, length.out = nc)
        ylines <- rep(ylines, length.out = 2)
        gap <- gap * sum(widths)
        #######################################################
        if (!horiz){
            yscale <- c(0, ymax)
            xscale <- c(0, sum(widths) + (nc + 1) * gap)
        } else {
            xscale <- c(0, ymax)
            yscale <- c(0, sum(widths) + (nc + 1) * gap)
        }                    
        #######################################################
        top_vp <- viewport(layout = grid.layout(nrow = 2, ncol = 3, 
            widths = unit(c(ylines[1], 1, ylines[2]), c("lines", 
                "null", "lines")), heights = unit(c(1, 1), c("lines", 
                "null"))), width = unit(1, "npc"), height = unit(1, 
            "npc") - unit(2, "lines"), name = paste("node_barplot", 
            node$nodeID, sep = ""))
        pushViewport(top_vp)
        grid.rect(gp = gpar(fill = "white", col = 0))
        top <- viewport(layout.pos.col = 2, layout.pos.row = 1)
        pushViewport(top)
        mainlab <- paste(ifelse(id, paste("Node", node$nodeID, 
            "(n = "), "n = "), sum(node$weights), ifelse(id, 
            ")", ""), sep = "")
        grid.text(mainlab)
        popViewport()
        plot <- viewport(layout.pos.col = 2, layout.pos.row = 2, 
            xscale = xscale, yscale = yscale, name = paste("node_barplot", 
                node$nodeID, "plot", sep = ""))
        pushViewport(plot)
        if (beside) {
            #############################################################
            if(!horiz){
                xcenter <- cumsum(widths + gap) - widths/2
                for (i in 1:np) {
 grid.rect(x = xcenter[i], y = 0, height = pred[i], width = widths[i], just = c("center", "bottom"), default.units = "native", gp = gpar(col = col[i],fill = fill[i]))
                }
                if (length(xcenter) > 1) 
                    grid.xaxis(at = xcenter, label = FALSE)
                grid.text(ylevels, x = xcenter, y = unit(-1, "lines"), 
                    just = c("center", "top"), default.units = "native", 
                    check.overlap = TRUE)
                grid.yaxis()
            } else {
                ycenter <- cumsum(widths + gap) - widths/2
                for (i in 1:np) {
grid.rect(y = ycenter[i], x = 0, width = pred[i], height = widths[i], just = c("left", "center"), default.units = "native", gp = gpar(col = col[i], fill = fill[i]))
                }
                if (length(ycenter) > 1) 
                    grid.yaxis(at = ycenter, label = FALSE)
                        grid.text(ylevels, y = ycenter, x = unit(-1, "lines"), 
                        just = c("right", "center"), default.units = "native", 
                         check.overlap = TRUE)
                grid.xaxis()
            }
        #############################################################
        }
        else {
            ycenter <- cumsum(pred) - pred
            for (i in 1:np) {
             
            }
            if (np > 1) {
                grid.text(ylevels[1], x = unit(-1, "lines"), 
                  y = 0, just = c("left", "center"), rot = 90, 
                  default.units = "native", check.overlap = TRUE)
                grid.text(ylevels[np], x = unit(-1, "lines"), 
                  y = ymax, just = c("right", "center"), rot = 90, 
                  default.units = "native", check.overlap = TRUE)
            }
            if (np > 2) {
                grid.text(ylevels[-c(1, np)], x = unit(-1, "lines"), 
                  y = ycenter[-c(1, np)], just = "center", rot = 90, 
                  default.units = "native", check.overlap = TRUE)
            }
            grid.yaxis(main = FALSE)
        }
        grid.rect(gp = gpar(fill = "transparent"))
        upViewport(2)
    }
    return(rval)
} plot(ctree, terminal_panel = alt_node_barplot(ctree, horiz = TRUE)) beside horiz beside ?viewport ?grid.rect reverse
-------------------------------------------------------------------------------------------------------
plot(TreeResults,tp_args = list(beside=F)) node_barplot() altbp<-function (ctreeobj, col = "black", fill = NULL, beside = NULL, 
    ymax = NULL, ylines = NULL, widths = 1, gap = NULL, reverse = NULL, 
    id = TRUE,rot=45) 
{
    getMaxPred <- function(x) {
        mp <- max(x$prediction)
        mpl <- ifelse(x$terminal, 0, getMaxPred(x$left))
        mpr <- ifelse(x$terminal, 0, getMaxPred(x$right))
        return(max(c(mp, mpl, mpr)))
    }
    y <- response(ctreeobj)[[1]]
    if (is.factor(y) || class(y) == "was_ordered") {
        ylevels <- levels(y)
        if (is.null(beside)) 
            beside <- if (length(ylevels) < 3) 
                FALSE
            else TRUE
        if (is.null(ymax)) 
            ymax <- if (beside) 
                1.1
            else 1
        if (is.null(gap)) 
            gap <- if (beside) 
                0.1
            else 0
    }
    else {
        if (is.null(beside)) 
            beside <- FALSE
        if (is.null(ymax)) 
            ymax <- getMaxPred(ctreeobj@tree) * 1.1
        ylevels <- seq(along = ctreeobj@tree$prediction)
        if (length(ylevels) < 2) 
            ylevels <- ""
        if (is.null(gap)) 
            gap <- 1
    }
    if (is.null(reverse)) 
        reverse <- !beside
    if (is.null(fill)) 
        fill <- gray.colors(length(ylevels))
    if (is.null(ylines)) 
        ylines <- if (beside) 
            c(3, 2)
        else c(1.5, 2.5)
    rval <- function(node) {
        pred <- node$prediction
        if (reverse) {
            pred <- rev(pred)
            ylevels <- rev(ylevels)
        }
        np <- length(pred)
        nc <- if (beside) 
            np
        else 1
        fill <- rep(fill, length.out = np)
        widths <- rep(widths, length.out = nc)
        col <- rep(col, length.out = nc)
        ylines <- rep(ylines, length.out = 2)
        gap <- gap * sum(widths)
        yscale <- c(0, ymax)
        xscale <- c(0, sum(widths) + (nc + 1) * gap)
        top_vp <- viewport(layout = grid.layout(nrow = 2, ncol = 3, 
            widths = unit(c(ylines[1], 1, ylines[2]), c("lines", 
                "null", "lines")), heights = unit(c(1, 1), c("lines", 
                "null"))), width = unit(1, "npc"), height = unit(1, 
            "npc") - unit(2, "lines"), name = paste("node_barplot", 
            node$nodeID, sep = ""))
        pushViewport(top_vp)
        grid.rect(gp = gpar(fill = "white", col = 0))
        top <- viewport(layout.pos.col = 2, layout.pos.row = 1)
        pushViewport(top)
        mainlab <- paste(ifelse(id, paste("Node", node$nodeID, 
            "(n = "), "n = "), sum(node$weights), ifelse(id, 
            ")", ""), sep = "")
        grid.text(mainlab)
        popViewport()
        plot <- viewport(layout.pos.col = 2, layout.pos.row = 2, 
            xscale = xscale, yscale = yscale, name = paste("node_barplot", 
                node$nodeID, "plot", sep = ""))
        pushViewport(plot)
        if (beside) {
            xcenter <- cumsum(widths + gap) - widths/2
            for (i in 1:np) {
                grid.(x = xcenter[i], y = 0, height = pred[i], 
                  width = widths[i], just = c("center", "bottom"), 
                  default.units = "native", gp = gpar(col = col[i], 
                    fill = fill[i]))
            }
            if (length(xcenter) > 1) 
                grid.xaxis(at = xcenter, label = FALSE)
            grid.text(ylevels, x = xcenter, y = unit(-1, "lines"), 
                just = c("center", "top"), default.units = "native", 
                check.overlap = TRUE,rot=rot)
            grid.yaxis()
        }
        else {
            ycenter <- cumsum(pred) - pred
            for (i in 1:np) {
                grid(x = xscale[2]/2, y = ycenter[i], height = min(pred[i], 
                  ymax - ycenter[i]), width = widths[1], just = c("center", 
                  "bottom"), default.units = "native", gp = gpar(col = col[i], 
                  fill = fill[i]))
            }
            if (np > 1) {
                grid.text(ylevels[1], x = unit(-1, "lines"), 
                  y = 0, just = c("left", "center"), rot = 90, 
                  default.units = "native", check.overlap = TRUE)
                grid.text(ylevels[np], x = unit(-1, "lines"), 
                  y = ymax, just = c("right", "center"), rot = 90, 
                  default.units = "native", check.overlap = TRUE)
            }
            if (np > 2) {
                grid.text(ylevels[-c(1, np)], x = unit(-1, "lines"), 
                  y = ycenter[-c(1, np)], just = "center", rot = 90, 
                  default.units = "native", check.overlap = TRUE)
            }
            grid.yaxis(main = FALSE)
        }
        grid.rect(gp = gpar(fill = "transparent"))
        upViewport(2)
    }
    return(rval)
} rot= grid.text beside=T plot(TreeResults,terminal_panel=altbp(TreeResults,ylines=1.2, gap=0.05,rot=45)) node_barplot altbp<-node_barplot
body(altbp)[[8]][[3]][[3]][[23]][[3]][[5]]<-substitute(
grid.text(ylevels, x = xcenter, y = unit(-1, "lines"), just = c("center", 
    "top"), default.units = "native", check.overlap = TRUE,rot=45)
)
plot(TreeResults,terminal_panel=altbp(TreeResults)) altbp
-------------------------------------------------------------------------------------------------------
dtt$model <- factor(dtt$model, levels=c("mb", "ma", "mc"), labels=c("MBB", "MAA", "MCC"))

library(ggplot2)
ggplot(dtt, aes(x=year, y=V, group = model, colour = model, ymin = lower, ymax = upper)) +
  geom_ribbon(alpha = 0.35, linetype=0)+ 
  geom_line(aes(linetype=model), size = 1) +       
  geom_point(aes(shape=model), size=4)  +      
  opts(legend.position=c(.6,0.8)) +
  opts(legend.background = theme_(colour = 'black', fill = 'grey90', size = 1, linetype='solid')) +
  opts() +
  scale_linetype_discrete("Model 1") +
  scale_shape_discrete("Model 1") +
  scale_colour_discrete("Model 1") ggplot(dtt, aes(x=year, y=V, group = model, colour = model, ymin = lower, ymax = upper)) +
  geom_ribbon(alpha=0.2, colour=NA)+ 
  geom_line() +       
  geom_point()  +      
  facet_wrap(~model)
-------------------------------------------------------------------------------------------------------
rect rect # set up simple plotting window
plot.new()
plot.window(xlim=c(0,6),ylim=c(0,8))

# example data. Using colour as the categorical value we will filter on
sample.d <- data.frame(x=c(3,4,5,6), yb=c(1,3,5,7), yt=c(0,2,4,6), colour=c("black","black","red","red"))

# draw black rectangles
black.d <- sample.d[sample.d$colour == "black",]
rect(0, black.d$yb, black.d$x, black.d$yt, col="black")

# draw red rectangles
red.d <- sample.d[sample.d$colour == "red",]
rect(0, red.d$yb, red.d$x, red.d$yt, col="red")
-------------------------------------------------------------------------------------------------------
plot(1:10)
mydf <- data.frame( xl =1:5, yb=1:5, xr=2:6, yt=10:6, 
    group=sample( c('A','B'), 5, replace=TRUE) )
with(mydf, 
rect( xl, yb, xr, yt, col=c('black','grey')) 
-------------------------------------------------------------------------------------------------------
mx=12
 my=12
 par(mar = c(mx,my, 4, 2) + 0.1)
 plot(c(1,4),c(1,4),type="n",main="title",xlab="site.x",ylab="ylab")
 rect(xleft,ybottom,xright,ytop,col=c("blue","red","green"))
 text(par()$usr[1]-0.5,y.label.position,y.label,xpd=TRUE,adj=1)
 text(y=par()$usr[3]-0.5,x=x.label.position,x.label,xpd=TRUE,adj=1,srt=90) mx my xpd=TRUE par(xpd=TRUE)
 legend(locator(1),legend=c("Species A","Species B","Species C"),
                             fill=c("blue", "red", "green")) locator(1) list(x=-0.7,y=0.6) ggplot
-------------------------------------------------------------------------------------------------------
par("mfg") par(mai=c(2.5, 2.25, 0.82, 0.42), mgp=c(9, 1, 0))
plot(c(1,4), c(1,4), xaxp=c(1,4,3), yaxp=c(1,4,3), type="n", 
  main="title", xlab="site.x", ylab="ylab")
rect(xleft, ybottom, xright, ytop, col=c("blue","red","green"))
axis(1, at=x.label.position, labels=x.label, las=2)
axis(2, at=y.label.position, labels=y.label, las=2)
par(xpd=TRUE)
legend(x=0.25, y=0.75, 
  legend=c("Text", "Text", "Text"),
  fill=c("blue", "red", "green"),
  title="Legend") ggplot2
-------------------------------------------------------------------------------------------------------
rle runs <- rle(as.logical(spy[, 1] > spy[, 2]))
l <- list(start=cumsum(runs$length)[which(runs$values)] - runs$length[which(runs$values)] + 1,
          end=cumsum(runs$lengths)[which(runs$values)])
rect <- data.frame(xmin=l$start, xmax=l$end, ymin=-Inf, ymax=Inf) ggplot2 ggplot(spy,aes(x=index(spy),y=spy$SPY.Adjusted))+geom_line()+geom_line(aes(x=index(spy),y=spy$sma))+geom_rect(data=rect, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax), color="grey20", alpha=0.5, inherit.aes = FALSE) alpha=1 geom_rect ggplot(spy,aes(x=index(spy),y=spy$SPY.Adjusted))+geom_rect(data=rect, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax), border=NA, color="grey20", alpha=1, inherit.aes = FALSE)+geom_line()+geom_line(aes(x=index(spy),y=spy$sma)) xts data.frame plot.xts spy <- as.xts(spy)
require(xtsExtra)
plot(spy, screens=1,
     blocks=list(start.time=paste(index(spy)[l$start]),
                 end.time=paste(index(spy)[l$end]), col='lightblue'),                    
     legend.loc='bottomright', auto.legend=TRUE)
-------------------------------------------------------------------------------------------------------
fit=ggplot(a1,aes(x,y,color=factor(colors)),col=colors)+
    geom_text(aes(label=Freq),size=5)+
    theme_bw()+
    scale_color_hue(breaks=c("1", "2", "3"),
                      labels=c("Low", "Medium", "High"))+
    opts(legend.position='top',
         legend.title=theme_blank(),
         legend.key=theme_rect(fill="white",colour="white"))
  print(fit)
  grid.gedit("^key-[-0-9]+$", label = "*")
-------------------------------------------------------------------------------------------------------
```{r example_pairs, include = F, fig.keep = 'none'}
example(pairs)
```

```{r test}
exists('panel.cor')
``` ## [1] TRUE panel.cor give.lines .ex <- example(pairs, give.lines = T)
# find the code in question (look for assignment / scope delimiters)
which(grepl(.ex, pattern = "(panel.hist <-)|(panel.cor <-)|[{}]"))
##[1] 18 19 26 33 34 42

cat(.ex[c(18:26, 33:42)], sep = "\n")
panel.hist <- function(x, ...)
{
    usr <- par("usr"); on.exit(par(usr))
    par(usr = c(usr[1:2], 0, 1.5) )
    h <- hist(x, plot = FALSE)
    breaks <- h$breaks; nB <- length(breaks)
    y <- h$counts; y <- y/max(y)
    rect(breaks[-nB], 0, breaks[-1], y, col="cyan", ...)
}
panel.cor <- function(x, y, digits=2, prefix="", cex.cor, ...)
{
    usr <- par("usr"); on.exit(par(usr))
    par(usr = c(0, 1, 0, 1))
    r <- abs(cor(x, y))
    txt <- format(c(r, 0.123456789), digits=digits)[1]
    txt <- paste(prefix, txt, sep="")
    if(missing(cex.cor)) cex.cor <- 0.8/strwidth(txt)
    text(0.5, 0.5, txt, cex = cex.cor * r)
}
-------------------------------------------------------------------------------------------------------
ggplot library(ggplot2)
df <- data.frame(x = c(1,10), y = c(20,40), class = 1:2)
layered_plot <- ggplot(df, aes(xmin = x, xmax = x + 1, ymin = y, ymax = y + 2, fill = class)) +
geom_rect() + 
opts(legend.position = "none") 
# Now save this as pdf
ggsave(layered_plot, file="p1.pdf") png pdf
-------------------------------------------------------------------------------------------------------
plot xaxs yaxs xaxs="r" xaxs="i" xaxs ?par plot(c(1,2.75),c(1,2.75),type="n",main="title",xlab="site.x",ylab="ylab", xaxs="i", yaxs="i")
rect(xleft,ybottom,xright,ytop,col=c("blue","red","green"))
-------------------------------------------------------------------------------------------------------
ggplot(mry, aes(x=year, y=number, colour=factor(rating))) +
  scale_colour_brewer(palette="YlGnBu") +  
  geom_point()  +      
  geom_point(size=5,colour="white",show_guide=FALSE)  +
  opts(
    panel.background = theme_rect(fill =  "transparent"), 
    panel.grid.minor = theme_blank(),
    panel.grid.major = theme_blank(),
    plot.background = theme_rect(fill = "transparent",colour = NA)
  ) +  geom_line(show_guide=FALSE)
-------------------------------------------------------------------------------------------------------
red30 scale_color_manual ggplot(data=df, aes(x=n, y=rt, group=kernel, shape=kernel, colour=kernel)) + 
 geom_point(fill="white", size=3) + geom_line() + xlab("n") + ylab("Runtime (s)") + 
 opts(title=title,plot.title=theme_text(size=font.size)) + 
 scale_colour_manual(values=c("grey30", "#EF8A62")) + 
 opts(legend.position = c(x_shift,0.87),legend.background=theme_rect(fill =  "transparent",colour=NA)) ggplot2 scale_brewer
-------------------------------------------------------------------------------------------------------
alpha 1/256 ggplot(d) + geom_density(aes(x = data), col = NA, fill = 'grey30') + 
  theme(panel.background = NULL) +
  geom_rect(aes(xmin = -30, xmax = 30, ymin = 0, ymax = 0.005), 
            fill = 'white', alpha = 1/256) alpha = I(1/d) d 1/256 geom_rect
-------------------------------------------------------------------------------------------------------
tex animation .Rnw ocgtools \documentclass{article}
%----------------------------------------------------------------%\
\usepackage[OT1]{fontenc}
\usepackage{Sweave}
\usepackage{animate}
\usepackage{hyperref}
\usepackage[margin=0.4in]{geometry}
%----------------------------------------------------------------%

\makeatletter
% command to create a toggle link
\newcommand{\ShowHideLayer}[3]{%
  % #1: anim No. (zero-based),
  % #2: layer No. (zero-based),
  % #3: link text
  \leavevmode%
  \pdfstartlink user {
    /Subtype /Link
    /Border [\@pdfborder]%
    /A <<
      /S/JavaScript
      /JS (
        \if at anim@useocg%
          if(a#1.fr[#2].state==true){
            a#1.fr[#2].state=false;
          }else{
            a#1.fr[#2].state=true;
          }
        \else
          if (a#1.fr[#2].display==display.visible){
            a#1.fr[#2].display=display.hidden;
          }else{
            a#1.fr[#2].display=display.visible;
          }
          this.dirty=false;
        \fi
      )
    >>
  }#3%
  \pdfendlink%
}

% command to create a link to show/hide all layers
\newcommand{\ShowHideAll}[2]{%
  % #1: anim No. (zero-based),
  % #2: link text
  \leavevmode%
  \pdfstartlink user {
    /Subtype /Link
    /Border [\@pdfborder]%
    /A <<
      /S/JavaScript
      /JS (
        var countvisible=0;
        for(var i in a#1.fr){
          \if at anim@useocg
            if(a#1.fr[i].state==true){countvisible++;}
          \else
            if (a#1.fr[i].display==display.visible){countvisible++;}
          \fi
        }
        if(countvisible){
          for(var i in a#1.fr){
            \if at anim@useocg
              a#1.fr[i].state=false;
            \else
              a#1.fr[i].display=display.hidden;
              this.dirty=false;
            \fi
          }
        }
        else{
          for(var i in a#1.fr){
            \if at anim@useocg
              a#1.fr[i].state=true;
            \else
              a#1.fr[i].display=display.visible;
              this.dirty=false;
            \fi
          }
        }
      )
    >>
  }#2%
  \pdfendlink%
}
\makeatother

\begin{document}

% heres the R-making of the plots, saved to working directory,
% which should be the folder containing this .Rnw file
% 3 versions of the same plot, one for each layer
<<echo = FALSE, hide = TRUE>>=
pdf("layer-0.pdf")
plot(NULL, type = "n", xlim = c(0, 1), ylim = c(0, 1), xlab = "", ylab = "")
dev.off()

pdf("layer-1.pdf")
plot(NULL, type = "n", xlim = c(0, 1), ylim = c(0, 1), axes = FALSE, xlab = "", ylab = "")
rect(0, .7, .7, 0, border = "blue", lwd = 2)
dev.off()

pdf("layer-2.pdf")
plot(NULL, type = "n", xlim = c(0, 1), ylim = c(0, 1), axes = FALSE, xlab = "", ylab = "")
rect(.3, 1, 1, .3, border = "red", lty = 2, lwd = 2)
dev.off()
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{center}
  %animated layer-set No. 0
  %                                          v-- frame rate ignored
  \animategraphics[width=1\linewidth,step]{1}{layer-}{0}{2}

  \ShowHideLayer{0}{1}{toggle red box}\\
  \ShowHideLayer{0}{2}{toggle blue box}\\
\end{center}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
-------------------------------------------------------------------------------------------------------
R DF <-
structure(list(id = c(1L, 1L), start = structure(c(1262340000, 
1262592000), class = c("POSIXct", "POSIXt"), tzone = "GMT"), 
    end = structure(c(1262469600, 1262613600), class = c("POSIXct", 
    "POSIXt"), tzone = "GMT")), .Names = c("id", "start", "end"
), row.names = c(NA, -2L), class = "data.frame") > DF
  id               start                 end
1  1 2010-01-01 10:00:00 2010-01-02 22:00:00
2  1 2010-01-04 08:00:00 2010-01-04 14:00:00 library("chron")
library("plyr")
DF$start.day <- as.Date(DF$start)
DF$end.day <- as.Date(DF$end)
DF$start.time <- as.chron(DF$start) - floor(as.chron(DF$start))
DF$end.time <- as.chron(DF$end) - floor(as.chron(DF$end)) t0 <- min(DF$start.day, DF$end.day)-1
DF$start.monitored.day <- as.numeric(DF$start.day - t0)
DF$end.monitored.day <- as.numeric(DF$end.day - t0) DF$index <- seq_len(nrow(DF))
DF <- ddply(DF, .(index), function(df) {
  if(df$start.monitored.day == df$end.monitored.day) {
    df 
  } else {
    data.frame(start.monitored.day = df$start.monitored.day : df$end.monitored.day,
               end.monitored.day = df$start.monitored.day : df$end.monitored.day,
               start.time = c(df$start.time, rep(times("00:00:00"), df$end.monitored.day-df$start.monitored.day)),
               end.time = times(c(rep(times("23:59:59"), df$end.monitored.day-df$start.monitored.day), df$end.time)),
               id = df$id,
               index = df$index)
  }
}) > DF[c("start.monitored.day", "end.monitored.day", "start.time", "end.time")]
  start.monitored.day end.monitored.day start.time end.time
1                   1                 1   10:00:00 23:59:59
2                   2                 2   00:00:00 22:00:00
3                   4                 4   08:00:00 14:00:00 ggplot library("ggplot2")
library("scales")
timesreverse_trans <- function() {
    trans <- function(x) {-as.numeric(x)}
    inv <- function(x) {times(-x)}
    fmt <- function(x) {
        notone <- x != 1
        simplify <- !any(diff(x) < 1/(24*60))
        ifelse(notone, 
               format(x-floor(x), simplify=simplify),
               ifelse(simplify, "24:00", "24:00:00"))
    }
    trans_new("chrontimes-reverse",
              transform = trans,
              inverse = inv,
              breaks = pretty_breaks(),
              format = fmt,
              domain=c(0,1))
}
scale_y_times <- function(..., trans=NULL) {
    scale_y_continuous(..., trans=timesreverse_trans())
} ggplot(DF) +
  min = start.monitored.day - 0.5,xmax = start.monitored.day + 0.5, ymin = start.time,ymax = end.time)) +
  scale_y_times("Time") +
  scale_x_continuous("Monitored day")
-------------------------------------------------------------------------------------------------------
qplot(prevRT, RT, group=ss, color = prim, 
 geom = c("smooth"), 
 method="lm", data =ss) + 
 facet_grid(~ Groupe) + 
 s, 
      aes(xmin=ave(ss$RT, ss$Groupe, FUN = function(x)quantile(x,c(0.05))),      
      xmax=ave(ss$RT, ss$Groupe, FUN = function(x)quantile(x,c(0.95))),
      ymin=-Inf,ymax=Inf), color="green", alpha=1/280, inherit.aes = FALSE)
-------------------------------------------------------------------------------------------------------
rect addtable2plotx <- fix(addtable2plot) if (hlines && vlines) rect(... addtable2plotx addtable2plot hlines vlines
-------------------------------------------------------------------------------------------------------
library('ggplot2')
library('plyr')
library('RColorBrewer')
library(scales)


label_positions<- function(x) {
  n<-length(x)
  wynik<-numeric(n)
  for (i in 1:n){
    if (i==1) {
      wynik[i]<-0+x[i]/2
    }
    else {
      wynik[i]<-x[i]-(x[i]-x[i-1])/2
    }
  }
  return(wynik)
}

exam1<-ddply(example,.(GroupingVar,FacetVar,VarOfInterest), 'nrow')
exam1.1<-ddply(example,.(GroupingVar,FacetVar),summarise, sr=mean(as.numeric(VarOfInterest),na.rm=T),
               odch=sd(as.numeric(VarOfInterest,na.rm=T)))

exam1<-merge(exam1,exam1.1,by.x=c('GroupingVar','FacetVar'),by.y=c('GroupingVar','FacetVar'))

names(exam1)[4]<-'Count'

exam2<-mutate(exam1,cumul=ave(Count,list(GroupingVar,FacetVar),FUN=cumsum),
              N=ave(cumul, list(GroupingVar,FacetVar),FUN=max),
              CumSumPercent=cumul/N*100,
              Freq=Count/N*100)


exam2<-mutate(exam2,cfrq = ave(CumSumPercent, list(GroupingVar,FacetVar), FUN = label_positions))
exam2$XLabel<-paste(exam2$GroupingVar,' (N=',exam2$N,')',sep='')
exam2$PosMean<-105

p<-ggplot(exam2, aes(x = Etykieta, y = Freq, fill = VarOfInterest)) +
  geom_bar(stat = 'identity',colour="black") +
  labs (x = "", y = "Percentage", fill=" ") + 
  scale_fill_brewer(name="Rating", palette="Greens", breaks = rev(levels(exam2$VarOfInterest))) +
  geom_text(aes(y = cfrq, label=paste(sprintf("%.01f",Freq), "%", sep='')), size=5) +
  geom_text(aes(y=PosMean,label=paste(sprintf("%.02f",sr),' (',sprintf("%.02f",odch),')',sep='')),size=5)+
                      facet_wrap(~FacetVar,ncol=1)  +
                       coord_flip() + ylab('Procent odpowiedzi') + 
  guides(fill=guide_legend(title=NULL)) + theme_bw()  + 
  theme(legend.position="bottom",strip.text.x=element_text(size=15,face='bold'),
        axis.text.x =element_text(size=12,face='bold'), axis.text.y =element_text(size=12,face='bold'),
        axis.title.x=element_text(size=15,face='bold'), axis.title.y=element_text(size=15,face='bold'),
        strip.background=element_rect(colour='black'))

plot(p)
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(extrafont)

### Already have read in fonts (see previous answer on how to do this)
loadfonts()

### Set up the trial dataset 
data <- NULL
data$x <- seq(1, 10, 0.1)
data$y1 <- sin(data$x)
data$y2 <- cos(data$x)
data$xaxis <- -1.5

data <- as.data.frame(data)

### XKCD theme
theme_xkcd <- theme(
    panel.background = element_rect(fill="white"), 
    axis.ticks = element_line(colour=NA),
    panel.grid = element_line(colour="white"),
    axis.text.y = element_text(colour=NA), 
    axis.text.x = element_text(colour="black"),
    text = element_text(size=16, family="Humor Sans")
    )

 ### Plot the chart
 p <- ggplot(data=data, aes(x=x, y=y1))+
      geom_line(aes(y=y2), position="jitter")+
      geom_line(colour="white", size=3, position="jitter")+
      geom_line(colour="red", size=1, position="jitter")+
      geom_text(family="Humor Sans", x=6, y=-1.2, label="A SIN AND COS CURVE")+
      geom_line(aes(y=xaxis), position = position_jitter(h = 0.005), colour="black")+
      scale_x_continuous(breaks=c(2, 5, 6, 9), 
      labels = c("YARD", "STEPS", "DOOR", "INSIDE"))+labs(x="", y="")+
      theme_xkcd

ggsave("xkcd_ggplot.jpg", plot=p, width=8, height=5)
-------------------------------------------------------------------------------------------------------
theme(panel.border = element_blank(), axis.line = element_line()) dat <- structure(list(x = c(0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1, 1.05, 
    1.1, 1.15, 1.2, 1.25, 1.3), y1 = c(34, 30, 26, 23, 21, 19, 17, 
    16, 15, 13, 12, 12, 11), y2 = c(45, 39, 34, 31, 28, 25, 23, 21, 
    19, 17, 16, 15, 14)), .Names = c("x", "y1", "y2"), row.names = c(NA, 
    -13L), class = "data.frame")


library(reshape2); library(ggplot2)
dat2 <- melt(dat, id='x')

ggplot(data=dat2, aes(x=x, y=value, color=variable)) + 
    geom_point(size=3) + geom_line(size=.5) +
    theme(panel.border = element_blank(), axis.line = element_line())

# or using the template you used from talkstats...
ggplot(data=dat2, aes(x=x, y=value, color=variable)) + 
    geom_point(size=3) + geom_line(size=1.5) +
    scale_y_continuous(breaks=seq(0, 45, by=5)) +
    scale_x_continuous(breaks=seq(.7, 1.3, by=.05)) +
    theme_bw() + ylab("Sample Size") + xlab("Mean Difference") +
    theme(legend.position="bottom", legend.title=element_blank(),
        legend.key = element_rect(colour = 'white'), 
        legend.background = element_rect(colour = "black")) +
    ggtitle("Sample Size vs. Mean Difference by Power") +
    theme(panel.border = element_blank(), axis.line = element_line())
-------------------------------------------------------------------------------------------------------
color=dat3$cols ggplot(dat3, aes(x=variable,  y=value, fill=grouping.var)) + 
  geom_bar(position="dodge", stat="identity")  +
  coord_flip() + theme_bw() + 
  theme(legend.position="top", legend.background = element_rect(color="white"),
        panel.grid.major=element_blank(),panel.grid.minor=element_blank(),
        legend.title=element_blank(), axis.ticks.y = element_blank(), 
        axis.text.y = element_blank()) +
          ylab("") +  xlab("") + facet_wrap(~variable, ncol=2, scales = "free_x") +
          scale_fill_manual(values=c("#0000FF", "#FF0000"),
                            guide = guide_legend(reverse=TRUE))+
geom_text(aes(label = labs,  y = loc, x = variable),
          size = 5, position = position_dodge(width=0.9))
-------------------------------------------------------------------------------------------------------
x <- rnorm(1e6)  ## data forming your empirical distribution
ll <- -1.96      ## lower bound of interval of interest
ul <- 1.96       ## upper bound of interval of interest

sum(x > ll & x < ul)/length(x)
# [1] 0.949735 h <- hist(x, breaks=100, plot=FALSE)       # Calculate but don't plot histogram
maxct <- max(h$counts)                     # Extract height of the tallest bar
## Or, if you want the height of the tallest bar within the interval
# start <- findInterval(ll, h$breaks)
# end   <- findInterval(ul, h$breaks)
# maxct <- max(h$counts[start:end])

plot(h, ylim=c(0, 1.05*maxct), col="blue") # Plot, leaving a bit of space up top

rect(xleft = ll, ybottom = -0.02*maxct,    xright = ul, ytop = 1.02*maxct,    border = "red", lwd = 2)
-------------------------------------------------------------------------------------------------------
set.seed(42) 
x <- rlnorm(5000) #some data
hist(x) #histogram
rect(7,-50,10,100,border="red") #red rectangle
table(cut(x,breaks=c(0,7,10,Inf)))/length(x) #fraction of values in intervals
#(0,7]    (7,10]   (10,Inf] 
#0.9754   0.0136   0.0110 Cut table length(x)
-------------------------------------------------------------------------------------------------------
ifelse scale_size_manual geom_rect geom_rect # Using ggplot2 version 0.9.2.1
library(ggplot2)

# Test dataset from original post has been assigned to 'molten'.

molten$Var2 = factor(molten$Var2)

# Example 1.
p1 = ggplot(data=molten, aes(x=Var1, y=Var2, fill=value)) +
     geom_raster() +
     scale_fill_gradient2(low="blue", high="red", na.value="black", name="") +
     geom_point(aes(size=ifelse(na, "dot", "no_dot"))) +
     scale_size_manual(values=c(dot=6, no_dot=NA), guide="none") +
     labs(title="Example 1")

ggsave(plot=p1, filename="plot_1.png", height=3, width=3.5) # Example 2.
# Create auxiliary data.frame.
frames = molten[molten$na, c("Var1", "Var2")]
frames$Var1 = as.integer(frames$Var1)
frames$Var2 = as.integer(frames$Var2)

p2 = ggplot(data=molten) +
     geom_raster(aes(x=Var1, y=Var2, fill=value)) +
     scale_fill_gradient2(low="blue", high="red", na.value="black", name="") +
     geom_ata=frames, size=1, fill=NA, colour="black",
       aes(xmin=Var1 - 0.5, xmax=Var1 + 0.5, ymin=Var2 - 0.5, ymax=Var2 + 0.5)) +
     labs(title="Example 2")

ggsave(plot=p2, filename="plot_2.png", height=3, width=3.5)
-------------------------------------------------------------------------------------------------------
VerticalHist <- function(x, xscale = NULL, xwidth, hist,
                         fillCol = "gray80", lineCol = "gray40") {
    ## x (required) is the x position to draw the histogram
    ## xscale (optional) is the "height" of the tallest bar (horizontally),
    ##   it has sensible default behavior
    ## xwidth (required) is the horizontal spacing between histograms
    ## hist (required) is an object of type "histogram"
    ##    (or a list / df with $breaks and $density)
    ## fillCol and lineCol... exactly what you think.
    binWidth <- hist$breaks[2] - hist$breaks[1]
    if (is.null(xscale)) xscale <- xwidth * 0.90 / max(hist$density)
    n <- length(hist$density)
    x.l <- rep(x, n)
    x.r <- x.l + hist$density * xscale
    y.b <- hist$breaks[1:n]
    y.t <- hist$breaks[2:(n + 1)]

    rect(xleft = x.l, ybottom = y.b, xright = x.r, ytop = y.t,col = fillCol, border = lineCol)
}



## Usage example
require(plyr) ## Just needed for the round_any() in this example
n <- 1000
numberOfHists <- 4
data <- data.frame(ReleaseDOY = rnorm(n, 110, 20),
                   bin = as.factor(rep(c(1, 2, 3, 4), n / 4)))
binWidth <- 1
binStarts <- c(1, 2, 3, 4)
binMids <- binStarts + binWidth / 2
axisCol <- "gray80"

## Data handling
DOYrange <- range(data$ReleaseDOY)
DOYrange <- c(round_any(DOYrange[1], 15, floor),
                      round_any(DOYrange[2], 15, ceiling))

## Get the histogram obects
histList <- with(data, tapply(ReleaseDOY, bin, hist, plot = FALSE,
    breaks = seq(DOYrange[1], DOYrange[2], by = 5)))
DOYmean <- with(data, tapply(ReleaseDOY, bin, mean))

## Plotting
par(mar = c(5, 5, 1, 1) + .1)
plot(c(0, 5), DOYrange, type = "n",
     ann = FALSE, axes = FALSE, xaxs = "i", yaxs = "i")

axis(1, cex.axis = 1.2, col = axisCol)
mtext(side = 1, outer = F, line = 3, "Length at tagging (mm)",
      cex = 1.2)
axis(2, cex.axis = 1.2, las = 1, line = -.7, col = "white",
    at = c(75, 107, 138, 169),
    labels = c("March", "April", "May", "June"), tck = 0)
mtext(side = 2, outer = F, line = 3.5, "Date tagged", cex = 1.2)
box(bty = "L", col = axisCol)

## Gridlines
abline(h = c(60, 92, 123, 154, 184), col = "gray80")

biggestDensity <- max(unlist(lapply(histList, function(h){max(h[[4]])})))
xscale <- binWidth * .9 / biggestDensity

## Plot the histograms
for (lengthBin in 1:numberOfHists) {
    VerticalHist(binStarts[lengthBin], xscale = xscale,
                         xwidth = binWidth, histList[[lengthBin]])
    }
-------------------------------------------------------------------------------------------------------
layout(matrix(1:2,nrow=1),widths=c(0.8,0.2))
colfunc <- colorRampPalette(c("white","black"))

par(mar=c(5.1,4.1,4.1,2.1))
plot(1:10,ann=FALSE,type="n")
grid()
points(1:10,col=colfunc(10),pch=19,cex=1.5)

xl <- 1
yb <- 1
xr <- 1.5
yt <- 2

par(mar=c(5.1,0.5,4.1,0.5))
plot(NA,type="n",ann=FALSE,xlim=c(1,2),ylim=c(1,2),xaxt="n",yaxt="n",bty="n")
rect(xl,head(seq(yb,yt,(yt-yb)/10),-1),xr,tail(seq(yb,yt,(yt-yb)/10),-1),col=colfunc(10))

mtext(1:10,side=2,at=tail(seq(yb,yt,(yt-yb)/10),-1)-0.05,las=2,cex=0.7)
-------------------------------------------------------------------------------------------------------
library(ggplot2)

data <- read.table(text = 
  "Letter      Year    Value 
 A           1998    5
                B           1999    10
                C           2000    15
                A           2000    7
                B           2001    15
                C           2002    20", sep = "", header = TRUE)
ggplot(data = data, aes(x = factor(Year), y = Value, colour = Letter)) +       
  geom_line(aes(group = Letter)) + scale_colour_grey() +
  theme(panel.background = element_rect(fill='white', colour='black'))
-------------------------------------------------------------------------------------------------------
ggplot2 library(ggplot2)

# Create test data.
dat = data.frame(count=c(10, 60, 30), category=c("A", "B", "C"))

# Add addition columns, needed for drawing with geom_rect.
dat$fraction = dat$count / sum(dat$count)
dat = dat[order(dat$fraction), ]
dat$ymax = cumsum(dat$fraction)
dat$ymin = c(0, head(dat$ymax, n=-1))

p1 = ggplot(dat, aes(fill=category, ymax=ymax, ymin=ymin, xmax=4, xmin=3)) +
     geom_rect() +
     coord_polar(theta="y") +
     xlim(c(0, 4)) +
     labs(title="Basic ring plot")

p2 = ggplot(dat, aes(fill=category, ymax=ymax, ymin=ymin, xmax=4, xmin=3)) +
     geom_rect(colour="grey30") +
     coord_polar(theta="y") +
     xlim(c(0, 4)) +
     theme_bw() +
     theme(panel.grid=element_blank()) +
     theme(axis.text=element_blank()) +
     theme(axis.ticks=element_blank()) +
     labs(title="Customized ring plot")


library(gridExtra)
png("ring_plots_1.png", height=4, width=8, units="in", res=120)
grid.arrange(p1, p2, nrow=1)
dev.off() iris iris[, 2:4] iris[, 1] geom_rect(data=dat2, xmax=3, xmin=2, aes(ymax=ymax, ymin=ymin)) period facet_wrap(~ period) ggplot2 melt() reshape2 ggplot(dat, aes(x=category, y=count, fill=category)) + geom_bar(stat="identity")
-------------------------------------------------------------------------------------------------------
geom_rect() library(ggplot2)

# Load example data.
df = data.frame(Block=rep(1:2, each=18),
            Row=rep(1:9, 4),
            Col=rep(1:4, each=9),
            Treat=sample(c(1:6),replace=F))
df$Mainplot = ceiling(df$Row/3) + 3*(ceiling(df$Col/2) - 1)

# Create an auxiliary data.frame for plotting borders.
group_dat = data.frame(Mainplot=sort(unique(df$Mainplot)),
                       xmin=0, xmax=0, ymin=0, ymax=0)
# Fill data.frame with appropriate values.
for(i in 1:nrow(group_dat)) {
    item = group_dat$Mainplot[i]
    tmp = df[df$Mainplot == item, ]
    group_dat[i, "xmin"] = min(tmp$Row) - 0.5
    group_dat[i, "xmax"] = max(tmp$Row) + 0.5
    group_dat[i, "ymin"] = min(tmp$Col) - 0.5
    group_dat[i, "ymax"] = max(tmp$Col) + 0.5
}


p2 = ggplot() + 
     geom_tile(data=df, aes(x=Row, y=Col, fill=factor(Treat)), 
               colour="grey30", size=0.35) +
     geom_rect(data=group_dat, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax),
               size=1.4, colour="grey30", fill=NA)

ggsave(filename="plot_2.png", plot=p2, height=3, width=6.5)
-------------------------------------------------------------------------------------------------------
df.p df.p1 <- df.p + geom_rect(aes(xmin=((Mainplot- 3*(ceiling(Col/2)-1) )-1)*3 + 0.5,
                         xmax=((Mainplot - 3*(ceiling(Col/2)-1))-1)*3 + 3.5,
                         ymin=ceiling(ceiling(Col/2)/2 + 2*(ceiling(Col/2)-1))-0.5,
                         ymax=2*ceiling(Col/2)+0.5),
                     colour="black", fill="transparent",size=1)
-------------------------------------------------------------------------------------------------------
?identify ?zoomInPlot rxlim rylim /20 identify() par(mfrow = c(1,2))
plot(1:10) # 1
plot(1:10) # 2
identifyPch(1:10) identifyPch() ?identify par(mfg=c(1, 1)) zoom <- function (x, y, xlim, ylim, xd, yd) 
{
  rxlim <- x + c(-1, 1) * (diff(range(xd))/20)
  rylim <- y + c(-1, 1) * (diff(range(yd))/20)
  par(mfrow = c(1, 2))
  plot(xd, yd, xlab = "mean", ylab = "sd")
  xext <- yext <- rxext <- ryext <- 0
  if (par("xaxs") == "r") {
    xext <- diff(xlim) * 0.04
    rxext <- diff(rxlim) * 0.04
  }
  if (par("yaxs") == "r") {
    yext <- diff(ylim) * 0.04
    ryext <- diff(rylim) * 0.04
  }
  rect(rxlim[1] - rxext, rylim[1] - ryext, rxlim[2] + rxext, rylim[2] + ryext)
  xylim <- par("usr")
  xypin <- par("pin")
  rxi0 <- xypin[1] * (xylim[2] - (rxlim[1] - rxext))/diff(xylim[1:2])
  rxi1 <- xypin[1] * (xylim[2] - (rxlim[2] + rxext))/diff(xylim[1:2])
  y01i <- xypin[2] * (xylim[4] - (rylim[2] + ryext))/diff(xylim[3:4])
  y02i <- xypin[2] * ((rylim[1] - ryext) - xylim[3])/diff(xylim[3:4])
  mu <- x
  curve(dnorm(x, mean = mu, sd = y), from = -4 * y + mu, to = 4 * y + mu, 
        xlab = paste("mean:", round(mu, 2), ", sd: ", round(y, 2)), ylab = "")
  xypin <- par("pin")
  par(xpd = NA)
  xylim <- par("usr")
  xymai <- par("mai")
  x0 <- xylim[1] - diff(xylim[1:2]) * (xymai[2] + xymai[4] + 
                                         rxi0)/xypin[1]
  x1 <- xylim[1] - diff(xylim[1:2]) * (xymai[2] + xymai[4] + 
                                         rxi1)/xypin[1]
  y01 <- xylim[4] - diff(xylim[3:4]) * y01i/xypin[2]
  y02 <- xylim[3] + diff(xylim[3:4]) * y02i/xypin[2]
  par(xpd = TRUE)
  xend <- xylim[1] - diff(xylim[1:2]) * xymai[2]/(2 * xypin[1])
  xprop0 <- (xylim[1] - xend)/(xylim[1] - x0)
  xprop1 <- (xylim[2] - xend)/(xylim[2] - x1)
  par(xpd = NA)
  segments(c(x0, x0, x1, x1), 
           c(y01, y02, y01, y02), 
           c(xend, xend, xend, xend), 
           c(xylim[4] - (xylim[4] - y01) * xprop0, 
             xylim[3] + (y02 - xylim[3]) * xprop0, 
             xylim[4] - (xylim[4] - y01) * xprop1, 
             xylim[3] + (y02 - xylim[3]) * xprop1))
  par(mfg = c(1, 1))
  plot(xd, yd, xlab = "mean", ylab = "sd")
}

ident <- function(x, y, ...)
{
  ans <- identify(x, y, n = 1, plot = FALSE, ...)
  if(length(ans)) {
    zoom(x[ans], y[ans], range(x), range(y), x, y)
    points(x[ans], y[ans], pch = 19)
    ident(x, y)
  }
}

x <- rnorm(10)
y <- rnorm(10, mean = 5)
par(mfrow = c(1, 2))
plot(x, y, xlab = "mean", ylab = "sd")
ident(x, y)
-------------------------------------------------------------------------------------------------------
p <- ggplot(DF, aes(x, y)) + geom_line()
p + theme(plot.background = element_rect(fill="lightblue"),
         panel.background = element_rect(fill='#D6E7EF'),
         panel.grid.major = element_line(size = 0.7, colour = 'white'), 
         panel.grid.minor = element_blank(), 
         axis.ticks = element_blank()) +
    ylim(0, 5)
-------------------------------------------------------------------------------------------------------
structure(list(scen = 1:6, 
               name = c("I", "II", "III", "IV", "V","VI"), 
               ymin = c(0.06, -0.102, 0.487, 0.116, -0.436, 0.021), 
               ymax = c(-0.231,0.135, 0.117, 0.338, -0.347, -0.025)), 
          .Names = c("scen", "name", "ymin", "ymax"), 
          row.names = c(NA, 6L), 
          class = "data.frame") scen name   ymin   ymax   y
1    1    I  0.060 -0.231   I
2    2   II -0.102  0.135  II
3    3  III  0.487  0.117 III
4    4   IV  0.116  0.338  IV
5    5    V -0.436 -0.347   V
6    6   VI  0.021 -0.025  VI theme_new <- theme_set(theme_bw())
p <- ggplot(data=dat) +
  geom_segment(aes(x=ymin,y=scen,xend=ymax,yend=scen),
               arrow=arrow(length=unit(0.3,"cm"),
                           ends='both'),size=1) 

p <- p+  geom_rect(xmin=max(dat$ymin)/2,
                    xmax=min(dat$ymax)/2,
                    ymin=0,
                    ymax=max(dat$scen)+1,
                    alpha=0.2,fill='grey')

p <- p + geom_text(aes(x=(ymin+ymax)/2,
                       y=scen+0.2,label =name),size=6)

p<- p + coord_cartesian(ylim=c(0,max(dat$scen)+3))+
  xlab(expression(P[1]-P[0]))+
  theme( 
    axis.ticks = element_blank(),
    axis.text.y = element_blank(),
    axis.text.x = element_blank(),
    axis.title.x = element_text(face="bold",  size=20))

p <- p + geom_vline(linetype   ='dashed',
                    xintercept = mid.dash)

p <- p + geom_text(aes(x= mid.dash,
                       y = max(dat$scen)+2, 
                       label="Zone of Indifference", 
                       color="NA*"),rotate=180)
p <- p + theme(legend.position = "none")
-------------------------------------------------------------------------------------------------------
print(.., vp=..) borderize <- function(plotObj, thick=2, color="orange", alpha=0.8) {
  # thick should be a value between (1, 100)
  # alpha should be a value between (0, 1)

  # these could be modified for separate width/height thicknesses
  wd <- ht <-  (100 - thick) / 100
  x <- (1 - wd)  / 2 
  y <- (1 - ht) / 2

  # create a solid rectangle.  The plot will go over it. 
  grid.rect(y = 1, height = 1, just = c("center", "top"), gp=gpar(fill=color, alpha=alpha, lwd=0))

  # create the viewport
  vp.inner <- viewport(height=unit(ht, "npc"), width=unit(wd, "npc"), just=c("left","bottom"), y=y, x=x)

  print(plotObj, vp=vp.inner)

} myPlot <- ggplot(iris,aes(Sepal.Length,Sepal.Width)) + 
                 geom_point(aes(color=Species,shape=Species))

borderize(myPlot, thick=5, color="#CF8042") plot.background panel.background plot.bg  <- theme(plot.background=element_rect(color="red", size=12))
panel.bg <- theme(panel.background=element_rect(color="blue", size=12))

plotObj + panel.bg + plot.bg plot panel plot.background borderize
-------------------------------------------------------------------------------------------------------
qplot(x= disp , y = wt , data = mtcars) +
  theme(plot.background = element_rect(colour="#CF8057",size=10))
-------------------------------------------------------------------------------------------------------
set.seed(123); 
plot(x=rnorm(100, sd=1000), y=rnorm(100, sd=1000) ,ylab="", xlab="")
rect(xleft=par("usr")[1]*1.25, ybottom=par("usr")[3]*1.4, xright=par("usr")[2]*1.1,ytop=par("usr")[4]*1.2, lwd=5, border="orange", xpd=TRUE)
-------------------------------------------------------------------------------------------------------
rect() lty=0 boxplot() rect() add=TRUE boxplot() a<-rep(c("g1","g2","g3","g4","g5","g6"),each=10)
b<-rnorm(60)    
boxplot(b~a)
rect(0.5,-3,1.5,3,col="grey75",lty=0)
rect(2.5,-3,3.5,3,col="grey75",lty=0)
boxplot(b~a,add=TRUE)
-------------------------------------------------------------------------------------------------------
library(reshape2)
library(plyr)
library(ggplot2)
library(systemfit)
library(xtable)
require(graphics)
require(tikzDevice)

setwd("~/DataFolder/")
Lab5p9 <- read.csv (file="~/DataFolder/Lab5part9.csv", comment.char="#")

AR <- subset(Lab5p9,Region == "Forward.Active")

# make sure the data names aren't already in latex format, it interferes with the ggplot ~  # tikzDecice combo
colnames(AR) <- c("$V_{BB}[V]$", "$V_{RB}[V]$" ,  "$V_{RC}[V]$" , "$I_B[\\mu A]$" , "IC" , "$V_{BE}[V]$" , "$V_{CE}[V]$" , "beta" , "$I_E[mA]$")

# make sure the working directory is where you want your tikz file to go
setwd("~/TexImageFolder/")

# export plot as a .tex file in the tikz format
tikz('betaplot.tex', width = 6,height = 3.5,pointsize = 12) #define plot name size and font size

#define plot margin widths
par(mar=c(3,5,3,5)) # The syntax is mar=c(bottom, left, top, right).

ggplot(AR, aes(x=IC, y=beta)) +                                # define data set 
    geom_point(colour="#000000",size=1.5) +                # use points
    geom_smooth(method=loess,span=2) +                     # use smooth
    theme_bw() +                    # no grey background
    xlab("$I_C[mA]$") +                 # x axis label in latex format
    ylab ("$\\beta$") +                 # y axis label in latex format
    theme(axis.title.y=element_text(angle=0)) + # rotate y axis label
    theme(axis.title.x=element_text(vjust=-0.5)) +  # adjust x axis label down
    theme(axis.title.y=element_text(hjust=-0.5)) +  # adjust y axis lable left
    theme(panel.grid.major=element_line(colour="grey80", size=0.5)) +# major grid color
    theme(panel.grid.minor=element_line(colour="grey95", size=0.4)) +# minor grid color 
    scale_x_continuous(minor_breaks=seq(0,9.5,by=0.5)) +# adjust x minor grid spacing
    scale_y_continuous(minor_breaks=seq(170,185,by=0.5)) + # adjust y minor grid spacing
    theme(panel.border=element_rect(colour="black",size=.75))# border color and size

dev.off() # export file and exit tikzDevice function
-------------------------------------------------------------------------------------------------------
boxplot() rect() rect() text() set.seed(123)
  x<-rnorm(100)
  boxplot(x,horizontal=TRUE,axes=FALSE)
  rect(min(x),1.5,quantile(x,0.25),1.4,col="red")
  rect(quantile(x,0.25),1.5,quantile(x,0.60),1.4,col="green")
  rect(quantile(x,0.60),1.4,max(x),1.5,col="yellow")
  text(-1.5,1.45,"25%")
  text(0,1.45,"35%")
  text(1.1,1.45,"40%")
-------------------------------------------------------------------------------------------------------
df <- data.frame(cond = factor( rep(c("A"), each=200) ), 
                 rating = c(rnorm(200),rnorm(200, mean=.8)))

library(lattice)
bwplot(cond ~ rating, data=df,gp=gpar(fill='blue'),
       par.settings = list( box.umbrella=list(col= c( "red")), 
                            box.dot=list(col= c("green")), 
                            box.rectangle = list(fill= c( "blue"),alpha=0.6))) downViewport("plot_01.panel.1.1.vp") segs <- grid.get('segments',grep=T)
cap.segs <- grid.get('cap.segments',grep=T) drawbox <- function(x0 = segs$x0[1] , col ='red',
                    width.vp = segs$x0[2] - segs$x0[1]){
  vpd <- viewport(
            x = x0 ,
            y = cap.segs$y1[2] + unit(0.5,'native'),
            width  = width.vp,
            height = unit(2,'cm'),
            just   = c('left','bottom'),
            name   = 'vpd')
  pushViewport(vpd)
    grid.rect(gp=(gpar(fill=col)))
    # The compute of percent is a little bit tricky due we can't apply '/'
    value <- as.numeric(convertUnit(width.vp,'native'))
    value <- value/as.numeric(convertUnit(cap.segs$x0[2]- cap.segs$x0[1],'native'))
    grid.text(label = paste(round(value*100),'%',sep='') , gp= gpar(cex=3))
  upViewport(1)
} drawbox()
drawbox(col='yellow',width=segs$x0[1] - cap.segs$x0[1], x0= cap.segs$x0[1])
drawbox(col='green',width.vp= cap.segs$x0[2]- segs$x0[2],x0 = segs$x0[2])
-------------------------------------------------------------------------------------------------------
rgeos sp library(maptools)

data(wrld_simpl)

# interested in the arealy bounded by the following rectangle
# rect(130, 40, 180, 70)

library(rgeos)
# create  a polygon that defines the boundary
bnds <- cbind(x=c(130, 130, 180, 180, 130), y=c(40, 70, 70, 40, 40))
# convert to a spatial polygons object with the same CRS
SP <- SpatialPolygons(list(Polygons(list(Polygon(bnds)), "1")),
proj4string=CRS(proj4string(wrld_simpl)))
# find the intersection with the original SPDF
gI <- gIntersects(wrld_simpl, SP, byid=TRUE)
# create the new spatial polygons object.
out <- vector(mode="list", length=length(which(gI)))
ii <- 1
for (i in seq(along=gI)) if (gI[i]) {
  out[[ii]] <- gIntersection(wrld_simpl[i,], SP)
  row.names(out[[ii]]) <- row.names(wrld_simpl)[i]; ii <- ii+1
}
# use rbind.SpatialPolygons method to combine into a new object.
out1 <- do.call("rbind", out)
# look here is Eastern Russia and a bit of Japan and China.
plot(out1, col = "khaki", bg = "azure2")
-------------------------------------------------------------------------------------------------------
d <- ggplot(platelay, aes(y=rown,x=factor(coln))) + 
  geom_point(aes(colour = colorvar), size =18) + theme_bw() data <- ggplot_build(d)$data[[1]]

 x <- data$x
 y <- data$y
 grid.newpage()
 pushViewport(plotViewport(c(4, 4, 2, 2)),
               dataViewport(x, y)) grid.ellipse(x, y,size=20,  ar = 2,angle=0,gp =gpar(fill=data$colour))
 grid.xaxis(at=c(labels=1:12,ticks=NA),gp=gpar(cex=2))
 grid.yaxis(at = 1:8,label=rev(LETTERS[1:8]),gp=gpar(cex=2))

 grid.roundrect(gp=gpar(fill=NA)) gpgrid <- gpar(col='grey',lty=2,col='white')
grid.segments(unit(1:12, "native") ,unit(0, "npc"), unit(1:12, "native"),unit(1, "npc"),gp=gpgrid)
grid.segments(unit(0, "npc"), unit(1:8, "native"), unit(1, "npc"),unit(1:8, "native"),gp=gpgrid)
upViewport()
-------------------------------------------------------------------------------------------------------
mylabd <- data.frame (company = rep(c("A", "B", "C"), each = 7),
                      skillsDg = rep(c("Basic", "HighSc", "Undgd", "MAST", "PHD", "EXPD", "EXECT"), 3),
                      number = c(200, 100, 40, 30, 10, 0, 0,
                                 220, 110, 35, 10, 0, 4, 1,
                                 140, 80, 120, 50, 52, 52, 3)
)



## to comapre we need o have the same scales for all organizations
nskills <- nlevels(mylabd$skillsDg)
ncompany <- nlevels(mylabd$company)
barYscale <- c(0,  nskills) * 1.05
barXscale <- c(0, max(mylabd$number) )* 1.05
## the global scene
vp <- plotViewport(c(5, 4, 4, 1),
                   yscale = barYscale,
                   layout = grid.layout(nrow=1,ncol=nbars))

pushViewport(vp)
grid.rect()
grid.yaxis(at=c(1:nlevels(mylabd$skillsDg)),label=unique(mylabd$skillsDg))
grid.grill()

## split data by companya
data.splitted <- split(mylabd,f=mylabd$company)
lapply(1:3,function(company){

  x <- data.splitted[[company]]
  vv <- x$number
  companyName <- unique(x$company)

  pushViewport(viewport(layout.pos.col=company,    
                        xscale = barXscale,
                        yscale = barYscale))
  grid.rect()
 # grid.xaxis(at= mean(x$number),label = companyName)
  grid.xaxis()
  grid.polygon(x  = unit.c(unit(0.5,'npc')-unit(vv/2,'native'),
                           unit(0.5,'npc')+unit(rev(vv)/2,'native')),
               y  = unit.c(unit(1:nmeasures,'native'),
                           unit(rev(1:nmeasures),'native')),
               gp=gpar(fill = rainbow(nmeasures)[company]))
  grid.polygon(x  = unit.c(unit(0.5,'npc')-unit(vv/2,'native'),
                           unit(0.5,'npc')+unit(rev(vv)/2,'native')),
               y  = unit.c(unit(1:nmeasures,'native'),
                           unit(rev(1:nmeasures),'native')),
               id = c(1:nmeasures,rev(1:nmeasures)),
               gp=gpar(fill = NA))

  grid.text( x = unit(0.5,'npc'),
             y = unit(0.5,'native'),
             label = unique(x$company))

  popViewport()

})

popViewport()
-------------------------------------------------------------------------------------------------------
stat_smooth geom_rect # generating data: Usage of set.seed for reproducibility 
# also I changed the multiplication constant to 0.1 to have 
# at least one negative slope.

require(ggplot2)
set.seed(12)
x <- rnorm(100)
y <-  + .1*x + rnorm(100)
f1 <- as.factor(c(rep("A",50),rep("B",50)))
f2 <- as.factor(rep(c(rep("C",25),rep("D",25)),2))
df <- data.frame(cbind(x,y))
df$f1 <- f1
df$f2 <- f2

# first generate your plot in this manner and run it
# from James' post, the part outfit=fit<<-..y.. will store 
# the output of fitted values in "fit"

g <- ggplot(df,aes(x=x,y=y)) + geom_point()+facet_grid(f1~f2) 
g <- g + stat_smooth(aes(outfit=fit<<-..y..), method="lm",se=FALSE)
# now run g to generate "fit"
g

# now extract the slope for each facet and 
# construct the data.frame for geom_rect (as per Joran's post)
# Edit: Just to add more info about "fit". By default it contains
# 80 values per facet. Hence the 80*4 = 320

slopes <- fit[seq(2, 320, by = 80)] - fit[seq(1, 320, by = 80)]
tp <- unique(df[, c('f1', 'f2')])
tp <- transform(tp, slopes=slopes, x=1, y=1)
tp$pos_neg <- ifelse(slopes > 0, 1, 0)
tp$pos_neg <- factor(tp$pos_neg)

# now plot again (but with geom_rect)
g <- ggplot(df,aes(x=x,y=y)) 
g <- g + geom_rect(data = tp, aes(fill = pos_neg), xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf, alpha = 0.5) 
g <- g + geom_point() + facet_grid(f1~f2) + stat_smooth(method = "lm",se = FALSE)
g stat_smooth
-------------------------------------------------------------------------------------------------------
grid ## transform the jpeg to raster grobs
library(jpeg)
names.axis <-  c("Interphase", "Prophase", "Metaphase", "Anaphase", "Telophase")
images <- lapply(names.axis,function(x){
  img <- readJPEG(paste('lily_',x,'.jpg',sep=''), native=TRUE)
  img <- rasterGrob(img, interpolate=TRUE)
  img
  } )
## main viewports, I divide the scene in 10 rows ans 5 columns(5 pictures)
pushViewport(plotViewport(margins = c(1,1,1,1),
             layout=grid.layout(nrow=10, ncol=5),xscale =c(1,5)))
## I put in the 1:7 rows the plot without axis
## I define my nested viewport then I plot it as a grob.
pushViewport(plotViewport(layout.pos.col=1:5, layout.pos.row=1:7,
             margins = c(1,1,1,1)))
pp <- ggplot() +
  geom_bar(data=myd, aes(y = value, x = phase, fill = cat), 
                 stat="identity",position='dodge') +
  theme_bw()+theme(legend.position="none", axis.title.y=element_blank(),
                   axis.title.x=element_blank(),axis.text.x=element_blank())
gg <- ggplotGrob(pp)
grid.draw(gg)
upViewport()
## I draw my pictures in between rows 8/9 ( visual choice)
## I define a nested Viewport for each picture than I draw it.
sapply(1:5,function(x){
  pushViewport(viewport(layout.pos.col=x, layout.pos.row=8:9,just=c('top')))
  pushViewport(plotViewport(margins = c(5.2,3,4,3)))
  grid.draw(images[[x]])
  upViewport(2)
  ## I do same thing for text 
  pushViewport(viewport(layout.pos.col=x, layout.pos.row=10,just=c('top')))
  pushViewport(plotViewport(margins = c(1,3,1,1)))
    grid.text(names.axis[x],gp = gpar(cex=1.5))
  upViewport(2)
})
pushViewport(plotViewport(layout.pos.col=1:5, layout.pos.row=1:9,
             margins = c(1,1,1,1)))
grid.rect(gp=gpar(fill=NA))
upViewport(2)
-------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------
grid.raster library(png)
flower <- readPNG("flower.png")
pushViewport(plotViewport(margins=c(5,5,5,5)))
grid.rect(gp = gpar(fill=NA))
pushViewport(plotViewport(margins=c(5,5,5,5),
                          xscale=extendrange(mydt$x),
                          yscale=extendrange(mydt$y)))


grid.raster(image=flower,x=mydt$x,y=mydt$y,width=mydt$z, 
                interpolate=FALSE,default.units = 'native')
grid.polyline(mydt$x,mydt$y,default.units='native')
upViewport(2)
-------------------------------------------------------------------------------------------------------
legend guide gtable grid gtable library(gtable)
  # Data transformation
  data <- ggplot_build(p)
  gtable <- ggplot_gtable(data)
  # Determining index of legends table
  lbox <- which(sapply(gtable$grobs, paste) == "gtable[guide-box]")
  # changing the space between the 2 legends: here -0.5 lines
  guide <- gtable$grobs[[lbox]]
  gtable$grobs[[lbox]]$heights <- unit.c(guide$heights[1:2],
                                    unit(-.5,'lines'),  ## you can the GAP here
                                    guide$heights[4:5])
  # Plotting
  grid.draw(gtable) grid pp <- grid.get('guide',grep=T)
 depth <- downViewport(pp$wrapvp$name)
 guide <- grid.get('guide',grep=T)
 grid.rect(gp=gpar(fill='white'))
 guide$heights <- unit.c(guide$heights[1:2],unit(-0.2,'lines'),guide$heights[4],unit(0.1,'lines'))
 grid.draw(guide)
 upViewport(depth)
-------------------------------------------------------------------------------------------------------
require(graphics)
labs = paste("sta_",1:50,sep="") #new labels
USArrests2<-USArrests #new data frame (just to keep original unchanged)
rownames(USArrests2)<-labs #set new row names
hc <- hclust(dist(USArrests2), "ave")
par(mar=c(3,1,1,5)) 
plot(as.dendrogram(hc),horiz=T) labs = paste("sta_",1:50,sep="") #new labels
hc <- hclust(dist(USArrests), "ave")

library(ggplot2)
library(ggdendro)

#convert cluster object to use with ggplot
dendr <- dendro_data(hc, type="rectangle") 

#your own labels are supplied in geom_text() and label=labs
ggplot() + 
  geom_segment(data=segment(dendr), aes(x=x, y=y, xend=xend, yend=yend)) + 
  geom_text(data=label(dendr), aes(x=x, y=y, label=labs, hjust=0), size=3) +
  coord_flip() + scale_y_reverse(expand=c(0.2, 0)) + 
  theme(axis.line.y=element_blank(),
        axis.ticks.y=element_blank(),
        axis.text.y=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_rect(fill="white"),
        panel.grid=element_blank())
-------------------------------------------------------------------------------------------------------
opts theme_rect myplot + theme(panel.background = element_rect(fill='green', colour='red')) theme_jack <- function (base_size = 12, base_family = "") {
    theme_gray(base_size = base_size, base_family = base_family) %+replace% 
        theme(
            axis.text = element_text(colour = "white"),
            axis.title.x = element_text(colour = "pink", size=rel(3)),
            axis.title.y = element_text(colour = "blue", angle=45),
            panel.background = element_rect(fill="green"),
            panel.grid.minor.y = element_line(size=3),
            panel.grid.major = element_line(colour = "orange"),
            plot.background = element_rect(fill="red")
    )   
} theme_set(theme_jack()) theme_update(plot.background = element_rect(fill="pink"), axis.title.x = element_text(colour = "red")) theme_pink <- theme_get() theme_pink theme_jack theme_set(theme_jack()) theme_set(theme_pink) theme_gray theme_bw theme_jack theme_bw theme_nogrid <- function (base_size = 12, base_family = "") {
    theme_bw(base_size = base_size, base_family = base_family) %+replace% 
        theme(
            panel.grid = element_blank()
    )   
} theme_map <- function (base_size = 12, base_family = "") {
    theme_gray(base_size = base_size, base_family = base_family) %+replace% 
        theme(
            axis.line=element_blank(),
            axis.text.x=element_blank(),
            axis.text.y=element_blank(),
            axis.ticks=element_blank(),
            axis.ticks.length=unit(0.3, "lines"),
            axis.ticks.margin=unit(0.5, "lines"),
            axis.title.x=element_blank(),
            axis.title.y=element_blank(),
            legend.background=element_rect(fill="white", colour=NA),
            legend.key=element_rect(colour="white"),
            legend.key.size=unit(1.2, "lines"),
            legend.position="right",
            legend.text=element_text(size=rel(0.8)),
            legend.title=element_text(size=rel(0.8), face="bold", hjust=0),
            panel.background=element_blank(),
            panel.border=element_blank(),
            panel.grid.major=element_blank(),
            panel.grid.minor=element_blank(),
            panel.margin=unit(0, "lines"),
            plot.background=element_blank(),
            plot.margin=unit(c(1, 1, 0.5, 0.5), "lines"),
            plot.title=element_text(size=rel(1.2)),
            strip.background=element_rect(fill="grey90", colour="grey50"),
            strip.text.x=element_text(size=rel(0.8)),
            strip.text.y=element_text(size=rel(0.8), angle=-90) 
        )   
}
-------------------------------------------------------------------------------------------------------
element_blank() strip.background element_rect(colour="black") panel.border panel.border ggplot(mtcars, aes(mpg, hp)) + geom_point() +
  facet_wrap(~carb, ncol = 3) + theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        strip.background = element_blank(),
        panel.border = element_rect(colour = "black"))
-------------------------------------------------------------------------------------------------------
> boxplot(myd$myv, col = "lightgreen", ylim=c(-10,18))s > col2rgb("purple")
#      [,1]
#red    160
#green   32
#blue   240
> rect(0.7, 4.5, 1.3, 8.2, col= rgb( 1,0.4,0.4) ) 
points > points(x=rep(1, sum( myd$myv > 8.2 | myd$myv < 4.5 )), 
         y= myd$myv[   myd$myv > 8.2 | myd$myv < 4.5 ] , 
         col="orange", pch=19, bg="orange")
-------------------------------------------------------------------------------------------------------
gridBase set.seed(1234)
myd <- data.frame (SN = 1:100, myv = round (rnorm(100, 5, 5), 2))
boxplot(myd$myv, col = "lightgreen")
sp <- baseViewports()
pushViewport(sp$plot)
grid.rect(default.units='native', width= 1,height=8.2-4.5 ,gp=gpar(fill=rgb(1,0,0,0.5)), y = 3)
grid.points(x = rep(1,6) ,y=c(-4,-2,3,9,10,11),
         gp=gpar(col=rgb(1,1,0,0.5),default.units='native'))
-------------------------------------------------------------------------------------------------------
myd <- data.frame (var1 = c("II", "III", "IV", "V"), zero_co = c(15.15152 , 3.030303,    0,     0),
             non_zero_CO = c(84.84848,   96.969697,  100,   100),
              size = c(230.00000,  813.000000,  317,  1532))

    require(ggplot2)

ggplot(myd) + geom_rect(aes(xmin = 0, xmax = zero_co, ymin =size , ymax =size + 80 ), fill = "lightgreen") +
geom_rect(aes(xmin = zero_co, xmax = zero_co + non_zero_CO, ymin =size , ymax =size + 80 ), fill = "darkblue") + theme_bw()
-------------------------------------------------------------------------------------------------------
library(grid)
library(ggplot2)
require(gridBase)

par(mfrow = c(2,1))
plot(1:10)
a <- par("mai")
plot.new()
vps <- baseViewports()
pushViewport(vps$figure)

p = qplot(1:10, 1:10) + theme_bw() 
g <- ggplot_gtable(ggplot_build(p))

lw = unit(a[2], "inch") - sum(g$widths[1:3]) 

g$widths[[2]] <- as.list(lw + g$widths[[2]])
g$widths[[4]] <- as.list(unit(1, "npc") - unit(a[2] + a[4], "inch"))
g$widths[[5]] <- unit(a[4], "inch")
grid.draw(g)

# draw a shaded vertical band to test the alignment
grid.rect(unit(a[2], "inch"), unit(0, "inch"), unit(1,"npc") - unit(a[2] + a[4], "inch"),  unit(2,"npc"),gp=gpar(lty=2, fill="red", alpha=0.1), hjust=0, vjust=0)

upViewport()
-------------------------------------------------------------------------------------------------------
set.seed (123)
xvar <- round (rnorm (100, 54, 10), 0)
xyvar <- round (rnorm (100, 54, 10), 0)
myd <- data.frame (xvar, xyvar)
valut <- as.numeric (cut(c(myd$xvar,myd$xyvar), 12))
myd$xwt <- valut[1:100]
myd$xywt <- valut[101:200]
xy.pop <- data.frame (table (myd$xywt))
xx.pop <- data.frame (table (myd$xwt))


stickBoy <- function() {
  grid.circle(x=.5, y=.8, r=.1, gp=gpar(fill="red"))
  grid.lines(c(.5,.5), c(.7,.2)) # vertical line for body
  grid.lines(c(.5,.6), c(.6,.7)) # right arm
  grid.lines(c(.5,.4), c(.6,.7)) # left arm
  grid.lines(c(.5,.65), c(.2,0)) # right leg
  grid.lines(c(.5,.35), c(.2,0)) # left leg
  grid.lines(c(.5,.5), c(.7,.2)) # vertical line for body
  grid.text(x=.5,y=-0.3,label ='Male',
            gp =gpar(col='white',fontface=2,fontsize=32)) # vertical line for body
}

stickGirl <- function() {
  grid.circle(x=.5, y=.8, r=.1, gp=gpar(fill="blue"))
  grid.lines(c(.5,.5), c(.7,.2)) # vertical line for body
  grid.lines(c(.5,.6), c(.6,.7)) # right arm
  grid.lines(c(.5,.4), c(.6,.7)) # left arm
  grid.lines(c(.5,.65), c(.2,0)) # right leg
  grid.lines(c(.5,.35), c(.2,0)) # left leg
  grid.lines(c(.35,.65), c(0,0)) # horizontal  line for body
  grid.text(x=.5,y=-0.3,label ='Female',
            gp =gpar(col='white',fontface=2,fontsize=32)) # vertical line for body
}

xscale <- c(0, max(c(xx.pop$Freq,xy.pop$Freq)))* 5
levels <- nlevels(xy.pop$Var1)
barYscale<- xy.pop$Var1
vp <- plotViewport(c(5, 4, 4, 1),
                   yscale = range(0:levels)*1.05,
                   xscale =xscale)


pushViewport(vp)

grid.yaxis(at=c(1:levels))
pushViewport(viewport(width = unit(0.5, "npc"),just='right', 
                      xscale =rev(xscale)))
grid.xaxis()
popViewport()

pushViewport(viewport(width = unit(0.5, "npc"),just='left',
                      xscale = xscale))
grid.xaxis()
popViewport()

grid.grill(gp=gpar(fill=NA,col='white',lwd=3),
           h = unit(seq(0,levels), "native"))
grid.rect(gp=gpar(fill=rgb(0,0.2,1,0.5)),width = unit(0.5, "npc"),just='right')

grid.rect(gp=gpar(fill=rgb(1,0.2,0.3,0.5)),width = unit(0.5, "npc"),just=c('left'))

vv.xy <- xy.pop$Freq
vv.xx <- c(xx.pop$Freq,0)

grid.polygon(x  = unit.c(unit(0.5,'npc')-unit(vv.xy,'native'),
                         unit(0.5,'npc')+unit(rev(vv.xx),'native')),
             y  = unit.c(unit(1:levels,'native'),
                         unit(rev(1:levels),'native')),
             gp=gpar(fill=rgb(1,1,1,0.8),col='white'))

grid.grill(gp=gpar(fill=NA,col='white',lwd=3,alpha=0.8),
           h = unit(seq(0,levels), "native"))
popViewport()

## some fun here 
vp1 <- viewport(x=0.2, y=0.75, width=0.2, height=0.2,gp=gpar(lwd=2,col='white'),angle=30)
pushViewport(vp1)
stickBoy()
popViewport()
vp1 <- viewport(x=0.9, y=0.75, width=0.2, height=0.2,,gp=gpar(lwd=2,col='white'),angle=330)
pushViewport(vp1)
stickGirl()
popViewport()
-------------------------------------------------------------------------------------------------------
base scales library(scales)
xy.poly <- data.frame(Freq=c(xy.pop$Freq, rep(0,nrow(xy.pop))), 
                      Var1=c(xy.pop$Var1, rev(xy.pop$Var1)))
xx.poly <- data.frame(Freq=c(xx.pop$Freq, rep(0,nrow(xx.pop))), 
                      Var1=c(xx.pop$Var1, rev(xx.pop$Var1)))
xrange <- range(c(xy.poly$Freq, xx.poly$Freq))
yrange <- range(c(xy.poly$Var1, xx.poly$Var1))

par(mfcol=c(1,2))
par(mar=c(5,4,4,0))
plot(xy.poly,type="n", main="Men", xlab="", ylab="", xaxs="i", 
     xlim=rev(xrange), ylim=yrange, axes=FALSE)
rect(-1,0,100,100, col="blue")
abline(h=0:15, col="white", lty=3)
polygon(xy.poly, col=alpha("grey",0.6))
axis(1, at=seq(0,20,by=5))
axis(2, las=2)
box()

par(mar=c(5,0,4,4))
plot(xx.poly,type="n", main="Women", xaxs="i", xlab="", ylab="",
     xlim=xrange, ylim=yrange, axes=FALSE)
rect(-1,0,100,100, col="red")
abline(h=0:15, col="white", lty=3)
axis(1, at=seq(5,20,by=5))
axis(4, las=2)
polygon(xx.poly, col=alpha("grey",0.6))
box()
-------------------------------------------------------------------------------------------------------
plot(NULL, type= "n", xlim = c(1,ncol(A)), ylim = c(1, nrow(A)), xlab = "column", ylab = "row",
  main = "HCL colors, pseudo-random hue, scaled chroma and luminance")
rect(col(A)-.5,row(A)-.5,col(A)+.5,row(A)+.5,col = hcl(h = round(runif(length(A))*360), c = 60*A/max(A)+20, l = 60*A/max(A)+20))
-------------------------------------------------------------------------------------------------------
## I define my plot
p <- ggplot(MeanFrameMelt, aes(x=variable, y=value, color=Legend, group=Legend))+ 
  geom_line()+ 
  theme(panel.background = element_rect(fill='NA', colour='black', size = 1), 
        legend.position = "none")+ 
  ylab("Tag Density (mean coverage/bp)")+ 
  xlab("Distance from reference side (bp)")
## init gwidgets
library(gWidgetsRGtk2)
w   <- gwindow("Tag Density Checkboxes", width = 1000)
g   <- ggroup(container = w, horizontal = FALSE)
gg  <- ggraphics(container=g)
lyt <- glayout(container = g, horizontal = FALSE)
## I plot it the first time 
print(p)
## I add a handler
ID <- addHandlerChanged(gg, handler=function(h,...) {
   p <-  p + scale_x_discrete(breaks=c("V1", "V200", "V400"), 
                     labels=c("-1000", "0", "1000"))
   print(p)
})
print(p)
-------------------------------------------------------------------------------------------------------
dbinom n=1:32 math.stackexchange simulate set.seed(42)
numbet <- 32
numtri <- 1e5
prob=5/6

require(plyr)
out <- ldply(1:numbet, function(idx) {
    outcome <- dbinom(idx:0, size=idx, prob=prob)
    bet     <- rep(idx, length(outcome))
    N       <- round(outcome * numtri)
    ymin    <- c(0, head(seq_along(N)/length(N), -1))
    ymax    <- seq_along(N)/length(N)
    data.frame(bet, fill=outcome, ymin, ymax)
})

require(ggplot2)
p <- ggplot(out, aes(xmin=bet-0.5, xmax=bet+0.5, ymin=ymin, ymax=ymax)) + 
geom_rect(aes(fill=fill), colour="grey80") + 
scale_fill_gradient("Outcome", low="red", high="blue") +
xlab("Bet") The plot: Andrie X ~ B(n, p) Y ~ B(m, p) n, m = size p = probability of success X + Y = B(n + m, p) xcum n = 1:32 xcum for-loop cumsum numtri * numbet length = numtri 0's 1's 5/6 1/6 numtri = 1000 0's 1's numbet numtri <- 1e3
numbet <- 32
set.seed(45)
xcum <- t(replicate(numtri, sample(0:1, numbet, prob=c(5/6,1/6), replace = TRUE)))

# check for count of 1's
> apply(xcum, 2, sum)
[1] 169 158 166 166 160 182 164 181 168 140 154 142 169 168 159 187 176 155 151 151 166 
163 164 176 162 160 177 157 163 166 146 170

# So, the count of 1's are "approximately" what we expect (around 166). n = 1 size = numtri n = 2 n = 3 cumulatively numbet xcum <- t(apply(xcum, 1, cumsum))

# you can verify that the second column has similar probabilities by this:
# calculate the frequency of all values in 2nd column.
> table(xcum[,2])
  0   1   2 
694 285  21 

> round(numtri * dbinom(2:0, 2, prob=5/6))
[1] 694 278  28
# more or less identical, good! xcum cumsum(1:numbet) xcum <- xcum/matrix(rep(cumsum(1:numbet), each=numtri), ncol = numbet) xcum for-loop frequency n+1 n=1:32 5/6 1/6 k nCk * (5/6)^(k-1) * (1/6)^k # where nCk is n choose k n=7 n=8 k=0:7 k=0:8 # n=7
   0    1    2     3     4     5 
.278 .394 .233  .077  .016  .002 

# n=8
   0    1    2    3     4      5 
.229 .375 .254 .111  .025   .006 numtri=1000 dbinom # n = 7
dbinom(7:0, 7, prob=5/6)
# output rounded to 3 decimal places
[1] 0.279 0.391 0.234 0.078 0.016 0.002 0.000 0.000

# n = 8
dbinom(8:0, 8, prob=5/6)
# output rounded to 3 decimal places
[1] 0.233 0.372 0.260 0.104 0.026 0.004 0.000 0.000 0.000 k=6,7 k=6,7,8 n=7 n=8 0 5.8 * 1e-7 n=8 k=8 1/5.8 * 1e7 n=32 and k=32 1.256493 * 1e-25 32 n=32 numtri numtri=1e6 n=7 n=8 k=0:7 k=0:8 # n = 7
     0      1      2      3      4      5      6      7 
279347 391386 233771  77698  15763   1915    117      3 

# n = 8
     0      1      2      3      4      5      6      7      8 
232835 372466 259856 104116  26041   4271    392     22      1 numtri
-------------------------------------------------------------------------------------------------------
dec.dens1 = ggplot(dec_ema_df, aes(x=dec_ema, group = new)) + 
  geom_density(aes(colour=factor(new), linetype = factor(new)), size = 1, alpha = .70,kernel='epanechnikov') + 
  xlab(NULL) + ylab(NULL) + 
  scale_linetype_manual(values=c('solid', 'solid','solid','solid','dashed','solid','solid','solid'),
                        labels=c('`05','`06','`07','`08','`09','`10','`11','`12')) +
                          scale_colour_manual(values = cbbPalette,labels=c('`05','`06','`07','`08','`09','`10','`11','`12'), name=NULL) +
                          scale_y_continuous(labels = percent) +
                          theme(axis.line = element_line(colour = "black"),
                                panel.grid.major = element_blank(),
                                panel.grid.minor = element_blank(),
                                panel.border = element_blank(),
                                panel.background = element_blank(),
                                legend.title=element_blank(),
                                legend.position = 'bottom', 
                                legend.text = element_text(color= 'black', size = 12, face = 'bold'),
                                legend.key = element_rect(fill = 'white', size = 0.5, linetype='solid'),
                                legend.key.size = unit(1.5, 'lines')) 


print(dec.dens1)
-------------------------------------------------------------------------------------------------------
width plot.ohlc.candles width R> xts:::plot.ohlc.candles
function (x, width = 0.2, order = 1:4, bar.col = "grey", candle.col = "white", 
    ...) 
{
    segments(.index(x), x[, order[2]], .index(x), x[, order[3]], 
        col = bar.col, ...)
    rect(.index(x) - width, x[, order[1]], .index(x) + width, x[, order[4]], col = candle.col, ...)
}
<environment: namespace:xts> plot.xts(SF, type='candles', width=60*60*24*0.25)
-------------------------------------------------------------------------------------------------------
ggplot2 require(vegan)
data(dune)
data(dune.env)

# RDA
RDA <- rda(dune ~ A1, data = dune.env)

# extract species scores
df1 <- data.frame(RDA.scores = scores(RDA)$sites[ , 1], Management = dune.env$Management)
df2 <- data.frame(y = scores(RDA)$species[ , 1], taxa = rownames(scores(RDA)$species))
# Order data according to species scores
df2<-df2[order(df2$y),]

# define values for rugs (segments). 4.9 and 5.0 used because data has 4 levels (+1)
df2$x=4.9
df2$xend=5

# define coordinates for names (30 is number of species)
df2$yend2<-seq(min(df1$RDA.scores),max(df1$RDA.scores),length.out=30)
df2$xend2=5.3

# plot
P <- ggplot(data = df1, aes( x = Management, y = RDA.scores) ) + 
     geom_segment(y=0,yend=0,x=0,xend=5, lty=2, size = I(0.3)) + 
     geom_boxplot() + 
     #add extra levels to get space
     scale_x_discrete(limits=c("BF", "HF", "NM", "SF", "","")) + 
     #set y scale
     scale_y_continuous(limits=c(-3,5),expand=c(0,0)) +
     #add rugs as segments and add segments connecting rugs and texts
     geom_segment(data= df2, mapping=aes(x=x,xend=xend,y=y,yend=y), size = I(0.3)) +
     geom_segment(data= df2, mapping=aes(x=xend,xend=xend2,y=y,yend=yend2), size = I(0.4)) +
     #add texts
     geom_text(data=df2,mapping=aes(x=xend2+0.1,y=yend2,label=taxa),hjust=0, size=3) +
     #add rectangular to imitate box around plot
     geom_rect(xmax=5,xmin=0.4,ymax=5,ymin=-3,colour="black",fill=NA)

# Final adjustments of plot
P+theme(axis.line=element_blank(),
        panel.grid=element_blank(),
        panel.background=element_blank())
-------------------------------------------------------------------------------------------------------
# data
temp <- structure(list(type = structure(c(1L, 2L, 3L, 2L, 3L, 3L), .Label = c("A", 
"B", "C"), class = "factor"), items = c(16L, 16L, 16L, 32L, 32L, 
64L), value = c(6.3, 8.3, 7.9, 7.7, 8.3, 7.9)), .Names = c("type", 
"items", "value"), class = "data.frame", row.names = c(NA, -6L
))

# plot
library(ggplot2)
ggplot(temp, aes(type, value, fill=type, group=items, facets=items)) + 
    geom_bar(stat="identity") + 
    facet_grid(.~ items, scales = "free_x", space="free") + 
    labs(y="value") + 
    scale_fill_manual(values = rep("steelblue",3), 
                      labels = c("A: Item A", "B: Item B", "C: Item C")) + 
    guides(fill = guide_legend(override.aes = list(fill = "white"))) + 
    theme_bw() + 
    opts(axis.title.y=theme_text(size=16,angle=90),
         axis.title.x=theme_text(size=16,angle=0)) + 
    opts(axis.text.x=theme_text(size=12)) + 
    opts(axis.text.y=theme_text(size=14)) + 
    opts(strip.background = theme_rect(colour = 'steelblue', fill = 'white',size = 1)) + 
    opts(legend.position="top", legend.text=theme_text(size=15), 
         legend.title=theme_text(size=0,colour="white")) +  
    opts(legend.key = theme_rect(colour = NA))
-------------------------------------------------------------------------------------------------------
theme_bw() df <- data.frame(lab = c('D1','D2','D3'),y = c(4,8,10),x= c(1,2,3))
library(Cairo)
#CairoPDF(file = "test2.pdf", width = 8.3, height = 11.7) 
library(grid)
library(ggplot2)
ggplot(df, aes(xmin = x-0.2, xmax = x + 0.2, ymin = 0, ymax = y,fill=lab)) +
  geom_rect()+xlim(labels = as.character(df$lab))+ theme_bw() 
dev.off() pdf(file = "test2.pdf", width = 8.3, height = 11.7)
-------------------------------------------------------------------------------------------------------
grid.newpage() grid.rect() grid.rect(x=x_Position, y=y_Position, width=width_Value, height=height_Value, gp=gpar(col=section_Color, fill=section_Color), just=c("left", "bottom"), default.units="native") grid.text() grid.text("Label Text", x_Value, y_Value, gp=gpar(col=color_Value, cex=font_Size), just=c("right","center"), rot=rot_Degrees, default.units="native") grid.lines() grid.lines(c(x_Start,x_End), c(y_Start, y_End), gp=gpar(col=color_Value), default.units="native") dataViewport() pushViewport(dataViewport(xData=x_Data, yData=y_Data, xscale=c(x_Min, x_Max), yscale=c(y_Min, y_Max), x=x_Value, y=y_Value, width=width_Value, height=height_Value, just=c("left","center"))) pushViewport() pushViewport(dataViewport([stuff in here])) popViewport() viewport(x=0, y=0, width=0.5, height=1, just=c("left","lower")) viewport(x=0.5, y=0, width=0.5, height=1, just=c("left","lower")) default.units="native"
-------------------------------------------------------------------------------------------------------
grid.raster maps gridBase library(maps)
map('usa',boundary=T,fill=T,col='grey')
library(gridBase)
library(grid)
library(png)
vps <- baseViewports()
pushViewport(vps$figure,vps$plot)
camel <- readPNG("camel.png")    ## some animal picture
grid.rect(gp = gpar(fill=NA))

x <- c(-110,-100,-70)
y <- c(30,40,40)

grid.raster(image=camel,x=x,y=y,width=5,   ## it is vectorized
            interpolate=FALSE,default.units = 'native')
upViewport(1)
-------------------------------------------------------------------------------------------------------
base ggplot2 bandline<-function(x, low.col, high.col, axis=TRUE){
    l <- max(unlist(lapply(x, length)), na.r=TRUE)
    r <- range(unlist(x), na.rm=TRUE)
    par(mfcol=c(length(x), 1))
    for(i in 1:length(x)){
        y <- boxplot.stats(x[[i]])
        ifelse(i==1, par(mar=c(0,3,3,3)), 
                     ifelse(i==length(x), par(mar=c(3,3,0,3)), 
                                          par(mar=c(0,3,0,3))))
        plot(NA, axes=F, bty="n", xlim=c(1,l), ylim=r, xaxs="i")
        rect(1,y$stats[2], l, y$stats[1], col="grey80", border=NA)
        rect(1,y$stats[4], l, y$stats[2], col="grey60", border=NA)
        rect(1,y$stats[5], l, y$stats[4], col="grey40", border=NA)
        abline(h=y$stats[3],col="white", lwd=2)
        lines(seq_along(x[[i]]), x[[i]])
        zhigh <- zlow <- x[[i]]
        zhigh[zhigh<=y$stats[5]]<-NA
        zlow[zlow>=y$stats[1]]<-NA
        points(seq_along(x[[i]]), zlow, bg=low.col, pch=21,cex=2)
        points(seq_along(x[[i]]), zhigh, bg=high.col, pch=21, cex=2)
        if(axis==TRUE){
            axis(2, at=pretty(x[[i]]), las=2)
            ifelse(i==1, axis(3, at=seq_len(l)), 
                         ifelse(i==length(x),axis(1, at=seq_len(l)),""))
            }
        mtext(names(x)[i], side=4, srt=270, line=1)
    }
} set.seed(1)
dat<-list(a=rnorm(100), b=rnorm(100), c=rnorm(100), d=rnorm(100))
bandline(dat, "black", "white", axis=FALSE)
-------------------------------------------------------------------------------------------------------
df <- data.frame(x = c("Alpha", "Beta", "Gamma", "Delta"), width = c(25, 50, 75, 100), height = c(100, 75, 50, 25))
df$w <- cumsum(df$width)
df$wm <- df$w - df$width
df$wt <- with(df, wm + (w - wm)/2)

library(ggplot2)
p  <- ggplot(df, aes(ymin = 0))
p1 <- p + geom_rect(aes(xmin = wm, xmax = w, ymax = height, fill = x))
library(grid) # needed for arrow function
p1 + geom_text(aes(x = wt, y = height * 0.8, label = x)) + 
     theme_bw() + labs(x = NULL, y = NULL) + 
     theme(axis.ticks = element_blank(),axis.text.x = element_blank(), 
     axis.text.y = element_blank(), legend.position = "none") + 
     annotate("text", x = 120, y = 83, label = "a Beta block") + 
     geom_segment(aes(x = 100, y = 80, xend = 80, yend = 75), 
     arrow = arrow(length = unit(0.5, "cm")))
-------------------------------------------------------------------------------------------------------
stl x <- na.action(as.ts(x)) period <- frequency(x)
if (period < 2 || n <= 2 * period) 
    stop("series is not periodic or has less than two periods") stl x ts na.action(as.ts(x)) period == 1 na.omit na.exclude getAnywhere("na.omit.ts") if (any(is.na(object))) 
    stop("time series contains internal NAs") na.omit NAs ts getAnywhere("na.exclude.default") NA exclude attr(omit, "class") <- "exclude" stl na.action(as.ts(x)) ts na.exclude(as.ts(x)) exclude NAs nottem[3] <- NA
frequency(nottem)
# [1] 12
na.new <- function(x) ts(na.exclude(x), frequency = 12)
stl(nottem, na.action = na.new, s.window = "per") stl NA na.action = na.pass z <- .Fortran(C_stl, ... na.new na.contaguous na.approx na.locf zoo stl NAs na.approx zoo stl NAs na.approx NAs library(zoo)
library(plyr)
library(reshape)
library(ggplot2)
mape <- function(f, x) colMeans(abs(1 - f / x) * 100)

stlCheck <- function(data, p = 3, ...){
  set.seed(20130201)
  pos <- lapply(3^(0:p), function(x) sample(1:length(data), x))
  datasetsNA <- lapply(pos, function(x) {data[x] <- NA; data})
  original <- data.frame(stl(data, ...)$time.series, stringsAsFactors = FALSE)
  original$id <- "Original"
  datasetsNA <- lapply(datasetsNA, function(x) 
    data.frame(stl(x, na.action = na.approx, ...)$time.series, 
               id = paste(sum(is.na(x)), "NAs"), 
               stringsAsFactors = FALSE))
  stlAll <- rbind.fill(c(list(original), datasetsNA))
  stlAll$Date <- time(data)
  stlAll <- melt(stlAll, id.var = c("id", "Date"))
  results <- data.frame(trend = sapply(lapply(datasetsNA, '[', i = "trend"), mape, original[, "trend"]))
  results$id <- paste(3^(0:p), "NAs")
  results <- melt(results, id.var = "id")
  results$x <- min(stlAll$Date) + diff(range(stlAll$Date)) / 4
  results$y <- min(original[, "trend"]) + diff(range(original[, "trend"])) / (4 * p) * (0:p)
  results$value <- round(results$value, 2)
  ggplot(stlAll, aes(x = Date, y = value, colour = id, group = id)) + geom_line() + 
    facet_wrap(~ variable, scales = "free_y") + theme_bw() +
    theme(legend.title = element_blank(), strip.background = element_rect(fill = "white")) + 
    labs(x = NULL, y = NULL) + scale_colour_brewer(palette = "Set1") +
    lapply(unique(results$id), function(z)
      geom_text(data = results, colour = "black", size = 3,
                aes(x = x, y = y, label = paste0("MAPE (", id, "): ", value, "%"))))
} nottem stlCheck(nottem, s.window = 4, t.window = 50, t.jump = 1) co2 stlCheck(log(co2), s.window = 21) mdeaths stlCheck(mdeaths, s.window = "per")
-------------------------------------------------------------------------------------------------------
p1 <- ggplot(dat, aes(Date, count)) + 
  geom_bar(aes(fill=Industry), stat="identity", position="stack") + 
  geom_smooth(method="lm", se=T, size=0.5, colour="yellow") +
  facet_grid(Industry~Country, scales="free_y", margins=T) + 
  scale_x_date(breaks = "3 month", minor_breaks = "1 week", 
             labels=date_format("%b-%y")) mytheme <-  theme(legend.position = 'bottom', legend.direction = 'horizontal',
        legend.title = element_blank(), 
        legend.text = element_text(size=10, face = 'bold')) +
  theme(axis.title.x = element_text(face="bold", colour="white", size=12), 
        axis.text.x  = element_text(angle=90, face="bold", size=10),
        axis.title.y = element_text(face="bold", 
                                    colour="white", 
                                    angle=90, 
                                    size=10),
        axis.text.y=element_text(size=10, face="bold"),
        legend.text = element_text(size=10, face = 'bold'), 
        legend.title = element_blank()) +
  theme(strip.text.x = element_text(size=10, 
                                    face="bold", colour="navyblue"), 
        strip.background = element_rect(colour="blue", fill="white"))+ 
  theme(plot.title=element_text(size=13, colour="white", face="bold"))


  p1 + mytheme
-------------------------------------------------------------------------------------------------------
ggplot2 R Date R Date library(ggplot2)
library(scales) # for date formatting with ggplot2

DT <- data.frame(Project = LETTERS[1:5], 
  start = as.Date(ISOdate(2012, c(2,3,2,4,3), c(15,15,1,10) )),
  end = as.Date(ISOdate(2012, c(3,5,3,5,6), c(1,15,15,15,30))))
# it is useful to have a numeric version of the Project column (
DT$ProjectN <- as.numeric(DT$Project) library(plyr)
# find the midpoint date  for each project
DTa <- ddply(DT, .(ProjectN, Project), summarize, mid = mean(c(start,end))) geom_rect ggplot(DT) + 
   geom_rect(aes(colour = Project,ymin = ProjectN - 0.45, 
                ymax = ProjectN + 0.45,  xmin = start, xmax = end)), fill = NA) + 
  scale_colour_hue(guide = 'none') +  # this removes the legend
 geom_text(data = DTa, aes(label = Project, y = ProjectN, x = mid,colour = Project), inherit.aes= FALSE) + # now some prettying up to remove text / axis ticks
  theme(panel.background = element_blank(), 
        axis.ticks.y = element_blank(), axis.text.y = element_blank()) + # and add date labels
  scale_x_date(labels = date_format('%b %d'), 
  breaks = sort(unique(c(DT$start,DT$end))))+ # remove axis labels
  labs(y = NULL, x = NULL)
-------------------------------------------------------------------------------------------------------
library(plotrix)
?gantt.chart dmY.format<-"%d/%m/%Y"
gantt.info<-list(
  labels= c("A","B","C","D","E"),
  starts= as.Date(c("15/02/2012", "15/03/2012", "01/02/2012", "10/04/2012","01/03/2012"),
                  format=dmY.format),
  ends= as.Date(c("01/03/2012", "15/06/2012", "15/03/2012", "15/05/2012","30/06/2012"),
                format=dmY.format)
  )

vgridpos<-as.Date(c("01/01/2012","01/02/2012","01/03/2012","01/04/2012","01/05/2012","01/06/2012","01/07/2012","01/08/2012"),format=dmY.format)
vgridlab<-
  c("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug")

gantt.chart(gantt.info, xlim= c(as.Date("01/01/2012",format=dmY.format), as.Date("01/08/2012",format=dmY.format)) , main="Projects duration",taskcolors=FALSE, border.col="black",
            vgridpos=vgridpos,vgridlab=vgridlab,hgrid=TRUE) data1 <- as.data.frame(gantt.info)
data1$order <- 1:nrow(data1)

library(ggplot2)

ggplot(data1, aes(xmin = starts, xmax = ends, ymin = order, ymax = order+0.5)) + geom_rect(color="black",fill=FALSE) + theme_bw()  + geom_text(aes(x= starts + (ends-starts)/2 ,y=order+0.25, label=labels)) +  ylab("Projects") + xlab("Date")
-------------------------------------------------------------------------------------------------------
dd <- data.frame(x = (x <- 1:10), 
                 y = x + rnorm(10), width = runif(10,1,2), height = runif(10,1,2))

ggplot(data = dd) + 
  geom_rect(aes(xmax = x + width/2, xmin = x - width/2, 
                ymax = y + height/2, ymin = y - height/2), 
            alpha =0.2, color = rgb(0,114,178, maxColorValue=256), 
            fill = rgb(0,114,178, maxColorValue=256)) + 
  coord_fixed() + 
  theme_bw()
-------------------------------------------------------------------------------------------------------
geom_point geom_rect d=data.frame(x=seq(1,10), 
             y=seq(1,10), 
             width=rep(c(0.1,0.5),each =5), 
             height=rep(c(0.8,0.9,0.4,0.6,0.7),each =2)) 

ggplot(data = d) + 
  geom_rect(aes(xmax = x + width, xmin = x-width, 
                ymax = y+height, ymin = y - height), 
            color = "black", fill = NA) + 
  geom_point(mapping=aes(x=x, y=y,size=height/width),
            color='red',shape=0)+
  theme_bw()
-------------------------------------------------------------------------------------------------------
melt() scale_linetype_maunual library(reshape)

intactos2 <- melt(intactos, id.var = c("ecd","ACTIVIDAD"))

a <- ggplot(intactos2,aes(y = value,  x= ecd,group=ACTIVIDAD))+  
     geom_line(aes(colour = ACTIVIDAD,linetype=ACTIVIDAD),colour='black',size=0.5)+
     scale_linetype_manual("Glaciares rocosos",
                            breaks=c("1","2"), 
                            values=c("solid","dashed"),
                            labels = c("Activos", "Inactivos"))+
     ylab("Altitud m") +
     xlab("Distribucion Acumulada (%)\n")+
     scale_y_continuous(limits=c(3500,5000),
                        breaks=c(3500,3750,4000,4250,4500,4750,5000))+
     scale_x_continuous(limits = c(0.00, 1.00),
                        breaks = seq(0, 1, 0.1),
                        labels=seq(0,100,10))+
  theme(  plot.background  = element_rect(fill="white")
         ,panel.background = element_rect(fill='white')
         ,panel.grid.major = element_line(colour = 'grey', linetype = 'dotted',size=0.5)
         ,panel.grid.minor = element_line(colour = 'white', linetype = 'dashed')
         ,panel.border = element_blank()
         ,axis.line = element_line(colour = 'black')
         ,axis.text.x=element_text(colour="black")
         ,axis.text.y=element_text(colour="black")
         ,panel.grid.major =element_line(colour = 'grey', linetype = 'dashed')
         ,legend.key=element_rect(fill="white",colour="white"),legend.position=c(0.3,0.8))+
          geom_hline(aes(yintercept=4000),linetype="solid",size = 0.5)
a

a   +    annotate("text",label="0C MAAT isoterma",x=0.8,y=4050,size=4)
-------------------------------------------------------------------------------------------------------
hh:mm decTime <- function(x) {
    t <- as.numeric(strsplit(x, ":")[[1]])
    t <- t[1] + t[2]/60
    return(t)
}

str <- 'n   day     tstart   tend   duration category
1   2012-10-01      13:40    14:16  36       Recreation
2   2012-10-02      10:15    10:57  42       Work
3   2012-10-02      13:23    13:47  24       Chores
4   2012-10-02      13:47    14:48  61       Work
5   2012-10-03      09:09    11:40  151      Work
6   2012-10-03      13:33    14:04  31       Recreation
7   2012-10-03      17:00    19:40  160      Recreation'

df <- read.table(textConnection(str), header=T) df$day  <- gsub('2012-10-', "", df$day)
df$day <- as.numeric(df$day)
df$starttime <- sapply(as.character(df$tstart), decTime, USE.NAMES=F)
df$endtime <- sapply(as.character(df$tend), decTime, USE.NAMES=F) df$color <- ifelse(df$category=='Recreation', 'RED', ifelse(df$category =='Chores', 'BLUE', 'GREEN')) #Plot empty graph
plot(x=unique(df$day), y=c(0,0,0), axes=F, ylim=c(0,24), xlim=c(0.5,3.5), xlab='date', ylab='time', type='n')
#Label axes properly
axis(side=1, at=c(1,2,3), labels=c('01', '02', '03'))
axis(side=2, at=seq(from=0,to=24,by=1), labels=seq(from=0,to=24,by=1))
#Draw required rectangles
rect(df$day-0.25, df$starttime, df$day+0.25, df$endtime, col=df$color)
-------------------------------------------------------------------------------------------------------
mfg par ?par par(mfg=c(1,2)) layout par(xpd=NA)
rect( grconvertX(0, from='nfc'), grconvertY(0,from='nfc'), 
grconvertX(1,from='nfc'), grconvertY(1, from='nfc'), 
col='white',border='white')
-------------------------------------------------------------------------------------------------------
geometry mesh.drectangle combn library(geometry)
## I generate some data 
set.seed(1234)
p.x <- sample(1:100,size=30,replace=T)
p.y <- sample(1:100,size=30,replace=T)
points <- cbind(p.x,p.y)

## the  algortithm
ll <- combn(1:nrow(points),2,function(x){
     x1<- p.x[x[1]]; y1 <- p.y[x[1]]
     x2<- p.x[x[2]]; y2 <- p.y[x[2]]
     p <- points[-x,]
     d <- mesh.drectangle(p,x1,y1,x2,y2)
     res <- NA
     if(length(which(d <0))){
        points.in = as.data.frame(p,ncol=2)[ d < 0 , ]
       res <- list(n = nrow(points.in), 
                    rect = list(x1=x1,x2=x2,y1=y1,y2=y2),
                    points.in = points.in)
     }
     res
},simplify=F)
ll <- ll[!is.na(ll)]

## the result
nn <- do.call(rbind,lapply(ll,'[[','n')) library(grid)
grid.newpage()
vp <- plotViewport(xscale = extendrange(p.x),
                          yscale = extendrange(p.y))
pushViewport(vp)
grid.xaxis()   
grid.yaxis()
grid.points(x=points[,'p.x'],y=points[,'p.y'],pch='*')
cols <- rainbow(length(ll))
ll <- ll[nn == 5]           ## here I plot only the rectangle with 5 points 
lapply(seq_along(ll),function(i){
            x <- ll[[i]]
            col <- sample(cols,1)
            x1<- x$rect$x1; x2<- x$rect$x2
            y1<- x$rect$y1; y2<- x$rect$y2
            grid.rect(x=(x1+x2)*.5,y=(y1+y2)*.5,
                      width= x2-x1,height = y2-y1,
                      default.units ='native',
                      gp=gpar(fill=col,col='red',alpha=0.2)
                      )
            grid.points(x=x$points.in$p.x,y=x$points.in$p.y,pch=19,
                        gp=gpar(col=rep(col,x$n))) 

 }
)
upViewport()
-------------------------------------------------------------------------------------------------------
R> library(reshape2)
R> dd = melt(hej3, colnames(hej3)[c(1:2, 4, 6:10)])
R> dd = dd[dd$variable=="Delgare.mn.",c(1, 9:10)]
R> head(dd, 4)
   Year variable value
1  1901        N    85
3  1902        N    92
5  1903        N    99
7  1904        N   112 + geom_line(data=dd, aes(x=Year, y = value, linetype=variable), 
          size = 1.5,  alpha = 1) + + coord_cartesian(ylim = c(-300, 600)) ggplot(subset(hej3,variable=="Delgare.mn."), aes(x = Year)) + 
geom_line(data=dd, aes(x=Year, y = value, linetype=variable), 
          size = 1.5,  alpha = 1) + 
geom_ribbon(aes(ymax = Max, 
                ymin = Min, fill = "Delgare Mn Max/Min"), linetype = 3, 
            alpha = 0.4) + 
geom_ribbon(aes(ymax = Mean+sd, ymin = Mean-sd, fill = "Mean +- sd"), 
            colour = "grey50", linetype = 3, alpha = 0.8)+
scale_color_manual("Variabler", breaks = c("Antal Kassor","Medelvrde"),  
                   values = c("Antal Kassor" = "black", "Medelvrde" = "#6E6E6E")) + 
scale_fill_manual(" Ribbons", breaks = c("Delgare Mn Max/Min", "Mean +- sd"), 
                  values = c(`Delgare Mn Max/Min` = "grey50", `Mean +- sd` = "#4E4E4E")) + 
theme(legend.direction = "horizontal", legend.position = "bottom", legend.key = element_blank(), 
      legend.background = element_rect(fill = "white", colour = "gray30")) + 
guides(fill = guide_legend(keywidth = 0.9, keyheight = 1))    +
coord_cartesian(ylim = c(-300, 600))
-------------------------------------------------------------------------------------------------------
geom_line() linetype= aes() + geom_line(aes(y = Mean, color = "Medelvrde",linetype = "Medelvrde"), 
            size = 1.5, alpha = 1)  
 + geom_line(aes(y = N, 
                color = "Antal Kassor",linetype="Antal Kassor"), size = 0.9, alpha = 1) scale_linetype_manual() scale_colour_manual() +scale_linetype_manual("Variabler",values=c("Antal Kassor"=2,"Medelvrde"=1)) guides() linetype colours + guides(fill = guide_legend(keywidth = 1, keyheight = 1),
    linetype=guide_legend(keywidth = 3, keyheight = 1),
    colour=guide_legend(keywidth = 3, keyheight = 1)) theplot<- ggplot(subset(hej3,variable=="Delgare.mn."), aes(x = Year)) + 

  geom_line(aes(y = Mean, color = "Medelvrde",linetype = "Medelvrde"), 
            size = 1.5, alpha = 1) + 

  geom_ribbon(aes(ymax = Max, 
                  ymin = Min, fill = "Delgare Mn Max/Min"), linetype = 3, 
              alpha = 0.4) + 

  geom_ribbon(aes(ymax = Mean+sd, ymin = Mean-sd, fill = "Mean +- sd"), 
              colour = "grey50", linetype = 3, alpha = 0.8)+

  #geom_line(aes(y = Sum, 
  #color = "Sum Delgare Mn"), size = 0.9, linetype = 1, alpha = 1) + 

  geom_line(aes(y = N, 
                color = "Antal Kassor",linetype="Antal Kassor"), size = 0.9, alpha = 1)+

  scale_y_continuous(breaks = seq(-500, 4800, by = 100), limits = c(-500, 4800), 
                     labels = seq(-500, 4800, by = 100))+ 
  scale_x_continuous(breaks=seq(1901,1930,2))+
  labs(title = "Manliga Delgare i Yrkeskassor") +

  scale_color_manual("Variabler", breaks = c("Antal Kassor","Medelvrde"),  
                     values = c("Antal Kassor" = "black", "Medelvrde" = "#6E6E6E")) + 
  scale_fill_manual(" Ribbons", breaks = c("Delgare Mn Max/Min", "Mean +- sd"), 
                    values = c(`Delgare Mn Max/Min` = "grey50", `Mean +- sd` = "#4E4E4E")) + 
  scale_linetype_manual("Variabler",values=c("Antal Kassor"=2,"Medelvrde"=1))+
  theme(legend.direction = "horizontal", legend.position = "bottom", legend.key = element_blank(), 
        legend.background = element_rect(fill = "white", colour = "gray30")) + 
  guides(fill = guide_legend(keywidth = 1, keyheight = 1), linetype=guide_legend(keywidth = 3, keyheight = 1),
         colour=guide_legend(keywidth = 3, keyheight = 1)) +
     coord_cartesian(ylim = c(-300, 600))
-------------------------------------------------------------------------------------------------------
chart_Series() print f1 <- function() { 
  require(quantmod)
  s <- get(getSymbols('PRGO'))["2012::"]
  print(chart_Series(s))
  u<-par("usr")
  d<-data.frame(Buttom=c(100,90),Top=c(110,95))
  rect(u[1],d[,'Buttom'],u[2],d[,'Top'],col=rgb(1,0,0,alpha=0.2),border=0)
}

f1()
-------------------------------------------------------------------------------------------------------
set.seed(1)
dd = data.frame(x = 1:5, eps_x = rnorm(5, 0, 0.1), y = rnorm(5), eps_y = rnorm(5, 0, 0.1))

##Save space later    
dd$xmin = dd$x - dd$eps_x
dd$xmax = dd$x + dd$eps_x
dd$ymin = dd$y - dd$eps_y
dd$ymax = dd$y + dd$eps_y library(ggplot2)
ggplot(dd) + 
     geom_rect(aes( xmax = xmax, xmin=xmin, ymin=ymin, ymax = ymax)) plot(0, 0, xlim=c(0.5, 5.5), ylim=c(-1, 1), type="n")
for(i in 1:nrow(dd)){
    d = dd[i,]
    polygon(c(d$xmin, d$xmax, d$xmax, d$xmin), c(d$ymin, d$ymin, d$ymax,d$ymax), col="grey80")
}
-------------------------------------------------------------------------------------------------------
ggplot2 R # An example data frame
dat <- data.frame(x = 1:5, y = 5:1, ex = (1:5)/10, ey = (5:1)/10)

# Plot
library(ggplot2)
ggplot(dat) +
  geom_rect(aes(xmin = x - ex, xmax = x + ex, ymin = y - ey, ymax = y + ey), 
            fill = "grey") +
  geom_point(aes(x = x, y = y)) aes geom_rect ex ey x y
-------------------------------------------------------------------------------------------------------
x1 <-  c(2,13,4)
y2 <- c(5,23,43)
foo <- data.frame(id=1:3, x1, y2)

library(ggplot2)
ggplot(data=foo) + geom_rect(aes(ymin=x1, ymax=y2, xmin=id-0.4, xmax=id+0.4))
-------------------------------------------------------------------------------------------------------
#Set alignment for tow plots. Extra zeros are needed to get space for axis at bottom.
layout(matrix(c(0,1,2,0),ncol=1),heights=c(1,3,3,1))

#Set spaces around plot (0 for bottom and top)
par(mar=c(0,5,0,5))

#1. plot
plot(df$V2~df$TIME2,type="l",xlim=c(1000,2000),axes=F,ylab="")

#Two rectangles - y coordinates are larger to ensure that all space is taken  
rect(1100,-15000,1300,15000,col="red",border="red")
rect(1800,-15000,1850,15000,col="red",border="red")

#plot again the same line (to show line over rectangle)
par(new=TRUE)
plot(df$V2~df$TIME2,type="l",xlim=c(1000,2000),axes=F,ylab="")

#set axis
axis(1,at=seq(800,2200,200),labels=NA)
axis(4,at=seq(-15000,10000,5000),las=2)


#The same for plot 2. rev() in ylim= ensures reverse axis.
plot(df$VARIABLE1~df$TIME1,type="l",ylim=rev(range(df$VARIABLE1)+c(-0.1,0.1)),xlim=c(1000,2000),axes=F,ylab="")
rect(1100,-15000,1300,15000,col="red",border="red")
rect(1800,-15000,1850,15000,col="red",border="red")
par(new=TRUE)
plot(df$VARIABLE1~df$TIME1,type="l",ylim=rev(range(df$VARIABLE1)+c(-0.1,0.1)),xlim=c(1000,2000),axes=F,ylab="")
axis(1,at=seq(800,2200,200))
axis(2,at=seq(-6.4,-8.4,-0.4),las=2) rect1<- data.frame (xmin=1100, xmax=1300, ymin=-Inf, ymax=Inf)
rect2 <- data.frame (xmin=1800, xmax=1850, ymin=-Inf, ymax=Inf) data aes geom_line() geom_rect() plot.margin= theme() -1 p1 p2 p2 library(ggplot2)
library(grid)
library(gridExtra)
p1<- ggplot() + geom_line(data=df, aes(TIME1, VARIABLE1)) + 
  scale_y_reverse() + 
  labs(x="AGE") + 
  scale_x_continuous(breaks = seq(1000,2000,200), limits = c(1000,2000)) + 
   geom_rect(data=rect1,aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymax),alpha=0.1,fill="blue")+
   geom_rect(data=rect2,aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymax),alpha=0.1,fill="blue")+
   theme(plot.margin = unit(c(-1,0.5,0.5,0.5), "lines"))

p2<- ggplot() + geom_line(data=df, aes(TIME2, V2)) + labs(x=NULL) + 
  scale_x_continuous(breaks = seq(1000,2000,200), limits = c(1000,2000)) + 
  scale_y_continuous(limits=c(-14000,10000))+
  geom_rect(data=rect1,aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymax),alpha=0.1,fill="blue")+
  geom_rect(data=rect2,aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymax),alpha=0.1,fill="blue")+
  theme(axis.text.x=element_blank(),
        axis.title.x=element_blank(),
        plot.title=element_blank(),
        axis.ticks.x=element_blank(),
        plot.margin = unit(c(0.5,0.5,-1,0.5), "lines"))


gp1<- ggplot_gtable(ggplot_build(p1))
gp2<- ggplot_gtable(ggplot_build(p2))
maxWidth = unit.pmax(gp1$widths[2:3], gp2$widths[2:3])
gp1$widths[2:3] <- maxWidth
gp2$widths[2:3] <- maxWidth
grid.arrange(gp2, gp1)
-------------------------------------------------------------------------------------------------------
gridFIG() gridBase plot.new() grid.newpage() library(grid)
library(gridBase)
plot.new()
vp1 <- viewport(x=0,y=0.5,width=0.5, height=0.5, just = c("left", "bottom"))
vp2 <- viewport(x=0.5,y=0,width=0.5, height=0.5, just = c("left", "bottom"))
pushViewport(vp1)
grid.rect()
grid.text("vp1", 0.5, 0.5)
par(new=TRUE, fig=gridFIG())
plot(1,2)
upViewport()
pushViewport(vp2)
grid.rect()
grid.text("vp2", 0.5, 0.5)
par(new=TRUE, fig=gridFIG())
plot(1,2)
-------------------------------------------------------------------------------------------------------
#Create data.frame
n=100
df <-data.frame(1:n,runif(n)*10,60+runif(n)*10,25+runif(n)*10,40+runif(n)*10,35-runif(n)*10,35+runif(n)*10)
colnames(df) <-c("id","beige.min","beige.max","gray.min","gray.max","red.min","red.max")

#Create chart
plot(x=df$id,y=NULL,ylim=range(df[,-1]), type="n")  #blank chart, ylim is the range of the data
rect(df$id-0.5,df[,2],df$id+0.5,df[,3],col="beige", border=FALSE) #first layer
rect(df$id-0.5,df[,4],df$id+0.5,df[,5],col="gray", border=FALSE)  #second layer
rect(df$id-0.5,df[,6],df$id+0.5,df[,7],col="darkred", border=FALSE) #third layer
-------------------------------------------------------------------------------------------------------
## here the edit 
dat.lines <- do.call(cbind,apply(connectd,2,
                                 function(x){
                                   id <- match(x,plotcord$plotname)
                                   plotcord[id,c(2,3)]}))

colnames(dat.lines) <- paste(rep(c('x','y'),3),rep(1:3,each=2),sep='') x1 y1   x2 y2   x3 y3
1 1.750  2 1.50  3 2.00  3
2 5.250  2 5.00  3 5.50  3
3 1.375  1 1.00  2 1.75  2
4 3.500  1 1.75  2 5.25  2
5 6.000  1 1.75  2 5.25  2
6 7.500  1 5.25  2 8.00  2 xyplot library(latticeExtra))
xyplot(plotgridY~plotgridX,data= plotcord,
       panel=function(x,y,...){
     apply(dat.lines,1,function(x){
       panel.segments(x0=x['x2'],y0=x['y2'],x1=x['x3'],y1=x['y3'])
       boxh <- 0.5
       x1=x['x1']
       y1=x['y1']
       y2 <- x['y2']
       x2 <- (x['x2']+x['x3'])/2
       ydelta <- (y2 - y1)/2
       browser()
       panel.segments(c(x1, x1, x2), c(y1, y1 + ydelta, y2 - 
                                   ydelta), c(x1, x2, x2), c(y1 + ydelta, y2 - 
                                                               ydelta, y2))
     })

         panel.rect(x=x,y=y,width=unit(2,'cm'),
                    height=unit(2,'cm'),col='lightyellow')
         panel.xyplot(x,y,...)
         panel.text(x,y,adj=c(0,-3),
                    label=plotcord$plotname,cex=1.5)

         ## add some prove of concept detail 
         panel.rect(x=x,y=y,width=unit(0.5,'cm'),
                    height=unit(0.5,'cm'),col='lightblue',lty=2)
         panel.text(x,y,adj=c(1,2),
                    label=paste(plotcord$plotname,1,sep=''),cex=1,col='blue')
         panel.text(x,y,adj=c(-0.5,2),
                    label=paste(plotcord$plotname,2,sep=''),
                    cex=1,col='blue')


         },ylim=extendrange(plotcord$plotgridY,f=0.5),xlab='',ylab='', axis = axis.grid,
   main='Arrangement of large number of plots \n and connect with lines ')
-------------------------------------------------------------------------------------------------------
ggplot2 + theme(panel.background=element_rect(fill="blue", colour="blue") plot.background panel.background opts theme theme_rect element_rect element_rect color fill + geom_rect(aes(xmin=-Inf, xmax=Inf, ymin=-Inf, ymax=Inf), fill="blue") geom_raster geom_tile pdf
-------------------------------------------------------------------------------------------------------
pushViewport(viewport(x=0, y=1, xscale=c(1, 10), yscale=c(0, 100), width=0.25, height=0.25, default.units="npc", just=c("left","bottom"), clip="off")) library(grid)

# Specify general chart options.
chart_Fill = "lemonchiffon"
chart_Col = "snow3"
space_Background = "white"
title_CEX = 0.8
axis_CEX = 0.6
chart_Width <- 3/3
chart_Height <- 2/5

# Function to initialize a plotting area.
init_Plot <- function(
    .df,
    .x_Loc, 
    .y_Loc, 
    .justify, 
    .width, 
    .height
    ){

    # Initialize plotting area to fit data.
    # We have to turn off clipping to make it
    # easy to plot the labels around the plot.
    pushViewport(viewport(xscale=c(min(.df[,1]), max(.df[,1])), yscale=c(min(0,min(.df[,-1])), max(.df[,-1])), x=.x_Loc, y=.y_Loc, width=.width, height=.height, just=.justify, clip="off", default.units="native"))

    # Color behind text.
    grid.rect(x=0, y=0, width=unit(axis_CEX, "lines"), height=1, default.units="npc", just=c("right", "bottom"), gp=gpar(fill=space_Background, col=space_Background))
    grid.rect(x=0, y=1, width=1, height=unit(title_CEX, "lines"), default.units="npc", just=c("left", "bottom"), gp=gpar(fill=space_Background, col=space_Background))

    # Color in the space.
    grid.rect(gp=gpar(fill=chart_Fill, col=chart_Col))
}

# Function to finalize and label a plotting area.
finalize_Plot <- function(
    .df, 
    .plot_Title
    ){

    # Label plot using the internal reference
    # system, instead of the parent window, so
    # we always have perfect placement.
    grid.text(.plot_Title, x=0.5, y=1.05, just=c("center","bottom"), rot=0, default.units="npc", gp=gpar(cex=title_CEX))
    grid.text(paste(names(.df)[-1], collapse=" & "), x=-0.05, y=0.5, just=c("center","bottom"), rot=90, default.units="npc", gp=gpar(cex=axis_CEX))
    grid.text(names(.df)[1], x=0.5, y=-0.05, just=c("center","top"), rot=0, default.units="npc", gp=gpar(cex=axis_CEX))

    # Finalize plotting area.
    popViewport()
}

# Function to plot a filled line chart of
# the data in a data frame.  The first column
# of the data frame is assumed to be the
# plotting index, with each column being a
# set of y-data to plot.  All data is assumed
# to be numeric.
plot_Line_Chart <- function(
    .df,
    .x_Loc,
    .y_Loc,
    .justify,
    .width,
    .height,
    .colors,
    .plot_Title
    ){

    # Initialize plot.
    init_Plot(.df, .x_Loc, .y_Loc, .justify, .width, .height)

    # Calculate what value to use as the
    # return for the polygons.
    y_Axis_Min <- min(0, min(.df[,-1]))

    # Plot each set of data as a polygon,
    # so we can fill it in with color to
    # make it easier to read.
    for (i in 2:ncol(.df)){
        grid.polygon(x=c(min(.df[,1]),.df[,1], max(.df[,1])), y=c(y_Axis_Min,.df[,i], y_Axis_Min), default.units="native", gp=gpar(fill=.colors[i-1], col=.colors[i-1], alpha=1/ncol(.df)))
    }

    # Draw plot axes.
    grid.lines(x=0, y=c(0,1), default.units="npc")
    grid.lines(x=c(0,1), y=0, default.units="npc")

    # Finalize plot.
    finalize_Plot(.df, .plot_Title)

}

# Function to plot a scatterplot of
# the data in a data frame.  The
# assumptions are the same as 'plot_Line_Chart'.
plot_Scatterplot <- function(
    .df,
    .x_Loc,
    .y_Loc,
    .justify,
    .width,
    .height,
    .colors,
    .plot_Title
    ){

    # Initialize plot.
    init_Plot(.df, .x_Loc, .y_Loc, .justify, .width, .height)

    # Plot each set of data as colored points.
    for (i in 2:ncol(.df)){
        grid.points(x=.df[,1], y=.df[,i], pch=19, size=unit(1, "native"), default.units="native", gp=gpar(col=.colors[i-1], alpha=1/ncol(.df)))
    }

    # Draw plot axes.
    grid.lines(x=0, y=c(0,1), default.units="npc")
    grid.lines(x=c(0,1), y=0, default.units="npc")

    # Finalize plot.
    finalize_Plot(.df, .plot_Title)

}

# Function to plot a histogram of
# all the columns in a data frame,
# except the first, which is assumed to
# be an index.
plot_Histogram <- function(
    .df,
    .x_Loc,
    .y_Loc,
    .justify,
    .width,
    .height,
    .colors,
    .plot_Title,
    ...
    ){

    # Create a list containing the histogram
    # data for each data column and calculate
    # data ranges.  Any extra parameters
    # specified will pass to the 'hist' function.
    hist_Data <- list()
    hist_Count_Range <- c(0,NA)
    hist_Breaks_Range <- c(NA,NA)
    for (i in 2:ncol(.df)){
        hist_Data[[i]] <- hist(.df[,i], plot=FALSE, ...)
        hist_Count_Range[2] <- max(max(hist_Data[[i]]$counts), hist_Count_Range[2], na.rm=TRUE)
        hist_Breaks_Range <- c(min(min(hist_Data[[i]]$breaks), hist_Breaks_Range[1], na.rm=TRUE), max(max(hist_Data[[i]]$breaks), hist_Breaks_Range[2], na.rm=TRUE))
    }


    # Initialize plotting area to fit data.
    # We are doing this in a custom way to
    # allow more flexibility than built into
    # the 'init_Plot' function.
    # We have to turn off clipping to make it
    # easy to plot the labels around the plot.
    pushViewport(viewport(xscale=hist_Breaks_Range, yscale=hist_Count_Range, x=.x_Loc, y=.y_Loc, width=.width, height=.height, just=.justify, clip="off", default.units="native"))

    # Color behind text.
    grid.rect(x=0, y=0, width=unit(axis_CEX, "lines"), height=1, default.units="npc", just=c("right", "bottom"), gp=gpar(fill=space_Background, col=space_Background))
    grid.rect(x=0, y=1, width=1, height=unit(title_CEX, "lines"), default.units="npc", just=c("left", "bottom"), gp=gpar(fill=space_Background, col=space_Background))

    # Color in the space.
    grid.rect(gp=gpar(fill=chart_Fill, col=chart_Col))


    # Draw x axis.
    grid.lines(x=c(0,1), y=0, default.units="npc")

    # Plot each set of data as a histogram.
    for (i in 2:ncol(.df)){
        grid.rect(x=hist_Data[[i]]$mids, y=0, width=diff(hist_Data[[i]]$mids[1:2]), height=hist_Data[[i]]$counts, default.units="native", just=c("center","bottom"), gp=gpar(fill=.colors[i-1], col=.colors[i-1], alpha=1/ncol(.df)))
    }

    # Label plot using the internal reference
    # system, instead of the parent window, so
    # we always have perfect placement.
    grid.text(.plot_Title, x=0.5, y=1.05, just=c("center","bottom"), rot=0, default.units="npc", gp=gpar(cex=title_CEX))
    grid.text(paste(names(.df)[-1], collapse=" & "), x=-0.05, y=0.5, just=c("center","bottom"), rot=90, default.units="npc", gp=gpar(cex=axis_CEX))

    # Finalize plotting area.
    popViewport()
}

draw_Sample_Box <- function(
    .x_Loc,
    .y_Loc,
    .x_Scale,
    .y_Scale,
    .justify,
    .width,
    .height,
    .colors,
    .box_X,
    .box_Y,
    .plot_Title
    ){

    pushViewport(viewport(xscale=.x_Scale, yscale=.y_Scale, x=.x_Loc, y=.y_Loc, width=chart_Width, height=chart_Height, just=.justify, clip="off", default.units="native"))

    # Color behind text.
    grid.rect(x=0, y=1, width=1, height=unit(title_CEX, "lines"), default.units="npc", just=c("left", "bottom"), gp=gpar(fill=space_Background, col=space_Background))

    # Color in the space.
    grid.rect(gp=gpar(fill=chart_Fill, col=chart_Col))

    # Label plot.
    grid.text(.plot_Title, x=0.5, y=1.05, just=c("center","bottom"), rot=0, default.units="npc", gp=gpar(cex=title_CEX))

    # Draw box and label points.
    grid.polygon(x=.box_X, y=.box_Y, default.units="native", gp=gpar(fill=.colors[1], col=.colors[2]))
    grid.text(paste(.plot_Title, 1, sep=""), x=min(.box_X), y=min(.box_Y), default.units="native", just=c("right","top"), gp=gpar(cex=0.5))
    grid.text(paste(.plot_Title, 2, sep=""), x=max(.box_X), y=min(.box_Y), default.units="native", just=c("left","top"), gp=gpar(cex=0.5))

    # Finalize plot.
    popViewport()
} # Draw twelve independent charts as
# a demo and connect with lines similar
# to a heiritage chart.
grid.newpage()

# Initialize a viewport to make our locations
# easier to map.
pushViewport(viewport(x=0, y=0, width=1, height=1, just=c("left","bottom"), xscale=c(0,10), yscale=c(0,4)))

# Color background of overall plot.
grid.rect(gp=gpar(fill=space_Background, col=space_Background))

# Store plot locations for convenience.
plot_Loc <- data.frame(x=c(2,4,6,8,1,3,7,9,2,4,6,8), y=c(3,3,3,3,2,2,2,2,1,1,1,1))

# Draw connecting lines.
connections <- data.frame(a=c(1, 3, 5, 6, 7, 1, 3, 5, 7, 6), b=c(2, 4, 6, 7, 8, 2, 4, 6, 8, 7), c=c(NA, NA, NA, NA, NA, 6, 7, 9, 12, 10), d=c(NA, NA, NA, NA, NA, NA, NA, NA, NA, 11))
for (i in 1:nrow(connections)){
    if (is.na(connections$c[i])){
        grid.lines(x=plot_Loc$x[unlist(connections[i,1:2])], y=plot_Loc$y[unlist(connections[i,1:2])], default.units="native")
    } else if (is.na(connections$d[i])) {
        grid.lines(x=median(plot_Loc$x[unlist(connections[i,1:2])]), y=plot_Loc$y[unlist(connections[i,2:3])], default.units="native")
    } else {
        grid.lines(x=median(plot_Loc$x[unlist(connections[i,1:2])]), y=c(plot_Loc$y[connections[i,2]], median(plot_Loc$y[unlist(connections[i,2:3])])), default.units="native")
        grid.lines(x=plot_Loc$x[unlist(connections[i,3:4])], y=median(plot_Loc$y[unlist(connections[i,2:3])]), default.units="native")
        grid.lines(x=plot_Loc$x[connections[i,3]], y=c(median(plot_Loc$y[unlist(connections[i,2:3])]), plot_Loc$y[connections[i,3]]), default.units="native")
        grid.lines(x=plot_Loc$x[connections[i,4]], y=c(median(plot_Loc$y[unlist(connections[i,2:3])]), plot_Loc$y[connections[i,4]]), default.units="native")
    }
}


# Draw four independent line charts.
p <- 1
plot_Line_Chart(data.frame(time=1:1860, EuStockMarkets)[1:3], .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("dodgerblue", "deeppink"), "EU Stocks")
p <- 2
plot_Line_Chart(data.frame(time=1:1860, EuStockMarkets)[c(1,4,5)], .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("green", "purple"), "EU Stocks")
p <- 3
plot_Line_Chart(data.frame(time=1:(12*20), sunspots=sunspot.month[(171*12+1):(171*12+12*20)]), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("darkgoldenrod"), "Sunspots")
p <- 4
plot_Line_Chart(data.frame(time=1:(12*20), temp=nottem), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("red"), "Nottem")

# Draw four independent scatterplots.
p <- 5
plot_Scatterplot(data.frame(time=1:(1860 + 1 - 1000), DAX=rowMeans(embed(EuStockMarkets[,1], 1000)), FTSE=rowMeans(embed(EuStockMarkets[,4], 1000))), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("deeppink", "purple"), "Smooth")
p <- 6
plot_Scatterplot(data.frame(time=1:1860, EuStockMarkets)[c(1,2,5)], .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("deeppink", "purple"), "EU Stocks")
p <- 9
plot_Scatterplot(data.frame(time=1:(1860 + 1 - 20), DAX=rowMeans(embed(EuStockMarkets[,1], 20)), FTSE=rowMeans(embed(EuStockMarkets[,4], 20))), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("deeppink", "purple"), "Smooth*20")
p <- 10
plot_Scatterplot(data.frame(time=1:(1860 + 1 - 100), DAX=rowMeans(embed(EuStockMarkets[,1], 100)), FTSE=rowMeans(embed(EuStockMarkets[,4], 100))), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("deeppink", "purple"), "Smooth*100")


# Draw two independent histograms.
p <- 7
plot_Histogram(data.frame(time=1:(12*20), sunspots=sunspot.month[(171*12+1):(171*12+12*20)]), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("darkgoldenrod"), "Sunspots", breaks=6)
p <- 8
plot_Histogram(data.frame(time=1:(12*20), temp=nottem), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("red"), "Nottem", breaks=6)

# Draw sample objects in two charts spaces.
p <- 11
draw_Sample_Box(.x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .x_Scale=c(0,10), .y_Scale=c(-10,0), .justify=c("center","center"), .width=chart_Width, .height=chart_Height, .colors=c("dodgerblue","blue"), .box_X=c(4,6,6,4), .box_Y=c(-4,-4,-5,-5), .plot_Title="K")
p <- 12
draw_Sample_Box(.x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .x_Scale=c(-1,1), .y_Scale=c(0,1), .justify=c("center","center"), .width=chart_Width, .height=chart_Height, .colors=c("dodgerblue","blue"), .box_X=c(-0.5,0,0,-0.5), .box_Y=c(0.8,0.8,0.7,0.7), .plot_Title="L")
-------------------------------------------------------------------------------------------------------
# Function to initialize a plotting area.
init_Plot <- function(
    .df,
    .x_Loc, 
    .y_Loc, 
    .justify, 
    .width, 
    .height
    ){

    # Initialize plotting area to fit data.
    # We have to turn off clipping to make it
    # easy to plot the labels around the plot.
    pushViewport(viewport(xscale=c(min(.df[,1]), max(.df[,1])), yscale=c(min(0,min(.df[,-1])), max(.df[,-1])), x=.x_Loc, y=.y_Loc, width=.width, height=.height, just=.justify, clip="off", default.units="npc"))

    # Color behind text.
    grid.rect(x=0, y=0, width=unit(axis_CEX, "lines"), height=1, default.units="npc", just=c("right", "bottom"), gp=gpar(fill=space_Background, col=space_Background))
    grid.rect(x=0, y=1, width=1, height=unit(title_CEX, "lines"), default.units="npc", just=c("left", "bottom"), gp=gpar(fill=space_Background, col=space_Background))

    # Color in the space.
    grid.rect(gp=gpar(fill=chart_Fill, col=chart_Col))
}

# Function to finalize and label a plotting area.
finalize_Plot <- function(
    .df, 
    .plot_Title
    ){

    # Label plot using the internal reference
    # system, instead of the parent window, so
    # we always have perfect placement.
    grid.text(.plot_Title, x=0.5, y=1.05, just=c("center","bottom"), rot=0, default.units="npc", gp=gpar(cex=title_CEX))
    grid.text(paste(names(.df)[-1], collapse=" & "), x=-0.05, y=0.5, just=c("center","bottom"), rot=90, default.units="npc", gp=gpar(cex=axis_CEX))
    grid.text(names(.df)[1], x=0.5, y=-0.05, just=c("center","top"), rot=0, default.units="npc", gp=gpar(cex=axis_CEX))

    # Finalize plotting area.
    popViewport()
}

# Function to plot a filled line chart of
# the data in a data frame.  The first column
# of the data frame is assumed to be the
# plotting index, with each column being a
# set of y-data to plot.  All data is assumed
# to be numeric.
plot_Line_Chart <- function(
    .df,
    .x_Loc,
    .y_Loc,
    .justify,
    .width,
    .height,
    .colors,
    .plot_Title
    ){

    # Initialize plot.
    init_Plot(.df, .x_Loc, .y_Loc, .justify, .width, .height)

    # Calculate what value to use as the
    # return for the polygons.
    y_Axis_Min <- min(0, min(.df[,-1]))

    # Plot each set of data as a polygon,
    # so we can fill it in with color to
    # make it easier to read.
    for (i in 2:ncol(.df)){
        grid.polygon(x=c(min(.df[,1]),.df[,1], max(.df[,1])), y=c(y_Axis_Min,.df[,i], y_Axis_Min), default.units="native", gp=gpar(fill=.colors[i-1], col=.colors[i-1], alpha=1/ncol(.df)))
    }

    # Draw plot axes.
    grid.lines(x=0, y=c(0,1), default.units="npc")
    grid.lines(x=c(0,1), y=0, default.units="npc")

    # Finalize plot.
    finalize_Plot(.df, .plot_Title)

} grid.newpage()

# Specify main chart options.
chart_Fill = "lemonchiffon"
chart_Col = "snow3"
space_Background = "white"
title_CEX = 1.4
axis_CEX = 1

plot_Line_Chart(data.frame(time=1:1860, EuStockMarkets)[1:5], .x_Loc=1, .y_Loc=0, .just=c("right","bottom"), .width=0.9, .height=0.9, c("dodgerblue", "deeppink", "green", "red"), "EU Stocks")

# Specify sub-chart options.
chart_Fill = "lemonchiffon"
chart_Col = "snow3"
space_Background = "lemonchiffon"
title_CEX = 0.8
axis_CEX = 0.7

for (i in 1:4){
    plot_Line_Chart(data.frame(time=1:1860, EuStockMarkets)[c(1,i + 1)], .x_Loc=0.15*i, .y_Loc=0.8, .just=c("left","top"), .width=0.1, .height=0.1, c("dodgerblue", "deeppink", "green", "red")[i], "EU Stocks")
}
-------------------------------------------------------------------------------------------------------
pairs() panel.cor() panel.cor <- function(x, y, digits=2, cex.cor)
{
  usr <- par("usr"); on.exit(par(usr))
  par(usr = c(0, 1, 0, 1))
  r <- abs(cor(x, y))
  txt <- format(c(r, 0.123456789), digits=digits)[1]
  test <- cor.test(x,y)
  Signif <- ifelse(round(test$p.value,3)<0.001,"p<0.001",paste("p=",round(test$p.value,3)))  
  text(0.5, 0.25, paste("r=",txt))
  text(.5, .75, Signif)
} panel.smooth() cex= col= pch= panel.smooth<-function (x, y, col = "blue", bg = NA, pch = 18, 
                        cex = 0.8, col.smooth = "red", span = 2/3, iter = 3, ...) 
{
  points(x, y, pch = pch, col = col, bg = bg, cex = cex)
  ok <- is.finite(x) & is.finite(y)
  if (any(ok)) 
    lines(stats::lowess(x[ok], y[ok], f = span, iter = iter), 
          col = col.smooth, ...)
} panel.hist() pairs() panel.hist <- function(x, ...)
{
  usr <- par("usr"); on.exit(par(usr))
  par(usr = c(usr[1:2], 0, 1.5) )
  h <- hist(x, plot = FALSE)
  breaks <- h$breaks; nB <- length(breaks)
  y <- h$counts; y <- y/max(y)
  rect(breaks[-nB], 0, breaks[-1], y, col="cyan", ...)
} pairs(USJudgeRatings[,c(2:3,6,1,7)],
          lower.panel=panel.smooth, upper.panel=panel.cor,diag.panel=panel.hist)
-------------------------------------------------------------------------------------------------------
geom_segment talking library(animation)
library(RColorBrewer)
library(grid)         ## for arrow
library(ggplot2)      
# scale the duration (not ideal)
talking$scale_duration <-scale(talking$duration, center = FALSE)
# ensure that we have different colours for each speaker

ss <- levels(talking$speaker)

speakerCol <- scale_colour_manual(values = setNames(brewer.pal(n=length(ss), 'Set2' ), ss), guide = 'none')

# the base plot with the table and speakers (and `talking` base dataset)
base <- ggplot(data = talking, aes(colour = speaker)) +
  geom_point(data=mapping, aes(x=x, y=y), size=10, inherit.aes = FALSE) +
  geom_text(data=mapping, aes(x=x, y=y, label=as.character(person)), 
    inherit.aes = FALSE, color="blue") +
  ylim(-.2, 1.2) + xlim(-.2, 1.2) + 
  geom_rect(data=the_table, aes(xmax = xmax, xmin=xmin, 
      ymin=ymin, ymax = ymax), fill="gray80", inherit.aes = FALSE) +
  speakerCol
 oopt <- ani.options(interval = 0.5)

# a function to create the animation


pp <- function(){
  print(base)
  interval = ani.options("interval")
  for(n in rep(seq_along(talking$duration), each = talking$duration))){
    # a segment for each row
    tn <- geom_segment(aes(x= speaker.x, y= speaker.y, xend = receiver.x, yend = receiver.y), arrow = arrow(), 
                       data =talking[n, ,drop = FALSE])
    print(base + tn)
    ani.pause()
  }
} saveGIF(pp(), interval = 0.1)
-------------------------------------------------------------------------------------------------------
library(grid)

myplot <- function(){

  pushViewport(viewport(x=0.5,width=1, just=0.5))
  grid.rect(gp=gpar(fill=grey(runif(1, 0.2, 0.8))))
  grid.points()
  popViewport()

}

p1 <- grid.grabExpr(myplot())
p2 <- grid.grabExpr(myplot())

library(gridExtra)

grid.arrange(p1, p2, ncol=2)
-------------------------------------------------------------------------------------------------------
library(ggplot2)

str(myrf)
str(myrf$importance)
data <- as.data.frame(cbind(rownames(myrf$importance),round(myrf$importance[,"IncNodePurity"],1)))
colnames(data) <- c("Parameters","IncNodePurity")
data$IncNodePurity <- as.numeric(as.character(data$IncNodePurity)) (p <- ggplot(data) + geom_point(aes(IncNodePurity,Parameters))) (p1 <- p+ theme(axis.text.y = element_text(angle = 90, hjust = 1))) (p2 <- p1 +  scale_x_continuous(limits=c(3,7),breaks=3:7) + theme(axis.title.y = element_blank())) (p3 <- p2+ theme(panel.grid.major.x = element_blank(),
panel.grid.minor.x = element_blank(),
panel.grid.minor.y = element_blank(),
panel.grid.major.y = element_line(colour = 'gray', linetype = 'dashed'),
panel.background = element_rect(fill='white', colour='black'))) ggsave("randomforestplot.pdf",p2) ggsave("randomforestplot.png",p2)

p2 p3
-------------------------------------------------------------------------------------------------------
ggplot(glomor, aes(x=Time.Period, y=Score, group=Variable, shape=Variable,     
                   color=Variable, width=0.5)) +
geom_point() +
scale_x_discrete(limits = c("Jan 1997 - Aug 2003",
     "Sep 2003 - Jun 2005","Jul 2005 - Dec 2009"), expand=c(0.2, 0)) +
geom_line(aes(linetype=Variable), size=1.3) +
geom_point(size=4.4) +
scale_shape_discrete(name="", labels=c("Significant Z-Score", "Moran's I Z-Score")) +
scale_linetype_manual(values=c(1, 3), name="", 
                      labels=c("Significant Z-Score", "Moran's I Z-Score"))   +
scale_color_manual(values=c("black", "grey40"), name="",
                   labels=c("Significant Z-Score", "Moran's I Z-Score")) +
scale_fill_discrete(name="", labels=c("Significant Z-Score", "Moran's I Z-Score")) +
theme_classic()+
ylim(0,10) +
xlab("Time Periods") +
ylab("Moran's I Z-Score") +
theme(axis.text.x=element_text(size=11)) +
theme(axis.title.x=element_text(size=14, face="bold")) +
theme(axis.title.y=element_text(size=14, face="bold")) +
theme(legend.position=c(.80, .90)) +
theme(legend.text=element_text(size=12)) +
theme(legend.background = element_rect(fill="white", linetype="dashed")) +
theme(legend.key = element_blank())
-------------------------------------------------------------------------------------------------------
ggplot environment = environment() ggplot(mydf, aes(Description, fill = type), environment = environment()) + 
    geom_rect(aes(x = Description, xmin = id - 0.45, xmax = id + 0.45, ymin = end, ymax = start)) + 
    scale_y_continuous(labels = formatter) +
    scale_x_discrete("", breaks = levels(mydf$Description), labels = strwr(levels(mydf$Description))) +
    geom_text(aes(x = id, y = end, label = formatter(change)), vjust = 1, size = 3) scales formatter plotIt() formatter Error in eval(expr, envir, enclos) : could not find function "formatter" base eval() envir parent.frame() environment() <environment: R_GlobalEnv> eval()
-------------------------------------------------------------------------------------------------------
df<-data.frame(nam=rep(c("A","B","C","D","E"),times=3),
  val=runif(15,0,1),type=rep(c("TypA","TypB","TypC"),each=5))
df<-rbind(df,df,df)
df$num.lev<-rep(c(10,20,30),each=15) panel.grid.major panel.grid.minor theme() panel.margin= library(ggplot2)
library(grid)
ggplot(df,aes(val,nam))+geom_point(size=3,colour="blue")+facet_grid(num.lev~type)+
  scale_x_continuous(breaks=c(0,0.2,0.4,0.6,0.8))+
  theme(panel.margin=unit(0,"cm"),
        panel.border=element_rect(colour="black",fill=NA,size=1.2),
        strip.background=element_rect(colour="black",size=1.2),
        panel.grid.major.x=element_blank(),
        panel.grid.minor.x=element_blank(),
        panel.grid.major.y=element_line(size=1.5,colour="grey88"),
        panel.background=element_rect(fill="white"))
-------------------------------------------------------------------------------------------------------
viewports library(grid)
grid.newpage()
for (x in 0:3){
  vp <- plotViewport(c(10-x,1+3*x,1+2*x,5-x),
                     xscale=c(0,10),yscale=c(0,10),
                     gp=gpar(alpha=1))
  pushViewport(vp)
  ## here I plot some rectangle since I don't have any data
  grid.rect(x=seq(0.5,10,length.out=20),y=0,width=0.5,height=0.5,
            def='native', just='bottom',
            gp=gpar(fill=grey.colors(4)[4-x+1],alpha=0.5))
  ## axes
  grid.lines(def='native',x=c(0,10),y=0,arrow=arrow())
  grid.lines(def='native',y=c(0,10),x=0,arrow=arrow())
  upViewport()
}
-------------------------------------------------------------------------------------------------------
grid.rect viewport pushViewport(plotViewport(c(5,5,5,5)))
grid.rect()
grid.rect(width=unit(1, "npc")-unit(0.5,'lines'),
          height=unit(1, "npc")-unit(0.5,'lines'))
pushViewport(plotViewport(c(1,1,1,1),
                      layout = grid.layout(4, 2, 
                                           heights =     unit(c(1,5,5,5), "null")))) 
grid.text("Summer Clear Day- August 2, 2012", 
          vp = viewport(layout.pos.row = 1, layout.pos.col = 1:2))
k1 <- ggplot(mtcars, aes(factor(cyl), mpg))  + geom_boxplot()

print(k1, vp = viewport(layout.pos.row = 2, layout.pos.col = 1))
print(k1, vp = viewport(layout.pos.row = 2, layout.pos.col = 2))
print(k1, vp = viewport(layout.pos.row = 3, layout.pos.col = 1))
print(k1, vp = viewport(layout.pos.row = 3, layout.pos.col = 2))
print(k1, vp = viewport(layout.pos.row = 4, layout.pos.col = 1))
print(k1, vp = viewport(layout.pos.row = 4, layout.pos.col = 2))
upViewport(2)
-------------------------------------------------------------------------------------------------------
legend plot(1)
# legend 1
l1 <- legend(
  "topleft"
  , legend=c(expression(q[c] == 0.00 ~ ";" ~ beta == 0)
    , expression(q[c] == 0.05 ~ ";" ~ beta == 2)
    , expression(q[c] == 0.10 ~ ";" ~ beta == 10)
    , expression(q[c] == 0.20 ~ ";" ~ beta == 10)
    , expression(q[c] == 0.40 ~ ";" ~ beta == 10)),
  title = expression(bold("Long:" ~ (w==10^2 ~ ";" ~ h==10^5))),
  , col=c( 1, 2, 3, 4, 5)
  , lty=c(1, 1, 1, 1, 1)
  , cex=.65,
   bty='n')
# legend 2, placed directly below legend 1
l2 <- legend(x = l1$rect$left, y = with(l1$rect, top - h),
             legend =c(expression(q[c] == 0.00 ~ ";" ~ beta == 0)
                       , expression(q[c] == 0.05 ~ ";" ~ beta == 2)
                       , expression(q[c] == 0.10 ~ ";" ~ beta == 10)
                       , expression(q[c] == 0.20 ~ ";" ~ beta == 10)
                       , expression(q[c] == 0.40 ~ ";" ~ beta == 10)),
             title = expression(bold("Wide:" ~ (w==10^3 ~ ";" ~ h==10^3))),
              col=c( 1, 2, 3, 4, 5)
             , lty=c(  2, 2, 2, 2, 2)
             , cex=.65,
             bty='n')
# add the rectangle around the legend
rect(xleft = l1$rect$left, ybottom = with(l2$rect, top - h), 
     xright = l1$rect$left + max(l1$rect$w, l1$rect$w), ytop = l1$rect$top)
-------------------------------------------------------------------------------------------------------
aggregate geom_point data.frame nutm <- aggregate( Nitrate ~ Date + Hydrology , data = nut , FUN = mean )

p <-ggplot(nut, aes(Date, Nitrate, shape = Hydrology)) +
  geom_point( data = nut , aes( fill = Wetland , group=Wetland ), colour="black", size=4)+
  scale_fill_manual(values=colvec) +
  scale_shape_manual(values=c(21,22))+
  facet_grid(. ~ Hydrology) +
  ylab ("Nitrate (mg/L) ") +
  geom_point( data = nutm , aes( x = Date , y = Nitrate) , color = "red" , fill = "red" , size = 4 ) +
  theme(legend.position="none",
        panel.background = element_rect(fill='white', colour='white'), 
        panel.grid = element_line(color = NA),
        panel.grid.minor = element_line(color = NA),
        panel.border = element_rect(fill = NA, color = "black"),
        axis.text.x  = element_text(size=10, colour="black"),  
        axis.title.x = element_text(vjust=0.1),
        axis.text.y = element_text(size=12, colour="black"),
        axis.title.y = element_text(vjust=0.3))

p
-------------------------------------------------------------------------------------------------------
library(grid)
library(lubridate)
library(plyr) set.seed(1)

#############################################
# User settings for the data generation.    #
#############################################

# Set number of hours to generate data for.
time_Periods <- 100

# Set starting datetime in m/d/yyyy hh:mm format.
start_Datetime <- "2/24/2013 00:00"

# Specify a list of websites along with a
# Poisson lambda to represent the average
# number of hits in a given time period.
df_Websites <- read.table(text="
url lambda
http://www.asitenoonereallyvisits.com 1
http://www.asitesomepeoplevisit.com 10
http://www.asitesomemorepeoplevisit.com 20
http://www.asiteevenmorepeoplevisit.com 40
http://www.asiteeveryonevisits.com 80
", header=TRUE, sep=" ")

#############################################
# Generate the data.                        #
#############################################

# Initialize lists to hold hit data and
# website names.
hits <- list()
websites <- list()

# For each time period and for each website,
# flip a coin to see if any visitors come.  If
# visitors come, use a Poisson distribution to
# see how many come.
# Also initialize the list of website names.
for (i in 1:nrow(df_Websites)){
    hits[[i]] <- rbinom(time_Periods, 1, 0.5) * rpois(time_Periods, df_Websites$lambda[i])
    websites[[i]] <- rep(df_Websites$url[i], time_Periods)
}

# Initialize list of time periods.
datetimes <- mdy_hm(start_Datetime) + hours(1:time_Periods)

# Tie the data into a data frame and erase rows with no hits.
# This is what the real data is more likely to look like
# after import and cleaning.
df_Hits <- data.frame(datetime=rep(datetimes, nrow(df_Websites)), hits=unlist(hits), website=unlist(websites))
df_Hits <- df_Hits[df_Hits$hits > 0,]

# Clean up data-generation variables.
rm(list=ls()[ls()!="df_Hits"]) unit(1, "lines") #############################################
# User settings for the graphic.            #
#############################################

# Specify the window width and height and
# pixels per inch.
device_Width=12
device_Height=4.5
pixels_Per_Inch <- 100

# Specify the bin width (in hours) of the
# upper histogram.
bin_Width <- 2

# Specify a padding size for separating text
# from other plot elements.
padding <- unit(1, "strwidth", "W")

# Specify the bin cut-off values for the hit
# counts and the corresponding colors.  The
# cutoff should be the maximum value to be
# contained in the bin.
bin_Settings <- read.table(text="
cutoff color
10 'darkblue'
20 'deepskyblue'
40 'purple'
80 'magenta'
160 'red'
", header=TRUE, sep=" ")

# Specify the size of the histogram plots 
# in 'grid' units.  Override only if necessary.
# histogram_Size <- unit(6, "lines")
histogram_Size <- unit(nrow(bin_Settings) + 1, "lines")

# Set the background color for distinguishing
# between rows of data.
row_Background <- "gray90"

# Set the color for the date lines.
date_Color <- "gray40"

# Set the color for marker lines on histograms.
marker_Color <- "gray80"

# Set the fontsize for labels.
label_Size <- 10 #############################################
# Make the graphic.                         #
#############################################

# Make sure bin cutoffs are in increasing order.
# This way, we can make assumptions later.
bin_Settings <- bin_Settings[order(bin_Settings$cutoff),]

# Initialize plot window.
# Make sure you always specify the pixels per
# inch, so you have an appropriately scaled
# graphic for output.
windows(
    width=device_Width,
    height=device_Height,
    xpinch=pixels_Per_Inch,
    ypinch=pixels_Per_Inch)
grid.newpage()

# Push an initial viewport, so we can set the
# font size to use in calculating label widths.
pushViewport(viewport(gp=gpar(fontsize=label_Size)))

# Find the list of websites in the data.
unique_Urls <- as.character(unique(df_Hits$website))

# Calculate the width of the website
# urls once printed on the screen.
label_Width <- list()
for (i in 1:length(unique_Urls)){
    label_Width[[i]] <- convertWidth(unit(1, "strwidth", unique_Urls[i]), "npc")
}
# Use the maximum url width plus two padding.
x_Label_Margin <- unit(max(unlist(label_Width)), "npc") + padding * 2

# Calculate a height for the date labels plus two padding.
y_Label_Margin <- unit(1, "strwidth", "99/99/9999") + padding * 2

# Calculate size of main plot after making
# room for histogram and label margins.
main_Width <- unit(1, "npc") - histogram_Size - x_Label_Margin
main_Height <- unit(1, "npc") - histogram_Size - y_Label_Margin

# Calculate x values, using the minimum datetime
# as zero, and counting the hours between each
# datetime and the minimum.
x_Values <- as.integer((df_Hits$datetime - min(df_Hits$datetime)))/60^2

# Initialize main plotting area
pushViewport(viewport(
    x=x_Label_Margin,
    y=y_Label_Margin,
    width=main_Width,
    height=main_Height,
    xscale=c(-1, max(x_Values) + 1),
    yscale=c(0, length(unique_Urls) + 1),
    just=c("left", "bottom"),
    gp=gpar(fontsize=label_Size)))

# Put grey background behind every other website
# to make data easier to read, and write urls as
# y-labels.
for (i in 1:length(unique_Urls)){
    if (i%%2==0){
        grid.rect(
            x=unit(-1, "npc"),
            y=i,
            width=unit(2, "npc"),
            height=1,
            default.units="native",
            just=c("left", "center"),
            gp=gpar(col=row_Background, fill=row_Background))
    }

    grid.text(
        unique_Urls[i],
        x=unit(0, "npc") - padding,
        y=i,
        default.units="native",
        just=c("right", "center"))
}

# Find the hour offset of the minimum date value.
time_Offset <- as.integer(format(min(df_Hits$datetime), "%H"))

# Find the dates in the data.
x_Labels <- unique(format(df_Hits$datetime, "%m/%d/%Y"))

# Find where the days begin in the data.
midnight_Locations <- (0:max(x_Values))[(0:max(x_Values)+time_Offset)%%24==0]

# Write the appropriate date labels on the x-axis
# where the days begin.
grid.text(
    x_Labels,
    x=midnight_Locations,
    y=unit(0, "npc") - padding,
    default.units="native",
    just=c("right", "center"),
    rot=90)

# Draw lines to vertically mark when days begin.
grid.polyline(
    x=c(midnight_Locations, midnight_Locations),
    y=unit(c(rep(0, length(midnight_Locations)), rep(1, length(midnight_Locations))), "npc"),
    default.units="native",
    id=rep(midnight_Locations, 2),
    gp=gpar(lty=2, col=date_Color))

# Initialize bin assignment variable.
bin_Assignment <- 1

# Calculate which bin each hit value belongs in.
for (i in 1:nrow(bin_Settings)){
    bin_Assignment <- bin_Assignment + ifelse(df_Hits$hits>bin_Settings$cutoff[i], 1, 0)
}

# Draw points, coloring according to the bin settings.
grid.points(
    x=x_Values,
    y=match(df_Hits$website, unique_Urls),
    pch=19,
    size=unit(1, "native"),
    gp=gpar(col=as.character(bin_Settings$color[bin_Assignment]), alpha=0.5))

# Finalize the main plotting area.
popViewport()

# Create the bins for the upper histogram.
bins <- ddply(
    data.frame(df_Hits, bin_Assignment, mid=floor(x_Values/bin_Width)*bin_Width+bin_Width/2),
    .(bin_Assignment, mid),
    summarize,
    freq=length(hits))

# Initialize upper histogram area
pushViewport(viewport(
    x=x_Label_Margin,
    y=y_Label_Margin + main_Height,
    width=main_Width,
    height=histogram_Size,
    xscale=c(-1, max(x_Values) + 1),
    yscale=c(0, max(bins$freq) * 1.05),
    just=c("left", "bottom"),
    gp=gpar(fontsize=label_Size)))


# Calculate where to put four value markers.
marker_Interval <- floor(max(bins$freq)/4)
digits <- nchar(marker_Interval)
marker_Interval <- round(marker_Interval, -digits+1)

# Draw horizontal lines to mark values.
grid.polyline(
    x=unit(c(rep(0,4), rep(1,4)), "npc"),
    y=c(1:4 * marker_Interval, 1:4 * marker_Interval),
    default.units="native",
    id=rep(1:4, 2),
    gp=gpar(lty=2, col=marker_Color))

# Write value labels for each marker.
grid.text(
    1:4 * marker_Interval,
    x=unit(0, "npc") - padding,
    y=1:4 * marker_Interval,
    default.units="native",
    just=c("right", "center"))

# Finalize upper histogram area, so we
# can turn it back on but with clipping.
popViewport()

# Initialize upper histogram area again,
# but with clipping turned on.
pushViewport(viewport(
    x=x_Label_Margin,
    y=y_Label_Margin + main_Height,
    width=main_Width,
    height=histogram_Size,
    xscale=c(-1, max(x_Values) + 1),
    yscale=c(0, max(bins$freq) * 1.05),
    just=c("left", "bottom"),
    gp=gpar(fontsize=label_Size),
    clip="on"))

# Draw bars for each bin.
for (i in 1:nrow(bin_Settings)){
    active_Bin <- bins[bins$bin_Assignment==i,]
    if (nrow(active_Bin)>0){
        for (j in 1:nrow(active_Bin)){
            grid.rect(
                x=active_Bin$mid[j],
                y=0,
                width=bin_Width,
                height=active_Bin$freq[j],
                default.units="native",
                just=c("center","bottom"),
                gp=gpar(col=as.character(bin_Settings$color[i]), fill=as.character(bin_Settings$color[i]), alpha=1/nrow(bin_Settings)))
        }
    }
}

# Draw x-axis.
grid.lines(x=unit(c(0, 1), "npc"), y=0, default.units="native")

# Finalize upper histogram area.
popViewport()

# Calculate the frequencies for each website and bin.
freq_Data <- ddply(
    data.frame(df_Hits, bin_Assignment),
    .(website, bin_Assignment),
    summarize,
    freq=length(hits))

# Create the line data for the side histogram.
line_Data <- matrix(0, nrow=length(unique_Urls)+2, ncol=nrow(bin_Settings))
for (i in 1:nrow(freq_Data)){
    line_Data[match(freq_Data$website[i], unique_Urls)+1,freq_Data$bin_Assignment[i]] <- freq_Data$freq[i]
}


# Initialize side histogram area
pushViewport(viewport(
    x=x_Label_Margin + main_Width,
    y=y_Label_Margin,
    width=histogram_Size,
    height=main_Height,
    xscale=c(0, max(line_Data) * 1.05),
    yscale=c(0, length(unique_Urls) + 1),
    just=c("left", "bottom"),
    gp=gpar(fontsize=label_Size)))

# Calculate where to put four value markers.
marker_Interval <- floor(max(line_Data)/4)
digits <- nchar(marker_Interval)
marker_Interval <- round(marker_Interval, -digits+1)

# Draw vertical lines to mark values.
grid.polyline(
    x=c(1:4 * marker_Interval, 1:4 * marker_Interval),
    y=unit(c(rep(0,4), rep(1,4)), "npc"),
    default.units="native",
    id=rep(1:4, 2),
    gp=gpar(lty=2, col=marker_Color))

# Write value labels for each marker.
grid.text(
    1:4 * marker_Interval,
    x=1:4 * marker_Interval,
    y=unit(0, "npc") - padding,
    default.units="native",
    just=c("center", "top"))

# Draw lines for each bin setting.
grid.polyline(
    x=array(line_Data),
    y=rep(0:(length(unique_Urls)+1), nrow(bin_Settings)),
    default.units="native",
    id=array(t(matrix(1:nrow(bin_Settings), nrow=nrow(bin_Settings), ncol=length(unique_Urls)+2))),
    gp=gpar(col=as.character(bin_Settings$color)))

# Draw vertical line for the y-axis.
grid.lines(x=0, y=c(0, length(unique_Urls)+1), default.units="native")

# Finalize side histogram area.
popViewport()

# Draw legend.
# Draw box behind legend headers.
grid.rect(
    x=0,
    y=1,
    width=unit(1, "strwidth", names(bin_Settings)[1]) + unit(1, "strwidth", names(bin_Settings)[2]) + 3 * padding,
    height=unit(1, "lines"),
    default.units="npc",
    just=c("left","top"),
    gp=gpar(col=row_Background, fill=row_Background))

# Draw legend headers from bin_Settings variable.
grid.text(
    names(bin_Settings)[1],
    x=padding,
    y=1,
    default.units="npc",
    just=c("left","top"))

grid.text(
    names(bin_Settings)[2],
    x=unit(1, "strwidth", names(bin_Settings)[1]) + 2 * padding,
    y=1,
    default.units="npc",
    just=c("left","top"))

# For each row in the bin_Settings variable,
# write the cutoff values and the color associated.
# Write the color name in the color it specifies.
for (i in 1:nrow(bin_Settings)){
    grid.text(
        bin_Settings$cutoff[i],
        x=unit(1, "strwidth", names(bin_Settings)[1]) + padding,
        y=unit(1, "npc") - i * unit(1, "lines"),
        default.units="npc",
        just=c("right","top"))

    grid.text(
        bin_Settings$color[i],
        x=unit(1, "strwidth", names(bin_Settings)[1]) + 2 * padding,
        y=unit(1, "npc") - i * unit(1, "lines"),
        default.units="npc",
        just=c("left","top"),
        gp=gpar(col=as.character(bin_Settings$color[i])))
}
-------------------------------------------------------------------------------------------------------
require(xts)

X.stock.rtns <- xts(rnorm(1000,0.00001,0.0003), Sys.Date()-(1000:1))
Y.stock.rtns <- xts(rnorm(1000,0.00003,0.0004), Sys.Date()-(1000:1))
Z.stock.rtns <- xts(rnorm(1000,0.00005,0.0005), Sys.Date()-(1000:1))
rtn.obj <- merge(X.stock.rtns , Y.stock.rtns, Z.stock.rtns)
colnames(rtn.obj) <- c("x","y","z")

# advanced charts.PerforanceSummary based on ggplot
gg.charts.PerformanceSummary <- function(rtn.obj, geometric = TRUE, main = "", plot = TRUE)
  {

    # load libraries
    suppressPackageStartupMessages(require(ggplot2))
    suppressPackageStartupMessages(require(scales))
    suppressPackageStartupMessages(require(reshape))
    suppressPackageStartupMessages(require(PerformanceAnalytics))

    # create function to clean returns if having NAs in data
    clean.rtn.xts <- function(univ.rtn.xts.obj,na.replace=0){
    univ.rtn.xts.obj[is.na(univ.rtn.xts.obj)]<- na.replace
    univ.rtn.xts.obj  
  }

    # Create cumulative return function
    cum.rtn <- function(clean.xts.obj, g = TRUE)
    {
      x <- clean.xts.obj
      if(g == TRUE){y <- cumprod(x+1)-1} else {y <- cumsum(x)}
      y
    }

    # Create function to calculate drawdowns
    dd.xts <- function(clean.xts.obj, g = TRUE)
    {
      x <- clean.xts.obj
      if(g == TRUE){y <- Drawdowns(x)} else {y <- Drawdowns(x,geometric = FALSE)}
      y
    }

    # create a function to create a dataframe to be usable in ggplot to replicate charts.PerformanceSummary
    cps.df <- function(xts.obj,geometric)
    {
      x <- clean.rtn.xts(xts.obj)
      series.name <- colnames(xts.obj)[1]
      tmp <- cum.rtn(x,geometric)
      tmp$rtn <- x
      tmp$dd <- dd.xts(x,geometric)
      colnames(tmp) <- c("Index","Return","Drawdown") # names with space
      tmp.df <- as.data.frame(coredata(tmp))
      tmp.df$Date <- as.POSIXct(index(tmp))
      tmp.df.long <- melt(tmp.df,id.var="Date")
      tmp.df.long$asset <- rep(series.name,nrow(tmp.df.long))
      tmp.df.long
    }

    # A conditional statement altering the plot according to the number of assets
    if(ncol(rtn.obj)==1)
    {
      # using the cps.df function
      df <- cps.df(rtn.obj,geometric)
      # adding in a title string if need be
      if(main == ""){
        title.string <- paste("Asset Performance")
      } else {
        title.string <- main
      }

    gg.xts <- ggplot(df, aes_string( x = "Date", y = "value", group = "variable" )) +
      facet_grid(variable ~ ., scales = "free_y", space = "fixed") +
      geom_line(data = subset(df, variable == "Index")) +
      geom_bar(data = subset(df, variable == "Return"), stat = "identity") +
      geom_line(data = subset(df, variable == "Drawdown")) +
      geom_hline(yintercept = 0, size = 0.5, colour = "black") +
      ggtitle(title.string) +
      theme(axis.text.x = element_text(angle = 0, hjust = 1)) +
      scale_x_datetime(breaks = date_breaks("6 months"), labels = date_format("%m/%Y")) +
      ylab("") +
      xlab("")

  } 
 else 
  {
    # a few extra bits to deal with the added rtn columns
    no.of.assets <- ncol(rtn.obj)
    asset.names <- colnames(rtn.obj)
    df <- do.call(rbind,lapply(1:no.of.assets, function(x){cps.df(rtn.obj[,x],geometric)}))
    df$asset <- ordered(df$asset, levels=asset.names)
    if(main == ""){
      title.string <- paste("Asset",asset.names[1],asset.names[2],asset.names[3],"Performance")
    } else {
      title.string <- main
    }

    if(no.of.assets>5){legend.rows <- 5} else {legend.rows <- no.of.assets}

      gg.xts <- ggplot(df, aes_string(x = "Date", y = "value" )) +

      # panel layout
      facet_grid(variable~., scales = "free_y", space = "fixed", shrink = TRUE, drop = TRUE, margin = 
                 , labeller = label_value) + # label_value is default

      # display points for Index and Drawdown, but not for Return
      geom_point(data = subset(df, variable == c("Index","Drawdown"))
                 , aes(colour = factor(asset), shape = factor(asset)), size = 1.2, show_guide = TRUE) + 

      # manually select shape of geom_point
      scale_shape_manual(values = c(1,2,3)) + 

      # line colours for the Index
      geom_line(data = subset(df, variable == "Index"), aes(colour = factor(asset)), show_guide = FALSE) +

      # bar colours for the Return
      geom_bar(data = subset(df,variable == "Return"), stat = "identity"
           , aes(fill = factor(asset), colour = factor(asset)), position = "dodge", show_guide = FALSE) +

      # line colours for the Drawdown
      geom_line(data = subset(df, variable == "Drawdown"), aes(colour = factor(asset)), show_guide = FALSE) +

      # horizontal line to indicate zero values
      geom_hline(yintercept = 0, size = 0.5, colour = "black") +

      # horizontal ticks
      scale_x_datetime(breaks = date_breaks("6 months"), labels = date_format("%m/%Y")) +

      # main y-axis title
      ylab("") +

      # main x-axis title
      xlab("") +

      # main chart title
      ggtitle(title.string)

      # legend 

      gglegend <- guide_legend(override.aes = list(size = 3))

      gg.xts <- gg.xts + guides(colour = gglegend, size = "none") +

      # gglegend <- guide_legend(override.aes = list(size = 3), direction = "horizontal") # direction overwritten by legend.box?
      # gg.xts <- gg.xts + guides(colour = gglegend, size = "none", shape = gglegend) + # Warning: "Duplicated override.aes is ignored"

      theme( legend.title = element_blank()
             , legend.position = c(0,1)
             , legend.justification = c(0,1)
             , legend.background = element_rect()
             , legend.box = "horizontal" # not working?
             , axis.text.x = element_text(angle = 0, hjust = 1)
            )

}

assign("gg.xts", gg.xts,envir=.GlobalEnv)
if(plot == TRUE){
    plot(gg.xts)
} else {}

}

# display chart
gg.charts.PerformanceSummary(rtn.obj, geometric = TRUE) # create a function to store fancy axis labels 

    my_labeller <- function(var, value){ # from the R Cookbook
        value <- as.character(value)
        if (var=="variable") 
        {
              value[value=="Index"] <- "Cumulative Returns"
              value[value=="Return"] <- "Daily Returns"
              value[value=="Drawdown"] <- "Drawdown"
        }
        return(value)
    } theme( legend.title = element_blank()
         , legend.position = c(0,1)
         , legend.justification = c(0,1)
         , legend.background = element_rect()
         #, legend.key = element_rect(fill="white",colour="white")# added as afterthought
         , legend.box = "horizontal" # not working?
         , axis.text.x = element_text(angle = 0, hjust = 1)
         #, axis.title.y = element_text(size=2,colour="black")
         , strip.background = element_rect(fill = 'white')
         , panel.background = element_rect(fill = 'white', colour = 'white')
         , panel.grid.major = element_line(colour = "grey", size = 0.5) 
         , panel.grid.minor = element_line(colour = NA, size = 0.0)
        )
-------------------------------------------------------------------------------------------------------
# > ret
#       x       y xmin xmax ymin ymax
# 1 test1 success    0    3    0    1
# 2 test2 success    0    3    1    2
# 3 test3 failure    3    6    0    1
# 4 test4 success    3    6    1    2 ggplot(ret, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax)) + 
          geom_rect(colour="white", alpha = 0.5, aes(fill=y)) + 
          scale_fill_manual(values=c("red", "green"), guide=FALSE) + 
          geom_text(aes(x=(xmin+xmax)/2, y=(ymin+ymax)/2, label=x)) + 
          theme_bw() + theme(axis.text.y = element_blank(), 
          axis.text.x = element_blank(), axis.ticks.x = element_blank(), 
          axis.ticks.y = element_blank(), panel.grid.major.x = element_blank(), 
          panel.grid.major.y = element_blank(), panel.grid.minor.x = element_blank(), 
          panel.grid.minor.y = element_blank()) + xlab("") + ylab("") + 
          ggtitle("My tests")
-------------------------------------------------------------------------------------------------------
wp <- structure(list(M.1990 = c(325814, 295272, 269351, 265163, 249651, 220027, 196523, 178295, 141789, 115097, 106579, 91763, 77150, 56845, 38053, 25716, 19442), M.2000 = c(319675, 317296, 317072, 290827, 262992, 256378, 241401, 212924, 188905, 169133, 131813, 103162, 90921, 72231, 53449, 32707, 25868), M.2010 = c(328759, 315119, 311456, 312831, 311077, 284258, 255596, 248575, 232217, 202633, 176241, 153494, 114194, 83129, 65266, 43761, 39223), F.1990 = c(308121, 281322, 257432, 254065, 238856, 211943, 188433, 170937, 138358, 112931, 106510, 93425, 82667, 67057, 47679, 37435, 36724), F.2000 = c(298455, 297012, 299757, 277706, 252924, 248127, 233583, 207518, 183646, 165444, 132307, 105429, 96681, 80227, 64956, 45832, 46413), F.2010 = c(307079, 293664, 290598, 293313, 295739, 273379, 247383, 241938, 226914, 201142, 176440, 156283, 121200, 92071, 77990, 56895, 66029)), .Names = c("M.1990", "M.2000", "M.2010", "F.1990", "F.2000", "F.2010"), row.names = c("0-4", "5-9", "10-14", "15-19", "20-24", "25-29", "30-34", "35-39", "40-44", "45-49", "50-54", "55-59", "60-64", "65-69", "70-74", "75-79", "80+"), class = "data.frame")

wp
      M.1990 M.2000 M.2010 F.1990 F.2000 F.2010
0-4   325814 319675 328759 308121 298455 307079
5-9   295272 317296 315119 281322 297012 293664
10-14 269351 317072 311456 257432 299757 290598
15-19 265163 290827 312831 254065 277706 293313
20-24 249651 262992 311077 238856 252924 295739
25-29 220027 256378 284258 211943 248127 273379
30-34 196523 241401 255596 188433 233583 247383
35-39 178295 212924 248575 170937 207518 241938
40-44 141789 188905 232217 138358 183646 226914
45-49 115097 169133 202633 112931 165444 201142
50-54 106579 131813 176241 106510 132307 176440
55-59  91763 103162 153494  93425 105429 156283
60-64  77150  90921 114194  82667  96681 121200
65-69  56845  72231  83129  67057  80227  92071
70-74  38053  53449  65266  47679  64956  77990
75-79  25716  32707  43761  37435  45832  56895
80+    19442  25868  39223  36724  46413  66029

xrange <- range(c(0,wp))
yrange <- range(c(0,nrow(wp))) par(mfcol=c(1,2))
par(mar=c(5,4,4,0))
plot(NA,type="n", main="Men", xlab="", ylab="", xaxs="i", 
     xlim=rev(xrange), ylim=yrange, axes=FALSE, yaxs="i")
rect(xrange[1],yrange[1],xrange[2],yrange[2], col="cadetblue")
abline(v=seq(0,xrange[2],by=1e5), col="white")
# All years with bars you want to represent filled 
# should be entered in reverse order
polygon(c(0,rep(wp$M.2000,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)),
        col="lightblue",border="lightblue")
polygon(c(0,rep(wp$M.1990,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)), 
        col="darkblue",border="darkblue")
# And those you want with just a border, afterwards:
polygon(c(0,rep(wp$M.2010,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)), 
        col=NA,border="darkred",lwd=2)
axis(1, at=c(0,1e5,2e5,3e5), labels=format(c(0,1e5,2e5,3e5),scientific=FALSE))
axis(2, at=1:nrow(wp)-0.5,labels=row.names(wp),las=2)
box()

par(mar=c(5,0,4,4))
plot(NA,type="n", main="Women", xlab="", ylab="", xaxs="i", 
     xlim=xrange, ylim=yrange, axes=FALSE, yaxs="i")
rect(xrange[1],yrange[1],xrange[2],yrange[2], col="cadetblue")
abline(v=seq(0,xrange[2],by=1e5), col="white")
polygon(c(0,rep(wp$F.2000,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)),
        col="lightblue",border="lightblue")
polygon(c(0,rep(wp$F.1990,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)), 
        col="darkblue",border="darkblue")
polygon(c(0,rep(wp$F.2010,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)), 
        col=NA,border="darkred",lwd=2)
axis(1, at=c(0,1e5,2e5,3e5), labels=format(c(0,1e5,2e5,3e5),scientific=FALSE))
axis(4, at=1:nrow(wp)-0.5,labels=row.names(wp),las=2)
box() library(scales)
[...]
polygon(c(0,rep(wp$M.1990,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)), 
        col=alpha("darkblue",0.4),border="darkblue")
[...]
polygon(c(0,rep(wp$F.1990,each=2), 0), c(0,0,rep(1:nrow(wp),each=2)), 
        col=alpha("darkblue",0.4),border="darkblue")
[...]
-------------------------------------------------------------------------------------------------------
tmp <- tapply( iris$Petal.Length, iris$Species, function(x) hist(x, plot=FALSE) )

plot.new()
tmp.r <- do.call( range, lapply(tmp, `[[`, 'breaks') )
plot.window(xlim=c(1/2,length(tmp)+1/2), ylim=tmp.r)
abline(v=seq_along(tmp))

for( i in seq_along(tmp) ) {
    h <- tmp[[i]]
    rf <- h$counts/sum(h$counts)
    rect( i-rf/2, head(h$breaks, -1), i+rf/2, tail(h$breaks, -1) )
}

axis(1, at=seq_along(tmp), labels=names(tmp))
axis(2)
box()
-------------------------------------------------------------------------------------------------------
hist breaks histogram panel.hanoi bwplot(crime.v ~ bias, data=df30, panel=panel.hanoi) bwplot(crime.v ~ bias, data=df, ylim=c(-1,1), pch="|", coef=0, panel=function(...){panel.hanoi(col="pink", breaks=cv.ints, ...); panel.bwplot(...)}) ylim pch coef cv.ints <- c(-1.000000000, -0.960000012, -0.822307704, -0.684615396, -0.546923088, -0.409230781, -0.271538473, -0.133846165, 0.003846142, 0.141538450, 0.279230758, 0.416923065, 0.554615373, 0.692307681, 0.829999988, 0.967692296, 1.000000000) panel.hanoi <- function(x, y, horizontal, breaks="Sturges", ...) {  # "Sturges" is hist()'s default

  if (horizontal) {
    condvar <- y # conditioning ("independent") variable
    datavar <- x # data ("dependent") variable
  } else {
    condvar <- x
    datavar <- y
  }

  conds <- sort(unique(condvar))

  # loop through the possible values of the conditioning variable
  for (i in seq_along(conds)) {

      h <- hist(datavar[condvar == conds[i]], plot=F, breaks) # use base hist(ogram) function to extract some information

    # strip outer counts == 0, and corresponding bins
    brks.cnts <- stripOuterZeros(h$breaks, h$counts)
    brks <- brks.cnts[[1]]
    cnts <- brks.cnts[[2]]

    halfrelfs <- (cnts/sum(cnts))/2  # i.e. half of the relative frequency
    center <- i

    # All of the variables passed to panel.rec will usually be vectors, and panel.rect will therefore make multiple rectangles.
    if (horizontal) {
      panel.rect(head(brks, -1), center - halfrelfs, tail(brks, -1), center + halfrelfs, ...)
    } else {
      panel.rect(center - halfrelfs, head(brks, -1), center + halfrelfs, tail(brks, -1), ...)
    }
  }
}

# function to strip counts that are all zero on ends of data, along with the corresponding breaks
stripOuterZeros <- function(brks, cnts) { do.call("stripLeftZeros", stripRightZeros(brks, cnts)) }

stripLeftZeros <- function(brks, cnts) {
  if (cnts[1] == 0) {
    stripLeftZeros(brks[-1], cnts[-1])
  } else {
    list(brks, cnts)
  }
}

stripRightZeros <- function(brks, cnts) {
  len <- length(cnts)
  if (cnts[len] ==0) {
    stripRightZeros(brks[-(len+1)], cnts[-len])
  } else {
    list(brks, cnts)
  }
}
-------------------------------------------------------------------------------------------------------
ggplot(df) +
  geom_rect(aes(xmin = min(x), xmax = 0, ymin = min(y), ymax = 0), fill = "red") +
  geom_rect(aes(xmin = min(0), xmax = max(x), ymin = min(y), ymax = 0), fill = "blue") +
  geom_rect(aes(xmin = min(0), xmax = max(x), ymin = 0, ymax = max(y)), fill = "green") +
  geom_rect(aes(xmin = min(x), xmax = 0, ymin = 0, ymax = max(y)), fill = "yellow") +
  geom_point(aes(x, y), size = 5)
-------------------------------------------------------------------------------------------------------
ggplot(df) +
  geom_rect(xmin = -Inf, xmax = 0,   ymin = -Inf, ymax = 0,   fill = "red") +
  geom_rect(xmin = 0,    xmax = Inf, ymin = -Inf, ymax = 0,   fill = "blue") +
  geom_rect(xmin = 0,    xmax = Inf, ymin = 0,    ymax = Inf, fill = "green") +
  geom_rect(xmin = -Inf, xmax = 0,   ymin = 0,    ymax = Inf, fill = "yellow") +
  geom_point(aes(x, y), size = 5) alpha=0.5 geom_rect df df alpha=0.01 ggplot(df) +
  annotate("rect", xmin=-Inf, xmax=0, ymin=-Inf, ymax=0, fill="red", alpha=0.5) +
  annotate("rect", xmin=0, xmax=Inf, ymin=-Inf, ymax=0, fill="blue", alpha=0.5) +
  annotate("rect", xmin=0, xmax=Inf, ymin=0, ymax=Inf, fill="green", alpha=0.5) +
  annotate("rect", xmin=-Inf, xmax=0, ymin=0, ymax=Inf, fill="yellow", alpha=0.5) +
  geom_point(aes(x, y), size=5)
-------------------------------------------------------------------------------------------------------
transform fIndirect fDirect fDirect(1:3,2:4)
[1]  2  6 12 fIndirect fIndirect(1:3,2:4)
[1]  2 fIndirect(1:3,2:4) = fVec(c(1:3,2:4)) transform(mydf, v=fct(a, b)) fct mydf fct(mydf[i, "a"], mydf[i, "b"]) i v fct(mydf[["a"]], mydf[["b"]]) fIndirect fIndirect <- function(a, b)
  vapply(1:length(a), function(row) fVec(c(a[row], b[row])), FUN.VALUE=1) Rcmdr
-------------------------------------------------------------------------------------------------------
base brX <- seq(min(myd$X),max(myd$X),length=11)
brY <- seq(min(myd$Y),max(myd$Y),length=11)

layout(matrix(c(1,0,2,3),nrow=2),width=c(2,8),height=c(8,2))
par(mar=c(0,3,5,0))
plot(NA,ylim=range(myd$Y),xlim=c(0,1),axes=F,ann=F,xaxs="i")
rect(0,brY[-length(brY)],1,brY[-1], col=colorRampPalette(c("red","yellow","green"))(length(brY)-1))

par(mar=c(0,0,5,5))
plot(NA,xlim=range(myd$X),ylim=range(myd$Y),ann=F,xaxt="n",yaxt="n")
abline(h=pretty(myd$Y),v=pretty(myd$X), col="grey95")
points(myd$X,myd$Y,pch=21)
axis(3)
axis(4)

par(mar=c(3,0,0,5))
plot(NA,xlim=range(myd$X),ylim=c(0,1),axes=F,ann=F,yaxs="i")
rect(brX[-length(brX)],0,brX[-1],1, col=colorRampPalette(c("blue","white","red"))(length(brX)-1))
-------------------------------------------------------------------------------------------------------
grid bezier lattice grid native library(grid)
library(lattice)

dat <- data.frame(x=c(1,1,2,2),
                  y=c(1,2,1,2),
                  weight=c(2,1,1,2),
                  text=c('B','A','B','A'))
cols <- colorRampPalette(c("grey", "green"))(nrow(dat))
xyplot(y~x,data=dat,groups=weight,
       xlim=extendrange(dat$x,f=1),
       ylim=extendrange(dat$y,f=1),
       panel=function(x,y,groups,...){
         lapply(seq_along(x),function(i){
grid.roundrect(x[i],y[i], width=.5, height=.5*groups[i],gp=gpar(fill=cols[i],lwd=5,col='blue'),def='native')
         grid.text(x[i],y[i],label=dat$text[i],
                    gp=gpar(cex=5,col='white'),
                   def='native')
        })
         xx <- c(x[1]+0.25, x[1]+0.25, x[3]-0.25, x[3]-0.25)
         yy <- c(y[1], y[1], y[3], y[3])
         grid.bezier(xx, yy,
                     gp=gpar(lwd=3, fill="black"),
                     arrow=arrow(type="closed"),
                     def='native')
         xx <- c(x[1]+0.25, 1, 2, x[4]-0.25)
         yy <- c(y[1], 2, 1, y[4])
         grid.bezier(xx, yy,
                     gp=gpar(lwd=3, fill="black"),
                     arrow=arrow(type="closed",
                                 length=unit(0.5, "inches")),
                     def='native')
         xx <- c(x[2]+0.25, x[2]+0.25, x[4]-0.25, x[4]-0.25)
         yy <- c(y[2], y[2], y[4], y[4])
         grid.bezier(xx, yy,
                     gp=gpar(lwd=3, fill="black"),
                     arrow=arrow(type="closed",
                                 length=unit(0.5, "inches")),
                     def='native')

         })
-------------------------------------------------------------------------------------------------------
ggplot(pd[pd$score1 != 0,], aes(x=x, y=species)) +
  coord_fixed(ratio = 1.5, xlim=c(0.5,16.5), ylim=c(0.5, 3.5)) +
  geom_tile(aes(fill=score1)) +
  scale_fill_gradient2("Score 1", limits=c(0,4),low="#762A83", mid="white", high="#1B7837", guide=guide_colorbar(title.position="top")) +
  geom_text(data=pd, aes(label=letters, size = score2, color=factor(change)), family="mono") +
  scale_size_continuous(range = c(4, 8)) +
  scale_color_manual("Change", values=c("black", "#F2A11F"), labels=c("None", "Some"), guide=guide_legend(direction="vertical", title.position="top", override.aes=list(shape = "A"))) +
  theme(panel.background=element_rect(fill="white", colour="white"),
        axis.title = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.y = element_text(family="mono", size=rel(2)),
        axis.text.x = element_text(size=rel(0.7)),
        legend.text = element_text(size=rel(0.7)),
        legend.key.size = unit(0.7, "lines"),
        legend.position = "bottom", legend.box = "horizontal") +
  ggtitle("What about Score2?") library(ggplot2)
library(grid)
library(proto)

GeomTile2 <- proto(ggplot2:::GeomTile, {
  reparameterise <- function(., df, params) {
    df <- .$.super$reparameterise(df, params)
    if (params$ud == "u") 
      transform(df, ymin = y) 
    else 
        transform(df, ymax = (y-ymin)*0.8 + ymin, ymin = (y-ymin)*0.2 + ymin)
  }
  draw <- function(..., ud) {.$.super$draw(..., ud)}
})
geom_tile2 <- function (mapping = NULL, data = NULL, stat = "identity", position = "identity", ..., ud = "u") { 
  GeomTile2$new(mapping = mapping, data = data, stat = stat, position = position, ..., ud = ud)
}

ggplot(pd, aes(x=x, y=species)) +
  coord_fixed(ratio = 1.5, xlim=c(0.5,16.5), ylim=c(0.5, 3.5)) +
  geom_tile2(aes(fill=score1), ud = "u") +
  geom_tile2(aes(fill = score2), ud = "d") +
  scale_fill_gradient2("Score 1", limits=c(0,4),low="#762A83", mid="white", high="#1B7837", guide=guide_colorbar(title.position="top")) +
  geom_text(data=pd, aes(label=letters, color=factor(change)), size=rel(5), family="mono") +
  scale_color_manual("Change", values=c("black", "#F2A11F"), labels=c("None", "Some"), guide=guide_legend(direction="vertical", title.position="top", override.aes=list(shape = "A"))) +
  theme(panel.background=element_rect(fill="white", colour="white"),
        axis.title = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.y = element_text(family="mono", size=rel(2)),
        axis.text.x = element_text(size=rel(0.7)),
        legend.text = element_text(size=rel(0.7)),
        legend.key.size = unit(0.7, "lines"),
        legend.position = "bottom", legend.box = "horizontal") +
  ggtitle("What about Score2?")
-------------------------------------------------------------------------------------------------------
warning ggplot(mtcars) + geom_rect(data = subset(mtcars, cyl == 4), aes(fill = cyl),xmin = -inf,xmax = Inf, ymin = -Inf,ymax = Inf, alpha = 0.05) +
  geom_point(aes(mpg, wt)) +  facet_grid(. ~ cyl)
-------------------------------------------------------------------------------------------------------
strip require(reshape)
require(ggplot2)
require(scales)

# fake data
mydf <- data.frame(val1 = runif(10, 0, 1), val2 = runif(10, 0, 1))
mydf

# reshape to long format
long.data <- melt(mydf)
long.data$facetvar <- "implicit"
long.data$facetvar[seq(1, 19, 2)] <- "explicit"
long.data

# plot
ggplot(long.data, aes(y = value, x = variable)) +
    geom_bar(position = 'dodge', stat = "identity") +
    facet_wrap (~ facetvar) +
    theme(strip.background = element_rect(fill = alpha('green', 0.3))) +
    theme(strip.text.x = element_text(colour = 'blue', size = 10))
-------------------------------------------------------------------------------------------------------
geom_rect p bgdf <- data.frame(xmin=as.POSIXct(paste0(2008:2011,"-04-01")),
                   xmax=as.POSIXct(paste0(2009:2012,"-04-01")),
                   ymin=min(df$var),ymax=max(df$var),alpha=((2008:2011)%%2)*0.1)
p + geom_rect(aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymax), data=bgdf,alpha=bgdf$alpha,fill="blue")
-------------------------------------------------------------------------------------------------------
alpha() scales element_rect() fill= library(scales)    
p<-ggplot(iris,aes(Petal.Length,Petal.Width,color=Species))+geom_point()
p+theme(legend.position=c(1,1),legend.justification=c(1,1),
        legend.direction="vertical",
        legend.box="horizontal",
        legend.box.just = c("top"), 
        legend.background = element_rect(fill=alpha('blue', 0.4)))
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(grid)
library(gtable)

grid.newpage()

# two plots
a = ggplot(tp1,aes(Date,bond)) + geom_line(colour=I("blue")) + xlim(range(tp1$Date))
b = ggplot(tp1,aes(Date,equity)) + 
  geom_line(colour=I("red")) + 
  theme(panel.background = element_rect(fill = NA))

# extract gtable
g1 <- ggplot_gtable(ggplot_build(a))
g2 <- ggplot_gtable(ggplot_build(b))

# overlap the panel of 2nd plot on that of 1st plot
pp <- c(subset(g1$layout, name == "panel", se = t:r))
g <- gtable_add_grob(g1, g2$grobs[[which(g2$layout$name == "panel")]], pp$t, 
                     pp$l, pp$b, pp$l)

## what I dd is to plot a new viewports.
vp=viewport(x=0.5,y=0.5,height=0.5,width=0.5)
pushViewport(vp)
grid.draw(g)
upViewport()
-------------------------------------------------------------------------------------------------------
#' A transition plot
#' 
#' This plot purpose is to illustrate how states change before and
#' after. In my research I use it before surgery and after surgery
#' but it can be used in any situation where you have a change from 
#' one state to another
#'  
#' @param transition_flow This should be a matrix with the size of the transitions.
#'  The unit for each cell should be number of observations, row/column-proportions 
#'  will show incorrect sizes. The matrix needs to be square. The best way to generate
#'  this matrix is probably just do a \code{table(starting_state, end_state)}. The rows 
#'  represent the starting positions, while the columns the end positions. I.e. the first
#'  rows third column is the number of observations that go from the first class to the 
#'  third class.
#' @param box_txt The text to appear inside of the boxes. If you need line breaks
#'  then you need to manually add a \\n inside the string. 
#' @param tot_spacing The proportion of the vertical space that is to be left
#'  empty. It is then split evenly between the boxes.
#' @param box_width The width of the box. By default the box is one fourth of
#'  the plot width.
#' @param fill_start_box The fill color of the start boxes. This can either 
#'  be a single value ore a vector if you desire different colors for each 
#'  box. 
#' @param txt_start_clr The text color of the start boxes. This can either 
#'  be a single value ore a vector if you desire different colors for each 
#'  box.
#' @param fill_end_box The fill color of the end boxes. This can either 
#'  be a single value ore a vector if you desire different colors for each 
#'  box.
#' @param txt_end_clr The text color of the end boxes. This can either 
#'  be a single value ore a vector if you desire different colors for each 
#'  box.
#' @param pt The point size of the text
#' @param min_lwd The minimum width of the line that we want to illustrate the
#'  tranisition with. 
#' @param max_lwd The maximum width of the line that we want to illustrate the
#'  tranisition with. 
#' @param lwd_prop_total The width of the lines may be proportional to either the 
#'  other flows from that box, or they may be related to all flows. This is a boolean
#'  parameter that is set to true by default, i.e. relating to all flows.
#' @return void 
#' @example examples/transitionPlot_example.R
#' 
#' @author max
#' @import grid
#' @export
transitionPlot <- function (transition_flow,
                            box_txt = rownames(transition_flow),
                            tot_spacing = 0.2,
                            box_width = 1/4, 
                            fill_start_box = "darkgreen",
                            txt_start_clr = "white",
                            fill_end_box = "steelblue",
                            txt_end_clr = "white",
                            pt=20,
                            min_lwd = 1,
                            max_lwd = 6,
                            lwd_prop_total = TRUE) {
  # Just for convenience
  no_boxes <- nrow(transition_flow)

  # Do some sanity checking of the variables
  if (tot_spacing < 0 ||
        tot_spacing > 1)
    stop("Total spacing, the tot_spacing param,",
      " must be a fraction between 0-1,",
      " you provided ", tot_spacing)

  if (box_width < 0 ||
        box_width > 1)
    stop("Box width, the box_width param,",
      " must be a fraction between 0-1,",
      " you provided ", box_width)

  # If the text element is a vector then that means that 
  # the names are the same prior and after
  if (is.null(box_txt))
    box_txt = matrix("", ncol=2, nrow=no_boxes)
  if (is.null(dim(box_txt)) && is.vector(box_txt))
    if (length(box_txt) != no_boxes)
      stop("You have an invalid length of text description, the box_txt param,",
          " it should have the same length as the boxes, ", no_boxes, ",",
          " but you provided a length of ", length(box_txt))
    else
      box_txt <- cbind(box_txt, box_txt)
  else if (nrow(box_txt) != no_boxes ||
        ncol(box_txt) != 2)
    stop("Your box text matrix doesn't have the right dimension, ", 
         no_boxes, " x 2, it has: ", 
         paste(dim(box_txt), collapse=" x "))


  # Make sure that the clrs correspond to the number of boxes
  fill_start_box <- rep(fill_start_box, length.out=no_boxes)
  txt_start_clr <- rep(txt_start_clr, length.out=no_boxes)
  fill_end_box <- rep(fill_end_box, length.out=no_boxes)
  txt_end_clr <- rep(txt_end_clr, length.out=no_boxes)

  if(nrow(transition_flow) != ncol(transition_flow))
    stop("Invalid input array, the matrix is not square but ",
      nrow(transition_flow), " x ", ncol(transition_flow))

  # Set the proportion of the start/end sizes of the boxes
  prop_start_sizes <- rowSums(transition_flow)/sum(transition_flow)
  prop_end_sizes <- colSums(transition_flow)/sum(transition_flow)

  if (sum(prop_end_sizes) == 0)
    stop("You can't have all empty boxes after the transition")

  getBoxPositions <- function (no, side){
    empty_boxes <- ifelse(side == "left", 
      sum(prop_start_sizes==0), 
      sum(prop_end_sizes==0))

    # Calculate basics
    space <- tot_spacing/(no_boxes-1-empty_boxes)

    # Do the y-axis
    ret <- list(height=(1-tot_spacing)*ifelse(side == "left", 
                                              prop_start_sizes[no], 
                                              prop_end_sizes[no]))
    if (no == 1){
      ret$top <- 1
    }else{
      ret$top <- 1 - 
        ifelse(side == "left", 
               sum(prop_start_sizes[1:(no-1)]), 
               sum(prop_end_sizes[1:(no-1)])) * (1-tot_spacing) -
        space*(no-1)
    }
    ret$bottom <- ret$top - ret$height
    ret$y <- mean(c(ret$top, ret$bottom))

    ret$y_exit <- rep(ret$y, times=no_boxes)
    ret$y_entry_height <- ret$height/3
    ret$y_entry <- seq(to=ret$y-ret$height/6,
                       from=ret$y+ret$height/6,
                       length.out=no_boxes)

    # Now the x-axis
    if (side == "right"){
      ret$left <- 1-box_width
      ret$right <- 1
    }else{
      ret$left <- 0
      ret$right <- box_width
    }

    txt_margin <- box_width/10
    ret$txt_height <- ret$height - txt_margin*2
    ret$txt_width <- box_width - txt_margin*2

    ret$x <- mean(c(ret$left, ret$right))

    return(ret)
  }

  plotBoxes <- function (no_boxes, width, txt, 
    fill_start_clr, fill_end_clr, 
    lwd=2, line_col="#000000") {

    plotBox <- function(bx, bx_txt, fill){
      grid.roundrect(y=bx$y, x=bx$x, height=bx$height, width=width, gp = gpar(lwd=lwd, fill=fill, col=line_col))

      if (bx_txt != ""){
        grid.text(bx_txt,y=bx$y, x=bx$x, 
          just="centre", 
          gp=gpar(col=txt_start_clr, fontsize=pt))
      }
    }

    for(i in 1:no_boxes){
      if (prop_start_sizes[i] > 0){
        bx_left <- getBoxPositions(i, "left")
        plotBox(bx=bx_left, bx_txt = txt[i, 1], fill=fill_start_clr[i])
      }

      if (prop_end_sizes[i] > 0){
        bx_right <- getBoxPositions(i, "right")
        plotBox(bx=bx_right, bx_txt = txt[i, 2], fill=fill_end_clr[i])
      }
    }
  }

  # Do the plot
  require("grid")
  plot.new()
  vp1 <- viewport(x = 0.51, y = 0.49, height=.95, width=.95)
  pushViewport(vp1)

  shadow_clr <- rep(grey(.8), length.out=no_boxes)
  plotBoxes(no_boxes, 
            box_width, 
            txt = matrix("", nrow=no_boxes, ncol=2), # Don't print anything in the shadow boxes
            fill_start_clr = shadow_clr, 
            fill_end_clr  = shadow_clr,
            line_col=shadow_clr[1])
  popViewport()

  vp1 <- viewport(x = 0.5, y = 0.5, height=.95, width=.95)
  pushViewport(vp1)
  plotBoxes(no_boxes, box_width, 
            txt = box_txt,
            fill_start_clr = fill_start_box, 
            fill_end_clr  = fill_end_box)

  for (i in 1:no_boxes){
    bx_left <- getBoxPositions(i, "left")
    for (flow in 1:no_boxes){
      if (transition_flow[i,flow] > 0){
        bx_right <- getBoxPositions(flow, "right")

        a_l <- (box_width/4)
        a_angle <- atan(bx_right$y_entry_height/(no_boxes+.5)/2/a_l)*180/pi
        if (lwd_prop_total)
          lwd <- min_lwd + (max_lwd-min_lwd)*transition_flow[i,flow]/max(transition_flow)
        else
          lwd <- min_lwd + (max_lwd-min_lwd)*transition_flow[i,flow]/max(transition_flow[i,])

        # Need to adjust the end of the arrow as it otherwise overwrites part of the box
        # if it is thick
        right <- bx_right$left-.00075*lwd
        grid.bezier(x=c(bx_left$right, .5, .5, right), 
                    y=c(bx_left$y_exit[flow], bx_left$y_exit[flow], 
                        bx_right$y_entry[i], bx_right$y_entry[i]), 
                    gp=gpar(lwd=lwd, fill="black"),
                    arrow=arrow(type="closed", angle=a_angle, length=unit(a_l, "npc")))
        # TODO: A better option is probably bezierPoints

      }
    }
  }
  popViewport()
} # Settings
no_boxes <- 3
# Generate test setting
transition_matrix <- matrix(NA, nrow=no_boxes, ncol=no_boxes)
transition_matrix[1,] <- 200*c(.5, .25, .25)
transition_matrix[2,] <- 540*c(.75, .10, .15)
transition_matrix[3,] <- 340*c(0, .2, .80)

transitionPlot(transition_matrix,  
  box_txt = c("First", "Second", "Third"))
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(grid)

sizeit <- function(p, panel.size = 2, default.ar=1){

  gb <- ggplot_build(p)
  # first check if theme sets an aspect ratio
  ar <- gb$plot$coordinates$ratio

  # second possibility: aspect ratio is set by the coordinates, which results in 
  # the use of 'null' units for the gtable layout. let's find out
  g <- ggplot_gtable(gb)
  nullw <- sapply(g$widths, attr, "unit")
  nullh <- sapply(g$heights, attr, "unit")

  # ugly hack to extract the aspect ratio from these weird units
  if(any(nullw == "null"))
    ar <- unlist(g$widths[nullw == "null"]) / unlist(g$heights[nullh == "null"])

  if(is.null(ar)) # if the aspect ratio wasn't specified by the plot
       ar <- default.ar

  # ensure that panel.size is always the larger dimension
  if(ar <= 1 ) panel.size <- panel.size / ar

  g$fullwidth <- convertWidth(sum(g$widths), "in", valueOnly=TRUE) + 
    panel.size
  g$fullheight <- convertHeight(sum(g$heights), "in", valueOnly=TRUE) + 
    panel.size / ar

  class(g) <- c("sizedgrob", class(g))
  g
}


print.sizedgrob <- function(x){
  dev.new(width=x$fullwidth, height=x$fullheight)
  grid.draw(x)
}


p1 <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point() + coord_fixed() +
  theme(plot.background = element_rect(colour = "red"))

p2 <- p1 + aes(x = mpg, y = wt)

# need for an explicit dummy device open, otherwise it's a bit off
# for no apparent reason that I can understand
dev.new() 

sizeit(p1, 0.1) sizeit(p2, 2)
-------------------------------------------------------------------------------------------------------
plot.background theme() theme(plot.background=element_rect(fill="black", colour=NA))
-------------------------------------------------------------------------------------------------------
geom_rect() ymin ymax xmin xmax ggplot(data=d[d$day=="Avg",], aes(x=day , y=count, fill=month)) + 
  geom_rect(data=NULL,aes(xmin=0.25,xmax=7.25,ymin=-Inf,ymax=Inf),fill="lightgreen")+
  geom_rect(data=NULL,aes(xmin=7.25,xmax=8.75,ymin=-Inf,ymax=Inf),fill="darkgreen")+
  geom_bar(position = "dodge", width = 1.2, stat="identity") +
  geom_text(aes(label=month, x=day, y=count), 
            position=position_dodge(width=1.2), vjust=-.6, size=3) + 
  geom_line(data=d[d$day!="Avg",], aes(x=day, y=count, group=month, colour=month)) + 
  facet_wrap(~snow,ncol=1,scales="free") + 
  scale_x_discrete(limits=levels(d$day))
-------------------------------------------------------------------------------------------------------
#library(devtools)
#install_github("tablegrob", "baptiste")
require(tablegrob)

d <- iris[sample(seq.int(nrow(iris)), 6),]

grid.newpage()
pushViewport(viewport(height=0.8,width=0.9))
g2 <- tableGrob(d, rows=NULL,
                widths=unit(1,"null"), heights=unit(1/(nrow(d)),"npc"))
grid.draw(g2)
grid.roundrect(y=unit(0,"line"), height=unit(1,"npc") +unit(1,"lines"),
               just="bottom", r=unit(0.05, "snpc"))
-------------------------------------------------------------------------------------------------------
plydat <- ddply(Suz2,.(org),transform,ybegin = copy - se,yend = copy + se)   

colvec <-c("blue", "orange")

ggplot(plydat, aes(time, copy, color = factor(org))) + 
   geom_point(size = 3.5) + facet_wrap(~group, ncol = 4) + 
   scale_color_manual(values = colvec) +
   geom_errorbar(aes(ymax=ybegin , ymin= yend), width = 0.08, 
        color = "black", size = 0.1) +
   theme(panel.background = element_rect(fill='white', colour='white'), 
        panel.grid = element_line(color = NA),
        panel.grid.minor = element_line(color = NA),
        panel.border = element_rect(fill = NA, color = "black"),
        strip.background = element_blank(),
        axis.text.x  = element_text(size=10, colour="black", face = "bold"),  
        axis.title.x = element_text(vjust=0.1, face = "bold"),
        axis.text.y = element_text(size=12, colour="black"),
        axis.title.y = element_text(vjust=0.2, size = 12, face = "bold"))
-------------------------------------------------------------------------------------------------------
panel.lines() panel.text() function () {
    trellis.device(width = 5, height = 5, new = F)
    xx <- GERD95.06
    xx$Country <- c("USA", "Singapore", "Denmark", "Australia", 
        "NZ")
    barchart(X1995 + X2006 ~ reorder(Country, xx$X2006), data = xx, 
        ylab = "GERD per capita, nominal $US PPP", cex = 0.8, 
        panel = function(...) {
            panel.lines(c(0.7, 5), c(720, 720), col = "gray", 
                lwd = 4)
            panel.text(lab = "OECD avg 2006", x = 1, y = 750, 
                adj = c(0.4, 0), cex = 0.7)
            panel.text(lab = "NZ at 2.5% of GDP", x = 1, y = 630, 
                adj = c(0.4, 0), cex = 0.7)
            panel.text(lab = "1995", x = 1.5, y = 900, adj = c(1, 
                0.5))
            panel.rect(xleft = 1.6, xright = 2, ybottom = 870, ytop = 930, col = 3)
            panel.text(lab = "2006", x = 1.5, y = 1000, adj = c(1, 
                0.5))
            panel.rect(xleft = 1.6, xright = 2, ybottom = 970, ytop = 1030, col = 8)
            panel.barchart(..., col = c(3, 8))
            panel.rect(xleft = 1, xright = 1.3333, ybottom = xx$X2006[xx$Country == "NZ"], ytop = 2.5/1.206 * xx$X2006[xx$Country == "NZ"])
        }, ylim = c(0, 1200))
}
-------------------------------------------------------------------------------------------------------
#' Plot two dimensional histogram
#'
#' @param hist matrix or two dimensional array containing the number of counts
#' in each of the bins.
#' @param borders_x the x-borders of the bins in the histogram. Should be a
#' numeric vector with lenght one longer than the number of columns of
#' \code{hist}
#' @param borders_y the y-borders of the bins in the histogram. Should be a
#' numeric vector with lenght one longer than the number of rows of
#' \code{hist}
#' @param type a character specifying the type of plot. Valid values are "text",
#' "area" and "color". See details for more information.
#' @param add add the plot to an existing one or create a new plot.
#' @param add_lines logical specifying whether or not lines should be drawn
#' between the bins.
#' @param draw_empty if \code{FALSE} empty bins (numer of counts equal to zero)
#' are not drawn. They are shown using the background color.
#' @param col for types "area" and "text" the color of the boxes and text.
#' @param line_col the color of the lines between the bins.
#' @param background_col the background color of the bins.
#' @param lty the line type of the lines between the bins.
#' @param text_cex the text size used for type "text". See \code{\link{par}} for
#' more information.
#' @param col_range the color scale used for type "color". Should be a function
#' which accepts as first argument the number of colors that should be
#' generated. The first color generated is used for the zero counts; the
#' last color for the highest number of counts in the histogram.
#' @param ... additional arguments are passed on to \code{\link{plot}}.
#'
#' @details
#' There are three plot types: "area", "text", and "color". In case of "area"
#' rectangles are drawn inside the bins with area proportional to the number of
#' counts in the bins. In case of text the number of counts is shown as text in
#' the bins. In case of color a color scale is used (by default heat.colors) to
#' show the number of counts.
#'
#' @seealso \code{\link{image}} which can be used to create plots similar to
#' type "color". \code{\link{contour}} may also be of interest.
#'
#' @examples
#' histplot2(volcano - min(volcano), type="color")
#' histplot2(volcano - min(volcano), add_lines=FALSE, type="area")
#' histplot2(volcano - min(volcano), type="text", text_cex=0.5)
#'
#' @export
histplot2 <- function(hist, borders_x=seq(0, ncol(hist)),
        borders_y=seq(0, nrow(hist)), type="area", add=FALSE, add_lines=TRUE,
        draw_empty=FALSE, col="black", line_col="#00000030",
        background_col="white", lty=1, text_cex=0.6, col_range=heat.colors, ...) {
    # create new plot
    rangex <- c(min(borders_x), max(borders_x))
    rangey <- c(min(borders_y), max(borders_y))
    if (add == FALSE) {
        plot(rangex, rangey, type='n', xaxs='i', yaxs='i', ...)
        rect(rangex[1], rangey[1], rangex[2], rangey[2], col=background_col,border=NA)
    }
    # prepare data
    nx <- length(borders_x)-1
    ny <- length(borders_y)-1
    wx <- rep(diff(borders_x), each=ny)
    wy <- rep(diff(borders_y), times=nx)
    sx <- 0.95*min(wx)/sqrt(max(hist))
    sy <- 0.95*min(wy)/sqrt(max(hist))
    x <- rep((borders_x[-length(borders_x)] + borders_x[-1])/2, each=ny)
    y <- rep((borders_y[-length(borders_y)] + borders_y[-1])/2, times=nx)
    h <- as.numeric(hist)
    # plot type "area"
    if (type == "area") {
        dx <- sqrt(h)*sx*0.5
        dy <- sqrt(h)*sy*0.5
        rect(x-dx, y-dy, x+dx, y+dy, col=col, border=NA)
    # plot type "text"
    } else if (type == "text") {
        if (draw_empty) {
            text(x, y, format(h), cex=text_cex, col=col)
        } else {
            text(x[h!=0], y[h!=0], format(h[h!=0]), cex=text_cex, col=col)
        }
    # plot type "color"
    } else if (type == "color" | type == "colour") {
        #h <- h/(wx*wy)
        col <- col_range(200)
        col <- col[floor(h/max(h)*200*(1-.Machine$double.eps))+1]
        sel <- rep(TRUE, length(x))
        if (!draw_empty) sel <- h > 0
        rect(x[sel]-wx[sel]/2, y[sel]-wy[sel]/2, x[sel]+wx[sel]/2, y[sel]+wy[sel]/2, col=col[sel], border=NA)
    } else {
        stop("Unknown plot type: options are 'area', 'text' and 'color'.")
    }
    # add_lines
    if (add_lines) {
        lines(rbind(borders_x, borders_x, NA),
            rbind(rep(rangey[1], nx+1), rep(rangey[2], nx+1), NA),
            col=line_col, lty=lty)
        lines(rbind(rep(rangex[1], ny+1), rep(rangex[2], ny+1), NA),
            rbind(borders_y, borders_y, NA), col=line_col, lty=lty)
    }
    # add border
    if (add == FALSE) box()
} X <- matrix(nrow=3, ncol=3)
X[1,] <- c(0.3, 0.4, 0.45)
X[2,] <- c(0.3, 0.7, 0.65)
X[3,] <- c(0.3, 0.4, 0.45)
centers <- c(1.5, 3, 4)

centers_to_borders <- function(centers) {
    nc <- length(centers)
    d0 <- centers[2]-centers[1]
    d1 <- centers[nc]-centers[nc-1]
    c(centers[1]-d0/2, 
      (centers[2:nc] + centers[1:(nc-1)])/2, centers[nc]+d1/2)
}

histplot2(X, centers_to_borders(centers), 
    centers_to_borders(centers), type="color") plot_range <- function(hist, col_range = heat.colors) {
    r <- range(c(0, X))
    par(cex=0.7, mar=c(8, 1, 8, 2.5))
    plot(0, 0, type='n', xlim=c(0,1), ylim=r, xaxs='i',
        yaxs='i', bty='n', xaxt='n', yaxt='n', xlab='', ylab='')
    axis(4)
    y <- seq(r[1], r[2], length.out=200)
    yc <- floor(y/max(y)*5*(1-.Machine$double.eps))+1
    col <- col_range(5)[yc]
    b <- centers_to_borders(y)
    rect(rep(0, length(y)), b[-length(b)], rep(1, length(y)),  b[-1], col=col, border=NA)
} layout layout(matrix(c(1,2), nrow = 1), widths = c(0.9, 0.1))
par(mar = c(5, 4, 4, 2) + 0.1)
histplot2(X, centers_to_borders(centers), 
    centers_to_borders(centers), type="color")
plot_range(X) histplot2 h <- h/(wx*wy)
-------------------------------------------------------------------------------------------------------
par mar mai oma omi ?par lattice ggplot2 ggplot2 library(ggplot2)
library(scales)

#### Setup the `theme` for the plot, i.e. the appearance of background, lines, margins, etc. of the plot.
##   This function returns a theme-object, which ggplot2 uses to control the appearance.
theme_tufte <- function(ticks=TRUE, base_family="serif", base_size=11) {
  ret <- theme_bw(base_family=base_family, base_size=base_size) +
    theme(
      legend.background = element_blank(),
      legend.key        = element_blank(),
      panel.background  = element_blank(),
      panel.border      = element_blank(),
      strip.background  = element_blank(),
      plot.background   = element_blank(),
      axis.line         = element_blank(),
      panel.grid = element_blank())
  if (!ticks) {
    ret <- ret + theme(axis.ticks = element_blank())
  }
  ret
}

## Here I modify the theme returned from the function,
theme <- theme_tufte() + theme(panel.margin=unit(c(0,0,0,0), 'lines'),     panel.border=element_rect(colour='grey', fill=NA))
## and instruct ggplot2 to use this theme as default.
theme_set(theme)

#### Some data generation.
size = 60*30
data <- data.frame(x=runif(size), y=rexp(size)+rnorm(size), mdl=sample(60,size, replace=TRUE))

#### Main plotting routine.
ggplot(data, aes(x,y, group=mdl)) ## base state of the plot to be used on all "layers", i.e. which data to use and which mappings to use (x should use x-variable, y should use the y-variable
  + geom_point()                  ## a layer that renders data as points, creates the scatterplot
  + stat_quantile(formula=y~x)    ## another layer that adds some statistics, in this case the 25%, 50% and 75% quantile lines.
  + facet_wrap(~ mdl, ncol=6)     ## Without this, all the groups would be displayed in one large plot; this breaks it up according to the `mdl`-variable. ggplot2 reshape2 plyr data.frame ggplot
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(reshape2)

X <- matrix(nrow=3, ncol=3)
X[1,] <- c(0.3, 0.4, 0.45)
X[2,] <- c(0.3, 0.7, 0.65)
X[3,] <- c(0.3, 0.4, 0.45)


colnames(X)<-c(1.5, 3, 4)
rownames(X)<-c(1.5, 3, 4)
X <- melt(X)
X <- as.data.frame(X)
names(X) <- c("Var1", "Var2", "value")
v1m <- unique(X$Var1)
X$Var1.min <- rep(c(0, v1m[-length(v1m)]), length.out = length(v1m))
v2m <- unique(X$Var2)
X$Var2.min <- rep(c(0, v2m[-length(v2m)]), each = length(v2m))

ggplot(data = X, aes(fill = value)) + 
    geom_rect(aes(ymin = Var1.min, ymax = Var1, xmin = Var2.min, xmax = Var2))
-------------------------------------------------------------------------------------------------------
filled.contour filled.contour my.filled.contour <-
function (x = seq(0, 1, length.out = nrow(z)), y = seq(0, 1,
    length.out = ncol(z)), z, xlim = range(x, finite = TRUE),
    ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE),
    levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors,
    col = color.palette(length(levels) - 1), plot.title, plot.axes,
    key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1,
    axes = TRUE, frame.plot = axes, ...)
{
    if (missing(z)) {
        if (!missing(x)) {
            if (is.list(x)) {
                z <- x$z
                y <- x$y
                x <- x$x
            }
            else {
                z <- x
                x <- seq.int(0, 1, length.out = nrow(z))
            }
        }
        else stop("no 'z' matrix specified")
    }
    else if (is.list(x)) {
        y <- x$y
        x <- x$x
    }
    if (any(diff(x) <= 0) || any(diff(y) <= 0))
        stop("increasing 'x' and 'y' values expected")
    mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar
    on.exit(par(par.orig))
    w <- (3 + mar.orig[2L]) * par("csi") * 2.54
    layout(matrix(c(2, 1), ncol = 2L), widths = c(1, lcm(w)))
    par(las = las)
    mar <- mar.orig
    mar[4L] <- mar[2L]
    mar[2L] <- 1
    par(mar = mar)
    plot.new()
    plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i",
        yaxs = "i")
#    rect(0, levels[-length(levels)], 1, levels[-1L], col = col)
#    if (missing(key.axes)) {
#        if (axes)
#            axis(4)
#    }
#    else key.axes
#    box()
    if (!missing(key.title))
        key.title
    mar <- mar.orig
    mar[4L] <- 1
    par(mar = mar)
    plot.new()
    plot.window(xlim, ylim, "", xaxs = xaxs, yaxs = yaxs, asp = asp)
    if (!is.matrix(z) || nrow(z) <= 1L || ncol(z) <= 1L)
        stop("no proper 'z' matrix specified")
    if (!is.double(z))
        storage.mode(z) <- "double"
    .Internal(filledcontour(as.double(x), as.double(y), z, as.double(levels),
        col = col))
    if (missing(plot.axes)) {
        if (axes) {
            title(main = "", xlab = "", ylab = "")
            Axis(x, side = 1)
            Axis(y, side = 2)
        }
    }
    else plot.axes
    if (frame.plot)
        box()
    if (missing(plot.title))
        title(...)
    else plot.title
    invisible()
} my.filled.contour(x=x, y=y, z=z,
               levels=levels,
               col=colorpanel(length(levels) + 1, "white", "grey10"),
               xlim=rev(range(x)),
               ylim=rev(range(y)),
               plot.axes={axis(1, c(0.18, 0.01), label=TRUE, tcl=-0.5)
                          axis(2, c(0.18, 0.01), label=TRUE, tcl=-0.5)
                          draw.contour()},
               xlab="x",
               frame=FALSE)
-------------------------------------------------------------------------------------------------------
geom_area aes m <- median(esoph$ncases)
Q1 <- quantile(as.numeric(esoph$ncases), c(0.25))
Q3 <- quantile(as.numeric(esoph$ncases), c(0.75))

ggplot(esoph, aes(x=agegp, y=ncases))+
geom_rect(xmin = -Inf , xmax = Inf , ymin = Q1 , ymax = Q3  ,fill = "blue", alpha = .002)+
geom_hline(yintercept= m,colour = "white", size=1)  + geom_boxplot(aes(group=agegp))+ coord_flip() + geom_point() + 
theme_classic()
-------------------------------------------------------------------------------------------------------
geom_rect() facet_grid() geom_text() df.text + geom_rect(data=df.text,aes(xmin=-Inf,xmax=Inf,ymin=-Inf,ymax=Inf),
        fill="white",inherit.aes=FALSE)
-------------------------------------------------------------------------------------------------------
geom_rect() Grunfeld ymax Inf ymin -Inf xmin xmax ggplot(dfm) +
    geom_rect(data = subset(Grunfeld, dummy == 0), 
              aes(ymin = -Inf, ymax = Inf, xmin = year-0.5, xmax = year+0.5), 
              alpha = 0.2)+
    geom_line(aes(x=year, y=value, linetype=variable, colour=variable)) +
    theme_bw() +
    facet_wrap( ~ firm)
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(grid)

pd = data.frame(
  letters = strsplit("AGTGACCGACTATCATAGTGACCCAGAATCATAGTGACCGAGTATGAT", "")[[1]],
  species = rep(c("Human", "Armadillo", "Porcupine"), each=16),
  x       = rep(1:16, 3),
  change  = c(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
              0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,
              0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0),
  score1  = c(0,0,0,0,0,0,1,1,2,2,2,3,3,3,4,3,
              0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,
              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),
  score2  = c(0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,
              0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,
              0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0)
)


p1=ggplot(pd[pd$score1 != 0,], aes(x=x, y=species)) +
  coord_fixed(ratio = 1.5, xlim=c(0.5,16.5), ylim=c(0.5, 3.5)) +
  geom_tile(aes(fill=score1)) +
  scale_fill_gradient2("Score 1", limits=c(0,4),low="#762A83", mid="white", high="#1B7837", guide=guide_colorbar(title.position="top")) +
  geom_text(data=pd, aes(label=letters, color=factor(change)), size=rel(5), family="mono") +
  scale_color_manual("Change", values=c("black", "#F2A11F"), labels=c("None", "Some"), guide=guide_legend(direction="vertical", title.position="top", override.aes=list(shape = "A"))) +
  theme(panel.background=element_rect(fill="white", colour="white"),
        axis.title = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.y = element_text(family="mono", size=rel(2)),
        axis.text.x = element_text(size=rel(0.7)),
        legend.text = element_text(size=rel(0.7)),
        legend.key.size = unit(0.7, "lines"),
        legend.position = "bottom", legend.box = "horizontal") +
  ggtitle("Voila, the Score2!")

p2=ggplot(pd[pd$score2 != 0,], aes(x=x, y=species)) +
  coord_fixed(ratio = 1.5, xlim=c(0.5,16.5), ylim=c(0.5, 3.5)) +
  geom_tile(aes(fill=score2)) +
  scale_fill_gradient2("Score 2", limits=c(0,3),low="#1B7837", mid="white", high="#762A83", guide=guide_colorbar(title.position="top")) +
  geom_text(data=pd, aes(label=letters, color=factor(change)), size=rel(5), family="mono") +
  scale_color_manual("Change", values=c("black", "#F2A11F"), labels=c("None", "Some"), guide=guide_legend(direction="vertical", title.position="top", override.aes=list(shape = "A"))) +
  theme(panel.background=element_rect(fill="white", colour="white"),
        axis.title = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.y = element_text(family="mono", size=rel(2)),
        axis.text.x = element_text(size=rel(0.7)),
        legend.text = element_text(size=rel(0.7)),
        legend.key.size = unit(0.7, "lines"),
        legend.position = "bottom", legend.box = "horizontal") +
  ggtitle("What about Score2?")


p1g=ggplotGrob(p1)
p2g=ggplotGrob(p2)

combo.grob = p1g

combo.grob$grobs[[8]] = cbind(p1g$grobs[[8]][,1:4], 
                              p2g$grobs[[8]][,3:5], 
                              size="first")

combo.grob$grobs[[4]] = reorderGrob(
                          addGrob(p1g$grobs[[4]], 
                                  getGrob(p2g$grobs[[4]], 
                                          "geom_rect.rect", 
                                          grep=TRUE)), 
                          c(1,2,5,3,4))
grid.newpage()
grid.draw(combo.grob)
-------------------------------------------------------------------------------------------------------
library(grid) 
grid.rect(width=unit(0.8, "npc"), gp=gpar(lty=2))
print(qplot(1,1), vp=viewport(width=unit(0.8, "npc")))
-------------------------------------------------------------------------------------------------------
p + guides(fill=guide_legend(keyheight=unit(1,"cm"))) + theme(plot.margin=unit(c(1,1,1,1),"cm"))
showViewport(col="black",label=TRUE, newpage=TRUE, leaves=FALSE) library(gtable)
g = ggplotGrob(p)
leg = gtable_filter(g, "guide")
plot(leg)
leg$heights
# sum(0.5lines, sum(1.5mm, 10mm, 0mm, 1.5mm), 0.5lines)+0cm
grid.rect(height=leg$heights) 
grid.rect(height=leg$heights - unit(1,"line"), gp=gpar(lty=2)) guide.margin
-------------------------------------------------------------------------------------------------------
hline <- data.frame(yint = 0.136,lt = 'Avg') 

ggplot(data=df[df$lang=="en",])+
    geom_point(aes(x=days,y=points),size=5,colour='cyan')+
    geom_point(aes(x=days,y=points,colour=days),size=4)+
    facet_wrap(~lang,ncol=1,scales="free")+
    xlab("")+
    ylab("")+
    scale_y_continuous(labels = percent_format())+
    theme(legend.position="right",
          legend.title = element_blank(),
          strip.text.x = element_text(size = 13, colour = 'black', angle = 0),
          axis.text.x=element_text(angle=0, hjust=.5, vjust=0),
          legend.position = 'none',
          panel.background = element_rect(fill = "#545454"),
          panel.grid.major = element_line(colour = "#757575"),
          panel.grid.minor = element_line(colour = "#757575"))+
    geom_hline(data = hline,aes(yintercept=yint,linetype = lt),color = "cyan",size=2,show_guide = TRUE) + 
    scale_colour_discrete(guide = "none") + 
    scale_linetype_manual(name = 'Legend',values = 1,guide = "legend") legend.title = element_blank()
-------------------------------------------------------------------------------------------------------
geom_rect geom_line shape="|" geom_point p<-ggplot(hab,aes(x=score, y=metric))+theme_classic()+geom_rect(aes(xmin = 0 , xmax = 25) , ymin = -Inf , ymax = Inf ,fill = "#F15922") + 
geom_rect(aes(xmin = 25 , xmax = 50) , ymin = -Inf , ymax = Inf ,fill = "#F7941E")+
geom_rect(aes(xmin = 50 , xmax = 75) , ymin = -Inf , ymax = Inf ,fill = "#00BAF2")+
geom_rect(aes(xmin = 75 , xmax = 100) , ymin = -Inf , ymax = Inf ,fill = "#00A975")+
geom_vline(xintercept=seq(0,100,by=25),colour="white",size=1.5)+
geom_hline(yintercept=c(seq(0,0.5,by=0.1),seq(1.5,15.5,by=1),seq(15.5,16,by=0.1)),colour="white",size=1.5)+
geom_point(colour="white", size=4) + geom_point(colour = "black",size=3)+
geom_text(aes(label = "Poor", x = 12.5, y = 16), vjust = 1.2,size=4)+
geom_text(aes(label = "Fair", x = 37.5, y = 16), vjust = 1.2,size=4)+
geom_text(aes(label = "Good", x = 62.5, y = 16), vjust = 1.2,size=4)+
geom_text(aes(label = "Excellent", x = 87.5, y = 16), vjust = 1.2,size=4)

p
-------------------------------------------------------------------------------------------------------
bg par base plot(d0)
subplot(fun = {plot(d0_inset, mgp = c(1,0.4,0), ann = F, cex.axis=0.5);
               rect(par("usr")[1],par("usr")[3],par("usr")[2],par("usr")[4],col = "blue");
               points(d0_inset, col=2, pch=".") }, 
        x = grconvertX(c(0.75,1), from='npc'), 
        y = grconvertY(c(0,0.25), from='npc'), 
        pars = list(mar = c(1.5,1.5,0,0) + 0.1), type="fig") plot(d0)
rect(grconvertX(0.75, from='npc'), grconvertY(0, from='npc'),
     grconvertX(1, from='npc'), grconvertY(0.25, from='npc'), 
     col="blue", border=NA)
subplot(fun = plot(d0_inset, mgp = c(1,0.4,0), ann = F, 
                    cex.axis=0.5,col=2, pch=".") , 
        x = grconvertX(c(0.75,1), from='npc'), 
        y = grconvertY(c(0,0.25), from='npc'), 
        pars = list(mar = c(1.5,1.5,0,0) + 0.1), type="fig")
-------------------------------------------------------------------------------------------------------
geom_rect geom_rect df<-data.frame(date,start,duration,event)

df <- transform(df,
                start = as.POSIXct(paste(date, start)),
                end   = as.POSIXct(paste(date, start)) + duration*3600)

df <- df[c("event", "start", "end")]

df$date <- strptime(df$start, "%Y-%m-%d")
df$start.new <- format(df$start, format = "%H:%M:%S")
df$end.new <- format(df$end, format = "%H:%M:%S")
df$day <- factor(as.POSIXct(df$date))
levels(df$day) <- 1:4
df$day <- as.numeric(as.character(df$day))
df$event.int <- df$event
levels(df$event.int) <- 1:7
df$event.int <- as.numeric(as.character(df$event.int))

p <- ggplot(df, aes(day, start)) + 
geom_rect(aes(ymin = start, ymax = end,xmin = (day - 0.45) + event.int/10,xmax = (day - 0.35) + event.int/10,fill = event)) +
  scale_x_discrete(limits = 1:4,breaks = 1:4, labels = sort(unique(date)),
                   name = "Start date") + ylab("Duration")
-------------------------------------------------------------------------------------------------------
df<-data.frame(date,start,duration,event)

library(ggplot2)

p <- ggplot(df, aes(xmin=as.Date(date),xmax=as.Date(date)+1,
                    ymin=as.POSIXct(start,format='%H:%M:%S'),
                    ymax=as.POSIXct(start,format='%H:%M:%S')+duration*3600,
                    fill=event))
p <- p+geom_rect(alpha = I(8/10)) 
p + ylab("time") + xlab("date") + scale_x_date(labels = date_format("%m/%d")) +
scale_y_datetime(labels = date_format("%H"))+
scale_colour_hue(h=c(360, 90))
theme(axis.text.x = element_text(hjust=1, angle=0))
-------------------------------------------------------------------------------------------------------
# From:

      x <- x[, id2 := which(vapply(groups, function(x,y) any(x==y), .BY[[1]], FUN.VALUE=T)), by=id]

# To something along the lines of:
      x$id2 <- findInterval( match( x$id, unlist(groups)), cumsum(c(0,sapply(groups, length)))+1) f2(x[["res"]]) Performance Comparison:
Unit: milliseconds
                       expr      min       lq   median       uq      max neval
                   f.main() 2.896716 2.982045 3.034334 3.137628 7.542367   100
 suppressWarnings(f.main()) 3.005142 3.081811 3.133137 3.210126 5.363575   100
            f.main.direct() 1.279303 1.384521 1.413713 1.486853 5.684363   100
-------------------------------------------------------------------------------------------------------
cols <- c("LINE1"="#f04546","LINE2"="#3591d1","BAR"="#62c76b")
ggplot(data=data,aes(x=a)) + 
  geom_bar(stat="identity", aes(y=h, fill = "BAR"),colour="#333333")+ #green
  geom_line(aes(y=b,group=1, colour="LINE1"),size=1.0) +   #red
  geom_point(aes(y=b, colour="LINE1"),size=3) +           #red
  geom_errorbar(aes(ymin=d, ymax=e, colour="LINE1"), width=0.1, size=.8) + 
  geom_line(aes(y=c,group=1,colour="LINE2"),size=1.0) +   #blue 
  geom_point(aes(y=c,colour="LINE2"),size=3) +           #blue
  geom_errorbar(aes(ymin=f, ymax=g,colour="LINE2"), width=0.1, size=.8) + 
  scale_colour_manual(name="Error Bars",values=cols) + scale_fill_manual(name="Bar",values=cols) +
  ylab("Symptom severity") + xlab("PHQ-9 symptoms") +
  ylim(0,1.6) +
  theme_bw() +
  theme(axis.title.x = element_text(size = 15, vjust=-.2)) +
  theme(axis.title.y = element_text(size = 15, vjust=0.3)) + theme(legend.key = element_rect(fill = "white",colour = "white")) guide = guide_legend(fill = NULL,colour = NULL) ggplot(data=data,aes(x=a)) + 
  geom_bar(stat="identity", aes(y=h,fill = "BAR", colour="BAR"))+ #green
  geom_line(aes(y=b,group=1, colour="LINE1"),size=1.0) +   #red
  geom_point(aes(y=b, colour="LINE1", fill="LINE1"),size=3) +           #red
  geom_errorbar(aes(ymin=d, ymax=e, colour="LINE1"), width=0.1, size=.8) + 
  geom_line(aes(y=c,group=1,colour="LINE2"),size=1.0) +   #blue 
  geom_point(aes(y=c,colour="LINE2", fill="LINE2"),size=3) +           #blue
  geom_errorbar(aes(ymin=f, ymax=g,colour="LINE2"), width=0.1, size=.8) + 
  scale_colour_manual(name="Error Bars",values=cols, guide = guide_legend(fill = NULL,colour = NULL)) + 
  scale_fill_manual(name="Bar",values=cols, guide="none") +
  ylab("Symptom severity") + xlab("PHQ-9 symptoms") +
  ylim(0,1.6) +
  theme_bw() +
  theme(axis.title.x = element_text(size = 15, vjust=-.2)) +
  theme(axis.title.y = element_text(size = 15, vjust=0.3)) override.aes guide_legend ggplot(data=data,aes(x=a)) + 
  geom_bar(stat="identity", aes(y=h,fill = "BAR", colour="BAR"))+ #green
  geom_line(aes(y=b,group=1, colour="LINE1"),size=1.0) +   #red
  geom_point(aes(y=b, colour="LINE1", fill="LINE1"),size=3) +           #red
  geom_errorbar(aes(ymin=d, ymax=e, colour="LINE1"), width=0.1, size=.8) + 
  geom_line(aes(y=c,group=1,colour="LINE2"),size=1.0) +   #blue 
  geom_point(aes(y=c,colour="LINE2", fill="LINE2"),size=3) +           #blue
  geom_errorbar(aes(ymin=f, ymax=g,colour="LINE2"), width=0.1, size=.8) + 
  scale_colour_manual(name="Error Bars",values=cols, 
                      guide = guide_legend(override.aes=aes(fill=NA))) + 
  scale_fill_manual(name="Bar",values=cols, guide="none") +
  ylab("Symptom severity") + xlab("PHQ-9 symptoms") +
  ylim(0,1.6) +
  theme_bw() +
  theme(axis.title.x = element_text(size = 15, vjust=-.2)) +
  theme(axis.title.y = element_text(size = 15, vjust=0.3))
-------------------------------------------------------------------------------------------------------
som.prep.df som.prep.df <- function(som.model, obs.classes, scaled) {
  require(reshape2)
  lev <- factor(wine.classes)
  df <- data.frame(cbind(unit=som.model$unit.classif, class=as.integer(lev)))
  # create table
  df2 <- data.frame(table(df))
  df2 <- dcast(df2, unit ~ class, value.var="Freq")
  df2$unit <- as.integer(df2$unit)
  # calc sum
  df2$sum <- rowSums(df2[,-1])
  # calc fraction borders of classes in each node
  tmp <- data.frame(cbind(X0=rep(0,nrow(df2)), 
                          t(apply(df2[,-1], 1, function(x) {
                            cumsum(x[1:(length(x)-1)]) / x[length(x)]
                          }))))
  df2 <- cbind(df2, tmp)
  df2 <- melt(df2, id.vars=which(!grepl("^\\d$", colnames(df2))))
  df2 <- df2[,-ncol(df2)]
  # define border for each classs in each node
  tmp <- t(apply(df2, 1, function(x) {
    c(x[paste0("X", as.character(as.integer(x["variable"])-1))], 
      x[paste0("X", as.character(x["variable"]))])
  }))
  tmp <- data.frame(tmp, stringsAsFactors=FALSE)
  tmp <- sapply(tmp, as.numeric)
  colnames(tmp) <- c("ymin", "ymax")
  df2 <- cbind(df2, tmp)
  # scale size of pie charts
  if (is.logical(scaled)) {
    if (scaled) {
      df2$xmax <- log2(df2$sum)
    } else {
      df2$xmax <- df2$sum
    }
  }
  df2 <- df2[,c("unit", "variable", "ymin", "ymax", "xmax")]
  colnames(df2) <- c("unit", "class", "ymin", "ymax", "xmax")
  # replace classes with original levels names
  df2$class <- levels(lev)[df2$class]
  return(df2)
}

som.draw <- function(som.model, obs.classes, scaled=FALSE) {
  # scaled - make or not a logarithmic scaling of the size of each node
  require(ggplot2)
  require(grid)
  g <- som.model$grid
  df <- som.prep.df(som.model, obs.classes, scaled)
  df <- cbind(g$pts, df[,-1])
  df$class <- factor(df$class)
  g <- ggplot(df, aes(fill=class, ymax=ymax, ymin=ymin, xmax=xmax, xmin=0)) +
    geom_rect() +
    coord_polar(theta="y") +
    facet_wrap(x~y, ncol=g$xdim, nrow=g$ydim) + 
    theme(axis.ticks = element_blank(), 
          axis.text.y = element_blank(),
          axis.text.x = element_blank(),
          panel.margin = unit(0, "cm"),
          strip.background = element_blank(),
          strip.text = element_blank(),
          plot.margin = unit(c(0,0,0,0), "cm"),
          panel.background = element_blank(),
          panel.grid = element_blank())
  return(g)
} require(kohonen)
data(wines)
som.wines <- som(scale(wines), grid = somgrid(5, 5, "rectangular"))

# Non-scaled map
som.draw(som.wines, wine.classes) # Scaled map
som.draw(som.wines, wine.classes, TRUE)
-------------------------------------------------------------------------------------------------------
geom_rect Vehicles <- structure(list(Road = c(1L, 1L, 1L, 2L, 2L, 2L, 2L, 2L, 3L, 3L, 
1L, 1L, 1L, 2L, 2L, 2L, 2L, 3L, 3L, 3L, 1L, 1L, 1L, 2L, 2L, 2L, 
2L, 2L, 2L, 3L, 3L, 3L), Start = c(157398137L, 216984017L, 238298694L, 
0L, 8794530L, 59852594L, 206737339L, 218695178L, 96301465L, 116345621L, 
157398137L, 216984017L, 238298694L, 0L, 8794530L, 59852594L, 
206737339L, 3469683L, 96301465L, 116345621L, 157398137L, 216984017L, 
238298694L, 0L, 8794530L, 59852594L, 206737339L, 218695178L, 
231142027L, 3469683L, 96301465L, 116345621L), End = c(166811234L, 
238298694L, 247249719L, 8794530L, 26703134L, 73085123L, 218577503L, 
231142027L, 115456078L, 126898764L, 166811234L, 238298694L, 247249719L, 
8794530L, 26703134L, 73085123L, 218577503L, 56797911L, 115456078L, 
126898764L, 166811234L, 238298694L, 247249719L, 8794530L, 26703134L, 
73085123L, 218577503L, 231142027L, 241946296L, 56797911L, 115456078L, 
126898764L), Vehicle = c("1", "1", "1", "1", "1", "1", "1", "1", 
"1", "1", "2", "2", "2", "2", "2", "2", "2", "2", "2", "2", "3", 
"3", "3", "3", "3", "3", "3", "3", "3", "3", "3", "3")), .Names = c("Road", 
"Start", "End", "Vehicle"), row.names = c(NA, 32L), class = "data.frame")

set.seed(42)
Vehicles$overspeed <- runif(nrow(Vehicles),0,50)
Vehicles$overspeed <- cut(Vehicles$overspeed,c(0,20,30,Inf))

roads <- read.table(text="Road    Length
1   529290651
2   249139323
3   298024420",header=TRUE)

library(ggplot2)
p <- ggplot(Vehicles,aes(xmin=as.numeric(Vehicle)-0.4,
                         xmax=as.numeric(Vehicle)+0.4,
                         ymin=Start,ymax=End,fill=overspeed)) + 
  geom_rect() +
  facet_grid(Road~.,scales = "free_y") +
  #ugly hack to get correct road lengths:
  geom_rect(data=roads,aes(ymin=0,ymax=Length,xmin=0.4,xmax=1.4,fill=NA),alpha=0) + 
  scale_y_continuous(expand=c(0,1)) +
  xlab("Vehicle") +
  ylab("Distance") +
  theme_bw() +
  scale_fill_manual(values=c("(0,20]"="blue","(20,30]"="yellow","(30,Inf]"="red"))
print(p) p + scale_y_reverse(expand=c(0,1))
-------------------------------------------------------------------------------------------------------
geom_rect() plus_ minus_ max min df ggplot(df,aes(xmin=minus_age,xmax=plus_age,ymin=minus_error,ymax=plus_error))+
  geom_rect(fill="green",color="black")
-------------------------------------------------------------------------------------------------------
rasterImage image <- as.raster( matrix( seq(0,1,length.out=1001), nrow=1001, ncol=1001) )
tmp <- ( row(image) - 501 ) ^2 + ( col(image) - 501 )^2
image[tmp > 500^2] <- NA

image2 <- as.raster( matrix( seq(1,0, length.out=1001), nrow=1001, ncol=1001) )
image2[ tmp > 500^2 ] <- NA

image3 <- row(image) + col(image)
image3 <- image3/max(image3)
image3[tmp>500^2] <- NA
image4 <- 1-image3
image3 <- as.raster(image3)
image4 <- as.raster(image4)

plot( 0:1, 0:1, type='n', asp=1,ann=FALSE,axes=FALSE)
rect(0,0,1,1, col='grey')
rasterImage(image, 0.2, 0.2, 0.3, 0.3)
rasterImage(image2, 0.6, 0.6, 0.7, 0.7)
rasterImage(image3, 0.6, 0.3, 0.7, 0.4)
rasterImage(image4, 0.3, 0.7, 0.4, 0.8)
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(gridExtra)

set.seed(42)
DF <- data.frame(x=rnorm(100,mean=c(1,5)),y=rlnorm(100,meanlog=c(8,6)),group=1:2)

p1 <- ggplot(DF,aes(x=x,y=y,colour=factor(group))) + geom_point() +
  scale_x_continuous(expand=c(0.02,0)) +
  scale_y_continuous(expand=c(0.02,0)) +
  theme_bw() +
  theme(legend.position="none",plot.margin=unit(c(0,0,0,0),"points"))

theme0 <- function(...) theme( legend.position = "none",
                               panel.background = element_blank(),
                               panel.grid.major = element_blank(),
                               panel.grid.minor = element_blank(),
                               panel.margin = unit(0,"null"),
                               axis.ticks = element_blank(),
                               axis.text.x = element_blank(),
                               axis.text.y = element_blank(),
                               axis.title.x = element_blank(),
                               axis.title.y = element_blank(),
                               axis.ticks.length = unit(0,"null"),
                               axis.ticks.margin = unit(0,"null"),
                               panel.border=element_rect(color=NA),...)

p2 <- ggplot(DF,aes(x=x,colour=factor(group),fill=factor(group))) + 
  geom_density(alpha=0.5) + 
  scale_x_continuous(breaks=NULL,expand=c(0.02,0)) +
  scale_y_continuous(breaks=NULL,expand=c(0.02,0)) +
  theme_bw() +
  theme0(plot.margin = unit(c(1,0,0,2.2),"lines")) 

p3 <- ggplot(DF,aes(x=y,colour=factor(group),fill=factor(group))) + 
  geom_density(alpha=0.5) + 
  coord_flip()  + 
  scale_x_continuous(labels = NULL,breaks=NULL,expand=c(0.02,0)) +
  scale_y_continuous(labels = NULL,breaks=NULL,expand=c(0.02,0)) +
  theme_bw() +
  theme0(plot.margin = unit(c(0,1,1.2,0),"lines"))

grid.arrange(arrangeGrob(p2,ncol=2,widths=c(3,1)),
             arrangeGrob(p1,p3,ncol=2,widths=c(3,1)),
             heights=c(1,3)) p2 <- ggplot(DF,aes(x=x,colour=factor(group),fill=factor(group))) + 
  geom_density(alpha=0.5) + 
  scale_x_continuous(breaks=NULL,expand=c(0.02,0)) +
  scale_y_continuous(breaks=NULL,expand=c(0.00,0)) +
  theme_bw() +
  theme0(plot.margin = unit(c(1,0,-0.48,2.2),"lines")) 

p3 <- ggplot(DF,aes(x=y,colour=factor(group),fill=factor(group))) + 
  geom_density(alpha=0.5) + 
  coord_flip()  + 
  scale_x_continuous(labels = NULL,breaks=NULL,expand=c(0.02,0)) +
  scale_y_continuous(labels = NULL,breaks=NULL,expand=c(0.00,0)) +
  theme_bw() +
  theme0(plot.margin = unit(c(0,1,1.2,-0.48),"lines"))
-------------------------------------------------------------------------------------------------------
library(gtable)
library(ggplot2)
library(plyr)

set.seed(1)
d <- data.frame(x=rep(1:10, 5),
                y=rnorm(50),
                g = gl(5,10))

# example plot
p <- ggplot(d, aes(x,y,colour=g)) +
  geom_line() +
  scale_x_continuous(expand=c(0,0))+
  theme(legend.position="top",
        plot.margin=unit(c(1,0,0,0),"line"))

# dummy data for the legend plot
# built with the same y axis (same limits, same expand factor)
d2 <- ddply(d, "g", summarise, x=0, y=y[length(y)])
d2$lab <- paste0("line #", seq_len(nrow(d2)))

plegend <- ggplot(d, aes(x,y, colour=g)) +
  geom_blank() +
  geom_segment(data=d2, aes(x=2, xend=0, y=y, yend=y), 
               arrow=arrow(length=unit(2,"mm"), type="closed")) +
  geom_text(data=d2, aes(x=2.5,label=lab), hjust=0) +
  scale_x_continuous(expand=c(0,0)) +
  guides(colour="none")+
  theme_minimal() + theme(line=element_blank(),
                          text=element_blank(),
                          panel.background=element_rect(fill="grey95", linetype=2))

# extract the panel only, we don't need the rest
gl <- gtable_filter(ggplotGrob(plegend), "panel")

# add a cell next to the main plot panel, and insert gl there
g <- ggplotGrob(p)
index <- subset(g$layout, name == "panel")
g <- gtable_add_cols(g, unit(1, "strwidth", "line # 1") + unit(1, "cm"))
g <- gtable_add_grob(g, gl, t = index$t, l=ncol(g), 
                     b=index$b, r=ncol(g))
grid.newpage()
grid.draw(g)
-------------------------------------------------------------------------------------------------------
grid.grab() knitr grid.grab() ```{r first, tidy = FALSE}
library(grid)
grid.newpage()

## draw a rectangle around the root vp and provide some text
grid.rect()
grid.text("this is the root vp", x = 0.5, y = 1, just = c("centre", "top"))

vp <- viewport(x = 0.5, y = 0.5, 
               height = 0.5, width = 0.5,
               just = c("centre", "centre"), 
               name="first")

pushViewport(vp)

grid.rect(gp = gpar(fill = "pink"))
grid.text("this is our first vp", x = 0.5, y = 1, just = c("centre", "top"))
scene <- grid.grab()
```

```{r second, tidy = FALSE, fig.keep='last'}
grid.draw(scene)
seekViewport("first")
vp <- viewport(x = 0.5, y = 0.5, 
               height = 0.5, width = 0.5,
               just = c("centre", "centre"))

pushViewport(vp)

grid.rect(gp = gpar(fill = "cornflowerblue"))
``` ```{r second, tidy = FALSE}
<<first>>
vp <- viewport(x = 0.5, y = 0.5, 
               height = 0.5, width = 0.5,
               just = c("centre", "centre"))

pushViewport(vp)

grid.rect(gp = gpar(fill = "cornflowerblue"))
```
-------------------------------------------------------------------------------------------------------
+ scale_colour_gradient2(low="#22FF00", mid="white", high="#FF0000", midpoint=median(iris$Sepal.Length)) + theme(panel.grid=element_blank(), panel.background=element_rect(fill="black")) scale_color_gradient2 iris <- iris[with(iris, order(Sepal.Length)),]
iris$rank <- 1:150
ggplot(iris) + geom_point(aes(x=Sepal.Width, y=Sepal.Length, colour=rank)) + scale_colour_gradient2(low="#22FF00", mid="white", high="#FF0000", midpoint=median(iris$rank)) + theme(panel.grid=element_blank(), panel.background=element_rect(fill="black"))
-------------------------------------------------------------------------------------------------------
ggplot(df, aes(xmin = x, xmax = x + 1, ymin = y, ymax = y + 2)) +
  geom_rect(alpha=.2) + 
  geom_rect(data=data.frame(xmin=3, xmax=6, ymin=3, ymax=5), 
            aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymax), 
            fill="green", alpha=.2)
-------------------------------------------------------------------------------------------------------
ggplot() + 
  geom_density(data=mtcars, aes(x=disp, group=cyl, fill=cyl), alpha=0.6, adjust=0.75) +
  geom_rect(aes(xmin=100, xmax=200, ymin=0,ymax=Inf), alpha=0.2, fill="red") geom_density annotate ggplot(mtcars) + 
  geom_density(aes(x=disp, group=cyl, fill=cyl), alpha=0.6, adjust=0.75) + 
  annotate("rect", xmin=100, xmax=200, ymin=0, ymax=Inf, alpha=0.2, fill="red")
-------------------------------------------------------------------------------------------------------
feel_job geom_rect() geom_bar() xmin, xmax, ymin ymax # save the data we were given
a.survey.data <-survey_data

# going to plot this as rectangles
a.survey.data$xmin[a.survey.data$feel_job < 4] = -a.survey.data$Freq[a.survey.data$feel_job < 4]
a.survey.data$xmin[a.survey.data$feel_job == 4] = -a.survey.data$Freq[a.survey.data$feel_job == 4]/2
a.survey.data$xmin[a.survey.data$feel_job > 4] = 0

a.survey.data$xmax[a.survey.data$feel_job < 4] = 0
a.survey.data$xmax[a.survey.data$feel_job == 4] = a.survey.data$Freq[a.survey.data$feel_job == 4]/2
a.survey.data$xmax[a.survey.data$feel_job > 4] = a.survey.data$Freq[a.survey.data$feel_job > 4]

# assign values to ymin and ymax based on gender and 
y.base <- NA
y.base[a.survey.data$gender == "Female"] = 1
y.base[a.survey.data$gender == "Male"] = 2
y.base[a.survey.data$gender == "Unreported"] = 3

a.survey.data$ymin <- y.base + (a.survey.data$feel_job-4)*0.1 - 0.05
a.survey.data$ymax <- y.base + (a.survey.data$feel_job-4)*0.1 + 0.05

# set the labels
a.survey.data$feel_job.cut <- factor(cut(a.survey.data$feel_job,
                                         breaks = c(0.5,1.5,2.5,3.5,4.5,5.5,6.5,7.5),
                                         labels = c("1",
                                                    "2",
                                                    "3",
                                                    "neutral",
                                                    "5",
                                                    "6",
                                                    "7"),
                                         ordered = TRUE))

p2 <- ggplot(data = a.survey.data,
             aes(xmax = xmax,
                 xmin = xmin,
                 ymax = ymax,
                 ymin = ymin)) +
  geom_rect(aes(fill = feel_job.cut)) +  
  scale_y_continuous(limits = c(0.5,3.5),
                     breaks=c(1,2,3), 
                     labels=c("Female","Male","Unreported"))
print(p2)
-------------------------------------------------------------------------------------------------------
grid gridBase box grid.rect gridBase base library(gridBase)
sp <- baseViewports()
vp <- sp$plot
vp$width <- unit(0.999,'npc')
vp$y <- unit(0.001,'npc')
pushViewport(vp)
grid.rect(gp=gpar(fill=NA))
upViewport(1) grid.rect library(grid)
grid.rect(width = unit(0.999,'npc'),
          y = unit(0.5001, "npc"),
          gp=gpar(fill=NA))
-------------------------------------------------------------------------------------------------------
lin <- data.frame(x = c(0:6), y = c(0.3, 0.1, 0.9, 3.1, 5, 4.9, 6.2))
linm <- lm(y ~ x, data = lin, subset = 2:4)
plot(y ~ x, data = lin)
abline(linm)
rect(0,0,3,3, col=rgb(.5,.5,.5,.5),border=NA)
-------------------------------------------------------------------------------------------------------
bgColors <- c("black", "green4", "blue", "red", "purple", "yellow")
txtColors <- c("white", "yellow", "white", "white", "green", "red")
stripHt <- rep(c(-1,0),each = 3)

# Create a function to be passes to "strip=" argument of xyplot
myStripStyle <- function(which.panel, factor.levels, ...) {
    panel.rect(0, stripHt[which.panel], 1, 1,col = bgColors[which.panel],border = 1)
    panel.text(x = 0.5, y = 0.5,
               font=2,
               lab = factor.levels[which.panel],
               col = txtColors[which.panel])
}    
xyplot(yield ~ year | site, data = barley, strip=myStripStyle)
-------------------------------------------------------------------------------------------------------
plot1 <- ggplot(data=df, aes(x=xval, y=yval, group=cond, colour=cond) ) +
         geom_smooth(aes(ymin = yval-se, ymax = yval+se,
                     linetype=cond, colour=cond, fill=cond), stat="identity",
                     size=1.1) +
         scale_colour_hue(l=25) +
         ylim(-0.1,1.3) + scale_linetype_manual(values = c('a' = 1,'b' = 2))

plot1 + facet_grid(~ zval, scales="free_y") + 
theme(strip.text.x = element_blank(),
      strip.background = element_rect(colour="white", fill="white"),
      legend.position=c(.9,.75)
      )
-------------------------------------------------------------------------------------------------------
grid_legend <- function (x, y, pch = NA, col = par('col'), labels, frame = TRUE, 
  hgap = unit(0.8, "lines"), vgap = unit(0.8, "lines"), default_units = "lines", 
  gp = gpar(), draw = TRUE, title = NULL, just = 'center', lwd = NA, lty = NA, 
  gp.title = NULL, gp.labels = NULL, gp.frame = gpar(fill = "transparent")) 
{

  if(is.character(x))
    switch(x,
           topleft = {x = unit(0,'npc'); y = unit(1,'npc'); just = c(0,1)},
           topright = {x = unit(1,'npc'); y = unit(1,'npc'); just = c(1,1)},
           bottomright = {x = unit(1,'npc'); y = unit(0,'npc'); just = c(1,0)},
           bottomleft = {x = unit(0,'npc'); y = unit(0,'npc'); just = c(0,0)})

  labels <- as.character(labels)
  nlabs <- length(labels)

  if(length(pch) == 1)
    pch <- rep(pch, nlabs)
  if(length(lwd) == 1)
    lwd <- rep(lwd, nlabs)
  if(length(lty) == 1)
    lty <- rep(lty, nlabs)
  if(length(col) == 1)
    col <- rep(col, nlabs)
  if(length(gp.labels) == 1)
    gp.labels <- rep(list(gp.labels), nlabs)


  if (is.logical(title) && !title) 
    title <- NULL
  ifelse(is.null(title), tit <- 0, tit <- 1)

  if (!is.unit(hgap)) 
    hgap <- unit(hgap, default_units)
  if (length(hgap) != 1) 
    stop("hgap must be single unit")
  if (!is.unit(vgap)) 
    vgap <- unit(vgap, default_units)
  if (length(vgap) != 1) 
    stop("vgap must be single unit")

  if(tit)
    legend.layout <- grid.layout(nlabs + tit, 3,
                                 widths = unit.c(unit(2, "lines"),
                                 max(unit(rep(1, nlabs), "strwidth", as.list(c(labels))),
                                 unit(1, "strwidth", title) - unit(2, "lines")), hgap),
                                 heights = unit.pmax(unit(1, "lines"),
                                 vgap + unit(rep(1, nlabs + tit ),
                                           "strheight", as.list(c(labels,title)))))
  else
     legend.layout <- grid.layout(nlabs, 3, widths = unit.c(unit(2, 
      "lines"), max(unit(rep(1, nlabs), "strwidth", as.list(labels))), 
      hgap), heights = unit.pmax(unit(1, "lines"), vgap + unit(rep(1, 
      nlabs), "strheight", as.list(labels))))

  fg <- frameGrob(layout = legend.layout, gp = gp)

  if (tit)
    fg <- placeGrob(fg, textGrob(title, x = .2, y = 0.5, just = c("left", "center"), gp = gp.title), col = 1, row = 1)

  for (i in 1:nlabs) {
    if(!is.na(pch[i]))
      fg <- placeGrob(fg, pointsGrob(0.5, 0.5, pch = pch[i], gp = gpar(col = col[i])), col = 1, row = i + tit)
      else if(!is.na(lwd[i]) || !is.na(lty[i]))
        fg <- placeGrob(fg, linesGrob( unit(c(0.2, .8), "npc"),  unit(c(.5), "npc"), 
                                gp = gpar(col = col[i], lwd = lwd[i], lty=lty[i])), col = 1, row = i + tit)

    fg <- placeGrob(fg, textGrob(labels[i], x = .1, y = 0.5, just = c("left", "center"), gp = gp.labels[[i]]), col = 2, row = i + tit)
  }

  pushViewport(viewport(x, y, height = grobHeight(fg), width = grobWidth(fg), just = just ))

  if (frame) 
    fg <- placeGrob(fg, rectGrob(gp = gp.frame))
  if (draw) 
    grid.draw(fg)
  popViewport(1)
  invisible(fg)
} require(grid)
png("grid_legend.png", 500, 400)
grid.newpage()
pushViewport(viewport(height = .9, width = .9 ))
grid.rect(gp = gpar(lwd = 2, lty = 2))

grid_legend(x = unit(.05,'npc'),
            y = unit(.05,'npc'),
            just = c(0,0),
            pch = c(1,2,3),
            col = c(1,2,3),
            lwd=NA, 
            lty=NA,
            labels = c("b",'r','g'),
            title = NULL,
            gp=gpar(lwd=2, cex=1),
            hgap = unit(.8, "lines"),
            vgap = unit(.9, "lines"))

grid_legend(x = unit(1,'npc'),
            y = unit(1,'npc'),
            just = c(1,1),
            pch = NA,
            col = c(1,2,3,4),
            lwd=c(1,1,1,3), 
            lty=c(1,2,1,3),
            labels = c("black",'red','green','blue'),
            gp.labels = list(gpar(col = 1), gpar(col = 2), 
                             gpar(col = 3), gpar(col = 4)),
            title = NULL,
            gp=gpar(lwd=2, cex=1),
            hgap = unit(.8, "lines"),
            vgap = unit(.9, "lines"))

grid_legend(x = 'topleft',
            pch = c(1,NA,2,NA),
            col = c(1,2,3,4),
            lwd=NA, 
            lty=c(NA,2,NA,3),
            labels = c("black",'red','green','blue'),
            title = 'Some LONG Title',
            gp.title = gpar(col = 3),
            gp.frame = gpar(col = 4, lty = 2, fill = "transparent"),
            gp.labels = gpar(col = 6),
            gp=gpar(lwd=2, cex=2, col = 1),
            hgap = unit(.8, "lines"),
            vgap = unit(.9, "lines"))


grid_legend(x = .7,
            y = .7,
            pch = c(1,NA,2,NA),
            col = c(1,2,3,4),
            lwd=1, 
            lty=c(NA,2,NA,3),
            labels = c("black",'red','green','blue'),
            title = 'short T',
            gp=gpar(lwd=1, cex=.7,col = 1),
            hgap = unit(.8, "lines"),
            vgap = unit(.9, "lines"))

grid_legend(x = 'bottomright',
            pch = c(1,NA,2,NA),
            col = c(2),
            lwd=NA, 
            lty=c(NA,2,NA,3),
            labels = c("black",'red','green','blue'),
            title = NULL,
            gp=gpar(lwd=2, cex=1,col = 1),
            hgap = unit(.8, "lines"),
            vgap = unit(.9, "lines"))
dev.off()
-------------------------------------------------------------------------------------------------------
data.frame geom_rect fill dd <- structure(list(xmin = structure(c(11382, 13848), class = "Date"), 
    xmax = structure(c(11656, 14425), class = "Date"), ymin = c(-Inf, 
    -Inf), ymax = c(Inf, Inf), fill = c("a", "a")), .Names = c("xmin", 
"xmax", "ymin", "ymax", "fill"), row.names = 1:2, class = "data.frame")

> dd
        xmin       xmax ymin ymax fill
1 2001-03-01 2001-11-30 -Inf  Inf    a
2 2007-12-01 2009-06-30 -Inf  Inf    a

ggplot() + geom_rect(data=dd, aes(xmin=xmin, xmax=xmax, 
    ymin=ymin, ymax=ymax, fill=fill), alpha=0.2) + 
    geom_line(data=values.melted, aes(x=Date, y=value, color=Series), 
    size=2) + labs(x= "Date", y = "Case-Shiller Index Value") + 
    scale_fill_manual(name = "", values="black", label="US Recessions")
-------------------------------------------------------------------------------------------------------
geom_rect aes() fill geom_rect scale_fill_manual() ggplot() + 
  geom_rect(aes(xmin=c(as.Date("2001-03-01"),as.Date("2007-12-01")), 
                xmax=c(as.Date("2001-11-30"),as.Date("2009-06-30")),
                ymin=c(-Inf, -Inf), ymax=c(Inf, Inf),
                fill = "US Recessions"),alpha=0.2) +
  scale_fill_manual("", breaks = "US Recessions", values ="black")+
  geom_line(data=values.melted, aes(x=Date, y=value, color=Series), size=2) + 
  labs(x= "Date", y="Case-Shiller Index Value")
-------------------------------------------------------------------------------------------------------
axis.text.x library(ggplot2)
library(grid)

## create some data with asymmetric fill aes to generalize solution 
data <- read.table(text = "Group Category Value
                   S1 A   73
                   S2 A   57
                   S3 A   57
                   S4 A   57
                   S1 B   7
                   S2 B   23
                   S3 B   57
                   S1 C   51
                   S2 C   57
                   S3 C   87", header=TRUE)

# user-level interface 
axis.groups = function(groups) {
  structure(
    list(groups=groups),
    ## inheritance since it should be a element_text
    class = c("element_custom","element_blank")  
  )
}
# returns a gTree with two children: 
# the categories axis
# the groups axis
element_grob.element_custom <- function(element, x,...)  {
  cat <- list(...)[[1]]
  groups <- element$group
  ll <- by(data$Group,data$Category,I)
  tt <- as.numeric(x)
  grbs <- Map(function(z,t){
    labs <- ll[[z]]
    vp = viewport(
             x = unit(t,'native'), 
             height=unit(2,'line'),
             width=unit(diff(tt)[1],'native'),
             xscale=c(0,length(labs)))
    grid.rect(vp=vp)
    textGrob(labs,x= unit(seq_along(labs)-0.5,
                                'native'),
             y=unit(2,'line'),
             vp=vp)
  },cat,tt)
  g.X <- textGrob(cat, x=x)
  gTree(children=gList(do.call(gList,grbs),g.X), cl = "custom_axis")
}

## # gTrees don't know their size 
grobHeight.custom_axis = 
  heightDetails.custom_axis = function(x, ...)
  unit(3, "lines")

## the final plot call
ggplot(data=data, aes(x=Category, y=Value, fill=Group)) + 
  geom_bar(position = position_dodge(width=0.9),stat='identity') +
  geom_text(aes(label=paste(Value, "%")),
            position=position_dodge(width=0.9), vjust=-0.25)+
  theme(axis.text.x = axis.groups(unique(data$Group)),
        legend.position="none")
-------------------------------------------------------------------------------------------------------
library(scales)
ggplot(f1, aes(x=V,y=EFAnoxE3, colour=NormaGEuro3))+
geom_point(size=4)+
  stat_function(fun = m5noxe3, size=1, colour="green")+
  stat_function(fun = c4noxe3, size=1, colour="green")+
  stat_function(fun = unoxe3, size=1, colour="red")+
scale_colour_manual(values = c("green", "blue", "green","red"),
                      name = "",
                      labels = c("MODEM 5 Euro 3","HBEFA 3 Euro 3", "COPERT 4 Euro 3","UNTEC Euro 3"))+
theme(plot.title = element_text(lineheight=.8, face="bold"),
axis.text.x=element_text(size=12, face="bold"),
axis.text.y=element_text(size=12, face="bold"),
legend.position=c(1,0.82),legend.justification=c(1,1),
legend.background = element_rect(fill=alpha("grey", 0.2)))+
ggtitle("Factores de Emisin NOx Vehiculos \n Particulares Gasolineros (g/km)")+
ylab("(g/km)") +
xlab("Velocidad Promedio (km/h)")+
annotate("rect", xmin = 25, xmax = 35, ymin = 0, ymax = 0.6, alpha = .2)
-------------------------------------------------------------------------------------------------------
colour # Add category column to data.frames, then combine.
v1$category = "A"
v2$category = "B"
v3 = rbind(v1, v2)

p1 = ggplot(v3, aes(x=Var1, y=Var2, z=value, colour=category)) +
     stat_contour(binwidth=10) +
     theme(panel.background=element_rect(fill="grey90")) +
     theme(panel.grid=element_blank()) +
     labs(title="Plot 1")

p2 = ggplot(v3, aes(x=Var1, y=Var2, z=value, colour=category)) +
     stat_contour(aes(alpha=..level..), binwidth=10) +
     theme(panel.background=element_rect(fill="white")) +
     theme(panel.grid=element_blank()) +
     labs(title="Plot 2")

p3 = ggplot(v3, aes(x=Var1, y=Var2, z=value, group=category)) +
     stat_contour(aes(color=..level..), binwidth=10) +
     scale_colour_gradient(low="white", high="#A1CD3A") +
     theme(panel.background=element_rect(fill="grey50")) +
     theme(panel.grid=element_blank()) +
     labs(title="Plot 3")

p4 = ggplot(v3, aes(x=Var1, y=Var2, z=value, linetype=category)) +
     stat_contour(aes(color=..level..), binwidth=10) +
     scale_colour_gradient(low="white", high="#A1CD3A") +
     theme(panel.background=element_rect(fill="grey50")) +
     theme(panel.grid=element_blank()) +
     labs(title="Plot 4")

library(gridExtra)
ggsave(filename="plots.png", height=8, width=10,
       plot=arrangeGrob(p1, p2, p3, p4, nrow=2, ncol=2)) aes(colour=category) ..level.. aes(group=category)
-------------------------------------------------------------------------------------------------------
ggplot2 geom_tile theme(panel.grid.major = element_blank()) + theme(panel.grid.minor = element_blank()) + geom_text png() width height library(ggplot2)
library(reshape)
library(scales)

set.seed(1234)
num.els <- 5
mydf <- data.frame(category1 = rep(LETTERS[1:num.els], 1, each = num.els),
                   category2 = rep(1:num.els, num.els),
                   value = runif(num.els^2, 0, 100))

p <- ggplot(mydf, aes(x = category1,
                      y = category2,
                      fill = value)) +
    geom_tile() +
    geom_text(label = round(mydf$value, 2), size = 4, colour = "black") +
    scale_fill_gradient2(low = "blue", high = "red",
                         limits = c(min(mydf$value), max(mydf$value)),
                         midpoint = median(mydf$value)) +
    scale_x_discrete(expand = c(0,0)) +
    scale_y_reverse() +
    theme(panel.grid.minor = element_blank()) +
    theme(panel.grid.major = element_blank()) +
    theme(axis.ticks = element_blank()) +
    theme(panel.background = element_rect(fill = "transparent"))+
    theme(legend.position = "none") +
    theme()

print(p)
-------------------------------------------------------------------------------------------------------
ggplot2 data.table geom_text pvalue require(data.table)
dt <- data.table(df)
pval <- dt[, list(pvalue = paste0("pval = ", sprintf("%.3f", 
        summary(aov(x ~ type))[[1]][["Pr(>F)"]][1]))), 
        by=list(country, month)]

ggplot(data = df, aes(x=type, y=x)) + geom_boxplot() + 
geom_text(data = pval, aes(label=pvalue, x="river", y=2.5)) + 
facet_grid(country ~ month) + theme_bw() + 
theme(panel.margin=grid::unit(0,"lines"), # thanks to @DieterMenne
strip.background = element_rect(fill = NA), 
panel.grid.major = element_line(colour=NA), 
panel.grid.minor = element_line(colour=NA))
-------------------------------------------------------------------------------------------------------
coord_flip() plot <- ggplot(aes(y = SCORE, x = DATE, fill = CATEGORY), data = data_R1000) 
+ geom_boxplot(width=0.8) + ylim(20,100) + labs(title = "US_MARKETOR") 
+ theme(legend.position="bottom") 
+ theme(panel.background = element_rect(fill = "transparent",colour = NA)) 
+ theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) 
+ scale_fill_hue(c=50, l=85) 
+ coord_flip()
-------------------------------------------------------------------------------------------------------
dd <- data.frame(vs = c(0,1), ff = factor(0:1))
ggplot() + geom_rect(data=dd, aes(fill=ff), 
    xmin=-Inf, xmax=Inf, ymin=-Inf, ymax=Inf, alpha=0.15) + 
    geom_bar(data = mtcars, aes(factor(cyl))) + facet_grid(. ~ vs) + 
    scale_fill_manual(values=c(NA, "red"), breaks=NULL)
-------------------------------------------------------------------------------------------------------
grid.newpage()
grid.rect()
pushViewport(viewport(layout=grid.layout(3, 1)))


do_treemap <- function(ind){
    vp <- viewport(layout.pos.col=1, layout.pos.row=ind)
    pushViewport(vp)
    treemap(business, index=c("NACE1", "NACE2", "NACE3"), vSize="turnover", type="index",vp=vp)
    popViewport()
    popViewport() #treemap doees not seem to pop corretly
    popViewport() #and one more!
}

lapply(1:3, do_treemap)
-------------------------------------------------------------------------------------------------------
df<-data.frame(xmin=as.Date(c('1970-01-01','1990-01-01')),
               xmax=as.Date(c('1980-01-01','2000-01-01')),
               ymin=c(-Inf,-Inf),
               ymax=c(Inf,Inf),
               years=c("1970s","1990s")) geom_rect() ggplot(data=economics, mapping=aes(x=date, y=unemploy)) +
  geom_line(size=1)+
  geom_rect(data=df,aes(xmin=xmin,ymin=ymin,xmax=xmax,ymax=ymax,fill=years),
                    alpha=0.2,inherit.aes=FALSE)+
  scale_fill_manual(values=c("red","green"))
-------------------------------------------------------------------------------------------------------
scale_x_discrete(labels=national.fare.long$Year_Quarter_lab) library(reshape)
library(ggplot2)
national.fare <- read.csv("http://www.rita.dot.gov/bts/airfares/national/csv", 
              header = TRUE)[ , 1:4]

names(national.fare) <- c("Year", "Quarter", "US_Average_Current", "US_Average_Inflation-Adjusted")

# Convert Year and Quarter as characters
national.fare$Year <- as.character(national.fare$Year)
national.fare$Quarter <- as.character(national.fare$Quarter)

# Convert to Long-version
national.fare.long <- melt(national.fare, measure.vars = c("US_Average_Current", "US_Average_Inflation-Adjusted"))

# Combine Year and Quarter for Graph
national.fare.long$Year_Quarter <- as.character(paste(national.fare.long$Year, "Q", national.fare.long$Quarter, sep = ""))
# Create a vector of labels with every fourth label
skip <- 0:(dim(national.fare.long)[1]-1)%%4
national.fare.long$Year_Quarter_lab <- ifelse(skip==0,as.character(paste(national.fare.long$Year, "\nQ", national.fare.long$Quarter, sep = "")),"")


# Chart: National Average Domestic Fare Current and Inflation-Adjusted

p <- ggplot(national.fare.long, aes(x = Year_Quarter, y = value, group = variable))

p + geom_line(aes(color = variable), size = 1.5) +
  scale_color_manual(values = c("navy", "red")) +
  scale_x_discrete(labels=national.fare.long$Year_Quarter_lab) +
  ylim(250, 500) +
  ggtitle("National Average Domestic Fare 1995 - 2013") +
  xlab("Year-Quarter") +
  ylab("Average Domestic Fare") +
  theme(legend.position = "top", 
        legend.key = element_rect(fill = "transparent", color = NA),
        legend.title = element_blank(),
        axis.title = element_text(family = "sans", color = "grey50", face = "bold"),
        axis.line.x = element_line(color = "grey"),
        axis.text.y = element_text(family = "sans"),
        axis.text.x = element_text(family = "sans", face = "plain", hjust = .5, vjust = 1, angle = 0),
        axis.ticks.x = element_line(),
        panel.grid.major.y = element_line(color = "grey", size = 0.5, linetype = "dashed"),
        panel.background = element_rect(fill = "transparent", color = NA),
        plot.background = element_rect(fill = "transparent", color = NA),
        plot.title = element_text(family = "sans", size = 18, face = "bold"))
-------------------------------------------------------------------------------------------------------
library(gsubfn)
national.fare.long$Year_Q_Date <- gsubfn("Q.*", 
    list('Q1' = '-01-01', 'Q2' = '-04-01', 'Q3' = '-06-01', 'Q4' = '-10-01'), 
    national.fare.long$Year_Quarter)
national.fare.long$Year_Q_Date <- as.Date(national.fare.long$Year_Q_Date)
firstObs <- national.fare.long$Year_Q_Date[1]
lastObs <- national.fare.long$Year_Q_Date[length(national.fare.long$Year_Q_Date)] dateticks <- seq(firstObs, lastObs, by="8 month") library(scales)

p <- ggplot(national.fare.long, aes(x = Year_Q_Date, y = value, group = variable))

p + geom_line(aes(color = variable), size = 1.5, ) +
  scale_color_manual(values = c("navy", "red")) +
  ylim(250, 500) +
  ggtitle("National Average Domestic Fare 2001 - 2012") +
  xlab("Year-Quater") +
  ylab("Average Domestic Fare") +
  scale_x_date(breaks=dateticks, labels=date_format("%Y %b")) +
  theme(legend.position = "top", 
      legend.key = element_rect(fill = "transparent", color = NA),
      legend.title = element_blank(),
      axis.title = element_text(family = "sans", color = "grey50", face = "bold"),
      axis.line.x = element_line(color = "grey"),
      axis.text.y = element_text(family = "sans"),
      axis.text.x = element_text(family = "sans", face = "plain", hjust = 0, vjust = 1, angle = 285),
      axis.ticks.x = element_line(),
      panel.grid.major.y = element_line(color = "grey", size = 0.5, linetype = "dashed"),
      panel.background = element_rect(fill = "transparent", color = NA),
      plot.background = element_rect(fill = "transparent", color = NA),
      plot.title = element_text(family = "sans", size = 18, face = "bold"))
-------------------------------------------------------------------------------------------------------
xyplot( 
    rnorm(100) ~ 1:100, type="l", col="black",
    panel=function (x,y,...){
    panel.rect(xleft=45, xright=65,ybottom=-3, ytop=3,col="grey")
    panel.xyplot(x,y,...)
    }
  ) panel.rect() rect() xyplot() ybottom ytop
-------------------------------------------------------------------------------------------------------
trellis.focus("panel", 1, 1)
grid.rect(x =.55, , y=.5, w = .2, height=6,  gp = gpar(fill = "light grey"))
trellis.unfocus() grid.rect panel.rect xyplot
-------------------------------------------------------------------------------------------------------
library(grid)

gt <- grobTree(linesGrob(x=c(0.2, 0.8), y=.5,  gp=gpar(col="grey", lwd=10)),
               textGrob("some label",  gp=gpar(cex=2)),
               cl = "mygrob")

widthDetails.mygrob <- function(x)
  do.call(max, lapply(x$children, grobWidth))


heightDetails.mygrob <- function(x)
  do.call(max, lapply(x$children, grobHeight))

grid.newpage()
grid.draw(gt)
grid.rect(width=grobWidth(gt), height=grobHeight(gt), gp=gpar(col="red"))
-------------------------------------------------------------------------------------------------------
data.frame dat <- data.frame(x1=c(1,27),x2=c(27,155),y=c(0.05325728,0.05179712))
#  x1  x2          y
#1  1  27 0.05325728
#2 27 155 0.05179712

# specify a height for the rectangles
hght <- 0.01

with(dat,plot(NA,xlim=c(min(x1),max(x2)),ylim=c(min(y),max(y)+hght),type="n"))
with(dat,rect(x1,y,x2,y+hght))
-------------------------------------------------------------------------------------------------------
'opts' is deprecated. Use 'theme' instead. (Deprecated; last used in version 0.9.1)
theme_rect is deprecated. Use 'element_rect' instead. (Deprecated; last used in version 0.9.1) theme() opts() ggplot(data = dat, aes(x = item, y = value, ymin = 0, ymax = value)) +
  geom_point(colour = "blue") + 
  geom_linerange(colour = "blue") + 
  facet_wrap(~draw, ncol = 5) + 
  scale_y_continuous(lim = c(0, 1)) +
  theme_bw() +
  theme(panel.border = element_rect(colour = "black")) scales ?facet_wrap coord_cartesian scale_y_continuous
-------------------------------------------------------------------------------------------------------
week.f "%U" "%W" dow ggplot library(ggplot2)

input <- as.Date("2013-09-11") # input date

st <- as.Date(cut(input, "month")) # calculate start of month
dates31 <- st + 0:30 # st and next 30 dates (31 in all)
dates <- dates31[months(dates31) == months(st)] # keep only dates in st's month

week.ch <- format(dates, "%U") # week numbers

mydf <- data.frame(
   day = as.numeric(format(dates, "%d")),
   week.f = factor(week.ch, rev(unique(week.ch))),
   dow = factor(format(dates, "%a"), c("Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"))
)

ggplot(mydf, aes(x = dow, y = week.f)) +
    geom_tile(colour = "black", fill = "white") +
    geom_text(label = mydf$day, size = 4) + 
    scale_x_discrete(expand = c(0,0)) +
    theme(axis.ticks = element_blank()) +
    theme(axis.title = element_blank()) +
    theme(panel.background = element_rect(fill = "transparent"))+
    theme(legend.position = "none") cal
-------------------------------------------------------------------------------------------------------
levels(mydf$dow) <- c('Mon','Tue','Wed','Thu','Fri','Sat','Sun') mydf$dow levels "Fri" "Mon" "Sat" "Sun" "Thu" "Tue" "Wed" 'Mon','Tue','Wed','Thu','Fri','Sat','Sun' mydf mydate month week day dow
1  2013-09-01     9   35   1 Thu
2  2013-09-02     9   36   2 Tue
3  2013-09-03     9   36   3 Sat
4  2013-09-04     9   36   4 Sun
5  2013-09-05     9   36   5 Fri
6  2013-09-06     9   36   6 Mon
7  2013-09-07     9   36   7 Wed require(ggplot2)
require(scales)
require(lubridate)


date.start <- as.Date('2013-09-01')
date.end <- date.start + months(1)

mydf <- data.frame(mydate = seq(as.Date(date.start),
                                as.Date(date.end) - days(1),
                                by = 'day'))

mydf$month <- month(mydf$mydate)
mydf$week <- week(mydf$mydate)
mydf$day <- day(mydf$mydate)
mydf$dow <- as.factor(format(mydf$mydate, format = "%a"))

mydf$dow <- factor(mydf$dow, levels=c('Mon','Tue','Wed','Thu','Fri','Sat','Sun'))

ggplot(mydf, aes(x = dow, y = as.factor(week))) +
  geom_tile(colour = "black", fill = "white", label = mydf$day) +
  geom_text(label = mydf$day, size = 4, colour = "black") +
  scale_x_discrete(expand = c(0,0)) +
  theme(axis.ticks = element_blank()) +
  theme(axis.title.y = element_blank()) +
  theme(axis.title.x = element_blank()) +
  theme(panel.background = element_rect(fill = "transparent"))+
  theme(legend.position = "none") +
  theme()
-------------------------------------------------------------------------------------------------------
x <- seq(-2, 2, 0.01)
y <- seq(-2, 2, 0.01)

plot(x,y, xlim = c(-2,2), ylim=c(-2,2), type='n', asp = 1)
curve((  1 * (4 - x^2)^0.5 ), add=TRUE, from=-2 , to =2)
curve(( -1 * (4 - x^2)^0.5 ), add=TRUE, from=-2 , to =2)
rect(-2,-2,2,2)

# to fill circle and square
plot(x,y, xlim = c(-2,2), ylim=c(-2,2), type='n', asp = 1)
x2 <- c(seq(-2, 2, 0.01), seq(-2, 2, 0.01))
y2 <- c((  1 * (4 - x2[1:401]^2)^0.5 ), ( -1 * (4 - x2[402:802]^2)^0.5 ))
rect(-2,-2,2,2, col = 'red')
polygon(x2,y2, col = 'green', border = NA) circle.square.function <- function(radius, x.midpoint, y.midpoint, 
                                   my.x.lim, my.y.lim) {

  x <- seq(x.midpoint-radius, x.midpoint+radius, 0.01)
  y <- seq(y.midpoint-radius, y.midpoint+radius, 0.01)

  plot(x,y, xlim = my.x.lim, ylim = my.y.lim, type='n', asp = 1)
  curve((  1 * (radius^2 - (x - x.midpoint)^2)^0.5 + y.midpoint), add=TRUE, 
                from = (x.midpoint-radius) , to = (x.midpoint+radius))
  curve(( -1 * (radius^2 - (x - x.midpoint)^2)^0.5 + y.midpoint), add=TRUE, 
                from = (x.midpoint-radius) , to = (x.midpoint+radius))
  rect((x.midpoint-radius),(y.midpoint-radius),
       (x.midpoint+radius),(y.midpoint+radius))

}

radius     <-  10          # radius of circle
x.midpoint <- 150          # center of circle on x-axis
y.midpoint <-  50          # center of circle on y-axis
my.x.lim   <- c(-100,200)  # x-axis to plot
my.y.lim   <- c(   0,200)  # y-axis to plot

circle.square.function(radius, x.midpoint, y.midpoint, my.x.lim, my.y.lim)
-------------------------------------------------------------------------------------------------------
aes geom_rect Dates$disp[1] print(  ggplot(mpgData,aes(disp,hp))+
        geom_point(shape=17,color="black",size=2) +
        geom_rect(xmin=Dates$disp[1], xmax=200, ymin=0, ymax=Inf,fill = "aquamarine",alpha=0.01) 
)
-------------------------------------------------------------------------------------------------------
corrgram set.seed(42)
library(corrgram)

# This panel adds significance starts, or NS for not significant
panel.signif <-  function (x, y, corr = NULL, col.regions, digits = 2, cex.cor, 
                           ...) {
  usr <- par("usr")
  on.exit(par(usr))
  par(usr = c(0, 1, 0, 1))
  results <- cor.test(x, y, alternative = "two.sided")
  est <- results$p.value
  stars <- ifelse(est < 5e-4, "***", 
                  ifelse(est < 5e-3, "**", 
                         ifelse(est < 5e-2, "*", "NS")))
  cex.cor <- 0.4/strwidth(stars)
  text(0.5, 0.5, stars, cex = cex.cor)
}

# This panel combines edits the "shade" panel from the package
# to overlay the correlation value as requested
panel.shadeNtext <- function (x, y, corr = NULL, col.regions, ...) 
{
  if (is.null(corr)) 
    corr <- cor(x, y, use = "pair")
  ncol <- 14
  pal <- col.regions(ncol)
  col.ind <- as.numeric(cut(corr, breaks = seq(from = -1, to = 1, 
                                               length = ncol + 1), include.lowest = TRUE))
  usr <- par("usr")
  rect(usr[1], usr[3], usr[2], usr[4], col = pal[col.ind], border = NA)
  box(col = "lightgray")
  on.exit(par(usr))
  par(usr = c(0, 1, 0, 1))
  r <- formatC(corr, digits = 2, format = "f")
  cex.cor <- .8/strwidth("-X.xx")
  text(0.5, 0.5, r, cex = cex.cor)
}

# Generate some sample data
sample.data <- matrix(rnorm(100), ncol=10)

# Call the corrgram function with the new panel functions
# NB: call on the data, not the correlation matrix
corrgram(sample.data, type="data", lower.panel=panel.shadeNtext, 
         upper.panel=panel.signif) corrplot panel.shadeNtext <- function (x, y, corr = NULL, col.regions, ...) 
{
  corr <- cor(x, y, use = "pair")
  results <- cor.test(x, y, alternative = "two.sided")
  est <- results$p.value
  stars <- ifelse(est < 5e-4, "***", 
                  ifelse(est < 5e-3, "**", 
                         ifelse(est < 5e-2, "*", "")))
  ncol <- 14
  pal <- col.regions(ncol)
  col.ind <- as.numeric(cut(corr, breaks = seq(from = -1, to = 1, 
                                               length = ncol + 1), include.lowest = TRUE))
  usr <- par("usr")
  rect(usr[1], usr[3], usr[2], usr[4], col = pal[col.ind], border = NA)
  box(col = "lightgray")
  on.exit(par(usr))
  par(usr = c(0, 1, 0, 1))
  r <- formatC(corr, digits = 2, format = "f")
  cex.cor <- .8/strwidth("-X.xx")
  fonts <- ifelse(stars != "", 2,1)
  # option 1: stars:
  text(0.5, 0.4, paste0(r,"\n", stars), cex = cex.cor)
  # option 2: bolding:
  #text(0.5, 0.5, r, cex = cex.cor, font=fonts)
}

# Generate some sample data
sample.data <- matrix(rnorm(100), ncol=10)

# Call the corrgram function with the new panel functions
# NB: call on the data, not the correlation matrix
corrgram(sample.data, type="data", lower.panel=panel.shadeNtext, 
         upper.panel=NULL)
-------------------------------------------------------------------------------------------------------
ggplot(cpu, aes(Date, Pc, group=1)) + 
    geom_rect(data=cpu,xmin=as.numeric(as.Date(c("2011-10-10"))), 
        xmax=as.numeric(as.Date(c("2013-08-11"))), ymin=0, ymax=Inf,fill = "blue",alpha = 0.01) +
    geom_point() + 
    geom_smooth(method="loess", size=1, colour="blue") + 
    theme_bw() + 
    scale_x_date(breaks = "3 weeks",minor_breaks="1 weeks",labels=date_format("%m/%d/%y")) + 
    theme(axis.text.x = element_text(angle=60, hjust=1)) geom_rect
-------------------------------------------------------------------------------------------------------
geom_bar df.year <- data.frame(yeardate = seq(as.Date("2010-07-01"), 
                                     by = "year", 
                                     length.out = 3), 
                      datevalue = abs(rnorm(3))) df.year <- data.frame(yearstart = seq(as.Date("2010-01-01"), 
                                      by = "year", length.out = 3),
                      yearend = seq(as.Date("2010-12-31"), 
                                    by = "year", length.out = 3),
                      datevalue = abs(rnorm(3))) geom_bar p <- p +    
geom_rect(data = df.year,aes(xmin = yearstart, xmax = yearend,ymin = 0, ymax = datevalue),alpha=0.7)
-------------------------------------------------------------------------------------------------------
ggplot(data, aes(x=Time, y=Average, colour=Test)) + 
  geom_rect(aes(xmin=20,xmax=30,ymin=-Inf,ymax=Inf),fill="pink",colour=NA,alpha=0.05) +
  geom_errorbar(aes(ymin=Average-se, ymax=Average+se), width=0.2) +
  geom_line() +
  geom_point()
-------------------------------------------------------------------------------------------------------
plot.xts add plot.xts plot.xtsMODIFIED<-function (x, y = NULL, type = "l", auto.grid = TRUE, major.ticks = "auto", 
    minor.ticks = TRUE, major.format = TRUE, bar.col = "grey", 
    candle.col = "white", ann = TRUE, axes = TRUE, ...) 
{
    series.title <- deparse(substitute(x))
    ep <- axTicksByTime(x, major.ticks, format.labels = major.format)
    otype <- type
    if (is.OHLC(x) && type %in% c("candles", "bars")) {
        x <- x[, has.OHLC(x, TRUE)]
        xycoords <- list(x = .index(x), y = seq(min(x), max(x), 
            length.out = NROW(x)))
        type <- "n"
    }
    else {
        if (NCOL(x) > 1) 
            warning("only the univariate series will be plotted")
        if (is.null(y)) 
            xycoords <- xy.coords(.index(x), x[, 1])
    }
    ###The next three lines are the only modifications i made to the function####
    plot(xycoords$x, xycoords$y, type = "n", axes = FALSE, ann = FALSE) 
    rect(par("usr")[1], par("usr")[3], par("usr")[2], par("usr")[4], col ="white")
    if(type=="l"){lines(xycoords$x, xycoords$y, ...)}

    if (auto.grid) {
        abline(v = xycoords$x[ep], col = "grey", lty = 4)
        grid(NA, NULL)
    }
    if (is.OHLC(x) && otype == "candles") 
        plot.ohlc.candles(x, bar.col = bar.col, candle.col = candle.col, 
            ...)
    dots <- list(...)
    if (axes) {
        if (minor.ticks) 
            axis(1, at = xycoords$x, labels = FALSE, col = "#BBBBBB", 
                ...)
        axis(1, at = xycoords$x[ep], labels = names(ep), las = 1, 
            lwd = 1, mgp = c(3, 2, 0), ...)
        axis(2, ...)
    }
    box()
    if (!"main" %in% names(dots)) 
        title(main = series.title)
    do.call("title", list(...))
    assign(".plot.xts", recordPlot(), .GlobalEnv)
} library(quantmod)
getSymbols('SPY', from='1998-01-01', to='2011-07-31', adjust=T)

GRAPH_BLUE<-rgb(43/255, 71/255,153/255)
GRAPH_BACKGROUND<-rgb(180/255, 226/255, 244/255)

par(bg=GRAPH_BACKGROUND)

plot.xtsMODIFIED(SPY, col=GRAPH_BLUE) Error in axis(1, at = xycoords$x, labels = FALSE, col = "#BBBBBB", ...) : formal argument "col" matched by multiple actual arguments. plot.xts ... col axis plot lines ...
axis(1, at = xycoords$x, labels = FALSE, col = "#BBBBBB", 
            ...)
... ...
axis(1, at = xycoords$x, labels = FALSE, ...)
... plot.xts plot.xtsMODIFIED<-function (x, y = NULL, type = "l", auto.grid = TRUE, major.ticks = "auto", 
                             minor.ticks = TRUE, major.format = TRUE, bar.col = "grey", 
                             candle.col = "white", ann = TRUE, axes = TRUE, 
                             lcol, ...) 
{
...
if(type=="l"){lines(xycoords$x, xycoords$y, lcol, ...)}
...
} plot.xtsMODIFIED(SPY, lcol=GRAPH_BLUE)
-------------------------------------------------------------------------------------------------------
par(bg="lightblue")
plot(0, 0, type="n", ann=FALSE, axes=FALSE)
u <- par("usr") # The coordinates of the plot area
rect(u[1], u[3], u[2], u[4], col="white", border=NA)

par(new=TRUE)
plot(1:10, cumsum(rnorm(10))) par(new=TRUE)
-------------------------------------------------------------------------------------------------------
plot.xts panel.first library(quantmod)
getSymbols('SPY', from='1998-01-01', to='2011-07-31', adjust=T)

GRAPH_BLUE<-rgb(43/255, 71/255,153/255)
GRAPH_BACKGROUND<-rgb(180/255, 226/255, 244/255)
par(bg=GRAPH_BACKGROUND)
white.rect=function() do.call(rect,as.list(c(par()$usr[c(1,3,2,4)],col="white")))
plot.xts(SPY,panel.first=white.rect()) col=GRAPH_BLUE
-------------------------------------------------------------------------------------------------------
makeplot_mosaic <- function(data, x, y, ...){
  xvar <- deparse(substitute(x))
  yvar <- deparse(substitute(y))
  mydata <- data[c(xvar, yvar)];
  mytable <- table(mydata);
  widths <- c(0, cumsum(apply(mytable, 1, sum)));
  heights <- apply(mytable, 1, function(x){c(0, cumsum(x/sum(x)))});

  alldata <- data.frame();
  allnames <- data.frame();
  for(i in 1:nrow(mytable)){
    for(j in 1:ncol(mytable)){
      alldata <- rbind(alldata, c(widths[i], widths[i+1], heights[j, i], heights[j+1, i]));
    }
  }
  colnames(alldata) <- c("xmin", "xmax", "ymin", "ymax")

  alldata[[xvar]] <- rep(dimnames(mytable)[[1]],rep(ncol(mytable), nrow(mytable)));
  alldata[[yvar]] <- rep(dimnames(mytable)[[2]],nrow(mytable));

  ggplot(alldata, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax)) + 
    geom_rect(color="black", aes_string(fill=yvar)) +
    xlab(paste(xvar, "(count)")) + ylab(paste(yvar, "(proportion)"));
} makeplot_mosaic(mtcars, vs, gear)
-------------------------------------------------------------------------------------------------------
df library("ggplot2")
library("reshape2")
library("grid") df.m df.m <- melt(df, id="Years")
df.m$measure <- gsub("(.*) \\(.*", "\\1", df.m$variable)
df.m$facet <- gsub(".*\\((.*)\\)", "\\1", df.m$variable) colour shape variable shape colour ggplot(df.m, aes(group=1, x=Years, y=value, colour=measure, shape=measure)) +
    scale_colour_manual(name='', values=c('chartreuse4', 'deepskyblue3')) +
    scale_shape_manual(name='', values=c(19, 17)) +
    geom_point(size=3) +
    facet_grid(.~facet) +
    coord_cartesian(ylim=(c(0.0,0.45))) +
    scale_x_discrete("", expand=c(0.01, 0.01)) +
    scale_y_continuous(name="") +
    guides(colour=guide_legend(title='', ncol=2, keywidth=unit(2,'lines'))) +
    theme(legend.position="top",
          legend.key=element_blank(),
          legend.background=element_rect(colour='black', fill='transparent'),
          legend.text=element_text(size=12),
          panel.grid.minor = element_blank(),
          panel.margin=unit(1, 'lines'),
          axis.text=element_text(size=12,color="black"),
          axis.title=element_text(size=16),
          strip.text.y = element_text(size = 14)) breaks scale_colour_manual scale_shape_manual g <- g + scale_colour_manual(name='',
                             breaks=c('% of Women (Physics)', 'Divergence (Physics)'),
                             labels=c('% of Women', 'Divergence'),
                             values=c('chartreuse4', 'deepskyblue3','chartreuse4', 
                                      'deepskyblue3', 'chartreuse4', 'deepskyblue3'))
g <- g + scale_shape_manual(name='',
                            breaks=c('% of Women (Physics)', 'Divergence (Physics)'),
                            labels=c('% of Women', 'Divergence'),
                            values=c(19, 17, 19, 17, 19, 17))
-------------------------------------------------------------------------------------------------------
fill aes library(maps)
world<-map_data("world")

set.seed(123)
w2<-data.frame(world,data=sample(10,length(unique(world$group)),T)[world$group])

ggplot(w2,aes(long,lat,group=group,fill=data))+
    geom_polygon(color="white")+
    scale_fill_gradient(low="lightgreen",high="darkgreen")+
    theme(panel.background = element_rect(fill = "lightsteelblue2"))
-------------------------------------------------------------------------------------------------------
geom_text geom_rect labels <- data.frame(id = c("Very poor", "Poor", "Moderate", "Good", "Very good"), 
  min = seq(0, 80, 20), max = seq(20, 100, 20)) x y geom base <- ggplot(p2r.m) + 
  geom_line(aes(x=time,y=value,group=variable,colour=variable))  +
  geom_point(aes(x=time,y=value), size=4,shape=21,fill="white") base + geom_rect(data = labels, aes(ymin = min, ymax = max,xmin = 0, xmax = 0.5, fill = id)) + 
    geom_text(data = labels, aes(x = 0.25, y = (min + max)/2, label = id), angle = 90) + 
    guides(fill = F)
-------------------------------------------------------------------------------------------------------
plot ylab='' xlab='' with(dat, plot(NA, xlim=c(min(x1),max(x2)),
                   ylim=c(min(y),max(y)+.15),
                   type="n", xlab='', ylab='')) # <- specify xlab and ylab here
with(dat, rect(x1,y,x2,y+0.1))
title(xlab="chrX Position", ylab="Divergence")
-------------------------------------------------------------------------------------------------------
w32-backend.c window gawin = newwindow("Cairo Graphics", rect(20,20,width,height),
                         Document|StandardWindow);
-------------------------------------------------------------------------------------------------------
p <- ggplot(mtcars, aes(factor(gear), mpg, fill=factor(gear)))
p <- p + scale_x_discrete()
p <- p + geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf, fill=(typeColor)))
p <- p + geom_boxplot()
p <- p + facet_grid(. ~ type)
p <- p + scale_fill_manual( values = c("black" = "black","white" = "white","3" = "green","4" = "red","5" = "blue"))
show(p)
-------------------------------------------------------------------------------------------------------
geom_rect ggplot(mtcars, aes(factor(gear), mpg, fill=factor(gear))) + 
        scale_x_discrete() + 
        geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf, fill=(typeColor)),show_guide = FALSE) + 
        geom_boxplot() + 
        facet_grid(. ~ type) + 
        scale_fill_manual(values = c("black" = "black","white" = "white","3" = "green","4" = "red","5" = "blue"), 
                          limits=c("3","4","5"))
-------------------------------------------------------------------------------------------------------
guides() override.aes= size= fill=NA legend.key= theme() df<-data.frame(x=rep(1:5,each=3),y=1:15,group=rep(c("A","B","C"),each=5))
ggplot(df,aes(x,y,color=group,fill=group))+geom_line()+
  guides(colour = guide_legend(override.aes = list(size = 10)))+
  theme(legend.key=element_rect(fill=NA))
-------------------------------------------------------------------------------------------------------
poly.df <- as.data.frame( t( apply(df, 1, 
              function(x) c(                        # for longitude, 
               xmin=x[1]-cos(x[2]*2*pi/360)*20/111.2,  # km/degr varies
               xmax=x[1]+cos(x[2]*2*pi/360)*20/111.2,  # with latitude
               ymin=x[2]-20/111.2,            # but not for lattitude
               ymax=x[2]+20/111.2) ) ) ) round( cos(seq(90, 0, by=-15)*2*pi/360)*111.2 , 1)
[1]   0.0  28.8  55.6  78.6  96.3 107.4 111.2 p+geom_rect(data=poly.df, color="red", fill="transparent", 
       aes(xmin=xmin.lon,xmax=xmax.lon, ymin=ymin.lat,ymax=ymax.lat) ) p+geom_vline(xintercept= seq(-50, -130, by=-1), color="red")+
      geom_hline(yintercept= seq(25,50, by=1), color="red")
-------------------------------------------------------------------------------------------------------
fill=NA override.aes= stat_smooth() se=TRUE theme() legend.key= ggplot(dd, aes(x = x, y = y, colour = col)) + geom_point(alpha = 1/5)+
  stat_smooth(method = "lm")+
  guides(colour = guide_legend(override.aes = list(alpha = 1,fill=NA))) + 
  theme(legend.key=element_rect(fill="white"))
-------------------------------------------------------------------------------------------------------
# bind data together to simplify plot code
df <- rbind(d1, d2)

# plot
with(df,
     errbar(x = x + c(rep(0.05, nrow(d1)), rep(-0.05, nrow(d2)), # dodge points to avoid overplotting
            y = meanY,
            yplus = meanY + sdY,
            yminus = meanY - sdY,
            pch = 1, cex = 0.5, cap = .0025,
            errbar.col = rep(c("red", "green"), times = c(nrow(d1), nrow(d2))),
            xlab = "X values", ylab = "Y values",
            xlim = c(1, 5), ylim = c(0, 7)))


# create data for legend
df_legend <- data.frame(x <- c(4.5, 4.5),
                        y <- c(1, 2),
                        sdy <- c(0.3, 0.3))

# add symbols to legend
with(df_legend,
  errbar(x = x,
         y = y,
         yplus = y + sdy,
         yminus = y - sdy,
         pch = 1, cex =.5, cap = .0025,
         errbar.col = c("red", "green"),
         add = TRUE))

# add text to legend
with(df_legend,
     text(x = x + 0.2,
          y = y,
          labels = c("d2", "d1")))

# add box
with(df_legend,
     rect(xleft = x - 0.2,ybottom = y[1] - 0.5,xright = x + 0.4,ytop = y[2] + 0.5))
-------------------------------------------------------------------------------------------------------
layout filled contour layout(matrix(c(1,2),nrow=1), width=c(4,1) )
# your plot code here

#
plot(1,1, xlim=c(0,.21), ylim=c(0,100), type="n", mar=c(0,0,0,0),
   oma=c(0,0,0,0) , axes=FALSE, ylab="", xlab="")
levels<-facetcol; rect(0, levels[-length(facetcol)], 1, levels[-1], col = color)
-------------------------------------------------------------------------------------------------------
#random data
DF <- data.frame(range = c("10 - 20", "28 - 30", "3 - 8", 
                          "100 - 180", "185 - 190", "200 - 350"), 
                    type = rep(c("helix", "beta", "turn"), 2), stringsAsFactors = F)

#manipulate "from - to" numerically
newDF <- cbind(DF, do.call(rbind, strsplit(DF$range, " - ")), stringsAsFactors = F)
names(newDF) <- c(names(DF), "xleft", "xright") #name the columns
newDF$"xleft" <- as.numeric(newDF$"xleft")  #make the values numeric
newDF$"xright" <- as.numeric(newDF$"xright") # -//-

#> newDF
#      range  type xleft xright
#1   10 - 20 helix    10     20
#2   28 - 30  beta    28     30
#3     3 - 8  turn     3      8
#4 100 - 180 helix   100    180
#5 185 - 190  beta   185    190
#6 200 - 350  turn   200    350

#color for each type
colors. <- c(rgb(0,1,0,1/3), rgb(0,0,1,1/3), rgb(1,0,0,1/3))[as.factor(newDF$type)]

#background plot 
plot(NULL, xlim = c(0, max(newDF[c("xleft", "xright")])), 
                        ylim = c(0,1), yaxt = "n", ann = F)

#legend
legend(x = max(newDF[c("xleft", "xright")]) * 0.5, y = 1.15, xpd = T, ncol = 3, 
         legend = c("beta", "helix", "turn"), 
             fill = c(rgb(0,1,0,1/3), rgb(0,0,1,1/3), rgb(1,0,0,1/3)))

#function that draws rectangles for each range
fun <- function(xl, yb, xr, yt, col.)
{
 rect(xleft = xl, ybottom = yb, xright = xr, ytop = yt, col = col.)
} 

#draw all rectangles
mapply(fun, xl = newDF$xleft, xr = newDF$xright, col. = colors., 
                       MoreArgs = list(yb = 0, yt = 1)) jpeg
-------------------------------------------------------------------------------------------------------
require(grid)
grid.newpage()
g1 <- grid.rect(width=unit(2, "cm"), height=unit(1.5, "line"))
g2 <- textGrob("this has to fit")
w1 <- convertWidth(grobWidth(g1), "mm", valueOnly=TRUE)
w2 <- convertWidth(grobWidth(g2), "mm", valueOnly=TRUE)
ratio <- w1 / w2
grid.draw(editGrob(g2, gp=gpar(cex=ratio)))
-------------------------------------------------------------------------------------------------------
base grid.table library(gridExtra)

layout(matrix(c(1,0,2,0), 2))
hist(iris$Sepal.Length, col="lightblue")
hist(iris$Sepal.Width, col="lightblue")

pushViewport(viewport(y=.25,height=.5))
grid.table(head(iris), h.even.alpha=1, h.odd.alpha=1,
           v.even.alpha=0.5, v.odd.alpha=1) viewport grid.rect()
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(gtable)

p <- qplot(1,1) + theme(panel.background=element_rect(fill=NA))
g <- ggplotGrob(p)

pos <- gtable_filter(g, "panel", trim=FALSE)$layout
g <- with(pos, gtable_add_grob(g, test.grob, t, l, b, r, z-1))

grid.newpage()
grid.draw(g)
-------------------------------------------------------------------------------------------------------
## choose just relevant columns
d <- dat[,c('start','end','Dest','Total')]
# Make sure the data is sorted
d <- d[ order(d$start), ]
h <- d
## here all the main stuff
for (i in head(seq_len(nrow(d)),-1)){
  if(d[i+1,'start'] < d[i,'end']){
    xx <- d[i,]
    xx$start <- d[i+1,'start'] 
    xx$Total <- d[i,'Total'] +d[i+1,'Total']
    h <- rbind(h,xx)   
  }
}

library(ggplot2)
ggplot(h,aes(x=start,y=Total,xmin=start,xmax=end,ymin=0,ymax=Total,
             ,fill=factor(Dest),alpha=0))+
  geom_rect() scale_x_datetime scales library(scales)
last_plot()
scale_x_datetime(breaks=unique(c(h$start,h$end)),
               labels = date_format("%H:%M"))
-------------------------------------------------------------------------------------------------------
library(plyr)
df2<-ddply(diamonds,.(clarity),nrow) ggplot() clarity V1 geom_blank() geom_rect() xmin xmax as.numeric() clarity xmin xmax ymin ymax V1 geom_bar(stat="identity") ggplot(df2,aes(clarity,V1)) + geom_blank()+
  geom_rect(aes(xmin=as.numeric(clarity)-0.38,xmax=as.numeric(clarity)+.5,ymin=0,ymax=V1+250),fill="green")+
  geom_bar(width=0.8,stat="identity")
-------------------------------------------------------------------------------------------------------
ranges = data.frame(species=c('species_a','species_b'), 
                    rmin=c(0.8,1.2),rmax=c(1.2,1.8))
ranges

    species rmin rmax
1 species_a  0.8  1.8
2 species_b  1.2  1.8 geom_rect() geom_violin() geom_blank() ggplot(df, aes(x=species, y=size))  + geom_blank() + 
  geom_rect(data=ranges,aes(xmin=as.numeric(species)-0.45,xmax=as.numeric(species)+0.45,ymin=rmin,ymax=rmax),inherit.aes=FALSE)+
  geom_violin()
-------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------
LtoM MtoH hm2 require(reshape2)
require(ggplot2)

# Random data
set.seed(100)
casted = data.frame(Var1 = rep(1985:2013, times=12), Var2 = rep(month.abb, each=29), return = rnorm(12*29, 0, 9))
molten = melt(casted, id.vars = c("Var1", "Var2"))

LtoM <-colorRampPalette(c('red', 'yellow' ))
Mid <- "snow3"
MtoH <-colorRampPalette(c('lightgreen', 'darkgreen'))

# Averages
monthly.avg = cbind(Var1 = rep("Mean", 12), dcast(molten, Var2 ~ ., mean))
colnames(monthly.avg)[3] = "Mean"
molten2 = merge(molten, melt(monthly.avg), all.x = TRUE, all.y = TRUE)

# New plot
hm2 = 
  ggplot(data = molten2, aes(x = factor(Var2, levels = month.abb), y=Var1, fill=value)) +
  geom_raster() +
  scale_fill_gradient2(low=LtoM(100), mid=Mid, high=MtoH(100)) +
  labs(fill='% Return') +
  geom_text(aes(label=paste(sprintf("%.1f %%", value))), size = 4) +
  xlab(label = NULL) + ylab(label = NULL) +
  theme_bw() +
  theme(axis.text.x = element_text(size = 10, hjust = 0, vjust = 0.4, angle=90)) +
  facet_grid(variable ~ ., scales = "free_y", space = "free_y") +    # grid layout
  theme(strip.background = element_rect(colour = 'NA', fill = 'NA'), strip.text.y = element_text(colour = 'white'))    # remove facet labels
-------------------------------------------------------------------------------------------------------
scatter_fill <- function (x, y, z,xlim=c(min(x),max(x)),ylim=c(min(y),max(y)),zlim=c(min(z),max(z)),
                          nlevels = 20, plot.title, plot.axes, 
                          key.title, key.axes, asp = NA, xaxs = "i", 
                          yaxs = "i", las = 1, 
                          axes = TRUE, frame.plot = axes, ...) 
{
  mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar
  on.exit(par(par.orig))
  w <- (3 + mar.orig[2L]) * par("csi") * 2.54
  layout(matrix(c(2, 1), ncol = 2L), widths = c(1, lcm(w)))
  par(las = las)
  mar <- mar.orig
  mar[4L] <- mar[2L]
  mar[2L] <- 1
  par(mar = mar)

# choose colors to interpolate
levels <- seq(zlim[1],zlim[2],length.out = nlevels)
col <- colorRampPalette(c("red","yellow","dark green"))(nlevels)  
colz <- col[cut(z,nlevels)]  
#   
plot.new()
plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i", yaxs = "i")

rect(0, levels[-length(levels)], 1, levels[-1L],col=col,border=col) 
if (missing(key.axes)) {if (axes){axis(4)}}
       else key.axes
   box()
   if (!missing(key.title)) 
     key.title
   mar <- mar.orig
   mar[4L] <- 1
   par(mar = mar)

   # points
   plot(x,y,type = "n",xaxt='n',yaxt='n',xlab="",ylab="",xlim=xlim,ylim=ylim,bty="n")
   points(x,y,col = colz,xaxt='n',yaxt='n',xlab="",ylab="",bty="n",...)

   ## options to make mapping more customizable

        if (missing(plot.axes)) {
          if (axes) {
            title(main = "", xlab = "", ylab = "")
            Axis(x, side = 1)
            Axis(y, side = 2)
          }
        }
        else plot.axes
        if (frame.plot) 
          box()
        if (missing(plot.title)) 
          title(...)
        else plot.title
        invisible()
 } # random vectors
vx <- rnorm(40,0,1)
vy <- rnorm(40,0,1)
vz <- rnorm(40,10,10)

scatter_fill(vx,vy,vz,nlevels=15,xlim=c(-1,1),ylim=c(-1,5),zlim=c(-10,10),main="TEST",pch=".",cex=8)
-------------------------------------------------------------------------------------------------------
library(ggplot2)
set.seed(1)
(d <- data.frame(cbind(x = sample(1:3, 10, replace = TRUE), y = sample(3:8, 10, replace = TRUE)), fac = sample(1:3, 10, replace = TRUE)))
ggplot(data=d) +
geom_rect(aes(xmin=fac-0.4,xmax=fac+0.4,ymin=x,ymax=y),alpha=0.25,fill="red") library(ggplot2)
set.seed(1)
d <- data.frame(cbind(x = sample(1:3, 15, replace = TRUE), 
     y = sample(3:8, 18, replace = TRUE)))

ggplot(data=d) +
   geom_tile(aes(x=x,y=y),alpha=0.25,fill="red")
-------------------------------------------------------------------------------------------------------
## Loading packages
    library(rgdal)
    library(plyr)
    library(maps)
    library(maptools)
    library(mapdata)
    library(ggplot2)
    library(RColorBrewer)
    library(foreign)  
    library(sp)

    ## get.centroids: function to extract polygon ID and centroid from shapefile
    get.centroids = function(x){
    poly = MoroccoReg@polygons[[x]]
    ID   = poly@ID
    centroid = as.numeric(poly@labpt)
    return(c(id=ID, long=centroid[1], lat=centroid[2]))
    }

    ## Loading shapefiles and .csv files
    #Morocco <- readOGR(dsn=".", layer="Morocco_adm0")
    MoroccoReg <- readOGR(dsn=".", layer="Morocco_adm1")
    MoroccoYield <- read.csv(file = "F:/Purdue University/RA_Position/PhD_ResearchandDissert/PhD_Draft/Country-CGE/RMaps_Morocco/Morocco_Yield.csv", header=TRUE, sep=",", na.string="NA", dec=".", strip.white=TRUE)
    MoroccoYield$ID_1 <- substr(MoroccoYield$ID_1,3,10) # Eliminate the ID_1 column

    ## Reorder the data in the shapefile
    MoroccoReg    <- MoroccoReg[order(MoroccoReg$ID_1), ]
    MoroccoYield  <- cbind(id=rownames(MoroccoReg@data),MoroccoYield) # Add the column "id" for correct merging with the spatial data 

    ## Build table of labels for annotation (legend).
    labs <- do.call(rbind,lapply(1:14,get.centroids))
    labs <- merge(labs,MoroccoYield[,c("id","ID_1","Label")],by="id")
    labs[,2:3] <- sapply(labs[,2:3],function(x){as.numeric(as.character(x))})
    labs$sort <- as.numeric(as.character(labs$ID_1))
    labs <- labs[order(labs$sort),]

    MoroccoReg.df <- fortify(MoroccoReg) # transform shapefile into dataframe
    MoroccoReg.df <- merge(MoroccoReg.df,MoroccoYield, by="id") # merge the spatial data and the yield data
    str(MoroccoReg.df)

    ## Define new theme for map
    ## I have found this function on the website
    theme_map <- function (base_size = 12, base_family = "") {
    theme_gray(base_size = base_size, base_family = base_family) %+replace% 
    theme(
    axis.line=element_blank(),
    axis.text.x=element_blank(),
    axis.text.y=element_blank(),
    axis.ticks=element_blank(),
    axis.ticks.length=unit(0.3, "lines"),
    axis.ticks.margin=unit(0.5, "lines"),
    axis.title.x=element_blank(),
    axis.title.y=element_blank(),
    legend.background=element_rect(fill="white", colour=NA),
    legend.key=element_rect(colour="white"),
    legend.key.size=unit(1.2, "lines"),
    legend.position="right",
    legend.text=element_text(size=rel(0.8)),
    legend.title=element_text(size=rel(0.8), face="bold", hjust=0),
    panel.background=element_blank(),
    panel.border=element_blank(),
    panel.grid.major=element_blank(),
    panel.grid.minor=element_blank(),
    panel.margin=unit(0, "lines"),
    plot.background=element_blank(),
    plot.margin=unit(c(1, 1, 0.5, 0.5), "lines"),
    plot.title=element_text(size=rel(1.2)),
    strip.background=element_rect(fill="grey90", colour="grey50"),
    strip.text.x=element_text(size=rel(0.8)),
    strip.text.y=element_text(size=rel(0.8), angle=-90) 
    )   
    }

    MoroccoRegMap1 <- ggplot(data = MoroccoReg.df, aes(long, lat, group = group)) 
    MoroccoRegMap1 <- MoroccoRegMap1 + geom_polygon(aes(fill = A2Med_noCO2))
    MoroccoRegMap1 <- MoroccoRegMap1 + geom_path(colour = 'gray', linestyle = 2)
    #MoroccoRegMap <- MoroccoRegMap + scale_fill_gradient(low = "#CC0000",high = "#006600")
    MoroccoRegMap1 <- MoroccoRegMap1 + scale_fill_gradient2(name = "%Change in yield",low = "#CC0000",mid = "#FFFFFF",high = "#006600")
    MoroccoRegMap1 <- MoroccoRegMap1 + labs(title="SRES_A2, noCO2 Effect")
    MoroccoRegMap1 <- MoroccoRegMap1 + coord_equal() + theme_map()
    MoroccoRegMap1 <- MoroccoRegMap1 + geom_text(data=labs, aes(x=long, y=lat, label=ID_1, group=ID_1), size=6)
    MoroccoRegMap1 <- MoroccoRegMap1 + annotate("text", x=max(labs$long)-5, y=min(labs$lat)+3-0.5*(1:14),
                                        label=paste(labs$ID_1,": ",labs$Label,sep=""),
                                        size=5, hjust=0)
    MoroccoRegMap1
-------------------------------------------------------------------------------------------------------
geom_rect() ymin ymax -Inf Inf data aes() geom_point() ggplot() alpha= geom_rect() ggplot()+
  geom_point(data=df,aes(x=y*abs(x),y=y),alpha=.2,size=5) +
  geom_rect(aes(xmin=-0.1,xmax=0.1,ymin=-Inf,ymax=Inf),alpha=0.1,fill="green")+
  geom_rect(aes(xmin=-0.25,xmax=-0.1,ymin=-Inf,ymax=Inf),alpha=0.1,fill="orange")+
  geom_rect(aes(xmin=0.1,xmax=0.25,ymin=-Inf,ymax=Inf),alpha=0.2,fill="orange")+
  theme_bw() +
  coord_cartesian(xlim = c(-.5,.5),ylim=c(-1,1))
-------------------------------------------------------------------------------------------------------
require(ggplot2)

big_votes_movies = movies[movies$votes > 100000,]
p <- ggplot(big_votes_movies, aes(x=rating, y=votes, label=year))
p + geom_text(size=12, aes(colour=factor(year), alpha=0.3)) + geom_jitter(alpha=0) + 
  scale_x_continuous(limits=c(8, 9.5))   + scale_y_continuous(limits=c(90000,170000)) require(ggplot2)
require(png)
require(plyr)
require(grid)

years<-data.frame(year=unique(big_votes_movies$year))
palette(rainbow(nrow(years)))
years$col<-palette() # manually set some different colors

# create a function to write the "year" images
writeYear<-function(year,col){

  png(filename=paste(year,".png",sep=""),width=550,height=300,bg="transparent")
  im<-qplot(1,1,xlab=NULL,ylab=NULL) + 
    theme(axis.text.x = element_blank(),axis.text.y = element_blank()) +
    theme(panel.background = element_rect(fill = "transparent",colour = NA),     plot.background = element_rect(fill = "transparent",colour = NA), panel.grid.minor =     element_line(colour = "white")) +
    geom_text(label=year, size=80, color=col)
  print(im)
  dev.off()
}
#call the function to create the placeholder images
apply(years,1,FUN=function(x)writeYear(x["year"],x["col"]))

# then roll up the data
summarydata<-big_votes_movies[,c("year","rating","votes")]
# make own bins (a cheat)
summarydata$rating<-cut(summarydata$rating,breaks=c(0,8,8.5,9,Inf),labels=c(0,8,8.5,9))
aggdata <- ddply(summarydata, c("year", "rating"), summarise, votes  = sum(votes) )
aggdata<-aggdata[order(aggdata$rating),]
aggdata<-ddply(aggdata,.(rating),transform,ymax=cumsum(votes),ymin=c(0,cumsum(votes))[1:length(votes)])
aggdata$imgname<-apply(aggdata,1,FUN=function(x)paste(x["year"],".png",sep=""))

#work out the upper limit on the y axis
ymax<-max(aggdata$ymax)

#plot the basic chart
z<-qplot(x=10,y=10,geom="blank") + scale_x_continuous(limits=c(8,9.5)) + scale_y_continuous(limits=c(0,ymax))  

#make a function to create the grobs and call the annotation_custom function
callgraph<-function(df){
  tiles<-apply(df,1,FUN=function(x)return(annotation_custom(rasterGrob(image=readPNG(x["imgname"]),
                                                      x=0,y=0,height=1,width=1,just=c("left","bottom")),
                                                          xmin=as.numeric(x["rating"]),xmax=as.numeric(x["rating"])+0.5,ymin=as.numeric(x["ymin"]),ym    ax=as.numeric(x["ymax"]))))
      return(tiles)
    }

# then add the annotations to the plot
z+callgraph(aggdata) require(ggplot2)
  require(png)
  require(plyr)
  require(grid)
  require(extrafont)

  #font_import(pattern="Show") RUN THIS ONCE ONLY
  #load the fonts
  loadfonts(device="win")

  #create a subset of data with big votes
  big_votes_movies = movies[movies$votes > 100000,]

  #create a custom palette and append to a table of the unique years (labels) 
  years<-data.frame(year=unique(big_votes_movies$year))
  palette(rainbow(nrow(years)))
  years$col<-palette()

  #function to create the labels as png files
  writeYear<-function(year,col){

    png(filename=paste(year,".png",sep=""),width=440,height=190,bg="transparent")
    im<-qplot(1,1,xlab=NULL,ylab=NULL,geom="blank") + 
      geom_text(label=year,size=70, family="Showcard Gothic", color=col,alpha=0.8) +
      theme(axis.text.x = element_blank(),axis.text.y = element_blank()) +
      theme(panel.background = element_rect(fill = "transparent",colour = NA), 
            plot.background = element_rect(fill = "transparent",colour = NA), 
            panel.grid.minor = element_line(colour = "transparent"), 
            panel.grid.major = element_line(colour = "transparent"),
            axis.ticks=element_blank())
    print(im)
    dev.off()
  }

  #call the function to create the placeholder images
  apply(years,1,FUN=function(x)writeYear(x["year"],x["col"]))

  #summarize the data, and create bins manually
  summarydata<-big_votes_movies[,c("year","rating","votes")]
  summarydata$rating<-cut(summarydata$rating,breaks=c(0,8,8.5,9,Inf),labels=c(0,8,8.5,9))

  aggdata <- ddply(summarydata, c("year", "rating"), summarise, votes  = sum(votes) )
  aggdata<-aggdata[order(aggdata$rating),]
  aggdata<-ddply(aggdata,.(rating),transform,ymax=cumsum(votes),ymin=c(0,cumsum(votes))[1:length(votes)])
  #identify the image placeholders
  aggdata$imgname<-apply(aggdata,1,FUN=function(x)paste(x["year"],".png",sep=""))
  ymax<-max(aggdata$ymax)

  #do the basic plot
  z<-qplot(x=10,y=10,geom="blank",xlab="Rating",ylab="Votes \n",main="Big Movie Votes \n") + 
    theme_bw() +
    theme(panel.grid.major = element_line(colour = "transparent"),
          text = element_text(family="Kalinga", size=20,face="bold")        
          ) +
    scale_x_continuous(limits=c(8,9.5)) + 
    scale_y_continuous(limits=c(0,ymax))  

  #creat a function to create the grobs and return annotation_custom() calls
  callgraph<-function(df){
    tiles<-apply(df,1,FUN=function(x)return(annotation_custom(rasterGrob(image=readPNG(x["imgname"]),
                                                        x=0,y=0,height=1,width=1,just=c("left","bottom")),
                                                 xmin=as.numeric(x["rating"]),xmax=as.numeric(x["rating"])+0.5,ymin=as.numeric(x["ymin"]),ymax=as.numeric(x["ymax"]))))
    return(tiles)
  }
  #add the tiles to the base chart
  z+callgraph(aggdata)
-------------------------------------------------------------------------------------------------------
ggplot2 grid blankRows ## MOCK up confidence interval data in the form:
## ID (level from groupData), low (2.5%) high (97.5%), target
CI_Data<-ddply(hazardData[!is.na(hazardData$HR),],.(ID),summarize,low=min(HR),high=max(HR),target=mean(HR)) geom_boxplot(fill=boxColor,size=0.5, alpha=0.8, notch=F) geom_point(data=CI_Data,aes(x = factor(ID), y = target),shape=22,size=5,fill=boxColor,vjust=0) + 
  geom_errorbar(data=CI_Data,aes(x=factor(ID),y=target,ymin =low, ymax=high),width=0.5)+ ## REQUIRED PACKAGES
require(grid)
require(ggplot2)
require(plyr)

############################################
### CUSTOMIZE APPEARANCE WITH THESE     ####
############################################
blankRows<-2    # blank rows under boxplot
titleSize<-4
dataSize<-4
boxColor<-"pink"
############################################
############################################

## BASIC THEMES (SO TO PLOT BLANK GRID)
theme_grid <- theme(
  axis.line = element_blank(), 
  axis.text.x = element_blank(), 
  axis.text.y = element_blank(),
  axis.ticks = element_blank(), 
  axis.title.x = element_blank(), 
  axis.title.y = element_blank(), 
  axis.ticks.length = unit(0.0001, "mm"),
  axis.ticks.margin = unit(c(0,0,0,0), "lines"), 
  legend.position = "none", 
  panel.background = element_rect(fill = "transparent"), 
  panel.border = element_blank(), 
  panel.grid.major = element_line(colour="grey"), 
  panel.grid.minor = element_line(colour="grey"), 
  panel.margin = unit(c(-0.1,-0.1,-0.1,-0.1), "mm"), 
  plot.margin = unit(c(5,0,5,0.01), "mm")
)

theme_bare <- theme_grid +
  theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank()
  )

## LOAD GROUP DATA AND P values from csv file
groupData<-read.csv(file="groupdata.csv",header=T)

## SYNTHESIZE SOME PLOT DATA - you can load csv instead
## EXPECTS 2 columns - integer for 'ID' matching groupdatacsv
## AND 'HR' Hazard Rate
hazardData<-expand.grid(ID=1:nrow(groupData),HR=1:6)
hazardData$HR<-1.3-runif(nrow(hazardData))*0.7
hazardData<-rbind(hazardData,ddply(groupData,.(Group),summarize,ID=max(ID)+0.1,HR=NA)[,2:3])
hazardData<-rbind(hazardData,data.frame(ID=c(0,-1:(-2-blankRows),max(groupData$ID)+1,max(groupData$ID)+2),HR=NA))

## Make the min/max mean labels
hrlabels<-ddply(hazardData[!is.na(hazardData$HR),],.(ID),summarize,lab=paste(round(mean(HR),2)," (",round(min(HR),2),"-",round(max(HR),2),")",sep=""))

## Points to plot on the log scale
scaledata<-data.frame(ID=0,HR=c(0.2,0.6,0.8,1.2,1.8))

## Pull out the Groups & P values
group_p<-ddply(groupData,.(Group),summarize,P=mean(P_G),y=max(ID)+0.1)

## identify the rows to be highlighted, and 
## build a function to add the layers
hl_rows<-data.frame(ID=(1:floor(length(unique(hazardData$ID[which(hazardData$ID>0)]))/2))*2,col="lightgrey")
hl_rows$ID<-hl_rows$ID+blankRows+1
hl_rect<-function(col="white",alpha=0.5){
  rectGrob(   x = 0, y = 0, width = 1, height = 1, just = c("left","bottom"), gp=gpar(alpha=alpha, fill=col))
}

## DATA FOR TEXT LABELS
RtLabels<-data.frame(x=c(rep(length(unique(hazardData$ID))-0.2,times=3)),
                      y=c(0.6,6,10),
                      lab=c("Hazard Ratio\n(95% CI)","P Value","P Value for\nInteraction"))

LfLabels<-data.frame(x=c(rep(length(unique(hazardData$ID))-0.2,times=2)),
                     y=c(0.5,4),
                     lab=c("Subgroup","No. of\nPatients"))

LegendLabels<-data.frame(x=c(rep(1,times=2)),
                     y=c(0.5,1.8),
                     lab=c("Off-Pump CABG Better","On-Pump CABG Better"))

## BASIC PLOT
haz<-ggplot(hazardData,aes(factor(ID),HR))+ labs(x=NULL, y=NULL)

## RIGHT PANEL WITH LOG SCALE
rightPanel<-haz + 
  apply(hl_rows,1,function(x)annotation_custom(hl_rect(x["col"],alpha=0.4),as.numeric(x["ID"])-0.5,as.numeric(x["ID"])+0.5,-20,20)) +
  geom_segment(aes(x = 2, y = 1, xend = 1.5, yend = 1)) + 
  geom_hline(aes(yintercept=1),linetype=2, size=0.5)+
  geom_boxplot(fill=boxColor,size=0.5, alpha=0.8)+ 
  scale_y_log10() + coord_flip() +
  geom_text(data=scaledata,aes(3,HR,label=HR), vjust=0.5, size=dataSize) +
  geom_text(data=RtLabels,aes(x,y,label=lab, fontface="bold"), vjust=0.5, size=titleSize) +
  geom_text(data=hrlabels,aes(factor(ID),4,label=lab),vjust=0.5, hjust=1, size=dataSize) +
  geom_text(data=group_p,aes(factor(y),11,label=P, fontface="bold"),vjust=0.5, hjust=1, size=dataSize) +
  geom_text(data=groupData,aes(factor(ID),6.5,label=P_S),vjust=0.5, hjust=1, size=dataSize) +
  geom_text(data=LegendLabels,aes(x,y,label=lab, fontface="bold"),hjust=0.5, vjust=1, size=titleSize) +
  geom_point(data=scaledata,aes(2.5,HR),shape=3,size=3) + 
  geom_point(aes(2,12),shape=3,alpha=0,vjust=0) + 
  geom_segment(aes(x = 2.5, y = 0, xend = 2.5, yend = 13)) + 
  geom_segment(aes(x = 2, y = 1, xend = 2, yend = 1.8),arrow=arrow(),linetype=1,size=1) + 
  geom_segment(aes(x = 2, y = 1, xend = 2, yend = 0.2),arrow=arrow(),linetype=1,size=1) + 
  theme_bare

## LEFT PANEL WITH NORMAL SCALE
leftPanel<-haz + 
  apply(hl_rows,1,function(x)annotation_custom(hl_rect(x["col"],alpha=0.4),as.numeric(x["ID"])-0.5,as.numeric(x["ID"])+0.5,-20,20)) +
  coord_flip(ylim=c(0,5.5)) +
  geom_point(aes(x=factor(ID),y=1),shape=3,alpha=0,vjust=0) + 
  geom_text(data=group_p,aes(factor(y),0.5,label=Group, fontface="bold"),vjust=0.5, hjust=0, size=dataSize) +
  geom_text(data=groupData,aes(factor(ID),1,label=Subgroup),vjust=0.5, hjust=0, size=dataSize) +
  geom_text(data=groupData,aes(factor(ID),5,label=NoP),vjust=0.5, hjust=1, size=dataSize) +
  geom_text(data=LfLabels,aes(x,y,label=lab, fontface="bold"), vjust=0.5, hjust=0, size=4, size=titleSize) +
  geom_segment(aes(x = 2.5, y = 0, xend = 2.5, yend = 5.5)) + 
  theme_bare

## PLOT THEM BOTH IN A GRID SO THEY MATCH UP
grid.arrange(leftPanel,rightPanel, widths=c(1,3), ncol=2, nrow=1)
-------------------------------------------------------------------------------------------------------
ggplot(aes(x=x), data=df_lng) + geom_line(aes(y=value, colour=variable), size=1.3) +
  geom_rect(aes(fill=factor(Back), xmin=x, xmax=x+1, ymin=0, ymax=max(value)*1.07), alpha=.1) + 
  scale_fill_discrete(guide="none")
-------------------------------------------------------------------------------------------------------
heatmap.2 cluster <- cutree(hcr, k=kcluster) 
clustab <- table(cluster)[unique(cluster[hcr$order])]
m <- c(0, cumsum(clustab))
which <- 1L:kcluster
border <- rep_len(border, length(which))
for (n in seq_along(which))
   r("usr")[2L]+10,m[which[n]] + 0.66, 
    mean(rev(hcr$height)[(kcluster - 1):kcluster]),
    m[which[n] + 1] + 0.33, 
    border = border[n]) plot(ddr, horiz = TRUE, axes = FALSE, yaxs = "i", leaflab = "none") heatmap.rect(as.matrix(mydata),
             dendrogram="row",trace="none", margin=c(8,9), 
             hclust=hclustfunc,distfun=distfunc,key=FALSE,
             kcluster=7,border='blue')
-------------------------------------------------------------------------------------------------------
shaded_rowseq <- rowseq[rep(c(T,F),length(rowseq)/2)]
rect(-10, shaded_rowseq-0.5, 12, shaded_rowseq+0.5, col="#00000025", border=NA)
-------------------------------------------------------------------------------------------------------
linetype= aes() stat_density() colors= scale_linetype_manual() ggplot(data=df)+
  stat_density(aes(x=R1, colour="rho = -0,6",linetype="rho = -0,6"), 
                     adjust=4, lwd=0.5, geom="line", position="identity")+
  stat_density(aes(x=R2, colour="rho = 0,6",linetype="rho = 0,6"), 
                     adjust=4, lwd=0.5, geom="line", position="identity")+
  stat_density(aes(x=R3, colour="rho = 0", linetype="rho = 0"), 
                     adjust=4, lwd=0.5, geom="line", position="identity")+
  xlim(-0.5, 0.5)+
  xlab("Renditen")+
  ylab("Dichte")+
  ggtitle("Renditeverteilung im Heston-Modell")+
  theme(plot.title=element_text(face="bold", size=16, vjust=2),  
        axis.title.x=element_text(vjust=-1, size=12), 
        axis.title.y=element_text(vjust=-0.25, size=12), 
        legend.text=element_text(size=12), legend.title=element_text(size=12),
        legend.margin=unit(1.5, "cm"),
        legend.key.height=unit(1.2, "line"), 
        legend.key.size=unit(0.4, "cm"), 
        legend.key=element_rect(fill=NA), 
        legend.background=element_rect(colour="darkgrey"),
        plot.margin=unit(c(1,1,1,1), "cm"))+
  scale_colour_manual(values=c("rho = -0,6"="red", "rho = 0,6"="blue", 
                                "rho = 0"="black"), name="Korrelation")+
  scale_linetype_manual(values=c("rho = -0,6"=1, "rho = 0,6"=1, 
                                "rho = 0"=2), name="Korrelation")
-------------------------------------------------------------------------------------------------------
df2 <- stack(df)
df2$ind <- as.character(df2$ind) value1 = 0.8
value2 = 0.8
value3 = 0
greeks <- list(bquote(rho==.(value1)), bquote(rho==.(value2)), bquote(rho==.(value3)))

ggplot(data=df2)+
  stat_density(aes(x=values, group=ind, color=ind), 
               adjust=4, lwd=0.5, geom="line", position="identity")+
  xlim(-3, 3)+
  xlab("Renditen")+
  ylab("Dichte")+
  ggtitle("Renditeverteilung im Heston-Modell")+
  theme(plot.title=element_text(face="bold", size=16, vjust=2, family="Times New Roman"),  
        axis.title.x=element_text(vjust=-1, size=14, family="Times New Roman"),
        axis.title.y=element_text(vjust=-0.25, size=14, family="Times New Roman"), 
        legend.text=element_text(size=14, family="Times New Roman"), 
            legend.title=element_blank(),
        legend.margin=unit(1, "cm"),
        legend.key.height=unit(1, "line"), 
        legend.key.size=unit(0.4, "cm"), 
        legend.key=element_rect(fill=NA), 
        legend.background=element_blank(),
        plot.margin=unit(c(1,1,1,1), "cm"))+
  scale_colour_manual(values=1:3, labels=greeks) 
 +guides(colour=guide_legend(override.aes=list(linetype=1:3)))
-------------------------------------------------------------------------------------------------------
facet_wrap gridExtra library(gridExtra)

blank <- grid.rect(gp=gpar(col="white"))

grid.arrange(plot1, plot2, blank, plot3, ncol=2)
-------------------------------------------------------------------------------------------------------
image.plot fields image.plot image graphics library(grid)
x=1:10
y=1:10
z=matrix(-50:49,10,10)

layout(matrix(c(1,2),ncol=2), widths=c(2,1))         
par(mar=c(5,3,5,3))
image(x,y,z,yaxt="n",xaxt="n", ylab="", xlab="",col=heat.colors(50)) 
cap <- grid.cap()
grid.newpage()
grid.raster(cap, x=unit(0.6,'npc'), #You can modify that if the plot 
            y=unit(0.5,'npc'),      #ends up outside the figure area
            vp=viewport(angle=36))
mtext("Some fancy title",side=3,cex=1.5,line=2) #Plot your title
par(mar=c(5,8,5,3))
plot(NA,ax=F,ann=F,type="n",xlim=c(0,1),ylim=c(0,50),yaxs="i")
for(i in 1:50)rect(0,i-1,1,i,col=heat.colors(50)[i],border=NA)
box()
axis(4,las=2,at=seq(0,50,by=10),labels=seq(-50,50,by=20))
-------------------------------------------------------------------------------------------------------
geom_rect(...) viewports grid require(ggplot2)
set.seed(123)
d   <- data.frame(x = sort(rlnorm(300)), y = sort(rlnorm(300)), grp = 1)
ggp <- ggplot(d, aes(x, y)) + 
  geom_point() + theme_bw() +
  scale_x_continuous(limits=c(0, 5)) + 
  scale_y_continuous(limits=c(0, 5)) 

sub <- ggplot(d)+geom_point(aes(x,y))+
  theme_bw()+
# assign single row data object so only one rectangle is drawn  
  geom_rect(data=d[1,],xmin=0,ymin=0,xmax=5,ymax=5,fill="blue",alpha=0.5)

library(grid)
grid.newpage()
print(ggp)
vp <- viewport(width = .6, height = .6, x=.37, y=.06,just=c("left","bottom"))
pushViewport(vp)
print(sub,vp=vp)
-------------------------------------------------------------------------------------------------------
ggplot(mtcars) +
  geom_density(aes(x=disp, group=cyl, fill=cyl), alpha=0.6, adjust=0.75) + 
  geom_rect(data=mtcars[1,], aes(xmin=100, xmax=200, ymin=0,ymax=Inf), fill="red", alpha=0.2)
-------------------------------------------------------------------------------------------------------
annotation_custom require(ggplot2)
d = data.frame(x = sort(rlnorm(300)), y = sort(rlnorm(300)), grp = 1)

main <- ggplot(d, aes(x, y)) + geom_point() + theme_bw() 

sub <- main + geom_rect(data=d[1,],xmin=0, ymin=0, xmax=5, ymax=5, 
                        fill="blue", alpha=0.5)
sub$layers <- rev(sub$layers) # draw rect below

main + annotation_custom(ggplotGrob(sub), xmin=2.5, xmax=5, ymin=0, ymax=2.5) +
  scale_x_continuous(limits=c(0, 5)) + scale_y_continuous(limits=c(0,4))
-------------------------------------------------------------------------------------------------------
## plotting area with no axes
plot(unrate.df, type = "n")
lim <- par("usr")
## adding one rectangle
for (i in 1:nrow(recessions.trim)) {
     rect(recessions.trim[i, 1], lim[3], recessions.trim[i, 2], lim[4], border = "pink", col = "pink")
}
## adding the data
lines(unrate.df)
box()
-------------------------------------------------------------------------------------------------------
plot(unrate.df, type="n")
makeRectangles(recessions.trim, col="pink", alpha=0.5)
lines(unrate.df)
grid() makeRectangles makeRectangles = function(x, col, alpha=1, border=NA, ...) {

  col = col2rgb(col=col, alpha=FALSE)
  col = rgb(red=col[1], green=col[2], blue=col[3], 
              alpha=floor(255*alpha) , maxColorValue=255)
  rect(x[,1], par("usr")[3], x[,2], par("usr")[4], col=col, border=border, ...)

  return(invisible())
}
-------------------------------------------------------------------------------------------------------
hist() add = TRUE freq = FALSE set.seed(123)
x<-rnorm(100)

plot(x, exp(x)/(1+exp(x)), col = "green") # some plot
hist(x, freq = FALSE, add = TRUE) hist rect() plot.histogram h <- hist(x, plot = FALSE) # computation
rect(h$breaks[-length(h$breaks)], 0, h$breaks[-1], h$intensities) # plotting
-------------------------------------------------------------------------------------------------------
df2 <- melt(df1, id.vars=c("Loc", "Type"))
ggplot(data=df2, aes(x=value, fill=Type)) + 
  geom_bar() + facet_wrap(~ Loc + variable, nrow=1) facet_grid df2 <- melt(df1, id.vars=c("Loc", "Type"))
ggplot(data=df2, aes(x=value, fill=Type)) + 
  geom_bar() + facet_grid(Loc ~ variable) df2 <- melt(df1, id.vars=c("Loc", "Type"))
ggplot(data=df2, aes(x=value, fill=Type)) + 
  geom_rect(aes(fill=Loc),xmin =-Inf,xmax=Inf,ymin=-Inf,ymax=Inf,alpha = 0.1) +
  geom_bar() +
  facet_wrap(~ Loc + variable, nrow=1) ggextra
-------------------------------------------------------------------------------------------------------
require(ggplot2)
 p <- ggplot(mtcars, aes(wt, mpg)) 
 p + geom_point() + 
     geom_rect(aes(xmin = 2, xmax = 4, ymin = -Inf, ymax = Inf), fill = "pink", alpha = 0.03))
-------------------------------------------------------------------------------------------------------
"last.bumpup" colour=field geom_dl(aes(label=field, colour=field), list('last.bumpup', cex = 1.3, hjust = 1)) scale_colour_discrete(guide="none") p <- ggplot(mydf, aes(y=value, x=ano, group=field)) +
  geom_line(aes(group=field, colour=field), show_guide = FALSE) + 
  ylab("Number of B.A. degrees awarded") + xlab("year") + theme_hyper() + 
  theme(legend.key = element_rect(colour = "white")) +
  scale_y_continuous(labels=comma) +
  geom_dl(aes(label=field, colour=field), list('last.bumpup', cex = 1.3, hjust = 1)) +
  scale_colour_discrete(guide="none")
-------------------------------------------------------------------------------------------------------
as.numeric geom_rect() ggplot(melt(C)) +
  geom_point(aes(Var1,Var2)) +
  geom_rect(aes(xmin=as.numeric(Var1)-0.5*abs(value),xmax=as.numeric(Var1)+0.5*abs(value),ymin=as.numeric(Var2)-0.5*abs(value),ymax=as.numeric(Var2)+0.5*abs(value),fill=as.factor(sign(value)))) +
  theme_bw()
-------------------------------------------------------------------------------------------------------
MCsubsetDT1112 <- read.csv("~/Downloads/MCsubsetDT1112.csv")
MCsubsetTemp1112 <- read.csv("~/Downloads/MCsubsetTemp1112.csv")

ggplot() +
  geom_bar(data = MCsubsetDT1112, 
           aes(x=as.Date(Date,"%m/%d/%Y"), y=Mean, group=SiteSub, fill=SubstrateConcat),
           stat="identity", position="dodge") +
  geom_bar(data = MCsubsetDT1112, 
           aes(x=as.Date(Date,"%m/%d/%Y"), y=Mean, group=SiteSub, fill=SubstrateConcat),    
           stat="identity", position="dodge", color="black", show_guide=FALSE) +
  geom_line(aes(x=as.Date(Date,"%m/%d/%Y"),y=Mean,group=SiteSub,  color=WaterType, linetype=SubstrateConcat), 
            data=MCsubsetTemp1112, size=1) + 
  geom_hline(yintercept=20, linetype="dashed") +
  ylim(-5,35) +
  labs(x= "Date", y=expression("Temperature  " ( degree~C)), color="Water Type", 
        linetype="Substrate",fill="delta-T Substrate") +
  scale_linetype_manual(values=c("solid", "dashed", "dotdash"), 
                        labels=c("Bottom", "Column", "Surface")) +
  scale_x_date(labels=date_format("%b %Y")) +
  scale_color_manual(values=c("darkblue", "maroon"), labels=c("non-Warm", "Warm")) +
  scale_fill_manual(values=c("white", "black","grey"), labels=c("Bottom", "Surface")) +
  guides(linetype=guide_legend(override.aes=list(fill=NA)),
         color=guide_legend(override.aes=list(fill=NA)),
         fill = guide_legend(override.aes = list(color = "black"))) +
  theme(plot.title=element_text(color="black", size=16, face="bold"),
        axis.line=element_line(color="black"),
        axis.title=element_text(color="black", size=16),
        axis.text=element_text(color="black", size=14),
        panel.background=element_rect(fill="white"),
        legend.background=element_blank(),
        legend.text=element_text(color="black"),
        legend.key = element_rect(colour = "black",fill = NA)) as.Date()
-------------------------------------------------------------------------------------------------------
waterfall <- function(balance){
  balance$desc <- factor(balance$desc, levels = balance$desc)
  balance$id <- seq_along(balance$amount)
  balance$type <- ifelse(balance$amount > 0, "increase","decrease")
  balance[balance$id %in% c(1,dim(balance)[1]),"type"] <- "net"
  balance$end <- cumsum(balance$amount)
  balance$end <- c(head(balance$end, -1), 0)
  balance$start <- c(0, head(balance$end, -1))
  balance$type <- factor(balance$type, levels = c("decrease","increase", "net"))
  p1 <- ggplot(balance, aes(desc, fill = type)) + 
    geom_rect(aes(x = desc,xmin = id - 0.45, xmax = id + 0.45, ymin = end,ymax = start))+
    xlab("") + 
    ylab("") + 
    geom_text(data = subset(balance,type == "net" & id == min(id)), aes(id, end, label = comma(end), vjust = ifelse(end <start, 1, -0.3)), size = 4,fontface="bold") + 
    geom_text(data = subset(balance,type == "net" & id == max(id)), aes(id, start, label = comma(start), vjust = ifelse(end < start, -0.3, 1)), size = 4,fontface="bold")+
    theme_bw()+
    theme(legend.position = "none")
  if ("increase" %in% balance$type){
    p1 <- p1 + geom_text(subset = .(type == "increase"), aes(id,end, label = comma(amount)), vjust = 1, size = 4,fontface="bold")
  }
  if ("decrease" %in% balance$type){
    p1 <- p1 + geom_text(subset = .(type == "decrease"), aes(id,end, label = comma(amount)), vjust = -0.3,size = 4,fontface="bold")
  }
  p1
} scale_fill_manual(values = c(decrease = "indianred",increase ="forestgreen", net = "dodgerblue2"))
-------------------------------------------------------------------------------------------------------
