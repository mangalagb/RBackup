library(zoo)
## create data

x <- rnorm(365)
## transform to regular zoo series with "Date" index

x <- zooreg(x, start = as.Date("2004-01-01")) plot(x)

## add rolling/running/moving average with window size 7 

lines(rollmean(x, 7), col = 2, lwd = 2)

## if you don't want the rolling mean but rather a weekly ## time series of means you can do
nextfri <- function(x) 7 * ceiling(as.numeric(x - 1)/7) + as.Date(1) xw <- aggregate(x, nextfri, mean)

## nextfri is a function which computes for a certain "Date" ## the next friday. xw is then the weekly series. 

lines(xw, col = 4) rollmean() nextfri()
-------------------------------------------------------------------------------------------------------
plot.multi.dens <- function(s)
{
junk.x = NULL
junk.y = NULL
for(i in 1:length(s))
{
junk.x = c(junk.x, density(s[[i]])$x)
junk.y = c(junk.y, density(s[[i]])$y)
}
xr <- range(junk.x)
yr <- range(junk.y)
plot(density(s[[1]]), xlim = xr, ylim = yr, main = "")
for(i in 1:length(s))
{
lines(density(s[[i]]), xlim = xr, ylim = yr, col = i)
}
}
dnow <- read.table("http://dpaste.com/88561/plain/")
library(sqldf)
x <- unlist(sqldf("select V1 from dnow where V2==0"))
y <- unlist(sqldf("select V1 from dnow where V2==1"))
z <- unlist(sqldf("select V1 from dnow where V2==2"))
plot.multi.dens(list(x,y,z))
library(Hmisc)
le <- largest.empty(x,y,.1,.1)
legend(le,legend=c("x","y","z"), col=(1:3), lwd=2, lty = 1)
-------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------
X <- c(rep(65, times=5), rep(25, times=5), rep(35, times=10), rep(45, times=4))
hist(X, prob=TRUE)            # prob=TRUE for probabilities not counts
lines(density(X))             # add a density estimate with defaults
lines(density(X, adjust=2), lty="dotted")   # add another "smoother" density
-------------------------------------------------------------------------------------------------------
x <- read.csv(filename) require(zoo)
require(forecast) # Needed for the ses function
x$date <- as.Date(x$date,"%m/%d/%Y") # Guessing you are using the US date format
x$weight <- zoo(x$weight,x$date) # Allows for irregular dates
plot(x$weight, xlab="Date", ylab="Weight") # Produce time plot
ewma <- as.vector(fitted(ses(ts(x$weight)))) # Compute ewma with parameter selected using MLE
lines(zoo(ewma,x$date),col="red") # Add ewma line to plot
-------------------------------------------------------------------------------------------------------
valact <- subset(val, variable=='actual')
valsort <- valact[ order(-valact[,"Value"]),] boxplot() op <- par(mar=c(3,3,3,3)) 
bp <- barplot(valsort [ , "Value"], ylab="", xlab="", ylim=c(0,1),    
              names.arg=as.character(valsort[,"State"]), main="How's that?") 
lines(bp, cumsum(valsort[,"Value"])/sum(valsort[,"Value"]), 
      ylim=c(0,1.05), col='red') 
axis(4)
box() 
par(op) lines()
-------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------
lines() df <- data.frame(a = runif(10), b = runif(10), c = runif(10), x = 1:10) xyplot() library(lattice)
xyplot(a + b + c ~ x, data = df, type = "l", auto.key=TRUE) geom_line() library(ggplot2)
ggplot(melt(df, id.vars="x"), aes(x, value, colour = variable,
        group = variable)) + geom_line() + theme_bw() library(lattice)
dotplot(VADeaths, type = "o", auto.key = list(lines = TRUE,
     space = "right"), main = "Death Rates in Virginia - 1940",
     xlab = "Rate (per 1000)") library(ggplot2)
p <- ggplot(melt(VADeaths), aes(value, X1, colour = X2,
             group = X2))
p + geom_point() + geom_line() + xlab("Rate (per 1000)") +
         ylab("") + opts(title = "Death Rates in Virginia - 1940")
-------------------------------------------------------------------------------------------------------
x <- seq(as.POSIXct("1949-01-01", tz="GMT"), length=36, by="months")
y <- rnorm(length(x))

plot(x, y, type="l", xaxt="n")
rect(xleft=as.POSIXct("1950-01-01", tz="GMT"),
     xright=as.POSIXct("1950-12-01", tz="GMT"),
     ybottom=-4, ytop=4, col="#123456A0") # use alpha value in col
idx <- seq(1, length(x), by=6)
axis(side=1, at=x[idx], labels=format(x[idx], "%Y-%m")) plot(x, y, type="n", xaxt="n")
rect(xleft=as.POSIXct("1950-01-01", tz="GMT"),
     xright=as.POSIXct("1950-12-01", tz="GMT"),
     ybottom=-4, ytop=4, col="lightblue")
lines(x, y)
idx <- seq(1, length(x), by=6)
axis(side=1, at=x[idx], labels=format(x[idx], "%Y-%m"))
box()
-------------------------------------------------------------------------------------------------------
## create a long monthly sequence and a sub-sequence
months <- seq( as.Date("1950-01-01"), as.Date("2009-12-12"), by="month")
subset <- seq( as.Date("1970-01-01"), as.Date("1979-12-31"), by="month")

## generate some random values
set.seed(42)
values <- cumsum(rnorm(length(months)))

## plot as a zoo object, overlay a gray background and overplot a line in red
library(zoo)
Z <- zoo(values, months)
plot(Z)
rect(xleft=head(subset,1), xright=tail(subset,1),
     ybottom=par("usr")[3], ytop=par("usr")[4],
     density=NA, col="lightgray")
lines(Z[subset], col='red')
box() par("usr") zoo
-------------------------------------------------------------------------------------------------------
help(par) par(mar=c(3,3,1,1) par(cex=0.7) loadPredefinedLayout() zoo R> data <- data.frame(Year=seq(as.Date("2007-01-01"), \
                   as.Date("2010-01-01"), by="year"), \
                 Region1=c(17,26,53,96), Region2=c(55,43,70,58))
R> data
        Year Region1 Region2
1 2007-01-01      17      55
2 2008-01-01      26      43
3 2009-01-01      53      70
4 2010-01-01      96      58
R> par(mar=c(3,4,1,1)) 
R> plot(data$Year, data$Region1, type='l', col='blue', ylab="Values")
R> lines(data$Year, data$Region2, col='red')
R>
-------------------------------------------------------------------------------------------------------
R test <- read.table("/tmp/test.txt", header=TRUE)
png(filename="/tmp/test.png", height=750, width=1000, 
    bg="white", res=300)
par(mar=c(2.5,2.5,0.75,0.75), 
    family="Gill Sans", font=1, # font 2 would be bold
    cex=0.75, cex.lab=0.75, cex.axis=0.75) 
mymax <- max(test$Region1, test$Region2)*1.25

plot(test$Region1, type="b", col="#304E67", 
     ylim=c(0, mymax), lwd=3,
     bty="l", axes=FALSE, ann=FALSE, cex=1.0, tck=1)

axis(1, lwd.ticks=0, at=1:length(test$Year), lab=test$Year)
axis(2, lwd=0, las=1, at=c(0,25,50,75,100), yaxp=c(0,100,4))
# grid(nx = NA, ny = 5, col = "lightgray") # wrong, see axTicks
for(y in c(25, 50, 75, 100)) {
  lines(rep(y, length(test$Region1)), type="l", col="lightgray", lwd=1)
}

lines(test$Region1, type="b", col="#304E67", lwd=3)
lines(test$Region2, type="b", col="#974449", lwd=3)

# title(xlab="Year", col.lab=rgb(0,0.5,0))
# title(ylab="Output", col.lab=rgb(0,0.5,0))
legend(1, mymax+8, c("Region 1","Region 2"), cex=0.75, 
       col=c("#304E67" ,"#974449"), 
       pch=1:1, # circles
       lty=1:1, # solid 
       lwd=1.5, # line width
       bty="n") # no box around

dev.off() Year Region1 Region2
2007 17 55
2008 26 43
2009 53 70
2010 96 58
-------------------------------------------------------------------------------------------------------
x <- rlnorm(1000)
hx <- hist(x, plot=FALSE)
plot(hx$counts, type="h", log="y", lwd=10, lend="square") plot(hx$counts, type="h", log="y", lwd=10, lend="square", axes = FALSE)
Axis(side=1)
Axis(side=2) lwd lattice ggplot par(lend="square")
bordercol <- "blue"
fillcol <- "pink"
linewidth <- 24
plot(hx$counts, type="h", log="y", lwd=linewidth, col=bordercol, axes = FALSE)
lines(hx$counts, type="h", lwd=linewidth-2, col=fillcol)
Axis(side=1)
Axis(side=2)
-------------------------------------------------------------------------------------------------------
lm(y ~ poly(x)) lm(y ~ ns(x)) smooth.splines(x, y) lowess(x, y) ksmooth(x, y) spusmu(x, y) scripts/ch08.R
-------------------------------------------------------------------------------------------------------
submitted y1 <- submitted[30:(length(submitted)-1)]
x1 <- seq(length(y1)) seq() barplot() as.vector() fit1 <- nls(y1~a*x1*exp(-b*x1^2),start=list(a=500,b=.01),trace=TRUE)
bar <- barplot(submitted, las=2, cex.axis=0.8, cex=0.8)
bar2 <- as.vector(bar) bar2 lines() length() lines(x = bar2[30:(length(bar2)-1)], y = predict(fit1))
-------------------------------------------------------------------------------------------------------
barplot dat <- 1:5                   # fake data for barplot
fit <- dat+rnorm(5, sd=0.1)  # fake fitted values

bp <- barplot(dat)           # draw plot and capture x-coordinates
lines(bp, fit)               # add line idx x <- 0:(length(submitted)-1) 
idx <- 30:(length(submitted)-1)  # the part of the data to be modeled
y1 <- submitted[idx] 
x1 <- idx-30 
fit1 <- nls(y1~a*x1*exp(-b*x1^2),start=list(a=500,b=.01),trace=TRUE) 
# capture the midpoints from the barplot
bp <- barplot(submitted,names.arg=x, las=2, cex.axis=0.8, cex=0.8) 
# subset the midpoints to the range of the fit
lines(bp[idx], predict(fit1)) seq(0:n) 0:n
-------------------------------------------------------------------------------------------------------
error.bars<-function(xv,z,nn){
par(las = 1)
yv <- barplot(xv,horiz = TRUE,col="cyan",xlim=c(0,(max(xv)+max(z))),names=nn,xlab=deparse(substitute(xv)))
g <- (max(yv)-min(yv))/(3*length(yv)) 
for (i in 1:length(yv)) {
lines(c(xv[i]+z[i],xv[i]-z[i]),c(yv[i],yv[i]))
lines(c(xv[i]+z[i],xv[i]+z[i]),c(yv[i]+g,yv[i]-g))
lines(c(xv[i]-z[i],xv[i]-z[i]),c(yv[i]+g,yv[i]-g))
}}

plot.data <- plot.data[order(plot.data$mean),] # reorder data
mean<-as.vector(plot.data$mean)
se<-as.vector(plot.data$error)
labels<-as.character(plot.data$var)

error.bars(mean,se,labels)
-------------------------------------------------------------------------------------------------------
plot(cumfreq1, ylab="CumFreq",xlab="Loglik Ratio", type="l") 
          # or type="b" for lines and points
lines(cumfreq2, col="red")
-------------------------------------------------------------------------------------------------------
data <- read.table("http://dpaste.com/173536/plain/", header = FALSE)

sample1 <- unlist(apply(as.matrix(data),1,function(x) rep(x[1],x[2])))
sample2 <- unlist(apply(as.matrix(data),1,function(x) rep(x[1],x[3])))

plot(ecdf(sample1), verticals=TRUE, do.p=FALSE,
main="ECDF plot for both samples", xlab="Scores", 
ylab="Cumulative Percent",lty="dashed")

lines(ecdf(sample2), verticals=TRUE, do.p=FALSE,
col.h="red", col.v="red",lty="dotted")

legend(100,.8,c("Sample 1","Sample 2"),
col=c("black","red"),lty=c("dashed","dotted"))
-------------------------------------------------------------------------------------------------------
{ v1 <- readline("Number of rows?: "); v2 <- readline("Number of columns?: ") } readlines <- function(...) {
   lapply(list(...), readline)
}
readlines("Number of rows?: ", "Number of columns?: ")
-------------------------------------------------------------------------------------------------------
lines() points() plot(x,y1,type="l",col="red")
lines(x,y2,col="green")
-------------------------------------------------------------------------------------------------------
diseasesev<-c(1.9,3.1,3.3,4.8,5.3,6.1,6.4,7.6,9.8,12.4)
# Predictor variable, (Centigrade)
temperature<-c(2,1,5,5,20,20,23,10,30,25)

## For convenience, the data may be formatted into a dataframe
severity <- as.data.frame(cbind(diseasesev,temperature))

## Fit a linear model for the data and summarize the output from function lm()
severity.lm <- lm(diseasesev~temperature,data=severity)

# Function to plot the linear regression and overlay the confidence intervals   
ci.lines<-function(model,conf= .95 ,interval = "confidence"){
  x <- model[[12]][[2]]
  y <- model[[12]][[1]]
  xm<-mean(x)
  n<-length(x)
  ssx<- sum((x - mean(x))^2)
  s.t<- qt(1-(1-conf)/2,(n-2))
  xv<-seq(min(x),max(x),(max(x) - min(x))/100)
  yv<- coef(model)[1]+coef(model)[2]*xv

  se <- switch(interval,
        confidence = summary(model)[[6]] * sqrt(1/n+(xv-xm)^2/ssx),
        prediction = summary(model)[[6]] * sqrt(1+1/n+(xv-xm)^2/ssx)
              )
  # summary(model)[[6]] = 'sigma'

  ci<-s.t*se
  uyv<-yv+ci
  lyv<-yv-ci
  limits1 <- min(c(x,y))
  limits2 <- max(c(x,y))

  predictions <- predict(model, level = conf, interval = interval)

  insideCI <- predictions[,'lwr'] < y & y < predictions[,'upr']

  x_name <- rownames(attr(model[[11]],"factors"))[2]
  y_name <- rownames(attr(model[[11]],"factors"))[1]

  plot(x[insideCI],y[insideCI],
  pch=16,pty="s",xlim=c(limits1,limits2),ylim=c(limits1,limits2),
  xlab=x_name,
  ylab=y_name,
  main=paste("Graph of ", y_name, " vs ", x_name,sep=""))

  abline(model)

  points(x[!insideCI],y[!insideCI], pch = 16, col = 'red')

  lines(xv,uyv,lty=2,col=3)
  lines(xv,lyv,lty=2,col=3)
} ci.lines(severity.lm, conf= .95 , interval = "confidence")
ci.lines(severity.lm, conf= .85 , interval = "prediction")
-------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------
sites <- read.table("349.txt", header = TRUE, sep = "\t", quote="\"", dec=".") 
p<-as.Date(sites$date, origin="1960-01-01")
sgam1 <- gam(sites$y ~ s(sites$date))
sgam <- predict(sgam1, se=TRUE)
plot(p,sites$y, xlab='Time', ylab='Counts')
 lines(p,sgam$fit, lty = 1)
 lines(p,sgam$fit + 1.96* sgam$se, lty = 2)
 lines(p,sgam$fit - 1.96* sgam$se, lty = 2)
-------------------------------------------------------------------------------------------------------
qplot(x, y, data = df, geom = 'point') + stat_smooth() plot(x, y)
lines(loess.smooth(x,y))
-------------------------------------------------------------------------------------------------------
g <- (nrow(data)-1)/(3*nrow(data))

plot(data[,"dist.mean"],col=2, type='o',lwd=2,cex=1.5, main="This is the title of the graph",
 xlab="x-Label", ylab="y-Label", xaxt="n",
 ylim=c(0,max(data[,"dist.mean"])+max(data[,"dist.sd"])),
 xlim=c(1-g,nrow(data)+g))
axis(side=1,at=c(1:nrow(data)),labels=data[,"ob_time"])

for (i in 1:nrow(data)) {
lines(c(i,i),c(data[i,"dist.mean"]+data[i,"dist.sd"],data[i,"dist.mean"]-data[i,"dist.sd"]))
lines(c(i-g,i+g),c(data[i,"dist.mean"]+data[i,"dist.sd"], data[i,"dist.mean"]+data[i,"dist.sd"]))
lines(c(i-g,i+g),c(data[i,"dist.mean"]-data[i,"dist.sd"], data[i,"dist.mean"]-data[i,"dist.sd"]))
}
-------------------------------------------------------------------------------------------------------
set.seed(100)
Data <- rbind(matrix(rnorm(100, sd = 0.3), ncol = 2),
           matrix(rnorm(100, mean = 1, sd = 0.3), ncol = 2))
colnames(x) <- c("x", "y")

# noise <- runif(100,0,.05)
line.width <- rep(.004, dim(Data)[1])
Y <- NULL
X <- NULL
k.range <- 2:10

plot(0,0, col = "white", xlim = c(1,10), ylim = c(-.5,1.6),
    xlab = "Number of clusters", ylab = "Clusters means", main = "(Basic) Clustergram")
axis(side =1, at = k.range)
abline(v = k.range, col = "grey")

centers.points <- list()

for(k in k.range)
{
    cl <- kmeans(Data, k)

    clusters.vec <- cl$cluster
    the.centers <- apply(cl$centers,1, mean)

    noise <- unlist(tapply(line.width, clusters.vec, cumsum))[order(seq_along(clusters.vec)[order(clusters.vec)])]  
    noise <- noise - mean(range(noise))
    y <- the.centers[clusters.vec] + noise
    Y <- cbind(Y, y)
    x <- rep(k, length(y))
    X <- cbind(X, x)

    centers.points[[k]] <- data.frame(y = the.centers , x = rep(k , k)) 
#   points(the.centers ~ rep(k , k), pch = 19, col = "red", cex = 1.5)
}

require(colorspace)
COL <- rainbow_hcl(100)
matlines(t(X), t(Y), pch = 19, col = COL, lty = 1, lwd = 1.5)

# add points
lapply(centers.points, function(xx) {with(xx,points(y~x, pch = 19, col = "red", cex = 1.3))})
-------------------------------------------------------------------------------------------------------
n <- 20
x <- rnorm(n)
y <- rnorm(n)
o <- order(x)
x <- x[o]
y <- y[o]
m <- loess(y~x, span = 1) #ggplot seems to smooth more than default
f <- predict(m, se = TRUE)
ci <- f$se * qt(0.975, f$df)
cih <- f$fit + ci
cil <- f$fit - ci
plot(x,y, ylim = c(min(cil,y), max(cih,y)))
lines(x, f$fit, lwd = 2)
xx <- c(x, rev(x))
yy <- c(cil, rev(cih))
polygon(xx, yy, col="#A9A9A930", border = NA)
-------------------------------------------------------------------------------------------------------
#loess and error curves almost just like ggplot2
op <- par(las=1, mar = c(3,3,1,1))
n <- 30
x <- sort(rnorm(n)) #(varying density in predictor)
x <- x + abs(min(x))
x <- x/max(x)*2*pi 
y <- sin(x)+rnorm(n) #(curvy)
m <- loess(y~x)
xx <- seq(min(x), max(x), (max(x)-min(x))/1000) #increase density of values to predict over to increase quality of curve
f <- predict(m, xx, se = TRUE)
ci <- f$se * qt(0.975, f$df)
cih <- f$fit + ci
cil <- f$fit - ci
plot(x,y, ylim = c(min(cil,y), max(cih,y)), cex.axis = 0.85, xlab = '', ylab = '', type = 'n')
title(xlab = 'x', ylab = 'y',line = 2)
grid(col = 'gray')
points(x,y, pch = 19, cex = 0.65)
lines(xx, f$fit, col = 'blue', lwd = 1.2)
xx <- c(xx, rev(xx))
yy <- c(cil, rev(cih))
polygon(xx, yy, col=rgb(0.1,0.1,0.1,0.25), border = NA)
par(op)

#qplot(x,y, geom = 'point') + stat_smooth()
-------------------------------------------------------------------------------------------------------
...
X.Vec <- 10^c(xRange$lg.X, tail(xRange$lg.X, 1), rev(xRange$lg.X), xRange$lg.X[1])  
Y.Vec <- 10^c(ci.l, tail(ci.u, 1), rev(ci.u), ci.l[1])
..
matlines(10^xRange$lg.X, 10^model.ci, lty=c(1, 2, 2), type="l", col=c("black", "red", "red"))
...
-------------------------------------------------------------------------------------------------------
import rpy2.robjects
f = file("C:/R/library/MantelScript.R")
code = ''.join(f.readlines())
result = rpy2.robjects.r(code)
# assume that MantelScript creates a variable "X" in the R GlobalEnv workspace
X = rpy2.rojects.globalenv['X']
-------------------------------------------------------------------------------------------------------
loess() data.frame y ~ x x y lowess() loess() loess() lowess() ## create an example data set                                                                                                                                
x <- sort(rpois(100,10) + rnorm(100,0,2))
y <- x^2 + rnorm(100,0,7)
df <- data.frame(x = x,y = y)
plot(x,y)
## fit a lowess and plot it                                                                                                                                  
l.fit1 <- lowess(x,y,f = 0.3)
lines(l.fit1, col = 2,lwd = 2)

## fit a loess and plot it                                                                                                                                   
l.fit2 <- loess(y ~ x, data = df)
lines(x,predict(l.fit2,x), col = 3,lwd = 2)
-------------------------------------------------------------------------------------------------------
# create an empty plot. You may want to add xlab, ylab etc
# EDIT: also add some appropriate axis limits with xlim and ylim
plot(0, 0, "n", xlim=c(0, 10), ylim=c(0, 2))
levels <- unique(frame$f1)
for (l in levels)
    {
    lines(density(frame$x[frame$f1==l]))
    }
-------------------------------------------------------------------------------------------------------
loess() > x <- 1:10
> y <- c(2,4,6,8,7,12,14,16,18,20)
> lo <- loess(y~x)
> plot(x,y)
> lines(predict(lo), col='red', lwd=2) loess()
-------------------------------------------------------------------------------------------------------
smoothingSpline = smooth.spline(x, y, spar=0.35)
plot(x,y)
lines(smoothingSpline)
-------------------------------------------------------------------------------------------------------
x <- 1:10
y <- c(2,4,6,8,7,8,14,16,18,20)
lo <- loess(y~x)
plot(x,y)
xl <- seq(min(x),max(x), (max(x) - min(x))/1000)
lines(xl, predict(lo,xl), col='red', lwd=2)
-------------------------------------------------------------------------------------------------------
apply x <- rnorm(240) # imagine this to be 10 days of hourly data
xm <- matrix(x, ncol=24, byrow=TRUE)
daily.avg <- apply(xm, 1, mean)
plot(x)
lines(12 + seq(1,240,24), daily.avg)
-------------------------------------------------------------------------------------------------------
lower <- 0
upper <- 20
t <- seq(lower,upper,0.01)
fA <- dexp(t, rate = 0.4)
fB <- dgamma(t,shape = 8, rate = 2)
## C has the same distribution as (A + B)/2
dC <- function(x, lower, upper, exp.rate, gamma.rate, gamma.shape){
  integrand <- function(Y, X, exp.rate, gamma.rate, gamma.shape){
    dexp(Y, rate = exp.rate)*dgamma(2*X-Y, rate = gamma.rate, shape = gamma.shape)*2
  }
  out <- NULL
  for(ix in seq_along(x)){
    out[ix] <-
      integrate(integrand, lower = lower, upper = upper,
                X = x[ix], exp.rate = exp.rate,
                gamma.rate = gamma.rate, gamma.shape = gamma.shape)$value
  }
  return(out)
}
fC <- dC(t, lower=lower, upper=upper, exp.rate=0.4, gamma.rate=2, gamma.shape=8)
## plot the resulting distribution
plot(t,fA,
     ylim = range(fA,fB,na.rm=TRUE,finite = TRUE),
     xlab = 'x',ylab = 'f(x)',type = 'l')
lines(t,fB,lty = 2)
lines(t,fC,lty = 3)
legend('topright', c('A ~ exp(0.4)','B ~ gamma(8,2)', 'C ~ (A+B)/2'),lty = 1:3)
-------------------------------------------------------------------------------------------------------
# Averaged imputed data
combchl <- tapply(mat$chl,mat$.id,mean)
combbmi <- tapply(mat$bmi,mat$.id,mean)
combhyp <- tapply(mat$hyp,mat$.id,mean)

# coefficients
coefs <- pool(fit)$qbar

# regression results
x <- data.frame(
        int = rep(1,25),
        chl = seq(min(combchl),max(combchl),length.out=25),
        hyp = seq(min(combhyp),max(combhyp),length.out=25)
      )

y <- as.matrix(x) %*%coefs


# a plot
plot(combbmi~combchl)
lines(x$chl,y,col="red")
-------------------------------------------------------------------------------------------------------
segments() set.seed(2)
x <- 1:100

y <- 20 + 3 * x
e <- rnorm(100, 0, 60)
y <- 20 + 3 * x + e

plot(x,y)
yx.lm <- lm(y ~ x)
lines(x, predict(yx.lm), col="red")
## Add segments
segments(x, y, x, fitted(yx.lm), col = "blue") n <- c(58,65)
segments(x[n], y[n], x[n], fitted(yx.lm)[n], col = "orange", lwd = 3)
-------------------------------------------------------------------------------------------------------
set.seed(10)
bg <- rnorm(10000,2,0.1)

scatterangle <- runif(10000,5,35)
signal <- bg + -0.4*scatterangle +
     2000*exp(-((scatterangle - 24)/0.4)^2) +
     1000*exp(-((scatterangle - 12)/0.14)^2)+
     rnorm(10000,sd=100)

sv <- list(
    h1 =  2300, m1 = 23.42, s1 = 0.3,
    h2 =  900,  m2 = 11.64, s2 = 0.2,
    bg=2, a = -0.1)


res <- nls( signal ~ bg + a*scatterangle
    + h1*exp(-((scatterangle - m1)/s1)^2)
    + h2*exp(-((scatterangle - m2)/s2)^2)
    ,
    start=sv)

signal2 <- with(sv,{
    bg + a*scatterangle
    + h1*exp(-((scatterangle - m1)/s1)^2)
    + h2*exp(-((scatterangle - m2)/s2)^2)
    }
)

id <- order(scatterangle)
plot(signal[id]~scatterangle[id],
     t='l', axes=F, xlab=expression(2*theta),
    ylab="",col="grey")
lines(scatterangle[id],signal2[id],col='blue',lwd=2)
lines(scatterangle[id],predict(res, data.frame(scatterangle))[id],col='red',lwd=2)
-------------------------------------------------------------------------------------------------------
plot(x, y, type = "n") text text(x, y, labels = y) lines lines(x, y, col = "grey80") dfr <- data.frame(x = 1:5, y = 1:5)
p <- ggplot(dfr, aes(x, y)) + 
  geom_text(aes(x, y, label = y)) + 
  geom_line(col = "grey80")
p ggplot(df, aes(x, y)) + geom_point() + geom_line() + facet_wrap(~cat) geom_segment ggplot(df, aes(x, y)) + 
   facet_wrap(~cat) +
   geom_line() + 
   geom_point(size = 5, colour = "white") + 
   geom_point() + 
   opts(panel.background = theme_blank())
-------------------------------------------------------------------------------------------------------
x <- 1:10
y <- x + c(-0.5,0.5)

plot(x,y, xlim=c(0,11), ylim=c(-1,12))

fit1 <- lm( y~offset(x) -1 )
fit2 <- lm( y~x )
fit3 <- lm( y~poly(x,3) )
fit4 <- lm( y~poly(x,9) )
library(splines)
fit5 <- lm( y~ns(x, 3) )
fit6 <- lm( y~ns(x, 9) )

fit7 <- lm( y ~ x + cos(x*pi) )

xx <- seq(0,11, length.out=250)
lines(xx, predict(fit1, data.frame(x=xx)), col='blue')
lines(xx, predict(fit2, data.frame(x=xx)), col='green')
lines(xx, predict(fit3, data.frame(x=xx)), col='red')
lines(xx, predict(fit4, data.frame(x=xx)), col='purple')
lines(xx, predict(fit5, data.frame(x=xx)), col='orange')
lines(xx, predict(fit6, data.frame(x=xx)), col='grey')
lines(xx, predict(fit7, data.frame(x=xx)), col='black')
-------------------------------------------------------------------------------------------------------
layout(matrix(c(1,2), nrow = 1), widths = c(0.7, 0.3))
par(mar = c(5, 4, 4, 2) + 0.1)
plot(1:3, rnorm(3), pch = 1, lty = 1, type = "o", ylim=c(-2,2))
lines(1:3, rnorm(3), pch = 2, lty = 2, type="o")
par(mar = c(5, 0, 4, 2) + 0.1)
plot(1:3, rnorm(3), pch = 1, lty = 1, ylim=c(-2,2), type = "n", axes = FALSE, ann = FALSE)
legend(1, 1, c("group A", "group B"), pch = c(1,2), lty = c(1,2))
-------------------------------------------------------------------------------------------------------
load fisheriris            %# load some data
%#meas = zscore(meas);     %# to normalize the attributes
h = plot(meas');            %'# plot
set(gca, 'XTick',1:4, 'XTickLabel',{'SL' 'SW' 'PL' 'PW'}, 'XGrid','on')
ylabel('feature value'), title('Parallel Coordinates')

%# color according to class label
c = grp2idx(species);
clr = lines( numel(c) );
arrayfun(@(k) set(h(c==k),'Color',clr(k,:)), unique(c))
-------------------------------------------------------------------------------------------------------
d = {}
col_label_set = set()
row_label_set = set()
input =  open("input.txt")
output = open("output.txt","w")
for line in input:
    line = line.strip()
    splat = line.split(',')
    if len(splat) != 3:
        break # error message???
    k1, k2, v = splat
    try:
        subdict = d[k1]
    except KeyError:
        subdict = {}
        d[k1] = subdict
    subdict[k2] = v
    row_label_set.add(k1)
    col_label_set.add(k2)
col_labels = sorted(col_label_set)
row_labels = sorted(row_label_set
output.write("\t")
for v in col_labels::
    output.write(v + "\t")
output.write("\n")
for r in row_labels:
    output.write(r + "\t")
    for c in col_labels:
        output.write(d[r].get(c, "") + "\t")
    output.write("\n") class SparseTable(object):

    def __init__(self, iterable):
        d = {}
        col_label_set = set()
        for row_label, col_label, value in iterable:
            try:
                subdict = d[row_label]
            except KeyError:
                subdict = {}
                d[row_label] = subdict
            subdict[col_label] = value
            col_label_set.add(col_label)
        self.d = d
        self.col_label_set = col_label_set

    def tabulate(self, row_writer, corner_label=u"", missing=u""):
        d = self.d
        col_labels = sorted(self.col_label_set)
        row_labels = sorted(d.iterkeys())
        orow = [corner_label] + col_labels
        row_writer(orow)
        for row_label in row_labels:
            orow = [row_label]
            subdict = d[row_label]
            for col_label in col_labels:
                orow.append(subdict.get(col_label, missing))
            row_writer(orow)

if __name__ == "__main__":

    import sys

    test_data = u"""
    3277,4733,54.1
    3278,4741,51.0
    3278,4750,28.4
    3278,4768,36.0
    3278,4776,50.1
    3278,4784,51.4
    3279,4792,82.6
    3279,4806,78.2
    3279,4814,36.4
    """.splitlines(True)

    def my_writer(row):
        sys.stdout.write(u"\t".join(row))
        sys.stdout.write(u"\n")

    def my_reader(iterable):
        for line in iterable:
            line = line.strip()
            if not line: continue
            splat = line.split(u",")
            if len(splat) != 3:
                raise ValueError(u"expected 3 fields, found %d" % len(splat))
            yield splat

    table = SparseTable(my_reader(test_data))
    table.tabulate(my_writer, u"A/B", u"....") A/B     4733    4741    4750    4768    4776    4784    4792    4806    4814
3277    54.1    ....    ....    ....    ....    ....    ....    ....    ....
3278    ....    51.0    28.4    36.0    50.1    51.4    ....    ....    ....
3279    ....    ....    ....    ....    ....    ....    82.6    78.2    36.4
-------------------------------------------------------------------------------------------------------
plot(speed ~ dist, cars)

fit1 = lm(speed ~ dist, cars) #fits a linear model
abline(fit1) #puts line on plot
fit2 = lm(speed ~ I(dist^2) + dist, cars) #fits a model with a quadratic term
fit2line = predict(fit2, data.frame(dist = -10:130))
lines(-10:130 ,fit2line, col=2) #puts line on plot coef(fit2)
-------------------------------------------------------------------------------------------------------
locator() text() y <- rnorm(100, 10)
y2 <- rnorm(100, 20)
x <- 1:100

plot(x, y, type = "n", ylim = c(0, 40), xlim = c(0, 120))
lines(x, y)
lines(x, y2, col = "red")
text(locator(), labels = c("red line", "black line)"))
-------------------------------------------------------------------------------------------------------
hist lines duration <- rpois(500, 10) # For duration data I assume Poisson distributed
hist(duration,
   probability = TRUE, # In stead of frequency
   breaks = "FD",      # For more breaks than the default
   col = "darkslategray4", border = "seashell3")
lines(density(duration - 0.5),   # Add the kernel density estimate (-.5 fix for the bins)
   col = "firebrick2", lwd = 3) density > density(duration)

Call:
        density.default(x = duration)

Data: duration (500 obs.);      Bandwidth 'bw' = 0.7752

       x                 y            
 Min.   : 0.6745   Min.   :1.160e-05  
 1st Qu.: 7.0872   1st Qu.:1.038e-03  
 Median :13.5000   Median :1.932e-02  
 Mean   :13.5000   Mean   :3.895e-02  
 3rd Qu.:19.9128   3rd Qu.:7.521e-02  
 Max.   :26.3255   Max.   :1.164e-01 ?bw.nrd
-------------------------------------------------------------------------------------------------------
set.seed(1001)
tmpf <- function() {
  duration <- rpois(500, 10) # For duration data I assume Poisson distributed
  hist(duration,
       probability = TRUE, # In stead of frequency
       breaks = "FD",      # For more breaks than the default
       col = "darkslategray4", border = "seashell3",
       main="",ann=FALSE,axes=FALSE,xlim=c(0,25),ylim=c(0,0.15))
  box()
  lines(density(duration),   # Add the kernel density estimate
        col = "firebrick2", lwd = 3)
  par(new=TRUE)
  plot(table(factor(duration,levels=0:25))/length(duration),
       xlim=c(0,25),ylim=c(0,0.15),col=4,ann=FALSE,axes=FALSE)
}

par(mfrow=c(3,3),mar=rep(0,4))
replicate(9,tmpf())
-------------------------------------------------------------------------------------------------------
df2 df2 df <- data.frame(grp=c("A","A","B","B","C","C"),val=c(1,2,3,1,2,3))
df2 <- data.frame(grp=c("A","A","B","B","C","C"),val=c(1,4,3,5,0,2))

p <- ggplot(df, aes(x=grp, y=val)) 
p <- p + geom_bar(stat="identity", alpha=0.75) 

p + geom_line(data=df2, aes(x=grp, y=val), colour="blue") geom_point(data = df2, aes(x = grp, y = val), colour = "red", size = 6) geom_bar() geom_lines() #First let's summarise df2 by group
 df3 <- ddply(df2, .(grp), summarise, total = sum(val))
>  df3
  grp total
1   A     5
2   B     8
3   C     3

#Second, let's plot df3 as a line while treating the grp variable as numeric

p <- ggplot(df, aes(x=grp, y=val))
p <- p + geom_bar(alpha=0.75, stat = "identity") 
p + geom_line(data=df3, aes(x=as.numeric(grp), y=total), colour = "red")
-------------------------------------------------------------------------------------------------------
na.pad rollmean() TRUE > input <- c(3,7,3,5,2,9,1,4,6,4,7,3,7,4)
> rollmean(input, 4, na.pad = TRUE, align = "right")
 [1]   NA   NA   NA 4.50 4.25 4.75 4.25 4.00 5.00 3.75 5.25 5.00 5.25 5.25 cbind() > k <- 4
> c( cumsum(input[1:(k-1)]) / 1:(k-1), rollmean(input, k, align = "right") )
 [1] 3.000000 5.000000 4.333333 4.500000 4.250000 4.750000 4.250000 4.000000
 [9] 5.000000 3.750000 5.250000 5.000000 5.250000 5.250000 > ## model observed data
> mod <- smooth.spline(seq_along(input), input, df = 3)
> ## plot data and fitted spline
> plot(seq_along(input), input)
> lines(predict(mod, seq_along(input)), col = "red", lwd = 2)
> ## model the fudged MA
> mod2 <- smooth.spline(seq_along(input),
+                       c( cumsum(input[1:(k-1)]) / 1:(k-1),
+                         rollmean(input, k, align = "right") ), df = 3)
> ## add this estimated spline
> lines(predict(mod2, seq_along(input)), col = "blue", lwd = 2)
-------------------------------------------------------------------------------------------------------
lines() x <- 1:10
y <- x^2
y2 <- x^3

plot(x,y, type = "l")
lines(x, y2, col = "red") library(ggplot2)

df <- data.frame(x, y, y2)

df.m <- melt(df, id.var = "x")

qplot(x, value, data = df.m, colour = variable, geom = "line")

qplot(x, value, data = df.m, geom = "line")+ facet_wrap(~ variable)
-------------------------------------------------------------------------------------------------------
plot(), lines(), abline(), points(), polygon(), segments(), rect(), box(), arrows(), ... set.seed(100)
x <- 1:10
y <- x^2
y2 <- x^3
yse <- abs(runif(10,2,4))

plot(x,y, type = "n")  # type="n" only plots the pane, no curves or points.

# plots the area between both curves
polygon(c(x,sort(x,decreasing=T)),c(y,sort(y2,decreasing=T)),col="grey")
# plot both curves
lines(x,y,col="purple")
lines(x, y2, col = "red")
# add the points to the first curve
points(x, y, col = "black")
# adds some lines indicating the standard error
segments(x,y,x,y+yse,col="blue")
# adds some flags indicating the standard error
arrows(x,y,x,y-yse,angle=90,length=0.1,col="darkgreen")
-------------------------------------------------------------------------------------------------------
runif() x <- seq( 0, 2, by=0.01 )
y <- sin( 2 * pi * cos( x - 1/2 ) ) +runif(201)
plot( x,y  )
lines(loess(y~x)$x, lowess(y~x)$y)
-------------------------------------------------------------------------------------------------------
slo<-0.5 #slope of underlying trend
sta<--0.5 #starting y value
amp<-0.2 #amplitude of sine wave
fre<-3 #frequency of sine wave
noi<-0.8 #amplitude of noise term
x<-seq(0,2,0.01)
y<-sta+(slo*x)+(amp*sin(fre*x)) #y no noise
ywnoise<-y+(noi*(runif(length(x))-0.5)) #y with noise

plot(x,ywnoise)
lines(x,y, col="orange")
grid()
-------------------------------------------------------------------------------------------------------
sm require(sm)
foo <- data.frame(Return=rpois(100,5))
foo$density <- sm.density(foo$Return,eval.points=foo$Return)$estimate
# the plot
id <- order(foo$Return)
hist(foo$Return,freq=F)
lines(foo$Return[id],foo$density[id],col="red") foo$counts <- ave(foo$Return,foo$Return,FUN=length) plot(density(foo$Return)) freq=F hist(foo$Return,freq=F)
lines(density(foo$Return),col="red")
-------------------------------------------------------------------------------------------------------
sm.density approx approxfun Returns set.seed(1)
foo <- data.frame(Date = seq(as.Date("2010-01-01"), as.Date("2010-12-31"),
                             by = "days"),
                  Returns = rnorm(365))
head(foo)
## compute the density, on fin grid (512*8 points)
dens <- with(foo, density(Returns, n = 512 * 8)) approx() x y approxfun() ## x and y are components of dens, see str(dens)
BAR <- with(dens, approxfun(x = x, y = y)) BAR() Returns > with(foo, BAR(Returns[1]))
[1] 0.3268715 Returns > foo <- within(foo, Density <- BAR(Returns))
> head(foo)
        Date    Returns   Density
1 2010-01-01 -0.6264538 0.3268715
2 2010-01-02  0.1836433 0.3707068
3 2010-01-03 -0.8356286 0.2437966
4 2010-01-04  1.5952808 0.1228251
5 2010-01-05  0.3295078 0.3585224
6 2010-01-06 -0.8204684 0.2490127 Returns lines plot(dens)
with(foo, lines(sort(Returns), BAR(sort(Returns)), col = "red")) Returns lines() lines()
-------------------------------------------------------------------------------------------------------
x<-round(rnorm(1000, 100, 15))
y<-table(x)
plot(y)
par(new=TRUE)
plot(density(x), yaxt="n", ylab="", xlab="", xaxt="n") lines(sort(x), dnorm(sort(x), 100, 15), col="red") points(x, dnorm(x, 100, 15))
-------------------------------------------------------------------------------------------------------
set.seed(1)
N <- 5000
DF <- data.frame(Y = rev(sort(rlnorm(N, -0.9))) + rnorm(N),
                 X = seq_len(N))
plot(Y ~ X, data = DF) mod <- rq(Y ~ log(X), data = DF, tau = .99) X pDF <- data.frame(X = seq(1, 5000, length = 100))
pDF <- within(pDF, Y <- predict(mod, newdata = pDF)) lines(Y ~ X, data = pDF, col = "red", lwd = 2)
-------------------------------------------------------------------------------------------------------
xyplot xyplot.zoo plot.zoo xblocks dts <- as.Date("20050101", '%Y%m%d') + seq(0,1000,15)
A <- data.frame( Dates = dts, Gas = 4000 + cumsum(abs( rnorm(length(dts), 100, 30))))

A <- transform( A,               
               Year = format(Dates, '%Y'),
               DayOfYear = as.numeric( format(Dates, '%j')),
               GasDiff = c(diff( Gas ),NA)) library(lattice) # xyplot
library(latticeExtra) # layer_, panel.xblocks
library(gridExtra) # grid.arrange
library(RColorBrewer) # brewer.pal

png("png1.png")
p1 <- xyplot(GasDiff ~ Dates, group = Year, A, type = "l",
    par.settings = list(superpose.line = list(col = 1:nlevels(A$Year))),
    auto.key = list(lines = TRUE, points = FALSE))

p2 <- xyplot(GasDiff ~ DayOfYear | Year, A, type = "l", layout = c(1, 3))

p3 <- xyplot(GasDiff ~ DayOfYear, A, group = Year, type = "l",
    auto.key = list(lines = TRUE, points = FALSE))

# and here is another style:

myPalette <- brewer.pal(nlevels(A$Year), "Set3")
p4 <- xyplot(GasDiff ~ Dates, A, type = "l", col = 1) + 
    layer_(panel.xblocks(A$Dates, myPalette[A$Year]))

grid.arrange(nrow = 2, p1, p2, p3, p4)
dev.off() png("png2.png")
library(zoo)
library(lattice)
library(latticeExtra) # layer_, panel.xblocks
library(gridExtra) # grid.arrange
library(RColorBrewer) # brewer.pal

z <- with(A, zoo(GasDiff, Dates))
year <- format(time(z), "%Y")

# split years into separate columns and plot
P1 <- xyplot(do.call("merge", split(z, year)), screen = 1, col = 1:3)

# split years into separate columns and use day.of.year as time
day.of.year <- function(x) as.numeric(format(x, "%j"))
zz <- read.zoo(A[c(1, 5, 3)], FUN = day.of.year, split = 3)
colnames(zz) <- unique(year)
P2 <- xyplot(na.approx(zz, na.rm = FALSE))

P3 <- xyplot(na.approx(zz, na.rm = FALSE), screen = 1, col = 1:3, auto.key = TRUE)

pal <- brewer.pal(nlevels(factor(year)), "Set3")
P4 <- xyplot(z, screen = 1) + layer_(panel.xblocks(time(z), pal[factor(year)]))

grid.arrange(nrow = 2, P1, P2, P3, P4)
dev.off() z zz pal library(zoo)
library(RColorBrewer) # brewer.pal

png("png3a.png")
plot(do.call("merge", split(z, year)), screen = 1, col = 1:3)
dev.off()
png("png3b.png")
plot(na.approx(zz, na.rm = FALSE))
dev.off()
png("png3c.png")
plot(na.approx(zz, na.rm = FALSE), screen = 1, col = 1:3)
legend("topleft", colnames(zz), lty = 1, col = 1:3, bty = "n")
dev.off()
png("png3d.png")
plot(z, type = "n")
xblocks(time(z), pal[factor(year)])
lines(z)
dev.off()
-------------------------------------------------------------------------------------------------------
TkBuildDist <- function(  x=seq(min+(max-min)/nbin/2,
                                max-(max-min)/nbin/2,
                                length.out=nbin),
                          min=0, max=10, nbin=10, logspline=TRUE,
                          intervals=FALSE) {

    if(logspline) logspline <- require(logspline)
    require(tkrplot)

    xxx <- x

    brks <- seq(min, max, length.out=nbin+1)
    nx <- seq( min(brks), max(brks), length.out=250 )

    lx <- ux <- 0
    first <- TRUE

    replot <- if(logspline) {
        if(intervals) {
            function() {
                hist(xxx, breaks=brks, probability=TRUE,xlab='', main='')
                xx <- cut(xxx, brks, labels=FALSE)
                fit <- oldlogspline( interval = cbind(brks[xx], brks[xx+1]) )
                lines( nx, doldlogspline(nx,fit), lwd=3 )
                if(first) {
                    first <<- FALSE
                    lx <<- grconvertX(min, to='ndc')
                    ux <<- grconvertX(max, to='ndc')
                }
            }
        } else {
            function() {
                hist(xxx, breaks=brks, probability=TRUE,xlab='', main='')
                fit <- logspline( xxx )
                lines( nx, dlogspline(nx,fit), lwd=3 )
                if(first) {
                    first <<- FALSE
                    lx <<- grconvertX(min, to='ndc')
                    ux <<- grconvertX(max, to='ndc')
                }
            }
        }
    } else {
        function() {
            hist(xxx, breaks=brks, probability=TRUE,xlab='',main='')
            if(first) {
                first <<- FALSE
                lx <<- grconvertX(min, to='ndc')
                ux <<- grconvertX(max, to='ndc')
            }
        }
    }

    tt <- tktoplevel()
    tkwm.title(tt, "Distribution Builder")

    img <- tkrplot(tt, replot, vscale=1.5, hscale=1.5)
    tkpack(img, side='top')

    tkpack( tkbutton(tt, text='Quit', command=function() tkdestroy(tt)),
           side='right')

    iw <- as.numeric(tcl('image','width',tkcget(img,'-image')))

    mouse1.down <- function(x,y) {
        tx <- (as.numeric(x)-1)/iw
        ux <- (tx-lx)/(ux-lx)*(max-min)+min
        xxx <<- c(xxx,ux)
        tkrreplot(img)
    }

    mouse2.down <- function(x,y) {
        if(length(xxx)) {
            tx <- (as.numeric(x)-1)/iw
            ux <- (tx-lx)/(ux-lx)*(max-min)+min
            w <- which.min( abs(xxx-ux) )
            xxx <<- xxx[-w]
            tkrreplot(img)
        }
    }

    tkbind(img, '<ButtonPress-1>', mouse1.down)
    tkbind(img, '<ButtonPress-2>', mouse2.down)
    tkbind(img, '<ButtonPress-3>', mouse2.down)

    tkwait.window(tt)

    out <- list(x=xxx)
    if(logspline) {
        if( intervals ) {
            xx <- cut(xxx, brks, labels=FALSE)
            out$logspline <- oldlogspline( interval = cbind(brks[xx], brks[xx+1]) )
        } else {
            out$logspline <- logspline(xxx)
        }
    }

    if(intervals) {
        out$intervals <- table(cut(xxx, brks))
    }

    out$breaks <- brks

    return(out)
} TkBuildDist2 <- function( min=0, max=1, nbin=10, logspline=TRUE) {
    if(logspline) logspline <- require(logspline)
    require(tkrplot)

    xxx <- rep( 1/nbin, nbin )

    brks <- seq(min, max, length.out=nbin+1)
    nx <- seq( min, max, length.out=250 )

    lx <- ux <- ly <- uy <- 0
    first <- TRUE

    replot <- if(logspline) {
        function() {
            barplot(xxx, width=diff(brks), xlim=c(min,max), space=0,
                    ylim=c(0,0.5), col=NA)
            axis(1,at=brks)
            xx <- rep( 1:nbin, round(xxx*100) )
            capture.output(fit <- oldlogspline( interval = cbind(brks[xx], brks[xx+1]) ))
            lines( nx, doldlogspline(nx,fit)*(max-min)/nbin, lwd=3 )

            if(first) {
                first <<- FALSE
                lx <<- grconvertX(min, to='ndc')
                ly <<- grconvertY(0,   to='ndc')
                ux <<- grconvertX(max, to='ndc')
                uy <<- grconvertY(0.5, to='ndc')
            }
        }
    } else {
        function() {
            barplot(xxx, width=diff(brks), xlim=range(brks), space=0,
                    ylim=c(0,0.5), col=NA)
            axis(at=brks)
            if(first) {
                first <<- FALSE
                lx <<- grconvertX(min, to='ndc')
                ly <<- grconvertY(0,   to='ndc')
                ux <<- grconvertX(max, to='ndc')
                uy <<- grconvertY(0.5, to='ndc')
            }
        }
    }

    tt <- tktoplevel()
    tkwm.title(tt, "Distribution Builder")

    img <- tkrplot(tt, replot, vscale=1.5, hscale=1.5)
    tkpack(img, side='top')

    tkpack( tkbutton(tt, text='Quit', command=function() tkdestroy(tt)),
           side='right')

    iw <- as.numeric(tcl('image','width',tkcget(img,'-image')))
    ih <- as.numeric(tcl('image','height',tkcget(img,'-image')))



    md <- FALSE

    mouse.move <- function(x,y) {
        if(md) {
            tx <- (as.numeric(x)-1)/iw
            ty <- 1-(as.numeric(y)-1)/ih

            w <- findInterval(tx, seq(lx,ux, length=nbin+1))

            if( w > 0 && w <= nbin && ty >= ly && ty <= uy ) {
                 xxx[w] <<- 0.5*(ty-ly)/(uy-ly)
                xxx[-w] <<- (1-xxx[w])*xxx[-w]/sum(xxx[-w])

                tkrreplot(img)
            }
        }
    }

    mouse.down <- function(x,y) {
        md <<- TRUE
        mouse.move(x,y)
    }

    mouse.up <- function(x,y) {
        md <<- FALSE
    }

    tkbind(img, '<Motion>', mouse.move)
    tkbind(img, '<ButtonPress-1>', mouse.down)
    tkbind(img, '<ButtonRelease-1>', mouse.up)

    tkwait.window(tt)

    out <- list(breaks=brks, probs=xxx)
    if(logspline) {
        xx <- rep( 1:nbin, round(xxx*100) )
        out$logspline <- oldlogspline( interval = cbind(brks[xx], brks[xx+1]) )
    }

    return(out)
}
-------------------------------------------------------------------------------------------------------
w_sp <- sample(seq(0, 100, 0.01), 1000)
power <- 1/(1+exp(-(w_sp -40)/5)) + rnorm(1000, sd = 0.1)

plot(w_sp, power)

x_grid <- seq(0, 100, length = 100)
lines(x_grid, predict(loess(power ~ w_sp), x_grid), col = "red", lwd = 3)
-------------------------------------------------------------------------------------------------------
mgcv w_sp <- sample(seq(0, 100, 0.01), 1000)
power <- 1/(1+exp(-(w_sp -40)/5)) + rnorm(1000, sd = 0.1)
df <- data.frame(power = power, w_sp = w_sp) gam() require(mgcv)
mod <- gam(power ~ s(w_sp, bs = "ad", k = 20), data = df, method = "REML")
summary(mod) x_grid <- with(df, data.frame(w_sp = seq(min(w_sp), max(w_sp), length = 100)))
pred <- predict(mod, x_grid, se.fit = TRUE)
x_grid <- within(x_grid, fit <- pred$fit)
x_grid <- within(x_grid, upr <- fit + 2 * pred$se.fit)
x_grid <- within(x_grid, lwr <- fit - 2 * pred$se.fit) plot(power ~ w_sp, data = df, col = "grey")
lines(fit ~ w_sp, data = x_grid, col = "red", lwd = 3)
## upper and lower confidence intervals ~95%
lines(upr ~ w_sp, data = x_grid, col = "red", lwd = 2, lty = "dashed")
lines(lwr ~ w_sp, data = x_grid, col = "red", lwd = 2, lty = "dashed")
## add loess fit from @hadley's answer
lines(x_grid$w_sp, predict(loess(power ~ w_sp, data = df), x_grid), col = "blue",
      lwd = 3)
-------------------------------------------------------------------------------------------------------
plotfun <- function(x) {
    plot( c(-0.5,-0.5,0.5,0.5), c(0,1,1,0), col='blue', xlim=c(-2,2),
         type='l', xlab='', ylab='' )
    if( x > -1 && x < 0 ) {
        polygon( c(-0.5, -0.5, x+0.5, x+0.5), c(0,1,1,0), col='yellow', border=NA )
        lines( c(-0.5, -0.5, 0.5, 0.5), c(0,1,1,0), col='blue' )
        lines( c(-1,x), c(0,x+1) )
    } else if( x >= 0 && x < 1 ) {
        polygon( c(x-0.5, x-0.5, 0.5, 0.5), c(0,1,1,0), col='yellow', border=NA )
        lines( c(-0.5, -0.5, 0.5, 0.5), c(0,1,1,0), col='blue' )
        lines( c(-1,0,x), c(0,1,1-x) )
    } else if (x >= 1) {
        lines( c(-1,0,1), c(0,1,0) )
    }
    abline(v=x, lty=3)
    lines( c(x-0.5,x-0.5,x+0.5,x+0.5), c(0,1,1,0), col='red' )
}

dev.new(height=3, width=6)

for(i in seq(-2.5, 2.5, 0.05) ) {
    plotfun(i)
    Sys.sleep(0.1)
} library(TeachingDemos)

tkexamp( plotfun, list(x=list('slider', from=-2.5, to=2.5, resolution=0.01)),
    vscale=1)
-------------------------------------------------------------------------------------------------------
chull() require(stats)
X <- matrix(rnorm(2000), ncol = 2)
chull(X)
## Not run: 
# Example usage from graphics package
plot(X, cex = 0.5)
hpts <- chull(X)
hpts <- c(hpts, hpts[1])
lines(X[hpts, ])
-------------------------------------------------------------------------------------------------------
x <- ts(myzoo,f=4)
fit <- ts(rowSums(tsSmooth(StructTS(x))[,-2]))
tsp(fit) <- tsp(x)
plot(x)
lines(fit,col=2)
-------------------------------------------------------------------------------------------------------
set.seed(1)
randomData <- c(rnorm(100, 5, 3), rnorm(100, 20, 3) )
hist(randomData, freq=FALSE)
lines(density(randomData), col="red") bw <- density(randomData)$bw
resample <- sample( randomData, 10000, replace=TRUE) noise <- rnorm(10000, 0, bw)
hist(resample + noise, freq=FALSE)
lines(density(randomData), col="red")
-------------------------------------------------------------------------------------------------------
help(par) plot(1:10, type='n', xlim=c(1,10), ylim=c(0,7))
for (i in 1:6) lines(1:10, rep(i, 10), lty=i)
-------------------------------------------------------------------------------------------------------
stime <- as.POSIXct("2011-01-01-00:00:00", format = "%Y-%d-%m-%H:%M:%S")
## dummy data
dat <- data.frame(Timestamp = seq(from = stime, by = 5, length = 2000000),
                  DD1 = sample(1:1000, replace = TRUE),
                  DD2 = sample(1:1000, replace = TRUE),
                  DD3 = sample(1:1000, replace = TRUE),
                  DD4 = sample(1:1000, replace = TRUE))
## write it out
write.csv(dat, file = "timestamp_data.txt", row.names = FALSE) "POSIXct" ## read it in:
system.time({
             tsdat <- read.csv("timestamp_data.txt", header = TRUE,
                                 colClasses = c("POSIXct",rep("integer", 4)))
            }) user  system elapsed 
 13.698   5.827  19.643 aggregate() ## Generate some indexes that we'll use the aggregate over
tsdat <- transform(tsdat,
                   hours   = factor(strftime(tsdat$Timestamp, format = "%H")),
                   jday    = factor(strftime(tsdat$Timestamp, format = "%j")))
## compute the mean of the 4 variables for each minute
out <- aggregate(cbind(Timestamp, DD1, DD2, DD3, DD4) ~ hours + jday, 
                 data = tsdat, FUN = mean)
## convert average Timestamp to a POSIX time
out <- transform(out,
                 Timestamp = as.POSIXct(Timestamp, 
                                        origin = ISOdatetime(1970,1,1,0,0,0))) out > head(out)
  hours jday           Timestamp      DD1      DD2      DD3      DD4
1    00  001 2010-12-31 23:29:57 500.2125 491.4333 510.7181 500.4833
2    01  001 2011-01-01 00:29:57 516.0472 506.1264 519.0931 494.2847
3    02  001 2011-01-01 01:29:57 507.5653 499.4972 498.9653 509.1389
4    03  001 2011-01-01 02:29:57 520.4111 500.8708 514.1514 491.0236
5    04  001 2011-01-01 03:29:57 498.3222 500.9139 513.3194 502.6514
6    05  001 2011-01-01 04:29:57 515.5792 497.1194 510.2431 496.8056 plot() plot(DD1 ~ Timestamp, data = out, type = "l") ylim <- with(out, range(DD1, DD2))
plot(DD1 ~ Timestamp, data = out, type = "l", ylim = ylim)
lines(DD2 ~ Timestamp, data = out, type = "l", col = "red") layout(1:2)
plot(DD1 ~ Timestamp, data = out, type = "l", col = "blue")
plot(DD2 ~ Timestamp, data = out, type = "l", col = "red")
layout(1)
-------------------------------------------------------------------------------------------------------
starttime <- strptime("20110110", "%Y%m%d")
 endtime <- strptime("20110226 1202", "%Y%m%d %H%M")
 #This is actually determined programmatically, but that's not important
 xrange <- c(starttime, endtime)
 yrange <- c(0, 100)
 par(mar=par()$mar+c(0,0,0,7),bty="l")

 #I added xaxt="n" to supress the plotting of the x-axis
 plot(xrange, yrange, type="n", xaxt="n", xlab="Submission Time", ylab="Best Score", main="Top Scores for each team over time")

 #I added the following two lines to plot the x-axis with a label every 7 days
 atx <- seq(starttime, endtime, by=7*24*60*60)
 axis(1, at=atx, labels=format(atx, "%b\n%d"), padj=0.5)

 #More code to loop and add a bunch of lines(), but it's not really relevant
-------------------------------------------------------------------------------------------------------
library(rpanel)

#Generate the x1 and x2 data
n1 <- rnorm(500)
n2 <- rnorm(200)
x1 <- c(n1, rep(0,100), n2, rep(0,150))
x2 <- c(rep(0,50), 2*n1, rep(0,150), 3*n2, rep(0,50))

#Build the panel function that will draw/update the graph
lvm.draw <- function(panel) {
       plot(x=(1:length(panel$dat3))+panel$off, y=panel$dat3, ylim=panel$dat1, xlab="", ylab="y", main=paste("Alignment Graph   Offset = ", panel$off, "   Scale = ", panel$sca, sep=""), typ="l")
       lines(x=1:length(panel$dat3), y=panel$sca*panel$dat4, col="red")
       grid()
       panel
}

#Build the panel
xlimdat <- c(1, length(x1))
ylimdat <- c(-5, 5)
panel <- rp.control(title = "Eye-Ball-It", dat1=ylimdat, dat2=xlimdat, dat3=x1, dat4=x2, off=100, sca=1.0, size=c(300, 160))
rp.slider(panel, var=off, from=-500, to=500, action=lvm.draw, title="Offset", pos=c(5, 5, 290, 70), showvalue=TRUE)
rp.slider(panel, var=sca, from=0, to=2, action=lvm.draw, title="Scale", pos=c(5, 70, 290, 90), showvalue=TRUE)
-------------------------------------------------------------------------------------------------------
k = 20 ## here we create a data frame with the pwr and spd variables
df <- data.frame(pwr = pwr, spd = spd)

## we load the package containing the code to fit the additive model
require(mgcv)

## This is the model itself, saying pwr is modelled as a smooth function of spd
## and the smooth function of spd is generated using an adaptive smoother with
## and "allowance" of 20. This allowance is a starting point and the actual
## smoothness of the curve will be estimated as part of the model fitting,
## here using a REML criterion
mod <- gam(pwr ~ s(spd, bs = "ad", k = 20), data = df, method = "REML")

## This just summarise the model fit
summary(mod)

## In this line we are creating a new spd vector (in a data frame) that contains
## 100 equally spaced spd values over the entire range of the observed spd
x_grid <- with(df, data.frame(spd = seq(min(spd) + 0.0001, maxi, length=100)))

## we will use those data to get predictions of the response pwr at each
## of the 100 values of spd we just created
## I did this so we had enough data to plot a nice smooth curve, but without
## having to predict for all the observed values of spd
pred <- predict(mod, x_grid, se.fit = TRUE)

## This line stores the 100 predicted values in the prediction data object
x_grid <- within(x_grid, fit <- pred$fit)

## This line draws the fitted smooth on to a plot of the data
## this assumes there is already a plot on the active device.
lines(fit ~ spd, data = x_grid, col = "red", lwd = thickLineWidth)
-------------------------------------------------------------------------------------------------------
data(SIM3DATA)
plotroc <- roc.plot.calculate(SIM3DATA,which.model=2, xlab = NULL, ylab = NULL)
plot(plotroc$threshold, plotroc$sensitivity, type="l", col="blue ")   
lines(plotroc$threshold, plotroc$specificity)    
lines(plotroc$threshold, (plotroc$specificity+plotroc$sensitivity)/2, col="red")
lines(1 - plotroc$specificity, plotroc$sensitivity, lwd = 2, lty = 5)
-------------------------------------------------------------------------------------------------------
import threading
from collections import deque
import sys
import mmap


class processor(Thread):
    """
        processor gets a batch of data at time from the diskio thread
    """
    def __init__(self,q):
        Thread.__init__(self,name="plotter")
        self._queue = q
    def run(self):
        #get batched data 
        while True:
            #we wait for a batch
            dataloop = self.feed(self._queue.get())
            try:
                while True:
                    self.plot(dataloop.next())
            except StopIteration:
                pass
            #sanitizer exceptions following, maybe

    def parseline(self,line):
        """ return a data struct ready for plotting """
        raise NotImplementedError

    def feed(self,databuf):
        #we yield one-at-time datastruct ready-to-go for plotting
        for line in databuf:
            yield self.parseline(line)

    def plot(self,data):
        """integrate
        https://www.esclab.tw/wiki/index.php/Matplotlib#Asynchronous_plotting_with_threads
        maybe
        """
class sharedq(object):
    """i dont recall where i got this implementation from 
    you may write a better one"""
    def __init__(self,maxsize=8192):
        self.queue = deque()
        self.barrier = threading.RLock()
        self.read_c = threading.Condition(self.barrier)
        self.write_c = threading.Condition(self.barrier)
        self.msz = maxsize
    def put(self,item):
        self.barrier.acquire()
        while len(self.queue) >= self.msz:
            self.write_c.wait()
        self.queue.append(item)
        self.read_c.notify()
        self.barrier.release()
    def get(self):
        self.barrier.acquire()
        while not self.queue:
            self.read_c.wait()
        item = self.queue.popleft()
        self.write_c.notify()
        self.barrier.release()
        return item



q = sharedq()
#sizehint for readine lines
numbytes=1024
for i in xrange(8):
    p = processor(q)
    p.start()
for fn in sys.argv[1:]
    with open(fn, "r+b") as f:
        #you may want a better sizehint here
        map = mmap.mmap(f.fileno(), 0)
        #insert a loop here, i forgot
        q.put(map.readlines(numbytes))

#some cleanup code may be desirable
-------------------------------------------------------------------------------------------------------
dat smooth.spline() n n = 48 SSpline <- function(x, y, n = 48, ...) {
    ## fit the spline to x, and y
    mod <- smooth.spline(x, y, ...)
    ## predict from mod for n points over range of x
    pred.dat <- seq(from = min(x), to = max(x), length.out = n)
    ## predict
    preds <- predict(mod, x = pred.dat)
    ## return
    preds
} > res <- SSpline(time, dat[1, 2:9])
> res
$x
 [1]  0.000000  0.893617  1.787234  2.680851  3.574468  4.468085  5.361702
 [8]  6.255319  7.148936  8.042553  8.936170  9.829787 10.723404 11.617021
[15] 12.510638 13.404255 14.297872 15.191489 16.085106 16.978723 17.872340
[22] 18.765957 19.659574 20.553191 21.446809 22.340426 23.234043 24.127660
[29] 25.021277 25.914894 26.808511 27.702128 28.595745 29.489362 30.382979
[36] 31.276596 32.170213 33.063830 33.957447 34.851064 35.744681 36.638298
[43] 37.531915 38.425532 39.319149 40.212766 41.106383 42.000000

$y
 [1]  0.052349585  0.001126837 -0.049851737 -0.100341294 -0.150096991
 [6] -0.198873984 -0.246427429 -0.292510695 -0.336721159 -0.378381377
[11] -0.416785932 -0.451229405 -0.481006377 -0.505411429 -0.523759816
[16] -0.535714043 -0.541224748 -0.540251293 -0.532753040 -0.518689349
[21] -0.498019582 -0.470750611 -0.437182514 -0.397727107 -0.352796426
[26] -0.302802508 -0.248157388 -0.189272880 -0.126447574 -0.059682959
[31]  0.011067616  0.085850805  0.164713260  0.247701633  0.334851537
[36]  0.425833795  0.519879613  0.616194020  0.713982047  0.812448724
[41]  0.910799082  1.008296769  1.104781306  1.200419068  1.295380186
[46]  1.389834788  1.483953003  1.577904960

> plot(time, dat[1, 2:9])
> lines(res, col = "blue") $y SSpline() apply() > res2 <- apply(dat[, 2:9], 1,
+               function(y, x, ...) { SSpline(x, y, ...)$y },
+               x = time)
> head(res2)
                1           2           3           4           5           6
[1,]  0.052349585 -0.02500000  0.21250000 -0.06117869 -0.02153366 -0.02295792
[2,]  0.001126837 -0.04293509  0.17175460 -0.10994988 -0.06538250 -0.06191095
[3,] -0.049851737 -0.06407856  0.12846458 -0.15838412 -0.10899505 -0.10074427
[4,] -0.100341294 -0.09168227  0.08005550 -0.20614476 -0.15213426 -0.13933920
[5,] -0.150096991 -0.12899810  0.02395291 -0.25289514 -0.19456304 -0.17757705
[6,] -0.198873984 -0.17927793 -0.04241763 -0.29829862 -0.23604434 -0.21533911 res2 dat res2 t(res2) matplot() > matplot(x = seq(min(time), max(time), length = 48), 
+         y = res2, type = "l")
-------------------------------------------------------------------------------------------------------
# The data have a common independent variable (x)
x <- 1:10

# Generate 4 different sets of outputs
y1 <- runif(10, 0, 1)
y2 <- runif(10, 100, 150)
y3 <- runif(10, 1000, 2000)
y4 <- runif(10, 40000, 50000)
y <- list(y1, y2, y3, y4)

# Colors for y[[2]], y[[3]], y[[4]] points and axes
colors = c("red", "blue", "green")

# Set the margins of the plot wider
par(oma = c(0, 2, 2, 3))

plot(x, y[[1]], yaxt = "n", xlab = "Common x-axis", main = "A bunch of plots on the same graph", 
     ylab = "")
lines(x, y[[1]])

# We use the "pretty" function go generate nice axes
axis(at = pretty(y[[1]]), side = 2)

# The side for the axes.  The next one will go on 
# the left, the following two on the right side
sides <- list(2, 4, 4) 

# The number of "lines" into the margin the axes will be
lines <- list(2, NA, 2)

for(i in 2:4) {
  par(new = TRUE)
  plot(x, y[[i]], axes = FALSE, col = colors[i - 1], xlab = "", ylab = "")
  axis(at = pretty(y[[i]]), side = sides[[i-1]], line = lines[[i-1]], 
      col = colors[i - 1])
  lines(x, y[[i]], col = colors[i - 1])
}

# Profit.
-------------------------------------------------------------------------------------------------------
#Generate the data for the four graphs
x <- seq(1, 50, 1)
y1 <- 10*rnorm(50)
y2 <- 100*rnorm(50)
y3 <- 1000*rnorm(50)
y4 <- 10000*rnorm(50)

#Set up the plot area so that multiple graphs can be crammed together
par(pty="m", plt=c(0.1, 1, 0, 1), omd=c(0.1,0.9,0.1,0.9))

#Set the area up for 4 plots
par(mfrow = c(4, 1))

#Plot the top graph with nothing in it =========================
plot(x, y1, xlim=range(x), type="n", xaxt="n", yaxt="n", main="", xlab="", ylab="")
mtext("Four Y Plots With the Same X", 3, line=1, cex=1.5)

#Store the x-axis data of the top plot so it can be used on the other graphs
pardat<-par()
xaxisdat<-seq(pardat$xaxp[1],pardat$xaxp[2],(pardat$xaxp[2]-pardat$xaxp[1])/pardat$xaxp[3])

#Get the y-axis data and add the lines and label
yaxisdat<-seq(pardat$yaxp[1],pardat$yaxp[2],(pardat$yaxp[2]-pardat$yaxp[1])/pardat$yaxp[3])
axis(2, at=yaxisdat, las=2, padj=0.5, cex.axis=0.8, hadj=0.5, tcl=-0.3)
abline(v=xaxisdat, col="lightgray")
abline(h=yaxisdat, col="lightgray")
mtext("y1", 2, line=2.3)
lines(x, y1, col="red")

#Plot the 2nd graph with nothing ================================
plot(x, y2, xlim=range(x), type="n", xaxt="n", yaxt="n", main="", xlab="", ylab="")

#Get the y-axis data and add the lines and label
pardat<-par()
yaxisdat<-seq(pardat$yaxp[1],pardat$yaxp[2],(pardat$yaxp[2]-pardat$yaxp[1])/pardat$yaxp[3])
axis(2, at=yaxisdat, las=2, padj=0.5, cex.axis=0.8, hadj=0.5, tcl=-0.3)
abline(v=xaxisdat, col="lightgray")
abline(h=yaxisdat, col="lightgray")
mtext("y2", 2, line=2.3)
lines(x, y2, col="blue")

#Plot the 3rd graph with nothing =================================
plot(x, y3, xlim=range(x), type="n", xaxt="n", yaxt="n", main="", xlab="", ylab="")

#Get the y-axis data and add the lines and label
pardat<-par()
yaxisdat<-seq(pardat$yaxp[1],pardat$yaxp[2],(pardat$yaxp[2]-pardat$yaxp[1])/pardat$yaxp[3])
axis(2, at=yaxisdat, las=2, padj=0.5, cex.axis=0.8, hadj=0.5, tcl=-0.3)
abline(v=xaxisdat, col="lightgray")
abline(h=yaxisdat, col="lightgray")
mtext("y3", 2, line=2.3)
lines(x, y3, col="green")

#Plot the 4th graph with nothing =================================
plot(x, y4, xlim=range(x), type="n", xaxt="n", yaxt="n", main="", xlab="", ylab="")

#Get the y-axis data and add the lines and label
pardat<-par()
yaxisdat<-seq(pardat$yaxp[1],pardat$yaxp[2],(pardat$yaxp[2]-pardat$yaxp[1])/pardat$yaxp[3])
axis(2, at=yaxisdat, las=2, padj=0.5, cex.axis=0.8, hadj=0.5, tcl=-0.3)
abline(v=xaxisdat, col="lightgray")
abline(h=yaxisdat, col="lightgray")
mtext("y4", 2, line=2.3)
lines(x, y4, col="darkgray")

#Plot the X axis =================================================
axis(1, at=xaxisdat, padj=-1.4, cex.axis=0.9, hadj=0.5, tcl=-0.3)
mtext("X Variable", 1, line=1.5)
-------------------------------------------------------------------------------------------------------
rollapply() zoo TimeSeries <- cumsum(rnorm(1000))
ZooSeries <- as.zoo(TimeSeries)

BollLines <- rollapply(ZooSeries,9,function(x){
    M <- mean(x)
    SD <- sd(x)
    c(M,M+SD*2,M-SD*2)
}) rollapply TimeSeries <- cumsum(rnorm(1000))
X <- BollingerBands(TimeSeries,80)
plot(X,TimeSeries,type="l",main="An Example") BollingerBands <- function(x,width){
  Start <- width +1
  Stop <- length(x)
  Trail <- rep(NA,ceiling(width/2))
  Tail <- rep(NA,floor(width/2))

  Lines <- sapply(Start:Stop,function(i){
    M <- mean(x[(i-width):i])
    SD <- sd(x[(i-width):i])
    c(M,M+2*SD,M-2*SD)
  })


  Lines <- apply(Lines,1,function(i)c(Trail,i,Tail))
  Out <- data.frame(Lines)
  names(Out) <- c("Mean","Upper","Lower")

  class(Out) <- c("BollingerBands",class(Out))

  Out
}

plot.BollingerBands <- function(x,data,lcol=c("red","blue","blue"),...){
    plot(data,...)

    for(i in 1:3){
      lines(x[,i],col=lcol[i])
    }
}
-------------------------------------------------------------------------------------------------------
#Build the data
 t <- 1:1000
 x1 <- 100 * sin(0.01 * t)
 x2 <- 200 * cos(0.04 * t)

 #Set up the plot area for two "crammed" plots
 par(pty="m", plt=c(0.1, 1, 0, 1), omd=c(0.1,0.9,0.1,0.9))
 par(mfrow = c(2, 1))

 #Plot x1 and x2 together
 plot(t, x1, type="l", ylim = 1.5 * range(x1, x2), xaxt="n", xlab="", ylab="", main="", col="blue", las=2)
 lines(t, x2, lwd=1, col="red")
 mtext(side=2, "Top Plot", line=5.3, cex=0.8)
 mtext(side=2, "(units)", line=4, cex=0.8)
 grid()
 mtext(side=3, "2 Plots Crammed Together", line=1.5, cex=1.2)
 legend("topright", legend=c("100 * sin(0.01 * t)", "200 * cos(0.4 * t)"), bg="white", lwd=c(1, 1), col=c("blue", "red"), cex=0.9)

 #Place the 1st x-axis
 axis(side = 1, col="blue", col.axis="blue")
 linloc <- par()$usr[3]
 abline(h=linloc, col="blue")
 mtext(side=1, "First X-Axis", line=2.5, cex=0.8, col="blue")

 #Place the fake 2nd x-axis
 xaxis2 <- 1:10
 par(plt=c(0.1,1,0.6,1))
 plot(xaxis2, type="n", xaxt="n", xlab="", yaxt="n", ylab="", xlim=range(xaxis2), bty="n")
 axis(side = 1, col="red", col.axis="red")
 linloc <- par()$usr[3]
 abline(h=linloc, col="red")
 mtext(side=1, "Second X-Axis", line=2.5, cex=0.8, col="red")
-------------------------------------------------------------------------------------------------------
library(pROC)

#Create dummy data set for test observations
obs<-rep(0:1, each=50)
pred1<-c(runif(50,min=0,max=0.8),runif(50,min=0.3,max=0.6))
pred2<-c(runif(50,min=0,max=0.6),runif(50,min=0.4,max=0.9))

roc1<-roc(obs~pred1) # Calculate ROC for each method
roc2<-roc(obs~pred2) 

#Plot roc curves for each method

plot(roc1)
lines(roc2,col="red")

#Compare differences in area under ROC
roc.test(roc1,roc2,method="bootstrap",paired=TRUE)
-------------------------------------------------------------------------------------------------------
lines(mean.yaxis ~ seq(0, 30, length=length(mean.yaxis)))
-------------------------------------------------------------------------------------------------------
data(quakes)

Seq <- c(40, 120, 200, 300, 400, 500, 600, 680)
depth.class <- cut(quakes$depth, Seq, include.lowest = TRUE)
mean.mag <- tapply(quakes$mag, depth.class, mean)

class.mids <- Seq[-1] - diff(Seq)/2

plot(mean.mag~class.mids,xlim=range(Seq))
lines(mean.mag~class.mids)
-------------------------------------------------------------------------------------------------------
?arrow length angle lwd lty plot(c(0:10),type="n")

arrows(1,0,2,1,length=0.2,angle=20)
arrows(1,1,2,2,length=0.1,angle=40,lwd=3)

invisible(mapply(arrows,
        rep(c(3,6),each=4),rep(3:6,2),
        rep(c(5,8),each=4),rep(5:8,2),
        angle=seq(10,40,length.out=8),
        length=rep(seq(0.1,0.3,length.out=4),2),
        lwd=rep(1:4,each=2))
)
-------------------------------------------------------------------------------------------------------
> dput(redata)
structure(c(1093L, 1182L, 1299L, 1372L, 1319L, 1362L, 1239L, 
1162L, 1059L, 921L, 815L, 720L, 835L, 853L, 1034L, 1030L, 1240L, 
1388L, 1429L, 1319L, 1231L, 1184L, 1076L, 825L, 991L, 1093L, 
854L, 808L, 1079L, 1092L, 1220L, 1251L, 1130L, 1131L, 1052L, 
951L, 950L, 1006L, 1112L, 1119L, 1250L, 1322L, 1347L, 1310L, 
1215L, 1128L, 1035L, 992L, 1079L, 1018L, 1112L, 1224L, 1323L, 
1344L, 1326L, 1267L, 1171L, 1075L, 916L, 932L, 888L, 904L, 939L, 
1018L, 1140L, 1174L, 1285L, 1311L, 1298L, 1231L, 1091L, 1088L, 
991L, 1028L, 1177L, 1322L, 1322L, 1398L, 1389L, 1174L, 1196L, 
1115L, 756L, 496L, 693L, 673L, 748L, 777L, 820L, 948L, 966L, 
1027L, 960L, 865L, 767L, 675L, 765L, 732L, 613L, 632L, 659L, 
705L, 684L, 734L, 715L, 626L, 551L, 487L, 500L, 536L, 575L, 595L, 
736L, 798L, 832L, 797L, 792L, 726L, 650L, 584L, 567L, 524L, 574L, 
571L, 591L, 657L, 699L, 756L, 867L, 795L, 760L, 685L, 609L, 588L, 
521L, 581L, 614L, 623L, 668L, 702L, 777L, 697L, 647L, 562L, 523L, 
508L, 493L, 504L, 534L, 586L, 621L, 620L, 636L, 600L, 549L, 557L
), .Dim = 12:13, .Dimnames = list(c("Jan", "Feb", "Mar", "Apr", 
"May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"), c("X1993", 
"X1994", "X1995", "X1996", "X1997", "X1998", "X1999", "X2000", 
"X2001", "X2002", "X2003", "X2004", "X2005"))) monthnames <- c(
"Jan",
"Feb",
"Mar",
"Apr",
"May",
"Jun",
"Jul",
"Aug",
"Sep",
"Oct",
"Nov",
"Dec"
)


# size of window
windows(w=6,h=3)

# margins
par(
mar=c(5.1,5.1,2.1,2.1),
cex.axis=0.7
)

# set up plot with the number of categories and the y limits 
# yaxs="i" sets the yaxis as having no separation from the corner point

ylimlp <-  c(0,max(redata))*1.06
plot(1:156, type="n", xaxt="n", ylim=ylimlp, ann=FALSE, yaxs="i", xaxs="i", bty="l", las="1")

abline(v=seq(13,156,13),lty=1,col="grey")

title(xlab="Month", col.lab=rgb(0,0,0), font.lab=2, cex.lab=0.75)
title(ylab="Listings", col.lab=rgb(0,0,0), font.lab=2, cex.lab=0.75)

lines(redata[1,],type="l",pch=NA,lwd=1,col="grey")
lines(c(rep(NA,13*1),redata[2,]),type="l",pch=NA,lwd=1,col="grey")
lines(c(rep(NA,13*2),redata[3,]),type="l",pch=NA,lwd=1,col="grey")
lines(c(rep(NA,13*3),redata[4,]),type="l",pch=NA,lwd=1,col="grey")
lines(c(rep(NA,13*4),redata[5,]),type="l",pch=NA,lwd=1,col="grey")
lines(c(rep(NA,13*5),redata[6,]),type="l",pch=NA,lwd=1,col="grey")
lines(c(rep(NA,13*6),redata[7,]),type="l",pch=NA,lwd=1,col="grey")
lines(c(rep(NA,13*7),redata[8,]),type="l",pch=NA,lwd=1,col="grey")
lines(c(rep(NA,13*8),redata[9,]),type="l",pch=NA,lwd=1,col="grey")
lines(c(rep(NA,13*9),redata[10,]),type="l",pch=NA,lwd=1,col="grey")
lines(c(rep(NA,13*10),redata[11,]),type="l",pch=NA,lwd=1,col="grey")
lines(c(rep(NA,13*11),redata[12,]),type="l",pch=NA,lwd=1,col="grey")

redatamonthmean <- apply(redata,1,mean)

lines(rep(redatamonthmean[1],13),type="l",pch=NA,lwd=1,col="black")
lines(c(rep(NA,13*1),rep(redatamonthmean[2],13)),type="l",pch=NA,lwd=1,col="black")
lines(c(rep(NA,13*2),rep(redatamonthmean[3],13)),type="l",pch=NA,lwd=1,col="black")
lines(c(rep(NA,13*3),rep(redatamonthmean[4],13)),type="l",pch=NA,lwd=1,col="black")
lines(c(rep(NA,13*4),rep(redatamonthmean[5],13)),type="l",pch=NA,lwd=1,col="black")
lines(c(rep(NA,13*5),rep(redatamonthmean[6],13)),type="l",pch=NA,lwd=1,col="black")
lines(c(rep(NA,13*6),rep(redatamonthmean[7],13)),type="l",pch=NA,lwd=1,col="black")
lines(c(rep(NA,13*7),rep(redatamonthmean[8],13)),type="l",pch=NA,lwd=1,col="black")
lines(c(rep(NA,13*8),rep(redatamonthmean[9],13)),type="l",pch=NA,lwd=1,col="black")
lines(c(rep(NA,13*9),rep(redatamonthmean[10],13)),type="l",pch=NA,lwd=1,col="black")
lines(c(rep(NA,13*10),rep(redatamonthmean[11],13)),type="l",pch=NA,lwd=1,col="black")
lines(c(rep(NA,13*11),rep(redatamonthmean[12],13)),type="l",pch=NA,lwd=1,col="black")

mtext(monthnames[1], side=1, cex=0.7, at=6.5)
mtext(monthnames[2], side=1, cex=0.7, at=6.5*3)
mtext(monthnames[3], side=1, cex=0.7, at=6.5*5)
mtext(monthnames[4], side=1, cex=0.7, at=6.5*7)
mtext(monthnames[5], side=1, cex=0.7, at=6.5*9)
mtext(monthnames[6], side=1, cex=0.7, at=6.5*11)
mtext(monthnames[7], side=1, cex=0.7, at=6.5*13)
mtext(monthnames[8], side=1, cex=0.7, at=6.5*15)
mtext(monthnames[9], side=1, cex=0.7, at=6.5*17)
mtext(monthnames[10], side=1, cex=0.7, at=6.5*19)
mtext(monthnames[11], side=1, cex=0.7, at=6.5*21)
mtext(monthnames[12], side=1, cex=0.7, at=6.5*23)
-------------------------------------------------------------------------------------------------------
time plot(mysurvfit, mark.time=FALSE, conf.int=TRUE)
lines(mysurvfit$surv ~ mysurvfit$time, col="blue",lty=1)
lines(mysurvfit$upper ~ mysurvfit$time, col="blue",lty=2)
lines(mysurvfit$lower ~ mysurvfit$time, col="blue",lty=2)
-------------------------------------------------------------------------------------------------------
install.packages("gWidgetsWWW2", repos="http://R-Forge.R-project.org") load_app("tic-tac-toe.r") w <- gwindow("Tic-Tac-Toe")
sb <- gstatusbar("Powered by gWidgetsWWW2 and Rook", cont=w)
ghtml("Tic-Tac-Toe, three in a row", cont=w)


## sizing
margin <- 10
sz <- 130
width <- height <- 3*sz + 2 * margin

state <- matrix(character(9), nrow=3)
x_move <- TRUE
sym <- c("o", "x")

f <- tempfile()
cnv <- gcanvas(f, width=width, height=height, cont=w)



make_board <- function() {
  ## make board
  for(i in seq(margin + sz, margin + 2*sz, by=sz)) {
    cnv$lines(c(margin, width-margin), c(i, i))
    cnv$lines(c(i, i), c(margin, width-margin))
  }
}

draw_x <- function(i, j) {
  delta <- sz/10
  cnv$lines(margin + sz *c(i-1, i) + delta*c(1,-1),
            margin + sz *c(j-1, j) + delta*c(1,-1))
  cnv$lines(margin + sz *c(i-1, i) + delta*c(1,-1),
            margin + sz *c(j, j-1) + delta*c(-1,1))

}

draw_o <- function(i, j) {
  cnv$circle(margin + (i-1/2)*sz, margin + (j-1/2)*sz, r = (3/8)*sz)
}

notify_winner <- function(mark) {
  if(mark == "x") {
    svalue(sb) <- "Congrats, x won"
  } else {
    svalue(sb) <- "Congrats, o won"
  }

}

check_winner <- function() {
  ## x
  is_winner <- function(mark) {
    any(colSums(state == mark) == 3)  ||
    any(rowSums(state == mark) == 3) ||
    sum((state == mark)[c(1,5,9)]) == 3 ||
    sum((state == mark)[c(3,5,7)]) == 3
  }
  if(is_winner("x")) {
    notify_winner("x")
    removeHandler(cnv, cbid)
    return(TRUE)
  } else if(is_winner("o")) {
    notify_winner("o")
    removeHandler(cnv, cbid)    
    return(TRUE)
  }
  return(FALSE)
}



cbid <- addHandlerClicked(cnv, handler=function(h,...) {
  i <- 1 + (h$X - margin) %/% sz
  j <- 1 + (h$Y - margin) %/% sz

  if(i %in% 1:3 && j %in% 1:3) {
    if(state[i,j] == "") {
      state[i,j] <<- sym[1 + x_move]
      if(x_move) {
        draw_x(i,j)
      } else {
        draw_o(i,j)
      }
      x_move <<- !x_move
      if(!check_winner())
        svalue(sb) <- "Click to move"
    } else {
      svalue(sb) <- "Already selected that cell"
    }
  }

})


## Start
make_board()
svalue(sb) <- "Click to  move"
-------------------------------------------------------------------------------------------------------
my.cars <- data.frame(Toyota = runif(50), Mazda = runif(50), Renault = runif(50)) #make some fake data for this example
plot(x = 1:nrow(my.cars), y = my.cars$Toyota, type = "n") #make an empty plot
with(my.cars, lines(x = 1:nrow(my.cars), y = Toyota, col = "red")) #add lines for Toyota
with(my.cars, lines(x = 1:nrow(my.cars), y = Mazda, col = "red")) # add lines for Mazda
with(my.cars, lines(x = 1:nrow(my.cars), y = Renault, col = "navy blue")) # add lines for Renault with() my.cars$Toyota my.cars$Mazda ?par plot
-------------------------------------------------------------------------------------------------------
library(plyr)
ps <- ldply(1:36, function(i)data.frame(s=0:i, n=i))
plot.new()
plot.window(c(1,36), c(0,1))
apply(ps, 1, function(x){
  s<-x[1]; n<-x[2];
  lines(c(n, n+1, n, n+1), c(s/n, s/(n+1), s/n, (s+1)/(n+1)), type="o")})
axis(1)
axis(2)
-------------------------------------------------------------------------------------------------------
x <- 1:36
boring <- function(x, n=1)n/(x+n-1)

plot(x, boring(x), type="l", usr=c(0, 36, 0, 1))
for(i in 1:36){
  lines(tail(x, 36-i+1), head(boring(x, i), 36-i+1), type="o", cex=0.5)
  lines(tail(x, 36-i+1), 1-head(boring(x, i), 36-i+1, type="o", cex=0.5))
}
-------------------------------------------------------------------------------------------------------
?ts.plot
my.ts.panel <- function(x, col = col, bg = bg, pch = pch, type = type,  vpos=8.75, ...){
      lines(x, col = col, bg = bg, pch = pch, type = type, ...)
      abline(v=vpos)}
plot.ts(cbind(a, b, c, d, e, f, g, h),main="Time Series", panel=my.ts.panel) vpos=8.75
my.ts.panel <- function(x, col = col, bg = bg, pch = pch, type = type,   ...){
      lines(x, col = col, bg = bg, pch = pch, type = type, ...)
      abline(v=vpos)}
plot.ts(cbind(a, b, c, d, e, f, g, h),main="Time Series", panel=my.ts.panel)
-------------------------------------------------------------------------------------------------------
library(sfsmisc)

#Generate the data
x <- 1:100000
y <- 1:100000

#Setup the plot area
par(pty="m", plt=c(0.1, 1, 0.1, 1), omd=c(0.1,0.9,0.1,0.9))

#Plot a blank graph without completing the x or y axis
plot(x, y, type = "n", xaxt = "n", yaxt="n", xlab="", ylab="", log = "x", col="blue")
mtext(side=3, text="Test Plot", line=1.2, cex=1.5)

#Complete the x axis
eaxis(1, padj=-0.5, cex.axis=0.8)
mtext(side=1, text="x", line=2.5)

#Complete the y axis and add the grid
aty <- seq(par("yaxp")[1], par("yaxp")[2], (par("yaxp")[2] - par("yaxp")[1])/par("yaxp")[3])
axis(2, at=aty, labels=format(aty, scientific=FALSE), hadj=0.9, cex.axis=0.8, las=2)
mtext(side=2, text="y", line=4.5)
grid()

#Add the line last so it will be on top of the grid
lines(x, y, col="blue")
-------------------------------------------------------------------------------------------------------
#---------- method --------------
 xyplot(-1:1 ~ -1:1, type="l")
trellis.focus("panel", 1, 1)
do.call("panel.abline", list(h=0,v=0, lty=3) )
trellis.unfocus()
# --- that method has the advantage of also demonstrating 
#        how to modify an existing plot

#---------- method 2--------------

 xp <-xyplot(-2:1 ~ -2:1, type="l", panel=function(...){
 panel.xyplot(...)
 panel.abline(h=0,v=0, lty=3)} )
xp
-------------------------------------------------------------------------------------------------------
x <- seq(1, pi, pi/36)
y <- sin(x) plot(x, y) type="b" lines(x[10:20], y[10:20], type="b")
-------------------------------------------------------------------------------------------------------
t1 <- "Time Value
1.023   5.786
2.564   10.675
3.678   14.678
5.023   17.456"

t2 <- "Time Value
0.787   1.765
1.567   3.456
3.011   5.879
4.598   7.768"

t3 <- "Time Value
1.208   3.780
2.478   6.890
3.823   9.091
5.125   12.769"

tex1 <- read.table(textConnection(t1), header = TRUE)
tex2 <- read.table(textConnection(t2), header = TRUE)
tex3 <- read.table(textConnection(t3), header = TRUE)

plot(tex1, type="l", xlim=range(tex1$Time, tex2$Time, tex3$Time), ylim=range(tex1$Value, tex2$Value, tex3$Value), main="Common Time Axis for 3 Data Series", col="black")
grid()
lines(tex2, col="red")
lines(tex3, col="blue")
-------------------------------------------------------------------------------------------------------
for #Set the number of bets and number of trials and % lines
numbet <- 6000 #6000 bets
numtri <- 1000 #Run 1000 trials of the 6000 bets
perlin <- 0.05 #Show the +/- 5% lines on the graph
rantri <- 60 #The 60th trial (just a random trial to be drawn)

#Fill a matrix where the rows are the cumulative bets and the columns are the trials
xcum <- matrix(NA, nrow=numbet, ncol=numtri)
for (i in 1:numtri) {
  x <- sample(c(-1,1), numbet, replace = TRUE)
  xcum[,i] <- cumsum(x)
}

#Plot the trials as transparent lines so you can see the build up
matplot(xcum, type="l", xlab="Number of Bets", ylab="Cumulative Sum", main="Cumulative Results", col=rgb(0.01, 0.01, 0.01, 0.02))
grid()

#Sort the trials of each bet so you can pick out the desired %
xcumsor <- xcum
for (i in 1:numbet) {
  xcumsor[i,] <- xcum[i,order(xcum[i,])]
}

#Draw the upper/lower limit lines and the 50% probability line     
lines(xcumsor[, perlin*numtri], type="l", lwd=2, col=rgb(1, 0.0, 0.0)) #Lower limit
lines(xcumsor[, 0.5*numtri], type="l", lwd=3, col=rgb(0, 1, 0.0)) #50% Line
lines(xcumsor[, (1-perlin)*numtri], type="l", lwd=2, col=rgb(1, 0.0, 0.0)) #Upper limit

#Show one of the trials
lines(xcum[, rantri], type="l", lwd=1, col=rgb(1, 0.8, 0)) #Random trial

#Draw the legend
legend("bottomleft", legend=c("Various Trials", "Single Trial", "50% Probability", "Upper/Lower % Limts"), bg="white", lwd=c(1, 1, 3, 2), col=c("darkgray", "orange", "green", "red")) #Set the bet sequence and the % lines
betseq <- 1:100000 #1 to 100,000 bets
perlin <- 0.05 #Show the +/- 5% lines on the graph

#Calculate the Upper and Lower limits using perlin
#qnorm() gives the multiplier for the square root
upplim <- qnorm(1-perlin)*sqrt(betseq)
lowlim <- qnorm(perlin)*sqrt(betseq)

#Get the range for y
yran <- range(upplim, lowlim)

#Plot the upper and lower limit lines
plot(betseq, upplim, ylim=yran, type="l", xlab="", ylab="")
lines(betseq, lowlim) dralim lines dralim #Set the bet sequence and the % lines
betseq <- 0:700 #0 to 700 bets
perlin <- 0.05 #Show the +/- 5% lines on the graph

#Define a function that plots the upper and lower % limit lines
dralim <- function(stax, endx, perlin) {
  lines(stax:endx, qnorm(1-perlin)*sqrt((stax:endx)-stax))
  lines(stax:endx, qnorm(perlin)*sqrt((stax:endx)-stax))
}

#Build the plot area and draw the vertical dashed lines
plot(betseq, rep(0, length(betseq)), type="l", ylim=c(-50, 50), main="", xlab="Trial Number", ylab="Cumulative Hits")
abline(h=0)
abline(v=35, lty="dashed") #Seg 1
abline(v=185, lty="dashed") #Seg 2
abline(v=385, lty="dashed") #Seg 3
abline(v=485, lty="dashed") #Seg 4
abline(v=585, lty="dashed") #Seg 5

#Draw the % limit lines that correspond to the vertical dashed lines by calling the
#new function dralim.
dralim(0, 35, perlin) #Seg 1
dralim(36, 185, perlin) #Seg 2
dralim(186, 385, perlin) #Seg 3
dralim(386, 485, perlin) #Seg 4
dralim(486, 585, perlin) #Seg 5
dralim(586, 701, perlin) #Seg 6
-------------------------------------------------------------------------------------------------------
dput(Corl) library(zoo)

Corl <- structure(list(Date = structure(c(15155, 15064, 14974, 14882,
  14790, 14699), class = "Date"), Survey = c(60L, 55L, 48L, 48L,
    56L, 57L), Actual = c(NA, 50L, 44L, 36L, 75L, 41L)), .Names = c("Date",
      "Survey", "Actual"), row.names = c(NA, -6L), class = "data.frame")

Corl.zoo <- read.zoo(Corl, FUN=as.yearqtr)
Corl.zoo

        Survey Actual
2010 Q1     57     41
2010 Q2     56     75
2010 Q3     48     36
2010 Q4     48     44
2011 Q1     55     50
2011 Q2     60     NA

plot(Corl.zoo) my.panel <- function(...) {
   lines(...)
   #This line adds the vertical grid lines
   abline(v=time(Corl.zoo), col="lightgray", lty=3)
   panel.number <- parent.frame()$panel.number
   # if bottom panel
   if (!length(panel.number) || panel.number == NCOL(Corl.zoo)) {
      # next line only if non-labelled ticks wanted for each point
      axis(1, at = time(Corl.zoo), lab = FALSE)
      labcou <- 1 #Put a label, counting between labels
      ix <- seq(1, length(Corl.zoo), labcou)
      labs <- format(time(Corl.zoo), "%Y\nQ%q\n ")
      axis(1, at = time(Corl.zoo)[ix], lab = labs[ix], tcl = -0.5, padj=0.6, cex.axis = 1)
   }
}

plot(Corl.zoo, panel = my.panel, xaxt = "n", main="My Title", xlab="")
-------------------------------------------------------------------------------------------------------
#Split the data into two groups
data1 <- data[1:7, ]
data2 <- data[8:15, ]

#Perform the regression
model1 <- lm(log(y) ~ log(x), data1)
model2 <- lm(log(y) ~ log(x), data2)
summary(model1)
summary(model2)

#Plot it
with(data, plot(x, y, log="xy"))
lines(1:7, exp(predict(model1, data.frame(x = 1:7))))
lines(8:15, exp(predict(model2, data.frame(x = 8:15)))) data$group <- factor(rep(letters[1:2], times = 7:8)) model_all <- lm(log(y) ~ log(x) * group, data)
summary(model_all)
-------------------------------------------------------------------------------------------------------
lm() subset lin <- data.frame(x = c(0:6), y = c(0.3, 0.1, 0.9, 3.1, 5, 4.9, 6.2))
linm <- lm(y ~ x, data = lin, subset = 2:4) R> linm

Call:
lm(formula = y ~ x, data = lin, subset = 2:4)

Coefficients:
(Intercept)            x  
     -1.633        1.500  

R> fitted(linm)
         2          3          4 
-0.1333333  1.3666667  2.8666667 log() logm1 <- lm(log(y) ~ log(x), data = dat, subset = 1:7)
logm2 <- lm(log(y) ~ log(x), data = dat, subset = 8:15) dat <- transform(dat, ind = factor(1:15 <= 7))
logm3 <- lm(log(y) ~ log(x) * ind, data = dat) R> coef(logm1)
  (Intercept)        log(x) 
-0.0001487042 -0.4305802355 
R> coef(logm2)
(Intercept)      log(x) 
  0.1428293  -1.4966954 R> coef(logm3)
   (Intercept)         log(x)        indTRUE log(x):indTRUE 
     0.1428293     -1.4966954     -0.1429780      1.0661152 ind logm3 logm2 logm2 logm3 log(x) logm1 R> coefs[1] + coefs[3]
  (Intercept) 
-0.0001487042 indTRUE R> coefs[2] + coefs[4]
    log(x) 
-0.4305802 logm1 coefs[2] coefs[4] abline() plot(y ~ x, data = lin)
abline(linm) pdat <- with(dat, data.frame(x = seq(from = head(x, 1), to = tail(x,1), 
                                     by = 0.1))
pdat <- transform(pdat, yhat = c(predict(logm1, pdat[1:70,, drop = FALSE]), 
                                 predict(logm2, pdat[71:141,, drop = FALSE]))) yhat plot(y ~ x, data = dat)

-------------------------------------------------------------------------------------------------------
abline() # The dataset:
daten <- data.frame(x = c(0:6), y = c(0.3, 0.1, 0.9, 3.1, 5, 4.9, 6.2))
# make a linear fit for the datapoints 3, 4, 5
mod <- lm(y~x, data = daten, subset = 3:5) x xr <- with(daten, range(x[3:5])) pred <- data.frame(x = seq(from = xr[1], to = xr[2], length = 50))
pred <- transform(pred, yhat = predict(mod, newdata = pred)) abline() plot(y ~ x, data = daten)
abline(mod) lines(yhat ~ x, data = pred, col = "red", lwd = 2) abline() ## range of all `x` data
xr2 <- with(daten, range(x))
## same as before
pred <- data.frame(x = seq(from = xr2[1], to = xr2[2], length = 100))
pred <- transform(pred, yhat = predict(mod, newdata = pred))

## plot the data and the fitted model line
plot(y ~ x, data = daten)
lines(yhat ~ x, data = pred)

## add emphasis to the interval used in fitting
with(pred, lines(yhat ~ x, data = pred, subset = x >= xr[1] & x <= xr[2],lwd = 2, col = "red")) subset subset TRUE FALSE lines() R> head(with(pred, x >= xr[1] & x <= xr[2]))
[1] FALSE FALSE FALSE FALSE FALSE FALSE
-------------------------------------------------------------------------------------------------------
plyr a_ply a_ply(t_weekmean, 3, function(arrayforcurweek){
allweek1<-(data.frame(arrayforcurweek)) #which selects the date and generates the data frame I want to later format the date using
week1<-stack(allweek1) #and then plot it using
plot(week1$values,type="n", xlim=c(0,2),xlab="Weight (gr)",ylab="Rate (umol/L*gr)",main="All individuals and Treatments at all times")
lines(week1$values[week1$ind=="X9"]~x,type="o",col="red")
lines(week1$values[week1$ind=="X12"]~x,type="o",col="blue")
lines(week1$values[week1$ind=="X15"]~x,type="o",col="green")
lines(week1$values[week1$ind=="X18"]~x,type="o",col="purple")
}) a_ply i t_weekmean[,,i]
-------------------------------------------------------------------------------------------------------
peaks peaks<-function(series,span=3){
  z <- embed(series, span)
  s <- span%/%2
  v<- max.col(z) == 1 + s
  result <- c(rep(FALSE,s),v)
  result <- result[1:(length(result)-s)]
  result
} 

x <- c(1:20)
y <- c(19.4, 17.9, 8.1, 11.3, 7.8, 8.0, 5.0, 1.7, 3.9, 
       5.4, 7.5, 5.4, 4.7, 5.0, 4.9, 3.5, 2.9, 2.4, 1.4, 1.7)

plot(x,y, type="l")
p <- which(peaks(y, span=3))

lines(x[p], y[p], col="red", type="b) span
-------------------------------------------------------------------------------------------------------
Ecdf() help(ecdf) lines() R> Ecdf(c(rnorm(20), rnorm(20)), group=g, col=c('blue', 'orange')) col= plot.stepfun()
-------------------------------------------------------------------------------------------------------
FindLowRegion <- function(x,n=length(x)/4,tol=length(x)/20,p=0.5){
    nx <- length(x)
    n <-  2*(n %/% 2) + 1
    # smooth out based on means
    sx <- rowMeans(embed(c(rep(NA,n/2),x,rep(NA,n/2)),n),na.rm=T)
    # find which series are far from the mean
    rlesx <- rle((sx-x)>0)
    # construct start and end of regions
    int <- embed(cumsum(c(1,rlesx$lengths)),2)
    # which regions fulfill requirements
    id <- rlesx$value & rlesx$length > tol
    # Cut regions to be in general smaller than median
    regions <-
    apply(int[id,],1,function(i){
        i <- min(i):max(i)
        tmp <- x[i]
        id <- which(tmp < quantile(tmp,p))
        id <- min(id):max(id)
        i[id]            
    })
    # return
    unlist(regions)
} n tol p Lows <- FindLowRegion(y)

newx <- seq_along(y)
newy <- ifelse(newx %in% Lows,y,NA)
plot(y, col="blue", type="l", lwd=2)
lines(newx,newy,col="red",lwd="3")
-------------------------------------------------------------------------------------------------------
plot(dfr[,1], dfr[,2], type="l")
lines(dfr[,1], dfr[,3], col="red")
-------------------------------------------------------------------------------------------------------
grid.lines(c(0.5, 0.5))
grid.text("orzorzorz", y=0.4, hjust=unit(0.25, "npc"))
grid.text("orzorzorz", y=0.5, hjust=unit(0.25, "mm"))
grid.text("orzorzorz", y=0.6, hjust=unit(0.25, "cm"))
grid.text("orzorzorz", y=0.7, hjust=0.25) u1+u2 > c(u1+u2)
$fname
[1] "+"

$arg1
[1] 0.5npc

$arg2
[1] 0.25npc hjust = c(u1)+c(u2)
-------------------------------------------------------------------------------------------------------
lines() x <- 1:40
y <- exp(-x)

plot(density(x), type = "p")
lines(density(y)) type lines ?plot ?par ?lines
-------------------------------------------------------------------------------------------------------
x <- rnorm(100)
mx <- mean(x)
hist(x)
abline(v = mx, col = "blue", lwd = 2) x <- rnorm(100, mean = 10)
mx <- mean(x)
hist(x)
lines( c(mx,mx), c(0,15), col = "red", lwd = 2)
lines(c(10, 11.5), c(0, 10), col = "steelblue", lwd = 3, lty = 22)
text(mx, 18 , round(mx, 2))
text(mx, 12 , "big", cex = 5)
-------------------------------------------------------------------------------------------------------
plot lines x <- 1:10
y1 <- 1:10
y2 <- 0.5 * y1

#Set up the plot
plot(range(x),range(c(y1,y2)),type="n")
#Create the lines
lines(x,y1)
lines(x,y2)
-------------------------------------------------------------------------------------------------------
with(bruth, plot(p, predict(mod), type="l" )  )
 with(bruth, points(p, g,  col="red") )
 with(bruth, lines(p, predict(mod2), lty=3, lwd=2, col="red") )
 title(main="Different uses of I() and interaction")
-------------------------------------------------------------------------------------------------------
x <- (-1):1
y <- 1 - abs(x)
plot(x, y, type="l")
lines(x, -y)
-------------------------------------------------------------------------------------------------------
s0 <- list(b=0.1,c=0.1,d=0,Th=3)
X <- read.table("rogersdat.txt",header=TRUE) predfun <- function(b,c,d,Th,Te,N0,debug=FALSE) {
  a <- (d+b*N0)/(1+c*N0)
  r <- N0 - (1/(a*Th))*lambertW(a*Th*N0*exp(a*(Th*N0-Te)))
  if (debug) cat(mean(a),b,c,d,Th,mean(r),"\n")
  r
} with(X,plot(Ne~N0))
## check starting value
lines(1:100,with(c(s0,X),predfun(b,c,d,Th,Te=72,N0=1:100))) library(emdbook)
n1 <- nls(Ne~predfun(b,c,d,Th,Te=72,N0),data=X,
    lower=c(1e-6,1e-6,-Inf,1e-6),algorithm="port",
    start=list(b=0.1,c=0.1,d=0.002,Th=3))
summary(n1)

Formula: Ne ~ predfun(b, c, d, Th, Te = 72, N0)

Parameters:
    Estimate Std. Error t value Pr(>|t|)   
b  0.0004155  0.0008745   0.475  0.63591   
c  0.0000010  0.0657237   0.000  0.99999   
d  0.0008318  0.0067374   0.123  0.90203   
Th 4.0639937  1.4665102   2.771  0.00686 **
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 

Residual standard error: 4.516 on 85 degrees of freedom

Algorithm "port", convergence message: relative convergence (4) 

confint.default(n1)

          2.5 %      97.5 %
b  -0.001298523 0.002129547
c  -0.128815083 0.128817083
d  -0.012373153 0.014036799
Th  1.189686504 6.938300956 pdat <- data.frame(N0=1:100,Ne=predict(n1,newdata=data.frame(N0=1:100)))
with(pdat,lines(N0,Ne,col=2))
library(ggplot2)
ggplot(X,aes(x=N0,y=Ne))+stat_sum(aes(size=factor(..n..)),alpha=0.5)+theme_bw()+
  geom_line(data=pdat,colour="red")
-------------------------------------------------------------------------------------------------------
Arima forecast fit <- Arima(WWWusage,order=c(3,1,0)) plot(fit$x,col="red")
lines(fitted(fit),col="blue")
-------------------------------------------------------------------------------------------------------
t   lq   med   uq
1   ..    ..   ..
2   ..    ..   ..
3   ..    ..   ..
4   ..    ..   .. res.df <- data.frame(t(apply(my.data.frame[,2:ncol(my.data.frame)], 1, quantile,probs=c(.25,.5,.75))))
res.df$t <- my.data.frame[,1]

res.df
         X25.        X50.        X75.   t
1 0.028624900 0.031074701 0.037136365 200
2 0.016687651 0.021395864 0.025269186 300
3 0.010939904 0.014344707 0.016897053 400
4 0.007891868 0.009855513 0.011671379 500
5 0.006553960 0.008057315 0.009885929 600
6 0.005831083 0.006755695 0.008090646 700 # Sample data
t=seq(33)
lq=runif(33)
med = lq+runif(33)*2
res.df <- data.frame( t=t, lq=lq, med = med, uq=med+runif(33)*2 )
colnames(res.df) <- c("t","lq","med","uq")

# Base graphics
plot(lq~t,data=res.df,type="l",col="springgreen",ylim=range(c(lq,uq)))
lines(med~t,data=res.df,col="steelblue")
lines(uq~t,data=res.df,col="springgreen") # ggplot2
res.df <- melt(res.df,id.vars="t")
library(ggplot2)
p <- ggplot(res.df, aes(y=value,x=t,colour=variable) )
p + geom_line()
-------------------------------------------------------------------------------------------------------
file help (file) import file f = open ("C:\BigScaryFinancialData.txt", "r");
for line in f.readlines():
    #line is a string type
    #do whatever you want to do on a per-line basis here, for example:
    print len(line) re help(re)
-------------------------------------------------------------------------------------------------------
arrowLine <- function(x0,y0,x1,y1,nArrow=1,...)
{
  lines(c(x0,x1),c(y0,y1),...)
  Ax=seq(x0,x1,length=nArrow+1)
    Ay=seq(y0,y1,length=nArrow+1)
  for (i in 1:nArrow)
  {
    arrows(Ax[i],Ay[i],Ax[i+1],Ay[i+1],...)
  }
} plot(0:1,0:1)
arrowLine(0,0,1,1,4)
-------------------------------------------------------------------------------------------------------
density() energy <- rnorm(100)
dens <- density(energy)
sum(dens$y)*diff(dens$x[1:2])
[1] 1.000952 density() probability=TRUE hist density() hist(energy,probability=TRUE)
lines(density(energy),col="red") x <- sample(letters[1:4],1000,replace=TRUE)
 prop.table(table(x))
x
    a     b     c     d 
0.244 0.262 0.275 0.219 count(x)/sum(count(x)) dnorm() x <- sort(rnorm(100,0,0.5))
h <- hist(x,plot=FALSE)
dens1 <-  h$counts/sum(h$counts)
dens2 <- dnorm(x,0,0.5)

hist(x,probability=TRUE,breaks="fd",ylim=c(0,1))
lines(h$mids,dens1,col="red")
lines(x,dens2,col="darkgreen") cdf <- cumsum(dens$y * diff(dens$x[1:2]))
cdf <- cdf / max(cdf) # to correct for the rounding errors
plot(dens$x,cdf,type="l")
-------------------------------------------------------------------------------------------------------
curly <- function(N = 100, Tilt = 1, Long = 2, scale = 0.1, xcent = 0.5,
                  ycent = 0.5, theta = 0, col = 1, lwd = 1, grid = FALSE){

# N determines how many points in each curve
# Tilt is the ratio between the axis in the ellipse 
#  defining the curliness of each curve
# Long is the length of the straight line in the curly brackets 
#  in units of the projection of the curly brackets in this dimension
# 2*scale is the absolute size of the projection of the curly brackets 
#  in the y dimension (when theta=0)
# xcent is the location center of the x axis of the curly brackets
# ycent is the location center of the y axis of the curly brackets
# theta is the angle (in radians) of the curly brackets orientation
# col and lwd are passed to points/grid.lines

           ymin <- scale / Tilt
           y2 <- ymin * Long
           i <- seq(0, pi/2, length.out = N)

           x <- c(ymin * Tilt * (sin(i)-1),
                  seq(0,0, length.out = 2),
                  ymin * (Tilt * (1 - sin(rev(i)))),
                  ymin * (Tilt * (1 - sin(i))),
                  seq(0,0, length.out = 2),
                  ymin * Tilt * (sin(rev(i)) - 1))

           y <- c(-cos(i) * ymin,
                  c(0,y2),
                  y2 + (cos(rev(i))) * ymin,
                  y2 + (2 - cos(i)) * ymin,
                  c(y2 + 2 * ymin, 2 * y2 + 2 * ymin),
                  2 * y2 + 2 * ymin + cos(rev(i)) * ymin)

           x <- x + xcent
           y <- y + ycent - ymin - y2

           x1 <- cos(theta) * (x - xcent) - sin(theta) * (y - ycent) + xcent
           y1 <- cos(theta) * (y - ycent) + sin(theta) * (x - xcent) + ycent

           ##For grid library:
           if(grid){
              grid.lines(unit(x1,"npc"), unit(y1,"npc"),gp=gpar(col=col,lwd=lwd))
           }

           ##Uncomment for base graphics
           else{
              par(xpd=TRUE)
              points(x1,y1,type='l',col=col,lwd=lwd)
              par(xpd=FALSE)
           }

}


library(ggplot2)
x <- c(runif(10),runif(10)+2)
y <- c(runif(10),runif(10)+2)
qplot(x=x,y=y) +
  scale_x_continuous("",breaks=c(.5,2.5),labels=c("Low types","High types") )

curly(N=100,Tilt=0.4,Long=0.3,scale=0.025,xcent=0.2525,
      ycent=par()$usr[3]+0.1,theta=-pi/2,col="red",lwd=2,grid=TRUE)
curly(N=100,Tilt=0.4,Long=0.3,scale=0.025,xcent=0.8,
      ycent=par()$usr[3]+0.1,theta=-pi/2,col="red",lwd=2,grid=TRUE)
-------------------------------------------------------------------------------------------------------
npregression npplot() mfrow data(Italy)
bw <- npregbw(formula=gdp~ordered(year), data = Italy)
model <- npreg(bws = bw, gradients = TRUE)
par(mfrow = c(2, 2))
plot(model)
points(ordered(Italy$year), Italy$gdp, cex=.2, col="red")
plot(1:10)
plot(1:5)
plot(1) data(cps71)
model.par <- lm(logwage ~ age + I(age^2), data = cps71)
model.np <- npreg(logwage ~ age,
                  regtype = "ll",
                  bwmethod = "cv.aic",
                  gradients = TRUE,
                  data = cps71)
par(mfrow=c(2,2))

plot(cps71$age,cps71$logwage,xlab="age",ylab="log(wage)",cex=.1)
lines(cps71$age,fitted(model.np),lty=1,col="blue")
lines(cps71$age,fitted(model.par),lty=2,col="red")

plot(cps71$age,gradients(model.np),xlab="age",ylab="gradient",type="l",lty=1,col="blue")
lines(cps71$age,coef(model.par)[2]+2*cps71$age*coef(model.par)[3],lty=2,col="red")

plot(cps71$age,fitted(model.np),xlab="age",ylab="log(wage)",ylim=c(min(fitted(model.np)-2*model.np$merr),max(fitted(model.np)+2*model.np$merr)),type="l")
lines(cps71$age,fitted(model.np)+2*model.np$merr,lty=2,col="red")
lines(cps71$age,fitted(model.np)-2*model.np$merr,lty=2,col="red")

plot(cps71$age,gradients(model.np),xlab="age",ylab="gradient",ylim=c(min(gradients(model.np)-2*model.np$gerr),max(gradients(model.np)+2*model.np$gerr)),type="l",lty=1,col="blue")
lines(cps71$age,gradients(model.np)+2*model.np$gerr,lty=2,col="red")
lines(cps71$age,gradients(model.np)-2*model.np$gerr,lty=2,col="red")
-------------------------------------------------------------------------------------------------------
border = NA barplot lines par(lwd = 3, lend = 2)
barplot(c(6,7),border = NA)
lines(c(0.2,0.2,1.2,1.2),c(0.02,6,6,0.02))
lines(c(1.4,1.4,2.4,2.4),c(0.02,7,7,0.02)) lines
-------------------------------------------------------------------------------------------------------
data("faithful", package = "datasets") 
x <- faithful$waiting 
opar <- par(mfcol= c(2,2))
for (bw in c(3,6,12,18) ) {
  hist(x, xlab = "Waiting interval", ylab = "Eruption Freq", 
  probability = TRUE, main = "Density plot: Triangular kernel", 
  border = "gray", sub= bquote("Bandwidth = "*.(bw) ) ) 
  lines(density(x, width = bw, window = "triangular"), lty=3, col="red")
  }
par(opar)
-------------------------------------------------------------------------------------------------------
?nls ## Initialize x1, y1, x2, y2
x1 <- c(1,2)
y1 <- c(10,10)

x2 <- c(3,4,5)
y2 <- c(20,30,40)

## make single x, y vector
x <- c(x1,x2)
set.seed(1001)
## (add a bit of noise to avoid zero-residual artificiality)
y <- c(y1,y2)+rnorm(5,sd=0.01)

g <- c(TRUE,TRUE,FALSE,FALSE,FALSE) ## specify identities of points

## particular changes:
##   * you have lower=upper=2 for x0.  Did you want 2<x0<3?
##   * specified data argument explicitly (allows use of predict() etc.)
##   * changed name from 'q' to 'fit1' (avoid R built-in function)
fit1 <- nls(y ~ ifelse(g,m1,m1+delta_m)*(x - x0) + y0,
         start = c(m1 = -1, delta_m = 2, y0 = 0, x0 = 2),
         algorithm = "port",
         lower = c(m1 = -Inf, delta_m = 0, y0 = -Inf, x0 = 2),
         upper = c(m1 = Inf, delta_m = Inf, y0 = Inf, x0 = 3),
         data=data.frame(x,y))

#Plot the original 'data'
plot(x,y,col=rep(c("red","blue"),c(2,3)),
           xlim=c(1,5),ylim=c(0,50))

## add predicted values
xvec <- seq(1,5,length.out=101)
lines(xvec,predict(fit1,newdata=data.frame(x=xvec))) ifelse x1 x2 x g g <- c(TRUE, TRUE, FALSE, FALSE, FALSE)
ifelse(g,x1,x2)
## [1] 1 2 5 3 4 x2 (3 4 5 3 4) ifelse > x2 + 1:5
[1] 4 6 8 7 9
Warning message:
In x2 + 1:5 :
  longer object length is not a multiple of shorter object length
-------------------------------------------------------------------------------------------------------
questionnumbers<-c(1,2,3,4,5,6,7,8)
result1<-c(0.2,0.4,0.3,0.6,0.9,0.3,0.4,0.8)
result2<-c(0.4,0.9,0.3,0.1,0.4,0.6,0.3,0.2)

plot(questionnumbers, result2, type = 'b', ylim = c(0,0.9), col = 'green', xlab = 'Question Nunbers', ylab = '', main = 'Chart 2', panel.first = grid(nx = NA, ny = NULL))
lines(questionnumbers, result1, col = 'blue', type = 'b')
legend('bottomleft', c('result1','result2'), fill = c('blue', 'green'), cex = 0.8, bty = 'n', horiz = TRUE)
-------------------------------------------------------------------------------------------------------
lattice #Set up the data
set.seed(1)
draws <- rnorm(100)^2
dens <- density(draws)

#Put in a simple data frame   
d <- data.frame(x = dens$x, y = dens$y)

#Define a custom panel function;
# Options like color don't need to be hard coded    
shadePanel <- function(x,y,shadeLims){
    panel.lines(x,y)
    m1 <- min(which(x >= shadeLims[1]))
    m2 <- max(which(x <= shadeLims[2]))
    tmp <- data.frame(x1 = x[c(m1,m1:m2,m2)], y1 = c(0,y[m1:m2],0))
    panel.polygon(tmp$x1,tmp$y1,col = "blue")
}

#Plot
xyplot(y~x,data = d, panel = shadePanel, shadeLims = c(1,3))
-------------------------------------------------------------------------------------------------------
factor plot plot.factor ?plot.factor spineplot type="l" X <- data.frame(
    Time = sort(sample(letters, 100, replace=TRUE)),
    Server = sample(c("PortalServer1", "PortalServer2"), 100, replace=TRUE),
    HeapFreePercent = runif(100))
str(X)

P1 <- subset(X, Server=="PortalServer1")
P2 <- subset(X, Server=="PortalServer2")

plot(P1$Time, P1$HeapFreePercent, type="l", col="red")
lines(P2$Time, P2$HeapFreePercent, col="green")
-------------------------------------------------------------------------------------------------------
locator() plot(cars)
xy <- locator(n=2)
lines(xy, col="red", lwd=5)
lm(y~x, xy)
abline(coef(lm(y~x, xy)))
coef(lm(y~x, xy))
(Intercept)           x 
  33.142094    1.529687 lm abline(coef(lm(dist~speed, cars)), col="blue") abline lm locator ?locator lm loess
-------------------------------------------------------------------------------------------------------
boring <- function(x, occ) occ/x

boring_seq <- function(occ, length.out){
  x <- seq(occ, length.out=length.out)
  data.frame(x = x, y = boring(x, occ))
}

numbet <- 31
odds <- 6
plot(1, 0, type="n",  
    xlim=c(1, numbet + odds), ylim=c(0, 1),
    yaxp=c(0,1,2),
    main="Frequency matrix", 
    xlab="Successive occasions",
    ylab="Relative frequency"
    )

axis(2, at=c(0, 0.5, 1))    

for(i in 1:odds){
  xy <- boring_seq(i, numbet+1)
  lines(xy$x, xy$y, type="o", cex=0.5)
}

for(i in 1:numbet){
  xy <- boring_seq(i, odds+1)
  lines(xy$x, 1-xy$y, type="o", cex=0.5)
}
-------------------------------------------------------------------------------------------------------
ps <- ldply(0:35, function(i)data.frame(s=0:i, n=i))
 plot.new()
 plot.window(c(0,36), c(0,1))
 apply(ps[ps$s<6 & ps$n - ps$s < 30, ], 1, function(x){
   s<-x[1]; n<-x[2];
   lines(c(n, n+1, n, n+1), c(s/n, s/(n+1), s/n, (s+1)/(n+1)), type="o")})
 axis(1)
 axis(2)
 lines(6:36, 6/(6:36), type="o")
 # need to fill in the unconnected points on the upper frontier
-------------------------------------------------------------------------------------------------------
x <- seq(from=1, to=10, by=0.1)
plot(x,sin(x), col='red', type='l')
clip(1,10,-1,.5)
lines(x,sin(x), col='yellow', type='l')
-------------------------------------------------------------------------------------------------------
nls(FUN, cbind(ph$counts, ph$mids),...) nls() smoo<-spline(ph$mids,ph$counts); lines(smoo$x,smoo$y)
-------------------------------------------------------------------------------------------------------
x = rnorm(1000)
hist(x, breaks = 30, freq = FALSE)
lines(density(x), col = "red")
-------------------------------------------------------------------------------------------------------
raster zip raster::getData unzip library(raster)
fraAlt <- raster('FRA_alt')
plot(fraAlt) ## Not only France is displayed... RData raster::getData RData SpatialPolygonsDataFrame gadm Raster mk <- rasterize(gadm, fraAlt) fraAltMask <- mask(fraAlt, x)
 plot(fraAltMask) ##Now only France is displayed lattice rasterVis library(rasterVis)
 levelplot(fraAlt)
 levelplot(fraAltMask) s <- stack(fraAlt, fraAltMask)
 layerNames(s) <- c('Alt', 'AltMask')
 boundaries <- as(gadm, 'SpatialLines')
 levelplot(s) + layer(sp.lines(boundaries))
-------------------------------------------------------------------------------------------------------
x <- c(126,162,233,304,375,446,517,588,659,730,801,839)
p <- c(0.06,0.06,0.1,0.08,0.12,0.16,0.14,0.14,0.08,0.02,0.04)
plot(x,c(p,0),type="s")
lines(x,c(0,p),type="S")
rect(x[-1],0,x[-length(x)],p,col="lightblue") rect lines plot(x,p,type="n") par(bty="l",lty=1) ?plot b <- barplot(p,width=diff(x),space=0)
-------------------------------------------------------------------------------------------------------
lines dat <- data.frame(x = rnorm(100), y = rnorm(100) + 2, z = rnorm(100) + 5)

plot(c(-2.5,8),c(0,0.5),type = "n")
lines(density(dat$x))
lines(density(dat$y))
lines(density(dat$z)) plot(...,type = "n") lines points
-------------------------------------------------------------------------------------------------------
set.seed(123)
xpois <- trunc(rpois(100, 4))
hist(xpois)
lines(seq(0,10), 100*dpois(seq(0,10), 4))
-------------------------------------------------------------------------------------------------------
scatter.smooth col lcol scatter.smooth <- function (x, y = NULL, span = 2/3, degree = 1, 
  family = c("symmetric", "gaussian"), xlab = NULL, ylab = NULL, 
  ylim = range(y, prediction$y, na.rm = TRUE), evaluation = 50, lcol="red", ...) 
{
    xlabel <- if (!missing(x)) 
        deparse(substitute(x))
    ylabel <- if (!missing(y)) 
        deparse(substitute(y))
    xy <- xy.coords(x, y, xlabel, ylabel)
    x <- xy$x
    y <- xy$y
    xlab <- if (is.null(xlab)) 
        xy$xlab
    else xlab
    ylab <- if (is.null(ylab)) 
        xy$ylab
    else ylab
    prediction <- loess.smooth(x, y, span, degree, family, evaluation)
    plot(x, y, ylim = ylim, xlab = xlab, ylab = ylab, ...)
    lines(prediction, col=lcol) #  <<-- Note the edit here
    invisible()
}

with(cars, scatter.smooth(speed, dist, col="blue", lcol="green"))
-------------------------------------------------------------------------------------------------------
scatter.smooth() ?scatter.smooth loess.smooth() scatter.smooth() plot() loess.smooth() plot(dist ~ speed, data = cars, col = "blue")
with(cars, lines(loess.smooth(speed, dist), col = "green")) loess.smooth() x y lines() > with(cars, loess.smooth(speed, dist))
$x
 [1]  4.000000  4.428571  4.857143  5.285714  5.714286  6.142857
 [7]  6.571429  7.000000  7.428571  7.857143  8.285714  8.714286
[13]  9.142857  9.571429 10.000000 10.428571 10.857143 11.285714
[19] 11.714286 12.142857 12.571429 13.000000 13.428571 13.857143
[25] 14.285714 14.714286 15.142857 15.571429 16.000000 16.428571
[31] 16.857143 17.285714 17.714286 18.142857 18.571429 19.000000
[37] 19.428571 19.857143 20.285714 20.714286 21.142857 21.571429
[43] 22.000000 22.428571 22.857143 23.285714 23.714286 24.142857
[49] 24.571429 25.000000

$y
 [1]  4.962236  6.132561  7.294531  8.451282  9.605949 10.761666
 [7] 11.921569 13.088792 14.266472 15.457742 16.646268 17.788187
[13] 18.916270 20.068806 21.284085 22.534880 23.776272 25.020014
[19] 26.277859 27.554763 28.793605 30.039834 31.287544 32.541662
[25] 33.982881 35.706712 37.262771 38.683122 40.080683 41.491404
[31] 42.951233 44.438569 45.860202 47.361200 49.023137 50.730452
[37] 52.619626 54.852390 57.325596 59.936095 62.580738 65.156375
[43] 67.559859 69.876282 72.248492 74.659973 77.094212 79.534692
[49] 81.964898 84.368316
-------------------------------------------------------------------------------------------------------
rollapply dat$D.time <- as.POSIXct(paste(dat$Date, dat$Time))
require(zoo)
 ?rollapply
 length(rollapply(dat$Watt,3, mean))
plot(dat$D.time, dat$Watt)
lines(dat$D.time[3:9], rollapply(dat$Watt,3, mean))
-------------------------------------------------------------------------------------------------------
caret nnet size decay #Load Packages
require(quantmod) #for Lag()
require(nnet)
require(caret)

#Make toy dataset
y <- sin(seq(0, 20, 0.1))
te <- data.frame(y, x1=Lag(y), x2=Lag(y,2))
names(te) <- c("y", "x1", "x2")

#Fit model
model <- train(y ~ x1 + x2, te, method='nnet', linout=TRUE, trace = FALSE,
                #Grid of tuning parameters to try:
                tuneGrid=expand.grid(.size=c(1,5,10),.decay=c(0,0.001,0.1))) 
ps <- predict(model, te)

#Examine results
model
plot(y)
lines(ps, col=2) neuralnet RSNNS caret nnet neuralnet RSNNS caret RSNNS caret caret
-------------------------------------------------------------------------------------------------------
y <- rnorm(1000, 0, 1)
x <- rnorm(1000, 0.5, 2)
dx <- density(x)
dy <- density(y)
plot(dx, xlim = range(dx$x, dy$x), ylim = range(dx$y, dy$y), 
     type = "l", col = "red")
lines(dy, col = "blue")
-------------------------------------------------------------------------------------------------------
# Expand right side of clipping rect to make room for the legend
par(xpd=T, mar=par()$mar+c(0,0,0,6))

# Plot graph normally
plot(1:3, rnorm(3), pch = 1, lty = 1, type = "o", ylim=c(-2,2))
lines(1:3, rnorm(3), pch = 2, lty = 2, type="o")

# Plot legend where you want
legend(3.2,1,c("group A", "group B"), pch = c(1,2), lty = c(1,2))

# Restore default clipping rect
par(mar=c(5, 4, 4, 2) + 0.1)
-------------------------------------------------------------------------------------------------------
data <- data.frame(time = seq(0, 23), noob = rnorm(24), plus = runif(24), extra = rpois(24, lambda = 1))
plot(extra ~ time, 
  data = data, 
  type = "l", 
  ylim = c(min(data[ ,-1]), max(data[ ,-1])),
  ylab = "value")
lines(data$time, data$plus, col = "steelblue")
lines(data$time, data$noob, col = "pink")
-------------------------------------------------------------------------------------------------------
lm optim set.seed(5)
d <- data.frame(x=seq(-5, 5, len=51))
d$y <- 50 - 0.3*d$x^2 + rnorm(nrow(d))
M <- 50 qM <- function(a, b, x, M) {
  c <- M - (3*b^2)/(4*a)
  a*x^2 + b*x + c
} ff <- function(ab, d, M) {
  p <- qM(ab[1], ab[2], d$x, M)
  y <- d$y
  sum((p-y)^2)
} lm m0 <- lm(y ~ I(x^2) + x, data=d)
start <- coef(m0)[2:3] ff o <- optim(start, ff, d=d, M=M)
o$par lm plot(d)
xs <- seq(-5, 5, len=101)
lines(xs, predict(m0, newdata=data.frame(x=xs)), col="gray")
lines(xs, qM(o$par[1], o$par[2], xs, M))
abline(h=50, lty=3)
-------------------------------------------------------------------------------------------------------
BBands VWAP require(quantmod)
getSymbols('SPY')
v <- VWAP(Cl(SPY),Vo(SPY))
b <- BBands(v)
plot(v)
lines(b[,'dn'], col='red')
lines(b[,'mavg'], col='blue')
lines(b[,'up'], col='red')
-------------------------------------------------------------------------------------------------------
splines # test data
df1 <- data.frame(x=rnorm(100), y=rpois(100, lambda=.5))
df2 <- data.frame(x=rnorm(200), y=rpois(200, lambda=.5))

tmp1 <- spline( lowess( df1[,1], df1[,2] ), n = 20 )
tmp2 <- spline( lowess( df2[,1], df2[,2] ), n = 20 )

plot( tmp1[[1]], tmp1[[2]], type="l" )
lines( tmp2[[1]], tmp2[[2]], col="red" ) plot( tmp1[[1]], tmp1[[2]], type="l", ylim=c(0,4) )
 lines( tmp2[[1]], tmp2[[2]], col="red" )
 points(jitter(df2[[1]]), df2[[2]],  cex=0.3, col="blue")
 points(jitter( df1[[1]]), df1[[2]], cex=0.3, col="red")
-------------------------------------------------------------------------------------------------------
loess span span=0.25 x <- seq(1, 10, 0.5)
y <- c(1, 1.5, 1.6, 1.7, 2.1,
    2.2, 2.2, 2.4, 3.1, 3.3,
    3.7, 3.4, 3.2, 3.1, 2.4,
    1.8, 1.7, 1.6, 1.4)

xl <- seq(1, 10, 0.125)
plot(x, y)
lines(xl, predict(loess(y~x, span=0.25), newdata=xl)) lowess spl <- smooth.spline(x, y)
plot(x, y)
lines(predict(spl, xl))
-------------------------------------------------------------------------------------------------------
> xl=seq(0,10,len=100)
> p=lm(y~poly(x,18))
> plot(x,y)
> lines(xl,predict(p,newdata=data.frame(x=xl)))
-------------------------------------------------------------------------------------------------------
x <- seq(1, 10, 0.5)
y <- c(1, 1.5, 1.6, 1.7, 2.1,
    2.2, 2.2, 2.4, 3.1, 3.3,
    3.7, 3.4, 3.2, 3.1, 2.4,
    1.8, 1.7, 1.6, 1.4)

library(splines)

isp <- interpSpline(x,y)

xvec <- seq(min(x),max(x),length=200)  ## x values for prediction

png("isp.png")
plot(x,y)
## predict() produces a list with x and y components
lines(predict(isp,xvec),col="red")
dev.off()
-------------------------------------------------------------------------------------------------------
\floatstyle{ruled}
\newfloat{rcode}{b}{R}
\floatname{rcode}{R Code}

\floatstyle{boxed}
\newfloat{rout}{b}{R}
\floatname{rout}{R Output}

\begin{document}

!@plot A very informative plot

a <- c(2,3,5,7)
plot(a)

@;

!@print Some output

a<-c(2,5,5,7)
print(a)

@;

\end{document} import sys
if __name__ == "__main__":
    old = open(sys.argv[1])
    new = open(sys.argv[2],'w')
    old_lines = old.readlines()
    i = 0

    out_file = ""

    while i < len(old_lines):

        if old_lines[i].lstrip()[0:2] == '!@':
            line = old_lines[i]
            obj = line[2:line.index(' ')].strip()
            label = line[line.index(' ')+1:line.index('\n')].strip()

            obj_end = i
            while old_lines[obj_end].strip() != "@;":
                obj_end += 1

            out_file += "\\begin{rcode}[p]\n"
            out_file += "<<label="+ label +", include=FALSE>>=\n"

            i += 1
            while i < obj_end:
                out_file += old_lines[i]
                i += 1

            out_file += "@\n"
            out_file += "\\caption{"+label+"}\n"
            out_file += "\\end{rcode}\n"

            if obj == "plot":
                out_file += "\\begin{figure}[H]\setkeys{Gin}{width=3.5in}\n"
                out_file += "<<fig=TRUE, echo=FALSE>>=\n"
                out_file += "<<"+label+">>"
                out_file += "\n@\n"
                out_file += "\\caption{"+label+"}\n"
                out_file += "\\end{figure}"

            if obj == "print":
                out_file += "\\begin{rout}[H]\n"
                out_file += "<<echo=FALSE>>=\n"
                out_file += "<<"+label+">>"
                out_file += "\n@\n"
                out_file += "\\caption{"+label+"}\n"
                out_file += "\\end{rout}"
            i += 1

        else:
            out_file += old_lines[i]
            i += 1

    new.write(out_file)
    new.close() #!/bin/bash                                                               
export SWEAVE_STYLEPATH_DEFAULT="TRUE"
export PATH=$PATH:/usr/texbin:/usr/local/bin
python ~/Library/TexShop/Scripts/sweave_macros.py "$1" "fin_$1"
R CMD Sweave "fin_$1"
pdflatex "fin_${1%.*}"
-------------------------------------------------------------------------------------------------------
## create some example data

Tg <- data.frame(Tg1 = rnorm(10))
for (i in 2:10) {
  vec <- rep(NA, 8)
  vec <- c(rnorm(sample(5:10,1)), vec)
  Tg[paste("Tg", i, sep="")] <- vec[1:10]

}

Pf <- data.frame(Pf1 = rnorm(10))
for (i in 2:10) {
  vec <- rep(NA, 8)
  vec <- c(rnorm(sample(5:10,1)), vec)
  Pf[paste("Pf", i, sep="")] <- vec[1:10]

}
## ok, sample data created

## now lets loop through all the columns
## if you didn't know how many columns there are you could 
## use ncol(Tg) to figure out

for (i in 1:10) {
  plot(1:10, Tg[,i], type = "l", col="blue", lwd=5, ylim=c(-3,3), 
     xlim=c(1, max(length(na.omit(Tg[,i])), length(na.omit(Pf[,i])))))
  lines(1:10, Pf[,i], type = "l", col="red", lwd=5, ylim=c(-3,3))
  dev.copy(png, paste('rplot', i, '.png', sep=""))
  dev.off()
}
-------------------------------------------------------------------------------------------------------
dat<- data.frame(t=seq(0, 2*pi, by=0.1) )
 xhrt <- function(t) 16*sin(t)^3
 yhrt <- function(t) 13*cos(t)-5*cos(2*t)-2*cos(3*t)-cos(4*t)
 dat$y=yhrt(dat$t)
 dat$x=xhrt(dat$t)
 with(dat, plot(x,y, type="l")) with(dat, polygon(x,y, col="hotpink")) help(points) TestChars points(c(10,-10, -15, 15), c(-10, -10, 10, 10), pch=169, font=5) library(Cairo)

clubs <- expression(symbol('\247'))
hearts <- expression(symbol('\251'))
diamonds <- expression(symbol('\250'))
spades <- expression(symbol('\252'))
csymbols <- c(clubs, hearts, diamonds, spades)

plot( 0, xlim=c(0,5), ylim=c(0,2), type="n" )
clr <- c("black", "red", "red", "black") 
for (i in 1:4) {
  hline <- function( yloc, ... ) 
         for (i in 1:length(yloc)) 
             lines( c(-1,6), c(yloc[i],yloc[i]), col="gray")  
              hline(0.9); 
                hline(1.0);
                hline(1.1);
                hline(1.2)  
 text( i, 1, csymbols[i], col=clr[i], cex=5 )  
 text( i, 0.5, csymbols[i], col=clr[i] ) }

# Also try this
plot(1,1)
text(x=1+0.2*cos(seq(0, 2*pi, by=.5)), 
     y=1+0.2*sin(seq(0, 2*pi, by=.5)), 
                  expression(symbol('\251') ) )
-------------------------------------------------------------------------------------------------------
plot(x, y*10, type = 'l', ylim = range(c(y*10,y1)), yaxt = 'n', col = 'red')
axis(2, (1:6)*10, 1:6, col = 'red')
lines(x1, y1, col = 'blue')
axis(4, (1:6)*10, col = 'blue')
grid(nx = NA, ny = NULL)
-------------------------------------------------------------------------------------------------------
arima.sim() simulate.Arima() simulate.Arima() simulate.Arima() Arima ?arima.sim install.packages("forecast") library(forecast) fit <- auto.arima(USAccDeaths) plot(USAccDeaths,xlim=c(1973,1982)) lines(simulate(fit, 36),col="red")
-------------------------------------------------------------------------------------------------------
SwStr K plot(res$SwStr, res$K) with(res,plot(K~SwStr)) K SwStr lm abline(graphic,...) predict K=c(.259, .215, .224, .223, .262, .233)
SwStr=c(.130, .117, .117, .114, .113, .111)
g <- lm(K~SwStr-1)
par(las=1,bty="l")  ## my favourites
plot(K~SwStr)
P <- predict(g)
lines(SwStr,P) newdata predict
-------------------------------------------------------------------------------------------------------
R-2.12.1 R-2.14.0 R-2.13.0 NEWS * plot(<formula>, data=<matrix>,..) now works in more cases;
  similarly for points(), lines() and text(). R
-------------------------------------------------------------------------------------------------------
hist(x) myhist(x) myhist(mydata$V3, breaks=c(0,1,2,3,4,5,25), log="xy") myhist <- function(x, ..., breaks="Sturges",
                   main = paste("Histogram of", xname),
                   xlab = xname,
                   ylab = "Frequency") {
  xname = paste(deparse(substitute(x), 500), collapse="\n")
  h = hist(x, breaks=breaks, plot=FALSE)
  plot(h$breaks, c(NA,h$counts), type='S', main=main,
       xlab=xlab, ylab=ylab, axes=FALSE, ...)
  axis(1)
  axis(2)
  lines(h$breaks, c(h$counts,NA), type='s')
  lines(h$breaks, c(NA,h$counts), type='h')
  lines(h$breaks, c(h$counts,NA), type='h')
  lines(h$breaks, rep(0,length(h$breaks)), type='S')
  invisible(h)
}
-------------------------------------------------------------------------------------------------------
plot(d)    
 abline(lm(x~y**2,data=d), col="black") lines(smooth.spline(x, y))
-------------------------------------------------------------------------------------------------------
R> y<-c(0.0100,2.3984,11.0256,4.0272,0.2408,0.0200);
R> x<-c(1,3,5,7,9,11);
R> d<-data.frame(x,y)
R> myLm<-lm(x~y**2,data=d)
R> myLm

Call:
lm(formula = x ~ y^2, data = d)

Coefficients:
(Intercept)            y  
      6.434       -0.147 x y R> plot(d)
R> lines(d$y,fitted(myLm))
-------------------------------------------------------------------------------------------------------
predict d <- data.frame(x=seq(1,11,by=2),
                y=c(0.0100,2.3984,11.0256,4.0272,0.2408,0.0200))
lm1 <-lm(y ~ log(x)+x, data=d)
lm2 <-lm(y ~ I(x^2)+x, data=d)
xvec <- seq(0,12,length=101)
plot(d)
lines(xvec,predict(lm1,data.frame(x=xvec)))
lines(xvec,predict(lm2,data.frame(x=xvec)))
-------------------------------------------------------------------------------------------------------
lines(mp, data.30.c$mean.rev,col=34)
-------------------------------------------------------------------------------------------------------
wrld_simpl library(maptools)
library(geosphere)

data(wrld_simpl)

US_lat = wrld_simpl$LAT[wrld_simpl$NAME == 'United States']
US_lon = wrld_simpl$LON[wrld_simpl$NAME == 'United States']

SWE_lat = wrld_simpl$LAT[wrld_simpl$NAME == 'Sweden']
SWE_lon = wrld_simpl$LON[wrld_simpl$NAME == 'Sweden']

points = gcIntermediate(c(US_lon, US_lat), c(SWE_lon, SWE_lat), 100)

dev.new(width=6, height=4)
plot(wrld_simpl)
lines(points, col='red')
-------------------------------------------------------------------------------------------------------
lines x y lines(c(US_lon, australia_lon), c(US_lat, australia_lat)) require(geosphere)
gc <- gcIntermediate(c(US_lon, US_lat), c(australia_lon, australia_lat), breakAt=TRUE, n=1000)
invisible(lapply(gc, lines, col='red', lwd=2))
-------------------------------------------------------------------------------------------------------
col z cut() cut2() x,y,z z.cols <- cut(z, 3, labels = c("pink", "green", "yellow"))
plot(x,y, col = as.character(z.cols), pch = 16) legend col type = "p" plot(x,y, type = "l", col = as.character(z.cols)) lines() segments() type = "l"
-------------------------------------------------------------------------------------------------------
PA <- c(3028.0,3083.0,2958.0,2889.0,2758.0,2815.0,2877.0,3145.0,3072.0,3056.0,2856.0,2934.0,3112.0,2913.0,2837.0)

den.PA <- density(PA)
lineat = 2913

# Find which x value that the density was computed
# for is the closest to the x value we want a line at
lineheight <- den.PA$y[which.min(abs(den.PA$x - lineat))]
plot(den.PA, main="Avidin PA",)
lines(c(lineat, lineat), c(0, lineheight), col = "red")
-------------------------------------------------------------------------------------------------------
newdata newx = seq(min(df$x), max(df$x), len=100)
lines(newx, predict(res, newdata=data.frame(x=newx)), col='blue', lwd=2) scaled=F newdata
-------------------------------------------------------------------------------------------------------
# Comparison of Linear Regression & PCA
# Generate sample data

set.seed(39) # gives a decent-looking example
np <- 10 # number of data points
x <- -np:np
e <- rnorm(length(x), 0, 10)
y <- rnorm(1, 0, 2) * x + 3*rnorm(1, 0, 2) + e

# Plot the main data & residuals

plot(x, y, main = "Regression minimizes the y-residuals & PCA the normals", asp = 1)
yx.lm <- lm(y ~ x)
lines(x, predict(yx.lm), col = "red", lwd = 2)
segments(x, y, x, fitted(yx.lm), col = "pink")

# Now the PCA using built-in functions
# rotation = loadings = eigenvectors

r <- prcomp(cbind(x,y), retx = TRUE)
b <- r$rotation[2,1] / r$rotation[1,1] # gets slope of loading/eigenvector 1
a <- r$center[2] - b * r$center[1]
abline(a, b, col = "blue") # Plot 1st PC

# Plot normals to 1st PC

X <- pointOnLineNearPoint(x, y, b, a)
segments( x, y, X[,1], X[,2], col = "lightblue1")

###### Needed Functions

pointOnLineNearPoint <- function(Px, Py, slope, intercept) {
    # Px, Py is the point to test, can be a vector.
    # slope, intercept is the line to check distance.

    Ax <- Px-10*diff(range(Px))
    Bx <- Px+10*diff(range(Px))
    Ay <- Ax * slope + intercept
    By <- Bx * slope + intercept
    pointOnLine(Px, Py, Ax, Ay, Bx, By)
    }

pointOnLine <- function(Px, Py, Ax, Ay, Bx, By) {

    # This approach based upon comingstorm's answer on
    # stackoverflow.com/questions/3120357/get-closest-point-to-a-line
    # Vectorized by Bryan

    PB <- data.frame(x = Px - Bx, y = Py - By)
    AB <- data.frame(x = Ax - Bx, y = Ay - By)
    PB <- as.matrix(PB)
    AB <- as.matrix(AB)
    k_raw <- k <- c()
    for (n in 1:nrow(PB)) {
        k_raw[n] <- (PB[n,] %*% AB[n,])/(AB[n,] %*% AB[n,])
        if (k_raw[n] < 0)  { k[n] <- 0
            } else { if (k_raw[n] > 1) k[n] <- 1
                else k[n] <- k_raw[n] }
        }
    x = (k * Ax + (1 - k)* Bx)
    y = (k * Ay + (1 - k)* By)
    ans <- data.frame(x, y)
    ans
    }
-------------------------------------------------------------------------------------------------------
t <- rect.hclust(fit, k=3, border=c("red",'green','blue')) [[1]]
[1] 12 14

[[2]]
 [1]  1  2  3  4  5  6  7  8  9 13

[[3]]
[1] 10 11 for (i in 1:length(dat$PA)){
    lineat = dat$PA[i]
    lineheight <- den.PA$y[which.min(abs(den.PA$x - lineat))]
    if(i %in% t[[1]]) lines(c(lineat, lineat), c(0, lineheight), col = "red")
    if(i %in% t[[2]]) lines(c(lineat, lineat), c(0, lineheight), col = "green")
    if(i %in% t[[3]]) lines(c(lineat, lineat), c(0, lineheight), col = "blue")
}
-------------------------------------------------------------------------------------------------------
par(mfrow=c(1,2))

d <- dist(rmsd$rmsd, method = "euclidean")
fit <- hclust(d, method="ward")
plot(fit, labels=rmsd$pdb)
groups <- cutree(fit, k=3)

cols = c('red', 'green', 'blue')

rect.hclust(fit, k=3, border=cols)

#for (i in dat[1]){for (z in i){ if (z=="1sx3.pdb"){print (z)}}}

cols = cols[sort(unique(groups[fit$order]), index=T)$ix]

den.PA <- density(dat$PA)
plot(den.PA)
for (i in 1:length(dat$PA)){
    lineat = dat$PA[i]
    lineheight <- den.PA$y[which.min(abs(den.PA$x - lineat))]
    col = cols[groups[which(rmsd$pdb == as.character(dat[i, 'pdb']))]]
    lines(c(lineat, lineat), c(0, lineheight), col = col)
}
-------------------------------------------------------------------------------------------------------
dfrm <- data.frame(tm <-1:364, ev1=ev1, ev2=ev2) ev1dens <-  density(dfrm$tm, weights=dfrm$ev1/sum(dfrm$ev1), from=0, to=364, n=364)
 plot( ev1dens, lwd=5)
 which.max(ev1dens$y)
#[1] 326
 abline(v=326)  # which(cumsum(ev1dens$y[ order(ev1dens$y, decreasing =TRUE) ])/sum(ev1dens$y) > 0.9)[1]
#[1] 124
 ev1dens$x[order(ev1dens$y, decreasing =TRUE) ][124]
#1] 240.6612 ev1dens <-  density(dfrm$tm, weights=dfrm$ev1/sum(dfrm$ev1), from=0, to=364)
 which(cumsum(ev1dens$y[ order(ev1dens$y, decreasing =TRUE) ])/sum(ev1dens$y) > 0.9)[1]
# [1] 175
 ev1dens$x[order(ev1dens$y, decreasing =TRUE) ][175]
# [1] 240.0548
 idx <- order(ev1dens$y, decreasing =TRUE)
  lines(ev1dens$x[idx], ev1dens$y[idx], lty=3, lwd=2.5, col="red")
  abline(v=240, col="green", lwd=3) require(hexbin)
 hexev1 <- with(dfrm,  hexbin(tm, ev1))
 plot(hexev1)
 hexev2 <- with(dfrm,  hexbin(tm, ev2))
 plot(hexev2)
 plot(hexev1) > min(which(cumsum(ev1) >= sum(ev1)*(x/100) ) )
[1] 317
> min(which(cumsum(ev2) >= sum(ev2)*(x/100) ) )
[1] 112
-------------------------------------------------------------------------------------------------------
x=1:length(ev)
 plot(x,ev)
 lxy <- loess(ev~x )
 lines(predict(lxy, x=1:length(y)))
 title(main="loess() fit of ev") x=1:length(y); y=c(356.83, 
 973.5, 0, 240.43, 1232.07, 1440, 1329.67, 1096.87, 1331.37, 1305.03, 
 1328.03, 1246.03, 1182.3, 1054.53, 723.03, 1171.53, 1263.17, 
 1200.37, 1054.8, 971.4, 936.4, 968.57, 897.93, 1099.87, 876.43, 
 1095.47, 1132, 774.4, 1075.13, 982.57, 947.33, 1096.97, 929.83, 
 1246.9, 1398.2, 1063.83, 1223.73, 1174.37, 1248.5, 1171.63, 1280.57, 
 1183.33, 1016.23, 1082.1, 795.37, 900.83, 1159.2, 992.5, 967.3, 
 1440, 804.13, 418.17, 559.57, 563.87, 562.97, 1113.1, 954.87, 
 883.8, 1207.1, 1046.83, 995.77, 803.93, 1036.63, 946.9, 887.33, 
 727.97, 733.93, 979.2, 1176.8, 1241.3, 1435.6)

 lxyhi <- loess(y~x)
 plot(x,y)
 lines(predict(lxyhi, x=1:length(y)))
-------------------------------------------------------------------------------------------------------
map.poly() as.polygon=FALSE lines() map.poly() as.polygon=TRUE polygon() border=FALSE map map("state","tennessee",fill=T,col="white",names=T,plot=T)
coords = map.poly("county",region=c("tennessee,williamson","tennessee,davidson","tennessee,wilson","tennessee,cheatham"), boundary=T, interior=F, fill=F, as.polygon=T)
polygon(coords, col='red', border=F)
map("county",region=c("tennessee,williamson","tennessee,davidson","tennessee,wilson","tennessee,cheatham"),fill=F,interior=F,add=T) ?map map(..., interior=F, fill=T, col='red')
-------------------------------------------------------------------------------------------------------
n <- 7
x <- runif(n)
y <- runif(n)
t <- 1:n
ts <- seq(1, n, by = 1/10)
xs <- splinefun(t, x)(ts)
ys <- splinefun(t, y)(ts)

plot(x, y, xlim = c(0, 1), ylim = c(0, 1))
lines(xs, ys)
-------------------------------------------------------------------------------------------------------
type.c <- c("debit", "debit", "credit")
type.f <- factor(type.c) storage.mode(type.c)
# [1] "character"
storage.mode(type.f)
# [1] "integer" levels(type.f)
 # [1] "credit" "debit" str(type.f)
# Factor w/ 2 levels "credit","debit": 2 2 1 dc <- c("debit", "credit")
N <- 300

# lets store the calculations as a matrix
# col1 = n
# col2 = sizeof(character)
# col3 = sizeof(factors)
res <- matrix(ncol=3, nrow=N)

for (i in c(1:N)) {
  type.c <- sample(dc, i, replace=T)
  type.f <- factor(type.c)
  res[i, 1] <- i
  res[i, 2] <- object.size(type.c)
  res[i, 3] <- object.size(type.f)
  cat('N=', i, '  object.size(type.c)=',object.size(type.c), '  object.size(type.f)=',object.size(type.f), '\n')
}
plot(res[,1], res[,2], col='blue', type='l', xlab='Number of items in type.x', ylab='bytes of storage')
lines(res[,1], res[,3], col='red')
mtext('blue for character; red for factor')

cat('Threshold at:', min(which(res[,2]>res[,3])), '\n')
-------------------------------------------------------------------------------------------------------
ylim plot plot(t,ylim=c(1,15))
lines(tt)
-------------------------------------------------------------------------------------------------------
plot(t,ylim=range(t[2],tt[2]))
lines(tt)
-------------------------------------------------------------------------------------------------------
require(plyr)

data(iris)

pcr <- prcomp(~ Sepal.Length + Sepal.Width + Petal.Length + Petal.Width, data = iris)

indiv <- data.frame(pcr$x[,1:2])

indiv$species <- iris$Species

column <- data.frame(pcr$rotation[ ,1:2])

n <- nrow(indiv)

eigenval <- pcr$sdev[1:2]

eigenval <- eigenval * sqrt(n)

indiv <- transform(indiv, pc1 = PC1 / eigenval[1], pc2  = PC2 / eigenval[2])

column <- transform(column, pc1 = PC1 * eigenval[1], pc2  = PC2 * eigenval[2])

### based on stats:::biplot.default

unsigned.range <- function(x) c(-abs(min(x, na.rm = TRUE)),  abs(max(x, na.rm = TRUE)))

rangx1 <- unsigned.range(indiv[, 4])
rangx2 <- unsigned.range(indiv[, 5])
rangy1 <- unsigned.range(column[, 3])
rangy2 <- unsigned.range(column[, 4])

mylim <- range(rangx1, rangx2)
ratio <- max(rangy1/rangx1, rangy2/rangx2)

nspecies <- table(iris$Species)

# compute the convex hull for each species
hull <- dlply(indiv[,1:3], .(species), chull)

# get points connected
hull <- llply(hull, function(x) c(x, x[1]))


plot(pc2 ~ pc1, data = indiv, cex = 0.5, col = c("blue", "yellow", "green")[iris$Species], xlim = mylim, ylim = mylim)

lines(indiv$pc1[hull$setosa], indiv$pc2[hull$setosa] , col = "blue")

lines(indiv$pc1[cumsum(nspecies)[1] + hull$versicolor], indiv$pc2[cumsum(nspecies)[1] + hull$versicolor], col = "yellow")

lines(indiv$pc1[cumsum(nspecies)[2] + hull$virginica],  indiv$pc2[cumsum(nspecies)[2] + hull$virginica], col = "green")

par(new = TRUE)

plot(pc1 ~ pc2, data = column, axes = FALSE, type = "n", xlim = mylim * ratio, ylim = mylim * ratio, xlab = "", ylab = "")

text(column$pc1, column$pc2, labels = rownames(column), cex = 0.5, col = "red")

arrows(0, 0, column$pc1 * 0.8, column$pc2 * 0.8, col = "red", length = 0.2)

axis(3, col = "red")

axis(4, col = "red")
-------------------------------------------------------------------------------------------------------
b <- lapply(Sys.glob('Trial7/*.csv'), function(file) {
    e <- read.table(file)
    data.frame(as.Date(e$V1, "%d.%m.%Y"), e$V2)
})

png('./Pictures/compare2.png')
plot(b[[1]], type='l', ylim=range(b[[1]][[2]],b[[2]][[2]]))
lines(b[[2]])
-------------------------------------------------------------------------------------------------------
general # Remixing Simon's answer
b <- lapply(Sys.glob('Trial7/*.csv'), function(file) {
    e <- read.table(file)
    data.frame(as.Date(e$V1, "%d.%m.%Y"), e$V2)
})

png('./Pictures/compare2.png')

# Generalizing here the range and lines
vals<-do.call(rbind, b)[[2]] 
plot(b[[1]], type='l', ylim=range(vals)) 
lapply(b[-1], function(file){ lines(file)}) 
dev.off()
-------------------------------------------------------------------------------------------------------
-age plot(-age~size, type="n",yaxt="n", xlab="", ylab="Age")
lines(-age~size)
segments(0, -age, size, -age)
axis(2, labels=c(0,5,10,15,20), at=-c(0,5,10,15,20), las=1) ylab="" text
-------------------------------------------------------------------------------------------------------
i <- order(offer)
lines(offer[i], predict(model,list(offer))[i]) * lm > lm(demand~(offer<22.4)*offer + (offer>=22.4)*offer)
Call:
lm(formula = demand ~ (offer < 22.4) * offer + (offer >= 22.4) * offer)
Coefficients:
            (Intercept)         offer < 22.4TRUE                    offer  
                -309.46                   356.08                    29.86  
      offer >= 22.4TRUE   offer < 22.4TRUE:offer  offer:offer >= 22.4TRUE  
                     NA                   -20.79                       NA (offer<22.4)*offer model <- lm(
  demand ~ ifelse(offer<22.4,offer-22.4,0) 
           + ifelse(offer>=22.4,offer-22.4,0) )
-------------------------------------------------------------------------------------------------------
lines lines #After reading your data into dat
Break <- 22.4
dat$grp <- dat$offer < Break

#Note the addition of the grp variable makes this a bit easier to read
m <- lm(demand~offer*grp,data = dat)
dat$pred <- predict(m)

plot(dat$offer,dat$demand)
dat <- dat[order(dat$offer),]
with(subset(dat,offer < Break),lines(offer,pred))
with(subset(dat,offer >= Break),lines(offer,pred))
-------------------------------------------------------------------------------------------------------
EBImage Rimage x <- -100:100
x2 <- seq(-70,-50,length.out=length(x)/4)

a.line <- list(x = x,
               y = 4*x + 5) 

a.hole <- list(
  x = c(x2,rev(x2)),
  y = c(200 + sqrt(100-(x2+60)^2),
        rev(200 - sqrt(100-(x2+60)^2)))
  )

plot(a.line,type='l')
lines(a.hole,col='red')

calc.distance <- function(line,hole){

  mline <- matrix(unlist(line),ncol=2)
  mhole <- matrix(unlist(hole),ncol=2)

  id1 <- rep(1:nrow(mline),nrow(mhole))
  id2 <- rep(1:nrow(mhole), each=nrow(mline))

  min(
    sqrt(
      (mline[id1,1]-mhole[id2,1])^2 + 
      (mline[id1,2]-mhole[id2,2])^2
    )
  )
} > calc.distance(a.line,a.hole)
[1] 95.51649
-------------------------------------------------------------------------------------------------------
latticeExtra library(latticeExtra)
p1 <- xyplot(var ~ temp | subj, data=orig, panel=function(..., subscripts) {
  fill <- my.fill[combined$trt[subscripts]] 
  panel.xyplot(..., pch=21, fill=my.fill, col="black")
})
p2 <- xyplot(var ~ temp | subj, data=model, type="l")
p1+p2 combined xyplot(var ~ temp | subj, groups=which, data = combined,
       panel = function(x, y, groups, subscripts){
         fill <- my.fill[combined$trt[subscripts]]
         g <- groups[subscripts]
         panel.points(x[g=="original"], y[g=="original"], pch = 21, 
                      fill = my.fill, col = "black")
         panel.lines(x[g=="model"], y[g=="model"], col = "black")
       },
       key = list(space = "right",
         text = list(c("trt1", "trt2"), cex = 0.8),
         points = list(pch = c(21), fill = c("black", "grey")),
         rep = FALSE)
       )
-------------------------------------------------------------------------------------------------------
rq require(quantreg)
 data(stackloss); fit <- rq(stack.loss ~ Air.Flow, .5, data=stackloss)
 with(stackloss,   plot(Air.Flow, stack.loss))
 abline(a=coef(fit)[1], b=coef(fit)[2]) loess fit <-loess(stack.loss ~ Air.Flow, data=stackloss, family="symmetric")
plot(stack.loss ~ Air.Flow, data=stackloss)
with(stackloss, lines(sort(unique(Air.Flow)),  
                      predict(fit, data.frame(Air.Flow=sort(unique(Air.Flow))))))
-------------------------------------------------------------------------------------------------------
x <- c(1, 1, 1, 2, 2, 3, 3, 3, 3)
y <- seq_along(x) x x plot(y ~ x)

m <- tapply(y, x, median)
lines(m ~ unique(x))
-------------------------------------------------------------------------------------------------------
devSVGTips onefile=TRUE onefile=FALSE # Same code as yours, indented, and with 
# a different title for the second plot to see the difference.
library(RSVGTipsDevice)

devSVGTips(
  "svgplot9.svg", toolTipMode=1,
  onefile=FALSE, # Try with TRUE (overlaid plots) or FALSE (separate plots)
  title="SVG example plot 9: line and point types"
)
plot(
  c(0,20),c(0,5), type="n", xlab="x", ylab="y",
  main="Example SVG plot with different line and point types"
)
for (i in 0:16) {
  lines(i+(0:4), (1:5), col=max(i,1), pch=i, lty=i, type="b")
  text(i, 0.5, lab=as.character(i), cex=2^(abs((i-8)/4)-1))
}

#devSVGTips(
#  "svgplot9.svg", toolTipMode=1, onefile=TRUE,
#  title="SVG example plot 10: line and point types"
#)
plot(
  c(0,20),c(0,5), type="n", xlab="x", ylab="y",
  main="Example SVG plot with different line and point types (2)"
)
for (i in 0:16) {
  lines(i+(0:4), (1:5), col=max(i,1), pch=i, lty=i, type="b")
  text(i, 0.5, lab=as.character(i), cex=2^(abs((i-8)/4)-1))
}

dev.off()
-------------------------------------------------------------------------------------------------------
set.seed(121)
a=sample(1:100,5)
b=sample(1:100,5)
c=sample(1:100,5)

dev.off()

layout(rbind(1,2), heights=c(7,1))  # put legend on bottom 1/8th of the chart

plot(a,type='l',ylim=c(min(c(a,b,c)),max(c(a,b,c))))
lines(b,lty=2)
lines(c,lty=3,col='blue')

# setup for no margins on the legend
par(mar=c(0, 0, 0, 0))
# c(bottom, left, top, right)
plot.new()
legend('center','groups',c("A","B","C"), lty = c(1,2,3),
       col=c('black','black','blue'),ncol=3,bty ="n")
-------------------------------------------------------------------------------------------------------
trace() myFun plot() myFun <- function() {
    x <- 
        8:1
    y <- 
        1:8
    plot(y~x)
    lines(y~x)
    text(x,y, letters[1:8], pos=3)
} trace myFun plot() as.list(body(myFun)) as.list(body(myFun)) 
# [[1]]
# `{`
# 
# [[2]]
# x <- 8:1
# 
# [[3]]
# y <- 1:8
# 
# [[4]]
# plot(y ~ x)
# 
# ... More ... trace() myFun trace(myFun, browser, 4)

# TRY IT OUT
# (Once in the browser, type "n" and press Enter to step through the code.)
myFun() untrace(myFun) findLineNum() setBreakPoint() myFun() "myScript.R" source("myScript.R")            # Must source() once before using findLineNum 
                                # or setBreakPoint
findLineNum("myScript.R#10")    # I see that I missed the step by one line
setBreakpoint("myScript.R#11")  # Insert the breakpoint at the line that calls 
                                # plot()

myFun()                         # Test that breakpoint was properly inserted
                                # (Again, use "n" and Enter to step through code)
-------------------------------------------------------------------------------------------------------
barp <- barplot( dat$X.2)
 barp  
# this is what barplot returns and is then used as the x-values for a call to lines.
     [,1]
[1,]  0.7
[2,]  1.9
[3,]  3.1
[4,]  4.3
[5,]  5.5
 lines(barp, 1000*dnorm(seq(3,7), 7,2))
-------------------------------------------------------------------------------------------------------
plot(0,type="n", xlim=c(0,10), ylim=c(0,10), xlab="X Label", ylab="Y Label", main="Title") lines(1:10, 1:10, type="l", lty=2)
lines(2:4, 10:8, col=2, type="l")
lines(6:9, c(5,6,5,6), col=3, type="l")
-------------------------------------------------------------------------------------------------------
oldlogspline logspline mymat <- cbind( c(0,1,5.5,10.5, 15.5), c(1,5.5,10.5, 15.5, Inf) )[rep(1:5, c(7,45,84,104,249)),]

library(logspline)

fit <- oldlogspline(interval=mymat[mymat[,2] < 100,],
    right=mymat[ mymat[,2]>100, 1], lbound=0)
fit2 <- oldlogspline.to.logspline(fit)

hist( mymat[,1]+0.5, breaks=c(0,1,5.5,10.5,15.5,60), main='', xlab='Years')
plot(fit2, add=TRUE, col='blue') survreg survival library(survival)

mymat2 <- mymat
mymat2[ mymat2>100 ] <- NA

fit3 <- survreg( Surv(mymat2[,1], mymat2[,2], ,type='interval2') ~ 1, 
    dist='gaussian', control=survreg.control(maxiter=100) )
curve( dnorm(x, coef(fit3), fit3$scale), from=0, to=60, col='green', add=TRUE) fit4 <- survreg( Surv(mymat2[,1]+.01, mymat2[,2], ,type='interval2') ~ 1,
    dist='weibull', control=survreg.control(maxiter=100) )
curve( dweibull(x, scale=exp(coef(fit4)), shape=1/fit4$scale), 
    from=0, to=60, col='red', add=TRUE) fitdistr MASS library(MASS)
tmpfun <- function(x, size, prob) {
    ifelse(x==0, dnbinom(0,size,prob),
    ifelse(x < 5, pnbinom(5,size,prob)-pnbinom(0,size,prob),
    ifelse(x < 10, pnbinom(10,size,prob)-pnbinom(5,size,prob),
    ifelse(x < 15, pnbinom(15,size,prob)-pnbinom(10,size,prob),
        pnbinom(15,size,prob, lower.tail=FALSE)))))
}

fit5 <- fitdistr( mymat[,1], tmpfun, start=list(size=6, prob=0.28) )
lines(0:60, dnbinom(0:60, fit5$estimate[1], fit5$estimate[2]), 
    type='h', col='orange')
-------------------------------------------------------------------------------------------------------
lwd rect shape polygon bc x = c(bc$x + dx, rev(bc$x - dx), y = c(bc$y + dy, rev(bc$y - dy) points(..., type = "l") lines(...)
-------------------------------------------------------------------------------------------------------
#create a Surv object
    s <- with(lung,Surv(time,status))

    #plot kaplan-meier estimate, per sex
    fKM <- survfit(s ~ sex,data=lung)
    plot(fKM)

    #plot Cox PH survival curves, per sex
    sCox <- coxph(s ~ as.factor(sex),data=lung)
    lines(survfit(sCox,newdata=data.frame(sex=1)),col='green')
    lines(survfit(sCox,newdata=data.frame(sex=2)),col='green') #plot weibull survival curves, per sex,
    sWei <- survreg(s ~ as.factor(sex),dist='weibull',data=lung)

    lines(predict(sWei, newdata=list(sex=1),type="quantile",p=seq(.01,.99,by=.01)),seq(.99,.01,by=-.01),col="red")
    lines(predict(sWei, newdata=list(sex=2),type="quantile",p=seq(.01,.99,by=.01)),seq(.99,.01,by=-.01),col="red")
-------------------------------------------------------------------------------------------------------
rnorm x <- seq(-5,5,length=100)
plot(x, pnorm(1 - 0.5*x), ty='n', lwd=2, bty='n', xlab='x', ylab="Pr(y=1)", 
     xaxs = 'i', ylim=c(0, 1))

params <- processres(npb.par)
sims <- 100000
sim.mat <- matrix(NA, ncol=length(x), nrow=sims)
for (i in 1:sims) {
  alpha <- rnorm(1, params[1, 1], params[1, 3])
  beta <- rnorm(1, params[2, 1], params[2, 3])
  sim.mat[i, ] <- pnorm(alpha - beta*x)
}

CI <- apply(sim.mat, 2, function(x) quantile(x, c(0.05, 0.95)))
polygon(c(x, rev(x)), c(CI[1, ], rev(CI[2, ])), col='gray', border=NA)
lines(x, pnorm(params[1, 1] - params[2, 1]*x), lwd=2)
rug(dat100$x)
box()
-------------------------------------------------------------------------------------------------------
rect par("usr") library(quantmod)
getSymbols("A")
plot( index(A), coredata(Ad(A)), type="n" )
# This example uses calendar years: adapt as needed
dates <- c( 
  ISOdate( year(min(index(A))),     1, 1 ),
  ISOdate( year(max(index(A))) + 1, 1, 1 )
)
dates <- as.Date(dates)
dates <- seq.Date(dates[1], dates[2], by="2 year")
rect( 
  dates, 
  par("usr")[3], 
  as.Date( ISOdate( year(dates) + 1, 1, 1 ) ),
  par("usr")[4], 
  col="grey",
  border=NA
)
lines(index(A), coredata(Ad(A)), lwd=3)
-------------------------------------------------------------------------------------------------------
qplot(year, sales, data=comp, colour=as.factor(company), group= company, geom="path", log="y")
-------------------------------------------------------------------------------------------------------
rect zoo zoo library(zoo)
#random data combined with time series that starts in 2009-01
v <- zooreg(rnorm(37), start = as.yearmon("2009-1"), freq=12)
plot(v, type = "n",xlab="",xaxt="n")
#this will catch some min and max values for y-axis points in rect
u <- par("usr")
#plot green rect - notice that x-coordinates are defined by date points
rect(as.yearmon("2009-6-30"), u[3], as.yearmon("2010-7-1"), u[4], 
        border = 0, col = "lightgreen")
lines(v)
axis(1, floor(time(v)))
#customized x-axis labels based on dates values
axis(1,at=c(2009.4, 2010.5),padj=-2,lty=0,labels=c("start","end"),cex.axis=0.8)
-------------------------------------------------------------------------------------------------------
myhist <- hist(x,prob=FALSE,col="gray",xlim=c(0,100))
    dens <- density(x)
    axis(side=1, at=seq(0,100, 20), labels=seq(0,100,20))
    lines(dens$x,dens$y*(1/sum(myhist$density))*length(x)) 1/sum(myhist$density) density(x)$x sum(density(x)$y) sum(density(x)$y)/(1/diff(density(x)$x)[1]) hist() length(x) xlim xlim ylim type = "n"
-------------------------------------------------------------------------------------------------------
POSIXct as.POSIXct iplot(ts, y) L its(ts, y, group) ilines(ts, y) ts
-------------------------------------------------------------------------------------------------------
# Function to create curly braces
# x, y position where to put the braces
# range is the widht
# position: 1 vertical, 2 horizontal
# direction: 1 left/down, 2 right/up
CurlyBraces <- function(x, y, range, pos = 1, direction = 1 ) {

    a=c(1,2,3,48,50)    # set flexion point for spline
    b=c(0,.2,.28,.7,.8) # set depth for spline flexion point

    curve = spline(a, b, n = 50, method = "natural")$y / 2 

    curve = c(curve,rev(curve))

    a_sequence = rep(x,100)
    b_sequence = seq(y-range/2,y+range/2,length=100)  

    # direction
    if(direction==1)
    a_sequence = a_sequence+curve
    if(direction==2)
    a_sequence = a_sequence-curve

    # pos
    if(pos==1)
    lines(a_sequence,b_sequence) # vertical
    if(pos==2)
    lines(b_sequence,a_sequence) # horizontal

    }

plot(0,0,ylim=c(-10,10),xlim=c(-10,10))
CurlyBraces(2, 0, 10, pos = 1, direction = 1 )
CurlyBraces(2, 0, 5,  pos = 1, direction = 2 )
CurlyBraces(1, 0, 10, pos = 2, direction = 1 )
CurlyBraces(1, 0, 5,  pos = 2, direction = 2 )
-------------------------------------------------------------------------------------------------------
## your data with different labels
dat <- data.frame(cutpoint = c(5, 7, 9),
                  TPR = c(0.56, 0.78, 0.91),
                  FPR = c(0.01, 0.19, 0.58))

## plot version 1    
op <- par(xaxs = "i", yaxs = "i")
plot(TPR ~ FPR, data = dat, xlim = c(0,1), ylim = c(0,1), type = "n")
with(dat, lines(c(0, FPR, 1), c(0, TPR, 1), type = "o", pch = 25, bg = "black"))
text(TPR ~ FPR, data = dat, pos = 3, labels = dat$cutpoint)
abline(0, 1)
par(op) plot() par() with(dat, lines(....)) type = "o" text(....) pos cutpoint abline() 0 1 0 1 op plot(TPR ~ FPR, data = dat, xlim = c(0,1), ylim = c(0,1), type = "n")
with(dat, lines(c(0, FPR, 1), c(0, TPR, 1), type = "o", pch = 25, bg = "black"))
text(TPR ~ FPR, data = dat, pos = 3, labels = dat$cutpoint)
abline(0, 1)
-------------------------------------------------------------------------------------------------------
dev.hold dev.flush plot(NA, xlim=c(0,1), ylim=c(0,1), type="n")
dev.hold()
for(i in 1:1e4) {
  lines( runif(2), runif(2) )
}
dev.flush()
-------------------------------------------------------------------------------------------------------
lines() ylim plot() set.seed(1)
    D1 <- density(rnorm(1000))
    D2 <- density(rnorm(10000))
    D3 <- density(rnorm(100000))
    plot(D1$x,D1$y,type='l',col="red",ylim=c(0,.45))
    lines(D2$x,D2$y,lty=2,col="blue")
    lines(D3$x,D3$y,lty=3,col="green")
-------------------------------------------------------------------------------------------------------
trace = TRUE text() trace pos = 2 set.seed(1)
    plot(1:10,runif(min=0,max=10,10),type='l',ylim=c(0,10),xlim=c(0,10),col=1)
    lines(1:10,runif(min=0,max=10,10),col=2,lty=2)
    lines(1:10,runif(min=0,max=10,10),col=3,lty=2)
    a <- legend(1,10,lty=1:3,col=1:3,legend=c("","",""),bty="n",trace=TRUE)
    text(a$text$x-1,a$text$y,c("line 1","line 2","line 3"),pos=2)
-------------------------------------------------------------------------------------------------------
dat dput() PA character den.PA <- density(dat$PA)
    plot(den.PA)

    for (i in 1:nrow(dat)){
        lineat <- dat$PA[i]
        organism <- as.character(dat$Species)[i]
        lineheight <- den.PA$y[which.min(abs(den.PA$x - lineat))]
        print (organism)
        if (organism == 'EQUUSCABALLUS'){
            col <- 'red'
        }
        if (organism == 'HOMOSAPIENS'){
            col <- 'blue'
        }
        if (organism == 'MUSMUSCULUS'){
            col <- 'green'
        }
        if (organism == 'BOSTAURUS'){
            col <- 'purple'
        }
        segments(lineat,0,lineat,lineheight,col=col)
    } lines() segments() = <-
-------------------------------------------------------------------------------------------------------
# Assuming files are open, for brevity

counts = {}
for line in file_1.readlines():
    number, count = line.split()
    counts[int(number)] = int(count)

results = []
for line in file_2.readlines():
    min, max = line.split()
    min, max = int(min), int(max)

    max += 1 # If your ranges are inclusive

    count = sum([counts.get(number,0) for number in range(min, max)])
    results += line + str(count)

 output_file.write('\n'.join(results))
-------------------------------------------------------------------------------------------------------
lines segments f <- function(x) {
  y <- Vr_Vmed(x,n,Tr)
  lines(c(x,x,0),c(0,y,y))
}
f(2) Vr_med
-------------------------------------------------------------------------------------------------------
plot(xdata,ydata)
lines(smooth.spline(xdata,ydata, df=10), col = "red") ?loess.smooth apropos("smooth")
-------------------------------------------------------------------------------------------------------
?survfit   # to get a working example since you did not provide one
  lsurv2 <- survfit(Surv(time, status) ~ x, aml, type='fleming')
  plot(lsurv2, lty=2:3, xmax=300)  # drats, no effect of xmax
  str(lsurv2)      # so see the structure of the survfit object
  lsurv2$time[21] <- 300         #add a time value
  lsurv2$n.censor[21] <- 1       # mark as censoring time
  lsurv2$strata[2] <- 11         # add to count of group 2

  plot(lsurv2, lty=2:3, xmax=300)  # horizontal line to 300 for group 2 plot(surv, mark.time=F, fun='event', xlim=c(0, 54))
  for (i in 1:length(surv$strata)) { #number of curves
     temp <- surv[i]
     lines(c(max(temp$time), 54), 1- rep(min(temp$surv),2))
     }
-------------------------------------------------------------------------------------------------------
lines() ?lines y NA d <- data.frame(x=1:20, 
              y=c(0,NA,NA,NA,NA,NA,0,NA,NA,NA,NA,2,NA,NA,NA,NA,NA,NA,NA,NA))

plot(y ~ x, data = d, type = "b", subset = !is.na(y))
-------------------------------------------------------------------------------------------------------
densify <- function(xy,n=5){
  ## densify a 2-col matrix
  cbind(dens(xy[,1],n=n),dens(xy[,2],n=n))
}

dens <- function(x,n=5){
  ## densify a vector
  out = rep(NA,1+(length(x)-1)*(n+1))
  ss = seq(1,length(out),by=(n+1))
  out[ss]=x
  for(s in 1:(length(x)-1)){
    out[(1+ss[s]):(ss[s+1]-1)]=seq(x[s],x[s+1],len=(n+2))[-c(1,n+2)]
  }
  out
} simplecentre <- function(xyP,dense){
require(deldir)
require(splancs)
require(igraph)
require(rgeos)

### optionally add extra points
if(!missing(dense)){
  xy = densify(xyP,dense)
} else {
  xy = xyP
}

### compute triangulation
d=deldir(xy[,1],xy[,2])

### find midpoints of triangle sides
mids=cbind((d$delsgs[,'x1']+d$delsgs[,'x2'])/2,
  (d$delsgs[,'y1']+d$delsgs[,'y2'])/2)

### get points that are inside the polygon 
sr = SpatialPolygons(list(Polygons(list(Polygon(xyP)),ID=1)))
ins = over(SpatialPoints(mids),sr)

### select the points
pts = mids[!is.na(ins),]

dPoly = gDistance(as(sr,"SpatialLines"),SpatialPoints(pts),byid=TRUE)
pts = pts[dPoly > max(dPoly/1.5),]

### now build a minimum spanning tree weighted on the distance
G = graph.adjacency(as.matrix(dist(pts)),weighted=TRUE,mode="upper")
T = minimum.spanning.tree(G,weighted=TRUE)

### get a diameter
path = get.diameter(T)

if(length(path)!=vcount(T)){
  stop("Path not linear - try increasing dens parameter")
}

### path should be the sequence of points in order
list(pts=pts[path+1,],tree=T)

} s = capture()
 p = gBuffer(s,width=0.2)
 plot(p,col="#cdeaff")
 plot(s,add=TRUE,lwd=3,col="red")
 scp = simplecentre(onering(p))
 lines(scp$pts,col="white") onering=function(p){p@polygons[[1]]@Polygons[[1]]@coords} capture = function(){p=locator(type="l")
            SpatialLines(list(Lines(list(Line(cbind(p$x,p$y))),ID=1)))}
-------------------------------------------------------------------------------------------------------
lines(ts(test2, start=2004.5, freq=frequency(test2)) ) start end frequency end length/frequency -1 start
-------------------------------------------------------------------------------------------------------
par()$usr lines( par()$usr[1:2], par()$usr[3:4] )
-------------------------------------------------------------------------------------------------------
lines type='l' plot with(dat,lines(...)) # can also do the col='black',lty=1 in here.
plot(tp ~ fp, data = dat, xlim = c(0,fp_max),ylim = c(0,tp_max), type = "l") fp_max tp_max (fp_max,tp_max) (0,0) tp fp dat (0,0) dat$tp dat$fp plot(tp ~ fp, ..., type='n')
# sort dat$tp
obj <- sort(dat$fp,index.return=T)
# use obj$x as tp and obj$ix to sort dat$fp prior to plotting
with(dat, 
     lines(c(0, obj$x, fp_max), c(0, tp[obj$ix], tp_max),  
           lty=1, type = "l",  col = "black"))
-------------------------------------------------------------------------------------------------------
PLOT <- FALSE
pdf('anna.pdf', paper='a4')
for (chr in paste('chr',c(seq(1,22),'X','Y'),sep='')){
    if(!PLOT){
      plot(exp,control,xlim=c(0,400),ylim=c(0,400),   
       pch=20,col='black',main='Tiles',xlab='exp',ylab 'Control')
       PLOT <- TRUE
    } else {
       points(exp,control, ...)
    }
}
dev.off()
-------------------------------------------------------------------------------------------------------
temperature <- function(temp1,temp2,temp3)
{ t1 <- deparse(substitute(temp1))
  t2 <- deparse(substitute(temp2))
  t3 <- deparse(substitute(temp3)) 
    dataPlot1 <- data.frame(temp1,temp2,temp3)
    matplot(dataPlot1,axes=T,frame=T,type="l",
            xlab="time (hour)",ylab="temperature(C)",
            main=names(dataPlot1))
    lines(dataPlot1[1],lty=1,col="blue")
    lines(dataPlot1[2],lty=2,col="red")
    lines(dataPlot1[3],lty=2,col="forestgreen")  
    legend("topright", c(t1,t2,t3), lty=c(1,2,2),
            col=c("blue","red","forestgreen"))
-------------------------------------------------------------------------------------------------------
fig # Sample data
n <- 100
k <- 6
d <- matrix(rnorm(k*n),nc=k)
d[,2] <- d[,1]  # To help check the results
colnames(d) <- LETTERS[1:k]
x <- apply(d,2,cumsum)
r <- hclust(dist(t(d)))
# Plot
op <- par(mar=c(0,0,0,0),oma=c(0,2,0,0))
plot(NA,ylim=c(.5,k+.5), xlim=c(0,4),axes=FALSE)
# Dendrogram. See ?hclust for details.
xc <- yc <- rep(NA,k)
o <- 1:k
o[r$order] <- 1:k
for(i in 1:(k-1)) {
  a <- r$merge[i,1]
  x1 <- if( a<0 ) o[-a] else xc[a]
  y1 <- if( a<0 ) 0 else yc[a]
  b <- r$merge[i,2]
  x2 <- if( b<0 ) o[-b] else xc[b]
  y2 <- if( b<0 ) 0 else yc[b]
  lines( 
    3+c(y1,i,i,y2)/k,
    c(x1,x1,x2,x2),
    lwd=k-i
  )
  xc[i] <- (x1+x2)/2
  yc[i] <- i
}
# Time series
axis(2,1:k,colnames(d)[r$order],las=1)
u <- par()$usr
for(i in 1:k) {
  f <- c(0,3,i-.5,i+.5)
  f <- c( 
    (f[1]-u[1])/(u[2]-u[1]), 
    (f[2]-u[1])/(u[2]-u[1]), 
    (f[3]-u[3])/(u[4]-u[3]), 
    (f[4]-u[3])/(u[4]-u[3])
  )
  par(new=TRUE,fig=f)
  plot(x[,r$order[i]],axes=FALSE,xlab="",ylab="",main="",type="l",col="navy",lwd=2)
  box()
}
par(op) layout
-------------------------------------------------------------------------------------------------------
gDistance rgeos SpatialLines/DataFrame SpatialPoints/DataFrame require(rgeos)
## untested code
shortest.dists <- numeric(nrow(sp.pts))
for (i in seq_len(nrow(sp.pts)) {
    shortest.dists[i] <- gDistance(sp.pts[i,], sp.lns)
} sp.pts sp.lns sp.pts sp.lns gDistance spDistsN1 sp longlat = TRUE library(maptools)

## simple global data set, which we coerce to Lines
data(wrld_simpl)

wrld_lines <- as(wrld_simpl, "SpatialLinesDataFrame")

## get every coordinate as a simple matrix (scary but quick)
wrld_coords <- do.call("rbind", lapply(wrld_lines@lines, function(x1) do.call("rbind", lapply(x1@Lines, function(x2) x2@coords[-nrow(x2@coords), ])))) ## no out of bounds clicking . . .
par(mar = c(0, 0, 0, 0), xaxs = "i", yaxs = "i") 

plot(wrld_lines, asp = "")

n <- 5

for (i in seq_len(n)) {
xy <- matrix(unlist(locator(1)), ncol = 2)
    all.dists <- spDistsN1(wrld_coords, xy, longlat = TRUE)
    min.index <- which.min(all.dists)
    points(xy, pch = "X")
lines(rbind(xy, wrld_coords[min.index, , drop = FALSE]), col = "green", lwd = 2)
}
-------------------------------------------------------------------------------------------------------
# make a data series
my.stat <- rnorm(100,sd=2.5)
# get its standard dev:
my.sd <- sd(my.stat)
# convert series to distance in sd:
my.lj.stat <- (my.stat - mean(my.stat)) / my.sd

plot(1:100, my.lj.stat, type = "o", pch = 19, col = "blue", ylab = "sd", xlab = "observation",
    main = paste("mean value of", round(mean(my.stat),3),"\nstandard deviation of",round(my.sd,3)))

# a low tech L-J chart function:
LJchart <- function(series, ...){
    xbar        <- mean(series)
    se          <- sd(series)
    conv.series <- (my.stat - xbar) / se

    plot(1:length(series), conv.series, type = "o", pch = 19, col = "blue", ylab = "sd", xlab = "observation",
        main = paste("mean value of", round(xbar,3), "\nstandard deviation of", round(se,3)), ...)
}

LJchart(rnorm(100,sd=2.5)) ... ... LJchart <- function(series, ...){
    xbar        <- mean(series)
    se          <- sd(series)
    conv.series <- (my.stat - xbar) / se

    plot(1:length(series), conv.series, type = "n", ...)
    rect(0, -1, length(series)+1, 1, col = gray(.9), border = NA)
    lines(1:length(series), conv.series, ...)
    points(1:length(series), conv.series, ...)
    if (! "main" %in% names(list(...))) {
        title(paste("mean value of", round(xbar,3), "\nstandard deviation of", round(se,3)))
    }
}

LJchart(rnorm(100,sd=2.5), xlab = "observations", ylab = "sd", col = "blue", pch = 19)
-------------------------------------------------------------------------------------------------------
sexi <- as.numeric(data.frame$sex)-1      #recode a factor as 0/1 numeric

beta <- numeric(60)              #Set up vector to Store the betas
deviance <- numeric(60)          #Set up vector to Store the deviances

for (i in 1:60){

  beta[i] <- 0.5 - (0.01*i)  
  #A vector of values either side of the fitted MLE (in this case -0.22)

  mod <- update(model,
                   .~. - sex             #Get rid of the fitted variable
                   + offset(   I(sexi*beta[i])   )   #Replace with offset term.
                )
  deviance[i] <- mod$deviance                        #Store i'th deviance
}

best <- which.min(deviance)                   
#Find the index of best deviance. Should be the fitted value from the model

deviance0 <- deviance - deviance[best]         
#Scale deviance to zero by subtracting best deviance

betahat <- beta[best]    #Store best beta. Should be the fitted value.
stderror <- 0.12187      #Store the std error of sex, found in summary(model)

quadratic <- ((beta-betahat)^2)*(1/(stderror^2))  
#Quadratic reference function to check quadratic assumption against

x11()                                    
plot(beta,deviance0,type="l",xlab="Beta(sex)",ylim=c(0,4))    
lines(beta,quadratic,lty=2,col=3)           #Add quadratic reference line
abline(3.84,0,lty=3)                #Add line at Deviance = 3.84
-------------------------------------------------------------------------------------------------------
scan() readlines()
-------------------------------------------------------------------------------------------------------
# Data: remove Group
dat <- data.frame(Domain, Kingdom, Phylum, Class, Order, Species)

# Start a new plot
par(mar=c(0,0,0,0))
plot(NA, xlim=c(0,ncol(dat)+1), ylim=c(0,nrow(dat)+1), 
  type="n", axes=FALSE, xlab="", ylab="", main="")

# Compute the position of each node and find all the edges to draw
positions <- NULL
links <- NULL
for(k in 1:ncol(dat)) {
  y <- tapply(1:nrow(dat), dat[,k], mean)
  y <- y[ names(y) != "NA" ]
  positions <- rbind( positions, data.frame(
    name = names(y),
    x = k,
    y = y
  ))
}
links <- apply( dat, 1, function(u) { 
  u <- u[ !is.na(u) & u != "NA" ]
  cbind(u[-length(u)],u[-1]) 
} )
links <- do.call(rbind, links)
rownames(links) <- NULL
links <- unique(links[ order(links[,1], links[,2]), ])

# Draw the edges
for(i in 1:nrow(links)) {
  from <- positions[links[i,1],]
  to   <- positions[links[i,2],]
  lines( c(from$x, from$x, to$x), c(from$y, to$y, to$y) )
}

# Add the text
text(positions$x, positions$y, label=positions$name)
-------------------------------------------------------------------------------------------------------
?nls #This is just our data frame
DNase1 <- subset(DNase, Run == 1)
DNase1$lconc <- log(DNase1$conc)
#Fit the model
fm1DNase1 <- nls(density ~ SSlogis(lconc, Asym, xmid, scal), DNase1)

#Plot the original points
# first argument is the x values, second is the y values
plot(DNase1$lconc,DNase1$density)

#This adds to the already created plot a line
# once again, first argument is x values, second is y values
lines(DNase1$lconc,predict(fm1DNase1)) predict nls y yFitted <- predict(fm1DNase1) yFitted lines r <- range(DNase1$lconc)
xNew <- seq(r[1],r[2],length.out = 200)
yNew <- predict(fm1DNase1,list(lconc = xNew))

plot(DNase1$lconc,DNase1$density)
lines(xNew,yNew)
-------------------------------------------------------------------------------------------------------
grconvertY() viewport grconvertY() ## Create three example plots
par(mfrow=c(1,3))
barplot(VADeaths, border = "dark blue") 
barplot(VADeaths, border = "yellow") 
barplot(VADeaths, border = "green") 

## From third plot, get the "normalized device coordinates" of 
## a point at a height of 50 on the y-axis.
(Y <- grconvertY(50, "user", "ndc"))
# [1] 0.314248

## Add the horizontal line using grid
library(grid)
pushViewport(viewport())
grid.lines(x = c(0,1), y = Y, gp = gpar(col = "red"))
popViewport() library(grid)
library(gridBase)
par(mfrow=c(1,3))

# barplot #1
barplot(VADeaths, border = "dark blue") 
X1 <- grconvertX(0, "user", "ndc")
# barplot #2
barplot(VADeaths, border = "yellow") 
# barplot #3
m <- barplot(VADeaths, border = "green") 
X2 <- grconvertX(tail(m, 1) + 0.5, "user", "ndc") # default width of bars = 1
Y <- grconvertY(50, "user", "ndc")

## Horizontal line
pushViewport(viewport())
grid.lines(x = c(X1, X2), y = Y, gp = gpar(col = "red"))
popViewport() grid.move.to() grid.line.to() library(grid)
library(gridBase)
par(mfrow=c(1,3))

barplot(VADeaths); vps1 <- do.call(vpStack, baseViewports())
barplot(VADeaths) 
barplot(VADeaths); vps3 <- do.call(vpStack, baseViewports())

pushViewport(vps1)
Y <- convertY(unit(50,"native"), "npc")
popViewport(3)

grid.move.to(x = unit(0, "npc"), y = Y, vp = vps1)
grid.line.to(x = unit(1, "npc"), y = Y, vp = vps3, 
             gp = gpar(col = "red"))
-------------------------------------------------------------------------------------------------------
lines(x, smooth(y)) ?smooth lines(supsmu(x, y))
-------------------------------------------------------------------------------------------------------
x <- seq(0.3,0.6,by =0.001)
plot(x, dnorm(x, 0.433697, 0.018629), type = 'l') rug(b1) set.seed(0)
b <- rnorm(15)
b1 <- ((b - mean(b))/sd(b)  * 0.018629) + 0.433697
rug(b1) lines(density(b1), col = 'red')
-------------------------------------------------------------------------------------------------------
lines i <- order(bf.red$chestc)
lines(bf.red$chestc[i], lo.pred$fit[i])
...
-------------------------------------------------------------------------------------------------------
abline() predict.lm() lines() f <- lm(y~x)
X <- c(1, 10)
Y <- predict(f, newdata=data.frame(x=X))

plot(x,y)
lines(x=X, y=Y)
-------------------------------------------------------------------------------------------------------
x<-1:10
y<-1:10
plot(x,y)
new <- data.frame(x = seq(1, 5, 0.5))
lines(new$x, predict(lm(y~x), new))
-------------------------------------------------------------------------------------------------------
plot(temp2, type="l", col="green")
lines(temp1, col="red")
-------------------------------------------------------------------------------------------------------
?plot col lines points ?par new par(new=TRUE) # plot temp1 y vs x in blue
plot(y~x, temp1, col='blue')

# draw the next plot on the same plot
par(new=TRUE)

# plot temp2 y vs x in red, on the SAME plot (new=TRUE)
plot(y~x, temp2, col='red') lines points par(new=TRUE) plot lines(y~x,temp2,...)
-------------------------------------------------------------------------------------------------------
value<-rnorm(100,1000,200) ##create list of numbers, "scan()" may be used for real observations
nmbrs<-length(value) ## determine the length of vector
obrv<-1:length(value) ## create list of observations
par(xpd=FALSE)
sd1<-sd(value[1:20])*1 ## 1 standart deviation
sd2<-sd(value[1:20])*2 ## 2 standart deviations
sd3<-sd(value[1:20])*3 ## 3 standart deviations
usd1<-mean(value)+sd1 ## upper limit
lsd1<-mean(value)-sd1 ## lower limit
lsd2<-mean(value)-sd2 ## lower limit
usd2<-mean(value)+sd2 ## upper limit
usd3<-mean(value)+sd3 ## upper limit
lsd3<-mean(value)-sd3 ## lower limit

## ploting the grid
plot(obrv,value,type="n",xlab="Observations",ylab="Value",ylim=c(lsd3-sd1,usd3+sd1))
abline(h=mean(value),col=2,lty=1)
abline(h=usd1,col=3,lty=3)
abline(h=lsd1,col=3,lty=3)
abline(h=usd2,col=4,lty=2)
abline(h=lsd2,col=4,lty=2)
abline(h=usd3,col=6,lty=1)
abline(h=lsd3,col=6,lty=1)


## 20 first values for L-G chart for QC limits
for (i in 1:20) 
{
points(obrv[i],value[i],col="black")
}
lines(obrv[1:20],value[1:20],col="red")


## if over mean - "red", under mean - "blue"
for (i in 21:nmbrs) 
{
points(obrv[i],value[i],col="blue")
segments(obrv[i-1],value[i-1],obrv[i],value[i],col="blue")
}

# 1s points - blue; 2s points - red
#if (value[i]<usd1 || value[i]>lsd1) points(obrv[i],value[i],col="blue")
#if (value[i]>usd1 || value[i]<lsd1) points(obrv[i],value[i],col="red")

#12s violation rule
#if (value[i]>usd1 || value[i]<usd1) text(30, usd3, "12s violation")
#if (value[i]>usd1 || value[i]<usd1) text(30, usd3, "12s violation")
#segments(obrv[i-1],value[i-1],obrv[i],value[i],col="blue")
#if (value[i]>usd1) break
#}


#legend placement - might be omited
#legend(1,min(value)-sd1*0.2,bg=8,c("mean","sd1","sd2","sd3"),lty=c(1,3,2,1),lwd=c(2.5,2.5,2.5,2.5),col=c(2,3,4,6),cex=0.8)
-------------------------------------------------------------------------------------------------------
lines density dat <- read.table(text = "info mean sd
info1 20.84 4.56
info2 29.18 5.41
info3 38.90 6.22
", header = TRUE)

densities <- apply(dat[, -1], 1, function(x) rnorm(n = 1000, mean = x[1], sd = x[2]))
colnames(densities) <- dat$info

plot(0, type = "n", xlim = c(min(densities), max(densities)), ylim = c(0, .2))
for (d in 1:ncol(densities)){
  lines(density(densities[, d]), lty = d)
}
legend("topright", legend=colnames(densities), lty=1:ncol(densities)) library(reshape2)
library(ggplot2)
#Put into long format
densities.m <- melt(densities)
#Plot
ggplot(densities.m, aes(value, linetype = Var2)) + geom_density()
-------------------------------------------------------------------------------------------------------
dd = data.frame(School_ID = c("A", "B", "C", "A", "B"),
  Year = c(1998, 1998, 1999, 2000, 2005),
  Value = c(5, 10, 15, 7, 15)) plot(dd$Year[dd$School_ID=="A"], dd$Value[dd$School_ID=="A"], type="b",
     xlim=range(dd$Year), ylim=range(dd$Value)) lines(dd$Year[dd$School_ID=="B"], dd$Value[dd$School_ID=="B"], col=2, type="b")
lines(dd$Year[dd$School_ID=="C"], dd$Value[dd$School_ID=="C"], col=3, type="b") type="b" require(ggplot2)
##The values Year, Value, School_ID are
##inherited by the geoms
ggplot(dd, aes(Year, Value,colour=School_ID)) + 
    geom_line() + 
    geom_point()
-------------------------------------------------------------------------------------------------------
D <- structure(list(hours = c(63.06666647, 63.9999998, 64.93333313, 
65.86666646, 66.79999979, 67.73333312, 68.66666645, 69.59999978, 
70.53333311, 71.46666644, 72.39999977), value = c(22657L, 21535L, 
20797L, 20687L, 20129L, 19671L, 19066L, 19534L, 19994L, 19575L, 
21466L)), .Names = c("hours", "value"), row.names = 60:70, class = "data.frame")

sm <- smooth.spline(D$hours, D$value, spar = 0.5) spar plot(D$hours, D$value)
lines(sm, col = "red") sm$y
[1] 22421.54 21682.93 21023.05 20469.70 19998.72 19634.10 19448.09 19506.52 19783.97
[10] 20251.24 20891.14
-------------------------------------------------------------------------------------------------------
V2 / sum(V2) dat <- data.frame(V1 = 1:6, V2 = c(11613, 6517, 2442, 687, 159, 29)) > with(dat, V2 / sum(V2))
[1] 0.541474332 0.303865342 0.113862079 0.032032452 0.007413624 0.001352170 dat2 <- unlist(apply(dat, 1, function(x) rep(x[1], x[2]))) hist() dens <- hist(dat2, breaks = c(0:6), plot = FALSE) > str(dens)
List of 7
 $ breaks     : int [1:7] 0 1 2 3 4 5 6
 $ counts     : int [1:6] 11613 6517 2442 687 159 29
 $ intensities: num [1:6] 0.54147 0.30387 0.11386 0.03203 0.00741 ...
 $ density    : num [1:6] 0.54147 0.30387 0.11386 0.03203 0.00741 ...
     $ mids       : num [1:6] 0.5 1.5 2.5 3.5 4.5 5.5
 $ xname      : chr "dat2"
 $ equidist   : logi TRUE
 - attr(*, "class")= chr "histogram" density > dens$density
[1] 0.541474332 0.303865342 0.113862079 0.032032452 0.007413624 0.001352170 dat <- transform(dat, density = V2 / sum(V2))
plot(density ~ V1, data = dat, type = "n")
lines(density ~ V1, data = dat, col = "red") plot(density ~ V1, data = dat, type = "n", ylim = c(0,1))
lines(density ~ V1, data = dat, col = "red")
-------------------------------------------------------------------------------------------------------
read.csv read.table quartz=(title...) quartz(title=...) plot() attach lines curve abline glm lm() family=binomial family=gaussian dat <- read.csv("/Path/PopulationGrowth.csv")
with(dat,plot(Year,CentralOakland,xlab="Year",ylab="Population",
  main="Central Oakland Population vs. Year"))
g <- lm(CentralOakland~Year,data=dat)
abline(g)
## OR
yearvec <- seq(min(Year),max(Year),length=51)
lines(yearvec,predict(g,newdata=data.frame(Year=yearvec),type="response")) ## from http://en.wikipedia.org/wiki/Oakland,_California
dat <- structure(list(year = c(1860L, 1870L, 1880L, 1890L, 1900L, 1910L, 
1920L, 1930L, 1940L, 1950L, 1960L, 1970L, 1980L, 1990L, 2000L, 
2010L), pop = c(1543L, 10500L, 34555L, 48682L, 66960L, 150174L, 
216261L, 284063L, 302163L, 384575L, 367548L, 361561L, 339337L, 
372242L, 399484L, 390724L)), .Names = c("year", "pop"), 
  class = "data.frame", row.names = c(NA,-16L)) ## SSlogis() is a "self-starting" logistic
m1 <- nls(pop~SSlogis(year,asym,xmid,scal),
          data=dat) par(las=1,bty="l",mar=c(5,6,2,2)+0.1)  ## graphics tweaks
with(dat,plot(pop~year,ylab=""))
## add y-label separately 
mtext("population",side=2,las=0,line=4)
yearvec <- 1860:2010
lines(yearvec,predict(m1,newdata=data.frame(year=yearvec)))
-------------------------------------------------------------------------------------------------------
x <- seq(from=as.Date("2000-01-01"), to=as.Date("2004-12-31"), by="day")
y <- sin(seq(from=0, to=2*pi*5,length.out=length(x)))+rnorm(length(x))
yyyymm <- paste(format(as.POSIXlt(x), format="%Y-%m"), "01", sep="-")
MEAN <- tapply(y, yyyymm, mean)
MAX <- tapply(y, yyyymm, max)
MIN <- tapply(y, yyyymm, min)
#plots
x11()
par(mfcol=c(1,2))
plot(x,y, ylim=range(MEAN, MAX, MIN), ylab="", xlab="")
plot(as.POSIXlt(names(MEAN)), MEAN, t="l", ylim=range(MEAN, MAX, MIN), ylab="", xlab="")
lines(as.POSIXlt(names(MEAN)), MAX, lty=2)
lines(as.POSIXlt(names(MEAN)), MIN, lty=2)
-------------------------------------------------------------------------------------------------------
rf = randomForest(x=predictors, y=response,mtry = 2,nodesize = 1)
plot(x1, response)
lines(x1, predict(rf, predictors), col="red") nodesize mtry mtry
-------------------------------------------------------------------------------------------------------
dat <- read.table("gnlsdat.txt",header=TRUE)
plot(SF~Site_Code,data=x)

library(nlme)
g0 <- gnls(SF ~ a * Site_Code^b, data = dat,
           weights = varPower(form = ~Site_Code),
           start=list(a=30,b=-0.5)) Generalized nonlinear least squares fit
  Model: SF ~ a * Site_Code^b 
  Data: dat 
  Log-likelihood: -130.3289

Coefficients:
        a         b 
19.319493 -1.152149 

Variance function:
 Structure: Power of variance covariate
 Formula: ~Site_Code 
 Parameter estimates:
    power 
-0.885528 
Degrees of freedom: 33 total; 31 residual
Residual standard error: 28.10023 plot(SF~Site_Code,data=x)
pframe <- data.frame(Site_Code=seq(1,5,length=41))
lines(pframe$Site_Code,predict(g0,newdata=pframe))
-------------------------------------------------------------------------------------------------------
grconvertX grconvertY gridBase grconvertX library(ggplot2)
library(grid)

test= data.frame(   x = c(1,2,3),   y = c(12,10,3),   n = c(75,76,73)   )  

qplot(x=x, y=y, data=test)+geom_line()+  opts(plot.margin = unit(c(1,3,8,1), "lines"))  

current.vpTree()
downViewport('panel-3-4')
pushViewport(dataViewport( test$x, clip='off',yscale=c(0,1)))

for (i in 1:nrow(test))  {
    grid.text(x=i, y = -0.2, default.units='native',
        label=paste("GRID.text at\nuser.x=", i, "\n"   ) )
        grid.lines(x=c(i, i), y = c(-0.1, 0), default.units='native' )
 }
-------------------------------------------------------------------------------------------------------
library (ggplot2)
library(grid)
library(gridBase)

test= data.frame(
  group=c(rep(1,6), rep(2,6)),
  subgroup=c( 1,1,1,2,2,2,1,1,1,2,2,2),
  category=c( rep(1:3, 4)),
  count=c( 10,80,10,5,90,5,  10,80,10,5,90,5   )
  )

qplot(subgroup, count, 
           data=test, geom="bar",  stat="identity",
           fill =category,  
           facets =  .~ group,  width=0.9)+
             opts(legend.position="none",  plot.margin = unit(c(0,9,2,0), "lines"))

current.vpTree()
downViewport('panel-4-6')
pushViewport(dataViewport( yscale=c(0,100), clip='off',xscale=c(0,1)))

grid.text(x=1.21,  y = 90, default.units='native' ,label="Text 1")
grid.text(x=1.21,  y = 55, default.units='native' ,label="Text 2")
grid.text(x=1.21,  y = 10, default.units='native' ,label="Text 3")

grid.lines(x=c(1.02,1.12), y = c(95,95), default.units='native' )
grid.lines(x=c(1.02,1.12), y = c(85, 85), default.units='native' )
grid.lines(x=c(1.12,1.12), y = c(85, 95), default.units='native' )

grid.lines(x=c(1.02,1.12), y = c(80, 80), default.units='native' )
grid.lines(x=c(1.02,1.12), y = c(20, 20), default.units='native' )
grid.lines(x=c(1.12,1.12), y = c(80, 20), default.units='native' )

grid.lines(x=c(1.02,1.12), y = c(5, 5), default.units='native' )
grid.lines(x=c(1.02,1.12), y = c(15, 15), default.units='native' )
grid.lines(x=c(1.12,1.12), y = c(5, 15), default.units='native' )
-------------------------------------------------------------------------------------------------------
A<-round(rnorm(50,100,5))
B<-round(rnorm(50,10,5))
C<-round(rnorm(50,50,5))
t<-round(seq(1400,1500,length.out=50))
dat<-cbind(A,B,C) plot(t,A,ylim=c(0,150),type="n") for(i in 1:ncol(dat){
ts=lines(t,dat[,i])
}
-------------------------------------------------------------------------------------------------------
library(xts)   
x1 <- xts(rnorm(10), as.Date("2012-01-01") + 0:9)   
x2 <- xts(rnorm(10), as.Date("2012-01-04") + 0:9)   

dz <- merge(x1=x1, x2=x2); dz$v1=4:16; dz$v2=rnorm(13)    
 # keeps it a zoo object rather than a data.frame

with(dz, plot( x1, type="l", xlab="", ylab="Test", main="Not using row.names()\nStick with zoo" ) )
lines( dz$x2, col="blue")    
lines( dz$v2, col="green")
-------------------------------------------------------------------------------------------------------
barplot(rbind(dens_k0, dens_k1, dens_k2, dens_k3, dens_k4, dens_k5), xlim=c(0,max(x)), ylim=c(0,max(emp_dens)), space=0.1, lwd=5, xlab="Value of X", ylab="Densities", font.main=1)
lines(emp_dens,lty=1,col="red") barplot(rbind(dens_k0, dens_k1, dens_k2, dens_k3, dens_k4, dens_k5, 0), 
       col = c(grey(exp((0:5)/5) / exp(1)), 'red'), xlim=c(0,max(x)), ylim=c(0,max(emp_dens)), space=0.1, lwd=5, xlab="Value of X", ylab="Densities", font.main=1, 
       legend.text = c('k0', 'k1', 'k2', 'k3', 'k4', 'k5', 'dens curve'))
-------------------------------------------------------------------------------------------------------
dens_kall<-rbind(dens_k0,dens_k1,dens_k2,dens_k3,dens_k4,dens_k5)
ltext<-c("K0","K1","K2","K3","K4","K5")
colnames(dens_kall)<-0:12
barplot(height=dens_kall,xlim=c(0,max(x)),ylim=c(0,max(emp_dens)),,space=0.1,lwd=5,xlab="Value of X",ylab="Densities",font.main=1
        ,legend.text =ltext,
        args.legend = list(x = "topright")
        );
lines(dat_dens,lty=1,col="red");
-------------------------------------------------------------------------------------------------------
plot graphics::arrow arrows(0,1,0,0) 
lines(c(1,1),c(-.5,.5)) 
arrows(1,2,.5,.5)
-------------------------------------------------------------------------------------------------------
TRUE FALSE . require(ggplot2)
ggplot(dat, aes(FALSE., TRUE., colour = as.factor(d), group = as.factor(d))) + 
  geom_line() colnames(dat)[2:3] <- c("T", "F")

dis <- unique(dat$d)

plot(NA, xlim = c(0, max(dat$F)), ylim = c(0, max(dat$T)))
for (i in seq_along(dis)){
  subdat <- subset(dat, d == dis[i])
  with(subdat, lines(F,T, col = linecols[i]))
}
legend("bottomright", legend=dis, fill=linecols)
-------------------------------------------------------------------------------------------------------
dat plot(1:max(dat$false), xlim = c(0,611),ylim =c(19000,28251), type="n")

apply(
rbind(unique(dat$d),1:2),
#the 1:2 here are your chosen colours
2,
function(x) lines(dat$false[dat$d==x[1]],dat$true[dat$d==x[1]],col=x[2])
)
-------------------------------------------------------------------------------------------------------
library(rgdal)
library(raster)

# define extent of map area
mapExtent <- rbind(c(0, 62), c(5, 45))

# BNG is British National Grid    
newProj <- CRS("+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.999601271625 
           +x_0=400000 +y_0=-100000 +ellps=airy +units=m +no_defs") 

mapExtentPr <- spTransform(SpatialPoints(mapExtent, 
                  proj4string=CRS("+proj=longlat")),
                  newProj)

# provide a valid 3 letter ISO country code
# obtain a list with: getData("ISO3")
uk0 <- getData('GADM', country="GBR", level=0) # UK
uk1 <- getData('GADM', country="GBR", level=1) # UK countries
uk2 <- getData('GADM', country="GBR", level=2) # UK counties

# United Kingdom projection
uk1Pr      <- spTransform(uk1, newProj)

# latitude-longitude grid projection
grd.LL     <- gridlines(uk1, ndiscr=100)
lat.longPR <- spTransform(grd.LL, newProj)

# latitude-longitude text projection
grdtxt_LL  <- gridat(uk1)
grdtxtPR   <- spTransform(grdtxt_LL, newProj)

# plot the map, lat-long grid and grid labels
plot(mapExtentPr, pch=NA)
plot(uk1Pr, border="white", col="lightgrey", add=TRUE)
plot(lat.longPR, col="black", add=TRUE)
text(coordinates(grdtxtPR),
   labels=parse(text=as.character(grdtxtPR$labels)))
-------------------------------------------------------------------------------------------------------
plot(tst_error, type='l', ylim=range( c(tst_error, tr_error) ) )
 lines(tr_error, type='l', col='red')
-------------------------------------------------------------------------------------------------------
"AC","Acrelândia","TV","Canal 18","AINDA NÃO OUTORGADO"
"AC","Acrelândia","RTV","Canal 9","RADIO TV DO AMAZONAS LTDA"
"AC","Acrelândia","RTV","Canal 10","RADIO TV DO AMAZONAS LTDA(REDENCAO)"
"AC","Acrelândia","TVD","Canal 15","RADIO TV DO AMAZONAS LTDA"
"AC","Acrelândia","TVD","Canal 15","AINDA NÃO OUTORGADO(REDENÇÃO)"
"AC","Acrelândia","FM","88,5 MHz","RADIO E TV MAIRA LTDA"
"AC","Assis Brasil","TV","Canal 34","AINDA NÃO OUTORGADO"
"AC","Assis Brasil","RTV","Canal 6","AMAZONIA CABO LTDA"
"AC","Assis Brasil","RTV","Canal 10","RADIO TV DO AMAZONAS LTDA"
"AC","Assis Brasil","RTV","Canal 13","AINDA NÃO OUTORGADO"
"AC","Assis Brasil","RTV","Canal 45","FUNDACAO JOAO PAULO II" #-*- coding: utf-8 -*-

import re
import csv

# CREATE DATA STRUCTURE TO SIMULATE READING A TEXT FILE

data = u'''AC-Acrelândia
TV    Canal 18    AINDA NÃO OUTORGADO
RTV  Canal 9    RADIO TV DO AMAZONAS LTDA
RTV  Canal 10    RADIO TV DO AMAZONAS LTDA(REDENCAO)
TVD  Canal 15    RADIO TV DO AMAZONAS LTDA
TVD  Canal 15    AINDA NÃO OUTORGADO(REDENÇÃO)
FM   88,5 MHz   RADIO E TV MAIRA LTDA

AC-Assis Brasil
TV    Canal 34    AINDA NÃO OUTORGADO
RTV  Canal 6    AMAZONIA CABO LTDA
RTV  Canal 10    RADIO TV DO AMAZONAS LTDA
RTV  Canal 13    AINDA NÃO OUTORGADO
RTV  Canal 45    FUNDACAO JOAO PAULO II'''.split('\n')

def read_records():
    for line in data:
        yield line


# INITIALIZE SPLITTER, READ RECORDS AND WRITE TO CSV FILE

splitter = re.compile('\s{2,}')
change_station = True
station = ''

f = open('./output.csv', 'w')
writer = csv.writer(f, quoting=csv.QUOTE_ALL)

for rec in read_records():
    rec = rec.strip()
    if rec == '':
        change_station = True
    elif change_station == True:
        station = rec.replace('-', '  ')
        change_station = False
    else:
        record = station + '  ' + rec
        record = record.encode('utf-8')
        record = re.split(splitter, record)
        writer.writerow(record)

f.close()

# READ IN FILE AND PRINT TO CONSOLE FOR DEMO PURPOSES

f = open('./output.csv', 'r')
print ''.join( f.readlines() )
f.close()
-------------------------------------------------------------------------------------------------------
PolarImageInterpolate <- function(x, y, z, outer.radius = 1, 
            breaks, col, nlevels = 20, contours = TRUE, legend = TRUE, 
            axes = TRUE, circle.rads = pretty(c(0,outer.radius))){

        minitics <- seq(-outer.radius, outer.radius, length.out = 1000)
        # interpolate the data
        Interp <- akima:::interp(x = x, y = y, z = z, 
                extrap = TRUE, 
                xo = minitics, 
                yo = minitics, 
                linear = FALSE)
        Mat <- Interp[[3]]

        # mark cells outside circle as NA
        markNA <- matrix(minitics, ncol = 1000, nrow = 1000) 
        Mat[!sqrt(markNA ^ 2 + t(markNA) ^ 2) < outer.radius] <- NA 

        # sort out colors and breaks:
        if (!missing(breaks) & !missing(col)){
            if (length(breaks) - length(col) != 1){
                stop("breaks must be 1 element longer than cols")
            }
        }
        if (missing(breaks) & !missing(col)){
            breaks <- seq(min(Mat,na.rm = TRUE), max(Mat, na.rm = TRUE), length = length(col) + 1)
            nlevels <- length(breaks) - 1
        }
        if (missing(col) & !missing(breaks)){
            col <- rev(heat.colors(length(breaks) - 1))
            nlevels <- length(breaks) - 1
        }
        if (missing(breaks) & missing(col)){
            breaks <- seq(min(Mat,na.rm = TRUE), max(Mat, na.rm = TRUE), length = nlevels + 1)
            col <- rev(heat.colors(nlevels))
        }

        # if legend desired, it goes on the right and some space is needed
        if (legend) {
            par(mai = c(1,1,1.5,1.5))
        }

        # begin plot
        image(x = minitics, y = minitics, t(Mat), useRaster = TRUE, asp = 1, 
            axes = FALSE, xlab = "", ylab = "", col = col, breaks = breaks)

        # add contours if desired
        if (contours){
            CL <- contourLines(x = minitics, y = minitics, t(Mat), levels = breaks)
            A <- lapply(CL, function(xy){
                        lines(xy$x, xy$y, col = gray(.2), lwd = .5)
                    })
        }

        # add radial axes if desired
        if (axes){ 
            # internals for axis markup
            RMat <- function(radians){
                matrix(c(cos(radians), sin(radians), -sin(radians), cos(radians)), ncol = 2)
            }    

            circle <- function(x, y, rad = 1, nvert = 500){
                rads <- seq(0,2*pi,length.out = nvert)
                xcoords <- cos(rads) * rad + x
                ycoords <- sin(rads) * rad + y
                cbind(xcoords, ycoords)
            }

            # draw circles
            if (missing(circle.rads)){
                circle.rads <- pretty(c(0,outer.radius))
            }

            for (i in circle.rads){
                lines(circle(0, 0, i), col = "#66666650")
            }

            # put on radial spoke axes:
            axis.rads <- c(0, pi / 6, pi / 3, pi / 2, 2 * pi / 3, 5 * pi / 6)
            r.labs <- c(90, 60, 30, 0, 330, 300)
            l.labs <- c(270, 240, 210, 180, 150, 120)

            for (i in 1:length(axis.rads)){ 
                endpoints <- zapsmall(c(RMat(axis.rads[i]) %*% matrix(c(1, 0, -1, 0) * outer.radius,ncol = 2)))
                segments(endpoints[1], endpoints[2], endpoints[3], endpoints[4], col = "#66666650")
                endpoints <- c(RMat(axis.rads[i]) %*% matrix(c(1.1, 0, -1.1, 0) * outer.radius, ncol = 2))
                lab1 <- bquote(.(r.labs[i]) * degree)
                lab2 <- bquote(.(l.labs[i]) * degree)
                text(endpoints[1], endpoints[2], lab1, xpd = TRUE)
                text(endpoints[3], endpoints[4], lab2, xpd = TRUE)
            }
            axis(2, pos = -1.2 * outer.radius, at = sort(union(circle.rads,-circle.rads)), labels = NA)
            text( -1.21 * outer.radius, sort(union(circle.rads, -circle.rads)),sort(union(circle.rads, -circle.rads)), xpd = TRUE, pos = 2)
        }

        # add legend if desired
        # this could be sloppy if there are lots of breaks, and that's why it's optional.
        # another option would be to use fields:::image.plot(), using only the legend. 
        # There's an example for how to do so in its documentation
        if (legend){
            ylevs <- seq(-outer.radius, outer.radius, length = nlevels + 1)
            rect(1.2 * outer.radius, ylevs[1:(length(ylevs) - 1)], 1.3 * outer.radius, ylevs[2:length(ylevs)], col = col, border = NA, xpd = TRUE)
            rect(1.2 * outer.radius, min(ylevs), 1.3 * outer.radius, max(ylevs), border = "#66666650", xpd = TRUE)
            text(1.3 * outer.radius, ylevs,round(breaks, 1), pos = 4, xpd = TRUE)
        }
    }

    # Example
    set.seed(10)
    x <- rnorm(20)
    y <- rnorm(20)
    z <- rnorm(20)
    PolarImageInterpolate(x,y,z, breaks = seq(-2,8,by = 1)) image() # arguments:

    # Mat, a matrix of z values as follows:
    # leftmost edge of first column = 0 degrees, rightmost edge of last column = 360 degrees
    # columns are distributed in cells equally over the range 0 to 360 degrees, like a grid prior to transform
    # first row is innermost circle, last row is outermost circle

    # outer.radius, By default everything scaled to unit circle 
    # ppa: points per cell per arc. If your matrix is little, make it larger for a nice curve
    # cols: color vector. default = rev(heat.colors(length(breaks)-1))
    # breaks: manual breaks for colors. defaults to seq(min(Mat),max(Mat),length=nbreaks)
    # nbreaks: how many color levels are desired?
    # axes: should circular and radial axes be drawn? radial axes are drawn at 30 degree intervals only- this could be made more flexible.
    # circle.rads: at which radii should circles be drawn? defaults to pretty(((0:ncol(Mat)) / ncol(Mat)) * outer.radius)

    # TODO: add color strip legend.

    PolarImagePlot <- function(Mat, outer.radius = 1, ppa = 5, cols, breaks, nbreaks = 51, axes = TRUE, circle.rads){

        # the image prep
        Mat      <- Mat[, ncol(Mat):1]
        radii    <- ((0:ncol(Mat)) / ncol(Mat)) * outer.radius

        # 5 points per arc will usually do
        Npts     <- ppa
        # all the angles for which a vertex is needed
        radians  <- 2 * pi * (0:(nrow(Mat) * Npts)) / (nrow(Mat) * Npts) + pi / 2
        # matrix where each row is the arc corresponding to a cell
        rad.mat  <- matrix(radians[-length(radians)], ncol = Npts, byrow = TRUE)[1:nrow(Mat), ]
        rad.mat  <- cbind(rad.mat, rad.mat[c(2:nrow(rad.mat), 1), 1])

        # the x and y coords assuming radius of 1
        y0 <- sin(rad.mat)
        x0 <- cos(rad.mat)

        # dimension markers
        nc <- ncol(x0)
        nr <- nrow(x0)
        nl <- length(radii)

        # make a copy for each radii, redimension in sick ways
        x1 <- aperm( x0 %o% radii, c(1, 3, 2))
        # the same, but coming back the other direction to close the polygon
        x2 <- x1[, , nc:1]
        #now stick together
        x.array <- abind:::abind(x1[, 1:(nl - 1), ], x2[, 2:nl, ], matrix(NA, ncol = (nl - 1), nrow = nr), along = 3)
        # final product, xcoords, is a single vector, in order, 
        # where all the x coordinates for a cell are arranged
        # clockwise. cells are separated by NAs- allows a single call to polygon()
        xcoords <- aperm(x.array, c(3, 1, 2))
        dim(xcoords) <- c(NULL)
        # repeat for y coordinates
        y1 <- aperm( y0 %o% radii,c(1, 3, 2))
        y2 <- y1[, , nc:1]
        y.array <- abind:::abind(y1[, 1:(length(radii) - 1), ], y2[, 2:length(radii), ], matrix(NA, ncol = (length(radii) - 1), nrow = nr), along = 3)
        ycoords <- aperm(y.array, c(3, 1, 2))
        dim(ycoords) <- c(NULL)

        # sort out colors and breaks:
        if (!missing(breaks) & !missing(cols)){
            if (length(breaks) - length(cols) != 1){
                stop("breaks must be 1 element longer than cols")
            }
        }
        if (missing(breaks) & !missing(cols)){
            breaks <- seq(min(Mat,na.rm = TRUE), max(Mat, na.rm = TRUE), length = length(cols) + 1)
        }
        if (missing(cols) & !missing(breaks)){
            cols <- rev(heat.colors(length(breaks) - 1))
        }
        if (missing(breaks) & missing(cols)){
            breaks <- seq(min(Mat,na.rm = TRUE), max(Mat, na.rm = TRUE), length = nbreaks)
            cols <- rev(heat.colors(length(breaks) - 1))
        }

        # get a color for each cell. Ugly, but it gets them in the right order
        cell.cols <- as.character(cut(as.vector(Mat[nrow(Mat):1,ncol(Mat):1]), breaks = breaks, labels = cols))

        # start empty plot
        plot(NULL, type = "n", ylim = c(-1, 1) * outer.radius, xlim = c(-1, 1) * outer.radius, asp = 1, axes = FALSE, xlab = "", ylab = "")
        # draw polygons with no borders:
        polygon(xcoords, ycoords, col = cell.cols, border = NA)

        if (axes){

            # a couple internals for axis markup.

            RMat <- function(radians){
                matrix(c(cos(radians), sin(radians), -sin(radians), cos(radians)), ncol = 2)
            }

            circle <- function(x, y, rad = 1, nvert = 500){
                rads <- seq(0,2*pi,length.out = nvert)
                xcoords <- cos(rads) * rad + x
                ycoords <- sin(rads) * rad + y
                cbind(xcoords, ycoords)
            }
            # draw circles
            if (missing(circle.rads)){
                circle.rads <- pretty(radii)
            }
            for (i in circle.rads){
                lines(circle(0, 0, i), col = "#66666650")
            }

            # put on radial spoke axes:
            axis.rads <- c(0, pi / 6, pi / 3, pi / 2, 2 * pi / 3, 5 * pi / 6)
            r.labs <- c(90, 60, 30, 0, 330, 300)
            l.labs <- c(270, 240, 210, 180, 150, 120)

            for (i in 1:length(axis.rads)){ 
                endpoints <- zapsmall(c(RMat(axis.rads[i]) %*% matrix(c(1, 0, -1, 0) * outer.radius,ncol = 2)))
                segments(endpoints[1], endpoints[2], endpoints[3], endpoints[4], col = "#66666650")
                endpoints <- c(RMat(axis.rads[i]) %*% matrix(c(1.1, 0, -1.1, 0) * outer.radius, ncol = 2))
                lab1 <- bquote(.(r.labs[i]) * degree)
                lab2 <- bquote(.(l.labs[i]) * degree)
                text(endpoints[1], endpoints[2], lab1, xpd = TRUE)
                text(endpoints[3], endpoints[4], lab2, xpd = TRUE)
            }
            axis(2, pos = -1.2 * outer.radius, at = sort(union(circle.rads,-circle.rads)))
        }
        invisible(list(breaks = breaks, col = cols))
    } image() set.seed(1)
    x <- runif(20, min = 0, max = 360)
    y <- runif(20, min = 0, max = 40)
    z <- rnorm(20)

    Interp <- akima:::interp(x = x, y = y, z = z, 
            extrap = TRUE, 
            xo = seq(0, 360, length.out = 300), 
            yo = seq(0, 40, length.out = 100), 
            linear = FALSE)
    Mat <- Interp[[3]]

    PolarImagePlot(Mat)
-------------------------------------------------------------------------------------------------------
trip tripGrid SpatialGridDataFrame sp rgdal speedfilter sp tripGrid pixellate.psp trip ?trip library(trip)
d <- data.frame(x = 1:10, y = rnorm(10), tms = Sys.time() + 1:10, id = gl(1, 5))
coordinates(d) <- ~x+y
tr <- trip(d, c("tms", "id"))
g <- tripGrid(tr)

pt <- coordinates(g)[which.max(g$z), ]
image(g, col = c("transparent", heat.colors(16)))
lines(tr, col = "black")
points(pt[1], pt[2], pch = "+", cex = 2)
-------------------------------------------------------------------------------------------------------
yourData <- read.csv("yourCSV.csv")
with(yourData, plot(X, Y, type = "l"))
with(yourData, lines(X, Y1))
with(yourData, lines(X, Y2)) ?abline
-------------------------------------------------------------------------------------------------------
map('state')
x <- -73.76275
y <- 41.04181
radius <- 205 # in kilometers
s <- seq(0,2*pi,length=1000)
yradius <- optimize(interval=c(0,3),f=function(z){
  abs(pointDistance(c(x,y),c(x,y+z),longlat=T) - radius*1000)})$par
xradius <- optimize(interval=c(0,3),f=function(z){
  abs(pointDistance(c(x,y),c(x+z,y),longlat=T) - radius*1000)})$par
lines(cos(s)*xradius+x,sin(s)*yradius+y)
-------------------------------------------------------------------------------------------------------
plot plot lines xrange <- range(c(a$Observation, b$Observation))
yrange <- range(c(a$Time, b$Time))
plot(0, type="n", xlim=xrange, ylim=yrange)
lines(a$Observation, a$Time, type="b", col="red", pch=19)
lines(b$Observation, b$Time, type="b", col="blue", pch=19)
-------------------------------------------------------------------------------------------------------
forecast simulate(fit) fit arima() Arima() library(forecast)
fit <- Arima(USAccDeaths,order=c(0,1,1),seasonal=c(0,1,1))
plot(USAccDeaths,xlim=c(1973,1980),ylim=c(6000,12000))
for(i in 1:10)
  lines(simulate(fit,nsim=24),col="blue") forecast(fit)
-------------------------------------------------------------------------------------------------------
require(plotrix)
x<-c(0,cumsum(rnorm(99)))
 y<-c(0,cumsum(rnorm(99)))
 xydist<-sqrt(x*x+y*y)
 plot(x,y,main="Random walk plot",xlab="X",ylab="Y",type="n")
 color.scale.lines(x,y,c(1,1,0),0,c(0,1,1),colvar=xydist,lwd=2)
-------------------------------------------------------------------------------------------------------
spl <- smooth.spline(x, y=ycs)
pred <- predict(spl)

plot (x, ycs, log="xy")
lines(pred, col=2)

ycs.prime <- diff(ycs)/diff(x)
pred.prime <- predict(spl, deriv=1)

plot(ycs.prime)
lines(pred.prime$y, col=2)
-------------------------------------------------------------------------------------------------------
1 - plnorm() plnorm() ## Function to plot aft data
plot.aft <- function(x, legend = c("ICU Patients", "Non-ICU Patients"),
    xlab = "Days since Infection", ylab="Percent Surviving", lwd = 2,
    col = c("red", "black"), at = c(0, 20, 40, 60, 80, 100, 120, 140, 160, 180),
        ...)
{
    plot(x[, 1], x[, 2], type = "l", ylim = c(0, 1), xaxt = "n", 
            xlab = xlab, ylab = ylab, col = col[2], lwd = 2, ...)
    axis(1, at = at)
    lines(x[, 1], x[, 3], col = col[1], lwd=2)
    legend("topright", legend = legend, lwd = lwd, col = col)
} ## Specify coefficients, variables, and linear models
beta0 <- 5.00
beta1 <- -0.500
icu <- c(0, 1)
t <- seq(0, 180)
linmod <- beta0 + (beta1 * icu)
names(linmod) <- c("unexposed", "exposed")

## Generate s(t) from exponential AFT model
s0.exp <- dexp(exp(-linmod["unexposed"]) * t)
s1.exp <- dexp(exp(-linmod["exposed"]) * t)

## Generate s(t) from lognormal AFT model
s0.lnorm <- 1 - plnorm(t, meanlog = linmod["unexposed"])
s1.lnorm <- 1 - plnorm(t, meanlog = linmod["exposed"]) ## Plot survival
plot.aft(data.frame(t, s0.exp, s1.exp), main = "Exponential model")
plot.aft(data.frame(t, s0.lnorm, s1.lnorm), main = "Log-normal model") plnorm(t, meanlog = linmod["exposed"]) pnorm((log(t) - linmod["exposed"]) / 1)
-------------------------------------------------------------------------------------------------------
plot(...)
lines(...)
grid(...)
legend(...) # legend has to be the last command!
-------------------------------------------------------------------------------------------------------
scatterBar.Norm <- function(x,y) {
 zones <- matrix(c(2,0,1,3), ncol=2, byrow=TRUE)
 layout(zones, widths=c(5/7,2/7), heights=c(2/7,5/7))
 xrange <- range(x)
 yrange <- range(y)
 par(mar=c(3,3,1,1))
 plot(x, y, xlim=xrange, ylim=yrange, xlab="", ylab="", cex=0.5)
 xhist <- hist(x, plot=FALSE, breaks=seq(from=min(x), to=max(x), length.out=20))
 yhist <- hist(y, plot=FALSE, breaks=seq(from=min(y), to=max(y), length.out=20))
 top <- max(c(xhist$density, yhist$density))
 par(mar=c(0,3,1,1))
 barplot(xhist$density, axes=FALSE, ylim=c(0, top), space=0)
 x.xfit <- seq(min(x),max(x),length.out=40)
 x.yfit <- dnorm(x.xfit, mean=mean(x), sd=sd(x))
 x.xscalefactor <- x.xfit / seq(from=0, to=19, length.out=40)
 lines(x.xfit/x.xscalefactor, x.yfit, col="red")
 par(mar=c(3,0,1,1))
 barplot(yhist$density, axes=FALSE, xlim=c(0, top), space=0, horiz=TRUE)
 y.xfit <- seq(min(y),max(y),length.out=40)
 y.yfit <- dnorm(y.xfit, mean=mean(y), sd=sd(y))
 y.xscalefactor <- y.xfit / seq(from=0, to=19, length.out=40)
 lines(y.yfit, y.xfit/y.xscalefactor, col="red")
} require(MASS)
#Sigma <- matrix(c(2.25, 0.8, 0.8, 1), 2, 2)
Sigma <- matrix(c(1, 0.8, 0.8, 1), 2, 2)
mvnorm <- mvrnorm(1000, c(0,0), Sigma) ; scatterBar.Norm(mvnorm[,1], mvnorm[,2])
-------------------------------------------------------------------------------------------------------
scatterBarNorm <- function(x, dcol="blue", lhist=20, num.dnorm=5*lhist, ...){
    ## check input
    stopifnot(ncol(x)==2)
    ## set up layout and graphical parameters
    layMat <- matrix(c(2,0,1,3), ncol=2, byrow=TRUE)
    layout(layMat, widths=c(5/7, 2/7), heights=c(2/7, 5/7))
    ospc <- 0.5 # outer space
    pext <- 4 # par extension down and to the left
    bspc <- 1 # space between scatter plot and bar plots
    par. <- par(mar=c(pext, pext, bspc, bspc),
                oma=rep(ospc, 4)) # plot parameters
    ## scatter plot
    plot(x, xlim=range(x[,1]), ylim=range(x[,2]), ...)
    ## 3) determine barplot and height parameter
    ## histogram (for barplot-ting the density)
    xhist <- hist(x[,1], plot=FALSE, breaks=seq(from=min(x[,1]), to=max(x[,1]),
                                     length.out=lhist))
    yhist <- hist(x[,2], plot=FALSE, breaks=seq(from=min(x[,2]), to=max(x[,2]),
                                     length.out=lhist)) # note: this uses probability=TRUE
    ## determine the plot range and all the things needed for the barplots and lines
    xx <- seq(min(x[,1]), max(x[,1]), length.out=num.dnorm) # evaluation points for the overlaid density
    xy <- dnorm(xx, mean=mean(x[,1]), sd=sd(x[,1])) # density points
    yx <- seq(min(x[,2]), max(x[,2]), length.out=num.dnorm)
    yy <- dnorm(yx, mean=mean(x[,2]), sd=sd(x[,2]))
    ## barplot and line for x (top)
    par(mar=c(0, pext, 0, 0))
    barplot(xhist$density, axes=FALSE, ylim=c(0, max(xhist$density, xy)),
            space=0) # barplot
    lines(seq(from=0, to=lhist-1, length.out=num.dnorm), xy, col=dcol) # line
    ## barplot and line for y (right)
    par(mar=c(pext, 0, 0, 0))
    barplot(yhist$density, axes=FALSE, xlim=c(0, max(yhist$density, yy)),
            space=0, horiz=TRUE) # barplot
    lines(yy, seq(from=0, to=lhist-1, length.out=num.dnorm), col=dcol) # line
    ## restore parameters
    par(par.)
}

require(mvtnorm)
X <- rmvnorm(1000, c(0,0), matrix(c(1, 0.8, 0.8, 1), 2, 2))
scatterBarNorm(X, xlab=expression(italic(X[1])), ylab=expression(italic(X[2])))
-------------------------------------------------------------------------------------------------------
?lines plot(1:100)
sapply(seq(1,100,5), function(i) lines(c(0,50), c(i,i)))
-------------------------------------------------------------------------------------------------------
nls2 ?Gest library(spatstat)
data(simdat)
simdat.Gest <- Gest(simdat)
Gvalues <- simdat.Gest$rs
Rvalues <- simdat.Gest$r
plot(Gvalues~Rvalues)

#let's try the normal CDF
fit <- nls(Gvalues~pnorm(Rvalues,mean,sd),start=list(mean=0.4,sd=0.2))
summary(fit)
lines(Rvalues,predict(fit))
#Looks not bad. There might be a better model, but not the one provided in the question.
-------------------------------------------------------------------------------------------------------
arrows require(plotrix)

color.scale.arrow = function(x1,y1,x2,y2,first.col,second.col,
lwd= par('lwd'),lty=par('lty'),angle=30,length=0.25) {
        x=mapply(seq,x1,x2,length.out=256) # Each column is one arrow
        y=mapply(seq,y1,y2,length.out=256) # Each column is one arrow

        arrows(x[255,],y[255,],x[256,],y[256,],
               col=ifelse(y[256,]<y[255,],first.col,second.col),
               lwd=lwd,lty=lty,angle=angle,length=length)

        rgb1=col2rgb(first.col)[,1] / 255
        rgb2=col2rgb(second.col)[,1] / 255
        cols=rbind(rgb1,(rgb1 + rgb2) / 2,rgb2)

        invisible(
              sapply(seq(ncol(x)),function(line) 
                  color.scale.
lines(x[,line],y[,line],cols[,'red'],cols[,'green'],cols[,'blue'],lwd=lwd,lty=lty)
              )
       )
}

# Create sample data
set.seed(1)
x <- runif(12); y <- rnorm(12)
i <- order(x,y); x <- x[i]; y <- y[i]
x1=x[s]
x2=x[s+1]
y1=y[s]
y2=y[s+1]

# Plot sample data
plot(x,y, main='', type='n')
color.scale.arrow(x1,y1,x2,y2,'red','blue',lwd=2) color.scale.arrow
-------------------------------------------------------------------------------------------------------
plot(NDVI, as.numeric(Used)-1 )
lines(xv,yv) 1L str(yv)
-------------------------------------------------------------------------------------------------------
nls nls nls1=nls(ygm~i*x^-z,start=list(i=-3,z=-2),data=dat) > nls1
Nonlinear regression model
  model:  ygm ~ i * x^-z 
   data:  dat 
       i        z 
245.0356   0.5449 
 residual sum-of-squares: 811.4

 ... 

> predict(nls1)
[1] 245.03564 167.95574 134.66070 115.12256 101.94200  92.30101  84.86458
[8]  78.90891
> plot(dat)
> lines(predict(nls1))
-------------------------------------------------------------------------------------------------------
predProbs<-predict(poislm,data.frame(y=seq(min(y), max(y), length.out=100)), type="response")
lines(seq(min(y), max(y), length.out=100), predProbs, col=2, lwd=2)
-------------------------------------------------------------------------------------------------------
unemploy<-read.table("ILIROQ5URN.txt",header=T,skip=11)
unemploy<-ts(unemploy$VALUE,frequency=12,start(1990,1))

plot(deseason<-stl(unemploy,s.window="periodic"))

plot(unemploy)
lines(deseason$time.series[,2],col="red")
-------------------------------------------------------------------------------------------------------
plot(myd$PC1, myd$PC2)
apply(combn(seq_len(nrow(myd)), 2), 2, 
      function(x) lines(myd[x, ]$PC1, myd[x, ]$PC2)) ps <- data.frame(t(apply(combn(seq_len(nrow(myd)), 2), 2, function(x) c(myd[x, ]$PC1, myd[x, ]$PC2))))
qplot(myd$PC1, myd$PC2) +
  geom_segment(data = ps, mapping = aes(x = X1, xend = X2, y = X3,yend = X4))
-------------------------------------------------------------------------------------------------------
rbind performance n1 <- getPerformance(test1)
n2 <- getPerformance(test2)
n3 <- getPerformance(test3) type x           y
1   n1 0 0.000000000
2   n1 0 0.003448276
3   n1 0 0.006896552
4   n1 0 0.010344828
5   n1 0 0.013793103
6   n1 0 0.017241379
...
26565   n1 0.9999619 1
26566   n1 1.0000000 1 n2_rev <- n2[nrow(n2):1,]
ns <- rbind(n1,n2_rev,n3) lines()
-------------------------------------------------------------------------------------------------------
data <- read.table("data.txt",header=T,row.names=1)
lst  <- c("LABELXYZ123","LABELXZZ123","LABELXYZ345","LABELXYZ567","LABELXYY1234","LABELXXX123")
labs <- row.names(data)
for(i in lst) {
    png(filename=paste(i,".png",sep=""),width = 700, height = 350)
    river  <- data[[paste(i, "_river", sep = "")]]
    lake <- data[[paste(i, "_lake", sep = "")]]
    allt <- c(river,lake)
    plot(river, xaxt='n',xlab="",ylab=i,type="b",col="darkred",lwd=3,ylim=c(min(allt)*1.05,max(allt)*0.95))
    lines(lake,type="b",col="darkgreen",lwd=3)
    axis(1,at=1:16,labels=labs,las=2)
    dev.off()
}
-------------------------------------------------------------------------------------------------------
d <- data.frame(x,y)  ## need to use data in a data.frame for predict()
logEstimate <- lm(y~log(x),data=d) predict plot(x,y)
xvec <- seq(0,7000,length=101)
logpred <- predict(logEstimate,newdata=data.frame(x=xvec))
lines(xvec,logpred) coef(logEstimate)
## (Intercept)      log(x) 
##  0.6183839   0.0856404 
curve(0.61838+0.08564*log(x),add=TRUE,col=2) with() with(as.list(coef(logEstimate)),
      curve(`(Intercept)`+`log(x)`*log(x),add=TRUE,col=4)) est1 <- predict(lm(y~x,data=d),newdata=data.frame(x=xvec))
plot(est1,logpred)
-------------------------------------------------------------------------------------------------------
x=c(61,610,1037,2074,3050,4087,5002,6100,7015)
y=c(0.974206,1.16716,1.19879,1.28192,1.30739,1.32019,1.35494,1.36941,1.37505)

Estimate = lm(y ~ x)
logEstimate = lm(y ~ log(x))

plot(x,predict(Estimate),type='l',col='blue')
lines(x,predict(logEstimate),col='red')
points(x,y) log y = log(x) exp(y) = x x y
-------------------------------------------------------------------------------------------------------
library(rmutil)  ## for rpareto
set.seed(101)
hh2 <- data.frame(V1=rpareto(1000, m=1, s=1.5)) pp <- hist(hh2$V1,plot=FALSE) gamma ghistfun <- function(x) {
    n <- length(x)
    scalepar <- var(x)/mean(x)
    shapepar <- mean(x)^2/var(x)
    y <- rgamma(n,shape=shapepar,scale=scalepar)
    xx <- hist(y,plot=FALSE)
    lines(log(xx$mids),log(xx$density),col="red")
    curve(dgamma(exp(x),shape=shapepar,scale=scalepar,log=TRUE),
        add=TRUE,col="blue")

    shapepar
} n curve(dgamma(x,...)) x log(x) plot(log(pp$mids),log(pp$density))
ghistfun(hh2$V1)
-------------------------------------------------------------------------------------------------------
as.numeric mydat <- runif(50)
day1 <- as.POSIXct("2012-07-13", tz = "UTC")
day2 <- day1 + 49*3600*24
pdays <- seq(day1, day2, by = "days")
lo <- loess(mydat ~ as.numeric(pdays))

# And then if you want to plot the result:
plot(pdays,mydat)
lines(pdays, lo$fitted)
-------------------------------------------------------------------------------------------------------
quantmod:::chartSeries.chob old.adj <- par('adj')
par('adj'=0)
do.call('title',list(x@name, col.main=x@colors$fg.col))
par('adj'=1)
do.call('title',list(paste('[',start(xx),'/',end(xx),']', sep='')
                  ,col.main=x@colors$main.col))
par('adj'=old.adj) if(x@type=='line') {
    lines(x.pos,Closes,col=x@colors$up.col,type=x@line.type)
    main.key <- c(list(list(legend=
                       paste('Last',last(Closes)),
                       text.col=x@colors$up.col)),main.key)
}
-------------------------------------------------------------------------------------------------------
load(url("http://dl.dropbox.com/u/61803503/nycounty.RData"))

library(plotrix)
e=10^-5
myglyff=function(gi) {
floating.pie(mean(gi$long),
             mean(gi$lat),
             x=c(gi[1,"white"]+e,
                 gi[1,"black"]+e,
                 gi[1,"hispanic"]+e,
                 gi[1,"asian"]+e,
                 gi[1,"other"]+e),
              radius=.1) #insert size variable here
}

g1=ny[which(ny$group==1),]
plot(g1$long,
     g1$lat,
     type='l',
     xlim=c(-80,-71.5),
     ylim=c(40.5,45.1))

myglyff(g1)

for(i in 2:62)
  {gi=ny[which(ny$group==i),]
    lines(gi$long,gi$lat)
    myglyff(gi)
  }
-------------------------------------------------------------------------------------------------------
library(TeachingDemos)
x <- pmin(3, pmax(-3, stats::rnorm(50)))
y <- pmin(3, pmax(-3, stats::rnorm(50)))
xhist <- hist(x, breaks=seq(-3,3,0.5), plot=FALSE)
yhist <- hist(y, breaks=seq(-3,3,0.5), plot=FALSE)
top <- max(c(xhist$density, yhist$density))
xrange <- c(-3,3)
yrange <- c(-3,3)
nf <- layout(matrix(c(2,0,1,3),2,2,byrow=TRUE), c(3,1), c(1,3), TRUE)
layout.show(nf)

par(mar=c(3,3,1,1))
plot(x, y, xlim=xrange, ylim=yrange, xlab="", ylab="")
par(mar=c(0,3,1,1))
bx.out <- barplot(xhist$density, axes=FALSE, ylim=c(0, top), space=0)
updateusr( bx.out[1:2], 0:1, xhist$mids[1:2], 0:1 )
xdens <- density(x)
lines(xdens$x, xdens$y, col='blue')
par(mar=c(3,0,1,1))
by.out <- barplot(yhist$density, axes=FALSE, xlim=c(0, top), space=0, horiz=TRUE)
updateusr( 0:1, by.out[1:2], 0:1, yhist$mids[1:2] )
ydens <- density(y)
lines(ydens$y, ydens$x, col='blue') counts density updateusr updateusr width xlim barplot
-------------------------------------------------------------------------------------------------------
jarque.bera.test library(tseries)
 jarque.bera.test(ss)

    Jarque Bera Test

data:  ss 
X-squared = 4100.781, df = 2, p-value < 2.2e-16 library(fBasics)
 basicStats(ss)
                     ss
nobs        3776.000000
NAs            0.000000
Minimum       -0.105195
Maximum        0.187713
1. Quartile   -0.009417
3. Quartile    0.010220
Mean           0.000462
Median         0.001224
Sum            1.745798
SE Mean        0.000336
LCL Mean      -0.000197
UCL Mean       0.001122
Variance       0.000427
Stdev          0.020671
Skewness       0.322820
Kurtosis       5.060026 ss plot(density(ss, kernel='epanechnikov'))
 set.seed(125)
 lines(density(rnorm(length(ss), mean(ss), sd(ss)), kernel='epanechnikov'), col=2)
-------------------------------------------------------------------------------------------------------
plot() lines() plot(density(x))
lines(density(rlogis(length(x), location = 0.0005210570,scale = 0.0106366354)), col="blue")
-------------------------------------------------------------------------------------------------------
xlim ylim range() plot(x$Date, x$Value, type="l", col="blue", xaxt="n",
     xlim=range(c(a$Date, x$Date)),
     ylim=range(c(z.pre, x$Value))
)

axis(1, x$Date, format(x$Date, "%b %Y"), cex.axis = .7) 

lines(a$Date, z.pre, col="red")
-------------------------------------------------------------------------------------------------------
sharpness tricol # Coordinates of the triangle
tri <- rbind(sin(0:2*2/3*pi), cos(0:2*2/3*pi))

# Function for calculating the color of a set of points `pt`
# in relation to the triangle
tricol <- function(pt, sharpness=2){
    require(splancs)
    RGB <- sapply(1:3, function(i){
        a <- sweep(pt, 2, tri[,i])
        b <- apply(tri[,-i], 1, mean) - tri[,i]
        sharpness*((a %*% b) / sum(b^2))-sharpness+1
    })
    RGB[-inpip(pt,t(tri)),] <- 1    # Color points outside the triangle white
    do.call(rgb, unname(as.data.frame(pmin(pmax(RGB, 0), 1))))
}

# Plot
res <- 1000                         # Resolution
xi <- seq(-1, 1, length=res)        # Axis points
yi <- seq(-.8, 1.2, length=res)
x <- xi[1] + cumsum(diff(xi))       # Midpoints between axis points
y <- yi[1] + cumsum(diff(yi))
xy <- matrix(1:(length(x)*length(y)), length(x))
image(xi, yi, xy, col=tricol(as.matrix(expand.grid(x,y))), useRaster=TRUE)
lines(tri[1,c(1:3,1)], tri[2,c(1:3,1)], type="l") tricol() i a pt b a b sharpness
-------------------------------------------------------------------------------------------------------
plot(x,y,main="X vs Y", xlab="X", ylab="Y")
lines(x,y,col="black",lty="dotted") plot(x,y,main="X vs Y", xlab="X", ylab="Y") plot.new()
-------------------------------------------------------------------------------------------------------
#First your data:
y<-c(123,92,104,23,17,89,13)
x<-c(11,45,24,50,18,7,2)
size<-c(1236,1067,1176,610,539,864,1026)
radius<-sqrt(size/pi)
col<-c(2,2,3,4,5,5,6)
name<-c("Acura", "Alfa Romeo","AM General","Aston Martin Lagonda","Audi","BMW","Bugatti")

#Then a simple function to draw a circle based on its center and its radius:
circle <- function (r, x0, y0, col){
    t <- seq(0, 2 * pi, by = 0.01)
    x <- r * cos(t) + x0
    y <- r * sin(t) + y0
    lines(x, y, col=col)
    }

#This is a smoothing factor:
sm <- 500

#The asp parameter is important here since we are actually drawing the circles and not plotting some circle symbols: if asp is not equal to 1 they will appear as ellipse.
plot(x,y,type="n",asp=1)

#This can probably be vectorized but I'm not a good vectorizer so if anyone wants to  give it a try:
for(j in 1:length(x)){
    radius[j]*sm:1/sm -> radiuses
    colorRampPalette(c(palette()[col[j]], "white"))->col_grad
    col_grad(length(radiuses))->colx
    for(i in 1:length(radiuses)){circle(radiuses[i], x[j], y[j], col=colx[i])}
    }

text(x, y, name, cex=1.5,font=4) ?colorRampPalette offset<-c(2,-2) #Offset of the shadow circles
 library(scales) #For function alpha

 plot(x,y,type="n",asp=1)

 for(j in 1:length(x)){
     radius[j]*sm:1/sm -> radiuses
     colorRampPalette(c(palette()[col[j]], "white"))->col_grad
     col_grad(length(radiuses))->colx
     for(i in 1:length(radiuses)){circle(radiuses[i], x[j]+offset[1], y[j]+offset[2], col=alpha("grey90",0.1))} #the alpha, the nuance of grey can be tweaked with obviously for the desired effect
     for(i in 1:length(radiuses)){circle(radiuses[i], x[j], y[j], col=colx[i])}
     }

 text(x, y, name, cex=1.5,font=4)
-------------------------------------------------------------------------------------------------------
neuralnet neuralnet plot(..., file = "") plot.nn() plot.nn <-
function (x, rep = NULL, x.entry = NULL, x.out = NULL, radius = 0.15, 
    arrow.length = 0.2, intercept = TRUE, intercept.factor = 0.4, 
    information = TRUE, information.pos = 0.1, col.entry.synapse = "black", 
    col.entry = "black", col.hidden = "black", col.hidden.synapse = "black", 
    col.out = "black", col.out.synapse = "black", col.intercept = "blue", 
    fontsize = 12, dimension = 6, show.weights = TRUE, file = NULL, 
    ...) 
{
    net <- x
    if (is.null(net$weights)) 
        stop("weights were not calculated")
    if (!is.null(file) && !is.character(file)) 
        stop("'file' must be a string")
    if (is.null(rep)) {
        for (i in 1:length(net$weights)) {
            if (!is.null(file)) 
                file.rep <- paste(file, ".", i, sep = "")
            else file.rep <- NULL
            #dev.new()
            plot.nn(net, rep = i, x.entry, x.out, radius, arrow.length, 
                intercept, intercept.factor, information, information.pos, 
                col.entry.synapse, col.entry, col.hidden, col.hidden.synapse, 
                col.out, col.out.synapse, col.intercept, fontsize, 
                dimension, show.weights, file.rep, ...)
        }
    }
    else {
        if (is.character(file) && file.exists(file)) 
            stop(sprintf("%s already exists", sQuote(file)))
        result.matrix <- t(net$result.matrix)
        if (rep == "best") 
            rep <- as.integer(which.min(result.matrix[, "error"]))
        if (rep > length(net$weights)) 
            stop("'rep' does not exist")
        weights <- net$weights[[rep]]
        if (is.null(x.entry)) 
            x.entry <- 0.5 - (arrow.length/2) * length(weights)
        if (is.null(x.out)) 
            x.out <- 0.5 + (arrow.length/2) * length(weights)
        width <- max(x.out - x.entry + 0.2, 0.8) * 8
        radius <- radius/dimension
        entry.label <- net$model.list$variables
        out.label <- net$model.list$response
        neuron.count <- array(0, length(weights) + 1)
        neuron.count[1] <- nrow(weights[[1]]) - 1
        neuron.count[2] <- ncol(weights[[1]])
        x.position <- array(0, length(weights) + 1)
        x.position[1] <- x.entry
        x.position[length(weights) + 1] <- x.out
        if (length(weights) > 1) 
            for (i in 2:length(weights)) {
                neuron.count[i + 1] <- ncol(weights[[i]])
                x.position[i] <- x.entry + (i - 1) * (x.out - 
                  x.entry)/length(weights)
            }
        y.step <- 1/(neuron.count + 1)
        y.position <- array(0, length(weights) + 1)
        y.intercept <- 1 - 2 * radius
        information.pos <- min(min(y.step) - 0.1, 0.2)
        if (length(entry.label) != neuron.count[1]) {
            if (length(entry.label) < neuron.count[1]) {
                tmp <- NULL
                for (i in 1:(neuron.count[1] - length(entry.label))) {
                  tmp <- c(tmp, "no name")
                }
                entry.label <- c(entry.label, tmp)
            }
        }
        if (length(out.label) != neuron.count[length(neuron.count)]) {
            if (length(out.label) < neuron.count[length(neuron.count)]) {
                tmp <- NULL
                for (i in 1:(neuron.count[length(neuron.count)] - 
                  length(out.label))) {
                  tmp <- c(tmp, "no name")
                }
                out.label <- c(out.label, tmp)
            }
        }
        grid.newpage()
        pushViewport(viewport(name = "plot.area", width = unit(dimension, 
            "inches"), height = unit(dimension, "inches")))
        for (k in 1:length(weights)) {
            for (i in 1:neuron.count[k]) {
                y.position[k] <- y.position[k] + y.step[k]
                y.tmp <- 0
                for (j in 1:neuron.count[k + 1]) {
                  y.tmp <- y.tmp + y.step[k + 1]
                  result <- calculate.delta(c(x.position[k], 
                    x.position[k + 1]), c(y.position[k], y.tmp), 
                    radius)
                  x <- c(x.position[k], x.position[k + 1] - result[1])
                  y <- c(y.position[k], y.tmp + result[2])
                  grid
 = y, arrow = arrow(length = unit(0.15, "cm"), type = "closed"), gp = gpar(fill = col.hidden.synapse, col = col.hidden.synapse, ...))
                  if (show.weights) 
                    draw.text(label = weights[[k]][neuron.count[k] - 
                      i + 2, neuron.count[k + 1] - j + 1], x = c(x.position[k], 
                      x.position[k + 1]), y = c(y.position[k], 
                      y.tmp), xy.null = 1.25 * result, color = col.hidden.synapse, 
                      fontsize = fontsize - 2, ...)
                }
                if (k == 1) {
                  grid.

                  draw.text(label = entry.label[(neuron.count[1] + 
                    1) - i], x = c((x.position - arrow.length), 
                    x.position[1] - radius), y = c(y.position[k], 
                    y.position[k]), xy.null = c(0, 0), color = col.entry.synapse, 
                    fontsize = fontsize, ...)
                  grid.circle(x = x.position[k], y = y.position[k], 
                    r = radius, gp = gpar(fill = "white", col = col.entry, 
                      ...))
                }
                else {
                  grid.circle(x = x.position[k], y = y.position[k], 
                    r = radius, gp = gpar(fill = "white", col = col.hidden, 
                      ...))
                }
            }
        }
        out <- length(neuron.count)
        for (i in 1:neuron.count[out]) {
            y.position[out] <- y.position[out] + y.step[out]
            h), y = y.position[out], arrow = arrow(length = unit(0.15, 
                "cm"), type = "closed"), gp = gpar(fill = col.out.synapse, 
                col = col.out.synapse, ...))
            draw.text(label = out.label[(neuron.count[out] + 
                1) - i], x = c((x.position[out] + radius), x.position[out] + 
                arrow.length), y = c(y.position[out], y.position[out]), 
                xy.null = c(0, 0), color = col.out.synapse, fontsize = fontsize, 
                ...)
            grid.circle(x = x.position[out], y = y.position[out], 
                r = radius, gp = gpar(fill = "white", col = col.out, 
                  ...))
        }
        if (intercept) {
            for (k in 1:length(weights)) {
                y.tmp <- 0
                x.intercept <- (x.position[k + 1] - x.position[k]) * 
                  intercept.factor + x.position[k]
                for (i in 1:neuron.count[k + 1]) {
                  y.tmp <- y.tmp + y.step[k + 1]
                  result <- calculate.delta(c(x.intercept, x.position[k + 
                    1]), c(y.intercept, y.tmp), radius)
                  x <- c(x.intercept, x.position[k + 1] - result[1])
                  y <- c(y.intercept, y.tmp + result[2])
                 x, y = y, arrow = arrow(length = unit(0.15, 
                    "cm"), type = "closed"), gp = gpar(fill = col.intercept, 
                    col = col.intercept, ...))
                  xy.null <- cbind(x.position[k + 1] - x.intercept - 
                    2 * result[1], -(y.tmp - y.intercept + 2 * 
                    result[2]))
                  if (show.weights) 
                    draw.text(label = weights[[k]][1, neuron.count[k + 
                      1] - i + 1], x = c(x.intercept, x.position[k + 
                      1]), y = c(y.intercept, y.tmp), xy.null = xy.null, 
                      color = col.intercept, alignment = c("right", 
                        "bottom"), fontsize = fontsize - 2, ...)
                }
                grid.circle(x = x.intercept, y = y.intercept, 
                  r = radius, gp = gpar(fill = "white", col = col.intercept, 
                    ...))
                grid.text(1, x = x.intercept, y = y.intercept, 
                  gp = gpar(col = col.intercept, ...))
            }
        }
        if (information) 
            grid.text(paste("Error: ", round(result.matrix[rep, 
                "error"], 6), "   Steps: ", result.matrix[rep, 
                "steps"], sep = ""), x = 0.5, y = information.pos, 
                just = "bottom", gp = gpar(fontsize = fontsize + 
                  2, ...))
        popViewport()
        if (!is.null(file)) {
            weight.plot <- recordPlot()
            save(weight.plot, file = file)
        }
    }
}
calculate.delta <-
function (x, y, r) 
{
    delta.x <- x[2] - x[1]
    delta.y <- y[2] - y[1]
    x.null <- r/sqrt(delta.x^2 + delta.y^2) * delta.x
    if (y[1] < y[2]) 
        y.null <- -sqrt(r^2 - x.null^2)
    else if (y[1] > y[2]) 
        y.null <- sqrt(r^2 - x.null^2)
    else y.null <- 0
    c(x.null, y.null)
}
draw.text <-
function (label, x, y, xy.null = c(0, 0), color, alignment = c("left", 
    "bottom"), ...) 
{
    x.label <- x[1] + xy.null[1]
    y.label <- y[1] - xy.null[2]
    x.delta <- x[2] - x[1]
    y.delta <- y[2] - y[1]
    angle = atan(y.delta/x.delta) * (180/pi)
    if (angle < 0) 
        angle <- angle + 0
    else if (angle > 0) 
        angle <- angle - 0
    if (is.numeric(label)) 
        label <- round(label, 5)
    pushViewport(viewport(x = x.label, y = y.label, width = 0, 
        height = , angle = angle, name = "vp1", just = alignment))
    grid.text(label, x = 0, y = unit(0.75, "mm"), just = alignment, 
        gp = gpar(col = color, ...))
    popViewport()
} png("test.png")
plot(nn)
dev.off()
-------------------------------------------------------------------------------------------------------
par ?par dev.new( width= 16, height= 7 )
## set outer margins
par( mar=c(5, 4, 4, 4), cex= 0.9 )
plot( 1:100, type="n", xlab = "", ylab = "", axes = F, las = 2, cex = 0.7 )
axis( 4, at = c ( 0, 30, 60, 90, 120, 150, 180 ), labels = c( "0", "30", "60", "90", "120", "150", "180" ), las = 0, cex.axis = .8,col.lab = "gray80",
tck = 0.01 )
rect( 153, -5.5, 169, 185, col = "gray80", border = NA)
rect( 246, -5.5, 272, 185, col = "gray80", border = NA)
lines( 1:200, col = "gray20" )
#text("Moon phase (º)", 330, 90, cex = .9 )
mtext(side = 4, text = "Moon phase (º)", line = 2, cex = .9 )
mtext(side = 1, text = "Dates", line = 4, cex = .9 )

par( new = T )
plot( 1:220, type = "n", lwd= 1.2, xlab= "", ylab= "Photoperiod (h)", axes = F, cex = .8, col.lab = "red" )
axis( side= 1, at = c ( 1, 20, 51, 82, 112, 143, 173, 204, 235, 264, 295, 324 ), labels = c ( "12 Jun'07", "1 Jul'07", "1 Aug'07", "1 Sep'07", "1 Oct'07", "1 Nov'07", "1 Dec'07", "1 Jan'08", "1 Feb'08", "1 Mar'08", "1 Apr'08", "30 Apr'08" ), las = 2, cex.axis = .75 )
axis ( side = 2, at = c( 12, 13, 14, 15, 16 ), labels = c( "12", "13", "14", "15", "16" ), cex.axis = .8, las = 2)
box()
-------------------------------------------------------------------------------------------------------
draw.ellipse plotrix RSiteSearch("ellipse", restrict="functions") ellipse <- function(xf1, yf1, xf2, yf2, k, new=TRUE,...){
    # xf1 and yf1 are the coordinates of your focus F1
    # xf2 and yf2 are the coordinates of your focus F2
    # k is your constant (sum of distances to F1 and F2 of any points on the ellipse)
    # new is a logical saying if the function needs to create a new plot or add an ellipse to an existing plot.
    # ... is any arguments you can pass to functions plot or lines (col, lwd, lty, etc.)
    t <- seq(0, 2*pi, by=pi/100)  # Change the by parameters to change resolution
    k/2 -> a  # Major axis
    xc <- (xf1+xf2)/2
    yc <- (yf1+yf2)/2  # Coordinates of the center
    dc <- sqrt((xf1-xf2)^2 + (yf1-yf2)^2)/2  # Distance of the foci to the center
    b <- sqrt(a^2 - dc^2)  # Minor axis
    phi <- atan(abs(yf1-yf2)/abs(xf1-xf2))  # Angle between the major axis and the x-axis
    xt <- xc + a*cos(t)*cos(phi) - b*sin(t)*sin(phi)
    yt <- yc + a*cos(t)*sin(phi) + b*sin(t)*cos(phi)
    if(new){ plot(xt,yt,type="l",...) }
    if(!new){ lines(xt,yt,...) }
    } F1 <- c(2,3)
F2 <- c(1,2)
plot(rbind(F1, F2), xlim=c(-1,5), ylim=c(-1, 5), pch=19)
abline(h=0, v=0, col="grey90")
ellipse(F1[1], F1[2], F2[1], F2[2], k=2, new=FALSE, col="red", lwd=2)
points((F1[1]+F2[1])/2, (F1[2]+F2[2])/2, pch=3)
-------------------------------------------------------------------------------------------------------
plot(1:10, 1:10, type = "n", xlim = c(1, 5))
usr = par("usr")
clip(usr[1], 5, usr[3], usr[4])
lines(1:10, 1:10, type = "l", xlim = c(1, 5))
-------------------------------------------------------------------------------------------------------
set.seed(1410)
df<-data.frame(
  "site.x"=c(rep("a",4),rep("b",4),rep("c",4),rep("d",4)),
  "site.y"=c(rep(c("e","f","g","h"),4)),
  "bond.strength"=sample(1:100,16, replace=TRUE), stringsAsFactors=FALSE)


Placement <- data.frame(site=c(unique(df$site.x),unique(df$site.y)), x = NA, y = NA, stringsAsFactors=FALSE)

Placement$x <- ifelse(Placement$site %in% unique(df$site.x), 0, 1)

Placement$y[Placement$x==0] <- seq(1,0,length=sum(Placement$x==0))
Placement$y[Placement$x==1] <- seq(1,0,length=sum(Placement$x==1))

cols <- rep("red",nrow(df))
cols[df$bond.strength < 33] <- "green"
cols[df$bond.strength >= 33 & df$bond.strength < 66] <- "yellow"

# Empty plot:
par(mar=c(0,0,0,0))
plot(1,type="n",xlim=c(-0.2,1.6),ylim=c(0,1),bty="n",axes=FALSE,xlab="",ylab="")
abline(v=c(0,1))
text(Placement$x + ifelse(Placement$x==0,-0.1,0.1),Placement$y,Placement$site)

for (i in 1:nrow(df))
{
  lines(c(0,1),Placement$y[c(match(df$site.x[i],Placement$site),match(df$site.y[i],Placement$site))],col=cols[i],lwd=2)
}

legend("right",col=c("green","yellow","red"),lty=1,lwd=2,legend=c("0-33","33-66","66-100"),title="bondstrength",cex=1.5,bty="n")
-------------------------------------------------------------------------------------------------------
h<-hist(data, breaks="FD", col="red", xlab="xTitle", main="Normal pdf and     histogram")
xfit<-seq(min(data),max(data),length=100)
x.norm<-rnorm(n=100000, mean=a, sd=b)
yfit<-dnorm(xfit,mean=mean(x.norm),sd=sd(x.norm))
yfit <- yfit*diff(h$mids[1:2])*length(loose_All)
lines(xfit, yfit, col="blue", lwd=2)
-------------------------------------------------------------------------------------------------------
require(plotrix)
 y<-runif(10)
 err<-runif(10)
 plotCI(1:10,y,err,2*err,lwd=2,col="red",scol="blue", 
                  main="Add colors to the points and error bars")
 lines(1:10, y)
-------------------------------------------------------------------------------------------------------
ROC ROC ROC ROC2 if (any(!is.na(match("ROC", toupper(plot))))) {
        plot(1 - res[, 2], res[, 1], xlim = 0:1, xlab = "1-Specificity", 
            ylim = 0:1, ylab = "Sensitivity", type = "n", ...)
        if (is.numeric(grid)) 
            abline(h = grid/100, v = grid/100, col = gray(0.9))
        abline(0, 1, col = gray(0.4))
        box()
       
-------------------------------------------------------------------------------------------------------
i <- seq(1 : length(y))
m <- cumsum(y)/i

se_y <- sqrt((1/(i-1)*cumsum(y^2) - i/(i-1)*m^2))

error <- qnorm(0.975)*se_y/sqrt(i)
lower <- m - error
upper <- m + error

# equivalent (slightly slower) methods for getting the std. errors

# method2:
se_2 <- rep(NA, length(y))
for (n in 1:length(y))  {
  se_2[n] <- sd(y[1:n])
}
# method3:
se_3 <- sapply(1:length(y), FUN= function(x) sd(y[1:x])) # plotting means and ci's against sample size (= up to 10000)
plot(x=i, y=m, xlab="Number of iterations (sample size)", 
title("Convergence of the ENVP's mean"), 
ylab="E[y] estimates and 95% CI's (EUR millions)", cex=0.4, ylim=c(2620, 2665))
lines(lower, col="gold")
lines(upper, col="gold")
legend("bottomright", legend=c("envp's mean", "95% ci"),
cex=0.8, col=c("black", "gold"), lwd=2, lty=1, bty="n")

dev.copy(tiff, file="mc_envp.tiff", height=6, width=6, units="in", res=200)
dev.off(); dev.off()
windows.options(reset=TRUE)
-------------------------------------------------------------------------------------------------------
grid.points() grid.lines() "native" "npc" args(grid.lines)
# function (x = unit(c(0, 1), "npc"), y = unit(c(0, 1), "npc"), 
#     default.units = "npc", arrow = NULL, name = NULL, gp = gpar(), 
#     draw = TRUE, vp = NULL)     
args(grid.points)
# function (x = stats::runif(10), y = stats::runif(10), pch = 1, 
#     size = unit(1, "char"), default.units = "native", name = NULL, 
#     gp = gpar(), draw = TRUE, vp = NULL) grid.lines() grid.points() grid.lines(x, y, gp = gpar(col = "red"), default.units = "native")
-------------------------------------------------------------------------------------------------------
zoo set.seed(1)
xz = zoo(ts(rnorm(20), frequency = 4, start = c(1959, 2)))
yz = zoo(ts(rnorm(20), frequency = 4, start = c(1959, 2)))
# Basic approach
plot(xz)
lines(yz, col = "red")
# Panels
plot.zoo(cbind(xz, yz))
# Overplotted
plot.zoo(cbind(xz, yz), 
         plot.type = "single", 
         col = c("red", "blue")) ts ts.plot set.seed(1)
x = ts(rnorm(20), frequency = 4, start = c(1959, 2))
y = ts(rnorm(20), frequency = 4, start = c(1959, 2))
ts.plot(x, y, gpars = list(col = c("black", "red")))
-------------------------------------------------------------------------------------------------------
ylim=(...) xlim=(...) layout(matrix(1:2, ncol=1))
par(mai=c(0.5, 1, 0.5, 1))

plot(c(-6, 6), 0:1, type="n", ylim=c(0, 1), xlab="", ylab="")
lines(density(x1), ylim=c(0, 1))

plot(c(-6, 6), 0:1, type="n", ylim=c(1, 0), xlab="", ylab="")
lines(density(x2), col="red", ylim=c(1, 0))
-------------------------------------------------------------------------------------------------------
x1 <- rnorm(100)
x2 <- rnorm(100, mean=2)
dens1 <- density(x1)
dens2 <- density(x2)
dens2$y <- dens2$y * -1
plot(dens1, 
     ylim = range(c(dens1$y, dens2$y)),
     xlim = range(c(dens1$x, dens2$x)),
     main = "",
     xlab = "")
lines(dens2, col = "red")
-------------------------------------------------------------------------------------------------------
plot(den2 <-density(absy2), type="l", axes=FALSE, xlab = "", ylab = "", main="", col="red")
lines(den1 <-density(absy1), col="blue") with( den1, polygon(x=c(0, x[x < 1],   rev(x[x<1]), 0),  y=c(0, 0*x[x < 1], rev(y[x<1]), 0), col="red") )
-------------------------------------------------------------------------------------------------------
ranges <-  apply(MyData, 2,
             function(x) { dens <- density(x); c(range(dens$x), range(dens$y)) })

plot(density(MyData$samp1), col="red",
       xlim = range(ranges[1:2, ]), ylim = range(ranges[3:4, ])) 
lines(density(MyData$samp2), col="green") 
lines(density(MyData$samp3), col="blue")
-------------------------------------------------------------------------------------------------------
library(decon) # for DeconPdf
library(deamer) # for deamerKE

set.seed(12345)
shape=5; scale=1; mu=0; sd=0.2

x <- rweibull(5000, shape=shape, scale=scale)
noise <- rnorm(5000, mean=mu, sd=sd)
y=x+noise
curve(dweibull(x,shape,scale),lwd=2, from = 0, to = 2)

est <- deamerKE(y, noise.type="Gaussian", mu=mu, sigma=sd, from=0, to=2)
lines(est)

estDecon <- DeconPdf(y, sd, error="normal", fft=TRUE)
lines(estDecon, lty=2)

legend('topright', lty=c(1,1,2), lwd=c(2,1,1), 
    legend=c("true", "deamerKE", "DeconPdf"))
-------------------------------------------------------------------------------------------------------
d <- data.frame(x=c(1,4,5,7),
                y=c(0.8,4.2,4.7,8)) lm1 <- lm(y~x,data=d) p_conf1 <- predict(lm1,interval="confidence")
p_pred1 <- predict(lm1,interval="prediction") nd <- data.frame(x=seq(0,8,length=51))
p_conf2 <- predict(lm1,interval="confidence",newdata=nd)
p_pred2 <- predict(lm1,interval="prediction",newdata=nd) plot(y~x,data=d,ylim=c(-5,12),xlim=c(0,8)) ## data
abline(lm1) ## fit
matlines(d$x,p_conf1[,c("lwr","upr")],col=2,lty=1,type="b",pch="+")
matlines(d$x,p_pred1[,c("lwr","upr")],col=2,lty=2,type="b",pch=1)
matlines(nd$x,p_conf2[,c("lwr","upr")],col=4,lty=1,type="b",pch="+")
matlines(nd$x,p_pred2[,c("lwr","upr")],col=4,lty=2,type="b",pch=1) confint type="terms" interval="none"
-------------------------------------------------------------------------------------------------------
dashboard <- function(dial=list(
                        list(color="red",
                             range=c(10, 40)),
                        list(color="yellow",
                             range=c(40, 60)),
                        list(color="green",
                             range=c(70, 100))
                        ),
                      value=from) {


  from <- min(unlist(lapply(dial, "[[", i="range")))
  to <-  max(unlist(lapply(dial, "[[", i="range")))

  theta <- seq(-pi/3, pi + pi/3, length=100)
  r <- 1

  scale <- function(x) {
    m <- (pi + pi/3 - (-pi/3))/(from - to)
    (pi + pi/3) + m*(x - from)
  }

  plot.new()
  plot.window(xlim=c(-1, 1), ylim=c(sin(-pi/3), 1))

  lines(cos(theta), sin(theta))sapply(dial, function(l) {d <- scale(l$range)x <- seq(d[1], d[2], length=100)
    lines(cos(x), sin(x), col=l$color, lwd=3)
  })

  ticks <- pretty(c(from, to), n=5)
  ticks_th <- scale(ticks)
  r <- 1 - .15
  text(r*cos(ticks_th), r*sin(ticks_th), labels=ticks)

  sapply(ticks_th, function(th) {
    lines(cos(th)*c(1,.95), sin(th)*c(1, .95))})

  r <- 1 - .25
  th <- scale(value)
  arrows(0, 0, cos(th), sin(th))


}

dashboard( value=60)
-------------------------------------------------------------------------------------------------------
getURL() readlines() out <- postForm("https://the.api.com/api", token="abcd", format="csv")
mydf <- read.table(textConnection(out),header=TRUE,sep=",",quote="\"")
-------------------------------------------------------------------------------------------------------
hist(index$LogNR, breaks = 100, prob=T)
mean_DJ = mean(index$LogNR, na.rm=T);
sd_DJ = sd(index$LogNR, na.rm=T);
#For the normal curve
curve(dnorm(x, mean_DJ, sd_DJ), add=T, col = "grey", lwd = 2)
#For kernel density
nsity(index$LogNR, na.rm=T), col = "blue", lwd = 2) index <- read.table(text="      Date  Close        LogNR
1  9/24/2012 690.79 -0.013373028
2  9/21/2012 700.09  0.001987433
3  9/20/2012 698.70 -0.004854378
4  9/19/2012 702.10  0.000270653
5  9/18/2012 701.91  0.003039191
6  9/17/2012 699.78  0.012221048
7  9/14/2012 691.28  0.012079375
8  9/13/2012 682.98  0.019501346
9  9/12/2012 669.79  0.013830855
10 9/11/2012 660.59 -0.003249381
11 9/10/2012 662.74 -0.026356891
12  9/7/2012 680.44  0.006147243
13  9/6/2012 676.27  0.008971468
14  9/5/2012 670.23 -0.007047308
15  9/4/2012 674.97  0.014520368
16 8/31/2012 665.24  0.002061531
17 8/30/2012 663.87 -0.014357104
18 8/29/2012 673.47 -0.001972899
19 8/28/2012 674.80 -0.001303241
20 8/27/2012 675.68  0.018612831
21 8/24/2012 663.22  0.000889995
22 8/23/2012 662.63 -0.009372956
23 8/22/2012 668.87  0.019337473
24 8/21/2012 656.06 -0.013760331
25 8/20/2012 665.15  0.025952144
26 8/17/2012 648.11  0.018327423
27 8/16/2012 636.34  0.008696599
28 8/15/2012 630.83 -0.001362355
29 8/14/2012 631.69  0.002678948
30 8/13/2012 630.00  0.013262158
", header=TRUE)
-------------------------------------------------------------------------------------------------------
polygon y98 = aggregate(gcdata$Pause.s. ~ hours, data=gcdata, FUN=q98)
y02 = aggregate(gcdata$Pause.s. ~ hours, data=gcdata, FUN=q02)
ymax = aggregate(gcdata$Pause.s. ~ hours, data=gcdata, FUN=max)
ymin = aggregate(gcdata$Pause.s. ~ hours, data=gcdata, FUN=min)
ymean = aggregate(gcdata$Pause.s. ~ hours, data=gcdata, FUN=mean)

x = ymean[,1]
y1 = cbind(y02[,2], ymean[,2], y98[,2])
y2 = cbind(ymin[,2], ymean[,2], ymax[,2])

plotAreaCI(x,y2, ylim=c(0,2), xlab="time", ylab="variable")
plotAreaCI(x,y1, ylim=c(0,2), poly.col="blue", add=TRUE) plotAreaCI(x,y2, ylim=c(0,2), xlab="time", ylab="variable", nice.x = TRUE)
plotAreaCI(x,y1, ylim=c(0,2), mean.lwd=2, poly.col="blue", add=TRUE) plotAreaCI plotAreaCI = function(x, y, add=FALSE, nice.x = FALSE,
                          xlim=NULL, ylim=NULL,
                          mean.col="black", mean.lwd=1.5,
                          poly.col="gray", poly.lty=3,
                          xlab=NULL, ylab=NULL, main="",
                          ...) {
      isFactorX = isClass("factor", x)
      if(isFactorX) {
        x.label = x
        x = as.numeric(x)
      }
      if(is.null(xlim)) xlim=range(x, na.rm=TRUE)
      if(is.null(ylim)) ylim=range(y, na.rm=TRUE)
      x.pol = c(x, rev(x), x[1])
      y.pol = c(y[,1], rev(y[,3]), y[,1][3])
      if(!add) {
        plot.new()
        plot.window(xlim=xlim, ylim=ylim, ...)
        if(!nice.x & isFactorX) {
          axis(1, at=x, labels=x.label)
        } else {
          xticks = axTicks(1)
          if(isFactorX) {
            xticks = xticks[xticks>=1]
            axis(1, at=xticks, labels=x.label[xticks])
          } else {
            axis(1)
          }
        }
            axis(2, las=1)
        box()
        title(xlab=xlab, ylab=ylab, main=main)
      }
      polygon(x.pol, y.pol, col=poly.col, lty=poly.lty)
      lines(x, y[,2], col=mean.col, lwd=mean.lwd)
      return(invisible())
    }
-------------------------------------------------------------------------------------------------------
plotAreaCorridor = function(x, y, col.poly1="lightgray", col.poly2="gray",...) {
   x.pol = c(x, rev(x), x[1])
   y.pol = c(y[,1], rev(y[,5]),y[,1][1])
   plot(x, y[,6]+1, type="n", ...) # ugly since type="n" does not work for factor
   polygon(x.pol, y.pol, col=col.poly1, lty=0)

   x.pol = c(x, rev(x), x[1])
   y.pol = c(y[,2], rev(y[,4]), y[,1][1])
   polygon(x.pol, y.pol, col=col.poly2, lty=0)

   lines(x, y[,3], col="blue") # median
   lines(x, y[,6], col="red")  # max

   return(invisible())
}
pause = gcdata$Pause.s.
hours = droplevels(cut(gcdata$date, breaks="hours")) # can I have 2 hours?
agg = aggregate(pause ~ hours, FUN=quantile, probs=c(5,20,50,80,95,100)/100)
x = agg$hours
ys = agg$pause
q99 <- function(x, ...) {  x <- quantile(x,probs=c(0.99)) }  
v99 = q99(gcdata$Pause.s.)
vmed = median(gcdata$Pause.s.)
plotAreaCorridor(x, ys,ylim=c(0,v99*1.5))
abline(h=vmed, col="lightblue")
abline(h=v99, col="grey")
label=paste("99%=",round(v99,digits=3),"s n=", length(gcdata$date),sep="")
text(x=30, y=v99, label, col="grey", pos=3)
title("NewPar Collection Activity")
-------------------------------------------------------------------------------------------------------
period.apply() endpoints() library(zoo)                                # for zoo objects
library(xts)                                # for period.apply

gcdata <- read.table("http://bernd.eckenfels.net/view/gc1001.ygc.csv",
                     header=TRUE, sep=",", dec=".")
timestamps <- gcdata$Timestamp + 
              as.POSIXct(strptime("2012-01-01 00:00:00", 
                         format="%Y-%m-%d %H:%M:%S"))
gcdatazoo <- zoo(gcdata[-1], order.by=timestamps)    # as zoo object zoo plotAreaCorridor <- function(x, y, col.poly1="lightgray", col.poly2="gray",...) {
    x.pol <- c(x, rev(x), x[1])
    y.pol <- c(y[,1], rev(y[,5]),y[,1][1])
    plot(x, y[,6]+1, type="n", ...) 
    polygon(x.pol, y.pol, col=col.poly1, lty=0)

    x.pol <- c(x, rev(x), x[1])
    y.pol <- c(y[,2], rev(y[,4]), y[,1][1])
    polygon(x.pol, y.pol, col=col.poly2, lty=0)

    lines(x, y[,3], col="blue") # median
    lines(x, y[,6], col="red")  # max

    invisible(NULL)
} agg <- period.apply(gcdatazoo[,"Pause.s."],               # to which data
                    INDEX=endpoints(gcdatazoo, "hours", k=2), # every 2 hours
                    FUN=function(x) quantile(x,               # what fun.
                                             probs=c(5,20,50,80,95,100)/100)) 

#v99 = q99(gcdata$Pause.s.)        # what is q99 ?
v99 <- mean(agg[,5])                  # mean of 95-th percentile?
plotAreaCorridor(index(agg),          # use time index as x axis
                 coredata(agg),       # and matrix part of zoo object as data
                 ylim=c(0,max(agg[,5])*1.5),
                 ylab="Quantiles of GC events",
                 main="NewPar Collection Activity")
abline(h=median(gcdatazoo[,"Pause.s."]), col="lightblue")
abline(h=v99, col="grey")
labeltxt <- paste("99%=",round(v99,digits=3),"s n=", nrow(gcdatazoo),sep="")
text(x=index(agg)[20], y=1.5*v99, labeltxt, col="grey", pos=3)  # or legend()
-------------------------------------------------------------------------------------------------------
tkexamp color.scale.lines library(TeachingDemos)
library(plotrix)

tmpfun <- function(start,numpoints=10) {
    plot(ccc$Lon,ccc$Lat, xlab='Longitute', ylab='Lattitude', type='n')
    to <- min(nrow(ccc), start+numpoints)
    color.scale.lines( ccc$Lon[start:to], ccc$Lat[start:to], c(0.7,0), c(0.7,0), c(0.7,0), colvar=seq_len(numpoints) )
}

tmplist <- list( numpoints=list('spinbox', init=10, from=1, to=nrow(ccc)),
                 start=list('animate',init=1, from=1, to=nrow(ccc)) )

tkexamp( tmpfun, tmplist ) tmpfun2 <- function(start, dur=120) {
    time <- as.numeric(h2h$Time3)
    fr <- which( time >= start )[1]
    if( is.na(fr) ) fr <- nrow(h2h)-1
    to <- which( time >= start+dur )[1]
    if( is.na(to) ) to <- nrow(h2h)
    plot(h2h$Lon, h2h$Lat, xlab='Longitute', ylab='Lattitude',
     type='n', main=paste('Times',time[fr],'to',time[to]) )
    color.scale.lines( h2h$Lon[fr:to], h2h$Lat[fr:to], c(0.7,0), c(0.7,0), c(0.7,0), colvar=time[fr:to])
}

tmplist2 <- list( dur=list('spinbox', init=120, from=10, to=1200),
                start=list('animate',init=0, from=0, to=1780, delay=100,
                            resolution=10) )

tkexamp( tmpfun2, tmplist2 )
-------------------------------------------------------------------------------------------------------
xkcd_line <- function(x, y, color) {
  len <- length(x);
  rg <- par("usr");
  yjitter <- (rg[4] - rg[3]) / 1000;
  xjitter <- (rg[2] - rg[1]) / 1000;
  x_mod <- x + rnorm(len) * xjitter;
  y_mod <- y + rnorm(len) * yjitter;
  lines(x_mod, y_mod, col='white', lwd=10);
  lines(x_mod, y_mod, col=color, lwd=5);
} xkcd_axis <- function() {
  rg <- par("usr");
  yaxis <- 1:100 / 100 * (rg[4] - rg[3]) + rg[3];
  xaxis <- 1:100 / 100 * (rg[2] - rg[1]) + rg[1];
  xkcd_line(1:100 * 0 + rg[1] + (rg[2]-rg[1])/100, yaxis,'black')
  xkcd_line(xaxis, 1:100 * 0 + rg[3] + (rg[4]-rg[3])/100, 'black')
} data <- data.frame(x=1:100)
data$one <- exp(-((data$x - 50)/10)^2)
data$two <- sin(data$x/10)
plot.new()
plot.window(
    c(min(data$x),max(data$x)),
    c(min(c(data$one,data$two)),max(c(data$one,data$two))))
xkcd_axis()
xkcd_line(data$x, data$one, 'red')
xkcd_line(data$x, data$two, 'blue')
-------------------------------------------------------------------------------------------------------
resid(model) library(dynlm)
x <- 10+rnorm(100)
y <- 10+rnorm(100)
model <- dynlm(x ~ y)

plot(x, type="l", col="red", ylim=c(min(c(x,y,resid(model))), max(c(x,y,resid(model)))))
lines(y, type="l", col="green")
lines(resid(model), type="l", col="blue")
-------------------------------------------------------------------------------------------------------
library(dynlm)
set.seed(771104)
x <- 5 + seq(1, 10, len=100) + rnorm(100)
y <- x + rnorm(100)
model <- dynlm(x ~ y)

par(oma=c(1,1,1,2))
plotModel(x, model) # works with models which accept 'predict' and 'residuals' plotModel plotModel =  function(x, model) {
  ymodel1 = range(x, fitted(model), na.rm=TRUE)
  ymodel2 = c(2*ymodel1[1]-ymodel1[2], ymodel1[2])
  yres1   = range(residuals(model), na.rm=TRUE)
  yres2   = c(yres1[1], 2*yres1[2]-yres1[1])
  plot(x, type="l", col="red", lwd=2, ylim=ymodel2, axes=FALSE,
       ylab="", xlab="")
  axis(1)
  mtext("residuals", 1, adj=0.5, line=2.5)
  axis(2, at=pretty(ymodel1))
  mtext("observed/modeled", 2, adj=0.75, line=2.5)
  lines(fitted(model), col="green", lwd=2)
  par(new=TRUE)
  plot(residuals(model), col="blue", type="l", ylim=yres2, axes=FALSE, 
       ylab="", xlab="")
  axis(4, at=pretty(yres1))
  mtext("residuals", 4, adj=0.25, line=2.5)
  abline(h=quantile(residuals(model), probs=c(0.1,0.9)), lty=2, col="gray")
  abline(h=0)
  box()  
}
-------------------------------------------------------------------------------------------------------
Dataset_1$timestamp <- strptime(paste(Dataset_1$Day, Dataset_1$Month, 
                                Dataset_1$Year, sep="-"), format="%d-%m-%Y")
Dataset_2$timestamp <- strptime(paste(Dataset_2$Hour, Dataset_2$Day, 
                                Dataset_2$Month, Dataset_2$Year, sep="-"), 
                                format="%H:%M-%d-%m-%Y") plot plot(Dataset_1$timestamp, Dataset_1$Value)
lines(Dataset_2$timestamp, Dataset_2$Value)
-------------------------------------------------------------------------------------------------------
>>> src = "ARGHISLEULEULYS"
>>> trans = {'ARG':'R', 'HIS':'H', 'LEU':'L', 'LYS':'K'}
>>> "".join(trans[src[x:x+3]] for x in range(0, len(src), 3))
'RHLLK' trans trans table Ala A
Arg R
Asn N
Asp D
Cys C
Glu E
Gln Q
Gly G
His H
Ile I
Leu L
Lys K
Met M
Phe F
Pro P
Ser S
Thr T
Trp W
Tyr Y
Val V trans = dict((l.upper(), s) for l, s in
             [row.strip().split() for row in open("table").readlines()])
-------------------------------------------------------------------------------------------------------
par(mfrow=c(1,2))
d1 = rnorm(100);d2 = rnorm(100);
hist(d1);hist(d2) plot(density(d1))
lines(density(d2), col=2) hist(d1, freq=FALSE)
lines(density(d2), col=2)
-------------------------------------------------------------------------------------------------------
ksmooth bandwidth x ksmooth x Date ksmooth x x x1 = seq(as.POSIXct("2000-01-01", tz="GMT"),
       as.POSIXct("2010-12-31", tz="GMT"),
       by="month")
x2 = c(1:length(x1)) 
set.seed(1)
y = runif(length(x1))

plot(x1,y,type='l')
smooth = ksmooth(x2,y,"normal")     
lines(x1,smooth$y,col='blue',lwd=2)
lines(x1,ksmooth(x2,y,'normal',bandwidth=2)$y,col='red',lwd=2)
lines(x1,ksmooth(x2,y,'normal',bandwidth=10)$y,col='green',lwd=2)
lines(x1,ksmooth(x2,y,'normal',bandwidth=20)$y,col='orange',lwd=2)
-------------------------------------------------------------------------------------------------------
ggplot2 #some data with a linear model
x <- 1:20
set.seed(1)
y <- 3*log(x)+5+rnorm(20)

#plot data
plot(y~x)

#fit log model
fit <- lm(y~log(x))
#look at result and statistics
summary(fit)
#extract coefficients only
coef(fit)

#plot fit with confidence band
matlines(x=seq(from=1,to=20,length.out=1000),
         y=predict(fit,newdata=list(x=seq(from=1,to=20,length.out=1000)),
                   interval="confidence")) #some data with a non-linear model
set.seed(1)
y <- log(0.1*x)+rnorm(20,sd=0.1)

#plot data
plot(y~x)

#fit log model
fit <- nls(y~log(a*x),start=list(a=0.2))
#look at result and statistics
summary(fit)

#plot fit
lines(seq(from=1,to=20,length.out=1000),predict(fit,newdata=list(x=seq(from=1,to=20,length.out=1000))))
-------------------------------------------------------------------------------------------------------
library(png)

#Replace the directory and file information with your info
ima <- readPNG("C:\\Documents and Settings\\Bill\\Data\\R\\Data\\Images\\sun.png")

#Set up the plot area
plot(1:2, type='n', main="Plotting Over an Image", xlab="x", ylab="y")

#Get the plot information so the image will fill the plot box, and draw it
lim <- par()
rasterImage(ima, lim$usr[1], lim$usr[3], lim$usr[2], lim$usr[4])
grid()
lines(c(1, 1.2, 1.4, 1.6, 1.8, 2.0), c(1, 1.3, 1.7, 1.6, 1.7, 1.0), type="b", lwd=5, col="white")
-------------------------------------------------------------------------------------------------------
splines::bs() degree=2 degree=3 library(splines)

## Some example data
set.seed(1)
x <- 1:10
y <- rnorm(10)

## Fit a couple of quadratic splines with different degrees of freedom
f1 <- lm(y ~ bs(x, degree = 2))  # Defaults to 2 - 1 = 1 degree of freedom
f9 <- lm(y ~ bs(x, degree = 2, df=9))

## Plot the splines
x0 <- seq(1, 10, by = 0.1)
plot(x, y, pch = 16)
lines(x0, predict(f1, data.frame(x = x0)), col = "blue")
lines(x0, predict(f9, data.frame(x = x0)), col = "red")
-------------------------------------------------------------------------------------------------------
hist density hist(x, prob=TRUE)
lines(density(x))
-------------------------------------------------------------------------------------------------------
plot(IQ~isAtheist)
lines(x=c(1,2), y=predict( lm(IQ~isAtheist), newdata=list(isAtheist=c("NO","YES") ) ) ,col="red", type="b") as.numeric(factor(isAtheist)) abline set.seed(123)
 isAtheist=factor(c("NO","YES")[1+rep( c(0,1), 50 )])
 plot(IQ~isAtheist)
     lines(x=c(1,2), y=predict( lm(IQ~isAtheist), newdata=data.frame(isAtheist=c("NO","YES") ) ) ,col="red", type="b")
-------------------------------------------------------------------------------------------------------
replicate colSums for apply mean(pvals<=alpha) sum(pvals<=alpha)/length(alpha) sapply for powfun <- function(ssize=100,
                   m=1000,      ## samples per trial
                   popmean=120, ## pop mean
                   popvar=225,  ## known/established pop variance
                   newvar=144,  ## variance of new methodology
                   alpha=0.01,
                   sampchisq=FALSE)  ## sample directly from chi-squared distrib?
{
    if (!sampchisq) {
      ymat <- matrix(rnorm(ssize*m,popmean,sd=sqrt(newvar)),ncol=m)
      ts <- colSums((ymat-popmean)^2/popvar)          ## test statistic
    } else {
      ts <- rchisq(m,df=ssize)*newvar/popvar
    }
    pvals <- pchisq(ts,df=ssize)                    ## pval
    mean(pvals<=alpha)                              ## power
} ssizevec <- seq(10,250,by=5)
set.seed(101)
system.time(powvec <- sapply(ssizevec,powfun,m=5000))  ## 13 secs elapsed m=1e5 m=5000 sapply(ssizevec,powfun,m=5000) library(plyr); aaply(ssizevec,.margins=1,powfun,.progress="text",m=5000) rchisq(m,df=ssize)*newvar/popvar system.time(powvec2 <- sapply(ssizevec,powfun,m=5000,sampchisq=TRUE))
## 0.24 seconds elapsed m=1e5 par(bty="l",las=1)
plot(ssizevec,powvec,type="l",xlab="sample size",ylab="power",
     xlim=c(0,250),ylim=c(0,1))
lines(ssizevec,powvec2,col="red")
-------------------------------------------------------------------------------------------------------
zoomplot TeachingDemos fplot <- function(x, y = NULL, type = "l", new = NULL, xlim, ylim, zoom = TRUE,...){
   require(TeachingDemos)
   if (is.null(y)){
if (length(dim(x)) == 2){
    y = x[,2]
    x = x[,1]
} else {
       y = x
       x = 1:length(y)
     } 
}

   if ( is.null(new) ){
   #determine whether to make a new plot or not
   new = FALSE
   if (is.null(recordPlot()[[1]])) new = TRUE
   }
   if (missing(xlim)) xlim = range(x)
   if (missing(ylim)) ylim = range(y)

   if (new){
   plot(x, y, type = type, xlim = xlim, ylim = ylim, ...)
   } else {
    if (type == "p"){
        points(x,y, ...)
    } else {
        lines(x,y, type = type, ...)
    }
    if (zoom){
    #rescale plot
    xcur = par("usr")[1:2]
    ycur = par("usr")[3:4]
    #shrink coordinates and pick biggest
    xcur = (xcur - mean(xcur)) /1.08 + mean(xcur)
    ycur = (ycur - mean(ycur)) /1.08 + mean(ycur)
    xlim = c(min(xlim[1], xcur[1]), max(xlim[2], xcur[2]))
    ylim = c(min(ylim[1], ycur[1]), max(ylim[2], ycur[2]))
    #zoom plot
    zoomplot(xlim, ylim)
    }
   }
 } dev.new()
fplot(1:4)
fplot(1:4 +1, col = 2)
fplot(0:400/100 + 1, sin(0:400/10), type = "p")
dev.new()
for (k in 1:20) fplot(sort(rnorm(20)), type = "b", new = (k==1) )
-------------------------------------------------------------------------------------------------------
from rpy2.robjects.vectors import IntVector
r.lines(x, IntVector(y) - 500, col = "green")
-------------------------------------------------------------------------------------------------------
polygon() polygon(c(myd$xvar[20:40], myd$xvar[40:20]),c(myd$yvarL[20:40],
 myd$yvarU[40:20]), col="gray") points(myd$xvar,myd$yvar,pch=19,cex=.75,col="blue")
points(myd$xvar,myd$yvarL,col="gray", pch=19,cex=.5)
points(myd$xvar,myd$yvarU,col="gray", pch=19,cex=.5) index <- which(myd$xvar>=200 & myd$xvar<=400) polygon(c(myd$xvar[index], myd$xvar[rev(index)]),c(myd$yvarL[index], 
 myd$yvarU[rev(index)]), col="gray") lines(myd$xvar[index],myd$yvar[index],pch=19,cex=.75,col="blue",type="o")
points(myd$xvar,myd$yvarL,col="gray", pch=19,cex=.5)
points(myd$xvar,myd$yvarU,col="gray", pch=19,cex=.5)
-------------------------------------------------------------------------------------------------------
readlines('enter something') readlines readlines read.table scan foo<-function(){
 + readline('enter data: ')->foostuff
 + return(foostuff)
 + }
 > foo()
 enter data: 4.30 56 hello world
 [1] "4.30 56 hello world"
-------------------------------------------------------------------------------------------------------
df$step <- 1

library(plyr)
df <- ddply(df,.(individual),transform,step=cumsum(step))

plot(step~events,data=df[df$individual==1,],type="s",xlim=c(0,max(df$events)),ylim=c(0,max(df$step)),xlab="time",ylab="step")
lines(step~events,data=df[df$individual==2,],type="s",col=2)
lines(step~events,data=df[df$individual==3,],type="s",col=3)
-------------------------------------------------------------------------------------------------------
require(tikzDevice)

tikz('normal.tex', standAlone = TRUE, width=5, height=5)

# Normal distribution curve
x <- seq(-4.5,4.5,length.out=100)
y <- dnorm(x)

# Integration points
xi <- seq(-2,2,length.out=30)
yi <- dnorm(xi)

# plot the curve
plot(x,y,type='l',col='blue',ylab='$p(x)$',xlab='$x$')
# plot the panels
lines(xi,yi,type='s')
lines(range(xi),c(0,0))
lines(xi,yi,type='h')

#Add some equations as labels
title(main="$p(x)=\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{x^2}{2}}$")
int <- integrate(dnorm,min(xi),max(xi),subdivisions=length(xi))
text(2.8, 0.3, paste("\\small$\\displaystyle\\int_{", min(xi),
    "}^{", max(xi), "}p(x)dx\\approx", round(int[['value']],3),
    '$', sep=''))

#Close the device
dev.off()

# Compile the tex file
tools::texi2dvi('normal.tex',pdf=T)
-------------------------------------------------------------------------------------------------------
smooth.spline lines plot.spline = function(x, y, ...) {
    s = smooth.spline(x, y, cv=TRUE)
    lines(predict(s), ...)
} plot.spline bootstrap.curves = function(dat, nboot, ...) {
    for (i in 1:nboot) {
        subdata = dat[sample(NROW(dat), replace=TRUE), ]
        plot.spline(subdata$age, subdata$spnbmd, ...)
    }
} bootstrap.curves(dat2[dat2$gender == "female", ], 10, col="red")
bootstrap.curves(dat2[dat2$gender == "male", ], 10, col="blue") 1: In smooth.spline(x, y, cv = TRUE) :
  crossvalidation with non-unique 'x' values seems doubtful smooth.spline x
-------------------------------------------------------------------------------------------------------
plot(x=seq(20, 65, by=5), predict( mlogit, 
                    newdata=data.frame(Drug="Y", Environment="H", Ethnicity="White",
                   Age=seq(20, 65, by=5) ), type="response" ) )
lines(x=seq(20, 65, by=5), predict( mlogit, 
                   newdata=data.frame(Drug="N", Environment="L", Ethnicity="White",
                   Age=seq(20, 65, by=5) ), type="response" ) )
-------------------------------------------------------------------------------------------------------
set.seed(001)
DF <- data.frame(matrix(rnorm(400, 100, 12), ncol=4)) # some data
den<-apply(DF, 2, density) # estimating density


par(mfrow=c(2,2))
sapply(den, plot) # plot each density
par(mfrow=c(1,1)) par(mfrow=c(2,2))
for(i in 1:length(den)){
  plot(den[[i]], 
       main=paste('density ', i))
}
par(mfrow=c(1,1)) par(mfrow=c(2,2)) sapply(den, plot) plot(den[[1]], ylim=c(0,.04), 
     main='Densities altogether') # plot the first density
for(i in 2:length(den)){          # Add the lines to the existing plot
  lines(den[[i]], col=i)          
} legend legend('topright', paste('density ', 1:4), col=1:4, lty=1, cex=.65)
-------------------------------------------------------------------------------------------------------
plotline <- function(df1,df2) {

  minX = min(df1$x, df2$x)
  minY = min(df1$y, df2$y)
  maxX = max(df1$x, df2$x)
  maxY = max(df1$y, df2$y)

  plot (df1, xlim=c(minX, maxX), ylim=c(minY, maxY))
  lines(df2)
} plotline(firstdf,seconddf) ...
-------------------------------------------------------------------------------------------------------
grDevices::devAskNewPage(ask = TRUE) readline abline plot(y) myFun <- function() {
     x = rnorm(20)
        y = 7*x^2 - 0.5*x + rnorm(20)
    y.0 = lm(y ~ 1)
    plot(y)
       # We'd get the same constant by just doing mean(y), but fitting it as a
       # regression model means functions like residuals() and predict() are
       # available for use later, the same as our other models
    abline(h=y.0$coefficients[1])
    # Get evenly spaced points for pretty plotting of other models
    d = seq(min(x),max(x),length.out=200)
    # Fit polynomials of order 1 to 9
    # It would be nicer if we let this run from 0 to 9, but R doesn't allow us to do a polynomial of degree 0
    for (degree in 1:9) {
        fm = lm(y ~ poly(x,degree))
        # Store the results in models called y.1, y.2, through y.9
        # The assign/paste trick here is often useful for storing results
            # which do not fit well into arrays!
            # check: y.1; y.2;...
        assign(paste("y",degree,sep="."), fm)
        # Plot them, with different line types
        readline('Press return to see the next line added')
        lines(d, predict(fm, data.frame(x=d)), lty=(degree+1))
    }

        x.new = rnorm(2e4)
        y.new = 7*x.new^2 - 0.5*x.new + rnorm(2e4)
        plot(x.new,y.new,xlab="x",ylab="y",pch=24,cex=0.1,col="blue")
        curve(7*x^2-0.5*x,col="grey",add=TRUE)  # the old curve
        abline(h=y.0$coefficients[1])
        d = seq(from=min(x.new),to=max(x.new),length.out=200)
        for (degree in 1:9) {
           fm = get(paste("y",degree,sep="."))
           readline('Press return to see the next line added')
           lines(d, predict(fm,data.frame(x=d)),lty=(degree+1))
        }
        points(x,y,col="red")
}
myFun()
-------------------------------------------------------------------------------------------------------
output$plot_Total <- reactivePlot(function() { 
  plot.new()
   plot.window(xlim=c(1850,2020), ylim = c(0,5000000))
   axis(1)
   axis(2)
   title(main="Numbers over the years")
   title(xlab="Year")
   title(ylab="Number of people")
   box()
   points(dat$Year, dat$Total, col="red")
   lines(dat$Year, dat$Total, col="red")
  if (input$RC) {   lines(dat$Year, dat$dat)}
  })
-------------------------------------------------------------------------------------------------------
par(new=TRUE) lines() par(new=TRUE) xlim survfit # Fake data for the plots
pump <- data.frame(TIME=rweibull(40, 2, 20),
                   CENSUS=runif(40) < .3,
                   DEVICE=rep(0:1, c(20,20)))
# load package
library("survival")

# Fit models
mfit.overall <-survfit(Surv(TIME, CENSUS==0) ~ 1, data=pump)
mfit.htx <- survfit(Surv(TIME, CENSUS==0) ~ 1, data=pump, subset=DEVICE==1)

# Plot
plot(mfit.overall, col=1, xlim=range(pump$TIME), fun=function(x) 1-x)
# `xlim` makes sure the x-axis is the same in both plots
# `fun` flips the curve to start at 0 and increase
par(new=TRUE)
plot(mfit.htx, col=2, xlim=range(pump$TIME), fun=function(x) 1-x,
    ann=FALSE, axes=FALSE, bty="n") # This hides the annotations of the 2nd plot
legend("topright", c("All", "HTX"), col=1:2, lwd=1)
-------------------------------------------------------------------------------------------------------
plot.new() lines() "surfit" plot(mfit.overall, col=1, xlim=range(pump$TIME), fun=function(x) 1-x)
lines(mfit.htx, col=2, fun=function(x) 1-x)
lines(mfit.htx, col=2, fun=function(x) 1-x, lty = "dashed", conf.int = "only")
legend("topleft", c("All", "HTX"), col=1:2, lwd=1, bty = "n") lines() lty lines() lines()
-------------------------------------------------------------------------------------------------------
glm lines test <- c(1.4, 2.3, 3.8, 3.6, 5.9, 5.4, 7.6, 7.4, 8.1, 8.7, 7.4, 6.9, 
5.4, 4.7, 2.7, 1.8, 1.1)

plot(test,type="l",ylim=c(0,12))
fit1 <- glm(test[1:8] ~ I(1:8))
fit2 <- glm(test[9:17] ~ I(1:9))

# ...$coefficients[2] is the slope, ...$coefficients[1] is the intercept
lines(1:9, 1:9 * fit1$coefficients[2] + fit1$coefficients[1],col="red")
lines(9:17,1:9 * fit2$coefficients[2] + fit2$coefficients[1],col="blue")
-------------------------------------------------------------------------------------------------------
nlmodel.plot <- plot(model.np, plot.behavior="data")

y.eval <- fitted(nlmodel.plot$r1) #fit partial regression model for r1=airnoise
y.se <- se(nlmodel.plot$r1) #grab SE from botstrap 
y.lower.ci <- y.eval + logp.se[,1] #lower CI
y.upper.ci <- y.eval + logp.se[,2] #upper CI

x1.eval <- nlmodel.plot$r1$eval[,1]  #grab x1 values saved in plot$r1

plot(x1,y)
 lines(x1.eval,y.eval)
 lines(x1.eval,y.lower.ci,lty=3)
 lines(x1.eval,y.upper.ci,lty=3)
-------------------------------------------------------------------------------------------------------
predict() df <- data.frame(y = c(1.4, 2.3, 3.8, 3.6, 5.9, 5.4, 7.6, 7.4, 8.1,
                       8.7, 7.4, 6.9, 5.4, 4.7, 2.7, 1.8, 1.1),
                 x = 1:17,
                 ind = rep(c(TRUE,FALSE), times = c(8,9)))

fit1 <- lm(y ~ x, data = df, subset = ind)
fit2 <- lm(y ~ x, data = df, subset = !ind)

## regions in a new data frame over which to predict
r1 <- data.frame(x = seq(from = 1, to = 8, length.out = 20))
r2 <- data.frame(x = seq(from = 9, to = 17, length.out = 20))

## predict
p1 <- predict(fit1, newdata = r1)
p2 <- predict(fit2, newdata = r2)

## add lines to plot
plot(y ~ x, data = df, type = "l")
lines(p1 ~ x, data = r1, col = "red")
lines(p2 ~ x, data = r2, col = "blue") predict()
-------------------------------------------------------------------------------------------------------
Value  Group
0      1
1      1
5      1
0      2
Etc. ggplot2 ggplot(yourdata, aes(x = xcoor, y = Value, color = Group)) + 
    geom_line() plot split_dat = with(yourdata, split(Value, Group))
plot(split_dat[[1]])
for(i in 2:length(split_dat)) {
   lines(split_dat[[i]])
 }
-------------------------------------------------------------------------------------------------------
lines plot ?lines ?points plot option$ option dat ?plot # draw original plot
plot(mean ~ p.move, dat=option, xlim=c(0,1), type="o", ylim=c(0,20),
     xlab="Probability",ylab="% time",col=1,lwd=1.85)

# draw extra lines (the '%' in the column names gets converted to '.' by R)
# note you can put your usual `plot` arguments into `lines` like lwd, type etc
# if you want
lines(upper95.CI ~ p.move, option)
lines(lower95.CI ~ p.move, option)
-------------------------------------------------------------------------------------------------------
df <- data.frame(s1=rnorm(100), s2=rnorm(100, mean=2), s3=rnorm(100, mean=-2)) foo <- boxplot(df, border=c(8,8,1), lwd=c(1,1,3)) aa <- 0.5
bb <- foo$stats[4,3]-foo$stats[2,3] tt <- seq(0,2*pi,by=.01)    
lines(3+aa*cos(tt),foo$stats[3,3]+bb*sin(tt))
-------------------------------------------------------------------------------------------------------
set.seed(001)    
low <- runif(10,min=10, max=50)

high <- runif(10,min=10000, max=11000)
plot(
  high,
  type="l",
  ylim=c(0,11000)
)
lines(low, type="l")


plot(high,            
     type="l",              
     col="red",              
     bty='l',                
     ylab='', xlab='',      
     las=1,                 
     cex.axis=.75)     

par(new=TRUE)                

plot(low,
     type="l", 
     col="blue", 
     bty='n',                
     xaxt="n",               
     yaxt="n",               
     xlab="", ylab="", 
     cex.axis=.75)

axis(4, las=1, cex.axis=.75) 

legend('topright', c('high', 'low'), col=c('red', 'blue'), lty=1, bty='n', cex=.75)
-------------------------------------------------------------------------------------------------------
for for(i in 1:1000) {
  jpeg(paste("1000s", i, ".png", sep=""))
  plot(0, 0, xlim=c(1,23), ylim=c(17,24), xlab="", ylab="")

  for(j in 1:i) {
    lines(c(1:23), matrix[, j], col=j)
  } 
  dev.off()
}
-------------------------------------------------------------------------------------------------------
require(grid)

dothegrid <- function(){
  grid.newpage()
  grid.lines(x=c(0.5, 0.5), y=c(0.25, 0.75), gp=gpar(col=rgb(1, 0, 0, 0.2)))
  grid.lines(x=c(0.4, 0.4), y=c(0.25, 0.75), gp=gpar(col=rgb(1, 0, 0, 0.6)))
}

# Window 7
# Make sure to restart RStudio/R before running this
dothegrid() # Rstudio: ok, nothing in RGui
# run again
dothegrid() # makes the lines disappear

pdf("a.pdf")
dothegrid()
dothegrid() # lines stay
dev.off()

png("a.png")
dothegrid() #lines stay
dev.off()
-------------------------------------------------------------------------------------------------------
grid.newpage()
 grid.lines(x,y,   gp=gpar(col='red'),default.units = "npc") grid.newpage()
 grid.lines(x,y,   gp=gpar(col='red',alpha=0.4),default.units='naif')
-------------------------------------------------------------------------------------------------------
tidy.source ## ============ Possible (wrong?) ideas on inline comments ============

  tidy.source.mod=  function (source = "clipboard", keep.comment = getOption("keep.comment",
    TRUE), keep.blank.line = getOption("keep.blank.line", TRUE),
    keep.space = getOption("keep.space", FALSE), replace.assign = getOption("replace.assign",
        FALSE), left.brace.newline = getOption("left.brace.newline",
        FALSE), reindent.spaces = getOption("reindent.spaces",
        4), output = TRUE, text = NULL, width.cutoff = getOption("width"),
    ...)
{     
    if (is.null(text)) {
        if (source == "clipboard" && Sys.info()["sysname"] ==
            "Darwin") {
            source = pipe("pbpaste")
        }
        text = readLines(source, warn = FALSE)
    } 
    if (length(text) == 0L || all(grepl("^\\s*$", text))) {
        if (output)
            cat("\n", ...)
        return(list(text.tidy = "", text.mask = ""))
    } 
    text.lines = text
    if (keep.comment) {
        if (!keep.space)
            text.lines = gsub("^[[:space:]]+|[[:space:]]+$",
                "", text.lines)
        head.comment = grepl("^[[:space:]]*#", text.lines)
        if (any(head.comment)) {
            text.lines[head.comment] = gsub("\"", "'", text.lines[head.comment])
        }
        if (!keep.space) {
            head.comment = head.comment & !grepl("^\\s*#+'",
                text.lines)
            text.lines = reflow_comments(text.lines, head.comment,
                width.cutoff)
            head.comment = grepl("^[[:space:]]*#", text.lines)
        }
        text.lines[head.comment] = sprintf("invisible(\"%s%s%s\")",
            begin.comment, text.lines[head.comment], end.comment)
        blank.line = grepl("^[[:space:]]*$", text.lines)
        if (any(blank.line) && keep.blank.line) {
            else.line = grep("^[[:space:]]*else(\\W|)", text.lines)
            for (i in else.line) {
                j = i - 1
                while (blank.line[j]) {
                  blank.line[j] = FALSE
                  j = j - 1
                  warning("removed blank line ", j, " (you should not put an 'else' in a separate line!)")
                }
            }
            text.lines[blank.line] = sprintf("invisible(\"%s%s\")",
                begin.comment, end.comment)
        }
        text.lines = mask_inline(text.lines)
    } 
    #modified code
    ic=grepl( "%InLiNe_IdEnTiFiEr%", text.lines)
    text.lines[ic]=substr(text.lines[ic], 1, nchar(text.lines[ic])-1)
    text.lines[ic]=  paste0(text.lines[ic], "%InLiNe_IdEnTiFiEr_mod%\"")
    #end modified code
    text.mask = tidy_block(text.lines, width.cutoff, replace.assign)
    text.tidy = if (keep.comment)
        unmask.source(text.mask)
    else text.mask
    text.tidy = reindent_lines(text.tidy, reindent.spaces)
    if (left.brace.newline)
        text.tidy = move_leftbrace(text.tidy, reindent.spaces)
    #modified code
    text.tidy= unlist(sapply(text.tidy, strsplit, "%InLiNe_IdEnTiFiEr_mod%", USE.NAMES=FALSE))
    #end modified code
    if (output)
        cat(paste(text.tidy, collapse = "\n"), "\n", ...)
    invisible(list(text.tidy = text.tidy, text.mask = text.mask))
}     
## ====================================================


## ============ Implementation ============

## Clean-up
if("formatR" %in% loadedNamespaces() ) detach('package:formatR', unload=TRUE)
if(exists("tidy.source"))rm(tidy.source)
library("formatR")


## String with inline comments after arguments
text.input="paste(1 # comm
   ,7)
"     
## The same in vector format
text.input=strsplit(text.input, "\n")[[1]]

## Implementation without patch
tidy.source(text=text.input) #newline removed with  wrong result!
# paste(1  # comm, 7) 


# Tentative patch
unlockBinding("tidy.source", as.environment("package:formatR") )
assign("tidy.source", tidy.source.mod, pos="package:formatR")
environment(tidy.source)= asNamespace( "formatR" )

## Implementation with patch
tidy.source(text=text.input) # apparently ok:
# paste(1  # comm
# , 7)
-------------------------------------------------------------------------------------------------------
x <- 1:200/100
set.seed(42)
y <- -10+(x+1)^3.5+rnorm(length(x),sd=3)
df <- data.frame(x,y)

plot(y~x,data=df)

fitFun <- function(x, add, b0, b1) {
    res <- b0 + (x+add)^b1
    res[res<0] <- 0
    res
}
fit <- nls(y~fitFun(x,add,intercept,power),
           data=df,start=list(intercept=1,power=3.5,add=2))
summary(fit)
lines(predict(fit)~df$x,col="red")
-------------------------------------------------------------------------------------------------------
b0>=0 fit2 <- nls(y~b0+(x+add)^b1,
            algorithm="port",
            lower=c(b0=0,b1=-Inf,add=-Inf),
            data=df,start=list(b0=1,b1=3.5,add=2))
lines(predict(fit2)~df$x,col="purple")
-------------------------------------------------------------------------------------------------------
ab ab xts xtsExtra xtsExtra library(xts)

ab=structure(c(-1, 0.579760106421202, -0.693649703427259, 0.0960078627769613, 
           0.829770469089809, -0.804276208608663, 0.72574639798749, 0.977165659135716, 
           -0.880178529686181, -0.662078620277974, -1, 2.35268982675599, 
           -0.673979231663719, 0.0673890875594205, 1.46584597734824, 0.38403707067242, 
           -1.53638088345349, 0.868743976582955, -1.8394614923913, 0.246736581314485), .Dim = c(10L, 2L), .Dimnames = list(NULL, c("a", "b")), index = structure(c(1354683600, 
          1354770000, 1354856400, 1354942800, 1355029200, 1355115600, 1355202000, 
          1355288400, 1355374800, 1355461200), tzone = "", tclass = "Date"), class = c("xts", 
          "zoo"), .indexCLASS = "Date", .indexTZ = "", tclass = "Date", tzone = "")

#Set up the plot area so that multiple graphs can be crammed together
#In the "par()" statement below, the "mar=c(0.3, 0, 0, 0)" part is used to change
#the spacing between the graphs.   "mar=c(0, 0, 0, 0)" is zero spacing.
par(pty="m", plt=c(0.1, 0.9, 0.1, 0.9), omd=c(0.1, 0.9, 0.2, 0.9), mar=c(0.3, 0, 0, 0))

#Set the area up for 2 plots
par(mfrow = c(2, 1))

#Build the x values so that plot() can be used, allowing more control over the format
xval <- index(ab)

#Plot the top graph with nothing in it =========================
plot(x=xval, y=ab$a, type="n", xaxt="n", yaxt="n", main="", xlab="", ylab="")
mtext(text="ab", side=3, font=2, line=0.5, cex=1.5)

#Store the x-axis data of the top plot so it can be used on the other graphs
pardat <- par()

#Layout the x axis tick marks
xaxisdat <- index(ab)

#If you want the default plot tick mark locations, un-comment the following calculation
#xaxisdat <- seq(pardat$xaxp[1], pardat$xaxp[2], (pardat$xaxp[2]-pardat$xaxp[1])/pardat$xaxp[3])

#Get the y-axis data and add the lines and label
yaxisdat <- seq(pardat$yaxp[1], pardat$yaxp[2], (pardat$yaxp[2]-pardat$yaxp[1])/pardat$yaxp[3])
axis(side=2, at=yaxisdat, las=2, padj=0.5, cex.axis=0.8, hadj=0.5, tcl=-0.3)
abline(v=xaxisdat, col="lightgray")
abline(h=yaxisdat, col="lightgray")
mtext(text="ab$a", side=2, line=2.3)
lines(x=xval, y=ab$a, col="red")
box() #Draw an outline to make sure that any overlapping abline(v)'s or abline(h)'s are covered

#Plot the 2nd graph with nothing in it ================================
plot(x=xval, y=ab$b,  type="n", xaxt="n", yaxt="n", main="", xlab="", ylab="")

#Get the y-axis data and add the lines and label
pardat <- par()
yaxisdat <- seq(pardat$yaxp[1], pardat$yaxp[2], (pardat$yaxp[2]-pardat$yaxp[1])/pardat$yaxp[3])
axis(side=2, at=yaxisdat, las=2, padj=0.5, cex.axis=0.8, hadj=0.5, tcl=-0.3)
abline(v=xaxisdat, col="lightgray")
abline(h=yaxisdat, col="lightgray")
mtext(text="ab$b", side=2, line=2.3)
lines(x=xval, y=ab$b, col="blue")
box() #Draw an outline to make sure that any overlapping abline(v)'s or abline(h)'s are covered

#Plot the X axis =================================================
axis(side=1, label=format(as.Date(xaxisdat), "%b %d\n%Y\n") , at=xaxisdat, padj=0.4, cex.axis=0.8, hadj=0.5, tcl=-0.3)
mtext(text="Date", side=1, line=2.5)
-------------------------------------------------------------------------------------------------------
mytest = data.frame(
              x =  rep(1:3, each = 2),
              groupcd= rep(c(1,2),3),
              y=   c(22,8,11,4,7,5)
              )
mytest = rbind(mytest,c(2,3,15),c(3,3,17))

    plottables <- split(mytest,mytest$groupcd)
plot(y~x,dat=plottables[[1]],type="n",xlim=range(mytest$x),ylim=range(mytest$y))
lapply(plottables,function(z)points(z$x, z$y))
lapply(plottables,function(z)lines(z$x, predict(lm(z$y ~ z$x), list(z$x)))) xvals <- tapply(mytest$x, mytest$groupcd, function(x) return(x))
    yvals <- tapply(mytest$y, mytest$groupcd, function(x) return(x))

    plot(1:max(unlist(xvals)),ylim=(c(0,max(unlist(yvals)))),type="n")
    mapply(points, xvals, yvals, bg=c(1:3),pch=21,type="p")
    mapply(lines(xvals, predict(lm(yvals ~ xvals), list(xvals)), col = c(1:3)))
-------------------------------------------------------------------------------------------------------
library(raster)

## Create a SpatialLines object
a <- c(2.1, 3.9) 
b <- c(3.8, 4.8)
## Method #1 -- Uses functions from the sp package.
SL <- SpatialLines(list(Lines(list(Line(rbind(a,b))), "ab")))
## Method #2 -- Uses readWKT() from the rgeos package. Easier to read.
# library(rgeos)
# string <- paste0("LINESTRING(", paste(a, b, collapse=", "), ")")
# SL <- readWKT(string)

## Create a raster object
m <- 10
n <- 10
mat <- matrix(seq_len(m*n), nrow = m, ncol = n)
r <- raster(mat, xmn = 0, xmx = n, ymn = 0, ymx = m) 

## Find which cells are intersected & get coordinates of their lower-left corners
ii <- extract(r, SL, cellnumbers=TRUE)[[1]][, "cell"]
floor(xyFromCell(r, ii))
#      x y
# [1,] 2 4
# [2,] 3 4
# [3,] 2 3

## Confirm that this is correct with a plot
image(r)
plot(as(rasterize(SL, r), "SpatialPolygons"), 
     border = "darkgrey", lwd = 2, add = TRUE)
lines(SL)
-------------------------------------------------------------------------------------------------------
x identical library(zoo)

rollmedianR <- function(x, k=3) {
  n <- length(x)
  k.low <- floor((k+1)/2)
  k.high <- n + 1 - k.low
  repeat {
    y <- rollmedian(x, k, na.pad=TRUE)
    y[1:k.low] <- y[k.low]; y[k.high:n] <- y[k.high]
    if (identical(x, y)) break
    x <- y
  }
  return(y)
} smooth set.seed(17)
x <- sin(seq(0, 2*pi, 2*pi/1000)) + rnorm(1001, 0.25)
0 >= var((smooth(x,"3R") - rollmedianR(x, 3)), rep(0.0, length(x))) rollmedianR identical plot(x, col="Gray", cex=0.8)
lines(rollmedianR(x,37), lwd=2, col="Red")
-------------------------------------------------------------------------------------------------------
fmt=persp(x, y, z, col = color[facetcol], phi = 15, theta = -50, xlab="x", ylab="y", zlab="Empirical Joint Density", border=NA)
pt = Sample[1,]
points(trans3d(pt[1],pt[2],.001,fmt),pch=20, col="Red")
lines(trans3d(c(pt[1],pt[1]), c(pt[2],pt[2]), c(0,.001),fmt),col="Red",cex=2)
-------------------------------------------------------------------------------------------------------
checkbox require(gWidgets2) ## from github
options(guiToolkit="Qt") ## other choices too
source(system.file("examples", "manipulate.R", package="gWidgets2"))

manipulate({
  plot(mpg ~ wt, mtcars)
  if(do_lm)
    abline(lm(mpg ~ wt, mtcars))
  if(do_loess)
    with(mtcars, lines(lowess(wt, mpg)))
  ## ...
},
           do_lm=checkbox("Add regression line"),
           do_loess = checkbox("Add lowess fit")
           )
-------------------------------------------------------------------------------------------------------
chull x <- data.frame(x = rnorm(100), y = rnorm(100))
plot(x)
chx <- chull(x)
chx <- rbind(x = x[chx, ], x[chx[1], ])
lines(chx)
-------------------------------------------------------------------------------------------------------
a  <-  rnorm(1000)
b  <-  rnorm(1000)


Plot_ConvexHull<-function(xcoord, ycoord, lcolor){
hpts <- chull(x = xcoord, y = ycoord)
hpts <- c(hpts, hpts[1])
lines(xcoord[hpts], ycoord[hpts], col = lcolor)
}

(xrange <- range(c(a)))
(yrange <- range(c(b)))

par(tck = 0.02, mgp = c(1.7, 0.3, 0))
plot(a, b, type = "p", pch = 1, col = "black", xlim = c(xrange), ylim = c(yrange))
Plot_ConvexHull(xcoord = a, ycoord = b, lcolor = "black")
-------------------------------------------------------------------------------------------------------
par(mfrow=c(2,1))  # Two plots in one window

plot(x,y)                # Your datapoints
lines(x,predict(reg))    # The model prediction

plot(x, residuals(reg), ylab='Residuals')    # x vs. residuals plot(reg)
-------------------------------------------------------------------------------------------------------
d <- data.frame(x,y) ## not absolutely necessary but good practice
library(mgcv)
m1 <- gam(y~s(x),family="binomial",data=d) plot(y~x, data=d)
pp <- data.frame(x=seq(0,1,length=101))
pp$y <- predict(m1,newdata=pp,type="response")
with(pp,lines(x,y)) library(ggplot2)
ggplot(d,aes(x,y))+geom_smooth(method="gam",family=binomial)
-------------------------------------------------------------------------------------------------------
library(grid)

## Set up plotting area with reasonable x-y limits
## and a "native" scale related to the scale of the data.
x <- -1:1
y <-  extendrange(c(myd$myears, myd2$myears))
dvp <- dataViewport(x, y, name = "figure")

grid.newpage()
pushViewport(dvp)

## Plot the central timeline
grid.lines(unit(0, "native"), unit(c(0,245), "native"),
           gp = gpar(col="dodgerblue"))

## Annotate LHS
grid.segments(x0=0.5, x1=0.47,
              y0=unit(c(0, myd$myears), "native"),
              y1=unit(c(0, myd$myears), "native"),
              gp=gpar(col="dodgerblue"))
grid.text(label=c(0, myd$myears), x=0.44, y=unit(c(0, myd$myears), "native"))
grid.text(label=myd$period, x=0.3, y=unit(myd$label, "native"),
          just=0, gp=gpar(col="dodgerblue", fontface="italic"))

## Annotate RHS
## Create a function that plots a pointer to the specified coordinate
pointer <- function(x, y, width=1) {
    grid.polygon(x = x + unit(width*(c(0, .1, .1)), "npc"),
                 y = y + unit(width*(c(0, .03, -.03)), "npc"), 
                 gp = gpar(fill="dodgerblue", col="blue", lwd=2))
}
## Call it once for each milestone
for(y in myd2$myears) {
    pointer(unit(.5, "npc"), y=unit(y, "native"), width=0.3)
}
## Or, if you just want blue line segments instead of those gaudy pointers:
## grid.segments(x0=0.5, x1=0.53,
##           y0=unit(c(myd2$myears), "native"),
##           y1=unit(c(myd2$myears), "native"), gp=gpar(col="dodgerblue"))

grid.text(label=myd2$event, x=0.55, y=unit(myd2$myears, "native"),
          just=0)
-------------------------------------------------------------------------------------------------------
my.symbols ms.polygon ms.arrows plot(c(-2,2),c(-2,2), axes=FALSE, xlab='', ylab='', type='n', asp=1)
abline(v=0, col='lightgrey')
abline(h=0, col='lightgrey')
my.symbols(c(0,0),c(0,0),ms.polygon, xsize=c(2,4), lwd=c(1,2), n=360)

theta <- seq(pi/4, 3*pi/4, length=250)
lines( 2.03*cos(theta), 2.03*sin(theta), lwd=2, lty='dashed' )
lines( c(0,0), c(0,2), lty='dashed', lwd=2 )

a <- c(300,305,355,0,5,45,65)
l <- c(1.1, .5, .4,1,.6,.7,1.25)

my.symbols( rep(0,7), rep(0,7), ms.arrows, xsize=2, r=l, adj=0, 
        angle=pi/2 - pi/180*a )
-------------------------------------------------------------------------------------------------------
df <- data.frame(weight, area, weightl = log10(weight), areal = log10(area))
df <- df[order(df$weight),]

fit_line <- predict(lm(areal ~ weightl, data=df))
fit_power <- predict(nls(area ~ i*weight^z, start=list(i=2,z=0.7), data=df))

plot(df$weightl, df$areal)
lines(df$weightl, fit_line, col="red")
lines(df$weightl, log10(fit_power), col="blue")

plot(df$weight, df$area)
lines(df$weight, 10^fit_line, col="red")
lines(df$weight, fit_power, col="blue")
-------------------------------------------------------------------------------------------------------
## Make some sample data
x <- sample(0:30, 200, replace=T, prob=15 - abs(15 - 0:30))

## Calculate and plot the two histograms
hcum <- h <- hist(x, plot=FALSE)
hcum$counts <- cumsum(hcum$counts)
plot(hcum, main="")
plot(h, add=T, col="grey")

## Plot the density and cumulative density
d <- density(x)
lines(x = d$x, y = d$y * length(x) * diff(h$breaks)[1], lwd = 2)
lines(x = d$x, y = cumsum(d$y)/max(cumsum(d$y)) * length(x), lwd = 2)
-------------------------------------------------------------------------------------------------------
lowess residual.plot <- function(a,b,count,energy)
{
    log.y1 <- log(a) - b * log(energy)
    fitted.y <- exp(log.y1)
    diff <- count - fitted.y

    #normal approximation
        low <- diff - sqrt(  exp(log(a) - b * log(energy)) )*qnorm(0.975)
        high <- diff + sqrt(  exp(log(a) - b * log(energy))  )*qnorm(0.975)

    par(mfrow = c(1,1))
    plot(energy, diff, ylim = c(-10,10), type = "p", pch = 7)
    lines(lowess(energy, low), type = "p", col = "red", pch = 1)
    lines(lowess(energy, high), type = "p", col = "blue", pch = 1)


} count energy
-------------------------------------------------------------------------------------------------------
set.seed(0815)
x <- 1:10
F <- runif(10,1,2) 
L <- runif(10,0,1)
U <- runif(10,2,3)

require(plotrix)
plotCI(x, F, ui=U, li=L) set.seed(0815)
df <- data.frame(x =1:10,
                 F =runif(10,1,2),
                 L =runif(10,0,1),
                 U =runif(10,2,3))

require(ggplot2)
ggplot(df, aes(x = x, y = F)) +
  geom_point(size = 4) +
  geom_errorbar(aes(ymax = U, ymin = L)) set.seed(1234)
x <- rnorm(20)
df <- data.frame(x = x,
                 y = x + rnorm(20))

plot(y ~ x, data = df)

# model
mod <- lm(y ~ x, data = df)

# predicts + interval
newx <- seq(min(df$x), max(df$x), length.out=100)
preds <- predict(mod, newdata = data.frame(x=newx), 
                 interval = 'confidence')

# plot
plot(y ~ x, data = df, type = 'n')
# add fill
polygon(c(rev(newx), newx), c(rev(preds[ ,3]), preds[ ,2]), col = 'grey80', border = NA)
# model
abline(mod)
# intervals
lines(newx, preds[ ,3], lty = 'dashed', col = 'red')
lines(newx, preds[ ,2], lty = 'dashed', col = 'red')
-------------------------------------------------------------------------------------------------------
plot() polygon() lines() set.seed(1234)
 df <- data.frame(x =1:10,
                 F =runif(10,1,2),
                 L =runif(10,0,1),
                 U =runif(10,2,3))


 plot(df$x, df$F, ylim = c(0,4), type = "l")
 #make polygon where coordinates start with lower limit and 
 # then upper limit in reverse order
 polygon(c(df$x,rev(df$x)),c(df$L,rev(df$U)),col = "grey75", border = FALSE)
 lines(df$x, df$F, lwd = 2)
 #add red lines on borders of polygon
 lines(df$x, df$U, col="red",lty=2)
 lines(df$x, df$L, col="red",lty=2) Lower <- c(0.418116841, 0.391011834, 0.393297710,
        0.366144073,0.569956636,0.224775521,0.599166016,0.512269587,
        0.531378573, 0.311448219, 0.392045751,0.153614913, 0.366684097,
        0.161100849,0.700274810,0.629714150, 0.661641288, 0.533404093,
        0.412427559, 0.432905333, 0.525306427,0.224292061,
        0.28893064,0.099543648, 0.342995605,0.086973739,0.289030388,
        0.081230826,0.164505624, -0.031290586,0.148383474,0.070517523,0.009686605,
        -0.052703529,0.475924192,0.253382210, 0.354011010,0.130295355,0.102253218,
        0.446598823,0.548330752,0.393985810,0.481691632,0.111811248,0.339626541,
        0.267831909,0.133460254,0.347996621,0.412472322,0.133671128,0.178969601,0.484070587,
        0.335833224,0.037258467, 0.141312363,0.361392799,0.129791998,
        0.283759439,0.333893418,0.569533076,0.385258093,0.356201955,0.481816148,
        0.531282473,0.273126565,0.267815691,0.138127486,0.008865700,0.018118398,0.080143484,
        0.117861634,0.073697418,0.230002398,0.105855042,0.262367348,0.217799352,0.289108011,
        0.161271889,0.219663224,0.306117717,0.538088622,0.320711912,0.264395149,0.396061543,
        0.397350946,0.151726970,0.048650180,0.131914718,0.076629840,0.425849394,
        0.068692279,0.155144797,0.137939059,0.301912657,-0.071415593,-0.030141781,0.119450922,
        0.312927614,0.231345972)

 Upper.limit <- c(0.6446223,0.6177311, 0.6034427, 0.5726503,
      0.7644718, 0.4585430, 0.8205418, 0.7154043,0.7370033,
      0.5285199, 0.5973728, 0.3764209, 0.5818298,
      0.3960867,0.8972357, 0.8370151, 0.8359921, 0.7449118,
      0.6152879, 0.6200704, 0.7041068, 0.4541011, 0.5222653,
      0.3472364, 0.5956551, 0.3068065, 0.5112895, 0.3081448,
      0.3745473, 0.1931089, 0.3890704, 0.3031025, 0.2472591,
      0.1976092, 0.6906118, 0.4736644, 0.5770463, 0.3528607,
      0.3307651, 0.6681629, 0.7476231, 0.5959025, 0.7128883,
      0.3451623, 0.5609742, 0.4739216, 0.3694883, 0.5609220,
      0.6343219, 0.3647751, 0.4247147, 0.6996334, 0.5562876,
      0.2586490, 0.3750040, 0.5922248, 0.3626322, 0.5243285,
      0.5548211, 0.7409648, 0.5820070, 0.5530232, 0.6863703,
      0.7206998, 0.4952387, 0.4993264, 0.3527727, 0.2203694,
      0.2583149, 0.3035342, 0.3462009, 0.3003602, 0.4506054,
      0.3359478, 0.4834151, 0.4391330, 0.5273411, 0.3947622,
      0.4133769, 0.5288060, 0.7492071, 0.5381701, 0.4825456,
      0.6121942, 0.6192227, 0.3784870, 0.2574025, 0.3704140,
      0.2945623, 0.6532694, 0.2697202, 0.3652230, 0.3696383,
      0.5268808, 0.1545602, 0.2221450, 0.3553377, 0.5204076,
      0.3550094)

  Fitted.values<- c(0.53136955, 0.50437146, 0.49837019,
  0.46939721, 0.66721423, 0.34165926, 0.70985388, 0.61383696,
  0.63419092, 0.41998407, 0.49470927, 0.26501789, 0.47425695,
  0.27859380, 0.79875525, 0.73336461, 0.74881668, 0.63915795,
  0.51385774, 0.52648789, 0.61470661, 0.33919656, 0.40559797,
  0.22339000, 0.46932536, 0.19689011, 0.40015996, 0.19468781,
  0.26952645, 0.08090917, 0.26872696, 0.18680999, 0.12847285,
  0.07245286, 0.58326799, 0.36352329, 0.46552867, 0.24157804,
  0.21650915, 0.55738088, 0.64797691, 0.49494416, 0.59728999,
  0.22848680, 0.45030036, 0.37087676, 0.25147426, 0.45445930,
  0.52339711, 0.24922310, 0.30184215, 0.59185198, 0.44606040,
  0.14795374, 0.25815819, 0.47680880, 0.24621212, 0.40404398,
  0.44435727, 0.65524894, 0.48363255, 0.45461258, 0.58409323,
  0.62599114, 0.38418264, 0.38357103, 0.24545011, 0.11461756,
  0.13821664, 0.19183886, 0.23203127, 0.18702881, 0.34030391,
  0.22090140, 0.37289121, 0.32846615, 0.40822456, 0.27801706,
  0.31652008, 0.41746184, 0.64364785, 0.42944100, 0.37347037,
  0.50412786, 0.50828681, 0.26510696, 0.15302635, 0.25116438,
  0.18559609, 0.53955941, 0.16920626, 0.26018389, 0.25378867,
  0.41439675, 0.04157232, 0.09600163, 0.23739430, 0.41666762,
  0.29317767) df2 <- data.frame(x=seq(length(Fitted.values)),
                    fit=Fitted.values,lwr=Lower,upr=Upper.limit)
 plot(fit~x,data=df2,ylim=range(c(df2$lwr,df2$upr)))
 #make polygon where coordinates start with lower limit and then upper limit in reverse order
 with(df2,polygon(c(x,rev(x)),c(lwr,rev(upr)),col = "grey75", border = FALSE))
 matlines(df2[,1],df2[,-1],
          lwd=c(2,1,1),
          lty=1,
          col=c("black","red","red"))
-------------------------------------------------------------------------------------------------------
# run your code above, then review the dotchart method for svyby objects:
    getS3method( 'dotchart' , 'svyby' ) b SE(b) confint( b ) barNest plotCI getS3method( 'dotchart' , 'default' ) # calculate the distinct groups within the `svyby` object
    groups <- as.numeric( as.factor( attr( b , 'row.names' ) ) )

    # calculate the distinct statistics within the `svyby` object
    nstats <- attr( b , 'svyby' )$nstats

    # calculate the total number of confidence intervals you need to add
    n <- length( groups ) * nstats

    # calculate the offset sizes
    offset <- cumsum(c(0, diff(groups) != 0))

    # find the exact y coordinates for each dot in the dotchart
    # and leave two spaces between each group
    y <- 1L:n + sort( rep( 2 * offset , nstats ) )

    # find the confidence interval positions
    ci.pos <- 
        rep( groups , each = nstats ) + 
        c( 0 , length( groups ) )

    # extract the confidence intervals
    x <- confint( b )[ ci.pos , ]

    # add the y coordinates to a new line data object
    ld <- data.frame( x )

    # loop through each dot in the dotchart..
    for ( i in seq_len( nrow( ld ) ) ){

        # add the CI lines to the current plot
        lines( ld[ i , 1:2 ] , rep( y[i] , 2 ) )

    } svyby survey dotchart survey
-------------------------------------------------------------------------------------------------------
lines S4 performance ROCR add = TRUE ?plot.performance library(ROCR)
data(ROCR.simple)
pred <- prediction( ROCR.simple$predictions, ROCR.simple$labels )
pred2 <- prediction(abs(ROCR.simple$predictions + 
                        rnorm(length(ROCR.simple$predictions), 0, 0.1)), 
        ROCR.simple$labels)
perf <- performance( pred, "tpr", "fpr" )
perf2 <- performance(pred2, "tpr", "fpr")
plot( perf, colorize = TRUE)
plot(perf2, add = TRUE, colorize = TRUE) preds <- cbind(p1 = ROCR.simple$predictions, 
                p2 = abs(ROCR.simple$predictions + 
                rnorm(length(ROCR.simple$predictions), 0, 0.1)))

pred.mat <- prediction(preds, labels = matrix(ROCR.simple$labels, 
                nrow = length(ROCR.simple$labels), ncol = 2) )

perf.mat <- performance(pred.mat, "tpr", "fpr")
plot(perf.mat, colorize = TRUE) lines plot(perf) 
lines(perf2@x.values[[1]], perf2@y.values[[1]], col = 2)
-------------------------------------------------------------------------------------------------------
ld <- data.frame( x )
dotchart(b,xlim=c(min(ld),max(ld)))#<-added
for ( i in seq_len( nrow( ld ) ) ){  
  lines( ld[ i , 1:2 ] , rep( y[i] , 2 ) )
}
-------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------
lines() plot type = "l" Col.rar1<-c(rgb(1,0,0,0.7), rgb(0,0,1,0.7), rgb(0,1,1,0.7),rgb(0.6,0,0.8,0.7),rgb(1,0.8,0,0.7),rgb(0.4,0.5,0.6,0.7),rgb(0.2,0.3,0.2,0.7),rgb(1,0.3,0,0.7))

x <-  seq(0, 5000, length.out=10)
y <- matrix(sort(rnorm(10*length(Col.rar1))), ncol=length(Col.rar1))
plot(x, y[,1], ylim=range(y), ann=FALSE, axes=T,type="l", col=Col.rar1[1])

lapply(seq_along(Col.rar1),function(i){
  lines(x, y[,i], col=Col.rar1[i])
  points(x, y[,i])  # this is optional
})
-------------------------------------------------------------------------------------------------------
caret train This function sets up a grid of tuning parameters for a number 
      of classification and regression routines. require(quantmod) 
require(nnet)
require(caret)
T = seq(0,20,length=200)
y = 1 + 3*cos(4*T+2) +.2*T^2 + rnorm(200)
dat <- data.frame( y, x1=Lag(y,1), x2=Lag(y,2))
names(dat) <- c('y','x1','x2')
#Fit model
model <- train(y ~ x1+x2 , 
               dat, 
               method='nnet', 
               linout=TRUE, 
               trace = FALSE)
ps <- predict(model, dat)

#Examine results

plot(T,Y,type="l",col = 2)
lines(T[-c(1:2)],ps, col=3)
legend(5, 70, c("y", "pred"), cex=1.5, fill=2:3)
-------------------------------------------------------------------------------------------------------
n<-50
x<-sample(40:70,n,rep=T)
y<-.7*x+rnorm(n,sd=5)
plot(x,y,xlim=c(20,90),ylim=c(0,80))
mylm<-lm(y~x)
abline(mylm,col="red")
newx<-seq(20,90)
prd<-predict(mylm,newdata=data.frame(x=newx),interval = c("confidence"), 
level = 0.90,type="response")
lines(newx,prd[,2],col="red",lty=2)
lines(newx,prd[,3],col="red",lty=2) x <- rnorm(15)
y <- x + rnorm(15)
new <- data.frame(x = seq(-3, 3, 0.5))

pred.w.clim <- predict(lm(y ~ x), new, interval="confidence")


# Just create a blank plot region with axes first. We'll add to this
plot(range(new$x), range(pred.w.clim), type = "n", ann = FALSE)


# For convenience
CI.U <- pred.w.clim[, "upr"]
CI.L <- pred.w.clim[, "lwr"]

# Create a 'loop' around the x values. Add values to 'close' the loop
X.Vec <- c(new$x, tail(new$x, 1), rev(new$x), new$x[1])

# Same for y values
Y.Vec <- c(CI.L, tail(CI.U, 1), rev(CI.U), CI.L[1])

# Use polygon() to create the enclosed shading area
# We are 'tracing' around the perimeter as created above
polygon(X.Vec, Y.Vec, col = "grey", border = NA)


# Use matlines() to plot the fitted line and CI's
# Add after the polygon above so the lines are visible
matlines(new$x, pred.w.clim, lty = c(1, 2, 2), type = "l", col =  
c("black", "red", "red"))
-------------------------------------------------------------------------------------------------------
txtlab <- c("2", "4", "6", "8", "Inf")
txtpos <- c(1.25, 2, 3, 4, 4.75)
ctlns <- contourLines(x, y, z2, levels=c(3, 5, 7, 9))
filled.contour(x,y,z2,col=rainbow(200),nlevels=200, 
     plot.axes={axis(1); axis(2); text(txtpos, txtpos, txtlab, cex=1.5);
     sapply(1:4, function(x) lines(ctlns[[x]][[2]], ctlns[[x]][[3]], lwd=2))
})
-------------------------------------------------------------------------------------------------------
future FALSE library(forecast)
fit <- Arima(USAccDeaths)
plot(simulate(fit,future=FALSE),col='red')
lines(c(USAccDeaths)) plot(simulate(fit,future=FALSE)-c(USAccDeaths))
-------------------------------------------------------------------------------------------------------
lines(lowess(ctlns[[1]]$x[ctlns[[1]]$y<0.2],ctlns[[1]]$y[ctlns[[1]]$y<0.2]), lwd=2, col="darkblue") ids <- duplicated(ctlns[[1]]$x) & ctlns[[1]]$y < 0.25
 lines(ctlns[[1]]$x[ids],ctlns[[1]]$y[ids], lwd=4, col="darkblue")
-------------------------------------------------------------------------------------------------------
require(graphics)
plot(cars, main = "lowess(cars)")

require(msir)
low <- loess.sd(cars[ ,1], cars[ ,2])
lines(low$x, low$y)
lines(low$x, low$upper)
lines(low$x, low$lower)
-------------------------------------------------------------------------------------------------------
lines() polygon() # sorry for my lame fake data
TotalPop <- 2000
m <- table(sample(0:12, TotalPop*.52, replace = TRUE))
f <- table(sample(0:12, TotalPop*.48, replace = TRUE))

# scale to make it density
m <- m / TotalPop
f <- f / TotalPop
# find appropriate x limits
xlim <- max(abs(pretty(c(m,f), n = 20))) * c(-1,1)
# open empty plot
plot(NULL, type = "n", xlim = xlim, ylim = c(0,13))

# females
polygon(c(0,rep(f, each = 2), 0), c(rep(0:13, each = 2)))
# males (negative to be on left)
polygon(c(0,rep(-m, each = 2), 0), c(rep(0:13, each = 2)))
-------------------------------------------------------------------------------------------------------
set.seed (123)
xvar <- round (rnorm (100, 54, 10), 0)
xyvar <- round (rnorm (100, 54, 10), 0)
myd <- data.frame (xvar, xyvar)
valut <- as.numeric (cut(c(myd$xvar,myd$xyvar), 12))
myd$xwt <- valut[1:100]
myd$xywt <- valut[101:200]
xy.pop <- data.frame (table (myd$xywt))
xx.pop <- data.frame (table (myd$xwt))


stickBoy <- function() {
  grid.circle(x=.5, y=.8, r=.1, gp=gpar(fill="red"))
  grid.lines(c(.5,.5), c(.7,.2)) # vertical line for body
  grid.lines(c(.5,.6), c(.6,.7)) # right arm
  grid.lines(c(.5,.4), c(.6,.7)) # left arm
  grid.lines(c(.5,.65), c(.2,0)) # right leg
  grid.lines(c(.5,.35), c(.2,0)) # left leg
  grid.lines(c(.5,.5), c(.7,.2)) # vertical line for body
  grid.text(x=.5,y=-0.3,label ='Male',
            gp =gpar(col='white',fontface=2,fontsize=32)) # vertical line for body
}

stickGirl <- function() {
  grid.circle(x=.5, y=.8, r=.1, gp=gpar(fill="blue"))
  grid.lines(c(.5,.5), c(.7,.2)) # vertical line for body
  grid.lines(c(.5,.6), c(.6,.7)) # right arm
  grid.lines(c(.5,.4), c(.6,.7)) # left arm
  grid.lines(c(.5,.65), c(.2,0)) # right leg
  grid.lines(c(.5,.35), c(.2,0)) # left leg
  grid.lines(c(.35,.65), c(0,0)) # horizontal  line for body
  grid.text(x=.5,y=-0.3,label ='Female',
            gp =gpar(col='white',fontface=2,fontsize=32)) # vertical line for body
}

xscale <- c(0, max(c(xx.pop$Freq,xy.pop$Freq)))* 5
levels <- nlevels(xy.pop$Var1)
barYscale<- xy.pop$Var1
vp <- plotViewport(c(5, 4, 4, 1),
                   yscale = range(0:levels)*1.05,
                   xscale =xscale)


pushViewport(vp)

grid.yaxis(at=c(1:levels))
pushViewport(viewport(width = unit(0.5, "npc"),just='right', 
                      xscale =rev(xscale)))
grid.xaxis()
popViewport()

pushViewport(viewport(width = unit(0.5, "npc"),just='left',
                      xscale = xscale))
grid.xaxis()
popViewport()

grid.grill(gp=gpar(fill=NA,col='white',lwd=3),
           h = unit(seq(0,levels), "native"))
grid.rect(gp=gpar(fill=rgb(0,0.2,1,0.5)),
          width = unit(0.5, "npc"),just='right')

grid.rect(gp=gpar(fill=rgb(1,0.2,0.3,0.5)),
          width = unit(0.5, "npc"),just=c('left'))

vv.xy <- xy.pop$Freq
vv.xx <- c(xx.pop$Freq,0)

grid.polygon(x  = unit.c(unit(0.5,'npc')-unit(vv.xy,'native'),
                         unit(0.5,'npc')+unit(rev(vv.xx),'native')),
             y  = unit.c(unit(1:levels,'native'),
                         unit(rev(1:levels),'native')),
             gp=gpar(fill=rgb(1,1,1,0.8),col='white'))

grid.grill(gp=gpar(fill=NA,col='white',lwd=3,alpha=0.8),
           h = unit(seq(0,levels), "native"))
popViewport()

## some fun here 
vp1 <- viewport(x=0.2, y=0.75, width=0.2, height=0.2,gp=gpar(lwd=2,col='white'),angle=30)
pushViewport(vp1)
stickBoy()
popViewport()
vp1 <- viewport(x=0.9, y=0.75, width=0.2, height=0.2,,gp=gpar(lwd=2,col='white'),angle=330)
pushViewport(vp1)
stickGirl()
popViewport()
-------------------------------------------------------------------------------------------------------
panel.smooth.spline <-  function(x, y,
                                 w=NULL, df, spar = NULL, cv = FALSE,
                                 lwd=plot.line$lwd, lty=plot.line$lty,col, 
                                 col.line=plot.line$col,type, ... )
{
  x <- as.numeric(x)
  y <- as.numeric(y)
  ok <- is.finite(x) & is.finite(y)
  if (sum(ok) < 1)
    return()
  if (!missing(col)) {
    if (missing(col.line))
      col.line <- col
  }
  plot.line <- trellis.par.get("plot.line")
  spline <-   smooth.spline(x[ok], y[ok],
                            w=w, df=df, spar = spar, cv = cv)
  pred = predict(spline,x= seq(min(x),max(x),length.out=150))
  panel.lines(x = pred$x, y = pred$y, col = col.line, lty = lty, lwd = lwd, ...)
  panel.abline(h=y[which.min(x)],col=col.line,lty=2)
}
-------------------------------------------------------------------------------------------------------
plot(rnorm(120), rnorm(120), col="darkblue", pch=16, xlim=c(-3,3), ylim=c(-4,4))
points(rnorm(120,-1,1), rnorm(120,2,1), col="darkred", pch=16)
points(c(-1,-1.5,-3), c(4,2,0), pch=3, cex=3) xspline dd <- xspline(c(-1,-1.5,-3), c(4,2,0), shape = -1,draw=FALSE) panel.lines library(lattice)
xyplot(y ~ x,
       data=dat,
       groups=l,
       col=c("darkblue", "darkred"),
       pch=16,
       panel = function(x, y, ...) {
         panel.xyplot(x=spl$x, y=spl$y, pch=3, cex=3)
         panel.lines(dd$x,dd$y)
         panel.superpose(x, y, ...,
                         panel.groups = function(x, y, ...) {
                           panel.xyplot(x, y, ...)
                         }
         )
       },
       xlim=c(-3,3), ylim=c(-4,4)
)
-------------------------------------------------------------------------------------------------------
splines panel.splines( ) local({
           model <- lm(y ~ bs(x, degree=2), data=spl)
           x0 <- seq(min(spl$x), max(spl$x), by=.1)
           panel.lines(x0, predict(model, data.frame(x=x0)))
         }) grid.xspline() panel.splines( ) grid.xspline(spl$x, spl$y, shape = -1, default.units="native")
-------------------------------------------------------------------------------------------------------
set.seed(42)
Wage <- rnorm(100, 50)
Empl <- Wage + rnorm(100, 0) model.ew <- lm(Empl~Wage)
summary(model.ew)
plot(Empl~Wage) # Note. You had the axes flipped here xval <- seq(min(Wage), max(Wage), length.out=101)
conf <- predict(model.ew, data.frame(Wage=xval), 
    interval="confidence", level=.90)
matlines(xval, conf, col=c("red", "blue", "blue"))
-------------------------------------------------------------------------------------------------------
myfun <- function(...) {
 plot(...)
 lines(...)
}
-------------------------------------------------------------------------------------------------------
densregion() denstrip require(denstrip)
x <- 1:10
nx <- length(x)
est <- seq(0, 1, length=nx)^3
se <- seq(.7,1.3,length.out=nx)/qnorm(0.975)
y <- seq(-3, 3, length=100)
z <- matrix(nrow=nx, ncol=length(y))
for(i in 1:nx) z[i,] <- dnorm(y, est[i], se[i])
plot(x, type="n", ylim=c(-3, 3),xlab="")
densregion(x, y, z)
lines(x,est,col="white")
-------------------------------------------------------------------------------------------------------
set.seed(1001)
x <- runif(1000)
y <- runif(1000)
dat <- data.frame(x,y) quantreg library(quantreg)
q1 <- rq(y~x,data=data.frame(x,y))
xvec <- seq(0,1,length=101)
pq <- predict(q1,newdata=data.frame(x=xvec)) plot(x,y,pch=".")
lines(lowess(x,y))
lines(xvec,pq,col=2) ggplot2 library(ggplot2)
theme_set(theme_bw())
qplot(x,y,data=dat,size=I(0.8),alpha=I(0.2))+
    geom_smooth(method="loess")+
    stat_quantile(quantiles=0.5,formula=y~x,colour="red")
-------------------------------------------------------------------------------------------------------
predict lines(predict(fit)) # plot the existing data with space for the predicted line
plot(c(cpi,rep(NA,12)),xaxt="n",ylab="CPI",xlab="",ylim=c(162,190))

# plot the future predictions as a line using the next 3 year periods
lines(13:24,predict(fit, newdata=data.frame(year=rep(c(2011,2012,2013),each=4),quarter=rep(1:4,3)) ))

year<-rep(2008:2013,each=4)
axis(1,labels=paste(year,quarter,sep="C"),at=1:24,las=3)
-------------------------------------------------------------------------------------------------------
?hist all(diff(breaks) == 1) hist(c(1,1,3,3 -3.5,-3.5, msum2),breaks=bins, freq= FALSE, right=FALSE) hist(msum2,breaks=bins, freq= FALSE, right=FALSE, xaxt="n")
axis(1,at=bins,labels=bins) x <- seq(-4, 4, length=100) `lines(x,dnorm(x))`
-------------------------------------------------------------------------------------------------------
igraph set.seed(1)
x = ceiling(rlnorm(1000, 4)) occur = as.vector(table(x))
occur = occur/sum(occur)
p = occur/sum(occur)
y = rev(cumsum(rev(p)))
x = as.numeric(names(table(x)))
plot(x, y, log="xy", type="l") igraph library(poweRlaw)

##Create a displ object
m = displ$new(x)
##Estimate the cut-off
estimate_xmin(m)
m$setXmin(105); m$setPars(2.644)

##Plot the data and the PL line
plot(m)
lines(m, col=2)
-------------------------------------------------------------------------------------------------------
population_mean <- 0
population_sd <- 1
n <- 1000
x <- rnorm(n, population_mean, population_sd) x qnorm population_x <- seq(
  qnorm(0.001, population_mean, population_sd), 
  qnorm(0.999, population_mean, population_sd), 
  length.out = 1000
) binwidth <- 0.5
breaks <- seq(floor(min(x)), ceiling(max(x)), binwidth) hist(x, breaks) lines(
  population_x, 
  n * dnorm(population_x, population_mean, population_sd) * binwidth, 
  col = "red"
) sample_mean <- mean(x)
sample_sd <- sd(x)
sample_x <- seq(
  qnorm(0.001, sample_mean, sample_sd), 
  qnorm(0.999, sample_mean, sample_sd), 
  length.out = 1000
)
lines(
  population_x, 
  n * dnorm(sample_x, sample_mean, sample_sd) * binwidth, 
  col = "blue"
)
-------------------------------------------------------------------------------------------------------
hist freq=FALSE breaks set.seed(1)
f1 <- rnorm(100, mean=0, sd=1)
f2 <- rnorm(100, mean=3, sd=3)
f3 <- rnorm(100, mean=4, sd=1)
f4 <- rnorm(100, mean=7, sd=3)

breaks <- pretty(c(f1, f2, f3, f4), n=20)
x11(width=4, height=8)
op <- par(mfcol=c(4,1))
hist(f1, freq=FALSE, breaks=breaks)
hist(f2, freq=FALSE, breaks=breaks)
hist(f3, freq=FALSE, breaks=breaks)
hist(f4, freq=FALSE, breaks=breaks)
par(op) t set.seed(1)

N <- 100
M <- 7
MEAN <- c(1:M)
SD <- MEAN*0.2+1
RES <- list()

for(i in seq(M)){
    RES[[i]] <- rnorm(N, mean=MEAN[[i]], sd=SD[[i]])
}


breaks <- pretty(unlist(RES), n=20)
x11(width=4, height=10)
op <- par(mfcol=c(M,1), mar=c(1,3,0,0), oma=c(3,2,1,1))
for(i in seq(M)){
    h1 <- hist(RES[[i]], breaks=breaks, plot=FALSE)
    plot(h1$mids, h1$densit, t="n", xlab="", ylab="", xaxt="n")
    grid()
    lines(h1$mids, h1$densit, t="S")
    text(par()$usr[1], par()$usr[3]+(par()$usr[4]-par()$usr[3])*0.9, labels=paste("t", i), pos=4)
    if(i == M){
        axis(1)
    } else {
        axis(1, labels=FALSE)
    }
}
mtext("Density", outer=TRUE, side=2, line=0)
par(op)
-------------------------------------------------------------------------------------------------------
density x = rnorm(100)
d = density(x, from=-5, to = 5, n = 1000)
d$x
d$y z x z = c(-2, -1, 2)
x = seq(-5, 5, 0.01) plot(0, 0, xlim=c(-5, 5), ylim=c(-0.02, 0.8), 
     pch=NA, ylab="", xlab="z")
for(i in 1:length(z)) {
   points(z[i], 0, pch="X", col=2)
}
 abline(h=0) ## Now we combine the kernels,
x_total = numeric(length(x))
for(i in 1:length(x_total)) {
  for(j in 1:length(z)) {
    x_total[i] = x_total[i] + 
      dnorm(x[i], z[j], sd=1)
  }
} lines(x, x_total, col=4, lty=2) ## Just as a histogram is the sum of the boxes, 
## the kernel density estimate is just the sum of the bumps. 
## All that's left to do, is ensure that the estimate has the
## correct area, i.e. in this case we divide by $n=3$:

plot(x, x_total/3, 
       xlim=c(-5, 5), ylim=c(-0.02, 0.8), 
       ylab="", xlab="z", type="l")
abline(h=0) density(z, adjust=1, bw=1)
-------------------------------------------------------------------------------------------------------
grid.newpage() grid.rect() grid.rect(x=x_Position, y=y_Position, width=width_Value, height=height_Value, gp=gpar(col=section_Color, fill=section_Color), just=c("left", "bottom"), default.units="native") grid.text() grid.text("Label Text", x_Value, y_Value, gp=gpar(col=color_Value, cex=font_Size), just=c("right","center"), rot=rot_Degrees, default.units="native") grid.lines() grid.lines(c(x_Start,x_End), c(y_Start, y_End), gp=gpar(col=color_Value), default.units="native") dataViewport() pushViewport(dataViewport(xData=x_Data, yData=y_Data, xscale=c(x_Min, x_Max), yscale=c(y_Min, y_Max), x=x_Value, y=y_Value, width=width_Value, height=height_Value, just=c("left","center"))) pushViewport() pushViewport(dataViewport([stuff in here])) popViewport() viewport(x=0, y=0, width=0.5, height=1, just=c("left","lower")) viewport(x=0.5, y=0, width=0.5, height=1, just=c("left","lower")) default.units="native"
-------------------------------------------------------------------------------------------------------
I > y=rnorm(10)
> x=rnorm(10)
> z=rnorm(10)
> mod <- lm(y ~ x:I(z>0) )
> mod

Call:
lm(formula = y ~ x:I(z > 0))

Coefficients:
    (Intercept)  x:I(z > 0)FALSE   x:I(z > 0)TRUE  
      -0.009983        -0.203004        -0.655941  

> predict(mod, newdata=data.frame(x=1:10, z=c(-1, 1)) )
         1          2          3          4          5          6          7 
-0.2129879 -1.3218653 -0.6189968 -2.6337471 -1.0250057 -3.9456289 -1.4310147 
         8          9         10 
-5.2575108 -1.8370236 -6.5693926 
> plot(1:10, predict(mod, newdata=data.frame(x=1:10, z=c(-1)) )  )
> lines(1:10, predict(mod, newdata=data.frame(x=1:10, z=c(1)) ) ) > model.matrix(mod)
   (Intercept) x:I(z > 0)FALSE x:I(z > 0)TRUE
1            1      -0.2866252     0.00000000
2            1       0.0000000    -0.03197743
3            1      -0.7427334     0.00000000
4            1       2.0852202     0.00000000
5            1       0.8548904     0.00000000
6            1       0.0000000     1.00044600
7            1       0.0000000    -1.18411791
8            1       0.0000000    -1.54110256
9            1       0.0000000    -0.21173300
10           1       0.0000000     0.17035257
attr(,"assign")
[1] 0 1 1
attr(,"contrasts")
attr(,"contrasts")$`I(z > 0)`
[1] "contr.treatment"
-------------------------------------------------------------------------------------------------------
base ggplot2 bandline<-function(x, low.col, high.col, axis=TRUE){
    l <- max(unlist(lapply(x, length)), na.r=TRUE)
    r <- range(unlist(x), na.rm=TRUE)
    par(mfcol=c(length(x), 1))
    for(i in 1:length(x)){
        y <- boxplot.stats(x[[i]])
        ifelse(i==1, par(mar=c(0,3,3,3)), 
                     ifelse(i==length(x), par(mar=c(3,3,0,3)), 
                                          par(mar=c(0,3,0,3))))
        plot(NA, axes=F, bty="n", xlim=c(1,l), ylim=r, xaxs="i")
        rect(1,y$stats[2], l, y$stats[1], col="grey80", border=NA)
        rect(1,y$stats[4], l, y$stats[2], col="grey60", border=NA)
        rect(1,y$stats[5], l, y$stats[4], col="grey40", border=NA)
        abline(h=y$stats[3],col="white", lwd=2)
        lines(seq_along(x[[i]]), x[[i]])
        zhigh <- zlow <- x[[i]]
        zhigh[zhigh<=y$stats[5]]<-NA
        zlow[zlow>=y$stats[1]]<-NA
        points(seq_along(x[[i]]), zlow, bg=low.col, pch=21,cex=2)
        points(seq_along(x[[i]]), zhigh, bg=high.col, pch=21, cex=2)
        if(axis==TRUE){
            axis(2, at=pretty(x[[i]]), las=2)
            ifelse(i==1, axis(3, at=seq_len(l)), 
                         ifelse(i==length(x),axis(1, at=seq_len(l)),""))
            }
        mtext(names(x)[i], side=4, srt=270, line=1)
    }
} set.seed(1)
dat<-list(a=rnorm(100), b=rnorm(100), c=rnorm(100), d=rnorm(100))
bandline(dat, "black", "white", axis=FALSE)
-------------------------------------------------------------------------------------------------------
pty="s" par(pty="s")
plot(iris$Petal.Width, iris$Petal.Length, asp=1)
lines(2+c(0,1,1,0,0),3+c(0,0,1,1,0)) # confirm square visually
-------------------------------------------------------------------------------------------------------
lines plot(X2,Y2)
ox2 <- order(X2)
lines(X2[ox2],fitted(model2s)[ox2])
-------------------------------------------------------------------------------------------------------
df <- read.csv('data.csv')
x <- df$x
y <- df$y
plot(x,y)

fit <- nls(y~A*(1-exp(-b*x))+R, data=df, start=list(A=3,b=0.005,R=-2))
s <- summary(fit)

A <- s[["parameters"]][1]
b <- s[["parameters"]][2]
R <- s[["parameters"]][3]

f <- function(z){
  v <- A*(1-exp(-b*z))+R
  v
}

x.t <- 0:max(x)
y.c <- sapply(x.t, f)
lines(x.t, y.c, col='red')
print(s)
-------------------------------------------------------------------------------------------------------
x <- rnorm(1000, mean=3, sd=2)
y <- rnorm(500, mean=3.5, sd=3)

dx <- density(x)
dy <- density(y)

plot.new()
plot.window(xlim=range(c(dx$x, dy$x)), ylim=range(c(dx$y, dy$y)))
with(dx, lines(x, y))
with(dy, lines(x, y, lty=2))
axis(1)
axis(2)
legend(topright, lty=1:2, c('x', 'y'))
mtext(side=1, line=2, 'Observed values')
mtext(side=2, line=2, 'Estimated probability mass')
title('Smoothed Density Estimates for 2-sample experiment')
-------------------------------------------------------------------------------------------------------
library(maptools)

Inspections.mp <- readShapeLines("InspDates2")
counties.mp <- readShapePoly("Boundary")
for(theMonth in 600: 0)
{
  plot(counties.mp, axes=FALSE, border="gray")

  result <- tryCatch({
    data1 <-Inspections.mp[Inspections.mp$MonthInt == theMonth,]
    lines(data1, col="blue", lwd=1)
    },warning = function(war){
      print("WARNING")
    },error = function (err)
    {
      print("Error")
    }, finally = {
      print("Finally")
    })
}
-------------------------------------------------------------------------------------------------------
set.seed(1)
x = round(rlnorm(100, 3, 2)+1) library(poweRlaw)
m = displ$new(x) xmin est = estimate_xmin(m)) m$setXmin(est[[2]])
m$setPars(est[[3]]) plot(m)
lines(m, col=2)
-------------------------------------------------------------------------------------------------------
panel.groups panel.superpose group.number panelfun <- function(...,type,group.number) {
    if (group.number==3) {
        panel.points(...)
        panel.lines(...)
    } else {
        panel.points(...,type="s")
    }
}

xyplot(lower.lim+upper.lim+observed ~ time, data=my.df,
    panel=function(...) panel.superpose(...,panel.groups=panelfun),
       col=c(1,1,2))
-------------------------------------------------------------------------------------------------------
?dcauchy dnorm x<-seq(-10,10,by=0.1)
plot(x, dnorm(x),type="l")
lines(x, dcauchy(x),col="red") seq
-------------------------------------------------------------------------------------------------------
read.table(text = 'col1 col2
           0012 0001245',head=T,colClasses=c('character','numeric'))


myd <- data.frame (X = 1:5, 
                   Y = c(0.8, 0.6, 0.7, 0.75,  0.1), 
                   clockd = c(12.05, 12.25, 12.45, 1.30, 2.1)) library(lattice)
library(grid)
xyplot(Y~X,data=myd,
       panel=function(x,y,...)
       {

         panel.fill(col='yellow')
         panel.lines(x,y)

         h_min <- do.call(rbind,strsplit(as.character(myd$clockd),'[.]'))
         hours <- as.numeric(h_min[,1])
         minutes <- as.numeric(h_min[,2])
         lapply(seq_along(x),
                         function(i)drawClock(x[i],y[i],hour = hours[i], minute = minutes[i]))


       }) drawClock <- function(x0,y0,hour, minute) {
  t <- seq(0, 2*pi, length=13)[-13]
  x <- cos(t)
  y <- sin(t)
  # Circle with ticks
  grid.circle(x=x0, y=y0, default="native", 
              r=unit(0.4,'in'),gp=gpar(fill='blue',alpha=0.5))
  #         grid.segments(x, y, x*.9, y*.9, default="native")
  # Hour hand
  hourAngle <- pi/2 - (hour + minute/60)/12*2*pi
  grid.segments(x0, y0, 
                x0+.06*cos(hourAngle), y0+.06*sin(hourAngle), 
                default="native", gp=gpar(lex=4))
  # Minute hand
  minuteAngle <- pi/2 - (minute)/60*2*pi
  grid.segments(x0, y0, 
                x0+.08*cos(minuteAngle), y0+.08*sin(minuteAngle), 
                default="native", gp=gpar(lex=2))    
}
-------------------------------------------------------------------------------------------------------
plot(0,0,xlim = c(-10,10),ylim = c(-10,10),type = "n")

cl <- rainbow(5)

for (i in 1:5){
    lines(-10:10,runif(21,-10,10),col = cl[i],type = 'b')
} type = "n" cl
-------------------------------------------------------------------------------------------------------
plot(pct_used, days)
lines(pct_used, predict(fit plot(pct_used, days, xlim=c(min(pct_used), 85) ,ylim= c(-50,350))
lines(seq(min(pct_used), 85, length=50), predict(fit, newdata=data.frame( 
                                        pct_used=seq( min(pct_used), 85, length=50))))
-------------------------------------------------------------------------------------------------------
state.map maps::map ##### start example 3 #####

library("M3")        # http://cran.r-project.org/web/packages/M3/
library("rasterVis") # http://cran.r-project.org/web/packages/rasterVis/

## Use an example file with projection=Lambert conformal conic.
# lcc.file <- system.file("extdata/ozone_lcc.ncf", package="M3")
# See notes in question regarding unfortunate problem with raster::raster,
# and remember to download or rename the file (symlinking alone will not work).
lcc.file <- "./ozone_lcc.nc"

lcc.proj4 <- M3::get.proj.info.M3(lcc.file)
lcc.proj4   # debugging
# [1] "+proj=lcc +lat_1=33 +lat_2=45 +lat_0=40 +lon_0=-97 +a=6370000 +b=6370000"
# Note +lat_0=40 +lat_1=33 +lat_2=45 for maps::map@projection (below)
lcc.crs <- sp::CRS(lcc.proj4)
lcc.pdf <- "./ozone_lcc.example3.pdf" # for output

## Read in variable with daily ozone.
# o3.raster <- raster::raster(x=lcc.file, varname="O3", crs=lcc.crs)
# ozone_lcc.nc has 4 timesteps, choose 1 at random
o3.raster <- raster::raster(x=lcc.file, varname="O3", crs=lcc.crs, level=1)
o3.raster@crs <- lcc.crs # why does the above assignment not take?
# start debugging
o3.raster
summary(coordinates(o3.raster)) # thanks, Felix Andrews!
M3::get.grid.info.M3(lcc.file)
#   end debugging

# > o3.raster
# class       : RasterLayer 
# band        : 1 
# dimensions  : 112, 148, 16576  (nrow, ncol, ncell)
# resolution  : 1, 1  (x, y)
# extent      : 0.5, 148.5, 0.5, 112.5  (xmin, xmax, ymin, ymax)
# coord. ref. : +proj=lcc +lat_1=33 +lat_2=45 +lat_0=40 +lon_0=-97 +a=6370000 +b=6370000 
# data source : .../ozone_lcc.nc 
# names       : O3 
# z-value     : 1 
# zvar        : O3 
# level       : 1 

# > summary(coordinates(o3.raster))
#        x                y         
#  Min.   :  1.00   Min.   :  1.00  
#  1st Qu.: 37.75   1st Qu.: 28.75  
#  Median : 74.50   Median : 56.50  
#  Mean   : 74.50   Mean   : 56.50  
#  3rd Qu.:111.25   3rd Qu.: 84.25  
#  Max.   :148.00   Max.   :112.00  

# > M3::get.grid.info.M3(lcc.file)
# $x.orig
# [1] -2736000
# $y.orig
# [1] -2088000
# $x.cell.width
# [1] 36000
# $y.cell.width
# [1] 36000
# $hz.units
# [1] "m"
# $ncols
# [1] 148
# $nrows
# [1] 112
# $nlays
# [1] 1

# The grid (`coordinates(o3.raster)`) is integers, because this
# data is stored using the IOAPI convention. IOAPI makes the grid
# Cartesian by using an (approximately) equiareal projection (LCC)
# and abstracting grid positioning to metadata stored in netCDF
# global attributes. Some of this spatial metadata can be accessed
# by `M3::get.grid.info.M3` (above), and some can be accessed via
# the coordinate reference system (`CRS`, see `lcc.proj4` above)

## Get US state boundaries in projection units.
state.map <- maps::map(
  database="state", projection="lambert", par=c(33,45), plot=FALSE)
#                  parameters to lambert: ^^^^^^^^^^^^
#                  see mapproj::mapproject

# replace its coordinates with
metadata.coords.IOAPI.list <- M3::get.grid.info.M3(lcc.file)
metadata.coords.IOAPI.x.orig <- metadata.coords.IOAPI.list$x.orig
metadata.coords.IOAPI.y.orig <- metadata.coords.IOAPI.list$y.orig
metadata.coords.IOAPI.x.cell.width <- metadata.coords.IOAPI.list$x.cell.width
metadata.coords.IOAPI.y.cell.width <- metadata.coords.IOAPI.list$y.cell.width
map.lines <- M3::get.map.lines.M3.proj(
  file=lcc.file, database="state", units="m")
map.lines.coords.IOAPI.x <-
  (map.lines$coords[,1] - metadata.coords.IOAPI.x.orig)/metadata.coords.IOAPI.x.cell.width
map.lines.coords.IOAPI.y <-
  (map.lines$coords[,2] - metadata.coords.IOAPI.y.orig)/metadata.coords.IOAPI.y.cell.width
map.lines.coords.IOAPI <- 
  cbind(map.lines.coords.IOAPI.x, map.lines.coords.IOAPI.y)
# start debugging
class(map.lines.coords.IOAPI)
summary(map.lines.coords.IOAPI)
#   end debugging

# >     class(map.lines.coords.IOAPI)
# [1] "matrix"
# >     summary(map.lines.coords.IOAPI)
#  map.lines.coords.IOAPI.x map.lines.coords.IOAPI.y
#  Min.   : 12.88           Min.   :14.47           
#  1st Qu.: 78.62           1st Qu.:39.28           
#  Median :101.37           Median :57.25           
#  Mean   : 95.17           Mean   :55.65           
#  3rd Qu.:124.47           3rd Qu.:72.57           
#  Max.   :140.51           Max.   :93.16           
#  NA's   :168              NA's   :168        

coordinates(state.map.shp) <- map.lines.coords.IOAPI # FAIL:
> Error in `coordinates<-`(`*tmp*`, value = c(99.0242231482288, 99.1277727928691,  : 
>   setting coordinates cannot be done on Spatial objects, where they have already been set

state.map.IOAPI <- state.map # copy
state.map.IOAPI$x <- map.lines.coords.IOAPI.x
state.map.IOAPI$y <- map.lines.coords.IOAPI.y
state.map.IOAPI$range <- c(
  min(map.lines.coords.IOAPI.x),
  max(map.lines.coords.IOAPI.x),
  min(map.lines.coords.IOAPI.y),
  max(map.lines.coords.IOAPI.y))
state.map.IOAPI.shp <-
  maptools::map2SpatialLines(state.map.IOAPI, proj4string=lcc.crs)
# start debugging
# thanks, Felix Andrews!
class(state.map.IOAPI.shp)
summary(do.call("rbind",
  unlist(coordinates(state.map.IOAPI.shp), recursive=FALSE)))
#   end debugging

# > class(state.map.IOAPI.shp)
# [1] "SpatialLines"
# attr(,"package")
# [1] "sp"

# > summary(do.call("rbind",
# +   unlist(coordinates(state.map.IOAPI.shp), recursive=FALSE)))
#        V1               V2       
#  Min.   : 12.88   Min.   :14.47  
#  1st Qu.: 78.62   1st Qu.:39.28  
#  Median :101.37   Median :57.25  
#  Mean   : 95.17   Mean   :55.65  
#  3rd Qu.:124.47   3rd Qu.:72.57  
#  Max.   :140.51   Max.   :93.16  

pdf(file=lcc.pdf)
rasterVis::levelplot(o3.raster, margin=FALSE
) + latticeExtra::layer(
  sp::sp.lines(state.map.IOAPI.shp, lwd=0.8, col='darkgray'))
dev.off()
# change this for viewing PDF on your system
system(sprintf("xpdf %s", lcc.pdf))

#####   end example 3 #####
-------------------------------------------------------------------------------------------------------
predict plot(factor,data)
lines(predict(lm(data~factor+I(factor^2))))
-------------------------------------------------------------------------------------------------------
smooth.spline spars <- seq(0.2,2,length.out=10)          ## I will choose between 10 values 
dat <- data.frame(
  spar= as.factor(rep(spars,each=18)),    ## spar to group data(to get different colors)
  x = seq(1:18),                          ## recycling here to repeat x and y 
  y = c(1:3,5,4,7:3,2*(2:5),rep(10,4)))
xyplot(y~x|spar,data =dat, type=c('p'), pch=19,groups=spar,
       panel =function(x,y,groups,...)
       {
          s2  <- smooth.spline(y,spar=spars[panel.number()])
          panel.lines(s2)
          panel.xyplot(x,y,groups,...)
       })
-------------------------------------------------------------------------------------------------------
bacteria bacteria.glm <- glm(cbind(Bacteria_count, 126 - Bacteria_count) ~ Time, 
                    data=bacteria, family=binomial(logit))

plot(Bacteria_count/126 ~ Time, data=bacteria)
lines(bacteria$Time, bacteria.glm$fitted, col="red") bacteria_intervals <- seq(0, 173.44, 30)
bac_predict<-data.frame(Time=bacteria_intervals, 
                        Bacteria_count=predict(bacteria.glm, data.frame(Time=bacteria_intervals), 
                                               type="response")*126)

plot(bacteria)
points(Bacteria_count~Time, data=bac_predict, col="red", pch=16) bac_predict
##   Time Bacteria_count
## 1    0       12.39587
## 2   30       76.11856
## 3   60      120.36021
## 4   90      125.57925
## 5  120      125.96982
## 6  150      125.99784 bacteria_linear <- approx(bacteria, xout=seq(0, 173.44, 30))
setNames(as.data.frame(bacteria_linear), c("Time", "Bacteria_count"))
##   Time Bacteria_count
## 1    0             NA
## 2   30        84.1200
## 3   60       118.5902
## 4   90       126.0000
## 5  120       126.0000
## 6  150       126.0000 bacteria_spline <- spline(bacteria, xout=seq(0, 173.44, 30))
setNames(as.data.frame(bacteria_spline), c("Time", "Bacteria_count"))
##   Time Bacteria_count
## 1    0      -1.672644
## 2   30      84.110483
## 3   60     118.854542
## 4   90     126.000000
## 5  120     126.000000
## 6  150     126.000000
-------------------------------------------------------------------------------------------------------
bbmle dframe1 <- structure(list(independent_variable = c(0.3, 0.24, 0.23, 0.16, 
0.14, 0.05, 0.01, -0.1, -0.2), dependent_variable = c(1, 1, 
1, 0.95, 0.93, 0.65, 0.55, 0.5, 0.5)), .Names = c("independent_variable", 
"dependent_variable"), class = "data.frame", row.names = c(NA, 
-9L)) wfun <- function(x,shape,scale) {
    (1+pweibull(x,shape,scale))/2.0
}

dframe2 <- transform(dframe1,y=round(40*dependent_variable),x=independent_variable) library(bbmle)
m1 <- mle2(y~dbinom(prob=wfun(exp(a+b*x),shape=exp(logshape),scale=1),size=40),
     data=dframe2,start=list(a=0,b=0,logshape=0)) pframe <- data.frame(x=seq(-0.2,0.3,length=101))
pframe$y <- predict(m1,pframe)

png("wplot.png")
with(dframe2,plot(y/40~x))
with(pframe,lines(y/40~x,col=2))
dev.off()
-------------------------------------------------------------------------------------------------------
ggplot2 A$group = "A"
B$group = "B"
dat = rbind(A,B) ggplot(aes(x = time, y = power, color = group), data = dat) + geom_line() plot(power~time, A)
lines(power~time, B)
-------------------------------------------------------------------------------------------------------
par(bg="black")
 plot(seq(0.15,0.85,by=0.01), 
      5*dbeta(seq(0.15,0.85,by=0.01),10,10 ), 
      type="l" , ylim=c(0,700) )  # this just sets up the plotting framework.

 for( i in 1:200 ) { lines(x= seq(0.15,0.85,by=0.01), 
                           y= i*dbeta(seq(0.15,0.85,by=0.01),10,10 ), 
                     col= colorRampPalette(c("yellow", "orange", "red", "hotpink", 
                             "violet", "blue", "lightblue", "lightgreen", "darkgreen",
                             "black"))(200)[i], 
                      lwd=13) }
 par(bg="white") plot(seq(0.15,0.85,by=0.01), 5*dbeta(seq(0.15,0.85,by=0.01),10,10 ), 
            type="l" , ylim=c(0,100))
for( i in seq(0.2, 5) ) { lines(seq(0.15,0.85,by=0.01), 
                     i*5*dbeta(seq(0.15,0.85,by=0.01),10,10 ) ) } plot(seq(0.15,0.85,by=0.01), 5*dbeta(seq(0.15,0.85,by=0.01),10,10 ), type="l" ,
          ylim=c(0,130))
for( i in 1:35 ) {lines(seq(0.15,0.85,by=0.01), i*dbeta(seq(0.15,0.85,by=0.01), 10,10 ), 
                           col=colorRampPalette(c("yellow", "orange", "red", "violet", 
                                        "blue", "lightblue", "lightgreen"))(35)[i],
                   lwd=3) } par(bg = 'black')
 plot(seq(0.15,0.85,by=0.01), 5*dbeta(seq(0.15,0.85,by=0.01),10,10 ), type="l", 
          ylim=c(0,130) )
 for( i in 1:35 ) { lines(seq(0.15,0.85,by=0.01), i*dbeta(seq(0.15,0.85,by=0.01),10,10), 
                          col=colorRampPalette(c("yellow", "orange", "red", "violet", 
                                "blue", "lightblue", "lightgreen", "darkgreen", 
                                 "black")) (35)[i], 
                           lwd=13) } grep("purple", colors(), value=TRUE)
 [1] "mediumpurple"  "mediumpurple1" "mediumpurple2" "mediumpurple3" "mediumpurple4"
 [6] "purple"        "purple1"       "purple2"       "purple3"       "purple4"
-------------------------------------------------------------------------------------------------------
x <- c(4.399449e-02,  2.161474e-02, -1.515223e-05,  1.298059e+01,
      3.163949e-01, -1.785220e+00,  1.041053e+01,  6.327219e-01, -5.778590e-03)

hist(x,col="grey",freq=FALSE, breaks=10) 
d<-density(x)
lines(d,col="red") x <- rgamma(100,1,1)
-------------------------------------------------------------------------------------------------------
set.seed(1234)
period <- 100
x <- 1:100
y <- sin(2*pi*x/period) + runif(length(x),-1,1)


require(quantreg)
mod <- rqss(y ~ qss(x))
mod2 <- rqss(y ~ qss(x), tau=0.75)
mod3 <- rqss(y ~ qss(x), tau=0.25)
plot(x, y)
lines(x[-1], mod$coef[1] + mod$coef[-1], col = 'red')
lines(x[-1], mod2$coef[1] + mod2$coef[-1], col = 'green')
lines(x[-1], mod3$coef[1] + mod3$coef[-1], col = 'green')
-------------------------------------------------------------------------------------------------------
lm y lm1 lm2 nls x lm nls AIC AIC lm nls1 lm3.2 nls2 lm1 <- lm(1/y ~ x)
nls1 <- nls(y ~ 1/(a + b*x), start = setNames(coef(lm1), c("a", "b")))
AIC(nls1) # -2.390924

lm2 <- lm(1/y ~ log(x))
nls2 <- nls(y ~ 1/(a + b*log(x)), start = setNames(coef(lm2), c("a", "b")))
AIC(nls2) # -1.29101

lm3.1 <- lm(y ~ x) 
AIC(lm3.1) # 13.43161

lm3.2 <- lm(y ~ poly(x, 2))
AIC(lm3.2) # -1.525982

lm3.3 <- lm(y ~ poly(x, 3))
AIC(lm3.3) # 0.1498972

plot(y ~ x)

lines(fitted(nls1) ~ x, lty = 1) # solid line
lines(fitted(nls2) ~ x, lty = 2) # dashed line AIC AICc
-------------------------------------------------------------------------------------------------------
R # read in the data
dat <- read.table(text= "x y 
28 45
91 14
102 11
393 5
4492 1.77", header = TRUE)

# quick visual inspection
plot(dat); lines(dat) # a smattering of possible models... just made up on the spot
    # with more effort some better candidates should be added
# a smattering of possible models...
models <- list(lm(y~x, data = dat), 
               lm(y~I(1/x), data=dat),
               lm(y ~ log(x), data = dat),
               nls(y ~ I(1/x*a) + b*x, data = dat, start = list(a = 1, b = 1)), 
               nls(y ~ (a + b*log(x)), data=dat, start = setNames(coef(lm(y ~ log(x), data=dat)), c("a", "b"))),
               nls(y ~ I(exp(1)^(a + b * x)), data=dat, start = list(a=0,b=0)),
               nls(y ~ I(1/x*a)+b, data=dat, start = list(a=1,b=1))
)

    # have a quick look at the visual fit of these models
    library(ggplot2)
    ggplot(dat, aes(x, y)) + geom_point(size = 5) +
  stat_smooth(method = "lm", formula = as.formula(models[[1]]), size = 1, se = FALSE, colour = "black") + 
  stat_smooth(method = "lm", formula = as.formula(models[[2]]), size = 1, se = FALSE, colour = "blue") + 
  stat_smooth(method = "lm", formula = as.formula(models[[3]]), size = 1, se = FALSE, colour = "yellow") + 
  stat_smooth(method = "nls", formula = as.formula(models[[4]]), data=dat, start = list(a=0,b=0), size = 1, se = FALSE, colour = "red") + 
  stat_smooth(method = "nls", formula = as.formula(models[[5]]), data=dat, start = setNames(coef(lm(y ~ log(x), data=dat)), c("a", "b")), size = 1, se = FALSE, colour = "green") +
  stat_smooth(method = "nls", formula = as.formula(models[[6]]), data=dat, start = list(a=0,b=0), size = 1, se = FALSE, colour = "violet") +
  stat_smooth(method = "nls", formula = as.formula(models[[7]]), data=dat, start = list(a=0,b=0), size = 1, se = FALSE, colour = "orange") # calculate the AIC and AICc (for small samples) for each 
# model to see which one is best, ie has the lowest AIC
library(AICcmodavg); library(plyr); library(stringr)
ldply(models, function(mod){ data.frame(AICc = AICc(mod), AIC = AIC(mod), model = deparse(formula(mod))) })


      AICc      AIC                     model
1 70.23024 46.23024                     y ~ x
2 44.37075 20.37075                y ~ I(1/x)
3 67.00075 43.00075                y ~ log(x)
4 43.82083 19.82083    y ~ I(1/x * a) + b * x
5 67.00075 43.00075      y ~ (a + b * log(x))
6 52.75748 28.75748 y ~ I(exp(1)^(a + b * x))
7 44.37075 20.37075        y ~ I(1/x * a) + b

# y ~ I(1/x * a) + b * x is the best model of those tried here for this curve
# it fits nicely on the plot and has the best goodness of fit statistic
# no doubt with a better understanding of nls and the data a better fitting
# function could be found. Perhaps the optimisation method here might be
# useful also: http://stats.stackexchange.com/a/21098/7744 # symbolic regression using Genetic Programming
# http://rsymbolic.org/projects/rgp/wiki/Symbolic_Regression
library(rgp)
# this will probably take some time and throw
# a lot of warnings...
result1 <- symbolicRegression(y ~ x, 
             data=dat, functionSet=mathFunctionSet,
             stopCondition=makeStepsStopCondition(2000))
# inspect results, they'll be different every time...
(symbreg <- result1$population[[which.min(sapply(result1$population, result1$fitnessFunction))]])

function (x) 
tan((x - x + tan(x)) * x) 
# quite bizarre...

# inspect visual fit
ggplot() + geom_point(data=dat, aes(x,y), size = 3) +
  geom_line(data=data.frame(symbx=dat$x, symby=sapply(dat$x, symbreg)), aes(symbx, symby), colour = "red")
-------------------------------------------------------------------------------------------------------
lines set.seed(1)
x1 = ceiling(rlnorm(1000, 4)) m = displ$new(x1) plot(m) xmin alpha lines m$setXmin(100)
p_100 = estimate_pars(m)
m$setPars(p_100)
lines(m, col=2, lwd=2)

##Line 2    
m$setXmin(202)
p_200 = estimate_pars(m)
m$setPars(p_200)
lines(m, col=3, lwd=2) set.seed(1)
x1 = ceiling(rlnorm(1000, 4))
x2 = ceiling(rlnorm(1000, 5)) m1 = displ$new(x1)
m1$setXmin(estimate_xmin(m1))

m2 = displ$new(x2)
m2$setXmin(estimate_xmin(m2)) pts2 pts2 = plot(m2) plot(m1)
points(pts2$x, pts2$y, col=3)
lines(m1, col=2)
lines(m2, col=4)
-------------------------------------------------------------------------------------------------------
H = 1.3 + D^2/(a+b*D+c*D^2) 1/(H-1.3) = a/D^2+b/D+c H 1/(H-1.3) data(trees)
df <- transform(trees,
            h=Height * 0.3048,   #transform to metric system
            dbh=Girth * 0.3048 / pi   #transform tree girth to diameter
            )
lm(1/(h-1.3) ~ poly(I(1/dbh),2,raw=TRUE),data=df)

## Coefficients:
##                    (Intercept)  poly(I(1/dbh), 2, raw = TRUE)1  
##                       0.043502                       -0.006136  
## poly(I(1/dbh), 2, raw = TRUE)2  
##                       0.010792 nls glm (fit2 <- glm(h-1.3 ~ poly(I(1/dbh),2,raw=TRUE),
             family=gaussian(link="inverse"),data=df))

## Coefficients:
##                    (Intercept)  poly(I(1/dbh), 2, raw = TRUE)1  
##                       0.041795                       -0.002119  
## poly(I(1/dbh), 2, raw = TRUE)2  
##                       0.008175  
## 
## Degrees of Freedom: 30 Total (i.e. Null);  28 Residual
## Null Deviance:       113.2 
## Residual Deviance: 80.05     AIC: 125.4 
## pframe <- data.frame(dbh=seq(0.8,2,length=51)) predict pframe$h <- predict(fit2,newdata=pframe,type="response")+1.3
p2 <- predict(fit2,newdata=pframe,se.fit=TRUE) ## predict on link scale
pframe$h_lwr <- with(p2,1/(fit+1.96*se.fit))+1.3
pframe$h_upr <- with(p2,1/(fit-1.96*se.fit))+1.3
png("dbh_tmp1.png",height=4,width=6,units="in",res=150)
par(las=1,bty="l")
plot(h~dbh,data=df)
with(pframe,lines(dbh,h,col=2))
with(pframe,polygon(c(dbh,rev(dbh)),c(h_lwr,rev(h_upr)),
      border=NA,col=adjustcolor("black",alpha=0.3)))
dev.off() 1/H - 1.3 = a/D^2 + ... ggplot geom_smooth library("ggplot2")
ggplot(df,aes(dbh,h))+geom_point()+theme_bw()+
   geom_line(data=pframe,colour="red")+
   geom_ribbon(data=pframe,colour=NA,alpha=0.3,
             aes(ymin=h_lwr,ymax=h_upr))

ggsave("dbh_tmp2.png",height=4,width=6)
-------------------------------------------------------------------------------------------------------
nls H(a, b, c, D) h ~ H(a, b, c, dbh) # use lm to get startingf values
lm1 <- lm(1/(h - 1.3) ~ I(1/dbh) + I(1/dbh^2), df)
start <- rev(setNames(coef(lm1), c("c", "b", "a")))

# run nls
H <- function(a, b, c, D) 1.3 + D^2 / (a + b * D + c * D^2)
nls1 <- nls(h ~ H(a, b, c, dbh), df, start = start)

nls1 # display result plot(h ~ dbh, df)
lines(fitted(nls1) ~ dbh, df)
-------------------------------------------------------------------------------------------------------
library(SDMTools) # Use this to get weighted means

testdata <- structure(list(Size=c(25L, 28L, 31L, 45L, 60L),
                           diseased=c(0L, 22L, 10L, 5L, 2L),
                           healthy=c(55L, 40L, 15L, 7L, 2L)),
                      .Names = c("Size", "diseased", "healthy"),
                      class = "data.frame",
                      row.names = c(NA, -5L))

barplot(testdata$healthy,
        names.arg=paste("                 ",testdata$Size),
        col="light blue",
        border="blue",
        xlim=c(0,6),
        ylim=c(0,70),
        width=0.5,
        space=1)
par(new=TRUE)
barplot(testdata$diseased,
        col="pink",
        border="red",
        xlim=c(0,6),
        ylim=c(0,70),
        width=0.5,
        space=c(2,1,1,1,1))

healthy_mean <- wt.mean(x=testdata$healthy,wt=testdata$Size)
healthy_sd <- wt.sd(x=testdata$healthy,wt=testdata$Size)
diseased_mean <- wt.mean(x=testdata$diseased,wt=testdata$Size)
diseased_sd <- wt.sd(x=testdata$diseased,wt=testdata$Size)

yfit_healthy <- as.data.frame(dnorm(0:max(testdata$healthy),
                              mean=healthy_mean,sd=healthy_sd))
names(yfit_healthy) <- "y"
yfit_diseased <- as.data.frame(dnorm(0:max(testdata$diseased),
                               mean=diseased_mean,sd=diseased_sd))
names(yfit_diseased) <- "y"

yfit_healthy$x <- seq(0,6,length.out=length(yfit_healthy$y))
yfit_diseased$x <- seq(0,6,length.out=length(yfit_diseased$y))

lines(yfit_healthy$x,(max(testdata$healthy)*yfit_healthy$y)/max(yfit_healthy$y),col="blue",lwd=2)

lines(yfit_diseased$x,(max(testdata$diseased)*yfit_diseased$y)/max(yfit_diseased$y),col="red",lwd=2)
-------------------------------------------------------------------------------------------------------
lines par( mar=c(5,4,4,5)+.1 )
boxplot( t( matrix( rnorm( 100 ), nrow=10 )), xlab="Var1", ylab="Var2")
lines( 1:10, runif(10,min=-2, max=3), type='b', col='blue', pch=15 )
axis(4)
mtext("Var3", side=4, line=3 )
-------------------------------------------------------------------------------------------------------
eps eps[ii,1] ii=2 theta epsf1 eps[ii,1] epsf1 rm(list=ls())
delka_experimentu = 1000;
lambda  = 1;
Q = diag(3);

e = rnorm(delka_experimentu);
u = rnorm(delka_experimentu);#rep(10,delka_experimentu)
y = rep(0,delka_experimentu);
y[1] = e[1];

for(ii in c(2:delka_experimentu)){
  y[ii] = 0.5*y[ii-1]+0.3*u[ii-1]+e[ii]-0.2*e[ii];
}

Res =  matrix(0,delka_experimentu,6);


P = 1000*diag(3);
R1 = 0.1*diag(3);
K = matrix(0,3,1);
eps = matrix(0,delka_experimentu,1)
epsf1 = y[1];
print(c(epsf1))
epsf2 = 0;
ef3 = 0;
yf1 = y[1];
yf2 = 0;
yf3 = 0;
uf1 = u[1];
uf2 = 0;
uf3 = 0;
eps[1,1] = y[1];

epst1 = 0;
pomocna1 = 0;
pomocna2 = 0;
theta = matrix(0,3,1);

for(ii in 2:30){ #delka_experimentu
  a1 = theta[1];
  b1 = theta[2];
  c1 = theta[3];
  eps[ii,1] = y[ii]+a1*y[ii-1]-b1*u[ii-1]-c1*eps[ii-1] #This is the line I moved
  pomocna1 = epsf1;
  epsf1 = eps[ii,1]-c1*epsf1;
  epsf2 = pomocna1;
  print(c(epsf1))
  pomocna1 = yf1;
  yf1 = y[ii]-c1*yf1;
  yf2 = pomocna1;

  pomocna1 = uf1;
  uf1 = u[ii]-c1*uf1;
  uf2 = pomocna1;



  #if(eps[ii]*eps[ii]>100){paste("problem",ii)}

  psi = matrix(c(yf2,uf2,epsf2),3,1);

  b = t(psi)%*%P%*%psi;
  P = (P - P%*%psi%*%solve(1+b[1,1])%*%t(psi)%*%P)/lambda #lambda*solve(Q)
  K = P%*%psi%*%solve(1+b[1,1]); #lambda*solve(Q)
  theta = theta + K%*%eps[ii];
  Res[ii,] = theta;
}  
}

plot(c(0,delka_experimentu),c(min(Res,-0.5),max(Res,1)),col="white")
lines(Res[,1],col="red")
#lines(Res[,2],col="red",type=o)
lines(Res[,3],col="blue")
#lines(Res[,4],col="blue")
lines(Res[,5])
#lines(Res[,6])

lines(c(0,delka_experimentu),c(-0.5,-0.5),col="red")
lines(c(0,delka_experimentu),c(0.3,0.3),col="blue")
lines(c(0,delka_experimentu),c(-0.2,-0.2)) [1] 0.003594182
[1] -0.9812494
[1] -5.430992
[1] -27.87607
[1] -143.5392
[1] -732.6409
[1] -3729.887
[1] -18962.87
[1] -96278.02
[1] -488131.6
[1] -2471325
[1] -12494038
[1] -63075221
[1] -317971881
[1] -1600659248
[1] -8043157617
[1] -40412374164
[1] -203058922762
[1] -1.020209e+12
[1] -5.125226e+12
[1] -2.308228e+13
[1] -1.039444e+14
[1] -4.680327e+14
[1] -2.107201e+15
[1] -9.47394e+15
[1] -4.259006e+16
[1] -1.914032e+17
[1] -8.600152e+17
[1] -3.905738e+18
-------------------------------------------------------------------------------------------------------
rqss dat <- read.csv("~/Downloads/Test.csv")

library(quantreg)
dat <- plyr::arrange(dat,Time)
fit<-rqss(Concentration~qss(Time,constraint="N"),tau=0.5,data = dat)
with(dat,plot(Time,Concentration))
lines(unique(dat$Time)[-1],fit$coef[1] + fit$coef[-1])
-------------------------------------------------------------------------------------------------------
y1 y2 m1<-mean(y1)
s1<-sd(y1)
m2<-mean(y2)
s2<-sd(y2) y1 y2 x dnorm() 2 4 df1<-data.frame(yval=seq(1,7,0.1),xval=(dnorm(seq(1,7,0.1),m1,s1)+2))
df2<-data.frame(yval=seq(6,12,0.1),xval=(dnorm(seq(6,12,0.1),m2,s2)+4)) lines() plot(x,y,pch=16,cex=0.9,xlim=c(0,6),ylim=c(0,13))
with(df1,lines(xval,yval))
with(df2,lines(xval,yval))
-------------------------------------------------------------------------------------------------------
pushViewport(viewport(x=0, y=1, xscale=c(1, 10), yscale=c(0, 100), width=0.25, height=0.25, default.units="npc", just=c("left","bottom"), clip="off")) library(grid)

# Specify general chart options.
chart_Fill = "lemonchiffon"
chart_Col = "snow3"
space_Background = "white"
title_CEX = 0.8
axis_CEX = 0.6
chart_Width <- 3/3
chart_Height <- 2/5

# Function to initialize a plotting area.
init_Plot <- function(
    .df,
    .x_Loc, 
    .y_Loc, 
    .justify, 
    .width, 
    .height
    ){

    # Initialize plotting area to fit data.
    # We have to turn off clipping to make it
    # easy to plot the labels around the plot.
    pushViewport(viewport(xscale=c(min(.df[,1]), max(.df[,1])), yscale=c(min(0,min(.df[,-1])), max(.df[,-1])), x=.x_Loc, y=.y_Loc, width=.width, height=.height, just=.justify, clip="off", default.units="native"))

    # Color behind text.
    grid.rect(x=0, y=0, width=unit(axis_CEX, "lines"), height=1, default.units="npc", just=c("right", "bottom"), gp=gpar(fill=space_Background, col=space_Background))
    grid.rect(x=0, y=1, width=1, height=unit(title_CEX, "lines"), default.units="npc", just=c("left", "bottom"), gp=gpar(fill=space_Background, col=space_Background))

    # Color in the space.
    grid.rect(gp=gpar(fill=chart_Fill, col=chart_Col))
}

# Function to finalize and label a plotting area.
finalize_Plot <- function(
    .df, 
    .plot_Title
    ){

    # Label plot using the internal reference
    # system, instead of the parent window, so
    # we always have perfect placement.
    grid.text(.plot_Title, x=0.5, y=1.05, just=c("center","bottom"), rot=0, default.units="npc", gp=gpar(cex=title_CEX))
    grid.text(paste(names(.df)[-1], collapse=" & "), x=-0.05, y=0.5, just=c("center","bottom"), rot=90, default.units="npc", gp=gpar(cex=axis_CEX))
    grid.text(names(.df)[1], x=0.5, y=-0.05, just=c("center","top"), rot=0, default.units="npc", gp=gpar(cex=axis_CEX))

    # Finalize plotting area.
    popViewport()
}

# Function to plot a filled line chart of
# the data in a data frame.  The first column
# of the data frame is assumed to be the
# plotting index, with each column being a
# set of y-data to plot.  All data is assumed
# to be numeric.
plot_Line_Chart <- function(
    .df,
    .x_Loc,
    .y_Loc,
    .justify,
    .width,
    .height,
    .colors,
    .plot_Title
    ){

    # Initialize plot.
    init_Plot(.df, .x_Loc, .y_Loc, .justify, .width, .height)

    # Calculate what value to use as the
    # return for the polygons.
    y_Axis_Min <- min(0, min(.df[,-1]))

    # Plot each set of data as a polygon,
    # so we can fill it in with color to
    # make it easier to read.
    for (i in 2:ncol(.df)){
        grid.polygon(x=c(min(.df[,1]),.df[,1], max(.df[,1])), y=c(y_Axis_Min,.df[,i], y_Axis_Min), default.units="native", gp=gpar(fill=.colors[i-1], col=.colors[i-1], alpha=1/ncol(.df)))
    }

    # Draw plot axes.
    grid.lines(x=0, y=c(0,1), default.units="npc")
    grid.lines(x=c(0,1), y=0, default.units="npc")

    # Finalize plot.
    finalize_Plot(.df, .plot_Title)

}

# Function to plot a scatterplot of
# the data in a data frame.  The
# assumptions are the same as 'plot_Line_Chart'.
plot_Scatterplot <- function(
    .df,
    .x_Loc,
    .y_Loc,
    .justify,
    .width,
    .height,
    .colors,
    .plot_Title
    ){

    # Initialize plot.
    init_Plot(.df, .x_Loc, .y_Loc, .justify, .width, .height)

    # Plot each set of data as colored points.
    for (i in 2:ncol(.df)){
        grid.points(x=.df[,1], y=.df[,i], pch=19, size=unit(1, "native"), default.units="native", gp=gpar(col=.colors[i-1], alpha=1/ncol(.df)))
    }

    # Draw plot axes.
    grid.lines(x=0, y=c(0,1), default.units="npc")
    grid.lines(x=c(0,1), y=0, default.units="npc")

    # Finalize plot.
    finalize_Plot(.df, .plot_Title)

}

# Function to plot a histogram of
# all the columns in a data frame,
# except the first, which is assumed to
# be an index.
plot_Histogram <- function(
    .df,
    .x_Loc,
    .y_Loc,
    .justify,
    .width,
    .height,
    .colors,
    .plot_Title,
    ...
    ){

    # Create a list containing the histogram
    # data for each data column and calculate
    # data ranges.  Any extra parameters
    # specified will pass to the 'hist' function.
    hist_Data <- list()
    hist_Count_Range <- c(0,NA)
    hist_Breaks_Range <- c(NA,NA)
    for (i in 2:ncol(.df)){
        hist_Data[[i]] <- hist(.df[,i], plot=FALSE, ...)
        hist_Count_Range[2] <- max(max(hist_Data[[i]]$counts), hist_Count_Range[2], na.rm=TRUE)
        hist_Breaks_Range <- c(min(min(hist_Data[[i]]$breaks), hist_Breaks_Range[1], na.rm=TRUE), max(max(hist_Data[[i]]$breaks), hist_Breaks_Range[2], na.rm=TRUE))
    }


    # Initialize plotting area to fit data.
    # We are doing this in a custom way to
    # allow more flexibility than built into
    # the 'init_Plot' function.
    # We have to turn off clipping to make it
    # easy to plot the labels around the plot.
    pushViewport(viewport(xscale=hist_Breaks_Range, yscale=hist_Count_Range, x=.x_Loc, y=.y_Loc, width=.width, height=.height, just=.justify, clip="off", default.units="native"))

    # Color behind text.
    grid.rect(x=0, y=0, width=unit(axis_CEX, "lines"), height=1, default.units="npc", just=c("right", "bottom"), gp=gpar(fill=space_Background, col=space_Background))
    grid.rect(x=0, y=1, width=1, height=unit(title_CEX, "lines"), default.units="npc", just=c("left", "bottom"), gp=gpar(fill=space_Background, col=space_Background))

    # Color in the space.
    grid.rect(gp=gpar(fill=chart_Fill, col=chart_Col))


    # Draw x axis.
    grid.lines(x=c(0,1), y=0, default.units="npc")

    # Plot each set of data as a histogram.
    for (i in 2:ncol(.df)){
        grid.rect(x=hist_Data[[i]]$mids, y=0, width=diff(hist_Data[[i]]$mids[1:2]), height=hist_Data[[i]]$counts, default.units="native", just=c("center","bottom"), gp=gpar(fill=.colors[i-1], col=.colors[i-1], alpha=1/ncol(.df)))
    }

    # Label plot using the internal reference
    # system, instead of the parent window, so
    # we always have perfect placement.
    grid.text(.plot_Title, x=0.5, y=1.05, just=c("center","bottom"), rot=0, default.units="npc", gp=gpar(cex=title_CEX))
    grid.text(paste(names(.df)[-1], collapse=" & "), x=-0.05, y=0.5, just=c("center","bottom"), rot=90, default.units="npc", gp=gpar(cex=axis_CEX))

    # Finalize plotting area.
    popViewport()
}

draw_Sample_Box <- function(
    .x_Loc,
    .y_Loc,
    .x_Scale,
    .y_Scale,
    .justify,
    .width,
    .height,
    .colors,
    .box_X,
    .box_Y,
    .plot_Title
    ){

    pushViewport(viewport(xscale=.x_Scale, yscale=.y_Scale, x=.x_Loc, y=.y_Loc, width=chart_Width, height=chart_Height, just=.justify, clip="off", default.units="native"))

    # Color behind text.
    grid.rect(x=0, y=1, width=1, height=unit(title_CEX, "lines"), default.units="npc", just=c("left", "bottom"), gp=gpar(fill=space_Background, col=space_Background))

    # Color in the space.
    grid.rect(gp=gpar(fill=chart_Fill, col=chart_Col))

    # Label plot.
    grid.text(.plot_Title, x=0.5, y=1.05, just=c("center","bottom"), rot=0, default.units="npc", gp=gpar(cex=title_CEX))

    # Draw box and label points.
    grid.polygon(x=.box_X, y=.box_Y, default.units="native", gp=gpar(fill=.colors[1], col=.colors[2]))
    grid.text(paste(.plot_Title, 1, sep=""), x=min(.box_X), y=min(.box_Y), default.units="native", just=c("right","top"), gp=gpar(cex=0.5))
    grid.text(paste(.plot_Title, 2, sep=""), x=max(.box_X), y=min(.box_Y), default.units="native", just=c("left","top"), gp=gpar(cex=0.5))

    # Finalize plot.
    popViewport()
} # Draw twelve independent charts as
# a demo and connect with lines similar
# to a heiritage chart.
grid.newpage()

# Initialize a viewport to make our locations
# easier to map.
pushViewport(viewport(x=0, y=0, width=1, height=1, just=c("left","bottom"), xscale=c(0,10), yscale=c(0,4)))

# Color background of overall plot.
grid.rect(gp=gpar(fill=space_Background, col=space_Background))

# Store plot locations for convenience.
plot_Loc <- data.frame(x=c(2,4,6,8,1,3,7,9,2,4,6,8), y=c(3,3,3,3,2,2,2,2,1,1,1,1))

# Draw connecting lines.
connections <- data.frame(a=c(1, 3, 5, 6, 7, 1, 3, 5, 7, 6), b=c(2, 4, 6, 7, 8, 2, 4, 6, 8, 7), c=c(NA, NA, NA, NA, NA, 6, 7, 9, 12, 10), d=c(NA, NA, NA, NA, NA, NA, NA, NA, NA, 11))
for (i in 1:nrow(connections)){
    if (is.na(connections$c[i])){
        grid.lines(x=plot_Loc$x[unlist(connections[i,1:2])], y=plot_Loc$y[unlist(connections[i,1:2])], default.units="native")
    } else if (is.na(connections$d[i])) {
        grid.lines(x=median(plot_Loc$x[unlist(connections[i,1:2])]), y=plot_Loc$y[unlist(connections[i,2:3])], default.units="native")
    } else {
        grid.lines(x=median(plot_Loc$x[unlist(connections[i,1:2])]), y=c(plot_Loc$y[connections[i,2]], median(plot_Loc$y[unlist(connections[i,2:3])])), default.units="native")
        grid.lines(x=plot_Loc$x[unlist(connections[i,3:4])], y=median(plot_Loc$y[unlist(connections[i,2:3])]), default.units="native")
        grid.lines(x=plot_Loc$x[connections[i,3]], y=c(median(plot_Loc$y[unlist(connections[i,2:3])]), plot_Loc$y[connections[i,3]]), default.units="native")
        grid.lines(x=plot_Loc$x[connections[i,4]], y=c(median(plot_Loc$y[unlist(connections[i,2:3])]), plot_Loc$y[connections[i,4]]), default.units="native")
    }
}


# Draw four independent line charts.
p <- 1
plot_Line_Chart(data.frame(time=1:1860, EuStockMarkets)[1:3], .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("dodgerblue", "deeppink"), "EU Stocks")
p <- 2
plot_Line_Chart(data.frame(time=1:1860, EuStockMarkets)[c(1,4,5)], .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("green", "purple"), "EU Stocks")
p <- 3
plot_Line_Chart(data.frame(time=1:(12*20), sunspots=sunspot.month[(171*12+1):(171*12+12*20)]), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("darkgoldenrod"), "Sunspots")
p <- 4
plot_Line_Chart(data.frame(time=1:(12*20), temp=nottem), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("red"), "Nottem")

# Draw four independent scatterplots.
p <- 5
plot_Scatterplot(data.frame(time=1:(1860 + 1 - 1000), DAX=rowMeans(embed(EuStockMarkets[,1], 1000)), FTSE=rowMeans(embed(EuStockMarkets[,4], 1000))), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("deeppink", "purple"), "Smooth")
p <- 6
plot_Scatterplot(data.frame(time=1:1860, EuStockMarkets)[c(1,2,5)], .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("deeppink", "purple"), "EU Stocks")
p <- 9
plot_Scatterplot(data.frame(time=1:(1860 + 1 - 20), DAX=rowMeans(embed(EuStockMarkets[,1], 20)), FTSE=rowMeans(embed(EuStockMarkets[,4], 20))), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("deeppink", "purple"), "Smooth*20")
p <- 10
plot_Scatterplot(data.frame(time=1:(1860 + 1 - 100), DAX=rowMeans(embed(EuStockMarkets[,1], 100)), FTSE=rowMeans(embed(EuStockMarkets[,4], 100))), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("deeppink", "purple"), "Smooth*100")


# Draw two independent histograms.
p <- 7
plot_Histogram(data.frame(time=1:(12*20), sunspots=sunspot.month[(171*12+1):(171*12+12*20)]), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("darkgoldenrod"), "Sunspots", breaks=6)
p <- 8
plot_Histogram(data.frame(time=1:(12*20), temp=nottem), .x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .just=c("center","center"), .width=chart_Width, .height=chart_Height, c("red"), "Nottem", breaks=6)

# Draw sample objects in two charts spaces.
p <- 11
draw_Sample_Box(.x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .x_Scale=c(0,10), .y_Scale=c(-10,0), .justify=c("center","center"), .width=chart_Width, .height=chart_Height, .colors=c("dodgerblue","blue"), .box_X=c(4,6,6,4), .box_Y=c(-4,-4,-5,-5), .plot_Title="K")
p <- 12
draw_Sample_Box(.x_Loc=plot_Loc$x[p], .y_Loc=plot_Loc$y[p], .x_Scale=c(-1,1), .y_Scale=c(0,1), .justify=c("center","center"), .width=chart_Width, .height=chart_Height, .colors=c("dodgerblue","blue"), .box_X=c(-0.5,0,0,-0.5), .box_Y=c(0.8,0.8,0.7,0.7), .plot_Title="L")
-------------------------------------------------------------------------------------------------------
m <- read.table(header=T, text='
       X        Y
     0.5      6.0
      1.5      5.0
      2.5      6.7
      3.5      7.1
      4.5      6.1
      5.5      8.1
      6.5      8.0
      7.5      7.9
      8.5      8.0
     9.5      6.0')

with(m,plot(X,Y)) lm_xy <- lm(Y~X,m)

abline(lm_xy,col='blue')

summary(lm_xy) lm nls pn_xy <- nls(Y ~ a*(X - b)^2 + c, start = c(a=0.05, b=8, c=8),data=m)

lines(m$X,predict(pn_xy,m$X),col='red')

summary(pn_xy)
-------------------------------------------------------------------------------------------------------
predict.nls newdata n nls #Here I replaced dData$n with n
dFit <- nls(ttr~fncTtr(n,d),data=dData,start=list(d=25),trace=T)

plot(dData$ttr~dData$n,main="Fitted d value",pch=19,)
xl <- seq(min(dData$n),max(dData$n), (max(dData$n) - min(dData$n))/1000)

a <- predict(dFit,newdata=list(n=xl))
length(a)==length(xl)
[1] TRUE

lines(xl,a,col="blue")
-------------------------------------------------------------------------------------------------------
> dat
  freq1 freq2 gain
1   2.0   6.0   43
2   6.0  18.0   40
3   8.5  10.5   50
4   8.5   9.3   52

> attach(dat)

#Don't actually need to calculate the midpoint but since you suggested it
#that's the way I did it
midpoint = (freq1+freq2)/2
plot(midpoint,gain,xlim=c(min(freq1),max(freq2)),col="white",xlab="")

points(freq1,gain,col=1:length(gain),pch=19)
points(freq2,gain,col=1:length(gain),pch=19)

for(i in 1:length(gain)){
    lines(c(freq1[i],freq2[i]),c(gain[i],gain[i]),col=i)
}
-------------------------------------------------------------------------------------------------------
x = rnorm(300000)
y = jitter(3*x,1000)

fit = lm(y~x)

#Prediction intervals
pred.int =  predict(fit,interval="prediction")

#Confidence intervals
conf.int =  predict(fit,interval="confidence")

fitted.values = pred.int[,1]

pred.lower = pred.int[,2]
pred.upper = pred.int[,3]

plot(x[1:1000],y[1:1000])
lines(x[1:1000],fitted.values[1:1000],col="red",lwd=2)
lines(x[1:1000],pred.lower[1:1000],lwd=2,col="blue")
lines(x[1:1000],pred.upper[1:1000],lwd=2,col="blue")
-------------------------------------------------------------------------------------------------------
# Function to initialize a plotting area.
init_Plot <- function(
    .df,
    .x_Loc, 
    .y_Loc, 
    .justify, 
    .width, 
    .height
    ){

    # Initialize plotting area to fit data.
    # We have to turn off clipping to make it
    # easy to plot the labels around the plot.
    pushViewport(viewport(xscale=c(min(.df[,1]), max(.df[,1])), yscale=c(min(0,min(.df[,-1])), max(.df[,-1])), x=.x_Loc, y=.y_Loc, width=.width, height=.height, just=.justify, clip="off", default.units="npc"))

    # Color behind text.
    grid.rect(x=0, y=0, width=unit(axis_CEX, "lines"), height=1, default.units="npc", just=c("right", "bottom"), gp=gpar(fill=space_Background, col=space_Background))
    grid.rect(x=0, y=1, width=1, height=unit(title_CEX, "lines"), default.units="npc", just=c("left", "bottom"), gp=gpar(fill=space_Background, col=space_Background))

    # Color in the space.
    grid.rect(gp=gpar(fill=chart_Fill, col=chart_Col))
}

# Function to finalize and label a plotting area.
finalize_Plot <- function(
    .df, 
    .plot_Title
    ){

    # Label plot using the internal reference
    # system, instead of the parent window, so
    # we always have perfect placement.
    grid.text(.plot_Title, x=0.5, y=1.05, just=c("center","bottom"), rot=0, default.units="npc", gp=gpar(cex=title_CEX))
    grid.text(paste(names(.df)[-1], collapse=" & "), x=-0.05, y=0.5, just=c("center","bottom"), rot=90, default.units="npc", gp=gpar(cex=axis_CEX))
    grid.text(names(.df)[1], x=0.5, y=-0.05, just=c("center","top"), rot=0, default.units="npc", gp=gpar(cex=axis_CEX))

    # Finalize plotting area.
    popViewport()
}

# Function to plot a filled line chart of
# the data in a data frame.  The first column
# of the data frame is assumed to be the
# plotting index, with each column being a
# set of y-data to plot.  All data is assumed
# to be numeric.
plot_Line_Chart <- function(
    .df,
    .x_Loc,
    .y_Loc,
    .justify,
    .width,
    .height,
    .colors,
    .plot_Title
    ){

    # Initialize plot.
    init_Plot(.df, .x_Loc, .y_Loc, .justify, .width, .height)

    # Calculate what value to use as the
    # return for the polygons.
    y_Axis_Min <- min(0, min(.df[,-1]))

    # Plot each set of data as a polygon,
    # so we can fill it in with color to
    # make it easier to read.
    for (i in 2:ncol(.df)){
        grid.polygon(x=c(min(.df[,1]),.df[,1], max(.df[,1])), y=c(y_Axis_Min,.df[,i], y_Axis_Min), default.units="native", gp=gpar(fill=.colors[i-1], col=.colors[i-1], alpha=1/ncol(.df)))
    }

    # Draw plot axes.
    grid.lines(x=0, y=c(0,1), default.units="npc")
    grid.lines(x=c(0,1), y=0, default.units="npc")

    # Finalize plot.
    finalize_Plot(.df, .plot_Title)

} grid.newpage()

# Specify main chart options.
chart_Fill = "lemonchiffon"
chart_Col = "snow3"
space_Background = "white"
title_CEX = 1.4
axis_CEX = 1

plot_Line_Chart(data.frame(time=1:1860, EuStockMarkets)[1:5], .x_Loc=1, .y_Loc=0, .just=c("right","bottom"), .width=0.9, .height=0.9, c("dodgerblue", "deeppink", "green", "red"), "EU Stocks")

# Specify sub-chart options.
chart_Fill = "lemonchiffon"
chart_Col = "snow3"
space_Background = "lemonchiffon"
title_CEX = 0.8
axis_CEX = 0.7

for (i in 1:4){
    plot_Line_Chart(data.frame(time=1:1860, EuStockMarkets)[c(1,i + 1)], .x_Loc=0.15*i, .y_Loc=0.8, .just=c("left","top"), .width=0.1, .height=0.1, c("dodgerblue", "deeppink", "green", "red")[i], "EU Stocks")
}
-------------------------------------------------------------------------------------------------------
box() par(mfrow=c(2,1))
boxplot(count ~ spray, data = InsectSprays, col = "lightgray")
boxplot(count ~ spray, data = InsectSprays,
        notch = TRUE, add = TRUE, col = "blue")
require(grDevices) # for colours
tN <- table(Ni <- stats::rpois(100, lambda=5))
r <- barplot(tN, col=rainbow(20))
box()
lines(r, tN, type='h', col='red', lwd=2)
-------------------------------------------------------------------------------------------------------
polygon lines pie ... lwd ...
polygon(c(P$x, 0), c(P$y, 0), density = density[i], angle = angle[i], 
        border = border[i], col = col[i], lty = lty[i])
    P <- t2xy(mean(x[i + 0:1]))
    lab <- as.character(labels[i])
    if (!is.na(lab) && nzchar(lab)) {
        lines(c(1, 1.05) * P$x, c(1, 1.05) * P$y)
.... par(lwd = 2) pie # save original settings
opar <- par(no.readonly = TRUE)
par(lwd = 2)
pie(x1$V1, labels=lbls1, col=tail(brewer.pal(3, 'PuBu'), n=2), 
  main=paste('My 3.1415'), cex=1.1) par(lwd = 3) # reset to original
par(opar)
-------------------------------------------------------------------------------------------------------
pairs() panel.cor() panel.cor <- function(x, y, digits=2, cex.cor)
{
  usr <- par("usr"); on.exit(par(usr))
  par(usr = c(0, 1, 0, 1))
  r <- abs(cor(x, y))
  txt <- format(c(r, 0.123456789), digits=digits)[1]
  test <- cor.test(x,y)
  Signif <- ifelse(round(test$p.value,3)<0.001,"p<0.001",paste("p=",round(test$p.value,3)))  
  text(0.5, 0.25, paste("r=",txt))
  text(.5, .75, Signif)
} panel.smooth() cex= col= pch= panel.smooth<-function (x, y, col = "blue", bg = NA, pch = 18, 
                        cex = 0.8, col.smooth = "red", span = 2/3, iter = 3, ...) 
{
  points(x, y, pch = pch, col = col, bg = bg, cex = cex)
  ok <- is.finite(x) & is.finite(y)
  if (any(ok)) 
    lines(stats::lowess(x[ok], y[ok], f = span, iter = iter), 
          col = col.smooth, ...)
} panel.hist() pairs() panel.hist <- function(x, ...)
{
  usr <- par("usr"); on.exit(par(usr))
  par(usr = c(usr[1:2], 0, 1.5) )
  h <- hist(x, plot = FALSE)
  breaks <- h$breaks; nB <- length(breaks)
  y <- h$counts; y <- y/max(y)
  rect(breaks[-nB], 0, breaks[-1], y, col="cyan", ...)
} pairs(USJudgeRatings[,c(2:3,6,1,7)],
          lower.panel=panel.smooth, upper.panel=panel.cor,diag.panel=panel.hist)
-------------------------------------------------------------------------------------------------------
xlim=c(0,40) mp<-barplot(as.matrix(t(df[,2:4])),beside=TRUE,xlim=c(0,40),ann=FALSE)
mp
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
[1,]  1.5  5.5  9.5 13.5 17.5 21.5 25.5 29.5 33.5  37.5
[2,]  2.5  6.5 10.5 14.5 18.5 22.5 26.5 30.5 34.5  38.5
[3,]  3.5  7.5 11.5 15.5 19.5 23.5 27.5 31.5 35.5  39.5 par(new=TRUE) plot() lines() mp axis() par(new=TRUE)
plot(mp[2,],df$CS1,xlim=c(0,40),type="l",col="red",axes=FALSE,ylim=c(0,100),ann=FALSE)
lines(mp[2,],df$CS2,col="blue")
lines(mp[2,],df$CS3,col="green")
axis(1,at=mp[2,],labels=df$V)
axis(4,at=seq(0,100,10))
box()
-------------------------------------------------------------------------------------------------------
y x lw1 <- loess(y ~ x,data=data)
plot(y ~ x, data=data,pch=19,cex=0.1)
j <- order(data$x)
lines(data$x[j],lw1$fitted[j],col="red",lwd=3)
-------------------------------------------------------------------------------------------------------
tapply() data.frame data means <- with(data, tapply(HR, Status, mean))
plot(means, type="l") serr <- with(data, tapply(HR, Status, function(x)sd(x)/sqrt(length(x))))
plot(means, type="o", ylim=c(50,80))
sapply(1:length(serr), function(i) lines(rep(i,2), c(means[i]+serr[i], means[i]-serr[i])))
-------------------------------------------------------------------------------------------------------
freq TRUE freq=TRUE freq=FALSE NA mean(...,na.rm=TRUE) dnorm(x, mean = mean(alvsloss,na.rm=TRUE), sd = sd(alvsloss,na.rm=TRUE)) curve lines(dnorm(x, mean = mean(alvsloss,na.rm=TRUE), sd = sd(alvsloss,na.rm=TRUE)), col="blue", lty="dotted") curve(dnorm,from=ToBeFilled,to=ToBeFilled,col="blue", lty="dotted",mean = mean(alvsloss,na.rm=TRUE), sd = sd(alvsloss,na.rm=TRUE))) ToBeFilled
-------------------------------------------------------------------------------------------------------
ellipse <- function(a,b,xc,yc,...){
    # a is the length of the axis parallel to the x-axis
    # b is the length of the axis parallel to the y-axis
    # xc and yc are the coordinates of the center of the ellipse
    # ... are any arguments that can be passed to function lines
    t <- seq(0, 2*pi, by=pi/100)
    xt <- xc + a*cos(t)
    yt <- yc + b*sin(t)
    lines(xt,yt,...)
    }

plot(UPb, PbPb, pch=19,
     xlab = expression({}^238*"U/"*{}^206*"Pb"), ylab = expression({}^207*"Pb/"*{}^206*"Pb"), 
     xlim = c(0,2500),ylim = c(0, 1), las=1, cex.lab = 1.5)

apply(upbiso, 1, 
      function(x)ellipse(a=x[2]*x[1]/100, b=x[5]*x[4]/100, 
                               xc=x[1], yc=x[4], col="red"))
-------------------------------------------------------------------------------------------------------
import rpy2.robjects.packages.SignatureTranslatedAnonymousPackage as STAP
with open('myfunc.r', 'r') as f:
    string = ''.join(f.readlines())
myfunc = STAP(string, "myfunc") myfunc.myfunc myfunc.getname
-------------------------------------------------------------------------------------------------------
spline splinefun layout(matrix(c(1,2,3),nrow=3,byrow=TRUE))
plot(NA,xlim=c(0,1),ylim=c(0,0.2),xlab="delta",ylab="K", xaxs="i",yaxs="i",
     main='orginal plot with 45000 points') # Empty plot
a1 <- curve((x+x^7-x^2-x^4)/(1+x-x^3-x^4), from=0, n=45000, add = TRUE)
x <- seq(0,1,length.out=1000)
y <- (x+x^7-x^2-x^4)/(1+x-x^3-x^4)
f <- splinefun(x, y)
plot(NA,xlim=c(0,1),ylim=c(0,0.2),xlab="delta",ylab="K", xaxs="i",yaxs="i",
     main='splinefun plot with 1000 points') 
curve(f(x),0, 1, col = "green", lwd = 1.5,add=TRUE)
plot(NA,xlim=c(0,1),ylim=c(0,0.2),xlab="delta",ylab="K", xaxs="i",yaxs="i",
     main='spline plot with 1000 points') 
lines(spline(x,y), col = 2)
-------------------------------------------------------------------------------------------------------
lines() segments() par(las=1,bty="l") dat <- transform(dat,k2=c(0,cumsum(diff(kanzler)!=0))) s <- split(dat,dat$k2) plot(ger.90.10.ratio~year,data=dat,type="n") invisible(lapply(s,
     function(x) with(x,lines(year,ger.90.10.ratio,col=kanzler)))) ggplot2 k2 library("ggplot2")
qplot(year,ger.90.10.ratio,data=dat,colour=factor(kanzler),
      group=k2,geom="line")
-------------------------------------------------------------------------------------------------------
lattice lattice compact library(lattice)
dat <- transform(dat,k2=c(0,cumsum(diff(kanzler)!=0)))
s <- split(dat,dat$k2)
xyplot(ger.90.10.ratio~year,data=dat,type=c('p'),groups=kanzler,
       main = 'THE PARTISAL POLITICAL ECONOMY',
       auto.key=list(columns=2,cex=2,text=c('Democrats','Republicans')),
       panel=function(x,y,...) {
         panel.xyplot(x,y,...)
         lapply(s,function(x) 
          with(x,panel.lines(year,ger.90.10.ratio,col=kanzler)))
         panel.grid()
       })
-------------------------------------------------------------------------------------------------------
viewports library(grid)
grid.newpage()
for (x in 0:3){
  vp <- plotViewport(c(10-x,1+3*x,1+2*x,5-x),
                     xscale=c(0,10),yscale=c(0,10),
                     gp=gpar(alpha=1))
  pushViewport(vp)
  ## here I plot some rectangle since I don't have any data
  grid.rect(x=seq(0.5,10,length.out=20),y=0,width=0.5,height=0.5,
            def='native', just='bottom',
            gp=gpar(fill=grey.colors(4)[4-x+1],alpha=0.5))
  ## axes
  grid.lines(def='native',x=c(0,10),y=0,arrow=arrow())
  grid.lines(def='native',y=c(0,10),x=0,arrow=arrow())
  upViewport()
}
-------------------------------------------------------------------------------------------------------
my_header <- readlines(myfile,n=7) my_data <- read.table(myfile,skip=7,...)
-------------------------------------------------------------------------------------------------------
data=data.frame(x=1:12,y=test)
plot(data)
lines(data)
lines(na.omit(data),col=2) ggplot(data,aes(x,y))+geom_point()+geom_line(data=na.omit(data))
-------------------------------------------------------------------------------------------------------
barplot2() gplots barplot2() ci.l ci.u hh <- t(VADeaths)[1:2, 5:1]
mybarcol <- "gray20"
ci.l <- hh * 0.85
ci.u <- hh * 1.15
mp <- barplot2(hh, beside = TRUE,
               col = c("grey12", "grey82"),
               legend = colnames(VADeaths)[1:2], ylim = c(0, 100),
               cex.names = 1.5, plot.ci = TRUE, ci.l = ci.l, ci.u = ci.u) mp mp
     [,1] [,2] [,3] [,4] [,5]
[1,]  1.5  4.5  7.5 10.5 13.5
[2,]  2.5  5.5  8.5 11.5 14.5 y.cord x.cord mp y.cord<-rbind(c(ci.u[1,]+1),c(apply(ci.u,2,max)+5),
          c(apply(ci.u,2,max)+5),c(ci.u[2,]+1))
x.cord<-apply(mp,2,function(x) rep(x,each=2)) sapply() sapply(1:5,function(x) lines(x.cord[,x],y.cord[,x])) text() x.text<-colMeans(mp)
y.text<-apply(ci.u,2,max)+7
text(c("*","**","***","NS","***"),x=x.text,y=y.text)
-------------------------------------------------------------------------------------------------------
type= l type="b" type="o" lines() plot(1:10, sample(1:10,10), pch=3)              
lines(1:10, sample(1:10,10), pch=1,type="o") type="o" type="b"
-------------------------------------------------------------------------------------------------------
R matpoints matlines boxplot dd <- data.frame(x=rnorm(15), y= rnorm(15))

boxplot(dd, boxwex = 0.3)
# note that you need to transpose `dd`
matpoints(y= t(dd), x= c(1.17,1.83),pch=19, col='black')
matlines(y= t(dd), x= c(1.2,1.8), lty=1, col = 'black')
-------------------------------------------------------------------------------------------------------
lattice #load packages
library(lattice)
library(latticeExtra)

#example data
B <- subset(OrchardSprays, treatment == "B")
D <- subset(OrchardSprays, treatment == "D")
BD <- rbind(B,D)

#create three separate plots
nobox = list(axis.line=list(col="transparent"))#to remove box around plots
boxplotB <- bwplot(decrease ~ treatment, B, ylab = NULL, ylim=c(0,70), 
                   par.settings=nobox)
boxplotD <- bwplot(decrease ~ treatment, D, ylab = NULL, ylim=c(0,70), 
                   par.settings=nobox)
plotBD <- xyplot(decrease ~ treatment, BD, col=1, ylim=c(0,70), pch=16,  
                 par.settings=nobox, panel=function(x, y, ...) {
                   panel.xyplot(x, y, ...)
                   panel.points(x, y, ...)
                   #this loop is required to create connections between points
                   for(i in 1:nrow(B)) 
                        panel.lines(1:2, c(y[i], y[i+nrow(B)]), alpha=0.5, ...)
                   }
                 )

#combine three plots
comb <- c(boxplotB, plotBD, boxplotD, layout = c(3,1), y.same = F)
update(comb, scales = list(at = list(NA, NA, NA), y = list(draw = FALSE)))
-------------------------------------------------------------------------------------------------------
myfun <- function(x,y,par1=NULL,par2=NULL){
  if(is.null(par1)){
    plot(x,y)
  }else{
    do.call(plot,c(list(x=x,y=y),par1))
  }
  if(is.null(par2)){
    lines(x,y)
  }else{
    do.call(lines,c(list(x=x,y=y),par2))
  }
} par1 plot par2 lines do.call myfun(1:10,1:10) # no params
myfun(1:10,1:10,par1=list(pch=20)) # params only to plot
myfun(1:10,1:10,par1=list(pch=20),par2=list(col="red",lwd=2)) # params to plot and lines
-------------------------------------------------------------------------------------------------------
library(grid)
library(lubridate)
library(plyr) set.seed(1)

#############################################
# User settings for the data generation.    #
#############################################

# Set number of hours to generate data for.
time_Periods <- 100

# Set starting datetime in m/d/yyyy hh:mm format.
start_Datetime <- "2/24/2013 00:00"

# Specify a list of websites along with a
# Poisson lambda to represent the average
# number of hits in a given time period.
df_Websites <- read.table(text="
url lambda
http://www.asitenoonereallyvisits.com 1
http://www.asitesomepeoplevisit.com 10
http://www.asitesomemorepeoplevisit.com 20
http://www.asiteevenmorepeoplevisit.com 40
http://www.asiteeveryonevisits.com 80
", header=TRUE, sep=" ")

#############################################
# Generate the data.                        #
#############################################

# Initialize lists to hold hit data and
# website names.
hits <- list()
websites <- list()

# For each time period and for each website,
# flip a coin to see if any visitors come.  If
# visitors come, use a Poisson distribution to
# see how many come.
# Also initialize the list of website names.
for (i in 1:nrow(df_Websites)){
    hits[[i]] <- rbinom(time_Periods, 1, 0.5) * rpois(time_Periods, df_Websites$lambda[i])
    websites[[i]] <- rep(df_Websites$url[i], time_Periods)
}

# Initialize list of time periods.
datetimes <- mdy_hm(start_Datetime) + hours(1:time_Periods)

# Tie the data into a data frame and erase rows with no hits.
# This is what the real data is more likely to look like
# after import and cleaning.
df_Hits <- data.frame(datetime=rep(datetimes, nrow(df_Websites)), hits=unlist(hits), website=unlist(websites))
df_Hits <- df_Hits[df_Hits$hits > 0,]

# Clean up data-generation variables.
rm(list=ls()[ls()!="df_Hits"]) unit(1, "lines") #############################################
# User settings for the graphic.            #
#############################################

# Specify the window width and height and
# pixels per inch.
device_Width=12
device_Height=4.5
pixels_Per_Inch <- 100

# Specify the bin width (in hours) of the
# upper histogram.
bin_Width <- 2

# Specify a padding size for separating text
# from other plot elements.
padding <- unit(1, "strwidth", "W")

# Specify the bin cut-off values for the hit
# counts and the corresponding colors.  The
# cutoff should be the maximum value to be
# contained in the bin.
bin_Settings <- read.table(text="
cutoff color
10 'darkblue'
20 'deepskyblue'
40 'purple'
80 'magenta'
160 'red'
", header=TRUE, sep=" ")

# Specify the size of the histogram plots 
# in 'grid' units.  Override only if necessary.
# histogram_Size <- unit(6, "lines")
histogram_Size <- unit(nrow(bin_Settings) + 1, "lines")

# Set the background color for distinguishing
# between rows of data.
row_Background <- "gray90"

# Set the color for the date lines.
date_Color <- "gray40"

# Set the color for marker lines on histograms.
marker_Color <- "gray80"

# Set the fontsize for labels.
label_Size <- 10 #############################################
# Make the graphic.                         #
#############################################

# Make sure bin cutoffs are in increasing order.
# This way, we can make assumptions later.
bin_Settings <- bin_Settings[order(bin_Settings$cutoff),]

# Initialize plot window.
# Make sure you always specify the pixels per
# inch, so you have an appropriately scaled
# graphic for output.
windows(
    width=device_Width,
    height=device_Height,
    xpinch=pixels_Per_Inch,
    ypinch=pixels_Per_Inch)
grid.newpage()

# Push an initial viewport, so we can set the
# font size to use in calculating label widths.
pushViewport(viewport(gp=gpar(fontsize=label_Size)))

# Find the list of websites in the data.
unique_Urls <- as.character(unique(df_Hits$website))

# Calculate the width of the website
# urls once printed on the screen.
label_Width <- list()
for (i in 1:length(unique_Urls)){
    label_Width[[i]] <- convertWidth(unit(1, "strwidth", unique_Urls[i]), "npc")
}
# Use the maximum url width plus two padding.
x_Label_Margin <- unit(max(unlist(label_Width)), "npc") + padding * 2

# Calculate a height for the date labels plus two padding.
y_Label_Margin <- unit(1, "strwidth", "99/99/9999") + padding * 2

# Calculate size of main plot after making
# room for histogram and label margins.
main_Width <- unit(1, "npc") - histogram_Size - x_Label_Margin
main_Height <- unit(1, "npc") - histogram_Size - y_Label_Margin

# Calculate x values, using the minimum datetime
# as zero, and counting the hours between each
# datetime and the minimum.
x_Values <- as.integer((df_Hits$datetime - min(df_Hits$datetime)))/60^2

# Initialize main plotting area
pushViewport(viewport(
    x=x_Label_Margin,
    y=y_Label_Margin,
    width=main_Width,
    height=main_Height,
    xscale=c(-1, max(x_Values) + 1),
    yscale=c(0, length(unique_Urls) + 1),
    just=c("left", "bottom"),
    gp=gpar(fontsize=label_Size)))

# Put grey background behind every other website
# to make data easier to read, and write urls as
# y-labels.
for (i in 1:length(unique_Urls)){
    if (i%%2==0){
        grid.rect(
            x=unit(-1, "npc"),
            y=i,
            width=unit(2, "npc"),
            height=1,
            default.units="native",
            just=c("left", "center"),
            gp=gpar(col=row_Background, fill=row_Background))
    }

    grid.text(
        unique_Urls[i],
        x=unit(0, "npc") - padding,
        y=i,
        default.units="native",
        just=c("right", "center"))
}

# Find the hour offset of the minimum date value.
time_Offset <- as.integer(format(min(df_Hits$datetime), "%H"))

# Find the dates in the data.
x_Labels <- unique(format(df_Hits$datetime, "%m/%d/%Y"))

# Find where the days begin in the data.
midnight_Locations <- (0:max(x_Values))[(0:max(x_Values)+time_Offset)%%24==0]

# Write the appropriate date labels on the x-axis
# where the days begin.
grid.text(
    x_Labels,
    x=midnight_Locations,
    y=unit(0, "npc") - padding,
    default.units="native",
    just=c("right", "center"),
    rot=90)

# Draw lines to vertically mark when days begin.
grid.polyline(
    x=c(midnight_Locations, midnight_Locations),
    y=unit(c(rep(0, length(midnight_Locations)), rep(1, length(midnight_Locations))), "npc"),
    default.units="native",
    id=rep(midnight_Locations, 2),
    gp=gpar(lty=2, col=date_Color))

# Initialize bin assignment variable.
bin_Assignment <- 1

# Calculate which bin each hit value belongs in.
for (i in 1:nrow(bin_Settings)){
    bin_Assignment <- bin_Assignment + ifelse(df_Hits$hits>bin_Settings$cutoff[i], 1, 0)
}

# Draw points, coloring according to the bin settings.
grid.points(
    x=x_Values,
    y=match(df_Hits$website, unique_Urls),
    pch=19,
    size=unit(1, "native"),
    gp=gpar(col=as.character(bin_Settings$color[bin_Assignment]), alpha=0.5))

# Finalize the main plotting area.
popViewport()

# Create the bins for the upper histogram.
bins <- ddply(
    data.frame(df_Hits, bin_Assignment, mid=floor(x_Values/bin_Width)*bin_Width+bin_Width/2),
    .(bin_Assignment, mid),
    summarize,
    freq=length(hits))

# Initialize upper histogram area
pushViewport(viewport(
    x=x_Label_Margin,
    y=y_Label_Margin + main_Height,
    width=main_Width,
    height=histogram_Size,
    xscale=c(-1, max(x_Values) + 1),
    yscale=c(0, max(bins$freq) * 1.05),
    just=c("left", "bottom"),
    gp=gpar(fontsize=label_Size)))


# Calculate where to put four value markers.
marker_Interval <- floor(max(bins$freq)/4)
digits <- nchar(marker_Interval)
marker_Interval <- round(marker_Interval, -digits+1)

# Draw horizontal lines to mark values.
grid.polyline(
    x=unit(c(rep(0,4), rep(1,4)), "npc"),
    y=c(1:4 * marker_Interval, 1:4 * marker_Interval),
    default.units="native",
    id=rep(1:4, 2),
    gp=gpar(lty=2, col=marker_Color))

# Write value labels for each marker.
grid.text(
    1:4 * marker_Interval,
    x=unit(0, "npc") - padding,
    y=1:4 * marker_Interval,
    default.units="native",
    just=c("right", "center"))

# Finalize upper histogram area, so we
# can turn it back on but with clipping.
popViewport()

# Initialize upper histogram area again,
# but with clipping turned on.
pushViewport(viewport(
    x=x_Label_Margin,
    y=y_Label_Margin + main_Height,
    width=main_Width,
    height=histogram_Size,
    xscale=c(-1, max(x_Values) + 1),
    yscale=c(0, max(bins$freq) * 1.05),
    just=c("left", "bottom"),
    gp=gpar(fontsize=label_Size),
    clip="on"))

# Draw bars for each bin.
for (i in 1:nrow(bin_Settings)){
    active_Bin <- bins[bins$bin_Assignment==i,]
    if (nrow(active_Bin)>0){
        for (j in 1:nrow(active_Bin)){
            grid.rect(
                x=active_Bin$mid[j],
                y=0,
                width=bin_Width,
                height=active_Bin$freq[j],
                default.units="native",
                just=c("center","bottom"),
                gp=gpar(col=as.character(bin_Settings$color[i]), fill=as.character(bin_Settings$color[i]), alpha=1/nrow(bin_Settings)))
        }
    }
}

# Draw x-axis.
grid.lines(x=unit(c(0, 1), "npc"), y=0, default.units="native")

# Finalize upper histogram area.
popViewport()

# Calculate the frequencies for each website and bin.
freq_Data <- ddply(
    data.frame(df_Hits, bin_Assignment),
    .(website, bin_Assignment),
    summarize,
    freq=length(hits))

# Create the line data for the side histogram.
line_Data <- matrix(0, nrow=length(unique_Urls)+2, ncol=nrow(bin_Settings))
for (i in 1:nrow(freq_Data)){
    line_Data[match(freq_Data$website[i], unique_Urls)+1,freq_Data$bin_Assignment[i]] <- freq_Data$freq[i]
}


# Initialize side histogram area
pushViewport(viewport(
    x=x_Label_Margin + main_Width,
    y=y_Label_Margin,
    width=histogram_Size,
    height=main_Height,
    xscale=c(0, max(line_Data) * 1.05),
    yscale=c(0, length(unique_Urls) + 1),
    just=c("left", "bottom"),
    gp=gpar(fontsize=label_Size)))

# Calculate where to put four value markers.
marker_Interval <- floor(max(line_Data)/4)
digits <- nchar(marker_Interval)
marker_Interval <- round(marker_Interval, -digits+1)

# Draw vertical lines to mark values.
grid.polyline(
    x=c(1:4 * marker_Interval, 1:4 * marker_Interval),
    y=unit(c(rep(0,4), rep(1,4)), "npc"),
    default.units="native",
    id=rep(1:4, 2),
    gp=gpar(lty=2, col=marker_Color))

# Write value labels for each marker.
grid.text(
    1:4 * marker_Interval,
    x=1:4 * marker_Interval,
    y=unit(0, "npc") - padding,
    default.units="native",
    just=c("center", "top"))

# Draw lines for each bin setting.
grid.polyline(
    x=array(line_Data),
    y=rep(0:(length(unique_Urls)+1), nrow(bin_Settings)),
    default.units="native",
    id=array(t(matrix(1:nrow(bin_Settings), nrow=nrow(bin_Settings), ncol=length(unique_Urls)+2))),
    gp=gpar(col=as.character(bin_Settings$color)))

# Draw vertical line for the y-axis.
grid.lines(x=0, y=c(0, length(unique_Urls)+1), default.units="native")

# Finalize side histogram area.
popViewport()

# Draw legend.
# Draw box behind legend headers.
grid.rect(
    x=0,
    y=1,
    width=unit(1, "strwidth", names(bin_Settings)[1]) + unit(1, "strwidth", names(bin_Settings)[2]) + 3 * padding,
    height=unit(1, "lines"),
    default.units="npc",
    just=c("left","top"),
    gp=gpar(col=row_Background, fill=row_Background))

# Draw legend headers from bin_Settings variable.
grid.text(
    names(bin_Settings)[1],
    x=padding,
    y=1,
    default.units="npc",
    just=c("left","top"))

grid.text(
    names(bin_Settings)[2],
    x=unit(1, "strwidth", names(bin_Settings)[1]) + 2 * padding,
    y=1,
    default.units="npc",
    just=c("left","top"))

# For each row in the bin_Settings variable,
# write the cutoff values and the color associated.
# Write the color name in the color it specifies.
for (i in 1:nrow(bin_Settings)){
    grid.text(
        bin_Settings$cutoff[i],
        x=unit(1, "strwidth", names(bin_Settings)[1]) + padding,
        y=unit(1, "npc") - i * unit(1, "lines"),
        default.units="npc",
        just=c("right","top"))

    grid.text(
        bin_Settings$color[i],
        x=unit(1, "strwidth", names(bin_Settings)[1]) + 2 * padding,
        y=unit(1, "npc") - i * unit(1, "lines"),
        default.units="npc",
        just=c("left","top"),
        gp=gpar(col=as.character(bin_Settings$color[i])))
}
-------------------------------------------------------------------------------------------------------
plot(log(concentration) ~ time,data=conc) fit <- lm(log(concentration) ~ time,data=conc)
summary(fit)

# Coefficients:
#               Estimate Std. Error t value Pr(>|t|)    
# (Intercept)   5.299355   0.009787   541.4 4.08e-13 ***
#   time       -0.992208   0.005426  -182.9 9.28e-11 ***
#   ---
#   Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 
# 
# Residual standard error: 0.01388 on 5 degrees of freedom
# Multiple R-squared: 0.9999,  Adjusted R-squared: 0.9998 
# F-statistic: 3.344e+04 on 1 and 5 DF,  p-value: 9.281e-11 lines(predict(fit)~conc$time) k <- -coef(fit)[2]
#0.9922081
-------------------------------------------------------------------------------------------------------
llines() lines() xyplot ?llines Description:

     These functions are intended to replace common low level
     traditional graphics functions, primarily for use in panel
     functions. set.seed(1)
dat <- data.frame(pr = PoissonRate(x), x = x)
loess_fit <- loess(pr ~ x, data = dat)

xyplot(PoissonRate(x) ~ x,
  panel = function(x, y, ...) {
    panel.xyplot(x, y, ...)
    llines(dat$x, predict(loess_fit), col.line = "red")
  }) predict x x ## following on from the above
pred <- with(dat, data.frame(x = seq(min(x), max(x), length = 100)))
pred <- transform(pred, pr = predict(loess_fit, newdata = x))

xyplot(PoissonRate(x) ~ x,
  panel = function(x, y, ...) {
    panel.xyplot(x, y, ...)
    with(pred, llines(x, pr, col.line = "red"))
  })
-------------------------------------------------------------------------------------------------------
points lines with(COUNT, plot(SESSION, MEANVISUAL, type='b', 
  ylim=range(MEANVISUAL,MEANOVERLAP,MEANWIDEANGLE)))
with(COUNT, lines(SESSION, MEANOVERLAP, type='b', col='blue', pch=2))
with(COUNT, lines(SESSION, MEANWIDEANGLE, type='b', col='green', pch=3)) matplot matplot( COUNT$SESSION, COUNT[ , 2:4], type='b' )
-------------------------------------------------------------------------------------------------------
y order plot(
  x ~ y, 
  xlab = "y", ylab = "x"  # Confusing...
)
i <- order(y)
lines( y[i], predict(reg4)[i] )
-------------------------------------------------------------------------------------------------------
predict x newdata x x <- c(1,2,3,4,5,6,7,8,9,10)
y <- c(1,4,9,15,25,9,36,25,36,25)
reg4 <- lm( x ~ y + I(y^2) )
## predictions
pred <- data.frame(y = seq(min(y), max(y), length = 100))
pred <- transform(pred, x = predict(reg4, newdata = pred))
## plot
plot(x ~ y)
lines(x ~ y, data = pred, type = "l", col = "red", lwd = 1)
-------------------------------------------------------------------------------------------------------
base plotrix circular.barplot<-function(values, labels, col, cex){
    df<-data.frame(values=sort(values), labels=labels[order(values)])
    col<-col[order(values)]
    plot(NA,xlim=c(-1.3,1.3),ylim=c(-1.3,1.3),axes=F, xlab=NA, ylab=NA, asp=1)
    t<-sapply(df$values,function(x).5*pi-seq(0, 2*pi*x/100,length=1000))
    x<-sapply(1:nrow(df),function(x)(.3+x/nrow(df))*cos(t[,x]))
    y<-sapply(1:nrow(df),function(x)(.3+x/nrow(df))*sin(t[,x]))
    for(i in 1:nrow(df)){
        lines(x=x[,i],y=y[,i],col=col[i],lwd=10,lend=1)
        text(x[1,i],y[1,i],paste(df$labels[i]," - ",df$values[i],"%",sep=""),
             pos=2,cex=cex)
        }
    }
-------------------------------------------------------------------------------------------------------
nls() fit <- nls(ratio ~ exp(-b*(years-1890)), start=list(b=0.5))
fit

Nonlinear regression model
  model:  ratio ~ exp(-b * (years - 1890)) 
   data:  parent.frame() 
     b 
0.2051 
 residual sum-of-squares: 0.05669

Number of iterations to convergence: 5 
Achieved convergence tolerance: 5.016e-06 plot(ratio~years, ylim=c(0,1))
newdata <- data.frame(years=1890:1917)
lines(newdata$years, predict(fit, newdata=newdata), col="red")
-------------------------------------------------------------------------------------------------------
rnormgammamix <- function(n,shape,rate,mean,sd,prob) {
    ifelse(runif(n)<prob,
           rgamma(n,shape,rate),
           rnorm(n,mean,sd))
} dnormgammamix <- function(x,shape,rate,mean,sd,prob,log=FALSE) {
    r <- prob*dgamma(x,shape,rate)+(1-prob)*dnorm(x,mean,sd)
    if (log) log(r) else r
} set.seed(101)
r <- rnormgammamix(1000,1.5,2,3,2,0.5)
d <- data.frame(r) bbmle library("bbmle")
m1 <- mle2(r~dnormgammamix(exp(logshape),exp(lograte),mean,exp(logsd),
                     plogis(logitprob)),
     data=d,
     start=list(logshape=0,lograte=0,mean=0,logsd=0,logitprob=0))
cc <- coef(m1)

png("normgam.png")
par(bty="l",las=1)
hist(r,breaks=100,col="gray",freq=FALSE)
rvec <- seq(-2,8,length=101)
pred <- with(as.list(cc),
             dnormgammamix(rvec,exp(logshape),exp(lograte),mean,
                           exp(logsd),plogis(logitprob)))
lines(rvec,pred,col=2,lwd=2)
true <- dnormgammamix(rvec,1.5,2,3,2,0.5)
lines(rvec,true,col=4,lwd=2)
dev.off() tcc <- with(as.list(cc),
            c(shape=exp(logshape),
              rate=exp(lograte),
              mean=mean,
              sd=exp(logsd),
              prob=plogis(logitprob)))
cbind(tcc,c(1.5,2,3,2,0.5)) library("MASS")
ff <- fitdistr(r,dnormgammamix,
     start=list(shape=1,rate=1,mean=0,sd=1,prob=0.5))

cbind(tcc,ff$estimate,c(1.5,2,3,2,0.5)) fitdistr mle2 ff2 <- fitdistr(r,dnormgammamix,
     start=list(shape=1.5,rate=2,mean=3,sd=2,prob=0.5))
-logLik(ff2)  ## 1725.994
-logLik(ff)   ## 1755.458
-------------------------------------------------------------------------------------------------------
set.seed(5)
data <- data.frame(1:60, rnorm(60, 0.6, 0.1), rnorm(60, 0.65, 0.15), 
                   seq(2,120,by=2)) type='n' plot(range(data[,4]), range(c(data[,3],data[,2])), type='n')
lines(data[,4], data[,3], type='l', col='green')
lines(data[,4], data[,2], type='l', col='red')
-------------------------------------------------------------------------------------------------------
## simulate some data - from mgcv::magic
set.seed(1)
n <- 400
x <- 0:(n-1)/(n-1)
f <- 0.2*x^11*(10*(1-x))^6+10*(10*x)^3*(1-x)^10
y <- f + rnorm(n, 0, sd = 2)

## load the splines package - comes with R
require(splines) bs() lm bs mod <- lm(y ~ bs(x, knots = seq(0.1, 0.9, by = 0.1))) > anova(mod)
Analysis of Variance Table

Response: y
                                        Df Sum Sq Mean Sq F value    Pr(>F)    
bs(x, knots = seq(0.1, 0.9, by = 0.1))  12 2997.5 249.792  65.477 < 2.2e-16 ***
Residuals                              387 1476.4   3.815                      
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 bs Boundary.knots Boundary.knots = range(x) knots ?bs x predict x pdat <- data.frame(x = seq(min(x), max(x), length = 100))
## predict for new `x`
pdat <- transform(pdat, yhat = predict(mod, newdata = pdat))

## now plot
ylim <- range(pdat$y, y) ## not needed, but may be if plotting CIs too
plot(y ~ x)
lines(yhat ~ x, data = pdat, lwd = 2, col = "red")
-------------------------------------------------------------------------------------------------------
plot.gam library(mgcv)
set.seed(2)
a <- rnorm(100)
b <- runif(100)
y <- a*b/(a+b)
dat <- data.frame(y = y, a = a, b = b)

mod <- gam(y~s(a)+s(b), data = dat) pdat <- with(dat,
             data.frame(a = c(seq(min(a), max(a), length = 100),
                              rep(mean(a), 100)),
                        b = c(rep(mean(b), 100),
                              seq(min(b), max(b), length = 100)))) pred <- predict(mod, pdat, type = "response", se.fit = TRUE)

> lapply(pred, head)
$fit
        1         2         3         4         5         6 
0.5842966 0.5929591 0.6008068 0.6070248 0.6108644 0.6118970 

$se.fit
       1        2        3        4        5        6 
2.158220 1.947661 1.753051 1.579777 1.433241 1.318022 $fit pdat b a a b fitted upper lower pdat <- transform(pdat, fitted = pred$fit)
pdat <- transform(pdat, upper = fitted + (1.96 * pred$se.fit),
                        lower = fitted - (1.96 * pred$se.fit)) 1:100 a 101:200 b layout(matrix(1:2, ncol = 2))
## plot 1
want <- 1:100
ylim <- with(pdat, range(fitted[want], upper[want], lower[want]))
plot(fitted ~ a, data = pdat, subset = want, type = "l", ylim = ylim)
lines(upper ~ a, data = pdat, subset = want, lty = "dashed")
lines(lower ~ a, data = pdat, subset = want, lty = "dashed")
## plot 2
want <- 101:200
ylim <- with(pdat, range(fitted[want], upper[want], lower[want]))
plot(fitted ~ b, data = pdat, subset = want, type = "l", ylim = ylim)
lines(upper ~ b, data = pdat, subset = want, lty = "dashed")
lines(lower ~ b, data = pdat, subset = want, lty = "dashed")
layout(1) ylim ylim <- with(pdat, range(fitted, upper, lower)) type = "terms" pred2 <- predict(mod, pdat, type = "terms", se.fit = TRUE) $fit $se.fit > lapply(pred2, head)
$fit
        s(a)       s(b)
1 -0.2509313 -0.1058385
2 -0.2422688 -0.1058385
3 -0.2344211 -0.1058385
4 -0.2282031 -0.1058385
5 -0.2243635 -0.1058385
6 -0.2233309 -0.1058385

$se.fit
      s(a)      s(b)
1 2.115990 0.1880968
2 1.901272 0.1880968
3 1.701945 0.1880968
4 1.523536 0.1880968
5 1.371776 0.1880968
6 1.251803 0.1880968 $fit pdat pdat <- transform(pdat, fitted = c(pred2$fit[1:100, 1], 
                                   pred2$fit[101:200, 2]))
pdat <- transform(pdat, upper = fitted + (1.96 * c(pred2$se.fit[1:100, 1], 
                                                   pred2$se.fit[101:200, 2])),
                        lower = fitted - (1.96 * c(pred2$se.fit[1:100, 1], 
                                                   pred2$se.fit[101:200, 2]))) 1:100 a 101:200 b layout(matrix(1:2, ncol = 2))
## plot 1
want <- 1:100
ylim <- with(pdat, range(fitted[want], upper[want], lower[want]))
plot(fitted ~ a, data = pdat, subset = want, type = "l", ylim = ylim)
lines(upper ~ a, data = pdat, subset = want, lty = "dashed")
lines(lower ~ a, data = pdat, subset = want, lty = "dashed")
## plot 2
want <- 101:200
ylim <- with(pdat, range(fitted[want], upper[want], lower[want]))
plot(fitted ~ b, data = pdat, subset = want, type = "l", ylim = ylim)
lines(upper ~ b, data = pdat, subset = want, lty = "dashed")
lines(lower ~ b, data = pdat, subset = want, lty = "dashed")
layout(1) b a
-------------------------------------------------------------------------------------------------------
x <- seq(0, 1, by=0.2)
plot(  x, x,   type="l" )
lines( x, x^2, col="red" )
xx1 <- c(0,x[x<1  & x>0 ],1,x[x<1  & x>0 ],0)
yy1 <- c(0,x[x<1  & x>0 ],1,x[x<1  & x>0 ]^2,0)
polygon(xx1, yy1, lwd=3, col="wheat")
points(xx1, yy1) xx1 plot(  x, x,   type="l" )
lines( x, x^2, col="red" )
xx1 <- c(x, rev(x))
yy1 <- c(x, rev(x)^2)
polygon(xx1, yy1, lwd=3, col="wheat")
-------------------------------------------------------------------------------------------------------
f optim fitG =
function(x,y,mu,sig,scale){

  f = function(p){
    d = p[3]*dnorm(x,mean=p[1],sd=p[2])
    sum((d-y)^2)
  }

  optim(c(mu,sig,scale),f)
 } fit2G <- function(x,y,mu1,sig1,scale1,mu2,sig2,scale2,...){

  f = function(p){
    d = p[3]*dnorm(x,mean=p[1],sd=p[2]) + p[6]*dnorm(x,mean=p[4],sd=p[5])
    sum((d-y)^2)
  }
  optim(c(mu1,sig1,scale1,mu2,sig2,scale2),f,...)
} > fit2P = fit2G(data$V3,data$V6,6,.6,.02,8.3,0.10,.002,control=list(maxit=10000))
Warning messages:
1: In dnorm(x, mean = p[1], sd = p[2]) : NaNs produced
2: In dnorm(x, mean = p[4], sd = p[5]) : NaNs produced
3: In dnorm(x, mean = p[4], sd = p[5]) : NaNs produced
> fit2P
$par
[1] 6.035610393 0.653149616 0.023744876 8.317215066 0.107767881 0.002055287 > plot(data$V3,data$V6)
> p = fit2P$par
> lines(data$V3,p[3]*dnorm(data$V3,p[1],p[2]))
> lines(data$V3,p[6]*dnorm(data$V3,p[4],p[5]),col=2) > fit2P = fit2G(data$V3,data$V6,6,.6,.02,8.3,0.10,.002,control=list(maxit=10000),method="L-BFGS-B",lower=c(0,0,0,0,0,0))
> fit2P
$par
[1] 6.03564202 0.65302676 0.02374196 8.31424025 0.11117534 0.00208724
-------------------------------------------------------------------------------------------------------
set.seed(1)
dat <- data.frame(y = rnorm(100))
dat <- transform(dat,
                 x1 = 0.2 + (0.4 * y) + rnorm(100),
                 x2 = 2.4 + (2.3 * y) + rnorm(100)) mod <- lm(y ~ x1 + x2, data = dat) pdatx1 <- with(dat, data.frame(x1 = seq(min(x1), max(x1), length = 100),
                               x2 = rep(mean(x2), 100)))
pdatx2 <- with(dat, data.frame(x1 = rep(mean(x1), 100),
                               x2 = seq(min(x2), max(x2), length = 100))) pdatx1 <- transform(pdatx1, yhat = predict(mod, pdatx1))
pdatx2 <- transform(pdatx2, yhat = predict(mod, pdatx2)) y ylim <- range(pdatx1$y, pdatx2$y, dat$y) layout(matrix(1:2, ncol = 2))
plot(y ~ x1, data = dat)
lines(yhat ~ x1, data = pdatx1, col = "red", lwd = 2)
plot(y ~ x2, data = dat)
lines(yhat ~ x2, data = pdatx2, col = "red", lwd = 2)
layout(1)
-------------------------------------------------------------------------------------------------------
lines circleFun lines() par(mfrow=c(1, 2))

plot(x=c(-1, 0, 1), y=c(-1, 1, -1), xlim=c(-2, 2), ylim=c(-2, 2),
     type="l", asp=1)
points(x=c(-1, 1), y=c(-1, -1))

plot(x=c(-1, 0, 1, -1), y=c(-1, 1, -1, -1), xlim=c(-2, 2), ylim=c(-2, 2),
     type="l", asp=1)
points(x=c(-1, 1), y=c(-1, -1))
-------------------------------------------------------------------------------------------------------
data<-data.frame(x=c(50,100,250,400),y1=c(0.74,0.75,0.82,0.79),y2=c(0.81,0.83,0.87,0.88))

windows()
plot(data$x,data$y1,type="l",col="red", ylim=c(0.5,1),xlim= c(50,500),col.axis = "white")
axis(1, xaxp=c(50,500,9))
axis(2, yaxp=c(0.5,1,10)) 
lines(data$x, data$y2, type='l',col="blue")

for(i in c(0.55,0.6,0.65,0.7,0.75,0.8,0.85,0.9,0.95)) {
lines(c(50,500),c(i,i),type="l",lty=2,lwd=0.5, col="black")
rm(i)
}
-------------------------------------------------------------------------------------------------------
lm library(zoo)
data1 <- read.table(text="
2012-01-11  99.06
2012-01-19 100.45
2012-02-07  98.11
2012-03-02 106.92
2012-04-19 106.78
2012-05-16 102.34
2012-07-05 119.05
2012-07-30 116.54
2012-08-03 116.06
2012-08-29 111.49
2012-09-07 112.69
2012-10-09 120.25
2012-10-17 119.70
2012-11-12 107.62
2012-12-05 105.53
2012-12-13 107.86
2013-01-10 109.77
2013-02-25 115.71")
data1 <-zoo(data1[,2],as.Date(data1[,1]))
plot.zoo(data1, type="p", col="blue", pch=16)

my.comb <-combn(data1, 3,simplify = FALSE)

for (i in 1:length(my.comb)){
vect <- my.comb[[i]]
reg <-lm(coredata(vect)~index(vect))
if(summary(reg)$adj.r.squared>0.9999) lines(my.comb[[i]], col="red")
}
-------------------------------------------------------------------------------------------------------
for loop for (x in 2:6) {
  lines(beforendafterdata[,x], ...)
} reshape2 ggplot2 melt ggplot2 library(reshape2)
beforeandafter_melted <- melt(beforeandafterdata) color group library(ggplot2)
ggplot(beforeandafter_melted, aes(x=Var1, y=value, color=factor(Var2), group=Var2)) + 
  geom_line() Var1 Var2 beforeandafterdata x <- c(1*2:307) 2:307 all.equal(c(1*2:307), 2:307)
# [1] TRUE
-------------------------------------------------------------------------------------------------------
xy.coords lines plot(beforeandafterdata[,1],type="l",col="black",xlim=c(0.9,2.1),ylim=ylimits,
     ann=FALSE,axes=FALSE) 
title(ylab=ylabel, cex.lab=1.4) 
axis(1,at=1:2,lab=c("Preop.","Postop."),cex.axis=1.5)
axis(2,labels=TRUE) 
x<-c(1*2:6) 
x 
lapply(x, function(x){
lines(xy.coords(x=c(1, 2), y=c(beforeandafterdata[,x])), type="l", col="black", 
      xlim=c(0.9,2.1),ylim=ylimits,ann=FALSE)
})
-------------------------------------------------------------------------------------------------------
layer() as.layer() + library(latticeExtra)
my.panel.loess <- function(x, y, span = 2/3, degree = 0.5, ...) {
    loess.fit <- loess.smooth(x, y, span = span, dgree = degree )
    panel.lines(loess.fit$x, loess.fit$y, ...)
}

## A plot with the smoothing lines
a <- xyplot(y ~ x|a, data = df, groups = b, type="l",
            panel=function(...) panel.superpose(panel.groups=my.panel.loess,...))
## A plot with the points
b <- xyplot(y ~ x|a, data=df, groups=b)

## Both together
plot(a+b)
-------------------------------------------------------------------------------------------------------
hist plot df <- read.table(text=" lowInts diving.means
X0         0  3.330978261
X3         3  3.299456522
X10       10  8.857608696
X20       20 17.646195652
X50       50 30.261413043
X100     100 29.356521739
X150     150  6.445108696
X200     200  0.664130435
X300     300  0.135869565
X400     400  0.001630435")

require(splines)
dens <-predict(interpSpline(df[,1], df[,2]))
plot(df[,1], df[,2], type="s", ylim=c(0,40))
lines(dens, col="red",lwd=2)
-------------------------------------------------------------------------------------------------------
set.seed(1)
x<-rlnorm(100)
hist(x, prob=TRUE)

lines(density(x), col='red')

library(ks)
tmp <- kde(x, hpi(x))
lines(tmp$eval.points, tmp$estimate, col='green')

library(logspline)
lsfit <- logspline(x, lbound=0)
curve( dlogspline(x,lsfit), add=TRUE, col='blue' )

curve( dlnorm, add=TRUE, col='orange' ) rlogspline plogspline qlogspline
-------------------------------------------------------------------------------------------------------
plot lines col ?plot ?lines ?points file1=read.table(text="x y
0.01 2
0.02 3
0.03 4",header=T)

file2=read.table(text="x y
0.015 3
0.024 6 
0.34  56",header=T)


plot(file1$x, file1$y, col="red", type='l', xlim=c(0,0.5), ylim=c(0,100))
lines(file2$x, file2$y, col="blue")
-------------------------------------------------------------------------------------------------------
d = data.frame(a = rnorm(100), b = rnorm(100, 1), c = rnorm(100, 2), d = rnorm(100, 3), e = rnorm(100, 4))

plot(density(d$a), xlim = c(-4, 8))
lines(density(d$b), col = "red")
lines(density(d$c), col = "green")
lines(density(d$d), col = "blue")
lines(density(d$e), col = "yellow")
-------------------------------------------------------------------------------------------------------
library(xts)
set.seed(21)
x <- xts(rnorm(10),Sys.Date()-10:1)
y <- xts(rnorm(3),Sys.Date()+0:2)
z <- merge(x,y)
plot(z[,1], ylim=range(z,na.rm=TRUE))
lines(z[,2],col='red')
-------------------------------------------------------------------------------------------------------
lines() plot() lines() plot ?lines
-------------------------------------------------------------------------------------------------------
lty plot() lines()
-------------------------------------------------------------------------------------------------------
library(EMD)
x <- as.vector(sunspots)
r <- emd(x)
# Keep 5 components -- you may need more, or less.
y <- apply( r$imf[,5:10], 1, sum ) + mean(r$residue)
plot(x, type="l", col="grey")
lines( y, type="l", lwd=2)
n <- length(y)
i <- y[2:(n-1)] > y[1:(n-2)] & y[2:(n-1)] > y[3:n]
points( which(i), y[i], pch=15 )
-------------------------------------------------------------------------------------------------------
lm(stock ~ poly(t, 6)) 

Call:
lm(formula = stock ~ poly(t, 6))

Coefficients:
(Intercept)  poly(t, 6)1  poly(t, 6)2  poly(t, 6)3  poly(t, 6)4  poly(t, 6)5  
    1030800      8866278      2217055       724873      -611351       580051  
poly(t, 6)6  
     721027  

plot(t, stock)
lines(t, predict(lm(stock ~ poly(t, 6, raw=TRUE)) ) )
lines(t, predict(lm(stock ~ poly(t, 6)) ) , col="red", lwd=3)
-------------------------------------------------------------------------------------------------------
png mean=100; sd=15
lb=80; ub=120

x <- seq(-4,4,length=100)*sd + mean
hx <- dnorm(x,mean,sd)

# load package and an image
library(png)
ima <- readPNG("Red_Hot_Sun.PNG")

# plot an empty plot with your labels, etc.
plot(1,xlim=c(min(x),max(x)), type="n", xlab="IQ Values", ylab="Density",
  main="Normal Distribution", axes=FALSE)
# put in the image
lim <- par()
rasterImage(ima, lim$usr[1], lim$usr[3], lim$usr[2], lim$usr[4])

# add your plot
par(new=TRUE)
plot(x, hx, xlim=c(min(x),max(x)), type="l", xlab="", ylab="", axes=FALSE)
i <- x >= lb & x <= ub
lines(x, hx)
# add a polygon to cover the background above plot
polygon(c(x,180,180,20,20), c(hx,0,1,1,0), col="white")
# add polygons to cover the areas under the plot you don't want visible
polygon(c(-20,-20,x[x<=lb],lb), c(-10,min(hx),hx[x<=lb],-10), col="white")
polygon(c(ub,x[x>=ub],200,200), c(-1,hx[x>=ub],min(hx),-1), col="white")

# add your extra text
area <- pnorm(ub, mean, sd) - pnorm(lb, mean, sd)
result <- paste("P(",lb,"< IQ <",ub,") =",
   signif(area, digits=3))
mtext(result,2)
-------------------------------------------------------------------------------------------------------
m = matrix(rnorm(60), ncol=3) plot(density(m[,1]), col=2) lines1E lines1E = function(x) {lines(density(x))} colwise(lines1E)(as.data.frame(m[ ,2:3])) ##Added in NA for illustration
m = matrix(rnorm(60), ncol=3)
m[1,] = NA
plot(density(m[,1], na.rm=T))
sapply(2:ncol(m), function(i) lines(density(m[,i], na.rm=T), col=i))
-------------------------------------------------------------------------------------------------------
by length x x sigma <- 1
mu    <- 0

lower.x <- -0.0
upper.x <-  2.1

x  <- seq(-4, 4, by = 0.1)
y  <- ( 1/(sigma * sqrt(2*pi)) ) * ( exp(1)^( (-1 * ((x - mu)^2)) / (2*(sigma^2)) ) )
plot(x,y,type="l", lwd=2, col="blue")

x=seq(lower.x, upper.x, by = 0.1)
y  <- ( 1/(sigma * sqrt(2*pi)) ) * ( exp(1)^( (-1 * ((x - mu)^2)) / (2*(sigma^2)) ) )
polygon(c(lower.x,x,upper.x), c(0,y,0), col="gray")
lines(x, y, col="blue", lwd=2)
-------------------------------------------------------------------------------------------------------
s <- seq(-.25,.35,0.01)
plot(s, dnorm(s,mean1, sd1), type="l")
lines(s, dnorm(s,mean2, sd2), col="red")
-------------------------------------------------------------------------------------------------------
panel.lines() panel.text() function () {
    trellis.device(width = 5, height = 5, new = F)
    xx <- GERD95.06
    xx$Country <- c("USA", "Singapore", "Denmark", "Australia", 
        "NZ")
    barchart(X1995 + X2006 ~ reorder(Country, xx$X2006), data = xx, 
        ylab = "GERD per capita, nominal $US PPP", cex = 0.8, 
        panel = function(...) {
            panel.lines(c(0.7, 5), c(720, 720), col = "gray", 
                lwd = 4)
            panel.text(lab = "OECD avg 2006", x = 1, y = 750, 
                adj = c(0.4, 0), cex = 0.7)
            panel.text(lab = "NZ at 2.5% of GDP", x = 1, y = 630, 
                adj = c(0.4, 0), cex = 0.7)
            panel.text(lab = "1995", x = 1.5, y = 900, adj = c(1, 
                0.5))
            panel.rect(xleft = 1.6, xright = 2, ybottom = 870, 
                ytop = 930, col = 3)
            panel.text(lab = "2006", x = 1.5, y = 1000, adj = c(1, 
                0.5))
            panel.rect(xleft = 1.6, xright = 2, ybottom = 970, 
                ytop = 1030, col = 8)
            panel.barchart(..., col = c(3, 8))
            panel.rect(xleft = 1, xright = 1.3333, ybottom = xx$X2006[xx$Country == 
                "NZ"], ytop = 2.5/1.206 * xx$X2006[xx$Country == 
                "NZ"])
        }, ylim = c(0, 1200))
}
-------------------------------------------------------------------------------------------------------
model<-nls(y~a+b*x^k,my.data,list(a=0.,b=1.,k=1))
plot(y~x,my.data)
a<-coef(model)[1]
b<-coef(model)[2]
k<-coef(model)[3]
lines(x<-c(1:10),a+b*x^k,col='red')
-------------------------------------------------------------------------------------------------------
panel plot.zoo ax.date <-as.POSIXlt("2013-01-06")+(0:167)*3600 #Dummy date for POSIXlt method

my.panel <- function(x, y, ..., pf = parent.frame()) {
 grid(NA,NULL)
 abline(v=seq(1,168,24),col = "lightgray", lty = "dotted", lwd = par("lwd"))
 lines(x, y, ...)

 #if bottom panel
 if (with(pf, length(panel.number) == 0 ||
        panel.number %% nr == 0 || panel.number == nser)) {
      # create ticks at x values and then label every 24th tick
      axis(side = 1, at = x, labels = FALSE, tcl=-0.3) #hour ticks
      axis(side = 1, at = seq(1,168,6), labels = FALSE) #6hour ticks ticks
      axis(1,at=seq(1,168,24), labels=format(ax.date[seq(1,168,24)],"%a")) #day of the week
      axis(1,at=seq(13,168,24),labels=format(ax.date[seq(13,168,24)],"%H"), cex.axis=0.7) #noon ticks
   }
 }
 plot(z[,3:5], panel = my.panel,yax.flip=TRUE,col=1:3,xaxt="n")
-------------------------------------------------------------------------------------------------------
#' Plot two dimensional histogram
#'
#' @param hist matrix or two dimensional array containing the number of counts
#' in each of the bins.
#' @param borders_x the x-borders of the bins in the histogram. Should be a
#' numeric vector with lenght one longer than the number of columns of
#' \code{hist}
#' @param borders_y the y-borders of the bins in the histogram. Should be a
#' numeric vector with lenght one longer than the number of rows of
#' \code{hist}
#' @param type a character specifying the type of plot. Valid values are "text",
#' "area" and "color". See details for more information.
#' @param add add the plot to an existing one or create a new plot.
#' @param add_lines logical specifying whether or not lines should be drawn
#' between the bins.
#' @param draw_empty if \code{FALSE} empty bins (numer of counts equal to zero)
#' are not drawn. They are shown using the background color.
#' @param col for types "area" and "text" the color of the boxes and text.
#' @param line_col the color of the lines between the bins.
#' @param background_col the background color of the bins.
#' @param lty the line type of the lines between the bins.
#' @param text_cex the text size used for type "text". See \code{\link{par}} for
#' more information.
#' @param col_range the color scale used for type "color". Should be a function
#' which accepts as first argument the number of colors that should be
#' generated. The first color generated is used for the zero counts; the
#' last color for the highest number of counts in the histogram.
#' @param ... additional arguments are passed on to \code{\link{plot}}.
#'
#' @details
#' There are three plot types: "area", "text", and "color". In case of "area"
#' rectangles are drawn inside the bins with area proportional to the number of
#' counts in the bins. In case of text the number of counts is shown as text in
#' the bins. In case of color a color scale is used (by default heat.colors) to
#' show the number of counts.
#'
#' @seealso \code{\link{image}} which can be used to create plots similar to
#' type "color". \code{\link{contour}} may also be of interest.
#'
#' @examples
#' histplot2(volcano - min(volcano), type="color")
#' histplot2(volcano - min(volcano), add_lines=FALSE, type="area")
#' histplot2(volcano - min(volcano), type="text", text_cex=0.5)
#'
#' @export
histplot2 <- function(hist, borders_x=seq(0, ncol(hist)),
        borders_y=seq(0, nrow(hist)), type="area", add=FALSE, add_lines=TRUE,
        draw_empty=FALSE, col="black", line_col="#00000030",
        background_col="white", lty=1, text_cex=0.6, col_range=heat.colors, ...) {
    # create new plot
    rangex <- c(min(borders_x), max(borders_x))
    rangey <- c(min(borders_y), max(borders_y))
    if (add == FALSE) {
        plot(rangex, rangey, type='n', xaxs='i', yaxs='i', ...)
        rect(rangex[1], rangey[1], rangex[2], rangey[2], col=background_col,
            border=NA)
    }
    # prepare data
    nx <- length(borders_x)-1
    ny <- length(borders_y)-1
    wx <- rep(diff(borders_x), each=ny)
    wy <- rep(diff(borders_y), times=nx)
    sx <- 0.95*min(wx)/sqrt(max(hist))
    sy <- 0.95*min(wy)/sqrt(max(hist))
    x <- rep((borders_x[-length(borders_x)] + borders_x[-1])/2, each=ny)
    y <- rep((borders_y[-length(borders_y)] + borders_y[-1])/2, times=nx)
    h <- as.numeric(hist)
    # plot type "area"
    if (type == "area") {
        dx <- sqrt(h)*sx*0.5
        dy <- sqrt(h)*sy*0.5
        rect(x-dx, y-dy, x+dx, y+dy, col=col, border=NA)
    # plot type "text"
    } else if (type == "text") {
        if (draw_empty) {
            text(x, y, format(h), cex=text_cex, col=col)
        } else {
            text(x[h!=0], y[h!=0], format(h[h!=0]), cex=text_cex, col=col)
        }
    # plot type "color"
    } else if (type == "color" | type == "colour") {
        #h <- h/(wx*wy)
        col <- col_range(200)
        col <- col[floor(h/max(h)*200*(1-.Machine$double.eps))+1]
        sel <- rep(TRUE, length(x))
        if (!draw_empty) sel <- h > 0
        rect(x[sel]-wx[sel]/2, y[sel]-wy[sel]/2, x[sel]+wx[sel]/2,
            y[sel]+wy[sel]/2, col=col[sel], border=NA)
    } else {
        stop("Unknown plot type: options are 'area', 'text' and 'color'.")
    }
    # add_lines
    if (add_lines) {
        lines(rbind(borders_x, borders_x, NA),
            rbind(rep(rangey[1], nx+1), rep(rangey[2], nx+1), NA),
            col=line_col, lty=lty)
        lines(rbind(rep(rangex[1], ny+1), rep(rangex[2], ny+1), NA),
            rbind(borders_y, borders_y, NA), col=line_col, lty=lty)
    }
    # add border
    if (add == FALSE) box()
} X <- matrix(nrow=3, ncol=3)
X[1,] <- c(0.3, 0.4, 0.45)
X[2,] <- c(0.3, 0.7, 0.65)
X[3,] <- c(0.3, 0.4, 0.45)
centers <- c(1.5, 3, 4)

centers_to_borders <- function(centers) {
    nc <- length(centers)
    d0 <- centers[2]-centers[1]
    d1 <- centers[nc]-centers[nc-1]
    c(centers[1]-d0/2, 
      (centers[2:nc] + centers[1:(nc-1)])/2, centers[nc]+d1/2)
}

histplot2(X, centers_to_borders(centers), 
    centers_to_borders(centers), type="color") plot_range <- function(hist, col_range = heat.colors) {
    r <- range(c(0, X))
    par(cex=0.7, mar=c(8, 1, 8, 2.5))
    plot(0, 0, type='n', xlim=c(0,1), ylim=r, xaxs='i',
        yaxs='i', bty='n', xaxt='n', yaxt='n', xlab='', ylab='')
    axis(4)
    y <- seq(r[1], r[2], length.out=200)
    yc <- floor(y/max(y)*5*(1-.Machine$double.eps))+1
    col <- col_range(5)[yc]
    b <- centers_to_borders(y)
    rect(rep(0, length(y)), b[-length(b)], rep(1, length(y)), 
        b[-1], col=col, border=NA)
} layout layout(matrix(c(1,2), nrow = 1), widths = c(0.9, 0.1))
par(mar = c(5, 4, 4, 2) + 0.1)
histplot2(X, centers_to_borders(centers), 
    centers_to_borders(centers), type="color")
plot_range(X) histplot2 h <- h/(wx*wy)
-------------------------------------------------------------------------------------------------------
data1 data1 = read.table('data1_lambda.dat', ...)
data2 = read.table('data2_lambda.dat', ...)
data3 = read.table('data3_lambda.dat', ...) plot(data.frame(data1[1], data1[2]), ...)
lines(data.frame('data2[1]', 'data2[2]', ...)
lines(data.frame('data3[1]', 'data3[2]', ...) data2 data3 'data2' 'data3' plot(data.frame(data1[1], data1[2]), xlim=c(-0.2, -7), ylim=c(0.31, 0.35), yaxt="n", type="l", xlab="", ylab="",lty="solid", col="red2", lwd=4, axes=TRUE)
lines(data.frame(data2[1], data2[2]) ,lty="twodash", col="deepskyblue4", lwd=4)
lines(data.frame(data3[1], data3[2]) ,lty="twodash", col="deepskyblue4", lwd=4) for(i in 1:3){
  if(i==1){
    plot(data.frame(data1[1], data1[2]), xlim=c(-0.2, -7), ylim=c(0.31, 0.35), yaxt="n", type="l", xlab="", ylab="",lty="solid", col="red2", lwd=4, axes=TRUE)
  } else { 
    dat <- get(paste('data', i, sep=''))
    lines(data.frame(dat[1], dat[2]) ,lty="twodash", col="deepskyblue4", lwd=4)
  }
} read.table paste
-------------------------------------------------------------------------------------------------------
nls nls library(minpack.lm)
model_iner2 <- nlsLM(output_cut ~ k*(1 - 1/(con1 - con2) * (con1 * exp(-time/con1) + con2 * exp(-time/con2))), 
                     start=list(k=-100, con1=2000, con2=0), data=DF, trace=T)
summary(model_iner2)

# Parameters:
#        Estimate Std. Error t value Pr(>|t|)    
#   k     -14.337      1.184 -12.105  < 2e-16 ***
#   con1  149.426     24.073   6.207 1.30e-08 ***
#   con2   18.020      2.168   8.313 5.43e-13 ***

plot(output_cut ~ time,data=DF)
lines(DF$time,predict(model_iner2)) nls nls2
-------------------------------------------------------------------------------------------------------
assign # Read the data by inserting each data.frame into our list.
data <- list()
for (i in 1:3) {
    data[[i]] <- data.frame(runif(10), rnorm(10)) # Replace with your call to read.table.
}

# As we are lazy, we can pre-save our styles and just use them later
ltys <- c('solid', 'twodash', 'twodash')
cols <- c('red', 'deepskyblue4', 'deepskyblue4')

# Creating the empty plot first allows us to do everything else with lines. Note that there are a ton of different ways to archive this. 
plot(NA, xlim=c(0,1), ylim=c(-2,2))
# And now we just may access the data by using the lists. 
for (i in 1:length(data)) {
    d <- data[[i]]
    lines(d[,1], d[,2], lty=ltys[i], col=cols[i], lwd=4)
} # This time we will read all data into one data.frame.
# This requires the data to be of the same form, however. 
data <- data.frame()
for (i in 1:3) {
    d <- data.frame(x=runif(10), y=rnorm(10))
    # Here is the trick: We add the index i (or a file name, or something totally different) as a separate column.
    data <- rbind(data, cbind(d, group=i))
}
# This is just to ensure that our group column is a factor.
data$group <- as.factor(data$group)

# Now, plotting could be done by various ways. Personally, I like the elegance of ggplot2. 
library(ggplot2)
qplot(x,y,data=data, col=group, geom="line")
-------------------------------------------------------------------------------------------------------
curve x <-runif(10)                               
plot(x, ylim=c(-5,5))                       
a <-curve(sin, add=TRUE, col="red")         
b <-curve(cos, add=TRUE, col="blue")        
xx <-(a$x+b$x)/2 # x average                              
yy <-(a$y+b$y)/2 # y average                                  
lines(xx,yy, col="purple")  #draw average curve
-------------------------------------------------------------------------------------------------------
x <- rpois(100,100)
xt <- table(x)
xtd <- as.data.frame(xt)
xtds <- subset(xtd, Freq>1)  # use subset, as noted by @baptiste
plot(Freq ~ x, xtd, type="h", ylim=c(0,10))
lines(Freq ~ x, xtds, type="h", col="red") data.frame table xt > 1
-------------------------------------------------------------------------------------------------------
interT = 8
 plot( density(rexp(100, rate=1/interT)) )
 with( density(rweibull(100, scale=interT, shape=1)), 
   lines(x,y, col="red"))
-------------------------------------------------------------------------------------------------------
## lonlat points
n <- 100
d <- cbind(runif(n, -180, 180), runif(n, -90, 90))


library(sp)
## distances on WGS84 ellipsoid
x <- spDists(d, longlat = TRUE)

## row, then column index of furthest points
ind <- c(row(x)[which.max(x)], col(x)[which.max(x)])

## maps
library(maptools)
data(wrld_simpl)
plot(as(wrld_simpl, "SpatialLines"), col = "grey")

points(d, pch = 16, cex = 0.5)

## draw the points and a line between  on the page
points(d[ind, ], pch = 16)
lines(d[ind, ], lwd = 2)


## for extra credit, draw the great circle on which the furthest points lie
library(geosphere)


lines(greatCircle(d[ind[1], ], d[ind[2], ]), col = "firebrick") geosphere ?spDists sp
-------------------------------------------------------------------------------------------------------
date valuex date <- c(1, 2, 3, 4, 5, 6, 7, 8)
valuex <- c(2, 1, 2, 1, 2, 3, 4, 2)
valuey <- c(2, 3, 4, 5, 6)
valueymod <- c(rep(NA, 3), valuey)

plot(date, valuex, type = "l", ylim = range(c(valuex, valuey)))
lines(date, valueymod, type = "l", col = "red")
-------------------------------------------------------------------------------------------------------
function(arriverate, servrate, endtime,cl,pl) { if(pl==1){plot(a,col=cl,ylim=c(0,200),type="l")} else{lines(a,col=cl)}} queueSimulation(1.0, 5.0, 100,"red",1)  
queueSimulation(2.0, 4.0, 100,"blue",0)  
queueSimulation(2.3, 3.5, 100,"green",0)  
queueSimulation(4.0, 5.0, 100,"black",0)
-------------------------------------------------------------------------------------------------------
d = data.frame(what=c("A","B","Difference"), 
               mean=c(75,105,30),
               lower=c(50,80,-3),
               upper = c(100,130,63))

plot(-1,-1,xlim=c(1,3),ylim=c(0,140),xaxt="n")

lines(c(1,1),c(d[1,3],d[1,4]))
points(rep(1,3),d[1,2:4],pch=4)

lines(c(1.5,1.5),c(d[2,3],d[2,4]))
points(rep(1.5,3),d[2,2:4],pch=4)

lines(c(2,2),c(d[3,3],d[3,4]))
points(rep(2,3),d[3,2:4],pch=4)

lines(c(1.5,2.2),c(d[2,2],d[2,2]),lty="dotted")

axis(1, at=c(1,1.5,2), labels=c("A","B","Difference"))
axis(4,at=c(40,80,120),labels=c(-1,0,1),pos=2.2)
-------------------------------------------------------------------------------------------------------
d xlim <- c(0.5, 3.5)

plot(1:2, d[d$what %in% LETTERS[1:2], "mean"], xlim = xlim, ylim = c(0, 140), 
    xlab = "", ylab = "", xaxt = "n", bty = "l", yaxs = "i")
lines(c(1,1), d[1, 3:4])
lines(c(2,2), d[2, 3:4])

par(new = TRUE)
plot(3, d[d$what == "Difference", "mean"], ylim = c(-80, 130), xlim = xlim, 
    yaxt = "n", xaxt = "n", xlab = "", ylab = "", bty = "n")
lines(c(3,3), d[3, 3:4])
Axis(x = c(-20, 60), at = c(-20, 0, 20, 40, 60), side = 4)
axis(1, at = c(1:3), labels = c("A", "B", "Difference")) xlim <- c(0.5, 4)
plot(1:2, d[d$what %in% LETTERS[1:2], "mean"], xlim = xlim, ylim = c(0, 140), 
    xlab = "", ylab = "", xaxt = "n", bty = "l", yaxs = "i")
lines(c(1,1), d[1, 3:4])
lines(c(2,2), d[2, 3:4])

par(new = TRUE)
plot(3.5, d[d$what == "Difference", "mean"], ylim = c(-80, 130), xlim = xlim, 
    yaxt = "n", xaxt = "n", xlab = "", ylab = "", bty = "n")
lines(c(3.5,3.5), d[3, 3:4])
Axis(x = c(-20, 60), at = c(-20, 0, 20, 40, 60), side = 4)
axis(1, at = c(1,2,3.5), labels = c("A", "B", "Difference"))
-------------------------------------------------------------------------------------------------------
library(rugarch)
data(sp500ret)
spec <- ugarchspec(distribution.model = "std")
mod <- ugarchroll(spec, data = sp500ret[1:2000,], n.ahead = 1, 
                 n.start = 1000,  refit.every = 100, refit.window = "moving", 
                 solver = "hybrid", fit.control = list(),
                 calculate.VaR = TRUE, VaR.alpha = c(0.01, 0.025, 0.05),
                 keep.coef = TRUE) plot(mod, which = 5) getMethod("plot", c(x = "uGARCHroll", y = "missing")) .intergarchrollPlot(x, choices = choices, plotFUN = paste(".plot.garchroll", 
            1:5, sep = "."), which = which, VaR.alpha = VaR.alpha, 
            density.support = density.support, ...) choices "Fit Coefficients (with s.e. bands)" rugarch:::.intergarchrollPlot rugarch:::.plot.garchroll.5 library(xts)
x <- mod
vmodel = x@model$spec@model$modeldesc$vmodel
if (!x@model$keep.coef) 
  stop("\n\nplot-->error: keep.coef set to FALSE in estimation\n")
coefs = x@model$coef
m = dim(coefs[[1]]$coef)[1]
N = length(coefs)
Z = matrix(NA, ncol = m, nrow = N)
Zup = matrix(NA, ncol = m, nrow = N)
Zdn = matrix(NA, ncol = m, nrow = N)
for (i in 1:m) {
  Z[, i] = sapply(coefs, FUN = function(y) y$coef[i, 1])
  Zup[, i] = Z[, i] + sapply(coefs, FUN = function(y) y$coef[i, 
                                                             2])
  Zdn[, i] = Z[, i] - sapply(coefs, FUN = function(y) y$coef[i, 
                                                             2])
}
dt = sapply(coefs, FUN = function(y) as.character(y$index))
cnames = rownames(coefs[[1]]$coef)
np = rugarch:::.divisortable(m) # added rugarch::: i plotFun <- function(i){
  plot(xts(Z[, i], as.POSIXct(dt)), type = "l", 
       ylim = c(min(Zdn[, i]), max(Zup[, i])), ylab = "value", xlab = "", main = "", 
       minor.ticks = FALSE, ann = FALSE, auto.grid = FALSE)
  lines(xts(Zdn[, i], as.POSIXct(dt)), col = 2)
  lines(xts(Zup[, i], as.POSIXct(dt)), col = 2)
  title(cnames[i], line = 0.4, cex = 0.9)
  grid()
} plotFun(1)
plotFun(2)
-------------------------------------------------------------------------------------------------------
full.xts.obj my.frame1 your.code.func <- function(my.xts){
   my.val <- my.xts[,1]*my.xts[,2]
   my.cumvol <- cumsum(my.xts[,2])
   my.cumval <- cumsum(my.val[,1])
   my.vwap <- my.cumval/my.cumvol

   my.ratio <- (my.xts[,1]/my.vwap - 1)*10000

   op <- par(mfrow=c(1,2))
   plot(my.ratio)
   plot(my.xts[,1])
   lines(my.vwap)
   par(op)
}

data.list <- split(full.xts.obj,'days')

for(i in c(1:(length(data.list))){
   tmp <- data.list[[i]]
   your.code.func(tmp)
}
-------------------------------------------------------------------------------------------------------
x <- seq(dat.1951)
sel <- dat.1951 >= 100
model1 <- lm(dat.1951[sel] ~ poly(x[sel], 2))
model2 <- lm(log(dat.1951[!sel]) ~ x[!sel])

plot(dat.1951, cex=1.5)
lines(x[sel], fitted(model1), col="blue", lwd=3)
lines(x[!sel], exp(fitted(model2)), col="navy", lwd=3) gam() mgcv library(mgcv)
model3 <- gam(dat.1951 ~ s(x))
lines(x, fitted(model3), col="orange", lwd=3, lty=2)
-------------------------------------------------------------------------------------------------------
#Example from help page ("works")

fit <- survfit(Surv(time, status==2) ~ sex, pbc,subset=1:312)
 plot(fit, mark.time=FALSE, xscale=365.25,
         xlab='Years', ylab='Survival')
 lines(fit[1], lwd=2, col="black", xscale=365.24)    
 points(fit[1], lwd=2, col="red", xscale=365.24)
-------------------------------------------------------------------------------------------------------
lm dat <- as.data.frame(cbind(a,b)) plot(log(b)~a, data=dat) fit <- lm(log(b) ~ a, data=dat)
summary(fit)

Call:
lm(formula = log(b) ~ a, data = dat)

Residuals:
       1        2        3        4        5 
 0.27207 -0.04616 -0.30751 -0.03222  0.11383 

Coefficients:
            Estimate Std. Error t value Pr(>|t|)    
(Intercept) 16.75764    0.20360   82.31 3.95e-06 ***
a            0.38502    0.05798    6.64  0.00696 ** 
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 

Residual standard error: 0.2481 on 3 degrees of freedom
Multiple R-squared: 0.9363,     Adjusted R-squared: 0.9151 
F-statistic: 44.09 on 1 and 3 DF,  p-value: 0.006959 lines(predict(fit)~dat$a)
-------------------------------------------------------------------------------------------------------
dframe1 <- structure(list(independent_variable = c(0.3, 0.24, 0.23, 0.16, 
0.14, 0.05, 0.01, -0.1, -0.2), dependent_variable = c(1, 1, 
1, 0.95, 0.93, 0.65, 0.55, 0.5, 0.5)), .Names = c("independent_variable", 
"dependent_variable"), class = "data.frame", row.names = c(NA, 
-9L))

library(psyphy)

plot(dependent_variable ~ independent_variable, dframe1)
fit <- glm(dependent_variable ~ exp(independent_variable), 
    binomial(mafc.cloglog(2)), 
    data = dframe1, 
    weights = rep(100, nrow(dframe1)))  # assuming 100 observations per point
xx <- seq(-0.2, 0.3, len = 100)
pred <- predict(fit, newdata = data.frame(independent_variable = xx), type = "response")
lines(xx, pred)
-------------------------------------------------------------------------------------------------------
ll <- lapply(LETTERS[1:4],function(let){
  dat.let <- dat[,grepl(let,colnames(dat))]
  dd <- reshape(dat.let,direction ='long',
                v.names=c('TimeVariable','Variable'),
                varying=1:6)
  dd$time <- factor(dd$time)
  dd$Type <- let
  dd
}
) head(ll[[1]])
 time TimeVariable Variable id Type
1.1    1            0        0  1    A
2.1    1            0        5  2    A
3.1    1            8      110  3    A
4.1    1           16        0  4    A
5.1    1           NA       NA  5    A
6.1    1           NA       NA  6    A layout(matrix(1:4, 2, 2, byrow = TRUE))
lapply(ll,function(data){
  label1=c(0,100,200,300)
  Type <- unique(dat$Type)
  dat <- subset(data,time==2)
  x.mm <- max(dat$Variable,na.rm=TRUE)
  plot(dat$TimeVariable,dat$Variable,axes=FALSE,ylab="",xlab="",xlim=c(0,x.mm),
       ylim=c(0,2.4),xaxs="i",yaxs="i",pch=19)
  dat <- subset(data,time==2)
  lines(dat$TimeVariable,dat$Variable)
  axis(2,tick=T,at=seq(0.0,2.4,by=0.6),label= seq(0.0,2.4,by=0.6))
  axis(1,tick=T,at=seq(0,x.mm,by=6),label=seq(0,x.mm,by=6))
  mtext(Type,side=1,outer=F,line=-10,adj=0.8)
  minor.tick(nx=5,ny=5)
  par(new=TRUE)
  dat <- subset(data,time==1)
  plot(dat$TimeVariable,dat$Variable,axes=FALSE,xlab="",ylab="",type="l",
       ylim=c(800,0),xaxs="i",yaxs="i")
  axis(3,xlim=c(0,24),tick=TRUE,at= seq(0,24,by=6),label=seq(0,24,by=6),col.axis="violetred4",col="violetred4")
  axis(4,tick=TRUE,at= label1,label=label1,col.axis="violetred4",col="violetred4")
  polygon(dat$TimeVariable,dat$Variable,col='violetred4',border=NA)
}) `ggplot2 facet_wrap ## transform your data to a data.frame
 dat.l <- do.call(rbind,ll)
 library(ggplot2)
 ggplot(subset(dat.l,time !=1)) +
  geom_line(aes(x=TimeVariable,y=Variable,group=time,color=time))+
  geom_polygon(data=subset(dat.l,time ==1),
              aes(x=TimeVariable,y=60-Variable/10,fill=Type))+
  geom_line(data=subset(dat.l,time ==1),
               aes(x=TimeVariable,y=Variable,fill=Type))+
  facet_wrap(~Type,scales='free')
-------------------------------------------------------------------------------------------------------
data <- read.csv("stackfig1_2.csv")
library(Hmisc)

label1=c(0,100,200,300)
plot(data$TimeVariable2C,data$Variable2C,axes=FALSE,ylab="",xlab="",xlim=c(0,24),
     ylim=c(0,2.4),xaxs="i",yaxs="i",pch=19)
lines(data$TimeVariable3C,data$Variable3C)
axis(2,tick=T,at=seq(0.0,2.4,by=0.6),label= seq(0.0,2.4,by=0.6))
axis(1,tick=T,at=seq(0,24,by=6),label=seq(0,24,by=6))
mtext("(C)",side=1,outer=F,line=-10,adj=0.8)
minor.tick(nx=5,ny=5)

par(new=TRUE)
plot(data$TimeVariable1C,data$Variable1C,axes=FALSE,xlab="",ylab="",type="l",
     ylim=c(800,0),xaxs="i",yaxs="i")
axis(3,xlim=c(0,24),tick=TRUE,at= seq(0,24,by=6),label=seq(0,24,by=6),col.axis="violetred4",col="violetred4")
axis(4,tick=TRUE,at= label1,label=label1,col.axis="violetred4",col="violetred4")
polygon(data$TimeVariable1C,data$Variable1C,col='violetred4',border=NA)


legend("top", legend = c("Variable A","Variable B","Variable C"), col = c("black","violetred4","black"),
       ncol = 2, lwd =c("","",2),pch=c(19,15,NA),cex=1) cex
-------------------------------------------------------------------------------------------------------
for (j in (1:2218)*2) {
 x <- unlist(e_web_clear[2*j-1,])
 y <- unlist(e_web_clear[2*j,])
 lines(x,y,'l',lwd=.00000000001, col="black")
 points(x[358], y[358], lwd = 1.5, cex = .1, col = "lightblue")
 }
-------------------------------------------------------------------------------------------------------
lines(index(x), lo$y,col='purple') index
-------------------------------------------------------------------------------------------------------
x <- seq_along(y)
y2 <- rep(y, each=2)
y2 <- y2[-length(y2)]
x2 <- rep(x, each=2)[-1]
x3 <- c(min(x2), x2, max(x2))
y3 <- c(0, y2, 0)

# because polygon() is dumb and wants a pre-existing plot
plot(x, y, ylim=c(0, max(y)), type="n")

polygon(x3, y3, border=NA, col="grey")
lines(x2, y2)
-------------------------------------------------------------------------------------------------------
par lwd x11 lwd x <- c(1:10, rep(1, 10))
y <- c(rep(1, 10), 1:10)
lwd <- 20

x11() #lwd is multiples of 1/96 inches (from help info)

plot(y ~ x, t="l", lend=2, ljoin=2, lwd=lwd, col=3, xlim=c(0,11), ylim=c(0,11))

x.units.per.inch <- (par("usr")[2] - par("usr")[1]) / par("pin")[1]
y.units.per.inch <- (par("usr")[4] - par("usr")[3]) / par("pin")[2]

x.offset <- x.units.per.inch * 1/96 * lwd
y.offset <- y.units.per.inch * 1/96 * lwd

lines(x + x.offset, y + y.offset, lend=2, ljoin=2, lwd=lwd, col=2)
lines(x - x.offset, y - y.offset, lend=2, ljoin=2, lwd=lwd, col=4)
-------------------------------------------------------------------------------------------------------
readLines library(stringr)
lines <- readlines("your file")
questions <- str_match(lines, "Question: (.*)")[, 2]
answers <- str_match(lines, "Answer: (.*)")[, 2]
data.frame(
  Question = questions[!is.na(questions)],
  Answer   = answers[!is.na(answers)]
)
-------------------------------------------------------------------------------------------------------
library("raster")
t2mc <- raster('gfs.grb', band=221)

> t2mc
class       : RasterLayer 
band        : 221  (of  315  bands)
dimensions  : 361, 720, 259920  (nrow, ncol, ncell)
resolution  : 0.5, 0.5  (x, y)
extent      : -0.25, 359.75, -90.25, 90.25  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=longlat +a=6371229 +b=6371229 +no_defs 
data source : /home/oscar/gfs.grb 
names       : gfs crop e <- extent(-40,40,20,90)
tt <- crop(t2mc,e) tt plot spplot e <- extent(-40,40,20,89.5)
tt <- crop(t2mc,e)

spplot(tt) library(maps)
library(mapdata)
library(maptools)

ext <- as.vector(e)
boundaries <- map('worldHires',
                  xlim=ext[1:2], ylim=ext[3:4],
                  plot=FALSE)
boundaries <- map2SpatialLines(boundaries,
                               proj4string=CRS(projection(tt))) rgb.palette <- colorRampPalette(c("snow1","snow2","snow3","seagreen","orange","firebrick"),
                                space = "rgb")

spplot(tt, col.regions=rgb.palette,
       colorkey=list(height=0.3),
       sp.layout=list('sp.lines', boundaries, lwd=0.5)) latticeExtra::layer library(rasterVis)
levelplot(tt, col.regions=rgb.palette,
          colorkey=list(height=.3)) +
    layer(sp.lines(boundaries, lwd=0.5))
-------------------------------------------------------------------------------------------------------
dat <- data.frame(distance <- seq(-1500 ,1500 ,25),
                  A=rnorm(length(distance),mean=0,sd=0.1),
                  B=rnorm(length(distance),mean=0,sd=0.09))

plot(dat[,c(1,2)],type="l",
     col="blue",
     main="My Title",
     xlab="My X Label",
     ylab="My Y Label",
     axes=F)
lines(dat[,c(1,3)],type="l",col="red")

axis(1, pos=0,las=1)
axis(2, pos=0,las=1)

legend("topright", pch = c("-","-"), 
       col = c("blue", "red"), 
       legend = c("A", "B"))
-------------------------------------------------------------------------------------------------------
## Recreate the data
my.data <- c(6,6,4,5,8,9,8,6,3,3,4,5,4,2,1,5,3,3,4,2,4,8,3,1,6,5,4,3,9,8,2,6,8,3,4,5,7,6,2,2,10,9,6,8,9,4,6,7)
n.block <- 6
n.sect  <- 8
my.list <- split(my.data, rep(1:n.block, each = n.sect))
names(my.list) <- paste0("Block", 1:n.block)
sect.name <- paste0("T", 1:n.sect)

## Plot
scale.fact <- max(my.data)
plot(my.list[[1]], type = "n", axes = FALSE, ylim = c(1, n.block + 1), xlab = "", ylab = "")
for (i in seq(along = my.list)){
    lines(i + my.list[[i]]/scale.fact)
}
axis(1, at = 1:n.sect, labels = sect.name, tick = TRUE)
axis(2, at = 1:n.block + sapply(my.list, function(x) x[[1]][1])/scale.fact,
 labels = names(my.list), tick = TRUE, las = 1)
-------------------------------------------------------------------------------------------------------
slide_header find_code_lines <- function(doc){
  code_blocks = which(grepl("^```", doc))
  code_lines = NULL
  for (i in seq.int(1, length(code_blocks), by = 2)){
    code_lines = c(code_lines, code_blocks[i]:code_blocks[i + 1])
  }
  return(code_lines)
}

add_slide_separator <- function(deckFile, slide_header = "###"){
  doc <- readLines(deckFile)
  code_lines = find_code_lines(doc)
  pattern = paste0('^(', slide_header, ".*)")
  doc[-c(code_lines)] = gsub(pattern, '\n---\n\\1', doc[-c(code_lines)])
  writeLines(doc, con = deckFile)
} ## ### gsub("^## |[^#]## ", "---\n\n## ", x)
-------------------------------------------------------------------------------------------------------
plot > plot(male,pch=16,col="red")
> lines(male, pch=16, col = "red")
> lines(female, pch=16, col = "green")
> points(female, pch=16, col = "green")
-------------------------------------------------------------------------------------------------------
map.scale map.scale2 <- map.scale fix(map.scale2) function (x, y, relwidth = 0.15, metric = TRUE, ratio = TRUE, function (x, y, relwidth = 0.15, metric = TRUE, ratio = TRUE, linecol="black", lines(linexy) lines(linexy,col=linecol) map.scale2(x=-112.89, y=36.851, ratio=F, metric = T, relwidth=0.2, col ="white", linecol="white")
-------------------------------------------------------------------------------------------------------
lines() Change axis() at= labels= at= x<-barplot(Sales,ylim=c(0,1000))
lines(x,Change*1000,type="b")
axis(4,at=seq(0,800,200),labels=seq(0,800,200)/1000)
-------------------------------------------------------------------------------------------------------
library(xts)
data<-xts(data.frame(a=c(1,2,3), b=c(4,5,6)), c(as.POSIXct("1970-01-01"), as.POSIXct("1971-01-01"), as.POSIXct("1972-01-01")))
plot(data[,1], ylim=c(min(data), max(data)))
for (i in 2:ncol(data)) { 
    lines(data[,i]) 
}
-------------------------------------------------------------------------------------------------------
par("usr") xaxs="i" xlim par(mar=c(5,5,2,5)) # change margins
x = barplot(Sales, ylim=c(0,1000)) # barplot, keep middle points of bars
mtext("Sales", 2, line=3) # first y-axis label
xlim = par("usr")[1:2] # get xlim from plot
par(new=TRUE) 
plot.new() # new plot
plot.window(xlim=xlim, ylim=c(0,1), xaxs="i", yaxs="i") # new plot area, same xlim
lines(x,Change,type="b") # the lines in the middle points
axis(4) # secondary y-axis
mtext("Change", 4, line=3) # secondary y-axis label
box()
-------------------------------------------------------------------------------------------------------
x$MonthNum <- sapply(x$Month, function(x) which(x==month.name)) plot(NA, xaxt="n", xlab="Month", xlim=c(0,13),
    ylim=c(.96*min(x$Value),1.04*max(x$Value)), type="l")
z <- sapply(1996:1998, function(y) with(x[x$Year==y,], lines(MonthNum, Value1)))
axis(1, at=1:12, labels=month.name) xlabpos <- tapply(x$MonthNum, x$Year, max)
ylabpos <- mapply(function(mon, year) x$Value1[x$MonthNum==mon & x$Year==year],     
    xlabpos, dimnames(xlabpos)[[1]])
text(x=xlabpos+.5, y=ylabpos, labels=dimnames(xlabpos)[[1]]) layout par(mar=c(2,4,1,1))
layout(matrix(1:3))
z <- sapply(1996:1998, function(y) {
    with(x[x$Year==y,], plot(Value1 ~ MonthNum, xaxt="n", xlab="Month", ylab=y,
        xlim=c(0,13), ylim=c(.96*min(x$Value),1.04*max(x$Value)), type="l"))
    axis(1, at=1:12, labels=month.name)
})
-------------------------------------------------------------------------------------------------------
> xx <- rnorm(100)
> yy <- rnorm(100)

> yd <- density(yy, from=-3, to=3)
> xd <- density(xx, from=-3, to=3)

> plot(xd,  col="red")

> str(xd)
List of 7
 $ x        : num [1:512] -3 -2.99 -2.98 -2.96 -2.95 ...
 $ y        : num [1:512] 0.0122 0.0126 0.0131 0.0136 0.0141 ...
 $ bw       : num 0.377
 $ n        : int 100
 $ call     : language density.default(x = xx, from = -3, to = 3)
 $ data.name: chr "xx"
 $ has.na   : logi FALSE
 - attr(*, "class")= chr "density"

> lines(yd$x, yd$y, col="red")
#  difference of the densities
> lines(yd$x, xd$y-yd$y, col="green")
-------------------------------------------------------------------------------------------------------
?text ?arrows x <- seq(0, 2, by=0.1)
y <- x*x
plot(x, y, type="l")

text(0.25, 2, "Some text", pos=3)
arrows(0.25, 2, 1, 1) text lines arrows x <- seq(0, 2, by=0.1)
y <- x*x
plot(x, y, type="l")

# x0, y0: coordinates of text; see ?text
# x1, y1: coordinates to which the arrows are drawn; see ?arrows
# labels: text
# vOffset/hOffset: vertical/horizontal offset
callout <- function(x0, y0, x1, y1, labels, vOffset=0.25, hOffset=0.25) {
  ## fetch labels width/height
  w <- strwidth(labels)
  w2 <- w/2
  h <- strheight(labels)
  h2 <- h/2

  ## draw text
  text(x0, y0, labels=labels)

  ## calulate arrow starting point/line end point
  x01 <- x0+w2*(1+hOffset)
  y01 <- y0-h2*(1+vOffset)

  ## draw horizontal lines
  for (i in seq(along=x0)) {
    lines(c(x0[i]-w2[i], x01[i]), c(y01[i], y01[i]))
  }

  ## draw arrows
  arrows(x0=x01, y0=y01, x1=x1, y1=y1)
}

callout(c(0.25, 0.25), c(2, 3), c(1, 1.5), c(1, 2.25),
        c("Some text", "Some other text"))
-------------------------------------------------------------------------------------------------------
lines x <- seq(0, 2, by=0.1)
y <- x*x
plot(x, y, type="l")
text(0.25,2.2,'Some text')
lines(c(0, 0.5,1), c(2 ,2,1),
      lwd=3, col="grey")

arrows(0.5,2,1,1,
  lwd=3, col="grey")
-------------------------------------------------------------------------------------------------------
data = data.frame(x=c(1,0.5,3,4,5,5.5,6,7), y=c(10, 25, 38, 44.5, 500, 550, 600, 705))
 fit = loess("y ~ x", data=data)
 new_y = predict(fit, data$x)
 plot( data$x , new_y)
lines(lowess(data, f=0.8)$x, lowess(data, f=0.8)$y)
# Obviously lowess with f=0.8 is giving different smoothing lines(lowess(data, f=0.8)$x, lowess(data, f=0.5)$y, col="red")
-------------------------------------------------------------------------------------------------------
lines x <- rnorm(400,0,1)
y <- rnorm(1200,2,2)
plot(density(x))
lines(density(y))
-------------------------------------------------------------------------------------------------------
plot(GIC.Fish ~ GIC.Zoop, data=dat, ylim=c(0,1.1) )
 with(dat,  lines(GIC.Fish ~ GIC.Zoop) )
 with(dat, text(GIC.Zoop, GIC.Fish+.05, labels=Dive.Number , 
           col= colorRampPalette( c("#FFFFD4", "#FED98E", "#FE9929", 
              "#D95F0E", "#993404"), space = "Lab")(36)[Dive.Number]) ) c("#00FFD4", "#00D98E", "#880088", "#D900ff", "#993404")
-------------------------------------------------------------------------------------------------------
xlim ylim col.01line x1 = runif(100)
x2 = runif(100)
x3 = runif(100)
plot.ecdf(x1, col="blue", main="Distribution XYZ",xlab="x_i", ylab="Prob(x_i<=y)", ylim=c(0, 1), xlim=c(0,1), col.01line="white", verticals=FALSE)
lines(ecdf(x2), col="red", col.01line="white")
lines(ecdf(x3), col="green", col.01line="white")
legend(600,0.6,c("x1","x2","x3"), lty=c(1,1,1), lwd=c(1,1,1),col=c("blue","red","green")) plot f1 = ecdf(x1)
f2 = ecdf(x2)
f3 = ecdf(x3)
pts = seq(0, 1, 0.01)
plot(pts, f1(pts), col="blue", type="b", xlab="x_i", ylab="Prob(x_i<=y)", pch=16, main="Distribution XYZ")
lines(pts, f2(pts), col="red", type="b", pch=16)
lines(pts, f3(pts), col="green", type="b", pch=16)
legend("topleft", c("x1","x2","x3"), fill=c("blue","red","green"))
-------------------------------------------------------------------------------------------------------
plot.ecdf(x1, col="blue",
     main="Distribution XYZ",
     xlab="x_i", ylab="Prob(x_i<=y)", 
     xaxs="i",yaxs="i", xlim=c(0,1000) )

lines(ecdf(x2), col="red")    
lines(ecdf(x3), col="green")  
legend(600,0.6, 
       c("x1","x2","x3"), 
       lty=c(1,1,1), 
       lwd=c(1,1,1),col=c("blue","red","green"))
-------------------------------------------------------------------------------------------------------
#coding: utf-8
import nltk
import random
import re

def get_split_sets():
    structured_dataset = get_dataset()
    train_set = set(random.sample(structured_dataset, int(len(structured_dataset) * 0.7)))
    test_set = [x for x in structured_dataset if x not in train_set]

    train_set = [(tweet_features(x[1]), x[0]) for x in train_set]
    test_set = [(tweet_features(x[1]), x[0]) for x in test_set]
    return (train_set, test_set)

def check_accurracy(times=5):
    s = 0
    for _ in xrange(times):
        train_set, test_set = get_split_sets()
        c = nltk.classify.DecisionTreeClassifier.train(train_set)
        # Uncomment to use a naive bayes classifier instead
        #c = nltk.classify.NaiveBayesClassifier.train(train_set)
        s += nltk.classify.accuracy(c, test_set)

    return s / times


def remove_urls(tweet):
    tweet = re.sub(r'http:\/\/[^ ]+', "", tweet)
    tweet = re.sub(r'pic.twitter.com/[^ ]+', "", tweet)
    return tweet

def tweet_features(tweet):
    words = [x for x in nltk.tokenize.wordpunct_tokenize(remove_urls(tweet.lower())) if x.isalpha()]
    features = dict()
    for bigram in nltk.bigrams(words):
        features["hasBigram(%s)" % ",".join(bigram)] = True
    for trigram in nltk.trigrams(words):
        features["hasTrigram(%s)" % ",".join(trigram)] = True  
    return features

def get_dataset():
    dataset = """copy dataset in here
"""
    structured_dataset = [('fruit' if x[0] == '0' else 'company', x[2:]) for x in dataset.splitlines()]
    return structured_dataset

if __name__ == '__main__':
    print check_accurracy()
-------------------------------------------------------------------------------------------------------
windows()
  plot(x, y, type="l", lwd=2, col="blue", ylim=c(0, 12), xaxs="i", yaxs="i")
  lines(x,z, lwd=2, col="red")
  legend("topleft", legend=c("y","z"), lwd=c(2,2), col=c("blue","red")) quartz() windows()
-------------------------------------------------------------------------------------------------------
apply x <- matrix(rnorm(40), ncol=4)
time <- 1:10

lfun <- apply(x, 2, approxfun, x = time, rule = 2, method="linear")

# using those functions in plots
time2 <- seq(1, 10, length=100)
par(mfrow=c(2,2))
for(ii in 1:4){
  plot(time, x[,ii])
  lines(time2, lfun[[ii]](time2))
}
-------------------------------------------------------------------------------------------------------
# Setup
xmin = 0; xmax=10 # domain of your plot
D = my.data
plot( D$probCategorySame, D$posttestScore, xlim=c(xmin,xmax) )
lmMultiple <- lm( posttestScore ~ pretestScore + probCategorySame + probDataRelated + practiceAccuracy + practiceNumTrials, data=D )

# create a dummy dataframe where all variables = their mean value for each record
# except the variable we want to plot, which will vary incrementally over the 
# domain of the plot. We need this object to get the predicted values we
# want to plot.
N=1e4
means = colMeans(D)
dummyDF = t(as.data.frame(means))
for(i in 2:N){dummyDF=rbind(dummyDF,means)} # There's probably a more elegant way to do this.
xv=seq(xmin,xmax, length.out=N)
dummyDF$probCSBinned = xv 
# if this gives you a warning about "Coercing LHS to list," use bracket syntax:
#dummyDF[,k] = xv # where k is the column index of the variable `posttestScore`

# Getting and plotting predictions over our dummy data.
yv=predict(lmMultiple, newdata=subset(dummyDF, select=c(-posttestScore)))
lines(xv, yv)
-------------------------------------------------------------------------------------------------------
plot(1:10, rnorm(10), ylim=c(0,1), ylim=c(-1,100))
Error in plot.default(1:10, rnorm(10), ylim = c(0, 1), ylim = c(-1, 100)) : 
  formal argument "ylim" matched by multiple actual arguments hist(x, prob = TRUE, main = main2, xlab = xlab2, ylim = c(0, maxy), ...) maxy <- max(max(a$density), 0.3989 * mix.object$lambda/mix.object$sigma) library(mixtools)
wait = faithful$waiting
mixmdl = normalmixEM(wait)
plot.new()
plot.window(xlim=c(25,110), ylim=c(0,0.5))
plot(mixmdl, which = 2, nclass=20, add = TRUE)
lines(density(wait), lty = 2, lwd = 2)
box(); axis(1); axis(2); title(xlab="Data", ylab="Density")
-------------------------------------------------------------------------------------------------------
library(reshape2)
m = melt(my.datamat)

s3d = scatterplot3d(m, type = "h"
              , lwd = 5, pch = " "
              , x.ticklabs = rownames(my.datamat)
              , y.ticklabs = colnames(my.datamat)
              , color = grey(150:1 / 200), main = "Northern Trust Data"
              ,lab=c(length(rownames(my.datamat)),length(colnames(my.datamat))) # defines how many ticks should appear on each axis
                    ) # regression plane
s3d$plane3d(lm(value~., data=nt.dat), lty.box="solid" ) plot(0,0, xlim=c(1,length(colnames(my.datamat)))
        ,ylim = range(my.datamat)
     , type='n'
     ,xaxt = "n")

sapply(1:length(rownames(my.datamat))
       ,function(i){lines(my.datamat[i,] , col=i)} )

legend("topright"
       , legend=rownames(my.datamat)
       ,lty=rep(1,length(rownames(my.datamat)))
       ,col=c(1:length(rownames(my.datamat)))
       )

axis(1, at = 1:length(colnames(my.datamat))
      , labels=colnames(my.datamat))
-------------------------------------------------------------------------------------------------------
plot.spei plot.spei <- 
function (x, ...) 
{
    ## label <- ifelse(as.character(x$call)[1] == "spei", "SPEI", 
    ##     "SPI")

    ser <- ts(as.matrix(x$fitted[-c(1:x$scale), ]), end = end(x$fitted), 
        frequency = frequency(x$fitted))
    ser[is.nan(ser - ser)] <- 0
    se <- ifelse(ser == 0, ser, NA)
    tit <- dimnames(x$coefficients)[2][[1]]
    if (start(ser)[2] == 1) {
        ns <- c(start(ser)[1] - 1, 12)
    }
    else {
        ns <- c(start(ser)[1], start(ser)[2] - 1)
    }
    if (end(ser)[2] == 12) {
        ne <- c(end(ser)[1] + 1, 1)
    }
    else {
        ne <- c(end(ser)[1], end(ser)[2] + 1)
    }
    n <- ncol(ser)
    if (is.null(n)) 
        n <- 1
    par(mar = c(4, 4, 2, 1) + 0.1)
    if (n > 1 & n < 5) 
        par(mfrow = c(n, 1))
    if (n > 1 & n >= 5) 
        par(mfrow = c({
            n + 1
        }%/%2, 2))
    for (i in 1:n) {
        datt <- ts(c(0, ser[, i], 0), frequency = frequency(ser), 
            start = ns, end = ne)
        datt.pos <- ifelse(datt > 0, datt, 0)
        datt.neg <- ifelse(datt <= 0, datt, 0)
        plot(datt, type = "n", xlab = "", main = tit[i], ...)
        if (!is.null(x$ref.period)) {
            k <- ts(5, start = x$ref.period[1, ], end = x$ref.period[2, 
                ], frequency = 12)
            k[1] <- k[length(k)] <- -5
            polygon(k, col = "light grey", border = NA, density = 20)
            abline(v = x$ref.period[1, 1] + (x$ref.period[1, 
                2] - 1)/12, col = "grey")
            abline(v = x$ref.period[2, 1] + (x$ref.period[2, 
                2] - 1)/12, col = "grey")
        }
        grid(col = "black")
        polygon(datt.pos, col = "blue", border = NA)
        polygon(datt.neg, col = "red", border = NA)
        lines(datt, col = "dark grey")
        abline(h = 0)
        points(se, pch = 21, col = "white", bg = "black")
    }
} ylab plot(spi1, ylab = "SPI") ts par(mfrow = c(3, 4))
listofmonths <- split(fitted(spi1), cycle(fitted(spi1)))
names(listofmonths) <- month.abb

require(plyr)
l_ply(seq_along(listofmonths), function(x) {
       plot(x = seq_along(listofmonths[[x]]), y = listofmonths[[x]],
            type = "l", xlab = "", ylab = "SPI")
       title(names(listofmonths)[x])
   }) monthplot(fitted(spi1), labels = month.abb, cex.axis = 0.8)
boxplot(fitted(spi1) ~ cycle(fitted(spi1)), names = month.abb, cex.axis = 0.8)
-------------------------------------------------------------------------------------------------------
predict tail # Sample data
library(quantmod)
getSymbols("^GSPC", from="2009-01-01")

# Rolling regression (unweighted), with prediction intervals
x <- rollapplyr( 
  as.zoo(Ad(GSPC)), 
  width=300, by.column = FALSE, 
  FUN = function(x) {
    r <- lm( x ~ index(x) )
    tail(predict(r, interval="prediction"),1)
  } 
)

# Plots
plot( index(GSPC), Ad(GSPC), type="l", lwd=3, las=1 )
lines( index(x), x$fit, col="purple", lwd=3 )
lines( index(x), x$lwr, col="purple", lwd=3, lty=3 )
lines( index(x), x$upr, col="purple", lwd=3, lty=3 )
abline( lm( Ad(GSPC) ~ index(GSPC) ), col="light blue", lwd=3 )
-------------------------------------------------------------------------------------------------------
dev.new(width=0.3,height=0.3)
par(mar=c(0.01,0.01,0.01,0.01))

set.seed(13)
x <- 1:10
y <- runif(10)

plot(x,y,type="n",xaxs="i",yaxs="i",ylim=c(0,1))
polygon( c(1,x,max(x),0), c(0,y,0,0), col="lightblue", border=NA)
lines(x,y,lwd=1)

box(lwd=1)
-------------------------------------------------------------------------------------------------------
png dev.new(width=1.3,height=0.3)
# repeat from here onwards only for png call below
par(mar=c(0,0,0,0))
set.seed(13)
x <- 1:10
y <- runif(10)
plot(x,y,type="n",xaxs="i",yaxs="i",ylim=c(0,1),bty="n")
polygon( c(1,x,max(x),0), c(0,y,0,0), col="lightblue", border=NA)
lines(x,y,lwd=1)
box(lwd=1) png png("textbox_direct.png",width=116,height=27)
# take code block from above
dev.off()
-------------------------------------------------------------------------------------------------------
breakAtDateLine=TRUE gcIntermediate() gg library(mapdata)
library(geosphere)
lon_nj<-118.7969
lat_nj<-32.06025
location<-structure(list(Index = 1:8, lon = c(2.352222, -72.922343, 108.926694, 
-79.944163, -117.328119, -79.953423, -84.396285, -95.712891), 
    lat = c(48.85661, 41.31632, 34.25005, 40.44306, 33.97329, 
    40.4442, 33.77562, 37.09024)), .Names = c("Index", "lon", 
"lat"), class = "data.frame", row.names = c(NA, -8L))

gg<-lapply(1:length(location$lon),function(j) {
  gcIntermediate(c(lon_nj, lat_nj), c(location$lon[j], 
                                      location$lat[j]), n=100,
                 breakAtDateLine=TRUE,
                 addStartEnd=TRUE)
}) gg2<-unlist(lapply(gg, function(x) 
  if (class(x) == "list") x else list(x)), recursive=FALSE) lapply() map("world) map("world")
lapply(gg2,lines) map('world2Hires') x map('world2Hires')
lapply(gg2,function(x) lines(ifelse(x[,1]>0,x[,1],x[,1]+360),x[,2]))
-------------------------------------------------------------------------------------------------------
for(kk in unique(DT[['analyte']])){ 
   DT[, (paste('ratio',kk,sep='.')) := mass / DT[force(kk)][['mass']]]
 }

# create the plot

DT['b', plot(x=time,y= ratio.e,type='n')]

# add the lines creating a colour vector `cc` first`
cc <- c('red','green','blue')
DT['b', lines(x = time,y = ratio.e, col = cc[src]), by = src] ggplot2 library(ggplot2)
ggplot(DT['b'], aes(x = time,y=ratio.e, colour = factor(src))) + geom_line()
-------------------------------------------------------------------------------------------------------
set.seed(1)

getRewardsGaussian <- function(arms, plays) {
## assuming each action has a normal distribution 

  # first generate new means
  QStar <- rnorm(arms, 0, 1)

  # then for each mean, generate `play`-many samples
  sapply(QStar, function(u)
    rnorm(plays, u, 1))
}


CalculateRewardsPerMethod <- function(arms=7, epsi1=0.01, epsi2=0.1
                    , plays=1000, methods=c("greedy", "epsi1", "epsi2")) {

  # names for easy handling
  names(methods) <- methods
  arm.names <- paste0("Arm", ifelse((1:arms)<10, 0, ""), 1:arms)

  # this could be different if not all actions' rewards have a gaussian dist.
  rewards.source <- getRewardsGaussian(arms, plays) 

  # Three dimensional array to track running averages of each method
  running.avgs <- 
    array(0, dim=c(plays, arms, length(methods))
           , dimnames=list(PlayNo.=NULL, Arm=arm.names, Method=methods))

  # Three dimensional array to track the outcome of each play, according to each method 
  rewards.received <- 
    array(NA_real_, dim=c(plays, 2, length(methods))
                  , dimnames=list(PlayNo.=seq(plays), Outcome=c("Arm", "Reward"), Method=methods))


  # define the function internally to not have to pass running.avgs 
  chooseAnArm <- function(p) {
    # Note that in a tie, which.max returns the lowest value, which is what we want
    maxes <- apply(running.avgs[p, ,methods, drop=FALSE], 3, which.max)

    # Note: deliberately drawing two separate random numbers and keeping this as 
    #       two lines of code to accent that the two draws should not be related 
    if(runif(1) < epsi1)
      maxes["epsi1"] <- sample(arms, 1)

    if(runif(1) < epsi2)
      maxes["epsi2"] <- sample(arms, 1)

    return(maxes)
  }

  ## TODO:  Perform each action at least once, then select according to algorithm
  ## Starting points. Everyone starts at machine 3
  choice <- c(3, 3, 3)
  reward <- rewards.source[1, choice]
  ## First run, slightly different
  rewards.received[1,,] <- rbind(choice, reward)
  running.avgs[1, choice, ] <- reward # if different starting points, this needs to change like below

  ## HERE IS WHERE WE START PULLING THE LEVERS ##
  ## ----------------------------------------- ##
  for (p in 2:plays) {
    choice <- chooseAnArm(p)
    reward <- rewards.source[p, choice]

    # Note: When dropping a dim, the methods will be the columns 
    #       and the Outcome info will be the rows. Use `rbind` instead of `cbind`.
    rewards.received[p,,names(choice)] <- rbind(choice, reward)

    ## Update the running averages. 
    ## For each method, the current running averages are the same as the
    ##    previous for all arms, except for the one chosen this round.
    ##    Thus start with last round's averages, then update the one arm.
    running.avgs[p,,] <- running.avgs[p-1,,]

    # The updating is only involved part (due to lots of array-indexing)
    running.avgs[p,,][cbind(choice, 1:3)] <- 
     sapply(names(choice), function(m) 
       # Update the running average for the selected arm (for the current play & method) 
          mean( rewards.received[ 1:p,,,drop=FALSE][ rewards.received[1:p,"Arm",m] == choice[m],"Reward",m])
     )
  } # end for-loop


  ## DIFFERENT RETURN OPTIONS ##
  ## ------------------------ ##


  ## All rewards received, in simplifed matrix (dropping information on arm chosen)
  # return(rewards.received[, "Reward", ])

  ## All rewards received, along with which arm chosen: 
  #   return(rewards.received)

  ## Running averages of the rewards received by method
  return( apply(rewards.received[, "Reward", ], 2, cumsum) / (1:plays) )

}


### EXECUTION (AND SIMULATION)

## PARAMETERS
arms   <- 10
plays  <- 1000
epsi1  <- 0.01
epsi2  <- 0.1
simuls <- 50  # 2000
methods=c("greedy", "epsi1", "epsi2")

## Single Iteration: 
### we can run system time to get an idea for how long one will take
tme <- system.time( CalculateRewardsPerMethod(arms=arms, epsi1=epsi1, epsi2=epsi2, plays=plays) )
cat("Expected run time is approx: ", round((simuls * tme[["elapsed"]]) / 60, 1), " minutes")

## Multiple iterations (simulations)
rewards.received.list <- replicate(simuls, CalculateRewardsPerMethod(arms=arms, epsi1=epsi1, epsi2=epsi2, plays=plays), simplify="array")

## Compute average across simulations
rewards.received <- apply(rewards.received.list, 1:2, mean)

## RESULTS
head(rewards.received, 17)
MeanRewards <- rewards.received

## If using an alternate return method in `Calculate..` use the two lines below to calculate running avg
#   CumulRewards <- apply(rewards.received, 2, cumsum)
#   MeanRewards  <- CumulRewards / (1:plays)

## PLOT
plot.ts(MeanRewards[, "greedy"], col = 'red', lwd = 2, ylim = range(MeanRewards), ylab = 'Average reward', xlab="Plays")
  lines(MeanRewards[, "epsi1"], col = 'orange', lwd = 2)
  lines(MeanRewards[, "epsi2"], col = 'navy', lwd = 2)
  grid(col = 'darkgray')

  legend('bottomright', c('greedy', paste("epsi1 =", epsi1), paste("epsi2 =", epsi2)), col = c('red', 'orange', 'navy'), lwd = 2, cex = 0.8)
-------------------------------------------------------------------------------------------------------
get.testbed = function(arms = 10, plays = 500, u = 0, sdev.arm = 1, sdev.rewards = 1){

  optimal = rnorm(arms, u, sdev.arm)
  rewards = sapply(optimal, function(x)rnorm(plays, x, sdev.rewards))

  list(optimal = optimal, rewards = rewards)
}

play.slots = function(arms = 10, plays = 500, u = 0, sdev.arm = 1, sdev.rewards = 1, eps = 0.1){

  testbed = get.testbed(arms, plays, u, sdev.arm, sdev.rewards)
  optimal = testbed$optimal
  rewards = testbed$rewards

  optim.index = which.max(optimal)
  slot.rewards = rep(0, arms)
  reward.hist = rep(0, plays)
  optimal.hist = rep(0, plays)
  pulls = rep(0, arms)
  probs = runif(plays)

  # vetorizar
  for (i in 1:plays){

      ## dont use ifelse() in this case
      ## idx = ifelse(probs[i] < eps, sample(arms, 1), which.max(slot.rewards))

      idx = if (probs[i] < eps) sample(arms, 1) else which.max(slot.rewards)
      reward.hist[i] = rewards[i, idx]

      if (idx == optim.index)
        optimal.hist[i] = 1

      slot.rewards[idx] = slot.rewards[idx] + (rewards[i, idx] - slot.rewards[idx])/(pulls[idx] + 1)
      pulls[idx] = pulls[idx] + 1
  }

  list(slot.rewards = slot.rewards, reward.hist = reward.hist, optimal.hist = optimal.hist, pulls = pulls)
}

do.simulation = function(N = 100, arms = 10, plays = 500, u = 0, sdev.arm = 1, sdev.rewards = 1, eps = c(0.0, 0.01, 0.1)){

  n.players = length(eps)
  col.names = paste('eps', eps)
  rewards.hist = matrix(0, nrow = plays, ncol = n.players)
  optim.hist = matrix(0, nrow = plays, ncol = n.players)
  colnames(rewards.hist) = col.names
  colnames(optim.hist) = col.names

  for (p in 1:n.players){
    for (i in 1:N){
      play.results = play.slots(arms, plays, u, sdev.arm, sdev.rewards, eps[p])
      rewards.hist[, p] = rewards.hist[, p] + play.results$reward.hist
      optim.hist[, p] = optim.hist[, p] + play.results$optimal.hist
    } 
  }

  rewards.hist = rewards.hist/N
  optim.hist = optim.hist/N
  optim.hist = apply(optim.hist, 2, function(x)cumsum(x)/(1:plays))

  ### Plot helper ###
  plot.result = function(x, n.series, colors, leg.names, ...){
    for (i in 1:n.series){
      if (i == 1)
        plot.ts(x[, i], ylim = 2*range(x), col = colors[i], ...)
      else
        lines(x[, i], col = colors[i], ...)
      grid(col = 'lightgray')
    }
    legend('topleft', leg.names, col = colors, lwd = 2, cex = 0.6, box.lwd = NA)
  }
  ### Plot helper ###

  #### Plots ####
  require(RColorBrewer)
  colors = brewer.pal(n.players + 3, 'Set2')
  op <-par(mfrow = c(2, 1), no.readonly = TRUE)

  plot.result(rewards.hist, n.players, colors, col.names, xlab = 'Plays', ylab = 'Average reward', lwd = 2)
  plot.result(optim.hist, n.players, colors, col.names, xlab = 'Plays', ylab = 'Optimal move %', lwd = 2)
  #### Plots ####

  par(op)
} do.simulation(N = 100, arms = 10, eps = c(0, 0.01, 0.1))
-------------------------------------------------------------------------------------------------------
mydf <- data.frame(V1=c(2,NA,NA,NA,6),V2=c(4,5,NA,7,6),V3=c(3,4,NA,3,9))

plot(NA,xlim=c(0,nrow(mydf)+1),ylim=c(min(mydf,na.rm=TRUE)-1,max(mydf,na.rm=TRUE)+1))
mapply(function(x,color){
    dat <- na.omit(cbind(1:length(x),x))
    lines(dat[,1],dat[,2],col=color)
},mydf,c("red","blue","green"))
-------------------------------------------------------------------------------------------------------
require(segmented)
out.lm<-lm(y~date3,data=df)
o<-segmented(out.lm, seg.Z= ~date3, psi=list(date3=c(-10)),
     control=seg.control(display=FALSE))
 slope(o)
#$date3
#          Est. St.Err. t value CI(95%).l CI(95%).u
#slope1  0.3964  0.1802   2.199   0.03531    0.7574
#slope2 -1.6970  0.1802  -9.418  -2.05800   -1.3360

str(fitted(o))
# Named num [1:60] 1.94 2.34 2.74 3.13 3.53 ...
# - attr(*, "names")= chr [1:60] "1" "2" "3" "4" ...
plot(y ~ date3, data=df)
lines(fitted(o) ~ date3, data=df)
-------------------------------------------------------------------------------------------------------
$est $time #create an empty plot frame
plot(c(min_time,max_time),c(min_est,max_est),t='n')

for(j in 1:(length(PTAR.CIage4)-1) ) {
    if(grepl("S", names(PTARcCIage4)[j]) ) {
         lines(PTARcCIage4[[j]]$time, PTARcCIage4[[j]]$est,...) #or `points` if desired
         }
    }
-------------------------------------------------------------------------------------------------------
# Enumerate the transformations (the dihedral group of order 8)
k <- 5
d1 <- expand.grid( 1:k, 1:k ) 
d2 <- expand.grid( k:1, 1:k ) 
d3 <- expand.grid( 1:k, k:1 ) 
d4 <- expand.grid( k:1, k:1 )
o1 <- order(d1[,1], d1[,2])
o2 <- order(d2[,1], d2[,2])
o3 <- order(d3[,1], d3[,2])
o4 <- order(d4[,1], d4[,2])
o5 <- order(d1[,2], d1[,1])
o6 <- order(d2[,2], d2[,1])
o7 <- order(d3[,2], d3[,1])
o8 <- order(d4[,2], d4[,1])
g1 <- function(p) o1[p]
g2 <- function(p) o2[p]
g3 <- function(p) o3[p]
g4 <- function(p) o4[p]
g5 <- function(p) o5[p]
g6 <- function(p) o6[p]
g7 <- function(p) o7[p]
g8 <- function(p) o8[p]
transformations <- list(g1,g2,g3,g4,g5,g6,g7,g8)

# Check that we have all the transformations
op <- par(mfrow=c(3,3), las=2, mar=c(1,1,1,1))
for( f in transformations ) { 
  plot( d1 )
  lines( d1[f(1:10),] )
}
par(op)

# Function to decide whether to keep a value
library(digest)
keep <- function(p, d) {
  q0 <- digest( d[ sort(p), , drop=FALSE] )
  q <- sapply( transformations, function(f) digest( d[ sort(f(p)), , drop=FALSE ] ) )
  q0 == sort(q)[1]
}

# Apply the function on each column    
i <- apply(combo, 2, keep, d=d1)  # Long...
length(i) / sum(i)   # Around 8 (not exactly, because some of those combinations are symmetric)
result <- combo[,i] apply( equiv, 1, keep, d=d1 )
#    p1    p2    p3    p4    p5    p6    p7    p8 
# FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE
-------------------------------------------------------------------------------------------------------
add_lines <- function(yx){
  annotate("segment", x=-Inf, xend=Inf, y=yx, yend=yx,size=1, colour="white") 
}

j + add_lines(c(8,10,20)) add_oneline <- function(yx){
  annotate("segment", x=-Inf, xend=Inf, y=yx, yend=yx,size=1, colour="white") 
}

lines <- lapply(c(8,10,20), add_oneline)
j + lines
-------------------------------------------------------------------------------------------------------
plot(x,y, xlim=range(x)*c(0, 1.5), ylim=range(y)*c(0, 1.5))
lines(out$par$h+c(-1,-1,1,1,-1)*out$par$r, # extremes of x-coord
      out$par$k+c(-1,1,1,-1 ,-1)*out$par$r, # extremes of y-coord
      col="red") lines(out$par$h+cos(seq(-pi,pi, by=0.1))*out$par$r, #center + r*cos(theta)
      out$par$k+sin(seq(-pi,pi, by=0.1))*out$par$r, #center + r*sin(theta)
      col="red")
-------------------------------------------------------------------------------------------------------
plot() xlim <- c(0, max(sapply(dDistributions, length)-1))
ylim <- c(0, max(unlist(dDistributions)))

plot(NA, type="n", xlim=xlim, ylim=ylim, xlab="degree", ylab="relative frequency")
sapply(dDistributions, function(x) lines(1:length(x)-1, x, type="l"))
-------------------------------------------------------------------------------------------------------
require(forecast)     ### [EDITED for clarity]

  data <- rep(cos(1:52*(3.1416/26)),5)*100+1000
  a.ts <- ts(data,start=c(2009,1),frequency=52)

  ## Predict from previous '3' years then one year out & generate the plot
  a.win  <- window(a.ts,start=c(end(a.ts)[1]-3,end(a.ts)[2]),frequency=52)
  a.fit  <- auto.arima(a.win)  
  a.pred <- forecast(a.fit, h=52)
  plot(a.pred, type="l", xlab="weeks", ylab="counts",
       main="Overlay forecasts & actuals",
       sub="green=FIT(1-105,by 16) wks back & PREDICT(26) wks, blue=52 wks")

  for (j in seq(1, 90, by=8)) {   ## Loop to overlay early forecasts 
    result1 <- tryCatch({
      b.end   <- c(end(a.ts)[1],end(a.ts)[2]-j) ## Window the time series  
      b.start <- c(b.end[1]-3,b.end[2])
      b.window <- window(a.ts, start=b.start, end=b.end, frequency=52)

      b.fit  <-auto.arima(b.window) 
      b.pred <- forecast(b.fit, h=26)
      lines(b.pred$mean, col="green", lty="dashed" )
    }, error = function(e) {return(e$message)} ) ## Skip Errors
  }
-------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------
plot.default add > args(plot.default)
function (x, y = NULL, type = "p", xlim = NULL, ylim = NULL, 
    log = "", main = NULL, sub = NULL, xlab = NULL, ylab = NULL, 
    ann = par("ann"), axes = TRUE, frame.plot = axes, panel.first = NULL, 
    panel.last = NULL, asp = NA, ...) 
NULL plot add points() lines() plot add plot.default add plot.default points() lines() plot.default add
-------------------------------------------------------------------------------------------------------
density lines plot(density( subset(dfrm, Group=='GrpA', AvgVisitsperday), na,rm=TRUE) )  
with( density( subset(dfrm, Group=='GrpB', AvgVisitsperday), na,rm=TRUE) ,
      lines(x,y)
with( density( subset(dfrm, Group=='GrpC', AvgVisitsperday), na,rm=TRUE) ,
      lines(x,y) require(lattice)
densityplot( ~ AvgVisitsperday, groups=Group, data=dfrm)
-------------------------------------------------------------------------------------------------------
exy <- predict(ellipsoidhull(d)) ## the ellipsoid boundary
me <- colMeans((exy))            ## center of the ellipse dist2center <- sqrt(rowSums((t(t(exy)-me))^2))
max(dist2center)     ## major axis
[1] 1.264351
> min(dist2center)   ## minor axis
[1] 0.1537401 plot(exy,type='l',asp=1)
points(d,col='blue')
points(me,col='red')
lines(rbind(me,exy[dist2center == min(dist2center),]))
lines(exy[dist2center == max(dist2center),])
-------------------------------------------------------------------------------------------------------
x <- c(1.798805,2.402390,2.000000,3.000000,1.000000)
y <- c(0.3130147,0.4739707,0.2000000,0.8000000,0.1000000)
d <- cbind( x, y )
library(cluster)
r <- ellipsoidhull(d)
plot( x, y, asp=1, xlim=c(0,4) )
lines( predict(r) )
e <- sqrt(eigen(r$cov)$values)
a <- sqrt(r$d2) * e[1]  # semi-major axis
b <- sqrt(r$d2) * e[2]  # semi-minor axis
theta <- seq(0, 2*pi, length=200)
lines( r$loc[1] + a * cos(theta), r$loc[2] + a * sin(theta) )
lines( r$loc[1] + b * cos(theta), r$loc[2] + b * sin(theta) )
-------------------------------------------------------------------------------------------------------
lm(log(Age) ~ log(Discharge), data=df)

Call:
lm(formula = log(Age) ~ log(Discharge), data = df)

Coefficients:
   (Intercept)  log(Discharge)  
         5.927          -1.024 log(Discharge) m <- lm(log(y) ~ log(x), data=df)

newdf <- data.frame(Discharge=seq(min(df$Discharge), max(df$Discharge), len=100))
plot(Age ~ Discharge, data=df)
lines(newdf$Discharge, exp(predict(m, newdf)))

text(600, .8, substitute(b0*x^b1, list(b0=exp(coef(m)[1]), b1=coef(m)[2])))
text(600, .75, substitute(plain("R-square: ") * r2, list(r2=summary(m)$r.squared)))
-------------------------------------------------------------------------------------------------------
#Example Data
n = 6
time02H = abs(rnorm(n))
time06H = abs(rnorm(n))
time24H = abs(rnorm(n))

allPAL.DE = data.frame(time02H,time06H,time24H)

plot(0,0,xlab="Time",ylab="Values",type="n",xlim=c(0,2),ylim=c(min(allPAL.DE,0),max(allPAL.DE)),axes="FALSE")
box()
axis(1,0:2,c("time02H","time06H","time24H"))
axis(2)
abline(h=0,col="grey",lty=2,lwd=2)

for(i in 1:nrow(allPAL.DE)){
    lines(0:2,allPAL.DE[i,],col=i,lwd=2)
}
-------------------------------------------------------------------------------------------------------
density mgcv # some arbitrary bimodal data. 
z <- c( rnorm(100,mean=-5), rnorm(100,mean=5) ) 

# get the points used to calculate the kernel density
d <- density(z) 
x <- d$x
y <- d$y 

# using a 30 dimensional basis. Smaller would probably work
g <- gam(y ~ s(x,k=30,fx=TRUE)) 
plot(x,y) 
lines(x, predict(g)) # it's perfectly interpolated 

# a function to calculate the density at a vector of new points, u.    
prednew <- function(u) predict(g,newdata=data.frame(x=u))
-------------------------------------------------------------------------------------------------------
windRose windRose.2 <- function (mydata, ws = "ws", wd = "wd", ws2 = NA, wd2 = NA, ws.int = 2, 
    angle = 30, type = "default", cols = "default", grid.line = NULL, 
    width = 1, seg = NULL, auto.text = TRUE, breaks = 4, offset = 10, 
    paddle = TRUE, key.header = NULL, key.footer = "(m/s)", key.position = "bottom", 
    key = TRUE, dig.lab = 5, statistic = "prop.count", pollutant = NULL, 
    annotate = TRUE, border = NA, ...) 
{
    if (is.null(seg)) 
        seg <- 0.9
    if (length(cols) == 1 && cols == "greyscale") {
        trellis.par.set(list(strip.background = list(col = "white")))
        calm.col <- "black"
    }
    else {
        calm.col <- "forestgreen"
    }
    current.strip <- trellis.par.get("strip.background")
    on.exit(trellis.par.set("strip.background", current.strip))
    if (360/angle != round(360/angle)) {
        warning("In windRose(...):\n  angle will produce some spoke overlap", 
            "\n  suggest one of: 5, 6, 8, 9, 10, 12, 15, 30, 45, etc.", 
            call. = FALSE)
    }
    if (angle < 3) {
        warning("In windRose(...):\n  angle too small", "\n  enforcing 'angle = 3'", 
            call. = FALSE)
        angle <- 3
    }
    extra.args <- list(...)
    extra.args$xlab <- if ("xlab" %in% names(extra.args)) 
        quickText(extra.args$xlab, auto.text)
    else quickText("", auto.text)
    extra.args$ylab <- if ("ylab" %in% names(extra.args)) 
        quickText(extra.args$ylab, auto.text)
    else quickText("", auto.text)
    extra.args$main <- if ("main" %in% names(extra.args)) 
        quickText(extra.args$main, auto.text)
    else quickText("", auto.text)
    if (is.character(statistic)) {
        ok.stat <- c("prop.count", "prop.mean", "abs.count", 
            "frequency")
        if (!is.character(statistic) || !statistic[1] %in% ok.stat) {
            warning("In windRose(...):\n  statistic unrecognised", 
                "\n  enforcing statistic = 'prop.count'", call. = FALSE)
            statistic <- "prop.count"
        }
        if (statistic == "prop.count") {
            stat.fun <- length
            stat.unit <- "%"
            stat.scale <- "all"
            stat.lab <- ""
            stat.fun2 <- function(x) signif(mean(x, na.rm = TRUE), 
                3)
            stat.lab2 <- "mean"
            stat.labcalm <- function(x) round(x, 1)
        }
        if (statistic == "prop.mean") {
            stat.fun <- function(x) sum(x, na.rm = TRUE)
            stat.unit <- "%"
            stat.scale <- "panel"
            stat.lab <- "Proportion contribution to the mean (%)"
            stat.fun2 <- function(x) signif(mean(x, na.rm = TRUE), 
                3)
            stat.lab2 <- "mean"
            stat.labcalm <- function(x) round(x, 1)
        }
        if (statistic == "abs.count" | statistic == "frequency") {
            stat.fun <- length
            stat.unit <- ""
            stat.scale <- "none"
            stat.lab <- "Count by wind direction"
            stat.fun2 <- function(x) round(length(x), 0)
            stat.lab2 <- "count"
            stat.labcalm <- function(x) round(x, 0)
        }
    }
    if (is.list(statistic)) {
        stat.fun <- statistic$fun
        stat.unit <- statistic$unit
        stat.scale <- statistic$scale
        stat.lab <- statistic$lab
        stat.fun2 <- statistic$fun2
        stat.lab2 <- statistic$lab2
        stat.labcalm <- statistic$labcalm
    }
    vars <- c(wd, ws)
    diff <- FALSE
    rm.neg <- TRUE
    if (!is.na(ws2) & !is.na(wd2)) {
        vars <- c(vars, ws2, wd2)
        diff <- TRUE
        rm.neg <- FALSE
        mydata$ws <- mydata[, ws2] - mydata[, ws]
        mydata$wd <- mydata[, wd2] - mydata[, wd]
        id <- which(mydata$wd < 0)
        if (length(id) > 0) 
            mydata$wd[id] <- mydata$wd[id] + 360
        pollutant <- "ws"
        key.footer <- "ws"
        wd <- "wd"
        ws <- "ws"
        vars <- c("ws", "wd")
        if (missing(angle)) 
            angle <- 10
        if (missing(offset)) 
            offset <- 20
        if (is.na(breaks[1])) {
            max.br <- max(ceiling(abs(c(min(mydata$ws, na.rm = TRUE), 
                max(mydata$ws, na.rm = TRUE)))))
            breaks <- c(-1 * max.br, 0, max.br)
        }
        if (missing(cols)) 
            cols <- c("lightskyblue", "tomato")
        seg <- 1
    }
    if (any(type %in% openair:::dateTypes)) 
        vars <- c(vars, "date")
    if (!is.null(pollutant)) 
        vars <- c(vars, pollutant)
    mydata <- openair:::checkPrep(mydata, vars, type, remove.calm = FALSE, 
        remove.neg = rm.neg)
    mydata <- na.omit(mydata)
    if (is.null(pollutant)) 
        pollutant <- ws
    mydata$x <- mydata[, pollutant]
    mydata[, wd] <- angle * ceiling(mydata[, wd]/angle - 0.5)
    mydata[, wd][mydata[, wd] == 0] <- 360
    mydata[, wd][mydata[, ws] == 0] <- -999
    if (length(breaks) == 1) 
        breaks <- 0:(breaks - 1) * ws.int
    if (max(breaks) < max(mydata$x, na.rm = TRUE)) 
        breaks <- c(breaks, max(mydata$x, na.rm = TRUE))
    if (min(breaks) > min(mydata$x, na.rm = TRUE)) 
        warning("Some values are below minimum break.")
    breaks <- unique(breaks)
    mydata$x <- cut(mydata$x, breaks = breaks, include.lowest = FALSE, 
        dig.lab = dig.lab)
    theLabels <- gsub("[(]|[)]|[[]|[]]", "", levels(mydata$x))
    theLabels <- gsub("[,]", " to ", theLabels)
    prepare.grid <- function(mydata) {
        if (all(is.na(mydata$x))) 
            return()
        levels(mydata$x) <- c(paste("x", 1:length(theLabels), 
            sep = ""))
        all <- stat.fun(mydata[, wd])
        calm <- mydata[mydata[, wd] == -999, ][, pollutant]
        mydata <- mydata[mydata[, wd] != -999, ]
        calm <- stat.fun(calm)
        weights <- tapply(mydata[, pollutant], list(mydata[, 
            wd], mydata$x), stat.fun)
        if (stat.scale == "all") {
            calm <- calm/all
            weights <- weights/all
        }
        if (stat.scale == "panel") {
            temp <- stat.fun(stat.fun(weights)) + calm
            calm <- calm/temp
            weights <- weights/temp
        }
        weights[is.na(weights)] <- 0
        weights <- t(apply(weights, 1, cumsum))
        if (stat.scale == "all" | stat.scale == "panel") {
            weights <- weights * 100
            calm <- calm * 100
        }
        panel.fun <- stat.fun2(mydata[, pollutant])
        u <- mean(sin(2 * pi * mydata[, wd]/360))
        v <- mean(cos(2 * pi * mydata[, wd]/360))
        mean.wd <- atan2(u, v) * 360/2/pi
        if (all(is.na(mean.wd))) {
            mean.wd <- NA
        }
        else {
            if (mean.wd < 0) 
                mean.wd <- mean.wd + 360
            if (mean.wd > 180) 
                mean.wd <- mean.wd - 360
        }
        weights <- cbind(data.frame(weights), wd = as.numeric(row.names(weights)), 
            calm = calm, panel.fun = panel.fun, mean.wd = mean.wd)
        weights
    }
    if (paddle) {
        poly <- function(wd, len1, len2, width, colour, x.off = 0, 
            y.off = 0) {
            theta <- wd * pi/180
            len1 <- len1 + off.set
            len2 <- len2 + off.set
            x1 <- len1 * sin(theta) - width * cos(theta) + x.off
            x2 <- len1 * sin(theta) + width * cos(theta) + x.off
            x3 <- len2 * sin(theta) - width * cos(theta) + x.off
            x4 <- len2 * sin(theta) + width * cos(theta) + x.off
            y1 <- len1 * cos(theta) + width * sin(theta) + y.off
            y2 <- len1 * cos(theta) - width * sin(theta) + y.off
            y3 <- len2 * cos(theta) + width * sin(theta) + y.off
            y4 <- len2 * cos(theta) - width * sin(theta) + y.off
            lpolygon(c(x1, x2, x4, x3), c(y1, y2, y4, y3), col = colour, 
                border = border)
        }
    }
    else {
        poly <- function(wd, len1, len2, width, colour, x.off = 0, 
            y.off = 0) {
            len1 <- len1 + off.set
            len2 <- len2 + off.set
            theta <- seq((wd - seg * angle/2), (wd + seg * angle/2), 
                length.out = (angle - 2) * 10)
            theta <- ifelse(theta < 1, 360 - theta, theta)
            theta <- theta * pi/180
            x1 <- len1 * sin(theta) + x.off
            x2 <- rev(len2 * sin(theta) + x.off)
            y1 <- len1 * cos(theta) + x.off
            y2 <- rev(len2 * cos(theta) + x.off)
            lpolygon(c(x1, x2), c(y1, y2), col = colour, border = border)
        }
    }
    mydata <- cutData(mydata, type, ...)
    results.grid <- ddply(mydata, type, prepare.grid)
    results.grid$calm <- stat.labcalm(results.grid$calm)
    results.grid$mean.wd <- stat.labcalm(results.grid$mean.wd)
    strip.dat <- openair:::strip.fun(results.grid, type, auto.text)
    strip <- strip.dat[[1]]
    strip.left <- strip.dat[[2]]
    pol.name <- strip.dat[[3]]
    if (length(theLabels) < length(cols)) {
        col <- cols[1:length(theLabels)]
    }
    else {
        col <- openColours(cols, length(theLabels))
    }
    max.freq <- max(results.grid[, (length(type) + 1):(length(theLabels) + 
        length(type))], na.rm = TRUE)
    off.set <- max.freq * (offset/100)
    box.widths <- seq(0.002^0.25, 0.016^0.25, length.out = length(theLabels))^4
    box.widths <- box.widths * max.freq * angle/5
    legend <- list(col = col, space = key.position, auto.text = auto.text, 
        labels = theLabels, footer = key.footer, header = key.header, 
        height = 0.6, width = 1.5, fit = "scale", plot.style = if (paddle) "paddle" else "other")
    legend <- openair:::makeOpenKeyLegend(key, legend, "windRose")
    temp <- paste(type, collapse = "+")
    myform <- formula(paste("x1 ~ wd | ", temp, sep = ""))
    mymax <- 2 * max.freq
    myby <- if (is.null(grid.line)) 
        pretty(c(0, mymax), 10)[2]
    else grid.line
    if (myby/mymax > 0.9) 
        myby <- mymax * 0.9
    xyplot.args <- list(x = myform, xlim = 1.03 * c(-max.freq - 
        off.set, max.freq + off.set), ylim = 1.03 * c(-max.freq - 
        off.set, max.freq + off.set), data = results.grid, type = "n", 
        sub = stat.lab, strip = strip, strip.left = strip.left, 
        as.table = TRUE, aspect = 1, par.strip.text = list(cex = 0.8), 
        scales = list(draw = FALSE), panel = function(x, y, subscripts, 
            ...) {
            panel.xyplot(x, y, ...)
            angles <- seq(0, 2 * pi, length = 360)
            sapply(seq(off.set, mymax, by = myby), function(x) 
llines(x * sin(angles), x * cos(angles), col = "grey85", lwd = 1))
            subdata <- results.grid[subscripts, ]
            upper <- max.freq + off.set
            larrows(-upper, 0, upper, 0, code = 3, length = 0.1)
            larrows(0, -upper, 0, upper, code = 3, length = 0.1)
            ltext(upper * -1 * 0.95, 0.07 * upper, "W", cex = 0.7)
            ltext(0.07 * upper, upper * -1 * 0.95, "S", cex = 0.7)
            ltext(0.07 * upper, upper * 0.95, "N", cex = 0.7)
            ltext(upper * 0.95, 0.07 * upper, "E", cex = 0.7)
            if (nrow(subdata) > 0) {
                for (i in 1:nrow(subdata)) {
                  with(subdata, {
                    for (j in 1:length(theLabels)) {
                      if (j == 1) {
                        temp <- "poly(wd[i], 0, x1[i], width * box.widths[1], col[1])"
                      } else {
                        temp <- paste("poly(wd[i], x", j - 1, 
                          "[i], x", j, "[i], width * box.widths[", 
                          j, "], col[", j, "])", sep = "")
                      }
                      eval(parse(text = temp))
                    }
                  })
                }
            }
            ltext(seq((myby + off.set), mymax, myby) * sin(pi/4), 
                seq((myby + off.set), mymax, myby) * cos(pi/4), 
                paste(seq(myby, mymax, by = myby), stat.unit, 
                  sep = ""), cex = 0.7)
            if (annotate) if (statistic != "prop.mean") {
                if (!diff) {
                  ltext(max.freq + off.set, -max.freq - off.set, 
                    label = paste(stat.lab2, " = ", subdata$panel.fun[1], 
                      "\ncalm = ", subdata$calm[1], stat.unit, 
                      sep = ""), adj = c(1, 0), cex = 0.7, col = calm.col)
                }
                if (diff) {
                  ltext(max.freq + off.set, -max.freq - off.set, 
                    label = paste("mean ws = ", round(subdata$panel.fun[1], 
                      1), "\nmean wd = ", round(subdata$mean.wd[1], 
                      1), sep = ""), adj = c(1, 0), cex = 0.7, 
                    col = calm.col)
                }
            } else {
                ltext(max.freq + off.set, -max.freq - off.set, 
                  label = paste(stat.lab2, " = ", subdata$panel.fun[1], 
                    stat.unit, sep = ""), adj = c(1, 0), cex = 0.7, 
                  col = calm.col)
            }
        }, legend = legend)
    xyplot.args <- openair:::listUpdate(xyplot.args, extra.args)
    plt <- do.call(xyplot, xyplot.args)
    if (length(type) == 1) 
        plot(plt)
    else plot(useOuterStrips(plt, strip = strip, strip.left = strip.left))
    newdata <- results.grid
    output <- list(plot = plt, data = newdata, call = match.call())
    class(output) <- "openair"
    invisible(output)
} windRose.2 stat.lab <- "Frequency of counts by wind direction (%)" stat.lab <- ""
-------------------------------------------------------------------------------------------------------
# Clear all
rm(list = ls())

# Load the library that reads xls files
library(gdata)

# Get the data in
data = read.csv('Readings.csv')

# Extract each Column
readings = data[,"Reading"]
dates = as.Date(data[,"Reading.Date"])

# Order the data correctly
readings = readings[order(dates)]
dates = dates[order(dates)]

# Calculate the difference between each date (in days) and readings
diff.readings = diff(readings)
diff.dates = as.numeric(diff(dates)) # Convert from days to an integer

# Calculate the usage per reading period
usage.per.period = diff.readings/diff.dates

# Get Every single day between the very first reading and the very last
# seq will create a sequence: first argument is min, second is max, and 3rd is the step size (which in this case is 1 day)
days = seq(min(dates),max(dates), 1)
# This creates an empty vector to get data from the for loop below
usage.per.day = numeric()

# The length of the diff.dates is the number of periods that exist.
for (period in 1:(length(diff.dates))){
    # to convert usage.per.period to usage.per.day, we need to replicate the 
    # value for the number of days in that period. the function rep will 
    # replicate a number: first argument is the number to replicate, and the 
    # second number is the number of times to replicate it. the function c will 
    # concatinate the current vector and the new period, sort of 
    # like value = value + 6, but with vectors. 
    usage.per.day = c(usage.per.day, rep(usage.per.period[period], diff.dates[period]))
}
# The for loop above misses out on the last day, so I add that single value manually
usage.per.day[length(usage.per.day)+1] = usage.per.period[period]

# Get the number of readings for each year
years = names(table(format(dates, "%Y")))

# Now break down the usages and the days by year
# list() creates an empty list
usage.per.day.grouped.by.year = list()
year.day = list()
# This defines some colors for plotting, rainbow(n) will give you 
colors = rainbow(length(years))
for (year.index in 1:length(years)){
    # This is a vector of trues and falses, to say whether a day is in a particular
    # year or not
    this.year = (days >= as.Date(paste(years[year.index],'/01/01',sep="")) &
                 days <= as.Date(paste(years[year.index],'/12/31',sep="")))
    usage.per.day.grouped.by.year[[year.index]] = usage.per.day[this.year]
    # We only care about the month and day, so drop the year
    year.day[[year.index]] = as.Date(format(days[this.year], format="%m/%d"),"%m/%d")
    # In the first year, we need to set up the whole plot
    if (year.index == 1){
        # create a png file with file name image.png
        png('image.png')
        plot(year.day[[year.index]], # x coords
             usage.per.day.grouped.by.year[[year.index]], # y coords
             "l", # as a line
             col=colors[year.index], # with this color
             ylim = c(min(usage.per.day),max(usage.per.day)), # this y max and y min
             ylab='Usage', # with this lable for y axis
             xlab='Date', # with this lable for x axis
             main='Usage Over Time') # and this title
    }
    else {
        # After the plot is set up, we just need to add each year
        lines(year.day[[year.index]], # x coordsusage.per.day.grouped.by.year[[year.index]], # y coordscol=colors[year.index]) # color
    }
}
# add a legend to the whole thing
legend("topright" , # where to put the legend
    legend = years, # what the legend names are
    lty=c(1,1), # what the symbol should look like
    lwd=c(2.5,2.5), # what the symbol should look like
    col=colors) # the colors to use for the symbols
dev.off() # save the png to file Reading Date,Reading
1/1/10,10
2/1/10,20
3/6/10,30
4/1/10,40
5/7/10,50
6/1/10,60
7/1/10,70
8/1/10,75
9/22/10,80
10/1/10,85
11/1/10,90
12/1/10,95
1/1/11,100
2/1/11,112.9545455
3/1/11,120.1398601
4/1/11,127.3251748
5/1/11,134.5104895
6/1/11,141.6958042
7/1/11,148.8811189
8/1/11,156.0664336
9/17/11,190
10/1/11,223.9335664
11/1/11,257.8671329
12/1/11,291.8006993
1/1/12,325.7342657
2/1/12,359.6678322
3/5/12,375
4/1/12,380
5/1/12,385
6/1/12,390
7/1/12,400
8/1/12,410
9/1/12,420
-------------------------------------------------------------------------------------------------------
DirLea ~ Time DirLea ~ Dur model <- glm(DirLea ~ (Time + Dur)*treatment, 
             data=data_animal, family = binomial(link=logit)) predict subset sucrose.line <- expand.grid(treatment = "sucrose", 
                            Time = seq(100, 1200, length=50)
                            Dur=mean(animal_data$Dur))
sucrose.line$fitted <- predict(model, sucrose.line)
lines(fitted ~ Time, data = sucrose.line,xlab ="Time of the presentation of the danger cue",    ylab="Proportion of wasps leaving the patch")
-------------------------------------------------------------------------------------------------------
x0 <- numeric()
object.size(x0)
# 40 bytes typeof() sizes <- sapply(0:50, function(n) object.size(seq_len(n)))
plot(c(0, 50), c(0, max(sizes)), xlab = "Length", ylab = "Bytes", 
  type = "n")
abline(h = 40, col = "grey80")
abline(h = 40 + 128, col = "grey80")
abline(a = 40, b = 4, col = "grey90", lwd = 4)
lines(sizes, type = "s") sizes - 40
#  [1]   0   8   8  16  16  32  32  32  32  48  48  48  48  64  64  64  64 128 128 128 128
# [22] 128 128 128 128 128 128 128 128 128 128 128 128 136 136 144 144 152 152 160 160 168
# [43] 168 176 176 184 184 192 192 200 200 # diff(sizes)
#  [1]  8  0  8  0 16  0  0  0 16  0  0  0 16  0  0  0 64  0  0  0  0  0  0  0  0  0  0  0
# [29]  0  0  0  0  8  0  8  0  8  0  8  0  8  0  8  0  8  0  8  0  8  0 xv <- numeric()
xm <- matrix(xv)

object.size(xm)
# 200 bytes

object.size(xm) - object.size(xv)
# 160 bytes list() object.size(pairlist(dims = c(1L, 1L)))
# 160 bytes msizes <- sapply(0:50, function(n) object.size(as.matrix(seq_len(n))))
plot(c(0, 50), c(160, max(msizes)), xlab = "Length", ylab = "Bytes", 
  type = "n")
abline(h = 40 + 160, col = "grey80")
abline(h = 40 + 160 + 128, col = "grey80")
abline(a = 40 + 160, b = 4, col = "grey90", lwd = 4)
lines(msizes, type = "s")
-------------------------------------------------------------------------------------------------------
# Simulate the data (from normal distribution)
d<-rnorm(1000)
# Calculate the density of the data
xd<-density(d)$x
yd<-density(d)$y
# Specify how many curves to plot
no.of.curves<-51

# Open a new plot window
x11(6, 8)
# Set background to black
par(bg=1)
# The the initial plot
plot(x=xd, y=yd+(no.of.curves-1)/10, ylim=c(0,no.of.curves/10+max(yd)), col="grey50", type="l", lwd=2)
# Color the curve with black
polygon(xd, yd+(no.of.curves-1)/10-0.02, col="black", border=NA)
# Add more urves to the plot
for(i in 1:no.of.curves) {
   lines(x=xd, y=yd+(no.of.curves-i)/10, ylim=c(0,no.of.curves/10+max(yd)), col="grey50", type="l", lwd=2)
   polygon(xd, yd+(no.of.curves-i)/10-0.02, col="black", border=NA)
} d<-structure(list(x = c(1L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L, 2L, 
3L, 3L, 3L, 3L, 3L, 4L, 4L, 4L, 4L, 4L, 5L, 5L, 5L, 5L, 5L), 
    y = c(1L, 2L, 3L, 4L, 5L, 1L, 2L, 3L, 4L, 5L, 1L, 2L, 3L, 
    4L, 5L, 1L, 2L, 3L, 4L, 5L, 1L, 2L, 3L, 4L, 5L), z = c(5.47, 
    3.36, 2.99, 3.04, 3.73, 3.25, 3.04, 2.19, 1.6, 2.63, 3.49, 
    2.48, 2.7, 1.6, 2.7, 3.33, 1.94, 2.39, 2.89, 2.94, 4.35, 
    3.21, 3.4, 3.36, 4.74)), .Names = c("x", "y", "z"), class = "data.frame", row.names = c(NA, 
-25L))

yvals<-rev(unique(d$y))
plot(x=0, y=0, ylim=c(min(d$y), max(d$y)+max(d$z)), xlim=c(min(d$x), max(d$x)), type="n", axes=F, xlab="", ylab="") 
 for(i in 1:length(yvals)) {
   a<-d[d$y==yvals[i],]
   polygon(x=a$x, y=a$z+i, border="grey75", col="black")
}
-------------------------------------------------------------------------------------------------------
plotexpl <- seq(1,4,length.out=10)
predresp <- predict(m2,newdata=list(expl=plotexpl))

lines(plotexpl, predresp^(3.79))
-------------------------------------------------------------------------------------------------------
dec read.table data <- read.table(text="<paste the cleaned data here>", header=TRUE) values<-data[,3]
T <-data[,1]

r<-nls(values~C+alpha*sin(W*T+phi), 
       start=list(C=8958.34, alpha=115.886, W=0.0652, phi=14.9286))
summary(r) Formula: values ~ C + alpha * sin(W * T + phi)

Parameters:
       Estimate Std. Error  t value Pr(>|t|)    
C     8.959e+03  3.892e+00 2302.173  < 2e-16 ***
alpha 2.214e+01  5.470e+00    4.047 6.16e-05 ***
W     6.714e-02  2.031e-03   33.065  < 2e-16 ***
phi   1.334e+01  5.113e-01   26.092  < 2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 80.02 on 423 degrees of freedom

Number of iterations to convergence: 21 
Achieved convergence tolerance: 5.952e-06 plot(values~T)
lines(predict(r)~T) raw.fft = fft(values)
truncated.fft = raw.fft[seq(1, length(values)/2 - 1)]
truncated.fft[1] = 0
W = which.max(abs(truncated.fft)) * 2 * pi / length(values)

r2<-nls(values~C+alpha*sin(W*T+phi), start=list(C=8958.34, alpha=115.886, W=W, phi=0))

lines(predict(r2)~T, col="red")  

summary(r2) Formula: values ~ C + alpha * sin(W * T + phi)

Parameters:
       Estimate Std. Error t value Pr(>|t|)    
C     8.958e+03  2.045e-01 43804.2   <2e-16 ***
alpha 1.160e+02  2.913e-01   398.0   <2e-16 ***
W     4.584e-02  1.954e-05  2345.6   <2e-16 ***
phi   2.325e+00  4.760e-03   488.5   <2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 4.204 on 423 degrees of freedom

Number of iterations to convergence: 9 
Achieved convergence tolerance: 1.07e-06 T T TRUE
-------------------------------------------------------------------------------------------------------
C + alpha * sin(omega*T) + beta * cos(omega*T) d <- read.table( "tmp.csv", dec=",", header=TRUE, nrows=400)
x <- d[,1]
y <- d[,3]

f <- function( omega ) { 
  x1 <- sin( omega * x )
  x2 <- cos( omega * x )
  r <- lm( y ~ x1 + x2 )
  res <- mean( residuals(r)^2 )
  attr( res, "coef" ) <- coef(r)
  res
}
omegas <- seq( .001, .2, length=1000 )
res <- sapply(omegas, f)
plot( 
  omegas, res,
  las=1, 
  ylab = "Residuals", xlab = "Omega",
  main = "Objective function: multiple local minima" 
) i <- which.min( res )
omega0 <- optimize(f, interval = c(omegas[i-1], omegas[i+1]))$minimum
p <- c( attr( f(omega0), "coef" ), omega0 )
plot( x, y )
lines( x, p[1] + p[2] * sin( p[4] * x ) + p[3] * cos( p[4] * x ),col = "orange", lwd=3 )
-------------------------------------------------------------------------------------------------------
37120255268, 0.00232666356444858, 
            0.00106361762946221, 0.000465332712889716, 0.000132952203682776, 
            0.000199428305524164, 0.000531808814731104, 0.00033238050920694, 
            6.6476101841388e-05), class = "table", .Dim = 22L, .Dimnames = structure(list(
              c("1", "2", "3", "4", "5", "6", "7", "8", "9", "15", "20", 
                "24", "26", "27", "28", "29", "30", "38", "39", "40", "41", 
                "42")), .Names = "")))

windows()
  plot(y)
  lines(dpois(1:42, lambda=10))
-------------------------------------------------------------------------------------------------------
summary() summary() time surv upper lower mod<-summary(leukemia.surv) plot() polygon() lower upper lines() type="s" lines() with(mod,plot(time,surv,type="n",xlim=c(5,50),ylim=c(0,1)))
with(mod,polygon(c(time,rev(time)),c(lower,rev(upper)),
                 col = "grey75", border = FALSE))
with(mod,lines(time,surv,type="s"))
-------------------------------------------------------------------------------------------------------
> datLines <- readLines(textConnection(" 24     i=6,j=529, Depth Avg
+ 129  1
+ 129.041687011719     1.00000035762787
+ 129.08332824707  .99999988079071
+ 129.125015258789     1.00000011920929
.......
###### snipped many lines
+ 129.833343505859     .99979567527771
+ 129.875030517578     .999777317047119
+ 129.91667175293  .999795794487
+ 129.958358764648     .99979555606842"))

grp <- cumsum(grepl("Depth", datLines)) # cumsum 1/0's creates group var
rdLines <- lapply( split(datLines, grp), # read within each group
                   function(x) read.table(text=x, skip=1) )
str(rdLines[1])
dafrm <- do.call(rbind, rdLines)  # bind in one dataframe
dafrm$grp <- rep(1:24, each=24)   # label them
bpt <- boxplot(V2~grp, data=dafrm) # save values in 'bpt' variable
str(bpt)
lines(1:24, bpt$stats[ 3, ])  # values of medians as y-arg to `lines`
-------------------------------------------------------------------------------------------------------
plot(v2, type="l", col="darkblue", lwd=2)
# v2 <- smooth(v2, kind="3")  # optional
lines(v2, lwd=1, col="red")
d2 <- diff(v2)
d2 <- d2>0
d2 <- d2*2 -1 
k <- 5
cutoff <- 10
scores <- sapply(k:(length(d2)-k), FUN=function(i){
  score <- abs(mean(-d2[ i-1:k ], na.rm=T) + mean(d2[ i+0:k ], na.rm=T))
})


scores <- sapply(k:(length(v2)-k), FUN=function(i){
  left <- (v2[sapply(i-1:k, max, 1) ]<v2[i])*2-1
  right <- (v2[sapply(i+1:k, min, length(v2)) ]<v2[i])*2-1

  score <- abs(sum(left) + sum(right))
})

inflections <- (k:(length(v2)-k))[scores>=cutoff]

plot(v2, type="l")
abline(v=inflections, col="red", lwd=3)
print(inflections) #  6 11 18 25 32 (missed 51, if you make cutoff=8 it'll catch it...)
-------------------------------------------------------------------------------------------------------
Benzaldehyde, 4-[(trimethylsilyl)oxy]-; Benzaldehyde, p-(trimethylsiloxy)-
Benzeneacetic acid, methyl ester; Acetic acid, phenyl-, methyl ester
Cyclopropaneoctanoic acid, 2-[[2-[(2-ethylcyclopropyl)methyl]cyclopropyl]methyl]-, methyl ester; Methyl 8-[2-((2-[(2-ethylcyclopropyl)methyl]cyclopropyl)methyl)cyclopropyl]octanoate #
Mevalonic lactone, trimethylsilyl deriv.; Mevalonic lactone, trimethylsilyl
Benzeneacetic acid, phenylmethyl ester; Acetic acid, phenyl-, benzyl ester
Butanoic acid, 3,3-dimethyl-, methyl ester; Butyric acid, 3,3-dimethyl-, methyl ester
Acetic acid, (4-(trifluoromethoxy)phenyl)methyl ester; NA
Phosphoramidothioic acid, O,S-dimethyl ester; Methamidophos
Octanoic acid, phenylmethyl ester; Octanoic acid, benzyl ester
Benzenepropanoic acid, methyl ester; Hydrocinnamic acid, methyl ester
2-Propenoic acid, 3-phenyl-, methyl ester; Cinnamic acid, methyl ester
Propanoic acid, 2-methyl-, phenylmethyl ester; Isobutyric acid, benzyl ester
Acetic acid, (2,3-dichlorophenyl)methyl ester; NA
L-Methionine, methyl ester; Methyl 2-amino-4-(methylsulfanyl)butanoate #
Butanoic acid, phenylmethyl ester; Butyric acid, benzyl ester Name: 1-Phosphatidyl-D-myo-inositol;: 1-Phosphatidyl-1D-myo-inositol;: 1-Phosphatidyl-myo-inositol;: Phosphatidyl-1D-myo-inositol;: (3-Phosphatidyl)-1-D-inositol;: 1,2-Diacyl-sn-glycero-3-phosphoinositol;: Phosphatidylinositol
Name: Androstenedione;: Androst-4-ene-3,17-dione;: 4-Androstene-3,17-dione
Name: Spermine;: N,N'-Bis(3-aminopropyl)-1,4-butanediamine
Name: H+;: Hydron
Name: 3-Iodo-L-tyrosine
Name: 3-Methoxytyramine
Name: 3-Methoxy-4-hydroxyphenylacetaldehyde;: (4-Hydroxy-3-methoxyphenyl)acetaldehyde;: Homovanillin
Name: L-Noradrenaline;: Noradrenaline;: Norepinephrine;: Arterenol;: 4-[(1R)-2-Amino-1-hydroxyethyl]-1,2-benzenediol
Name: 3,4-Dihydroxymandelaldehyde;: 3,4-Dihydroxyphenylglycolaldehyde
Name: L-Metanephrine
Name: L-Adrenaline;: (R)-(-)-Adrenaline;: (R)-(-)-Epinephrine;: (R)-(-)-Epirenamine;: (R)-(-)-Adnephrine;: 4-[(1R)-1-Hydroxy-2-(methylamino)ethyl]-1,2-benzenediol
Name: 3-Methoxy-4-hydroxyphenylglycolaldehyde
Name: L-Normetanephrine
Name: L-Dopachrome;: 2-L-Carboxy-2,3-dihydroindole-5,6-quinone
Name: 5,6-Dihydroxyindole;: DHI import requests

def name_to_cids(name):
    '''Retrive set of pubchem cids for given name'''
    url = 'https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/name/{0}/cids/JSON'.format(name)
    r = requests.get(url)
    return set(r.json()["IdentifierList"]["CID"])  if r.status_code == 200 else set()


def names_to_cids(names):
    '''Take list of names and return set of pubchem cids'''
    cids = set()
    for name in names:
        cids = cids.union(name_to_cids(name))
    return cids

def find_matching(from_key, from_dict, to_dict):
    matching = []
    from_cids = from_dict[from_key]['cids']
    for k, v in to_dict.items():
        if len(from_cids.intersection(v['cids'])) != 0:
            matching.append(k)
    return matching

#Read input files
input_1 = [line.replace('#','').strip().split(';') for line in open('input1.csv').readlines()]
input_2 = [[n for n in line.replace('Name: ', '').strip().split(';:') if n != 'NA'] for line in open('input2.csv').readlines()]

input_1_dict = {" ".join(names): {'names': names, 'cids': names_to_cids(names)} for names in input_1}
input_2_dict = {" ".join(names): {'names': names, 'cids': names_to_cids(names)} for names in input_2}

print(find_matching(from_key=input_1_dict.keys()[0], from_dict=input_1_dict, to_dict=input_2_dict))
-------------------------------------------------------------------------------------------------------
myf<-function(x, x1=20, y1=50, m=-2){ 
  firstInds<-intersect(which(x >= 0), which(x < x1)) 
  y<-x
  y[firstInds]<-m*x[firstInds]+y1-m*x1
  y[-firstInds]<-0
  y
} x<-1:50
plot(x, myf(x)) plot(x, myf(x), ylab="Y", xlab="X"); lines(x, myf(x), col="red")
-------------------------------------------------------------------------------------------------------
plot points() lines() text() NewDay <- gam (INI~s(day), family = gaussian, data = INI_New_Day)

plot(NewDay)
points(INI_New_Day3$day, INI_New_Day$INI)) plot new = TRUE points lines ?par new
-------------------------------------------------------------------------------------------------------
#!/usr/bin/rscript --vanilla
filename='smith_chart.pdf'
pdf(filename, 6, 6)

# applies conformal map (z-1)/(z+1) to complex number z
cmap <- function(z) (z-1)/(z+1)

plot.new()
plot.window(c(-1, 1), c(-1, 1), asp = 1)

dd <- c(seq(-100, 100, 1), seq(-10, 10, 0.1), seq(-2, 2, 0.02))
dd <- round(dd, digits = 2) # fix roundoff errors
dd <- sort(unique(dd)) # remove duplicates

smith_grid <- function (val, step) {
  # applies conformal map to lines having fixed real component
  r_grid <- outer(1i * dd[dd >= -val & dd <= val], seq(0, val, step), '+')
  r_grid <- cmap(r_grid)
  matlines(Re(r_grid), Im(r_grid), lwd = 0.5, col = 1, lty = 1)

  # applies conformal map to lines having fixed imaginary component
  x_grid <- outer(dd[dd >= 0 & dd <= val], 1i * seq(-val, val, step), '+')
  x_grid <- cmap(x_grid)
  matlines(Re(x_grid), Im(x_grid), lwd = 0.5, col = 1, lty = 1)
}

smith_grid(50, 10)
smith_grid(10, 1)
smith_grid(2, 0.2)
smith_grid(0.6, 0.1)

dev.off()
-------------------------------------------------------------------------------------------------------
pracma::plotyy graphics::axis axis(side=4,{other setup arguments}) lines(data3,...) plotyy plotyy(x1, y1, x2, y2, gridp = TRUE, box.col = "grey",
                       type = "l", lwd = 1, lty = 1,
                       xlab = "x", ylab = "y", main = "",
                       col.y1 = "navy", col.y2 = "maroon", ...)
Arguments

x1, x2  
x-coordinates for the curves

y1, y2  
the y-values, with ordinates y1 left, y2 right.

type    
type of the curves, line or points (for both data). x1,y1 x2,y2
-------------------------------------------------------------------------------------------------------
?<function name> # here I generate some example data, set.seed makes it reproducible
set.seed(33)
x <- 1:20; y0 <- 20; y1 <- 25; y2 <- 300
for(i in 2:20){
  y0 <- c(y0, y0[i-1]+rnorm(1, mean=0.25, sd=1.5))
  y1 <- c(y1, y1[i-1]+rnorm(1, mean=0,    sd=1))
  y2 <- c(y2, y2[i-1]+rnorm(1, mean=-10,  sd=5))
}
max(y0, y1)  
# [1] 35.3668
min(y0, y1)
# [1] 17.77653
# from 0 to 50 seems like a reasonable Y range for the plotting area

windows()
  plot (x, y0, pch=6,  cex=.5, col="blue", type="b", 
        xlab="Mb", ylab="Pi", ylim=c(0, 50))
  lines(x, y1, pch=18, cex=.5, col="red",  type="b")

# We need to create a new variable that will fit within this plotting area
y2new <- scale(y2)        # this makes y2 have mean 0 & sd 1
y2new <- y2new*sd(y0)     # now its sd will equal that of y0
y2new <- y2new+mean(y0)   # now its mean will also equal that of y0

  lines(x, y2new, pch=24, cex=.5, col="green", type="b")

# now y2 fits within the window, but we need an axis which must map the 
#   plotted points to the original values

summary(y0)
#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
#   17.78   20.64   24.34   25.62   30.25   35.37
summary(y2)
#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
#   125.1   178.2   222.2   220.0   266.3   300.0
sd(y0)
# [1] 5.627629
sd(y2)
#[1] 54.76167

# thus, we need an axis w/ 25.62 showing 220 instead, & where 5.63 higher
#   shows 54.76 higher instead

increments <- (mean(y0)-seq(from=0, to=50, by=10))/sd(y0)
increments
# [1]  4.5521432  2.7751960  0.9982488 -0.7786983 -2.5556455
# [6] -4.3325927
newTicks   <- mean(y2) - increments*sd(y2)
newTicks
# [1] -29.24281  68.06579 165.37438 262.68298 359.99158
# [6] 457.30017

# the bottom of the y axis in the plot is 4.55 sd's below y0's mean, 
#   thus the bottom of the new axis should be about -30, and the top of 
#   the new axis should be about 460

  axis(side=4, at=seq(0, 50, 10), labels=round(newTicks), col="green")
  legend("bottomleft", c("y0 (left axis)", "y1 (left axis)", 
         "y2 (right axis)"), pch=c(6, 18, 24), lty=1, 
         col=c("blue", "red", "green")) plotyy()
-------------------------------------------------------------------------------------------------------
spline.fit <- function(x, y, df=5) {
  ## INPUT: x, y are two vectors (predictor and response);
  ##        df is the number of spline basis.  Increase "df" to fit more adaptively to the data.
  require(splines) # available as default R Package.
  bx <- bs(x, df)  # B-spline basis matrix as New Predictors (dimension is "length(x)" by "df")
  f <- lm(y ~ bx)  # Linear Regression on Spline Basis (that is, "df" number of new predictors)
  fy <- fitted(f)  # Fitted Response
  plot(x, y); lines(x, fy, col="blue", lwd=2) # Make a plot to show the fit.
  invisible(list(x=bx, y=fy, f=f))    # Return the Basis (new predictors), Fitted Y, Regression
}

if (F) {                                # Unit Test
  spline.fit(1:100, rnorm(100))
  spline.fit(1:100, rnorm(100), df=20)
}
-------------------------------------------------------------------------------------------------------
par(las=1, bty = 'n')
point_colors  <- c("royalblue4", "gray")
subjects <- c("Comp. Sc.\n(17.2%)", "Physics\n(19.6%)", "Maths\n(29.4%)",
              "Pol. Sc.\n(40.4%)", "Psychology\n(69.8%)")
aVals <- c(52.36, 52.00, 55.43, 56.08, 62.89)
bVals <- c(53.57, 52.93, 56.07, 58.86, 63.87)
n <- length(aVals)
plot(1:n, aVals, ylim = c(50, 65), type = 'l', col=point_colors[1], xlab="Disciplines (% of women)", ylab = "Classification accuracy (%)", xaxt = 'n', panel.first = grid(nx = NA, ny = NULL))
lines(1:n, bVals, col = point_colors[2])
axis(1, 1:5, subjects, cex.axis = 0.85, tcl = -0.1)
text(c(3.25, 3.5), c(54, 59), c('aVals', 'bVals')) par(las=1, bty = 'n')
point_colors  <- c("royalblue4", "gray")
subjects <- c("Comp. Sc.\n(17.2%)", "Physics\n(19.6%)", "Maths\n(29.4%)",
              "Pol. Sc.\n(40.4%)", "Psychology\n(69.8%)")
xpos <- c(17.2, 19.6, 29.4, 40.4, 69.8)
aVals <- c(52.36, 52.00, 55.43, 56.08, 62.89)
bVals <- c(53.57, 52.93, 56.07, 58.86, 63.87)
n <- length(aVals)
plot(xpos, aVals, ylim = c(50, 65), type = 'l', col=point_colors[1], xlab="Disciplines (% of women)", ylab = "Classification accuracy (%)", xaxt = 'n', panel.first = grid(nx = NA, ny = NULL))
lines(xpos, bVals, col = point_colors[2])
axis(1, xpos, subjects, cex.axis = 0.85, tcl = -0.1)
text(c(3.25, 3.5), c(54, 59), c('aVals', 'bVals'))
-------------------------------------------------------------------------------------------------------
# Initialize our N number of X points and
# colors vector.
N <- 20
colors <- c("yellow", "red", "blue", "green")

# Create function 'generate_X' to perform
# as implied by the OP.
generate_X <- function(.N){
    rnorm(n=.N, mean=0, sd=1)
}

# Generate the entire data frame
# using the 'matrix' function to shape
# the data quickly.
data <- data.frame(
    id=1:N,
    matrix(
        generate_X(N*length(colors)), 
        ncol=length(colors)
        )
    ) data[,-1] plot(
    range(data$id), 
    range(data[,-1]), 
    col="white", 
    xlab="x", 
    ylab="y") for(i in 1:length(colors)){
    lines(data$id, data[, i + 1], type="l", col=colors[i])
} i # Load packages for shaping data and plotting.
library(reshape2)
library(ggplot2) + melt(data, id.vars="id") #    id variable        value
# 1   1       X1 -0.280035386
# 2   2       X1 -0.371020958
# 3   3       X1 -0.239889784
# 4   4       X1  0.450357442
# 5   5       X1 -0.801697283
# 6   6       X1 -0.453057841
# 7   7       X1 -0.451321958
# 8   8       X1  0.948124835
# 9   9       X1  2.724205279
# 10 10       X1 -0.725622824
# 11 11       X1  0.475545293
# 12 12       X1  0.533060822
# 13 13       X1 -1.928335572
# 14 14       X1 -0.466790259
# 15 15       X1 -1.606005895
# 16 16       X1  0.005678344
# 17 17       X1 -1.719827853
# 18 18       X1  0.601011314
# 19 19       X1 -2.056315661
# 20 20       X1  1.006169713
# 21  1       X2 -1.591227194
# ...
# 80 20       X4 -1.045224561 ggplot() + 
    geom_line(
        data=melt(data, id.vars="id"), 
        aes(
            x=id, 
            y=value, 
            col=variable
            ), 
        lwd=1, 
        alpha=0.7)
-------------------------------------------------------------------------------------------------------
plot(obs_v_exp$observed, type="l")
lines(obs_v_exp$expected, col="red") set.seed(2)
obs_v_exp <- data.frame(observed=sample(0:6, 10, TRUE),
                        expected=sample(0:6, 10, TRUE))
plot(obs_v_exp$observed, type="l")
lines(obs_v_exp$expected, col="red")
-------------------------------------------------------------------------------------------------------
chart1 <-xyplot(ts1    ,    
panel=function(x,y)    
{    
panel.xyplot(x,y)    
panel.lines(x,y)    
},    
strip= strip.custom(factor.levels=paste(dimnames(ts1)[[2]],"max value =",round(apply(ts1,2,max),2)))    
)    
 chart1
-------------------------------------------------------------------------------------------------------
legend plot( 0, type="n", xlim=c(0,5), ylim=c(0,5) )
A <- matrix( c( c(1,2,3,4), c(2,1,2,4)), ncol=2 )
B <- matrix( c( c(1,2,3,4), c(1,3,3,2)), ncol=2 )
lines( A, col="red" )
points( A, col="blue", pch=15 )
lines( B, col="green" )
points( B, col="purple", pch=17 )

legend( x="topleft", 
        legend=c("Red line, blue points","Green line, purple points"),
        col=c("red","green"), lwd=1, lty=c(1,2), 
        pch=c(NA,NA) )

legend( x="topleft", 
        legend=c("Red line, blue points","Green line, purple points"),
        col=c("blue","purple"), lwd=1, lty=c(0,0), 
        pch=c(15,17) ) legend legend( x="topleft", 
        legend=c("",""),
        col=c("blue","purple"), lwd=1, lty=c(0,0), 
        pch=c(15,17), bty='n' ) legend
-------------------------------------------------------------------------------------------------------
for (i in 1:length(R1_isoclines)){
    lines(rep(R1_isoclines[i],times=2), c(R2_isoclines[i],maxxx), col=i+1, type="l")
    lines(c(R1_isoclines[i], maxxx), rep(R2_isoclines[i],times=2),col=i+1,type="l")
}
-------------------------------------------------------------------------------------------------------
plot.xts add plot.xts plot.xtsMODIFIED<-function (x, y = NULL, type = "l", auto.grid = TRUE, major.ticks = "auto", 
    minor.ticks = TRUE, major.format = TRUE, bar.col = "grey", 
    candle.col = "white", ann = TRUE, axes = TRUE, ...) 
{
    series.title <- deparse(substitute(x))
    ep <- axTicksByTime(x, major.ticks, format.labels = major.format)
    otype <- type
    if (is.OHLC(x) && type %in% c("candles", "bars")) {
        x <- x[, has.OHLC(x, TRUE)]
        xycoords <- list(x = .index(x), y = seq(min(x), max(x), 
            length.out = NROW(x)))
        type <- "n"
    }
    else {
        if (NCOL(x) > 1) 
            warning("only the univariate series will be plotted")
        if (is.null(y)) 
            xycoords <- xy.coords(.index(x), x[, 1])
    }
    ###The next three lines are the only modifications i made to the function####
    plot(xycoords$x, xycoords$y, type = "n", axes = FALSE, ann = FALSE) 
    rect(par("usr")[1], par("usr")[3], par("usr")[2], par("usr")[4], col ="white")
    if(type=="l"){lines(xycoords$x, xycoords$y, ...)}

    if (auto.grid) {
        abline(v = xycoords$x[ep], col = "grey", lty = 4)
        grid(NA, NULL)
    }
    if (is.OHLC(x) && otype == "candles") 
        plot.ohlc.candles(x, bar.col = bar.col, candle.col = candle.col, 
            ...)
    dots <- list(...)
    if (axes) {
        if (minor.ticks) 
            axis(1, at = xycoords$x, labels = FALSE, col = "#BBBBBB", 
                ...)
        axis(1, at = xycoords$x[ep], labels = names(ep), las = 1, 
            lwd = 1, mgp = c(3, 2, 0), ...)
        axis(2, ...)
    }
    box()
    if (!"main" %in% names(dots)) 
        title(main = series.title)
    do.call("title", list(...))
    assign(".plot.xts", recordPlot(), .GlobalEnv)
} library(quantmod)
getSymbols('SPY', from='1998-01-01', to='2011-07-31', adjust=T)

GRAPH_BLUE<-rgb(43/255, 71/255,153/255)
GRAPH_BACKGROUND<-rgb(180/255, 226/255, 244/255)

par(bg=GRAPH_BACKGROUND)

plot.xtsMODIFIED(SPY, col=GRAPH_BLUE) Error in axis(1, at = xycoords$x, labels = FALSE, col = "#BBBBBB", ...) : formal argument "col" matched by multiple actual arguments. plot.xts ... col axis plot lines ...
axis(1, at = xycoords$x, labels = FALSE, col = "#BBBBBB", 
            ...)
... ...
axis(1, at = xycoords$x, labels = FALSE, ...)
... plot.xts plot.xtsMODIFIED<-function (x, y = NULL, type = "l", auto.grid = TRUE, major.ticks = "auto", 
                             minor.ticks = TRUE, major.format = TRUE, bar.col = "grey", 
                             candle.col = "white", ann = TRUE, axes = TRUE, 
                             lcol, ...) 
{
...
if(type=="l"){lines(xycoords$x, xycoords$y, lcol, ...)}
...
} plot.xtsMODIFIED(SPY, lcol=GRAPH_BLUE)
-------------------------------------------------------------------------------------------------------
convolve smooth<-function(x,D,delta){
  z<-exp(-abs(-D:D)/delta)
  r<-convolve(x,z,type="open")/convolve(rep(1,length(x)),z,type="open")  
  r<-head(tail(r,-D),-D)
  r
} y > yy<-smooth(y,15,5)
> yy
 [1]  50.70804  52.10837  54.04788  56.33651  58.87682  61.61121  64.50214
 [8]  67.52265  70.65186  73.87197  77.16683  80.52193  83.92574  87.36969
[15]  90.84850  94.35809  98.15750 101.93317 105.67833 109.38989 113.06889
[22] 116.72139 120.35510 123.97707 127.59293 131.20786 134.82720 138.45720
[29] 142.10507 145.77820 149.48224 153.21934 156.98794 160.78322 164.60057
[36] 168.43699 172.29076 176.15989 180.04104 183.93127 187.83046 191.74004
[43] 195.66223 199.59781 203.54565 207.50342 211.46888 215.44064 219.41764
[50] 223.39908 227.05822 230.66813 234.22890 237.74176 241.20236 244.60039
[57] 247.91917 251.14346 254.25876 257.24891 260.09121 262.74910 265.16057
[64] 267.21598 268.70276 plot(y)
lines(yy)
-------------------------------------------------------------------------------------------------------
Drift_graph = function(t,R){
  N<-250
  p<-0.5
  freq<-as.numeric();
    for( i in 1:t ){
      A1=rbinom(1,2*N,p)
      p=A1/(N*2);
      freq[length(freq)+1]<-p;
    }
  plot(freq,type="l",ylim=c(0,1),col=3,xlab="t",ylab=expression(p(A[1])))
    for(u in 1:R){
      freq1<-as.numeric();
      p<-0.5
        for( j in 1:t ){
          A1=rbinom(1,2*N,p)
          p=A1/(N*2);
          freq1[length(freq1)+1]<-p;
        }
      random<-sample(1:1000,1,replace=F)
      randomcolor<-colors()[random] 
      lines(freq1,type="l",col=(randomcolor))
    }
}

Drift_graph(2000,50)
-------------------------------------------------------------------------------------------------------
?plot.zoo panel parent.frame$panel.number hline # create values for hline, one for each panel
hlines <- c(50, 50, 48, 50)

# panel function that loops over panels
my.panel <- function(x, ...) {
  lines(x, ...)
  panel.number <- parent.frame()$panel.number
  abline(h = hlines[panel.number], col = "red", lty = "solid", lwd = 1.5)
}

plot.zoo(x, main = "title", type = "o", lwd = 1.5, col = "blue", panel = my.panel)
-------------------------------------------------------------------------------------------------------
ecdf x <- rnorm(100)
plot(ecdf(x))
lines(seq(-3, 3, by=.1), pnorm(seq(-3, 3, by=.1)), col=2) actuar # load package
require(actuar)
# check out the parametrization! 
?dllogis
# estimate shape and scale from your data
shape <- 20
scale <- 1
# Don't do this. Use your own data instead. 
x <- rllogis(100, shape=shape, scale=scale)
# Plotting the empirical distribution function
plot(ecdf(x))
# x-values for plotting distribution function
xvals <- seq(min(x), max(x), length=100)
# plot estimated distribution function with your estimated shape and scale
lines(xvals, pllogis(xvals, shape=shape, scale=scale), col=2)
-------------------------------------------------------------------------------------------------------
ymax <- max(r.sims)
ymin <- min(r.sims)

plot(r.sims[,1], type="l", col="#ff000010", ylim=c(ymin, ymax))
for (i in 2:1000){
lines(r.sims[,i], type="l", col="#ff000010")
} ymax <- max(r.sims)
ymin <- min(r.sims)
color <- c(rep("#ff000010", 499), rep("#0000ff10", 500))

plot(r.sims[,1], type="l", col="#ff000010", ylim=c(ymin, ymax))
for (i in 2:1000){
lines(r.sims[,i], type="l", col=color[i])
}
-------------------------------------------------------------------------------------------------------
DF <- read.table(text="x       y       log10(x)         log10(y)
7      240     0.84509804      2.380211242
45      610     1.653212514     2.785329835
14      340     1.146128036     2.531478917
30      500     1.477121255     2.698970004
24      450     1.380211242     2.653212514
57      690     1.755874856     2.838849091", header=TRUE) SSpower <- selfStart(~ A*x^B,
                     function(mCall, data, LHS)
                     {
                       xy <- sortedXyData(mCall[["x"]], LHS, data)
                       if(nrow(xy) < 3) {
                         stop("Too few distinct x values to fit a power function")
                       }
                       z <- xy[["y"]]
                       xy[["logx"]] <- log(xy[["x"]])     
                       xy[["logy"]] <- log(xy[["y"]])  
                       aux <- coef(lm(logy ~ logx, xy))
                       pars <- c(exp(aux[[1]]), aux[[2]])
                       setNames(pars,
                                mCall[c("A", "B")])
                     }, c("A", "B")) fit <- nls(y ~ SSpower(x, A, B), data=DF) plot(y~x, data=DF)
lines(x=1:60, y=predict(fit, newdat=list(x=1:60)))
-------------------------------------------------------------------------------------------------------
# Make an empty plot
plot(0, 0, type="n", xlim=c(1, 19), ylim=range(SDMeasurement, na.rm=TRUE))

# Add the lines
for(i in seq(df)){
    y <- SDMeasurement[[i]]
    lines(which(!is.na(y)), na.omit(y), col=i)
}
-------------------------------------------------------------------------------------------------------
mat <- sapply(-10:10, function(mean) dnorm(seq(-20,20,len=210), mean))+
        sapply(rep(0,21), function(mean) dnorm(seq(-20,20,len=210), mean))
matplot(seq(-20,20,len=210), mat, type="n", ylim=c(0,1.5))
matlines(seq(-20,20,len=210), mat+rep( seq(0,1, len=21), each=210), lty=1,col=1)
-------------------------------------------------------------------------------------------------------
ksmooth plot(Height,Counts)
smoothCounts<-ksmooth(Height,Counts,kernel="normal",bandwidth=2)
dsmooth<-diff(smoothCounts$y)
locmax<-sign(c(0,dsmooth))>0 & sign(c(dsmooth,0))<0
lines(smoothCounts)
points(smoothCounts$x[locmax],smoothCounts$y[locmax],cex=3,c=2)
-------------------------------------------------------------------------------------------------------
deathrow <- read.csv("death_row_by_year.csv", sep=",", header=T)
plot(range(deathrow$Year, na.rm=T), range(c(deathrow$Population, deathrow$Executions)), na.rm=T), type='n')
lines(deathrow$Year, deathrow$Population, col="red")
lines(deathrow$Year, deathrow$Executions, col="green") plot type='n' xlim=range(...) ylim=range(...) lines
-------------------------------------------------------------------------------------------------------
> cdf<-function(x) integrate(df,-20,x)$value
> qdf<-function(x) optimize(function(z)(cdf(z)-x)^2,c(-20,20))$minimum
> rdf<-function(n) sapply(runif(n),qdf)
> x<-rdf(2000)
> hist(x,freq=F)
> xseq<-seq(-8,8,len=1000)
> lines(xseq,sapply(xseq,df))
-------------------------------------------------------------------------------------------------------
plot(q1, type = "l", lty = 1, lwd = 2, col = "white", ylim = c(0,4*10^6), )
smoothingSpline = smooth.spline(q1, spar=1)
lines(smoothingSpline, col = "darkolivegreen3",lwd = 2)
-------------------------------------------------------------------------------------------------------
library(foreign)
dat <- read.arff(url("http://www.cs.umb.edu/~rickb/files/UCI/autos.arff")) train <- dat[1:150,]
test <- dat[151:nrow(dat),] fit <- lm(`city-mpg` ~ `peak-rpm`+horsepower+`wheel-base`,data=train)
temp_test <- predict(fit,test) par(las=1,bty="l") ## cosmetic
plot(test[["peak-rpm"]],temp_test,xlab="peak rpm",ylab="predicted") cf <- coef(fit)
abline(a=cf["(Intercept)"]+
          mean(test$horsepower)*cf["horsepower"]+
          mean(test$`wheel-base`)*cf["`wheel-base`"],
          b=coef(fit)["`peak-rpm`"]) predict() newdat <- with(test,
            data.frame(horsepower=mean(horsepower),
                       "wheel-base"=mean(`wheel-base`),
                       "peak-rpm"=seq(min(`peak-rpm`),
                                        max(`peak-rpm`),
                                        length=41),
                       check.names=FALSE))
newdat["city-mpg"] <- predict(fit,newdat)
with(newdat,lines(`peak-rpm`,`city-mpg`,col=4)) fit2 <- lm(`city-mpg` ~ `peak-rpm`,data=train)
abline(fit2,col="red")
-------------------------------------------------------------------------------------------------------
density() dgamma lines( sort(x) , y = dgamma( sort(x) , shape = 8 , scale = 0.1 ) , col = "blue" , lty = 2 , lwd = 2 )
-------------------------------------------------------------------------------------------------------
actiontype$lastAction 'reset' actiontype$lastAction 'draw' else temp xval yval NULL input$coords input$coords input$coords NULL #server.R
library(shiny)
N = 30
x = sort(runif(N, 0, 10)); y = x + rnorm(N)
xval=NULL
yval=NULL
checker <- 1 #### CHANGE

shinyServer(function(input, output) {
get.coords <- reactive({
    data.frame(x=input$coords$x, y=input$coords$y)
})

actiontype <- reactiveValues()
actiontype$lastAction <- 'draw'

observe({
    if (input$reset != 0)
        actiontype$lastAction <- 'reset'
})
observe({
    if (input$closepolygon != 0)
        actiontype$lastAction <- 'closepolygon'
})

output$diagPlot = renderPlot({
    plot(x, y, xlim = range(x), ylim = range(y))
    grid()

    if (identical(actiontype$lastAction, 'reset')) {
        xval <<- NULL
        yval <<- NULL
        checker <<- 0 ####CHANGE
        actiontype$lastAction <- 'draw'

    } else if (identical(actiontype$lastAction, 'draw')){
        temp <- get.coords()
        xval <<- c(xval,temp$x)
        yval <<- c(yval,temp$y)

        ########### CHANGE...
        if(identical(checker, 0))
         {
           points(xval, yval, pch = 19, col = rgb(1,0,0,0), cex = 1.5)
           xval <<- NULL
           yval <<- NULL
           checker <<- 1
         }else
         {
          points(xval, yval, pch = 19, col = 'red', cex = 1.5)
         }
        ############# ...CHANGE

        for (i in 1:(length(xval)-1))
             lines(c(xval[i],xval[i+1]),c(yval[i],yval[i+1]),type="l",col="blue")
        if(identical(actiontype$lastAction, 'closepolygon'))
       lines(c(xval[1],xval[length(xval)]),c(yval[1],yval[length(yval)]),
              type="l",col="blue")
    }
}, width = 700, height = 600)
}) input$coords input$coords checker 1 0
-------------------------------------------------------------------------------------------------------
lines(log(x), exp(predict(model, newdata=list(x=log(x)))) ,col="red") lines(x, exp(predict(model, newdata=list(x=x))) ,col="red")
-------------------------------------------------------------------------------------------------------
x y las prs require(MASS)
data(Boston, package='MASS')
y <- Boston$nox
x <- Boston$dis
n <- length(x)

cvs <- rep(0, n)
for(j in seq(n)){
  ys <- y[-j]
  xs <- x[-j]
  d <- nls(ys ~ A + B * exp(C * xs), start=list(A=0.5, B=0.5, C=-0.5))
  cvs[j] <- (y[j] - predict(d, data.frame(xs=x[j])))^2
  print(paste0(j, " of ", n, " finished (", round(j/n*100), "%)"))
}

plot(y~x, pch=19, col='gray', cex=1.5, xlab='dis', ylab='nox')
d <- nls(y~ A + B * exp(C * x), start=list(A=0.5, B=0.5, C=-0.5))
lines(predict(d)[order(x)]~sort(x), lwd=4, col='black')
usr <- par("usr")
text(usr[1] + 0.9*(usr[2]-usr[1]), usr[3] + 0.9*(usr[4]-usr[3]), paste("LOO MSE", "=", round(mean(cvs), 5)), pos=2)
text(usr[1] + 0.9*(usr[2]-usr[1]), usr[3] + 0.8*(usr[4]-usr[3]), paste("MSE", "=", round(mean(resid(d)^2), 5)), pos=2)
-------------------------------------------------------------------------------------------------------
T' Tc plot(0:length(Tc)*2, c(Tc, tail(Tc,1)), type="s") tail plot(seq(1, 2*length(Tc), length.out=length(Tc)+1), c(Tc, tail(Tc,1)), type="s") barplot(Tc, width=2, space=0)
lines(seq(Tb)-.5, Tb, type="b", lwd=2)
-------------------------------------------------------------------------------------------------------
mapply fun <- function(row.o, row.d)
{
 lines(c(o[row.o,1], d[row.d,1]), c(o[row.o,2], d[row.d,2]), lwd = 2 * s[row.o,row.d] / mean(s))
}

#all combinatios of rows of `d` and `o` 
args.od <- expand.grid(1:nrow(o), 1:nrow(d))

mapply(fun, row.o = args.od[,1], row.d = args.od[,2])
-------------------------------------------------------------------------------------------------------
lines r=0.8
z=2
k=seq(0,5,by=0.1)
y1=(z^2+k*r)/(r*z+k)
y2=z*(z+k*r)/(r+k)
y3=0.8*y2
ymin=min(c(y1,y2,y3))
ymax=max(c(y1,y2,y3))
plot(k,y1,type='l',ylab='lines',col="red",ylim=c(ymin,ymax))
par(new=TRUE)
lines(k,y2,type='l',col="green",ylim=range(c(y1,y2)))
lines(k,y3) r=0.8
z=3
p=seq(0.1,5,by=0.1)
y1=(p*z^2+r*z)/(p*r*z+1)
y2=z*(p+r)/(p*r+1)
y3=(p^2*z*2-1+sqrt((p^2*z*2)^2+4*p^2*r*2*z*2))/(2*p*2*r*z)
ymin=-1
ymax=max(c(y1,y2,y3))
plot(p,y1,type='l',ylab='lines',col="red",ylim=c(ymin,ymax))
par(new=TRUE)
lines(p,y2,type='l',col="green",ylim=range(c(y1,y2)))
lines(p,y3, col="blue")
-------------------------------------------------------------------------------------------------------
import re

# This pattern should match correct data lines and should not
# match "continuation" lines (lines added by the unquoted newline).
# This pattern means: start of line, then a number, then white space,
# then another number, then more white space, then another number.

# This program won't work right if this pattern isn't correct.
pat = re.compile("^\d+\s+\d+\s+\d+")

def collect_lines(iterable):
    itr = iter(iterable)  # get an iterator

    # First, loop until we find a valid line.
    # This will skip the first line with the "header" info.
    line = next(itr)
    while True:
        line = next(itr)
        if pat.match(line):
            # found a valid line; hold it as cur
            cur = line
            break
    for line in itr:
        # Look at the line after cur.  Is it a valid line?
        if pat.match(line):
            # Line after cur is valid!
            yield cur  # output cur
            cur = line  # hold new line as new cur
        else:
            # Line after cur is not valid; append to cur but do not output yet.
            cur = cur.rstrip('\r\n') + line
    yield cur

data = """\
   JOB  REF Comment V2  Other
@@@1   3   45  This was a small job    NULL    sdnsdf
@@@2   4   456 This was a large job and I have to go onto a new line, 
@@@    but I didn't properly escape so it's on the next row whoops!    NULL    NULL        
@@@3   7   354 NULL    NULL    NULL
"""

lines = data.split('@@@')
for line in collect_lines(lines):
    print(">>>{}<<<".format(line)) with open("filename", "rt") as f:
    for line in collect_lines(f):
        # do something with each line cur cur
-------------------------------------------------------------------------------------------------------
with open("filename", "r") as data:
    datadict={}
    for count,linedata in enumerate(data):
        datadict[count]=linedata.split('\t')

extra_line_numbers=[]
for count,x in enumerate(datadict):
    if count==0: #get rid of the first line
        continue
    if not datadict[count][1].isdigit(): #if item #2 isn't a number
        datadict[count-1][3]=datadict[count-1][3]+datadict[count][1]
        datadict[count-1][4:6]=(datadict[count][2],datadict[count][3])
        extra_line_numbers.append(count)

for x in extra_line_numbers:
    del(datadict[x])

with open("newfile",'w') as data:
    data.writelines(['\t'.join(x)+'\n' for x in datadict.values()])
-------------------------------------------------------------------------------------------------------
rollmean zoo library(quantmod)

getSymbols("SPY")
getSymbols("AAPL")

par(mfrow=2:1)
plot(SPY[, "SPY.Open"], main="SPY", auto.grid=F)
lines(rollmean(SPY, k=30, fill=NA)[, "SPY.Open"], col="red")
plot(AAPL[, "AAPL.Open"], main="AAPL", auto.grid=F)
lines(rollmean(AAPL, k=30, fill=NA)[, "AAPL.Open"], col="red") k rollmean auto.grid=F ?plot.xts spy.open <- as.vector(SPY[, "SPY.Open"])
plot(spy.open, type="l")
-------------------------------------------------------------------------------------------------------
library(rworldmap)
library(WDI) # WORLD BANK INDICATORS

## lines of either type may obscure more than they add
##**choose line option here
addLines <- 'gc' #'none''straight' 'gc'
if ( addLines == 'gc' ) library(geosphere)

# setting background colours
oceanCol = rgb(7,0,30,maxColorValue=255) 
landCol = oceanCol 

#produces a list of indicator IDs and names as a matrix
indicatorList <- WDIsearch('aid flows')

#setting up a world map shaped plot window
#*beware this is windows specific
mapDevice('windows',width=10,height=4.5)


year <- 2000
#for(indNum in 1:2)
for(indNum in 1:nrow(indicatorList))
{
  indID <- indicatorList[indNum][1]
  donorISO3 <- substr(indID,start=8,stop=10)

  dFdonor <- WDI(indicator=indID,start=year,end=year)
  #divide by 10^6 for million dollars
  dFdonor[indID] <- dFdonor[indID] * 1/10^6

  sPDFdonor <- joinCountryData2Map(dFdonor,nameJoinColumn='country',joinCode='NAME')
  #take out Antarctica
  sPDFdonor <- sPDFdonor[-which(row.names(sPDFdonor)=='Antarctica'),]

  legendTitle=paste("aid flow from",donorISO3,year,"(millions US$)") 
  mapBubbles(sPDFdonor, nameZSize=indID, plotZeroVals=FALSE, legendHoriz=TRUE, legendPos="bottom", fill=FALSE, legendTitle=legendTitle, oceanCol=oceanCol, landCol=landCol,borderCol=rgb(50,50,50,maxColorValue=255),lwd=0.5,lwdSymbols=1)
  #removed because not working , main=paste('donor', donorISO3,year)

  #now can I plot lines from the centroid of the donor to the centroids of the recipients
  xDonor <- sPDFdonor$LON[ which(sPDFdonor$ISO3==donorISO3) ]
  yDonor <- sPDFdonor$LAT[ which(sPDFdonor$ISO3==donorISO3) ] 
  xRecips <- sPDFdonor$LON[ which(sPDFdonor[[indID]] > 0) ]
  yRecips <- sPDFdonor$LAT[ which(sPDFdonor[[indID]] > 0) ]
  amountRecips <- sPDFdonor[[indID]][ which(sPDFdonor[[indID]] > 0) ]


  ## straight lines
  if ( addLines == 'straight' )
  {
    for(line in 1:length(xRecips))
    {  
       #col <- 'blue'
       #i could modify the colour of the lines by the size of the donation
       #col=rgb(1,1,1,alpha=amountRecips[line]/max(amountRecips))
       #moving up lower values
       col=rgb(1,1,0,alpha=sqrt(amountRecips[line])/sqrt(max(amountRecips)))
       lines(x=c(xDonor,xRecips[line]),y=c(yDonor,yRecips[line]),col=col, lty="dotted", lwd=0.5)   #lty = "dashed", "dotted", "dotdash", "longdash", lwd some devices support <1
    }
  }

  ## great circle lines
  ## don't work well when donor not centred in the map
  ## also the loop fails at CEC & TOT because not ISO3 codes
  if ( addLines == 'gc' & donorISO3 != "CEC" & donorISO3 != "TOT" )
  {  
    for(line in 1:length(xRecips))
    {
      #gC <- gcIntermediate(c(xDonor,yDonor),c(xRecips[line],yRecips[line]), n=50, breakAtDateLine=TRUE)
      #30/10/13 lines command failed with Error in xy.coords(x, y) : 
      #'x' is a list, but does not have components 'x' and 'y'
      #adding sp=TRUE solved
      gC <- gcIntermediate(c(xDonor,yDonor),c(xRecips[line],yRecips[line]), n=50, breakAtDateLine=TRUE, sp=TRUE)

      #i could modify the colour of the lines by the size of the donation
      #col=rgb(1,1,1,alpha=amountRecips[line]/max(amountRecips))
      #moving up lower values
      col=rgb(1,1,0,alpha=sqrt(amountRecips[line])/sqrt(max(amountRecips)))

      lines(gC,col=col,lwd=0.5)
    }
  }  

  #adding coasts in blue looks nice but may distract
  data(coastsCoarse)
  plot(coastsCoarse,add=TRUE,col='blue')

  #repeating mapBubbles with add=T to go on top of the lines
  mapBubbles(sPDFdonor, nameZSize=indID, plotZeroVals=FALSE, fill=FALSE, addLegend=FALSE, add=TRUE, ,lwd=2)
  #removed because not working : , main=paste('donor', donorISO3,year)

  #looking at adding country labels
  text(xRecips,yRecips,sPDFdonor$NAME[ which(sPDFdonor[[indID]] > 0) ],col=rgb(1,1,1,alpha=0.3),cex=0.6,pos=4) #pos=4 right (1=b,2=l,3=ab)

  #add a title 
  nameDonor <- sPDFdonor$NAME[ which(sPDFdonor$ISO3==donorISO3) ]
  mtext(paste("Aid flow from",nameDonor,year), cex = 1.8, line=-0.8)

  #savePlot(paste("C:\\rProjects\\aidVisCompetition2012\\Rplots\\greatCircles\\wdiAidFlowLinesDonor",donorISO3,year,sep=''),type='png')
  #savePlot(paste("C:\\rProjects\\aidVisCompetition2012\\Rplots\\greatCircles\\wdiAidFlowLinesDonor",donorISO3,year,sep=''),type='pdf')

} #end of indNum loop
-------------------------------------------------------------------------------------------------------
mean(cvs,na.rm=TRUE)
[1] 0.003753745

plot(y~x)
lines( d$x[order(d$x)], d$fitted[order(d$x)])
which(is.na(d$fitted[order(d$x)]) )
#integer(0) #add as debugging code
if(is.na(cvs[i]) ) {print(i);print(x[i])}}
[1] 354
[1] 12.1265
[1] 373
[1] 1.1296

 range(x)
#[1]  1.1296 12.1265 (y[ which(is.na(cvs)) ]-predict(d, x[ which(is.na(cvs)) ] ))^2
[1] 3.218139e-06 3.742504e-04
-------------------------------------------------------------------------------------------------------
library(lubridate)
library(reshape2)
# simulating data...
Date  <- seq(as.Date("1953-10-01"),as.Date("2010-10-01"),by="day")
Year  <- year(Date)
Month <- month(Date)
Day <- day(Date)
set.seed(1)
Flow <- rpois(length(Date), 2000)
Data <- data.frame(Date=Date,Year=Year,Month=Month,Day=Day,Flow=Flow)

# use acast to get it in a convenient shape:
PlotData <- acast(Data,Year~Month+Day,value.var="Flow")
# apply for quantiles
Quantiles <- apply(PlotData,2,function(x){
    quantile(x,probs=c(1,.9,.75,.5,.25,.1,0),na.rm=TRUE)
  })
Mean <- colMeans(PlotData, na.rm=TRUE)
# ugly way to get month tick separators
MonthTicks <- cumsum(table(unlist(lapply(strsplit(names(Mean),split="_"),"[[",1))))

# and finally your question:
plot(1:366,seq(0,max(Flow),length=366),type="n",xlab = "Water Year",ylab="Discharge",axes=FALSE)
polygon(c(1:366,366:1),c(Quantiles["50%",],rev(Quantiles["75%",])),border=NA,col=gray(.6))
polygon(c(1:366,366:1),c(Quantiles["50%",],rev(Quantiles["25%",])),border=NA,col=gray(.4))
lines(1:366,Quantiles["90%",], col = gray(.5), lty=4)
lines(1:366,Quantiles["10%",], col = gray(.5))
lines(1:366,Quantiles["100%",], col = gray(.7))
lines(1:366,Quantiles["0%",], col = gray(.7), lty=4)
lines(1:366,Mean,lwd=3)
axis(1,at=MonthTicks, labels=NA)
text(MonthTicks-15,-100,1:12,pos=1,xpd=TRUE)
axis(2) polygon()
-------------------------------------------------------------------------------------------------------
# This is equivalent to your for-loops, use whatever you prefer
x0 <- do.call(rbind, lapply(1:350, function(i) {
  arima.sim(list(order=c(1,0,0), ar=ifelse(i <= 150, 0.9, -0.9)), n=76)
}))

plotStuff <- function(indices, ...) {
  plot.new()
  plot.window(xlim=c(1, ncol(x0)), ylim=range(x0[indices,]))
  box()
  for (i in indices)
    lines(x0[i,], ...)
}

par(mfrow=c(2,1), mar=rep(1,4)) # two rows, reduced margin
plotStuff(1:150,   col="orange")
plotStuff(151:350, col="blue")
-------------------------------------------------------------------------------------------------------
apply quantile set.seed(1)
Fund <- matrix(rnorm(20*10), ncol=20, nrow=10)
qs <- apply(Fund, 2, quantile, probs=c(0.05, 0.5, 0.95))
qs
ylim=range(qs)
plot(seq(ncol(Fund)), qs[1,], t="l", lty=2, ylim=ylim) #5%
lines(seq(ncol(Fund)), qs[2,], lty=1, lwd=2) #50%
lines(seq(ncol(Fund)), qs[3,], lty=2, col=2)  #95%
legend("topleft", legend=rev(rownames(qs)), lwd=c(1,2,1), col=c(2,1,1), lty=c(2,1,2))
-------------------------------------------------------------------------------------------------------
lines() a+b*x a=50 b=-1 segments() segments() plot.new()
plot.window(xlim=c(0,100),ylim=c(0,100))
lines(x=c(0,50),y=50-1*c(0,50))
segments(50,0,100,0)
-------------------------------------------------------------------------------------------------------
plot.new()
plot.window(xlim=c(0,100),ylim=c(0,100))
lines(c(0,50,100), c(50,0,0))
axis(1)
axis(2)
title(main="Graph")
title(xlab="X")
title(ylab="Y")
box()
-------------------------------------------------------------------------------------------------------
#dummy data
hourvec <- runif(20)
sd_hourvec <- sd(hourvec)

#get hourvec upper lower
plotUpper <- sd_hourvec + hourvec
plotLower <- hourvec -sd_hourvec

#plot
plot(hourvec, ylim=(c(-2,2)))
for(x in 1:length(hourvec)) lines(c(x,x),c(plotUpper[x],plotLower[x]))
-------------------------------------------------------------------------------------------------------
#dummy data
df <- read.csv(text="
ID, Test1, Test2, Test3, Test4
1, 83, 84, 67, 44
2, 67, 55, 58, 59
3, 99, 98, 98, 95
")
#blank plot
plot(0,0,ylim=c(0,100),xlim=c(1,4),bty="n")
#add lines for each ID
for(i in df$ID) lines(1:(ncol(df)-1),
                      df[df$ID==i,2:ncol(df)])
-------------------------------------------------------------------------------------------------------
NA y2high <- y2
y2high[y2high < y1] <- NA
y2low <- y2
y2low[y2low > y1] <- NA

plot(x,y1,type='l', col='blue')
lines(x,y2high,col='red')
lines(x,y2low,col='green')
-------------------------------------------------------------------------------------------------------
# call your data dat
dat <- 
structure(list(V1 = c(881001L, 883001L, 885001L, 887001L, 889001L, 
891001L, 893001L, 895001L, 897001L, 899001L, 901001L, 903001L, 
905001L, 907001L), V2 = c(2L, 0L, 0L, 0L, 2L, 7L, 6L, 0L, 2L, 
2L, 2L, 5L, 5L, 3L), V3 = c(1L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 
0L, 0L, 0L, 0L, 0L), V4 = c(0L, 0L, 2L, 1L, 0L, 0L, 2L, 3L, 0L, 
0L, 0L, 0L, 0L, 0L)), .Names = c("V1", "V2", "V3", "V4"), class = "data.frame", row.names = c(NA, 
-14L))


plot(dat$V1, dat$V2, main = "your plot")
lines(spline(dat$V1, dat$V2), col = 4)
-------------------------------------------------------------------------------------------------------
splom(~iris.out[1:4],
  lower.panel=function(x,y,...){
    x.out=order(x,decreasing=FALSE)[1:10]
    y.out=order(x,decreasing=FALSE)[1:10]
    out=c(x.out,y.out)
    x=x[-out]
    y=y[-out]
    panel.hexbinplot(x,y, xbins =20,colramp = function(n){heat.ob(n, beg=15, end=225)},...)
  },
  diag.panel = function(x,...){
    x=x[-order(x,decreasing=FALSE)[1:10]]
    yrng <- current.panel.limits()$ylim
    d <- density(x, na.rm = TRUE)
    d$y <- with(d, yrng[1] + 0.95 * diff(yrng) * y / max(y))
    panel.lines(d, col = "darkgrey")
    diag.panel.splom(x, ...)
  },
  upper.panel=function(x,y,groups=iris$Species,...){
    x.out=order(x,decreasing=FALSE)[1:10]
    y.out=order(x,decreasing=FALSE)[1:10]
    out=c(x.out,y.out)
    x=x[-out]
    y=y[-out]
    panel.splom(x,y,groups=iris$Species,...)
  }
)
-------------------------------------------------------------------------------------------------------
?par "33" matplot lty matplot lty lty = c("44","22","33","3322") matplot if (!add) {
        ii <- ii[-1L]
        plot(x[, 1L], y[, 1L], type = type[1L], xlab = xlab, 
            ylab = ylab, xlim = xlim, ylim = ylim, lty = lty[[1L]], 
            lwd = lwd[1L], lend = lend[1L], pch = pch[1L], col = col[1L], 
            cex = cex[1L], bg = bg[1L], ...)
    }
    for (i in ii)
 lines(x[, i], y[, i], type = type[i], lty = lty[[i]], lwd = lwd[i], lend = lend[i], pch = pch[i], col = col[i], cex = cex[i], bg = bg[i]) [[ [ lty lty
-------------------------------------------------------------------------------------------------------
maps mapproject expand.grid(long,lat) library("mapproj")
m <- map( "world", "Antarctica", plot=FALSE)
map("world", "Antarctica", proj="conic", param=-90, fill=TRUE, col="gray")
map.grid(m, nx=4, ny=6, col="black")

front.lim <- data.frame(x=seq(-180, 180, length.out=1000),
                        y=rep(-62, 1000))
front.lim <- mapproject(front.lim$x, front.lim$y, projection="conic", parameters=-90)
lines(front.lim$x, front.lim$y, col="red", lwd=2) map(add=TRUE) plot(c(-10, 45), c(30, 60), type="n", xlab="", ylab="") # image(ncdf)
map(add=TRUE, fill=TRUE, col="gray")
abline(v=seq(-10, 45, 7.5), lty=2)
abline(h=seq(-30, 60, 7.5), lty=2)
-------------------------------------------------------------------------------------------------------
h<-hist(g, breaks=10, density=10, col="lightgray", xlab="Accuracy", main="Overall") 
    xfit<-seq(min(g),max(g),length=40) 
    yfit<-dnorm(xfit,mean=mean(g),sd=sd(g)) 
    yfit <- yfit*diff(h$mids[1:2])*length(g) 
    lines(xfit, yfit, col="black", lwd=2)
-------------------------------------------------------------------------------------------------------
hist myhist <- hist(mtcars$mpg)
multiplier <- myhist$counts / myhist$density
mydensity <- density(mtcars$mpg)
mydensity$y <- mydensity$y * multiplier[1]

plot(myhist)
lines(mydensity) myhist <- hist(mtcars$mpg)
multiplier <- myhist$counts / myhist$density
mydensity <- density(mtcars$mpg)
mydensity$y <- mydensity$y * multiplier[1]

plot(myhist)
lines(mydensity)

myx <- seq(min(mtcars$mpg), max(mtcars$mpg), length.out= 100)
mymean <- mean(mtcars$mpg)
mysd <- sd(mtcars$mpg)

normal <- dnorm(x = myx, mean = mymean, sd = mysd)
lines(myx, normal * multiplier[1], col = "blue", lwd = 2)

sd_x <- seq(mymean - 3 * mysd, mymean + 3 * mysd, by = mysd)
sd_y <- dnorm(x = sd_x, mean = mymean, sd = mysd) * multiplier[1]

segments(x0 = sd_x, y0= 0, x1 = sd_x, y1 = sd_y, col = "firebrick4", lwd = 2)
-------------------------------------------------------------------------------------------------------
NA fit.lm$fitted time data Data <- read.table(file="900days.txt", header=TRUE, sep="")
Time <- Data$time 
temperature <- Data$temperature

xc<-cos(2*pi*Time/366)
xs<-sin(2*pi*Time/366)
fit.lm <- lm(temperature~xc+xs)

# access the fitted series (for plotting)
fit <- fitted(fit.lm)  

# find predictions for original time series
pred <- predict(fit.lm, newdata=data.frame(Time=Time))    

plot(temperature ~ Time, data= Data, xlim=c(1, 900))
lines(fit, col="red")
lines(Time, pred, col="blue")
-------------------------------------------------------------------------------------------------------
plot(log(y)~log(x)) y plot(log(y)~x)
modlm <- lm(log(y)~x)
abline(modlm) summary(modlm)

Call:
lm(formula = log(y) ~ x)

Residuals:
       Min         1Q     Median         3Q        Max 
-0.0081825 -0.0009194  0.0000952  0.0008455  0.0070058 

Coefficients:
              Estimate Std. Error t value Pr(>|t|)    
(Intercept)  6.927e+00  4.567e-04 15166.4   <2e-16 ***
x           -1.227e-04  3.516e-07  -349.1   <2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 0.002185 on 64 degrees of freedom
Multiple R-squared:  0.9995,    Adjusted R-squared:  0.9995 
F-statistic: 1.219e+05 on 1 and 64 DF,  p-value: < 2.2e-16 nls modnls <- nls(y~exp(a+b*x), start=list(a=coef(modlm)[[1]], b=coef(modlm)[[2]]))
plot(y~x)
xnew <- seq(min(x), max(x), by=0.5)
lines(xnew, exp(coef(modnls)[[1]]+xnew*coef(modnls)[[2]])) summary(modnls)

Formula: y ~ exp(a + b * x)

Parameters:
    Estimate Std. Error t value Pr(>|t|)    
a  6.926e+00  4.384e-04 15797.5   <2e-16 ***
b -1.225e-04  3.831e-07  -319.7   <2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 1.904 on 64 degrees of freedom

Number of iterations to convergence: 2 
Achieved convergence tolerance: 6.25e-08 lm nls y x
-------------------------------------------------------------------------------------------------------
library(Rcpp)

cppFunction('
  NumericVector rollmean_c2( NumericVector x, NumericVector y, double width,
                              double Min, double Max) {

double total = 0, redge,center;
unsigned int n = (Max - Min) + 1,
                  i, j=0, k, ledge=0, redgeIndex;
NumericVector out(n);


for (i = 0; i < n; i++){
  center = Min + i + 0.5;
  redge = center - width / 2;
  redgeIndex = 0;
  total = 0;

  while (x[redgeIndex] < redge){
    redgeIndex++;
  }
  j = redgeIndex;

  while (x[j] < redge + width){
    total += y[j++];

  }

  out[i] = total / (j - redgeIndex);
}
return out;

  }')

# Set up example data
x = seq(0,4*pi,length.out=2500)
y = sin(x) + rnorm(length(x),0.5,0.5)
plot(x,y,pch=20,col="black",
     main="Sliding window mean; width=1",
     sub="rollmean_c in red      rollmean_r overlaid in white.")


c.out = rollmean_c2(x,y,width=1,Min = min(x), Max = max(x)) 
lines(0.5:12.5,c.out,col="red",lwd=3)
-------------------------------------------------------------------------------------------------------
plot(spa, asp = 1, type = "n", main = "Brown trout", 
     xlab = "x coordinate (km)", ylab = "y coordinate (km)")
lines(spa, col="light blue")
points(spa, col = "brown", cex = spe$TRU)
points(spa, col = "green", cex = spe$OMB)
legend("topright", legend = c("Brown Trout", "Grayling"),
       col = c("brown","green"), pch = 1, bty = "n") points() lines() points()
-------------------------------------------------------------------------------------------------------
#basic plot
plot(NULL, ann = F, xlim = c(-10,20), ylim = c(-10,20))
abline(h = -10:20, col = grey(0.75), lty = 2)
abline(v = -10:20, col = grey(0.75), lty = 2)

#starting coordinates
A_coords = c(0,0)
B_coords = c(10,0)
text(A_coords[1], A_coords[2], "A", col = "red")
text(B_coords[1], B_coords[2], "B", col = "blue")

for(i in 1:15000)
 {
  Sys.sleep(1)

  text(A_coords[1], A_coords[2], "A", col = "white")
  text(B_coords[1], B_coords[2], "B", col = "white")
                                                       #used jonas's idea
  A <- A_coords + unlist(sample(list(c(0, 1), c(1, 0), c(-1, 0), c(0, -1)), 1)) 
  B <- B_coords + unlist(sample(list(c(0, 1), c(1, 0), c(-1, 0), c(0, -1)), 1))

  lines(c(A_coords[1], A[1]), c(A_coords[2], A[2]), col = "red")
  lines(c(B_coords[1], B[1]), c(B_coords[2], B[2]), col = "blue")

  A_coords <- A
  B_coords <- B

  text(A_coords[1], A_coords[2], "A", col = "red")
  text(B_coords[1], B_coords[2], "B", col = "blue")

  if(all(abs(A_coords - B_coords) <= 1)) break
 }

list(steps = i, A_coordinates = A_coords, B_coordinates = B_coords)
-------------------------------------------------------------------------------------------------------
### Create data frame with mean and std dev
x <- data.frame(mean=tapply(mtcars$mpg, list(mtcars$cyl), mean), sd=tapply(mtcars$mpg, list(mtcars$cyl), sd) )

###  Add lower and upper levels of confidence intervals
x$LL <- x$mean-2*x$sd
x$UL <- x$mean+2*x$sd

### plot dotchart with confidence intervals

title <- "MPG by Num. of Cylinders with 95% Confidence Intervals"

dotchart(x$mean, col="blue", xlim=c(floor(min(x$LL)/10)*10, ceiling(max(x$UL)/10)*10), main=title )

for (i in 1:nrow(x)){
    lines(x=c(x$LL[i],x$UL[i]), y=c(i,i))
}
grid()
-------------------------------------------------------------------------------------------------------
N <- 10000
 x <- rnbinom(N, 10, .5)
 hist(x, 
 xlim=c(min(x),max(x)), probability=T, nclass=max(x)-min(x)+1, 
   col='lightblue', xlab=' ', ylab=' ', axes=F,
   main='Positive Skewed')
lines(density(x,bw=1), col='red', lwd=3) curve(dbeta(x,8,4),xlim=c(0,1))
title(main="posterior distrobution of p")
-------------------------------------------------------------------------------------------------------
dfP <- data.frame(Pareto_n=1:10,Pareto_z=1:10) lines points plot(dfP$Pareto_n,dfP$Pareto_z,xlim=c(1,max(dfP$Pareto_n)),
  ylim=c(min(dfP$Pareto_z),max(dfP$Pareto_z)),xlab="n",ylab="z(n)",type="n")

lines(dfP$Pareto_n,dfP$Pareto_z,lwd=2,col="blue")
points(dfP$Pareto_n,dfP$Pareto_z,lwd=2,pch=23,col="red",bg="red")
-------------------------------------------------------------------------------------------------------
fit <- gam(MPG~s(SP), data=car)

plot(car$HP, car$MPG)
x <- seq(0, 350, length = 500)
y <- predict(fit, data.frame(SP = x))
lines(x, y, col = "red", lwd = 2)
-------------------------------------------------------------------------------------------------------
par(mfrow=c(1,2))

fit <- gam(MPG~s(SP), data=car)
plot(car$SP, car$MPG)
x <- seq(0, 350, length = 500)
y <- predict(fit, data.frame(SP = x))
lines(x, y, col = "red", lwd = 2)

fit <- gam(MPG~s(HP), data=car)
plot(car$HP, car$MPG)
x <- seq(0, 350, length = 500)
y <- predict(fit, data.frame(HP = x))
lines(x, y, col = "red", lwd = 2)
-------------------------------------------------------------------------------------------------------
predict x.two <- df$x2
lines(x = sort(x.two),
      y = predict(mod, newdata=data.frame(x1=factor("1"), x2=sort(x.two) ) ) ,
      col="red")
 lines(x = sort(x.two),
       y = predict(mod, newdata=data.frame(x1=factor("2"), x2=sort(x.two) ) ) ,
       col="green")
 lines(sort(x.two),
       predict(mod,  newdata=data.frame(x1=factor("3"),x2=sort(x.two) ) ) , col="orange")
-------------------------------------------------------------------------------------------------------
x = seq(0, 3, len = 100)
y1 = function(x) x^2 -2*x +2
y2 = function(x) -4*x + 1
z = function(x) y1(x)/(y1(x)-y2(x)) plot(x,y1(x),ylim=c(-12,5),type="l",ylab="y")
lines(x,y2(x),col="blue")
lines(x,z(x),col="red")
abline(h=0,v=0,col="gray")
legend("bottomleft",c("y1(x)","y2(x)","z(x)"),fill=c("black","blue","red"))
-------------------------------------------------------------------------------------------------------
x <- rnorm(100) # example data

hist(x, freq = FALSE) # you need to specify freq = FALSE
lines(density(x))
-------------------------------------------------------------------------------------------------------
-1i imVecs <- lengths*c(0-1i)^(0:3)
imVecs
# [1]  9+0i  0-5i -9+0i  0+9i  8+0i  0-5i -8+0i  0+7i  8+0i  0-1i -5+0i  0+3i  4+0i  0-7i -4+0i  0+2i
#[17]  3+0i  0-7i -5+0i  0+8i

cumsum(imVecs)
# [1] 9+0i 9-5i 0-5i 0+4i 8+4i 8-1i 0-1i 0+6i 8+6i 8+5i 3+5i 3+8i 7+8i 7+1i 3+1i 3+3i 6+3i 6-4i 1-4i
#[20] 1+4i
plot(cumsum(imVecs))
lines(cumsum(imVecs)) > sqrt(-1i)
[1] 0.7071068-0.7071068i
> imVecs <- lengths*sqrt(0-1i)^(0:7)
Warning message:
In lengths * sqrt(0 - (0+1i))^(0:7) :
  longer object length is not a multiple of shorter object length
> plot(cumsum(imVecs))
> lines(cumsum(imVecs))
-------------------------------------------------------------------------------------------------------
turn set.seed(11)
dat <- data.frame(id = LETTERS[1:6], lens = sample(2:9, 6),
                                     turn = -pi/2)

dat <- within(dat, { facing   <- pi/2 + cumsum(turn)
                     move     <- lens * exp(1i * facing)
                     position <- cumsum(move)
                     x2       <- Re(position)
                     y2       <- Im(position)
                     x1       <- c(0, head(x2, -1))
                     y1       <- c(0, head(y2, -1))
                   })

dat[c("id", "lens", "x1", "y1", "x2", "y2")]
#   id lens x1 y1 x2 y2
# 1  A    4  0  0  4  0
# 2  B    2  4  0  4 -2
# 3  C    5  4 -2 -1 -2
# 4  D    8 -1 -2 -1  6
# 5  E    6 -1  6  5  6
# 6  F    9  5  6  5 -3 turn lens -pi/2 trace.path <- function(lens, turn) {
  facing   <- pi/2 + cumsum(turn)
  move     <- lens * exp(1i * facing)
  position <- cumsum(move)
  x        <- c(0, Re(position))
  y        <- c(0, Im(position))

  plot.new()
  plot.window(range(x), range(y))
  lines(x, y)
}

trace.path(lens = seq(0, 1,  length.out = 200),
           turn = rep(pi/2 * (-1 + 1/200), 200)) trace.path(lens = seq(1, 10, length.out = 1000),
           turn = rep(2 * pi / 10, 1000))

trace.path(lens = seq(0, 1,  length.out = 500),
           turn = seq(0, pi, length.out = 500))

trace.path(lens = seq(0, 1,  length.out = 600) * c(1, -1),
           turn = seq(0, 8*pi, length.out = 600) * seq(-1, 1, length.out = 200))
-------------------------------------------------------------------------------------------------------
x = ts(cumsum(rnorm(40)), start = c(2013, 1), freq = 12)
x.sub = window(x, start = c(2014, 1), end = c(2014, 12))

plot(x)
lines(x.sub, col = 'red', lwd = 2) plot(x, xlim = c(2014, 2014.5))
-------------------------------------------------------------------------------------------------------
density angle polygon() x=seq(-7,10,length=200)
 y1=dnorm(x,mean=0,sd=1)
 plot(x,y1,type="l",lwd=2,col="red")
 y2=dnorm(x,mean=3,sd=2)
 lines(x,y2,type="l",lwd=2,col="blue")


 polygon(x,pmin(y1,y2), density = 10, angle = -45)
-------------------------------------------------------------------------------------------------------
plot plot(NA, xlim=c( min(dat$Value)-max(dat$Error), 
                 max(dat$Value)+max(dat$Error) ),
         ylim=c(0,1) )
apply(dat, 1, function(x){ xx <-seq( x['Value']-x['Error'], 
                                    x['Value']+x['Error'], length=20);
                           yy=dnorm(xx, x['Value'], x['Error']/2);  sd is 1/2 'Error'
                           lines(xx,  yy/max(yy)) })  # normalize to peak == 1
-------------------------------------------------------------------------------------------------------
library(ape)

heatmap.phylo <- function(x, Rowp, Colp, breaks, col, denscol="cyan", respect=F, ...){
    # x numeric matrix
    # Rowp: phylogenetic tree (class phylo) to be used in rows
    # Colp: phylogenetic tree (class phylo) to be used in columns
    # ... additional arguments to be passed to image function

    scale01 <- function(x, low = min(x), high = max(x)) {
        x <- (x - low)/(high - low)
        x
    }

    col.tip <- Colp$tip
    n.col <- 1
    if (is.null(col.tip)) {
        n.col <- length(Colp)
        col.tip <- unlist(lapply(Colp, function(t) t$tip))
        col.lengths <- unlist(lapply(Colp, function(t) length(t$tip)))
        col.fraction <- col.lengths / sum(col.lengths)
        col.heights <- unlist(lapply(Colp, function(t) max(node.depth.edgelength(t))))
        col.max_height <- max(col.heights)
    }

    row.tip <- Rowp$tip
    n.row <- 1
    if (is.null(row.tip)) {
        n.row <- length(Rowp)
        row.tip <- unlist(lapply(Rowp, function(t) t$tip))
        row.lengths <- unlist(lapply(Rowp, function(t) length(t$tip)))
        row.fraction <- row.lengths / sum(row.lengths)
        row.heights <- unlist(lapply(Rowp, function(t) max(node.depth.edgelength(t))))
        row.max_height <- max(row.heights)
    }

    cexRow <- min(1, 0.2 + 1/log10(n.row))
    cexCol <- min(1, 0.2 + 1/log10(n.col))

    x <- x[row.tip, col.tip]
    xl <- c(0.5, ncol(x)+0.5)
    yl <- c(0.5, nrow(x)+0.5)

    screen_matrix <- matrix( c(
        0,1,4,5,
        1,4,4,5,
        0,1,1,4,
        1,4,1,4,
        1,4,0,1,
        4,5,1,4
    ) / 5, byrow=T, ncol=4 )

    if (respect) {
        r <- grconvertX(1, from = "inches", to = "ndc") / grconvertY(1, from = "inches", to = "ndc")
        if (r < 1) {
            screen_matrix <- screen_matrix * matrix( c(r,r,1,1), nrow=6, ncol=4, byrow=T)
        } else {
            screen_matrix <- screen_matrix * matrix( c(1,1,1/r,1/r), nrow=6, ncol=4, byrow=T)
        }
    }


    split.screen( screen_matrix )

    screen(2)
    par(mar=rep(0,4))

    if (n.col == 1) {
        plot(Colp, direction="downwards", show.tip.label=FALSE,xaxs="i", x.lim=xl)
    } else {
        screens <- split.screen( as.matrix(data.frame( left=cumsum(col.fraction)-col.fraction, right=cumsum(col.fraction), bottom=0, top=1)))
        for (i in 1:n.col) {
            screen(screens[i])
            plot(Colp[[i]], direction="downwards", show.tip.label=FALSE,xaxs="i", x.lim=c(0.5,0.5+col.lengths[i]), y.lim=-col.max_height+col.heights[i]+c(0,col.max_height))
        }
    }

    screen(3)
    par(mar=rep(0,4))

    if (n.col == 1) {
        plot(Rowp, direction="rightwards", show.tip.label=FALSE,yaxs="i", y.lim=yl)
    } else {
        screens <- split.screen( as.matrix(data.frame( left=0, right=1, bottom=cumsum(row.fraction)-row.fraction, top=cumsum(row.fraction))) )
        for (i in 1:n.col) {
            screen(screens[i])
            plot(Rowp[[i]], direction="rightwards", show.tip.label=FALSE,yaxs="i", x.lim=c(0,row.max_height), y.lim=c(0.5,0.5+row.lengths[i]))
        }
    }


    screen(4)
    par(mar=rep(0,4), xpd=TRUE)
    image((1:nrow(x))-0.5, (1:ncol(x))-0.5, x, xaxs="i", yaxs="i", axes=FALSE, xlab="",ylab="", breaks=breaks, col=col, ...)

    screen(6)
    par(mar=rep(0,4))
    plot(NA, axes=FALSE, ylab="", xlab="", yaxs="i", xlim=c(0,2), ylim=yl)
    text(rep(0,nrow(x)),1:nrow(x),row.tip, pos=4, cex=cexCol)

    screen(5)
    par(mar=rep(0,4))
    plot(NA, axes=FALSE, ylab="", xlab="", xaxs="i", ylim=c(0,2), xlim=xl)
    text(1:ncol(x),rep(2,ncol(x)),col.tip, srt=90, adj=c(1,0.5), cex=cexRow)

    screen(1)
    par(mar = c(2, 2, 1, 1), cex = 0.75)

    symkey <- T
    tmpbreaks <- breaks
    if (symkey) {
        max.raw <- max(abs(c(x, breaks)), na.rm = TRUE)
        min.raw <- -max.raw
        tmpbreaks[1] <- -max(abs(x), na.rm = TRUE)
        tmpbreaks[length(tmpbreaks)] <- max(abs(x), na.rm = TRUE)
    } else {
        min.raw <- min(x, na.rm = TRUE)
        max.raw <- max(x, na.rm = TRUE)
    }
    z <- seq(min.raw, max.raw, length = length(col))

    image(z = matrix(z, ncol = 1), col = col, breaks = tmpbreaks, 
          xaxt = "n", yaxt = "n")
    par(usr = c(0, 1, 0, 1))
    lv <- pretty(breaks)
    xv <- scale01(as.numeric(lv), min.raw, max.raw)
    axis(1, at = xv, labels = lv)

    h <- hist(x, plot = FALSE, breaks = breaks)
    hx <- scale01(breaks, min.raw, max.raw)
    hy <- c(h$counts, h$counts[length(h$counts)])
    lines(hx, hy/max(hy) * 0.95, lwd = 1, type = "s", 
          col = denscol)
    axis(2, at = pretty(hy)/max(hy) * 0.95, pretty(hy))
    par(cex = 0.5)
    mtext(side = 2, "Count", line = 2)

    close.screen(all.screens = T)

}

tree <- read.tree(text = "(A:1,B:1);((C:1,D:2):2,E:1);((F:1,G:1,H:2):5,((I:1,J:2):2,K:1):1);", comment.char="")
N <- sum(unlist(lapply(tree, function(t) length(t$tip))))

set.seed(42)
m <- cor(matrix(rnorm(N*N), nrow=N))
rownames(m) <- colnames(m) <- LETTERS[1:N]
heatmap.phylo(m, tree, tree, col=bluered(10), breaks=seq(-1,1,length.out=11), respect=T)
-------------------------------------------------------------------------------------------------------
x1 x2 set.seed(1)
x1=rnorm(100,0,1)
x2=rnorm(100,1,1)
# Find points where x1 is above x2.
above<-x1>x2
# Points always intersect when above=TRUE, then FALSE or reverse
intersect.points<-which(diff(above)!=0)
# Find the slopes for each line segment.
x1.slopes<-x1[intersect.points+1]-x1[intersect.points]
x2.slopes<-x2[intersect.points+1]-x2[intersect.points]
# Find the intersection for each segment.
x.points<-intersect.points + ((x2[intersect.points] - x1[intersect.points]) / (x1.slopes-x2.slopes))
y.points<-x1[intersect.points] + (x1.slopes*(x.points-intersect.points))
# Plot.
plot(x1,type='l')
lines(x2,type='l',col='red')
points(x.points,y.points,col='blue')
-------------------------------------------------------------------------------------------------------
my.panel <- function(x, y, ..., pf = parent.frame()) {
  grid(NA,NULL)
  lines(x, y, ...)
  if (pf$panel.number == 3) axis(1, at = ticks, labels = format(ticks, "%b-%y"))
}

plot(zoo(Factors, ticks), 
   main = "Factors 1, 2 & 3", xlab= "Date", ylab = paste("Factor", 1:3),
   panel = my.panel,
   col = 1:3,
   xaxt = "n")
-------------------------------------------------------------------------------------------------------
ggplot df <- data.frame(t(freqTable))        # transpose (more suitable for plotting)
df <- cbind(Response=rownames(df),df) # add row names as first column

plot(as.numeric(df$Response),df$f,type="b",col="red", 
     xaxt="n", ylab="Count",xlab="Response")
lines(as.numeric(df$Response),df$m,type="b",col="blue")
axis(1,at=c(1,2,3,4,5,6),labels=c("Str.Agr.","Sl.Agr","Neither","Sl.Disagr","Str.Disagr","NA")) df df <- data.frame(freqTable)
df <- cbind(Gender=rownames(df),df)    # append rownames (Gender)
df <- df[-3,]                          # drop unknown gender
df
#   Gender X1 X2 X3 X4 X5 X8
# m      m  5 16  3 16  5  0
# f      f 12 25  3 10  3  1

df <- df[-3,]     # remove unknown gender column

library(ggplot2)
library(reshape2)
gg=melt(df)

labels <- c("Agree\nFully","Somewhat\nAgree","Neither Agree\nnor Disagree","Somewhat\nDisagree","Disagree\nFully", "No Answer")
ggp <- ggplot(gg,aes(x=variable,y=value))
ggp <- ggp + geom_bar(aes(fill=Gender), position="dodge", stat="identity")
ggp <- ggp + scale_x_discrete(labels=labels)
ggp <- ggp + theme(axis.text.x = element_text(angle=90, vjust=0.5))
ggp <- ggp + labs(x="", y="Frequency")
ggp ggp + facet_grid(Gender~.)
-------------------------------------------------------------------------------------------------------
ternaryplot library(vcd)
ternaryplot(abs(replicate(3, rnorm(50))), grid=FALSE)

top <- sqrt(3)/2
xlim <- c(-0.03, 1.03)
ylim <- c(-1, top)
pushViewport(viewport(width = unit(1, "snpc")))
pushViewport(viewport(width = 0.8, height = 0.8, xscale = xlim, 
                      yscale = ylim, name = "plot"))
grid.lines(c(0.75, 0.00), c(0.5 * top, 0))
grid.lines(c(0.25, 1.00), c(0.5 * top, 0))
grid.lines(c(0.50, 0.50), c(1.0 * top, 0))
upViewport(2)
-------------------------------------------------------------------------------------------------------
# not using layout function

# colors
n <- 1:50
col <- rainbow(length(n))

# expanding right margin 
par(mar=c(5,4,4,8),xpd=T)

# simulating any graph
plot(n,n*2,type='n',ylab="fun(x,n)")

# making DYI scale and legend
# scale
x <- rep(par('usr')[2]*1.1,length(n)+1)
y <- seq(f=par('usr')[3],t=par('usr')[4],length.out=length(n)+1)
nul <- sapply(n,FUN=function(n,col,x,y,...){lines(x=x[c(n,n+1)],y=y[c(n,n+1)],col=col[n],...)},lwd=30,lend="butt",col=col,x=x,y=y)
# labels
ty <- y[n]+diff(y)/2
tx <- rep(par('usr')[2]*1.25,length(n))
t <- paste("Lab",n)
ti <- pretty(n)
text(x=tx[ti],y=ty[ti],t[ti])
-------------------------------------------------------------------------------------------------------
## plotting area with no axes
plot(unrate.df, type = "n")
lim <- par("usr")
## adding one rectangle
for (i in 1:nrow(recessions.trim)) {
     rect(recessions.trim[i, 1], lim[3], 
          recessions.trim[i, 2], lim[4], border = "pink", col = "pink")
}
## adding the data
lines(unrate.df)
box()
-------------------------------------------------------------------------------------------------------
plot(unrate.df, type="n")
makeRectangles(recessions.trim, col="pink", alpha=0.5)
lines(unrate.df)
grid() makeRectangles makeRectangles = function(x, col, alpha=1, border=NA, ...) {

  col = col2rgb(col=col, alpha=FALSE)
  col = rgb(red=col[1], green=col[2], blue=col[3], 
              alpha=floor(255*alpha) , maxColorValue=255)
  rect(x[,1], par("usr")[3], x[,2], par("usr")[4], col=col, border=border, ...)

  return(invisible())
}
-------------------------------------------------------------------------------------------------------
lines() mids x lwd= lend="butt" set.seed(123)
x<-rnorm(100)
zz<-hist(x)

plot(x=c(-2.5,2.5),y=c(0,1),type="n")
lines(zz$mids, zz$density, type="h",lwd=50,lend="butt") plot(x=c(-2.5,2.5),y=c(0,1),type="n")
lines(zz$mids, zz$density, type="h",lwd=50,lend="butt")
lines(zz$mids, zz$density-0.005, type="h",lwd=48,lend="butt",col="white")
-------------------------------------------------------------------------------------------------------
lines hist h <- hist(..., plot=FALSE)
# Other plotting functions go here.
lines(h) # will now plot the histogram in the plotting window.
-------------------------------------------------------------------------------------------------------
Data <- structure(list(data1 = c(155, 195, 21, 15, 190, 2, 182, 115, 
                                 170, 17), data2 = c(130, 10, 26, 210, 15, 205, 50, 55, 1, 56)), .Names = c("data1", 
                                                                                                            "data2"), row.names = c(NA, -10L), class = "data.frame")
par( mfrow=c(1,2) ) 
invisible(lapply(1:ncol(Data), function(i){
  x <- Data[,i]
  h <- hist(x, col=c("red","blue"),
            main = paste0("Histogram of ", names(Data)[i]),
            xlab="X-Axis", ylab="Y-Axis", breaks=5,
            cex.lab= 1, col.lab="blue")
  xfit<-seq(min(x),ceiling(210/50)*50,length=40) 
  yfit<-dnorm(xfit,mean=mean(x),sd=sd(x)) 
  yfit <- yfit*diff(h$mids[1:2])*length(x) 
  lines(xfit, yfit, col="green", lwd=2)
}))
-------------------------------------------------------------------------------------------------------
freq = FALSE hist set.seed(1)
Y1 <- rgamma(100, 10, 3)

hist(Y1, breaks = 30, freq = FALSE)
dens <- density(Y1)
lines(dens)
-------------------------------------------------------------------------------------------------------
x.pois Y1 Y1 <- 100
set.seed(101) ## for reproducibility
x.pois<-rpois(Y1, 20)
hist(x.pois, breaks=100,freq=FALSE)
lines(density(x.pois, bw=0.8), col="red")
library(MASS)
(my.mle<-fitdistr(x.pois, densfun="poisson"))
##      lambda  
##   20.6700000 
##  ( 0.4546427)
BIC(my.mle)
## [1] 572.7861 Y1 rpois() Y1 x.pois
-------------------------------------------------------------------------------------------------------
base points lines barplot plot par(mar=c(5,5,2,3)+0.1)
ratio<-9e6/0.14
bar.col<-'#558ED5'
vencido.col<-'#77933C'
castigos.col<-'#FE0F0F'
b<-barplot(Data$'Monto Otorgado acumulado',names.arg=Data$Month,col=bar.col,border=FALSE,main='My Plot',ylim=c(0,9e6),axes=FALSE)
lines(b,Data$'% Vencida' * ratio, col=vencido.col,lwd=2) 
points(b,Data$'% Vencida' * ratio, col=vencido.col,bg='white',pch=21) 
lines(b,Data$'% Castigos' * ratio, col=castigos.col,lwd=2)
points(b,Data$'% Castigos' * ratio, col=castigos.col,bg='white',pch=21)
left.axis.pos<-seq(0,9e6,by=1e6)
axis(2,at=left.axis.pos,labels=formatC(left.axis.pos, big.mark = ",", format = "d"),las=2)
right.axis.ticks<-0:14
axis(4,at=(right.axis.ticks/100)*ratio,labels=paste0(right.axis.ticks,'%'),las=2)
legend('topleft',legend=c('Monto Otorgado acumulado','% Vencido','% Castigos'),col=c(bar.col,vencido.col,castigos.col),lty=1,lwd=c(4,2,2),bty='n')
par(mar=c(5,4,2,2)+0.1)
-------------------------------------------------------------------------------------------------------
> library(drc)
> value.m1 <- drm(value ~ period, fct = LL.4())
>
> before <- predict(value.m1, data.frame(period = 1:12)); before
 [1] -0.021014377 -0.014620515 -0.003811402  0.011217655  0.030115032
 [6]  0.052416255  0.077583272  0.105041527  0.134213115  0.164544170
[11]  0.195525422  0.226705738
> after <- predict(value.m1, data.frame(period = 74:140)); after
 [1] 0.8295972 0.8309413 0.8322356 0.8334824 0.8346839 0.8358422 0.8369594
 [8] 0.8380374 0.8390778 0.8400824 0.8410528 0.8419904 0.8428968 0.8437731
[15] 0.8446209 0.8454411 0.8462350 0.8470037 0.8477483 0.8484696 0.8491687
[22] 0.8498463 0.8505035 0.8511409 0.8517594 0.8523597 0.8529424 0.8535083
[29] 0.8540579 0.8545920 0.8551109 0.8556154 0.8561059 0.8565830 0.8570470
[36] 0.8574986 0.8579380 0.8583658 0.8587823 0.8591880 0.8595831 0.8599681
[43] 0.8603433 0.8607090 0.8610656 0.8614132 0.8617523 0.8620831 0.8624058
[50] 0.8627207 0.8630281 0.8633282 0.8636213 0.8639074 0.8641869 0.8644600
[57] 0.8647268 0.8649875 0.8652424 0.8654915 0.8657351 0.8659733 0.8662063
[64] 0.8664342 0.8666572 0.8668754 0.8670889
> plot(value.m1, xlim = c(1, 140), ylim = 0:1, pch = 20) before MM.3 value.m2 <- drm(value ~ period, fct = MM.3())
plot(value.m2, xlim = c(1, 140), ylim = 0:1, pch = 20) value.pred1 <- predict(value.m1, data.frame(period = 1:140))
value.pred2 <- predict(value.m2, data.frame(period = 1:140))
value.pred12 <- c( head(value.pred1, 19), tail(value.pred2, -19) )
lines(1:140, value.pred12, col = "red") DF <- data.frame(value.cum = cumsum(value), period)
fm <- drm(value.cum ~ period, data = DF, fct = LL.4())
plot(fm, xlim = c(1, 140), ylim = c(0, 100), pch = 20) MM.3
-------------------------------------------------------------------------------------------------------
DF <- read.table(text="4924    0.0000 
4989    0.0287 
4702    0.0574 
4169    0.0861 
3616    0.1148 
3148    0.1435 
2682    0.1722 
2314    0.2010 
2153    0.2297 
2079    0.2584 
2019    0.2871 
2060    0.3158 
2314    0.3445 
2472    0.3732 
2604    0.4019 
2904    0.4306 
3173    0.4593 
3392    0.4880 
3655    0.5167 
3862    0.5455 
4101    0.5742 
4441    0.6029 
4625    0.6316 
4698    0.6603")

DF[, 3] <- filter(DF[, 1], c(1, 2, 1)/4)

plot(DF[, 2:1])
lines(DF[, 2:3])
-------------------------------------------------------------------------------------------------------
N      <- 1000
D      <- 1
path.1 <- matrix(NA,N,2)
path.2 <- matrix(NA,N,2)
path.1[1,] <- c(40,40)
path.2[1,] <- c(50,50)
set.seed(1)
system.time({
for (i in 2:N){
  path.1[i,] <- path.1[i-1,] + sample(-D:D,2)
  path.2[i,] <- path.2[i-1,] + sample(-D:D,2)
  cross <- sapply(2:i,function(k){seg.intersect(path.2[(k-1):k,],path.1[(i-1):i,])})
  if (any(cross)) break
  cross <- sapply(2:i,function(k){seg.intersect(path.1[(k-1):k,],path.2[(i-1):i,])})
  if (any(cross)) break
}
})
#    user  system elapsed 
#  296.25    0.00  296.83 
plot(0:70,0:70, type="n", xlab="X", ylab="Y")
points(path.1[1,1],path.1[1,2], pch=16, col="red", cex=1.5)
points(path.2[1,1],path.2[1,2], pch=16, col="green", cex=1.5)
lines(path.1[1:i,])
lines(path.2[1:i,],col="red") i 2*(i-1) k 2*k*(k+1) k ~O(10000) seg.intersect(...) seg.intersect <- function(l1,l2){
  is.between <- function(x,vec) {  # test if x is between values in vec
    return(x>=range(vec)[1] & x<=range(vec)[2])
  }
  get.line <- function(l) {        # returns slope and intercept 
    if (diff(l)[1]==0) return(c(Inf,NA))
    m <- diff(l)[2]/diff(l)[1]
    b <- l[1,2]-m*l[1,1]
    return(c(m,b))
  }
  special.cases = function(l1,l2) {
    pts   <- list(l1,l2)
    coeff <- do.call(rbind,lapply(pts,get.line))
    # points coincide: not a line segment!
    if (rowSums(diff(l1)^2)==0 | rowSums(diff(l2)^2)==0) return(c(NA,FALSE))
    # both lines vertical
    if (is.infinite(coeff[1,1]) & is.infinite(coeff[2,1])) {
      if (l1[1,1]!=l2[1,1]) return(c(NA,FALSE))
      t1 <- is.between(l1[1,2],l2[,2]) | is.between(l1[2,2],l2[,2])
      t2 <- is.between(l2[1,2],l1[,2]) | is.between(l2[2,2],l1[,2])
      return(c(NA,t1|t2))
    }
    # only l1 is vertical
    if (is.infinite(coeff[1,1]) & is.finite(coeff[2,1])) {
      x <- l1[1,1]
      y <- c(x,1) %*% coeff[2,]
      return(c(x,y))
    }
    # only l2 is vertical
    if (is.finite(coeff[1,1]) & is.infinite(coeff[2,1])) {
      x <- l2[1,1]
      y <- c(x,1) %*% coeff[1,]
      return(c(x,y))
    }
    # parallel, non-coincident lines
    if (diff(coeff[,1])==0 & diff(coeff[,2])!=0) return(c(NA,FALSE))
    # parallel, coincident lines
    if (diff(coeff[,1])==0 & diff(coeff[,2])==0) {
      x <- l1[1,1]
      y <- l1[1,2]
      return(c(x,y))
    }
    # base case: finite slopes, not parallel
    x <- -diff(coeff[,2])/diff(coeff[,1])
    y <- c(x,1) %*% coeff[1,]
    return(c(x,y))   
  }
  z <- special.cases(l1,l2)
  if (is.na(z[1])) return (z[2])
#  print(coeff)
#  print(z)
  found <- do.call("&",lapply(pts,function(x){is.between(z[1],x[,1]) & is.between(z[2],x[,2])}))
  return(found)
}
-------------------------------------------------------------------------------------------------------
