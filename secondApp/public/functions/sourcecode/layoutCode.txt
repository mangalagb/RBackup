grid.newpage()
pushViewport(viewport(layout=grid.layout(2,2)))
vplayout<-function(x,y)
    viewport(layout.pos.row=x,layout.pos.col=y)
print(a,vp=vplayout(1,1:2))
print(b,vp=vplayout(2,1))
print(c,vp=vplayout(2,2))
-------------------------------------------------------------------------------------------------------
run.jags sink("results_str.txt")
str(results$density)
sink() results$density$m$layout <- c(1,2)
print(results$density$m) c.trellis latticeExtra class(results$density$m) <- "trellis"   # overwrite class "plotindpages"
class(results$density$c) <- "trellis"   # overwrite class "plotindpages"
library("latticeExtra")
update(c(results$density$m, results$density$c), layout=c(2,2)) grid library("grid")
results$density$m$layout <- c(2,1)
results$density$c$layout <- c(2,1)
class(results$density$m) <- "trellis"
class(results$density$c) <- "trellis"
layout <- grid.layout(2, 1, heights=unit(c(1, 1), c("null", "null")))
grid.newpage()
pushViewport(viewport(layout=layout))
pushViewport(viewport(layout.pos.row=1))
print(results$density$m, newpage=FALSE)
popViewport()
pushViewport(viewport(layout.pos.row=2))
print(results$density$c, newpage=FALSE)
popViewport()
popViewport()
-------------------------------------------------------------------------------------------------------
p1 <- results$density$c
p2 <- results$density$m

p1$layout <- c(1,1)
p1$index.cond[[1]] <- 1   # remove second index
p1$condlevels[[1]] <- "c"   # remove "V1"
class(p1) <- "trellis"   # overwrite class "plotindpages"

p2$layout <- c(1,1)
p2$index.cond[[1]] <- 1   # remove second index
p2$condlevels[[1]] <- "m"   # remove "V1"
class(p2) <- "trellis"   # overwrite class "plotindpages"

library(grid)
layout <- grid.layout(2, 1, heights=unit(c(1, 1), c("null", "null")))
grid.newpage()
pushViewport(viewport(layout=layout))
pushViewport(viewport(layout.pos.row=1))
print(p1, newpage=FALSE)
popViewport()
pushViewport(viewport(layout.pos.row=2))
print(p2, newpage=FALSE)
popViewport()
popViewport()
-------------------------------------------------------------------------------------------------------
?layout r<-lm(y~x1+x2)
layout(matrix(1:4,2,2))
plot(r)
-------------------------------------------------------------------------------------------------------
require(gplots) 

# example data, bivariate normal, no correlation
x <- rnorm(2000, sd=4) 
y <- rnorm(2000, sd=1) 

# separate scales for each axis, this looks circular
hist2d(x,y, nbins=50, col = c("white",heat.colors(16))) 
rug(x,side=1) 
rug(y,side=2) 
box() library("geneplotter")  ## from BioConductor
require("RColorBrewer") ## from CRAN

x1  <- matrix(rnorm(1e4), ncol=2)
x2  <- matrix(rnorm(1e4, mean=3, sd=1.5), ncol=2)
x   <- rbind(x1,x2)

layout(matrix(1:4, ncol=2, byrow=TRUE))
op <- par(mar=rep(2,4))
smoothScatter(x, nrpoints=0)
smoothScatter(x)
smoothScatter(x, nrpoints=Inf,
              colramp=colorRampPalette(brewer.pal(9,"YlOrRd")),
              bandwidth=40)
colors  <- densCols(x)
plot(x, col=colors, pch=20)

par(op)
-------------------------------------------------------------------------------------------------------
layout(1:2) plot(A)    
plot(B)
-------------------------------------------------------------------------------------------------------
arrange() grid.arrange() vp.layout <- function(x, y) viewport(layout.pos.row=x, layout.pos.col=y)
arrange <- function(..., nrow=NULL, ncol=NULL, as.table=FALSE) {
 dots <- list(...)
 n <- length(dots)
 if(is.null(nrow) & is.null(ncol)) { nrow = floor(n/2) ; ncol = ceiling(n/nrow)}
 if(is.null(nrow)) { nrow = ceiling(n/ncol)}
 if(is.null(ncol)) { ncol = ceiling(n/nrow)}
        ## NOTE see n2mfrow in grDevices for possible alternative
grid.newpage()
pushViewport(viewport(layout=grid.layout(nrow,ncol) ) )
 ii.p <- 1
 for(ii.row in seq(1, nrow)){
 ii.table.row <- ii.row 
 if(as.table) {ii.table.row <- nrow - ii.table.row + 1}
  for(ii.col in seq(1, ncol)){
   ii.table <- ii.p
   if(ii.p > n) break
   print(dots[[ii.table]], vp=vp.layout(ii.table.row, ii.col))
   ii.p <- ii.p + 1
  }
 }
}
-------------------------------------------------------------------------------------------------------
library(gWidgets)
options(guiToolkit="tcltk") ## or RGtk2 or Qt

w <- gwindow("Multiple comboboxes")
tbl <- glayout(cont=w, horizontal=FALSE)

fruit <- c("Apple","Orange","Banana","Pear")


tbl[1,1] <- "Favorite fuits"
tbl[1,2] <- (cb1 <- gcombobox(fruit, cont=tbl))

tbl[2,1] <- "Other fruit?"
tbl[2,2] <- (cb2 <- gcombobox(fruit, cont=tbl))

tbl[3,2] <- (b <- gbutton("Ok", cont=tbl))

addHandlerClicked(b, handler=function(h,...) {
  cat(sprintf("You picked %s and %s\n", svalue(cb1), svalue(cb2)))
})
-------------------------------------------------------------------------------------------------------
layout() 1 2
3 4
5 6
7 8 par
-------------------------------------------------------------------------------------------------------
par(mfrow=c(rows,columns)) rows columns layout(mat) mat matrix(c(1,2,3,4)) ?par ?layout
-------------------------------------------------------------------------------------------------------
jpeg(filename="somefile.jpg")
op <- par(mfrow=c(2,2)
#plot the plots you want
par(op)
dev.off() layout(matrix(1:4,nrow=2) par(mfcol=c(2,2)) layout(matrix(c(1,4,3,2),ncol=2)) main
-------------------------------------------------------------------------------------------------------
align.plots <- function(..., vertical=TRUE){
#http://ggextra.googlecode.com/svn/trunk/R/align.r
  dots <- list(...)
  dots <- lapply(dots, ggplotGrob)
  ytitles <- lapply(dots, function(.g) editGrob(getGrob(.g,"axis.title.y.text",grep=TRUE), vp=NULL))
  ylabels <- lapply(dots, function(.g) editGrob(getGrob(.g,"axis.text.y.text",grep=TRUE), vp=NULL))
  legends <- lapply(dots, function(.g) if(!is.null(.g$children$legends))
                    editGrob(.g$children$legends, vp=NULL) else ggplot2:::.zeroGrob)

  gl <- grid.layout(nrow=length(dots))
  vp <- viewport(layout=gl)
  pushViewport(vp)
  widths.left <- mapply(`+`, e1=lapply(ytitles, grobWidth),
                        e2= lapply(ylabels, grobWidth), SIMPLIFY=F)
  widths.right <- lapply(legends, function(g) grobWidth(g) + if(is.zero(g)) unit(0, "lines") else unit(0.5, "lines")) # safe margin recently added to ggplot2
  widths.left.max <- max(do.call(unit.c, widths.left))
  widths.right.max <- max(do.call(unit.c, widths.right))

  for(ii in seq_along(dots)){
    pushViewport(viewport(layout.pos.row=ii))
    pushViewport(viewport(x=unit(0, "npc") + widths.left.max - widths.left[[ii]],
                          width=unit(1, "npc") - widths.left.max + widths.left[[ii]] -
                                                 widths.right.max + widths.right[[ii]],
                          just="left"))
    grid.draw(dots[[ii]])
  upViewport(2)
  }
}



p <- ggplot(datapoly[datapoly$variable=="val1",], aes(x=x, y=y)) + geom_polygon(aes(fill=value, group=id),colour="black")
p1 <- ggplot(datapoly[datapoly$variable=="val2",], aes(x=x, y=y)) + geom_polygon(aes(fill=value, group=id),colour="black")
align.plots( p,p1)
-------------------------------------------------------------------------------------------------------
build_legend <- function(name, mapping, layers, default_mapping, theme) {
  legend_data <- plyr::llply(layers, build_legend_data, mapping, default_mapping)

  # determine if the elements are aligned horizontally or vertically
  horiz<-(!is.null(theme$legend.align) && theme$legend.align=="horizontal")

  # Calculate sizes for keys - mainly for v. large points and lines
  size_mat <- do.call("cbind", plyr::llply(legend_data, "[[", "size"))
  if (is.null(size_mat)) {
    key_sizes <- rep(0, nrow(mapping))
  } else {
    key_sizes <- apply(size_mat, 1, max)
  }

  title <- theme_render(
    theme, "legend.title",
    name, x = 0, y = 0.5
  )

                                        # Compute heights and widths of legend table
  nkeys <- nrow(mapping)
  hgap <- vgap <- unit(0.3, "lines")

  numeric_labels <- all(sapply(mapping$.label, is.language)) || suppressWarnings(all(!is.na(sapply(mapping$.label, "as.numeric"))))
  hpos <- numeric_labels * 1

  labels <- lapply(mapping$.label, function(label) {
    theme_render(theme, "legend.text", label, hjust = hpos, x = hpos, y = 0.5)
  })

  # align horizontally
  if(!horiz){
    label_width <- do.call("max", lapply(labels, grobWidth))
    label_width <- convertWidth(label_width, "cm")
    label_heights <- do.call("unit.c", lapply(labels, grobHeight))
    label_heights <- convertHeight(label_heights, "cm")

    width <- max(unlist(plyr::llply(legend_data, "[[", "size")), 0)
    key_width <- max(theme$legend.key.size, unit(width, "mm"))

    widths <- unit.c(
                     hgap, key_width,
                     hgap, label_width,
                     max(
                         unit(1, "grobwidth", title) - key_width - label_width,
                         hgap
                         )
                     )
    widths <- convertWidth(widths, "cm")

    heights <- unit.c(
                      vgap, 
                      unit(1, "grobheight", title),
                      vgap, 
                      unit.pmax(
                                theme$legend.key.size, 
                                label_heights, 
                                unit(key_sizes, "mm")
                                ),
                      vgap
                      )  
    heights <- convertHeight(heights, "cm")

  }else{
    label_width <- do.call("unit.c", lapply(labels, grobWidth))
    label_width <- convertWidth(label_width, "cm")
    label_heights <- do.call("max", lapply(labels, grobHeight))
    label_heights <- convertHeight(label_heights, "cm")

    height <- max(unlist(plyr::llply(legend_data, "[[", "size")), 0)
    key_heights <- max(theme$legend.key.size, unit(height, "mm"))

    key_width <- unit.pmax(theme$legend.key.size, unit(key_sizes, "mm"))
    # width of (key gap label gap) x nkeys
    kglg_width<-do.call("unit.c",lapply(1:length(key_width), function(i)unit.c(key_width[i], hgap, label_width[i], hgap)))
    widths <- unit.c(
                      hgap,
                      kglg_width,
                      max(
                          unit(0,"lines"),
                          unit.c(unit(1, "grobwidth", title) - (sum(kglg_width) - hgap))
                          )
                      )
    widths <- convertWidth(widths, "cm")

    heights <- unit.c(
                       vgap, 
                       unit(1, "grobheight", title),
                       vgap, 
                       max(
                           theme$legend.key.size,
                           label_heights, 
                           key_heights
                           ),
                       vgap
                       )  
  heights <- convertHeight(heights, "cm")

  }

  # Layout the legend table
  legend.layout <- grid.layout(
    length(heights), length(widths), 
    widths = widths, heights = heights, 
    just = c("left", "centre")
  )

  fg <- ggname("legend", frameGrob(layout = legend.layout))
  fg <- placeGrob(fg, theme_render(theme, "legend.background"))

  fg <- placeGrob(fg, title, col = 2:(length(widths)-1), row = 2)
  for (i in 1:nkeys) {

    if(!horiz){
      fg <- placeGrob(fg, theme_render(theme, "legend.key"), col = 2, row = i+3)
    }else{
      fg <- placeGrob(fg, theme_render(theme, "legend.key"), col = 1+(i*4)-3, row = 4)
    }

    for(j in seq_along(layers)) {
      if (!is.null(legend_data[[j]])) {
        legend_geom <- Geom$find(layers[[j]]$geom$guide_geom())
        key <- legend_geom$draw_legend(legend_data[[j]][i, ],
           c(layers[[j]]$geom_params, layers[[j]]$stat_params))
        if(!horiz){
          fg <- placeGrob(fg, ggname("key", key), col = 2, row = i+3)
        }else{
          fg <- placeGrob(fg, ggname("key", key), col = 1+(i*4)-3, row = 4)
        }
      }
    }
    label <- theme_render(
      theme, "legend.text", 
      mapping$.label[[i]], hjust = hpos,
      x = hpos, y = 0.5
    )
    if(!horiz){
      fg <- placeGrob(fg, label, col = 4, row = i+3)
    }else{
      fg <- placeGrob(fg, label, col = 1+(i*4)-1, row = 4)
    }
  }
  fg
}

assignInNamespace("build_legend", build_legend, "ggplot2")

# test and usage
# specify by opts(legend.align="horizontal")
p1<-qplot(mpg, wt, data=mtcars, colour=cyl)+opts(legend.align="horizontal",legend.position="bottom")
p2<-qplot(mpg, wt, data=mtcars, colour=cyl)
-------------------------------------------------------------------------------------------------------
layout() legend()
-------------------------------------------------------------------------------------------------------
layout(matrix(c(1,2), nrow = 1), widths = c(0.7, 0.3))
par(mar = c(5, 4, 4, 2) + 0.1)
plot(1:3, rnorm(3), pch = 1, lty = 1, type = "o", ylim=c(-2,2))
lines(1:3, rnorm(3), pch = 2, lty = 2, type="o")
par(mar = c(5, 0, 4, 2) + 0.1)
plot(1:3, rnorm(3), pch = 1, lty = 1, ylim=c(-2,2), type = "n", axes = FALSE, ann = FALSE)
legend(1, 1, c("group A", "group B"), pch = c(1,2), lty = c(1,2))
-------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------
import random 
import networkx as nx
z=[int(random.gammavariate(alpha=9.0,beta=2.0)) for i in range(100)]
G=nx.configuration_model(z) Notes
-----
As described by Newman [1]_.

A non-graphical degree sequence (not realizable by some simple
graph) is allowed since this function returns graphs with self
loops and parallel edges.  An exception is raised if the degree
sequence does not have an even sum.

This configuration model construction process can lead to
duplicate edges and loops.  You can remove the self-loops and
parallel edges (see below) which will likely result in a graph
that doesn't have the exact degree sequence specified.  This
"finite-size effect" decreases as the size of the graph increases.

References
----------
.. [1] M.E.J. Newman, "The structure and function
       of complex networks", SIAM REVIEW 45-2, pp 167-256, 2003.

Examples
--------
>>> from networkx.utils import powerlaw_sequence
>>> z=nx.create_degree_sequence(100,powerlaw_sequence)
>>> G=nx.configuration_model(z)

To remove parallel edges:

>>> G=nx.Graph(G)

To remove self loops:

>>> G.remove_edges_from(G.selfloop_edges()) #!/usr/bin/env python
import random
import matplotlib.pyplot as plt
import networkx as nx

def seq(n):
    return [random.gammavariate(alpha=2.0,beta=1.0) for i in range(100)]    
z=nx.create_degree_sequence(100,seq)
nx.is_valid_degree_sequence(z)
G=nx.configuration_model(z)  # configuration model

degree_sequence=sorted(nx.degree(G).values(),reverse=True) # degree sequence
print "Degree sequence", degree_sequence
dmax=max(degree_sequence)

plt.hist(degree_sequence,bins=dmax)
plt.title("Degree histogram")
plt.ylabel("count")
plt.xlabel("degree")

# draw graph in inset 
plt.axes([0.45,0.45,0.45,0.45])
Gcc=nx.connected_component_subgraphs(G)[0]
pos=nx.spring_layout(Gcc)
plt.axis('off')
nx.draw_networkx_nodes(Gcc,pos,node_size=20)
nx.draw_networkx_edges(Gcc,pos,alpha=0.4)

plt.savefig("degree_histogram.png")
plt.show()
-------------------------------------------------------------------------------------------------------
grid.newpage()
pushViewport(viewport(layout=grid.layout(2, 2)))
grid.rect(gp=gpar(fill=1),vp=viewport(layout.pos.col=1,layout.pos.row=1))
grid.rect(gp=gpar(fill=2),vp=viewport(layout.pos.col=1,layout.pos.row=2))
grid.rect(gp=gpar(fill=3),vp=viewport(layout.pos.col=2,layout.pos.row=1))
grid.rect(gp=gpar(fill=4),vp=viewport(layout.pos.col=2,layout.pos.row=2))

pushViewport(viewport(x=unit(0.5, "npc"), width=unit(0.5, "npc"), 
  y=unit(0.75, "npc"), height=unit(0.5, "npc")))
grid.rect(gp=gpar(fill="white")) vpvp <- function(pos.col, pos.row){
  cvp <- current.viewport()
  nrow <- cvp$layout$nrow
  ncol <- cvp$layout$ncol
  w <- unit(1/ncol, "npc")
  h <- unit(1/nrow, "npc")
  x <- unit((pos.col-0.5)/ncol, "npc")
  y <- unit(1-(pos.row-0.5)/nrow, "npc")
  viewport(x=x, y=y, width=w, height=h)
}

grid.newpage()
pushViewport(viewport(layout=grid.layout(2, 3)))
grid.rect(gp=gpar(fill=1),vp=viewport(layout.pos.col=1,layout.pos.row=1))
grid.rect(gp=gpar(fill=2),vp=viewport(layout.pos.col=1,layout.pos.row=2))
grid.rect(gp=gpar(fill=3),vp=viewport(layout.pos.col=2,layout.pos.row=1))
grid.rect(gp=gpar(fill=4),vp=viewport(layout.pos.col=2,layout.pos.row=2))
grid.rect(gp=gpar(fill=5),vp=viewport(layout.pos.col=3,layout.pos.row=1))
grid.rect(gp=gpar(fill=6),vp=viewport(layout.pos.col=3,layout.pos.row=2))

pushViewport(vpvp(pos.col=2.5, pos.row=1.5))
grid.rect(gp=gpar(fill="white"))
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(ggExtra) # from R-forge

p1 <- qplot(x = 1, y = mpg, data = mtcars, xlab = "", geom = 'boxplot') + 
  coord_flip(ylim=c(10,35), wise=TRUE)
p2 <- qplot(x = mpg, data = mtcars, geom = 'histogram') + 
  coord_cartesian(xlim=c(10,35), wise=TRUE)

align.plots(p1, p2) align.plots2 <- function (..., vertical = TRUE, pos = NULL) 
{
    dots <- list(...)
    if (is.null(pos)) pos <- lapply(seq(dots), I)
    dots <- lapply(dots, ggplotGrob)
    ytitles <- lapply(dots, function(.g) editGrob(getGrob(.g, 
        "axis.title.y.text", grep = TRUE), vp = NULL))
    ylabels <- lapply(dots, function(.g) editGrob(getGrob(.g, 
        "axis.text.y.text", grep = TRUE), vp = NULL))
    legends <- lapply(dots, function(.g) if (!is.null(.g$children$legends)) 
        editGrob(.g$children$legends, vp = NULL)
    else ggplot2:::.zeroGrob)
    gl <- grid.layout(nrow = do.call(max,pos))
    vp <- viewport(layout = gl)
    pushViewport(vp)
    widths.left <- mapply(`+`, e1 = lapply(ytitles, grobWidth), 
        e2 = lapply(ylabels, grobWidth), SIMPLIFY = F)
    widths.right <- lapply(legends, function(g) grobWidth(g) + 
        if (is.zero(g)) 
            unit(0, "lines")
        else unit(0.5, "lines"))
    widths.left.max <- max(do.call(unit.c, widths.left))
    widths.right.max <- max(do.call(unit.c, widths.right))
    for (ii in seq_along(dots)) {
        pushViewport(viewport(layout.pos.row = pos[[ii]]))
        pushViewport(viewport(x = unit(0, "npc") + widths.left.max - 
            widths.left[[ii]], width = unit(1, "npc") - widths.left.max + 
            widths.left[[ii]] - widths.right.max + widths.right[[ii]], 
            just = "left"))
        grid.draw(dots[[ii]])
        upViewport(2)
    }
} # 5 rows, with 1 for p1 and 2-5 for p2
align.plots2(p1, p2, pos=list(1,2:5))
# 5 rows, with 1-2 for p1 and 3-5 for p2
align.plots2(p1, p2, pos=list(1:2,3:5))
-------------------------------------------------------------------------------------------------------
ggplot2 coord_flip require(ggplot2)
df <- data.frame(Type = sample(c('Male', 'Female', 'Female'), 1000, replace=TRUE),
                 Age = sample(18:60, 1000, replace=TRUE))

AgesFactor <- ordered( cut(df$Age, breaks = c(18,seq(20,60,5)), 
                           include.lowest = TRUE))

df$Age <- AgesFactor gg <- ggplot(data = df, aes(x=Age))

gg.male <- gg + 
  geom_bar( subset = .(Type == 'Male'), 
            aes( y = ..count../sum(..count..), fill = Age)) +
  scale_y_continuous('', formatter = 'percent') + 
  opts(legend.position = 'none') +
  opts(axis.text.y = theme_blank(), axis.title.y = theme_blank()) + 
  opts(title = 'Male', plot.title = theme_text( size = 10) ) +  
  coord_flip() trans = "reverse" gg.female <- gg + 
  geom_bar( subset = .(Type == 'Female'), 
            aes( y = ..count../sum(..count..), fill = Age)) +
  scale_y_continuous('', formatter = 'percent', trans = 'reverse') + 
  opts(legend.position = 'none') +
  opts(axis.text.y = theme_blank(), 
       axis.title.y = theme_blank(), 
       title = 'Female') +
  opts( plot.title = theme_text( size = 10) ) +
  coord_flip() geom_text geom_bar gg.ages <- gg + 
  geom_bar( subset = .(Type == 'Male'), aes( y = 0, fill = alpha('white',0))) +
  geom_text( aes( y = 0,  label = as.character(Age)), size = 3) +
  coord_flip() +
  opts(title = 'Ages',
       legend.position = 'none' ,
       axis.text.y = theme_blank(),
       axis.title.y = theme_blank(),
       axis.text.x = theme_blank(),
       axis.ticks = theme_blank(),          
       plot.title = theme_text( size = 10)) grid.newpage()

pushViewport( viewport( layout = grid.layout(1,3, widths = c(.4,.2,.4))))

vplayout <- function(x, y) viewport(layout.pos.row = x, layout.pos.col = y)

print(gg.female, vp = vplayout(1,1))
print(gg.ages,   vp = vplayout(1,2))
print(gg.male,   vp = vplayout(1,3))
-------------------------------------------------------------------------------------------------------
seriation set.seed(1)
dat <- data.frame(A = c(rnorm(10, 2), rnorm(10, -2), rnorm(10, -2)),
                  B = c(rnorm(10, 0), rnorm(10, 5), rnorm(10, -2)),
                  C = c(rnorm(10, 0), rnorm(10, 0), rnorm(10, -10)))

## randomise the rows
dat <- dat[sample(nrow(dat)),]
clus <- kmeans(scale(dat, scale = FALSE), centers = 3, iter.max = 50,
               nstart = 10)

## means of n points in each cluster
mns <- sapply(split(dat, clus$cluster), function(x) mean(unlist(x)))

## order the data by cluster with clusters ordered by `mns`, low to high
dat2 <- dat[order(order(mns)[clus$cluster]), ]

## heatmaps
## original first, then reordered:
layout(matrix(1:2, ncol = 2))
image(1:3, 1:30, t(data.matrix(dat)), ylab = "Observations", 
      xlab = "Variables", xaxt = "n", main = "Original")
axis(1, at = 1:3)
image(1:3, 1:30, t(data.matrix(dat2)), ylab = "Observations", 
      xlab = "Variables", xaxt = "n", main = "Reordered")
axis(1, at = 1:3)
layout(1)
-------------------------------------------------------------------------------------------------------
stime <- as.POSIXct("2011-01-01-00:00:00", format = "%Y-%d-%m-%H:%M:%S")
## dummy data
dat <- data.frame(Timestamp = seq(from = stime, by = 5, length = 2000000),
                  DD1 = sample(1:1000, replace = TRUE),
                  DD2 = sample(1:1000, replace = TRUE),
                  DD3 = sample(1:1000, replace = TRUE),
                  DD4 = sample(1:1000, replace = TRUE))
## write it out
write.csv(dat, file = "timestamp_data.txt", row.names = FALSE) "POSIXct" ## read it in:
system.time({
             tsdat <- read.csv("timestamp_data.txt", header = TRUE,
                                 colClasses = c("POSIXct",rep("integer", 4)))
            }) user  system elapsed 
 13.698   5.827  19.643 aggregate() ## Generate some indexes that we'll use the aggregate over
tsdat <- transform(tsdat,
                   hours   = factor(strftime(tsdat$Timestamp, format = "%H")),
                   jday    = factor(strftime(tsdat$Timestamp, format = "%j")))
## compute the mean of the 4 variables for each minute
out <- aggregate(cbind(Timestamp, DD1, DD2, DD3, DD4) ~ hours + jday, 
                 data = tsdat, FUN = mean)
## convert average Timestamp to a POSIX time
out <- transform(out,
                 Timestamp = as.POSIXct(Timestamp, 
                                        origin = ISOdatetime(1970,1,1,0,0,0))) out > head(out)
  hours jday           Timestamp      DD1      DD2      DD3      DD4
1    00  001 2010-12-31 23:29:57 500.2125 491.4333 510.7181 500.4833
2    01  001 2011-01-01 00:29:57 516.0472 506.1264 519.0931 494.2847
3    02  001 2011-01-01 01:29:57 507.5653 499.4972 498.9653 509.1389
4    03  001 2011-01-01 02:29:57 520.4111 500.8708 514.1514 491.0236
5    04  001 2011-01-01 03:29:57 498.3222 500.9139 513.3194 502.6514
6    05  001 2011-01-01 04:29:57 515.5792 497.1194 510.2431 496.8056 plot() plot(DD1 ~ Timestamp, data = out, type = "l") ylim <- with(out, range(DD1, DD2))
plot(DD1 ~ Timestamp, data = out, type = "l", ylim = ylim)
lines(DD2 ~ Timestamp, data = out, type = "l", col = "red") layout(1:2)
plot(DD1 ~ Timestamp, data = out, type = "l", col = "blue")
plot(DD2 ~ Timestamp, data = out, type = "l", col = "red")
layout(1)
-------------------------------------------------------------------------------------------------------
layout m <- matrix(c(1, 0, 1,  3, 2, 3, 2, 0), nrow = 2, ncol = 4)
##set up the plot
layout(m)
## now put out the 3 plots to each layout "panel"
plot(1:10, main = "plot1")
plot(10:1, main = "plot2")
plot(rnorm(10), main = "plot3") layout.show m
      [,1] [,2] [,3] [,4]
 [1,]    1    1    2    2
 [2,]    0    3    3    0
-------------------------------------------------------------------------------------------------------
layout R> layout(matrix(c(1,2,3,3), 2, 2, byrow = TRUE))
R> plot(rnorm(100),col=1)
R> plot(rnorm(100),col=2)
R> plot(rnorm(100),col=3) R> layout(matrix(c(1,3,2,3), 2, 2, byrow = TRUE))
R> plot(rnorm(100),col=1)
R> plot(rnorm(100),col=2)
R> plot(rnorm(100),col=3)
-------------------------------------------------------------------------------------------------------
library(lattice)
histogram(~x2|equal.count(x1),data=frame) shingle equal.count par(mfrow=c(2,1))
hist(x2)
boxplot(x2) layout()
-------------------------------------------------------------------------------------------------------
deSolve deSolve layout(matrix(c(1, 1, 2, 2), 2, 2, byrow = TRUE))
plot(df2, type="l", which = "y1", ylab = "x", xlab = "t", main = "(a)", mfrow = c(2, 1))
plot(t, x, type = "l", main = "(b)")
-------------------------------------------------------------------------------------------------------
d1 <- read.csv(url("http://misterdavis.org/r_wiki/r_results_1231_2010"))
lpp_axis1 <- with(d1, data.frame("Compile Source Code" = Q3A.1,
                                 "View Source Code" = Q3A.2,
                                 "Change Source Code" = Q3A.3, 
                                 "Write Documentation" = Q3A.8, 
                                 "File Bug Reports"= Q3B.3,
                                 "Ask Questions" = Q3B.5,
                                 "Provide Answers" = Q3B.6,
                                 "Overall Participation" = Q3a3bConsolidated))

lpp_axis2 <- with(d1, data.frame("Identification" = Q1,
                                 "Overall Learning" = Q6Consolidated,  
                                 "Learning Programming" = Q6.1,
                                 "Learning about Computers" = Q6.2, 
                                 "Learning Teamwork" =  Q6.3))

corrplot(cor(lpp_axis1, lpp_axis2), method=c("number"), bg = "grey10",
         addgrid.col = "gray50", tl.cex=1,
         tl.col = "black", 
         col = colorRampPalette(c("yellow","green","navyblue"))(100))
dev.new()
corrplot(cor(lpp_axis1, lpp_axis2), method=c("number"), bg = "grey10",
         addgrid.col = "gray50", tl.cex=2,
         tl.col = "black", 
         col = colorRampPalette(c("yellow","green","navyblue"))(100)) dev.new() tl.offset tl.cex = 1 tl.cex = 2 tl.cex tl.offset packageDescription() R> packageDescription("corrplot")
Package: corrplot
Type: Package
Title: visualization of a correlation matrix
Version: 0.30
Date: 2010-05-30
Author: Taiyun Wei
Suggests: seriation, cairoDevice, Cairo,
Maintainer: Taiyun Wei <weitaiyun@gmail.com>
Description: The corrplot package is a graphical display of a
        correlation matrix, confidence interval. It also contains some
        algorithms to do matrix reordering.
License: GPL-2 | GPL-3
LazyLoad: yes
URL: http://corrplot.r-forge.r-project.org
Repository: CRAN
Repository/R-Forge/Project: corrplot
Repository/R-Forge/Revision: 45
Date/Publication: 2010-05-31 07:44:14
Packaged: 2010-05-30 20:39:16 UTC; rforge
Built: R 2.13.0; ; 2011-04-01 12:33:21 UTC; unix require(corrplot)
data(mtcars)
corr <- cor(mtcars)
corrplot(corr, method = "number", tl.cex = 2) tl.offset corrplot() tl.offset tl.offset layout(matrix(1:2, ncol = 2))
corrplot(corr, method = "number", tl.cex = 2, tl.offset = 3)
corrplot(corr, method = "number", tl.cex = 2)
layout(1) pdf() png() corrplot() tl.cex = 2 corrplot(corr, method = "number", tl.cex = 4) tl.cex corrplot(corr, method = "number", tl.cex = 0.8)
-------------------------------------------------------------------------------------------------------
l <-layout.reingold.tilford(g) 
 l
     [,1] [,2]
[1,]    0    0
[2,]   -1    3
[3,]    0    1
[4,]    0    3
[5,]    0    2
[6,]    0    4
[7,]    1    3 plot.igraph(g, 
  vertex.label = V(g)$name, vertex.label.color = "gray20",
  vertex.size = ideg*25 + 40, vertex.size2 = 30,
  vertex.color = "gray90", vertex.frame.color = "gray20",
  vertex.shape = "rectangle",
  edge.arrow.size=0.5, edge.color=col, edge.width = E(g)$weight / 10,
  edge.curved = T, 
  layout = l) params root l <- layout.reingold.tilford(g,params=list(root=2)) RGraphViz gridLayout <- function(x)
{
    LmatX <- seq(-1,1,length=ncol(x))
    LmatY <- seq(1,-1,length=nrow(x))

    loc <- t(sapply(1:max(x),function(y)which(x==y,arr.ind=T)))
    layout <- cbind(LmatX[loc[,2]],LmatY[loc[,1]])
    return(layout)
} layout() grid <- matrix(c(
    0,0,1,0,0,
    2,0,3,0,4),nrow=2,byrow=TRUE)

library("igraph")

g <- graph.adjacency(matrix(1,4,4))

plot(g,layout=gridLayout(L))
-------------------------------------------------------------------------------------------------------
#Build the data
 t <- 1:1000
 x1 <- 100 * sin(0.01 * t)
 x2 <- 200 * cos(0.04 * t)

 #Set up the plot area for two "crammed" plots
 par(pty="m", plt=c(0.1, 1, 0, 1), omd=c(0.1,0.9,0.1,0.9))
 par(mfrow = c(2, 1))

 #Plot x1 and x2 together
 plot(t, x1, type="l", ylim = 1.5 * range(x1, x2), xaxt="n", xlab="", ylab="", main="", col="blue", las=2)
 lines(t, x2, lwd=1, col="red")
 mtext(side=2, "Top Plot", line=5.3, cex=0.8)
 mtext(side=2, "(units)", line=4, cex=0.8)
 grid()
 mtext(side=3, "2 Plots Crammed Together", line=1.5, cex=1.2)
 legend("topright", legend=c("100 * sin(0.01 * t)", "200 * cos(0.4 * t)"), bg="white", lwd=c(1, 1), col=c("blue", "red"), cex=0.9)

 #Place the 1st x-axis
 axis(side = 1, col="blue", col.axis="blue")
 linloc <- par()$usr[3]
 abline(h=linloc, col="blue")
 mtext(side=1, "First X-Axis", line=2.5, cex=0.8, col="blue")

 #Place the fake 2nd x-axis
 xaxis2 <- 1:10
 par(plt=c(0.1,1,0.6,1))
 plot(xaxis2, type="n", xaxt="n", xlab="", yaxt="n", ylab="", xlim=range(xaxis2), bty="n")
 axis(side = 1, col="red", col.axis="red")
 linloc <- par()$usr[3]
 abline(h=linloc, col="red")
 mtext(side=1, "Second X-Axis", line=2.5, cex=0.8, col="red")
-------------------------------------------------------------------------------------------------------
require(MASS)
set.seed(1)
dat <- data.frame(mvrnorm(100, mu = c(2,6,3), 
                          Sigma = matrix(c(10,   2,   4,
                                            2,   3, 0.5,
                                            4, 0.5,   2), ncol = 3))) dij <- dist(scale(dat, center = TRUE, scale = TRUE)) clust <- hclust(dij, method = "average") ord <- order(cutree(clust, k = 3)) coph <- cophenetic(clust) layout(matrix(1:4, ncol = 2))
image(as.matrix(dij)[ord, ord], main = "Original distances")
image(as.matrix(coph)[ord, ord], main = "Cophenetic distances")
image((as.matrix(coph) - as.matrix(dij))[ord, ord], 
      main = "Cophenetic - Original")
plot(coph ~ dij, ylab = "Cophenetic distances", xlab = "Original distances",
     main = "Shepard Plot")
abline(0,1, col = "red")
box()
layout(1)
-------------------------------------------------------------------------------------------------------
plt ?par ‘plt’ A vector of the form ‘c(x1, x2, y1, y2)’ giving the
      coordinates of the plot region as fractions of the current
      figure region. par(plt=c(1, 1, 1, 1)) op <- par(mar = rep(0, 4))
plot(1:10)
par(op) oma plt > par("plt")
[1] 0.1173174 0.9399106 0.1457273 0.8828467
> op <- par(mar = rep(0, 4))
> par("plt")
[1] 0 1 0 1
> par(op)
> par("plt")
[1] 0.1173174 0.9399106 0.1457273 0.8828467 x y xaxs yaxs ?par set.seed(1)
dat <- matrix(rnorm(100*100), ncol = 100, nrow = 100)

layout(matrix(1:2, ncol = 2))
image(dat)
op <- par(mar = rep(0, 4))
image(dat)
par(op)
layout(1)
-------------------------------------------------------------------------------------------------------
Rowv Colv NA heatmap(as.matrix(df)[order(k$cluster),],Rowv=NA,Colv=NA,scale="none",labRow=NA) image() image myHeatmap <- function(x,ord,xlab="",ylab="",main="My Heatmap",
                      col=heat.colors(5), ...){
    op <- par(mar=c(3,0,2,0)+0.1)
    on.exit(par(op))
    nc <- NCOL(x)
    nr <- NROW(x)
    labCol <- names(x)

    x <- t(x[ord,])
    image(1L:nc, 1L:nr, x, xlim = 0.5 + c(0, nc), ylim = 0.5 +
        c(0, nr), axes = FALSE, xlab=xlab, ylab=ylab, main=main,
        col=col,...)

    axis(1, 1L:nc, labels = labCol, las = 2, line = -0.5, tick = 0)
    axis(2, 1L:nr, labels = NA, las = 2, line = -0.5, tick = 0)
}

library(RColorBrewer)
myHeatmap(df,order(k$cluster),col=brewer.pal(5,"BuGn")) RColorBrewer
-------------------------------------------------------------------------------------------------------
X Y Z ## Your data
dat <- data.frame(X = factor(rep(LETTERS[1:4], times = c(10,20,30,40)), 
                             levels = LETTERS[1:4]),
                  Y = factor(rep(LETTERS[1:4], times = c(20,30,40,10)),
                             levels = LETTERS[c(4,1:3)]),
                  Z = factor(rep(LETTERS[1:4], times = c(30,40,10,20)),
                             levels = LETTERS[c(3:4,1:2)])) scale_fill_manual() dat n p1 <- ggplot(dat, aes(x = factor(1), fill = factor(X))) + 
          geom_bar(width = 1) + coord_polar(theta = "y") +
          scale_fill_manual(value = c("red","green","yellow","blue"))
p2 <- ggplot(dat, aes(x = factor(1), fill = factor(Y))) + 
          geom_bar(width = 1) + coord_polar(theta = "y") +
          scale_fill_manual(value = c("red","green","yellow","blue")[c(4,1:3)])
p3 <- ggplot(dat, aes(x = factor(1), fill = factor(Z))) + 
          geom_bar(width = 1) + coord_polar(theta = "y") +
          scale_fill_manual(value = c("red","green","yellow","blue")[c(3:4,1:2)]) grid.newpage()
pushViewport(viewport(layout = grid.layout(2,2))) vplayout <- function(x, y) {
    viewport(layout.pos.row = x, layout.pos.col = y)
} vp print(p1, vp = vplayout(1,1))
print(p2, vp = vplayout(1,2))
print(p3, vp = vplayout(2,1))
-------------------------------------------------------------------------------------------------------
grid.layout() label <- textGrob("A page number! ", x=0.5, y = 1.0, just="centre")
x <- seq(0.1, 0.9, length=50)
y <- runif(50, 0.1, 0.9)
gplot <- 
  gTree(
    children=gList(rectGrob(gp=gpar(col="grey60",
                                    fill="white")),
                   linesGrob(x, y), 
                   pointsGrob(x, y, pch=16, 
                              size=unit(1.5, "mm"))),
    vp=viewport(width=unit(1, "npc") - unit(5, "mm"), 
                height=unit(1, "npc") - unit(10, "mm")))



layout <- grid.layout(2, 1,widths=unit(c(1, 1), c("null", "grobwidth"),list(NULL, label)),heights = unit(c(1, 1),c("null", "grobheight"),list(NULL, label)))

grid.rect(gp=gpar(col="grey60", fill="grey90"))
pushViewport(viewport(layout=layout))
pushViewport(viewport(layout.pos.row=2))
grid.draw(label)
popViewport()
pushViewport(viewport(layout.pos.col=1))
grid.draw(gplot)
popViewport(2)
-------------------------------------------------------------------------------------------------------
mtext() op <- par(oma = c(2,0,0,0))
layout(matrix(1:4, ncol = 2))
plot(1:10)
plot(1:10)
plot(1:10)
plot(1:10)
mtext(side = 1, text = "Page 1", outer = TRUE)
layout(1)
par(op) > mtext(side = 1, text = "Page 1")
Error in mtext(side = 1, text = "Page 1") : 
  plot.new has not been called yet require(ggplot2)
p1 <- ggplot(data.frame(X = 1:10, Y = runif(10)), aes(x = X, y = Y)) + 
        geom_point()
vplayout <- function(x, y) {
    viewport(layout.pos.row = x, layout.pos.col = y)
}
grid.newpage()
pushViewport(viewport(layout = grid.layout(2, 2)))
print(p1, vp = vplayout(1,1))
print(p1, vp = vplayout(1,2))
print(p1, vp = vplayout(2,1))
print(p1, vp = vplayout(2,2))
mtext(side = 1, text = "Page 1")
-------------------------------------------------------------------------------------------------------
set.seed(1)
dat2 <- data.frame(fac = factor(sample(LETTERS, 100, replace = TRUE)))
hist(table(dat2), xlab = "Frequency of Level Occurrence", main = "") hist() table(dat) table(dat) hist() dat <- data.frame(fac = rep(LETTERS[1:4], times = c(3,3,1,5))) "table" layout(matrix(1:4, ncol = 2))
plot(table(dat), main = "plot method for class \"table\"")
barplot(table(dat), main = "barplot")
tab <- as.numeric(table(dat))
names(tab) <- names(table(dat))
dotchart(tab, main = "dotchart or dotplot")
## or just this
## dotchart(table(dat))
## and ignore the warning
layout(1) factor table(factor) table(dat) table(dat$fac) lattice require(lattice)
with(dat, dotplot(fac, horizontal = FALSE)) ggplot2 require(ggplot2)
p <- ggplot(data.frame(Freq = tab, fac = names(tab)), aes(fac, Freq)) + 
    geom_point()
p
-------------------------------------------------------------------------------------------------------
\documentclass{article}
\usepackage{Sweave}
\usepackage{tikz}
<<echo=FALSE,results=hide>>=
  require(tikzDevice)
@

\begin{document}

\begin{figure}
<<echo=FALSE,results=hide>>=
  # Standard LaTeX article class has a \textwidth of ~4.5in
  # Therefore, divide by 2 to get the right height.
  tikz('layout-ex.tex', width = 4.5, height = 2.25)

  Layout<- matrix(c(1, 2), nrow = 1, ncol=2, byrow = TRUE)
  nf <- layout(mat = Layout, widths = c(1,1),heights = c(1,1), respect = TRUE)
  layout.show(nf)

  dev.off()
@

  \centering
  \input{layout-ex}
  \label{fig:layout-ex}
  \caption{A layout with two sub-figures}
\end{figure}

\end{document}
-------------------------------------------------------------------------------------------------------
arrange <- function(..., nrow=NULL, ncol=NULL, as.table=FALSE, 
                    main=NULL, sub=NULL, plot=TRUE) { 
  dots <- list(...) 
  n <- length(dots) 
  if(is.null(nrow) & is.null(ncol)) { nrow = floor(n/2) ; ncol = ceiling(n/nrow)} 
  if(is.null(nrow)) { nrow = ceiling(n/ncol)} 
  if(is.null(ncol)) { ncol = ceiling(n/nrow)} 
  fg <- frameGrob(layout=grid.layout(nrow,ncol)) 
  ii.p <- 1 
  for(ii.row in seq(1, nrow)){ 
    ii.table.row <- ii.row       
    if(as.table) {ii.table.row <- nrow - ii.table.row + 1} 
    for(ii.col in seq(1, ncol)){ 
      ii.table <- ii.p 
      if(ii.p > n) break 
      fg <- placeGrob(fg, ggplotGrob(dots[[ii.table]]), 
                      row=ii.table.row, col=ii.col) 
      ii.p <- ii.p + 1 
    } 
  } 
  if(!is.null(main) | !is.null(sub)){ 
    g <- frameGrob() # large frame to place title(s) and content 
    g <- packGrob(g, fg) 
    if (!is.null(main)) 
      g <- packGrob(g, textGrob(main), side="top") 
    if (!is.null(sub)) 
      g <- packGrob(g, textGrob(sub), side="bottom") 
  } else { 
    g <- fg 
  } 
  if(plot) grid.draw(g) 
  invisible(g) 
} 

library(ggplot2) 
plots <- llply(1:2, function(.x) qplot(1:10,rnorm(10), main=paste("plot",.x))) 
arrange(plots[[1]],plots[[2]], nrow=1, ncol = 2, as.table=TRUE, main="test main",   
        sub="subtitle test")
-------------------------------------------------------------------------------------------------------
p1 <- ggplot(diamonds, aes(price,depth)) + geom_point()
p2 <- ggplot(diamonds, aes(price,carat)) + geom_point()
p3 <- ggplot(diamonds, aes(x=1,y=1,label="Title")) + geom_text(size=20) + opts(panel.background=theme_blank(), panel.grid.minor=theme_blank(), panel.grid.major=theme_blank(), axis.text.x=theme_blank(), axis.text.y=theme_blank(), axis.ticks=theme_blank(), axis.title.x=theme_blank(), axis.title.y=theme_blank())
vplayout <- function(x, y) viewport(layout.pos.row=x, layout.pos.col=y)
grid.newpage()
pushViewport(viewport(layout=grid.layout(4,4)))
print(p1,vp=vplayout(2:4,1:2))
print(p2,vp=vplayout(2:4,3:4))
print(p3,vp=vplayout(1,1:4))
-------------------------------------------------------------------------------------------------------
grid library(lattice)
library(grid)
library(gridExtra)
res <- matrix(nc=3, nr=4)
for (i in 1:4) res[i,] <- tapply(iris[,i], iris[,5], mean)
colnames(res) <- levels(iris[,5])
rownames(res) <- colnames(iris)[1:4]
dp <- dotplot(res, auto.key=list(position="top", column=3), xlab="Mean")

pdf("1.pdf", width=10, height=5)
grid.newpage() 
pushViewport(viewport(layout=grid.layout(1, 2, widths=unit(c(5,4), "inches"))))

pushViewport(viewport(layout.pos.col=1, layout.pos.row=1)) 
print(dp, newpage=FALSE) 
popViewport(1)

pushViewport(viewport(layout.pos.col=2, layout.pos.row=1, clip="on"))
grid.draw(tableGrob(head(iris), gp=gpar(fontsize=6, lwd=.5)))
popViewport()
dev.off() ggplot2 gridExtra::grid.arrange() grid.newpage() 
pushViewport(viewport(layout=grid.layout(1, 1, widths=unit(c(5,4), "inches"))))

pushViewport(viewport(layout.pos.col=1, layout.pos.row=1)) 
print(dp, newpage=FALSE) 
popViewport(1)

pushViewport(viewport(x=0.5, y=0.3, clip="off"))
grid.draw(tableGrob(head(iris), padding.v=unit(1, "mm"), padding.h=unit(1, "mm"), 
          gp=gpar(fontsize=6, lwd=.5)))
popViewport() theme= tableGrob()
-------------------------------------------------------------------------------------------------------
plyr a_ply a_ply(t_weekmean, 3, function(arrayforcurweek){
allweek1<-(data.frame(arrayforcurweek)) #which selects the date and generates the data frame I want to later format the date using
week1<-stack(allweek1) #and then plot it using
plot(week1$values,type="n", xlim=c(0,2),xlab="Weight (gr)",ylab="Rate (umol/L*gr)",main="All individuals and Treatments at all times")
lines(week1$values[week1$ind=="X9"]~x,type="o",col="red")
lines(week1$values[week1$ind=="X12"]~x,type="o",col="blue")
lines(week1$values[week1$ind=="X15"]~x,type="o",col="green")
lines(week1$values[week1$ind=="X18"]~x,type="o",col="purple")
}) a_ply i t_weekmean[,,i]
-------------------------------------------------------------------------------------------------------
dev.cur() Rplots.pdf Rplot001.png layout par options(device="pdf")
layout(1:4)
dev.off()

options(device="png")
par()
dev.off()
-------------------------------------------------------------------------------------------------------
layout(matrix(seq(4), nrow=2))

chartSeries (GLD, subset="2010", TA = NULL, layout=NULL)               
chartSeries (SLV, subset="2010", TA = NULL, layout=NULL)               
chartSeries (TLT, subset="2010", TA = NULL, layout=NULL)               
chartSeries (GSR, subset="2010", TA = NULL, layout=NULL)
-------------------------------------------------------------------------------------------------------
?par ‘font’ An integer which specifies which font to use for text.  If
     possible, device drivers arrange so that 1 corresponds to
     plain text (the default), 2 to bold face, 3 to italic and 4
     to bold italic.  Also, font 5 is expected to be the symbol
     font, in Adobe symbol encoding.  On some devices font
     families can be selected by ‘family’ to choose different sets
     of 5 fonts. font.main > layout(1:2)
> plot(1:10, font.main = 1, main = "Foo") ## plain font
> plot(1:10, main = "Foo")                ## default bold font
> layout(1)
-------------------------------------------------------------------------------------------------------
layout(matrix(1:2, ncol = 1), widths = 1, heights = c(2,1.5), respect = FALSE)
par(mar = c(0, 4.1, 4.1, 2.1))
with(economics, plot(unemploy~date, type = 'l', xaxt = 'n', main = 'My Great Graph'))
par(mar = c(4.1, 4.1, 0, 2.1))
with(economics, plot(pop~date, type = 'l'))
-------------------------------------------------------------------------------------------------------
proxy::dist() simil() > dist(dfm, method='Pearson')
                                  Gawker Read/WriteWeb WWdN: In Exile ProBlogger Blog Tips Seth's Blog
Read/WriteWeb                  0.2662006                                                              
WWdN: In Exile                 0.2822594     0.2662006                                                
ProBlogger Blog Tips           0.2928932     0.5917517      0.6984887                                 
Seth's Blog                    0.2662006     0.2928932      0.4072510            0.2928932            
The Huffington Post | Raw Feed 0.1835034     0.2312939      0.2662006            0.2928932   0.2312939

> pr_simil2dist(simil(dfm, method = "pearson"))
                                  Gawker Read/WriteWeb WWdN: In Exile ProBlogger Blog Tips Seth's Blog
Read/WriteWeb                  0.2662006                                                              
WWdN: In Exile                 0.2822594     0.2662006                                                
ProBlogger Blog Tips           0.2928932     0.5917517      0.6984887                                 
Seth's Blog                    0.2662006     0.2928932      0.4072510            0.2928932            
The Huffington Post | Raw Feed 0.1835034     0.2312939      0.2662006            0.2928932   0.2312939 d1 <- dist(dfm, method='Pearson')
d2 <- pr_simil2dist(simil(dfm, method = "pearson"))
h1 <- hclust(d1)
h2 <- hclust(d2)
layout(matrix(1:2, ncol = 2))
plot(h1)
plot(h2)
layout(1)
all.equal(h1, h2) > all.equal(h1, h2)
[1] "Component 6: target, current do not match when deparsed" h1 h2 d1 d2 row.names read.table() dfm <- structure(list(china = c(0L, 2L, 0L, 0L, 0L, 0L), kids = c(1L, 
0L, 2L, 0L, 0L, 6L), music = c(0L, 1L, 4L, 0L, 1L, 0L), yahoo = c(0L, 
3L, 0L, 0L, 0L, 0L), want = c(7L, 1L, 0L, 2L, 3L, 14L), wrong = c(0L, 
1L, 0L, 0L, 1L, 5L)), .Names = c("china", "kids", "music", "yahoo", 
"want", "wrong"), class = "data.frame", row.names = c("Gawker", 
"Read/WriteWeb", "WWdN: In Exile", "ProBlogger Blog Tips", "Seth's Blog", 
"The Huffington Post | Raw Feed"))
-------------------------------------------------------------------------------------------------------
layout(matrix(c(1,2,5,6,3,4,7,8,9,10,13,14,11,12,15,16), 4, 4, byrow=TRUE))
replicate(16, hist(rnorm(100)))
par(xpd=NA)
rect( grconvertX(0.005, from='ndc'), grconvertY(0.505, from='ndc'),
     grconvertX(0.495, from='ndc'), grconvertY(0.995, from='ndc'))
rect( grconvertX(0.005, from='ndc'), grconvertY(0.005, from='ndc'),
     grconvertX(0.495, from='ndc'), grconvertY(0.495, from='ndc'))
rect( grconvertX(0.505, from='ndc'), grconvertY(0.505, from='ndc'),
     grconvertX(0.995, from='ndc'), grconvertY(0.995, from='ndc'))
rect( grconvertX(0.505, from='ndc'), grconvertY(0.005, from='ndc'),
     grconvertX(0.995, from='ndc'), grconvertY(0.495, from='ndc'))
-------------------------------------------------------------------------------------------------------
par layout par (fig=c(0,1,0,1), # Figure region in the device display region (x1,x2,y1,y2)
       omi=c(0,0,0.3,0), # global margins in inches (bottom, left, top, right)
       mai=c(0.1,0.1,0.3,0.1)) # subplot margins in inches (bottom, left, top, right)
  layout(matrix(1:4, 2, 2, byrow = TRUE))
-------------------------------------------------------------------------------------------------------
grid.raster library(gridplot)
row_layout(a, b, c) lattice ggplot2 scales guides gridExtra
-------------------------------------------------------------------------------------------------------
set.seed(2)
q1 <- ggplot(data.frame(x=rnorm(50)), aes(x)) + geom_density()
q2 <- ggplot(data.frame(x=rnorm(50)), aes(x)) + geom_density()
q3 <- ggplot(data.frame(x=rnorm(50)), aes(x)) + geom_density()
q4 <- ggplot(data.frame(x=rnorm(50)), aes(x)) + geom_density()

grid.newpage()
pushViewport(viewport(layout=grid.layout(2,2)))
vplayout <- function(x,y) viewport(layout.pos.row=x,layout.pos.col=y)
print(q1,vp=vplayout(1,1))
print(q2,vp=vplayout(1,2))
print(q3,vp=vplayout(2,1))
print(q4,vp=vplayout(2,2))
-------------------------------------------------------------------------------------------------------
grid.arrange gridExtra ggplot2 multiplot multiplot <- function(..., plotlist=NULL, cols) {
    require(grid)

    # Make a list from the ... arguments and plotlist
    plots <- c(list(...), plotlist)

    numPlots = length(plots)

    # Make the panel
    plotCols = cols                       # Number of columns of plots
    plotRows = ceiling(numPlots/plotCols) # Number of rows needed, calculated from # of cols

    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(plotRows, plotCols)))
    vplayout <- function(x, y)
        viewport(layout.pos.row = x, layout.pos.col = y)

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
        curRow = ceiling(i/plotCols)
        curCol = (i-1) %% plotCols + 1
        print(plots[[i]], vp = vplayout(curRow, curCol ))
    }

} set.seed(2)
q1 <- ggplot(data.frame(x=rnorm(50)), aes(x)) + geom_density()
q2 <- ggplot(data.frame(x=rnorm(50)), aes(x)) + geom_density()
q3 <- ggplot(data.frame(x=rnorm(50)), aes(x)) + geom_density()
q4 <- ggplot(data.frame(x=rnorm(50)), aes(x)) + geom_density()
q5 <- ggplot(data.frame(x=rnorm(50)), aes(x)) + geom_density()
q6 <- ggplot(data.frame(x=rnorm(50)), aes(x)) + geom_density()

multiplot(q1, q2, q3, q4, q5, q6, cols=2)
-------------------------------------------------------------------------------------------------------
library(gWidgets)
items <- data.frame(id=numeric(0), gender=character(0), age=numeric(0), race=character(0), stringsAsFactors=FALSE)
genders <- c("Male", "Female")
race <- c("Black", "Hispanic", "Other")

w <- gwindow("Capn's GUI", visible=FALSE)
g <- ggroup(cont=w, horizontal=FALSE)
lyt <- glayout(cont=g)
lyt[1,1] <- "Gender:"
lyt[1,2] <- gradio(genders, cont=lyt)

lyt[2,1] <- "Age:"
lyt[2,2] <- gedit("40", coerce.with=as.numeric, cont=lyt)

lyt[3,1] <- "Race:"
lyt[3,2] <- gcombobox(race, selected=0L, cont=lyt)

lyt[4,2] <- gbutton("Add", cont=lyt, handler=function(h,...) {
  vals <- lapply(lyt[1:3, 2], svalue)
  id <- nrow(items) + 1                 # or roll your own
  items[id, ] <<- c(id, vals)
  tbl[] <- items
})
gseparator(cont=g)
tbl <- gtable(items, cont=g)


visible(w) <- TRUE
-------------------------------------------------------------------------------------------------------
pupilplot <- function (wf, cp = NULL, col = topo.colors(256), addContours = FALSE, 
cscale = TRUE, ...) 
 {
     if (cscale) {
         mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar
        on.exit(par(par.orig))
        w <- (3 + mar.orig[2]) * par("csi") * 2.54
        layout(matrix(c(2, 1), ncol = 2), widths = c(1, lcm(w)))
        par(las = 1)
        mar <- mar.orig
        mar[4] <- mar[2]
        mar[2] <- 1
        par(mar = mar) 
    thelist <- list(...)  
    findz <- which(names(thelist) == 'zlim')  
    if (length(findz) > 0 ) {   
        zlim <- thelist$zlim  
        }else{  
                zlim <- range(wf, finite = TRUE) #the original line  
        } 
 # end of my hack  
        levels <- seq(zlim[1], zlim[2], length = length(col))
        plot.new()
        plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i", yaxs = "i")
        rect(0, levels[-length(levels)], 1, levels[-1], col = col,  density = NA)
        axis(4)
         box()
        mar <- mar.orig
        mar[4] <- 0
        par(mar = mar)
    }
    if (is.null(cp)) {
        axis1 <- 1:nrow(wf)
        axis2 <- 1:ncol(wf)
    }
    else {
         axis1 <- ((1:nrow(wf)) - cp$xc)/cp$rx
        axis2 <- ((1:ncol(wf)) - cp$yc)/cp$ry
    }
    image(axis1, axis2, wf, col = col, asp = 1, xlab = "X", ylab = "Y",  ...)
     if (addContours) 
        contour(axis1, axis2, wf, add = TRUE)
}
-------------------------------------------------------------------------------------------------------
heatmap.2 hm3 hm3 if (missing(lhei) || is.null(lhei)) layout layout(lmat, widths = lwid, heights = lhei, respect = FALSE) x  <- as.matrix(mtcars) 
lhei <- c(1.5, 4,1.5,4)
lwid <- c(1.5, 4,1.5,4)
layout(rbind(c(4,3,8,7),c(2,1,6,5)), 
    widths = lwid, heights = lhei, respect = FALSE)
hm3(x)
hm3(x) hm3
-------------------------------------------------------------------------------------------------------
multiplot multiplot(plot1, plot2, cols=2) multiplot <- function(..., plotlist=NULL, cols) {
    require(grid)

    # Make a list from the ... arguments and plotlist
    plots <- c(list(...), plotlist)

    numPlots = length(plots)

    # Make the panel
    plotCols = cols                          # Number of columns of plots
    plotRows = ceiling(numPlots/plotCols) # Number of rows needed, calculated from # of cols

    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(plotRows, plotCols)))
    vplayout <- function(x, y)
        viewport(layout.pos.row = x, layout.pos.col = y)

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
        curRow = ceiling(i/plotCols)
        curCol = (i-1) %% plotCols + 1
        print(plots[[i]], vp = vplayout(curRow, curCol ))
    }

}
-------------------------------------------------------------------------------------------------------
+opts(title = XXX) p1 <- ggplot(mtcars, aes(factor(cyl))) + geom_bar()
p2 <- ggplot(mtcars, aes(wt, mpg)) + geom_point()
p3 <- p2 + geom_line()

pushViewport(viewport(layout = grid.layout(2, 2)))  
print(p1 + opts(title = "bar"), 
  vp = viewport(layout.pos.row = 1, layout.pos.col = 1))     
print(p2 + opts(title = "point"), 
  vp = viewport(layout.pos.row = 1, layout.pos.col = 2))     
print(p3 + opts(title = "point and line"), 
  vp = viewport(layout.pos.row = 2, layout.pos.col = 1:2)) pushViewport(viewport(layout = grid.layout(3, 2, heights = unit(c(1, 4, 4), "null"))))
grid.text("title of this panel", vp = viewport(layout.pos.row = 1, layout.pos.col = 1:2))
print(p1, vp = viewport(layout.pos.row = 2, layout.pos.col = 1))
print(p2, vp = viewport(layout.pos.row = 2, layout.pos.col = 2))
print(p3, vp = viewport(layout.pos.row = 3, layout.pos.col = 1:2))
-------------------------------------------------------------------------------------------------------
filled.contour scatter.fill <- function (x, y, z, 
                              nlevels = 20, plot.title, plot.axes, 
                              key.title, key.axes, asp = NA, xaxs = "i", 
                              yaxs = "i", las = 1, 
                              axes = TRUE, frame.plot = axes, ...) 
    {
        mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar
        on.exit(par(par.orig))
        w <- (3 + mar.orig[2L]) * par("csi") * 2.54
        layout(matrix(c(2, 1), ncol = 2L), widths = c(1, lcm(w)))
        par(las = las)
        mar <- mar.orig
        mar[4L] <- mar[2L]
        mar[2L] <- 1
        par(mar = mar)

        #Some simplified level/color picking
        levels <- seq(min(z),max(z),length.out = nlevels)
  col <- colorRampPalette(c("blue","red"))(nlevels)[rank(z)]

        plot.new()
        plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i", 
            yaxs = "i")
  rect(0, levels[-length(levels)], 1, levels[-1L], col = colorRampPalette(c("blue","red"))(nlevels)
        if (missing(key.axes)) {
            if (axes) 
                axis(4)
        }
        else key.axes
        box()
        if (!missing(key.title)) 
            key.title
        mar <- mar.orig
        mar[4L] <- 1
        par(mar = mar)

        #Simplified scatter plot construction
        plot(x,y,type = "n")
        points(x,y,col = col,...)

        if (missing(plot.axes)) {
            if (axes) {
                title(main = "", xlab = "", ylab = "")
                Axis(x, side = 1)
                Axis(y, side = 2)
            }
        }
        else plot.axes
        if (frame.plot) 
            box()
        if (missing(plot.title)) 
            title(...)
        else plot.title
        invisible()
    } x <- runif(40)
y <- runif(40)
z <- runif(40)
scatter.fill(x,y,z,nlevels = 40,pch = 20) filled.contour
-------------------------------------------------------------------------------------------------------
layout layout(matrix(c(1, 1, 0, 2), ncol = 2L), widths = c(1,1),heights = c(0.5,1))
par(mar = c(3,2,2,2))
plot(1:10,1:10)
par(mar = c(3,2,2,2))
plot(1:10,1:10) c(0.2,0.8) omd par(mfrow = c(1,2)) plt quartz quartz(width = 5,height = 5)
par(mfrow=c(1,2))
vec <- par("plt")
plot(1:10,1:10)
par(plt = vec * c(1,1,1,0.75))
plot(1:5,1:5)
-------------------------------------------------------------------------------------------------------
chartSeries layout NULL layout() mfrow library(quantmod)
getSymbols("AA")

op <- par(mfrow=c(3,2))
for(i in 1:6) {
  chartSeries(
    AA["2011-01"], "candlesticks", 
    TA=NULL, # No volume plot
    layout=NULL, 
    yrange=c(15,18)
  )
}
par(op) layout mfrow layout( matrix( c(
    1, 3,
    2, 4,
    5, 7,
    6, 8,
    9, 11,
   10, 12
  ), nc=2, byrow=TRUE),
  heights = rep( c(2,1), 3 )
)
#layout.show(12) # To check that the order is as desired
for(i in 1:6) {
  chartSeries( 
    AA[sprintf("2011-%02d",i)], 
    "candlesticks", layout=NULL, yrange=c(15,19) 
  )
}
-------------------------------------------------------------------------------------------------------
ylim=c(18000,20000)
layout(matrix(1:12,nrow=6,ncol=2), height=c(4,2,4,2,4,2))
for(d in bars){
    chartSeries(d,layout=NULL,TA=c(addVo(),addBBands()),yrange=ylim)
    }
-------------------------------------------------------------------------------------------------------
scipen ?options las ?par x <- rnorm(20)^2 * 10000000
layout(matrix(1:2, ncol = 2))
plot(x)
getOption("scipen")
opt <- options("scipen" = 20)
getOption("scipen")
plot(x)
options(opt)
layout(1) plot(x / 10000000, axes = FALSE)
axis(1)
pts <- pretty(x / 10000000)
axis(2, at = pts, labels = paste(pts, "MM", sep = ""))
box() pretty() plot() axis() box() opt <- options("scipen" = 20)
op <- par(mar = c(5,7,4,2) + 0.1) ## extra margin to accommodate tick labs
x <- rnorm(20)^2 * 10000000
plot(x, las = 1, ylab = "")       ## no y-axis label 
title(ylab = "label", line = 5.5) ## need to plot the axis label
par(op)
options(opt) las plot() las = 1 axis() op <- par(mar = c(5,5,4,2) + 0.1)
plot(x / 10000000, axes = FALSE, ylab = "")
axis(1)
pts <- pretty(x / 10000000)
axis(2, at = pts, labels = paste(pts, "MM", sep = ""), las = 1)
title(ylab = "my label", line = 4)
box()
par(op)
-------------------------------------------------------------------------------------------------------
set.seed(121)
a=sample(1:100,5)
b=sample(1:100,5)
c=sample(1:100,5)

dev.off()

layout(rbind(1,2), heights=c(7,1))  # put legend on bottom 1/8th of the chart

plot(a,type='l',ylim=c(min(c(a,b,c)),max(c(a,b,c))))
lines(b,lty=2)
lines(c,lty=3,col='blue')

# setup for no margins on the legend
par(mar=c(0, 0, 0, 0))
# c(bottom, left, top, right)
plot.new()
legend('center','groups',c("A","B","C"), lty = c(1,2,3),
       col=c('black','black','blue'),ncol=3,bty ="n")
-------------------------------------------------------------------------------------------------------
m <- matrix(c(3, 1, 0, 2), 2, byrow = T)
lay <- gglayout(m, widths = c(1, 3), heights = c(3, 1))
ggtable(p1, p2, p3, layout = lay) install.packages('devtools')
library(devtools)
dev_mode()
install_github("ggplot2", "kohske", "cutting-edge")
library(ggplot2)
-------------------------------------------------------------------------------------------------------
respect=TRUE grid_layout <- grid.layout(nrow=2, ncol=2, widths=c(1,2), heights=c(2,1), respect=TRUE)
-------------------------------------------------------------------------------------------------------
# Split the plot area in two
layout(matrix(c(1,1,2),nc=1))
# First plot
plot( pos, value, type="l", las=1 )
# Reduce the margins for the second plot
m <- par()$mar
m[1] <- m[3] <- 0
par(mar=m)
# Set the limits of the second plot
plot( pos, pos-pos, type="n", axes=FALSE, xlab="", ylab="" )
# Add the rectangle, the segments and the text.
polygon( 
  c(0,max(mydf2$pos),max(mydf2$pos),0), 
  .2*c(-1,-1,1,1),
  col=rgb(.1,.5,.3)
)
segments( mydf$position, -.5, mydf$position, .5 )
text(mydf$position, -.7, mydf$label)
text(mydf$position,  .7, mydf$position)
-------------------------------------------------------------------------------------------------------
p \documentclass[12pt]{article}
\title{Example}

\begin{document}

<<loading,echo=F>>=
library(ggplot2)
library(gridExtra)
@

\section{This is a Section}

<<message=F,fig.width=9,fig.height=6,out.width=\textwidth,cache=T>>=
x <- rnorm(100)
y <- runif(100)
dat <- data.frame(x,y)

grid.newpage()
pushViewport(viewport(layout = grid.layout(2,9))) 

p1 <- ggplot(dat, aes(x,y)) + geom_point()
p2 <- ggplot(dat, aes(y,x)) + geom_point()

print(p1, vp=viewport(layout.pos.row=1,layout.pos.col=1:9))
print(p2, vp=viewport(layout.pos.row=2,layout.pos.col=1:9))
@

\end{document}
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(grid)


vplayout <- function(x, y) viewport(layout.pos.row = x, layout.pos.col = y)


plot1 <- qplot(mtcars,x=wt,y=mpg,geom="point",main="Scatterplot of wt vs. mpg")
plot2 <- qplot(mtcars,x=wt,y=disp,geom="point",main="Scatterplot of wt vs disp")
plot3 <- qplot(wt,data=mtcars)
plot4 <- qplot(wt,mpg,data=mtcars,geom="boxplot")
plot5 <- qplot(wt,data=mtcars)
plot6 <- qplot(mpg,data=mtcars)
plot7 <- qplot(disp,data=mtcars)

# 4 figures arranged in 2 rows and 2 columns
grid.newpage()
pushViewport(viewport(layout = grid.layout(2, 2)))
print(plot1, vp = vplayout(1, 1))
print(plot2, vp = vplayout(1, 2))
print(plot3, vp = vplayout(2, 1))
print(plot4, vp = vplayout(2, 2))


# One figure in row 1 and two figures in row 2
grid.newpage()
pushViewport(viewport(layout = grid.layout(2, 2)))
print(plot5, vp = vplayout(1, 1:2))
print(plot6, vp = vplayout(2, 1))
print(plot7, vp = vplayout(2, 2))
-------------------------------------------------------------------------------------------------------
plot() Raster* image(temp_var, axes=FALSE, xlab="", ylab="") layout(matrix(c(1,1,1,1,1,2,2), 7, 1))
par(mar=c(0,0,0,0))
image(temp_var, axes=FALSE, xlab="", ylab="")
plot(c(0,1), c(0,1), type="n", xlab="", ylab="", axes=FALSE)
legend(0.1,0.9, legend=c(1:5), fill=rainbow(5), horiz=TRUE)
-------------------------------------------------------------------------------------------------------
layout(..) ?image.plot breaks lab.breaks image.plot # generate an image_variable for demonstration
image_variable <- array(runif(100),dim=c(10,10))
color_plate=c('royalblue4','springgreen4','yellow2','darkred')

library(fields) # for image.plot
# This puts the colour scale marks within the colour bar, not on the boundaries:
# image.plot(image_variable,col=color_plate,zlim=c(0,1),...)

zlim <- c(0,1)
# define colour breaks (they were default spaced evenly):
brks = seq(0,1,length.out=length(color_plate)+1)

# plot:
image.plot(image_variable, zlim=zlim, axes=F,
           col=color_plate, breaks=brks, lab.breaks=brks) image.plot(image_variable, col=color_plate, zlim=zlim, axes=F,
       axis.args=list(at=zlim, labels=zlim))
-------------------------------------------------------------------------------------------------------
ps=c(1,2,3)
layout(matrix(1:3,1,3))
for(i in 1:3){
    plot(1,1,main=substitute(paste(italic(p), " = 0.", x, sep=""), list(x=ps[i])))
}
-------------------------------------------------------------------------------------------------------
for if (i == 1 & j == 2){
   mtext("This title should be centered according to the plot matrix", side=3,
        line=2, outer=FALSE, adj=0.5, at=0.5)
} outer = FALSE d <- 4
d2 <- d*d
layout.mat <- matrix(1:d2, byrow=TRUE, ncol=d) # plot matrix
layout.mat <- cbind(layout.mat, rep(0, d)) # space
layout.mat <- cbind(layout.mat, rep(d2+1, d)) # column on the right side
layout.mat <- rbind(c(rep(18,d),0,0),layout.mat) #Add row on top
wspace <- 6*par("csi")*2.54 # width of the space in character height in cm
wside <- 3*par("csi")*2.54 # width of the right side in character height in cm
#Note adjustments to heights
layout(layout.mat, respect=TRUE, widths=c(rep(1, d), lcm(wspace), lcm(wside)),
       heights = c(0.25,rep(1,nrow(layout.mat)-1)))
layout.show(d2+1)
par(mar=rep(0, 4), oma=c(4,4,6,4))
for(i in 1:d){
    for(j in 1:d){
        plot.new()
        plot.window(xlim=c(0,1), ylim=c(0,1))
        ll <- par("usr")
        rect(ll[1], ll[3], ll[2], ll[4])
        text(0.5, 0.5, paste("i=",i,", j=",j,sep=""), cex=1.4)
    }
}
plot.new()
plot.window(xlim=c(0,1), ylim=c(0,1))
ll <- par("usr")
rect(ll[1], ll[3], ll[2], ll[4])
text(0.5, 0.5, "side", cex=1.4)

## title
plot.new()
plot.window(xlim=c(0,1), ylim=c(0,1))
ll <- par("usr")
#rect(ll[1], ll[3], ll[2], ll[4])
text(0.5, 0.5, "top", cex=1.4)
-------------------------------------------------------------------------------------------------------
years <- seq(1975,1989,2)
db <- data.frame(Dallas=c( 25, 28, 27, 29, 31, 33, 35, 37),
 Houston=c( 33, 38, 43, 48, 53, 58, 63, 68),
 Lubbock=c( 28, 29, 31, 33, 35, 37, 39, 41),
 Austin= c(22, 24, 26, 28, 30, 32, 34, 36),
 San_Antonio= c(31, 32, 33, 34, 35, 36, 37, 38)
)
db <- as.matrix(db)

#plot
layout(matrix(c(1,2), nrow=1, ncol=2), widths=c(4,1), heights=c(4))
layout.show(2)
par(mar=c(5,5,1,1))
image(x=years, z=db, yaxt="n")
axis(2, at=seq(0,1,,dim(db)[2]), labels=colnames(db))
#image.scale from http://menugget.blogspot.de/2011/08/adding-scale-to-image-plot.html
par(mar=c(5,0,1,5))
image.scale(db, horiz=FALSE, yaxt="n", xaxt="n", xlab="", ylab="")
axis(4)
mtext("temp", side=4, line=2)
box()
-------------------------------------------------------------------------------------------------------
R python numpy pandas matplotlib import numpy as np
import pandas as pd
import matplotlib.pyplot as plt 

df = pd.DataFrame({'original_length': [1875, 1143, 960, 1302, 2016],
                   'row_retained': [False, False, False, False, True],
                   'percentage_retained': [11.0, 23.0, 44.0, 66.0, 87.0]})
fig, ax = plt.subplots()
ax.scatter(df.original_length, df.percentage_retained,
           c=np.where(df.row_retained, 'green', 'red'),
           s=np.random.randint(50, 500, 5)
           )   
true_value = df[df.row_retained]
ax.annotate('This one is True',
            xy=(true_value.original_length, true_value.percentage_retained),
            xytext=(0.1, 0.001), textcoords='figure fraction',
            arrowprops=dict(arrowstyle="->"))
ax.grid()
ax.set_xlabel('Original Length')
ax.set_ylabel('Precentage Retained')
ax.margins(0.04)
plt.tight_layout()
plt.savefig('alternative.png') pandas
-------------------------------------------------------------------------------------------------------
base_size theme_XXX() png("example2.png", width = 81, height = 100, units = "mm", res = 300)
grid.newpage()
pushViewport(viewport(layout = grid.layout(1, 2)))
print(len + theme_gray(base_size=12*(81/169)), vp = vplayout(1, 1))
print(wid + theme_gray(base_size=12*(81/169)), vp = vplayout(1, 2))
dev.off()
-------------------------------------------------------------------------------------------------------
set.seed(42)
x <- rnorm(100)
y <- 3.4 + (0.5 * x) + rnorm(100) ask FALSE png('Filename%03d.png', width=6, height=6, units='in', res=300)
plot(lm(y~x), ask = FALSE)
dev.off() %03d "Filename001.png" ?plot.lm ask ?png png("Filename_all.png", width=6, height=6, units='in', res=300)
layout(matrix(1:4, ncol = 2))
plot(lm(y~x))
layout(1)
dev.off()
-------------------------------------------------------------------------------------------------------
m <- matrix(c(1,2,3,4,5,6,7,7,7),nrow = 3,ncol = 3,byrow = TRUE)

layout(mat = m,heights = c(0.4,0.4,0.2))

for (i in 1:6){
    par(mar = c(2,2,1,1))
    plot(runif(5),runif(5),xlab = "",ylab = "")
}


plot(1, type = "n", axes=FALSE, xlab="", ylab="")
plot_colors <- c("blue","black", "green", "orange", "pink")
legend(x = "top",inset = 0,
        legend = c("Fabricated Metal", "Iron and Steel", "Paper","Beverages", "Tobacco"), 
        col=plot_colors, lwd=5, cex=.5, horiz = TRUE)
-------------------------------------------------------------------------------------------------------
pushViewport(viewport(layout = grid.layout(3, 2, heights = unit(c(0.5, 5, 5), "null")))) print(ggplot(mtcars, aes(hp)) + geom_histogram(), vp = viewport(layout.pos.row = 2, layout.pos.col = 1:2))
print(ggplot(mtcars, aes(wt)) + geom_histogram(), vp = viewport(layout.pos.row = 3, layout.pos.col = 1))
print(ggplot(mtcars, aes(mpg)) + geom_histogram(), vp = viewport(layout.pos.row = 3, layout.pos.col = 2)) grid.text("MAIN TITLE", vp = viewport(layout.pos.row = 1, layout.pos.col = 1:2))
-------------------------------------------------------------------------------------------------------
layout layout(
  matrix(
    c(1,1,2,3,3,2,4,5,5,6,6,6), 
    nc=3, byrow = TRUE
  )
)
layout.show(6) par(fig=...,new=TRUE) plot.new()
par(mar=c(2,2,1,1))
k <- 4
f <- function() 
  plot(rnorm(20),rnorm(20), xlab="", ylab="", main="", las=1)
for(i in 1:k) {
  par(fig=c(0,i/(k+1), (i-1)/k, i/k), new=TRUE)
  f()
  par(fig=c(i/(k+1),1, (i-1)/k, i/k), new=TRUE)
  f()
}
-------------------------------------------------------------------------------------------------------
?options set.seed(42)
dat <- data.frame(x = runif(100, min = 0, max = 1000000),
                  y = runif(100, min = 0, max = 1000000))

layout(matrix(1:2, ncol = 2))
plot(y ~ x, data = dat)
opt <- options(scipen = 10)
plot(y ~ x, data = dat)
options(opt)
layout(1) axes = FALSE plot() axis() format() ?format
-------------------------------------------------------------------------------------------------------
Final Final <- data.frame(Loc = Locations,
                    Doy = as.numeric(format(Date,format = "%j")),
                    Temp = RandData) plot() subset subset() ylab <- "Temperature"
xlab <- "Day of year"

layout(matrix(1:2, ncol = 2))
plot(Temp ~ Doy, data = Final, subset = Loc == "England", main = "England",
     ylab = ylab, xlab = xlab)
plot(Temp ~ Doy, data = Final, subset = Loc == "Wales", main = "Wales",
     ylab = ylab, xlab = xlab)
layout(1) ylab <- "Temperature"
xlab <- "Day of year"
xlim <- with(Final, range(Doy))
ylim <- with(Final, range(Temp))
layout(matrix(1:2, ncol = 2))
plot(Temp ~ Doy, data = Final, subset = Loc == "England", main = "England",
     ylab = ylab, xlab = xlab, xlim = xlim, ylim = ylim)
plot(Temp ~ Doy, data = Final, subset = Loc == "Wales", main = "Wales",
     ylab = ylab, xlab = xlab, xlim = xlim, ylim = ylim)
layout(1) Doy type = "l" plot() require(lattice)
xyplot(Temp ~ Doy | Loc, data = Final, type = c("l","p") type = "p" type = "l"
-------------------------------------------------------------------------------------------------------
library(lattice)
# Create layout and viewports
masterLayout <- grid.layout(
  nrow    = 3, 
  ncol    = 1, 
  heights = unit(c(1, .5, 1), c("null", "inches", "null")),
  respect = matrix(c(0, 1, 0)))
vp1 <- viewport(layout.pos.row=1,  name="vp1")  
vp2 <- viewport(layout.pos.row=3,  name="vp2")     
vp3 <- viewport(layout.pos.row=2,  name="spacer")     

theme.novpadding <-
   list(layout.heights =
        list(top.padding = 0,
        main.key.padding = 0,
        key.axis.padding = 0,
        axis.xlab.padding = 0,
        xlab.key.padding = 0,
        key.sub.padding = 0,
        bottom.padding = 0),
        layout.widths =
        list(left.padding = 0,
        key.ylab.padding = 0,
        ylab.axis.padding = 0,
        axis.key.padding = 0,
        right.padding = 0))

# Create plots
plot1 <- xyplot(1 ~ 1, panel = function () grid.rect(gp=gpar(fill="black")),
   scales=list(axs='i',draw=FALSE),
   xlab=NULL,ylab=NULL,par.settings = theme.novpadding)
plot2 <- xyplot(1 ~ 1, panel = function () grid.rect(gp=gpar(fill="red")),
   scales=list(axs='i',draw=FALSE),
   xlab=NULL,ylab=NULL,par.settings = theme.novpadding)       

grid.newpage()
pushViewport(vpTree(viewport(layout = masterLayout,name="master"), vpList(vp1, vp2, vp3)))
seekViewport("master")
print(plot1, draw.in = "vp1")
print(plot2, draw.in = "vp2")
seekViewport("spacer")
grid.rect()
-------------------------------------------------------------------------------------------------------
par(mfrow layout par( oma=c(5,4,4,1)+0.1, mar=c(0,0,0,0) )
layout( matrix( 1:3, nrow=1 ) )
for( i in levels(iris$Species) ) {
    with( iris[ iris$Species==i, ], {
        plot(Sepal.Width, Sepal.Length, ann=FALSE, xaxt='n', yaxt='n',
            ylim=range(iris$Sepal.Length))
        axis(1, outer=TRUE)
        mtext(side=3, i ) }
    )
}
axis(2, outer=TRUE)
-------------------------------------------------------------------------------------------------------
scatterBar.Norm <- function(x,y) {
 zones <- matrix(c(2,0,1,3), ncol=2, byrow=TRUE)
 layout(zones, widths=c(5/7,2/7), heights=c(2/7,5/7))
 xrange <- range(x)
 yrange <- range(y)
 par(mar=c(3,3,1,1))
 plot(x, y, xlim=xrange, ylim=yrange, xlab="", ylab="", cex=0.5)
 xhist <- hist(x, plot=FALSE, breaks=seq(from=min(x), to=max(x), length.out=20))
 yhist <- hist(y, plot=FALSE, breaks=seq(from=min(y), to=max(y), length.out=20))
 top <- max(c(xhist$density, yhist$density))
 par(mar=c(0,3,1,1))
 barplot(xhist$density, axes=FALSE, ylim=c(0, top), space=0)
 x.xfit <- seq(min(x),max(x),length.out=40)
 x.yfit <- dnorm(x.xfit, mean=mean(x), sd=sd(x))
 x.xscalefactor <- x.xfit / seq(from=0, to=19, length.out=40)
 lines(x.xfit/x.xscalefactor, x.yfit, col="red")
 par(mar=c(3,0,1,1))
 barplot(yhist$density, axes=FALSE, xlim=c(0, top), space=0, horiz=TRUE)
 y.xfit <- seq(min(y),max(y),length.out=40)
 y.yfit <- dnorm(y.xfit, mean=mean(y), sd=sd(y))
 y.xscalefactor <- y.xfit / seq(from=0, to=19, length.out=40)
 lines(y.yfit, y.xfit/y.xscalefactor, col="red")
} require(MASS)
#Sigma <- matrix(c(2.25, 0.8, 0.8, 1), 2, 2)
Sigma <- matrix(c(1, 0.8, 0.8, 1), 2, 2)
mvnorm <- mvrnorm(1000, c(0,0), Sigma) ; scatterBar.Norm(mvnorm[,1], mvnorm[,2])
-------------------------------------------------------------------------------------------------------
scatterBarNorm <- function(x, dcol="blue", lhist=20, num.dnorm=5*lhist, ...){
    ## check input
    stopifnot(ncol(x)==2)
    ## set up layout and graphical parameters
    layMat <- matrix(c(2,0,1,3), ncol=2, byrow=TRUE)
    layout(layMat, widths=c(5/7, 2/7), heights=c(2/7, 5/7))
    ospc <- 0.5 # outer space
    pext <- 4 # par extension down and to the left
    bspc <- 1 # space between scatter plot and bar plots
    par. <- par(mar=c(pext, pext, bspc, bspc),
                oma=rep(ospc, 4)) # plot parameters
    ## scatter plot
    plot(x, xlim=range(x[,1]), ylim=range(x[,2]), ...)
    ## 3) determine barplot and height parameter
    ## histogram (for barplot-ting the density)
    xhist <- hist(x[,1], plot=FALSE, breaks=seq(from=min(x[,1]), to=max(x[,1]),
                                     length.out=lhist))
    yhist <- hist(x[,2], plot=FALSE, breaks=seq(from=min(x[,2]), to=max(x[,2]),
                                     length.out=lhist)) # note: this uses probability=TRUE
    ## determine the plot range and all the things needed for the barplots and lines
    xx <- seq(min(x[,1]), max(x[,1]), length.out=num.dnorm) # evaluation points for the overlaid density
    xy <- dnorm(xx, mean=mean(x[,1]), sd=sd(x[,1])) # density points
    yx <- seq(min(x[,2]), max(x[,2]), length.out=num.dnorm)
    yy <- dnorm(yx, mean=mean(x[,2]), sd=sd(x[,2]))
    ## barplot and line for x (top)
    par(mar=c(0, pext, 0, 0))
    barplot(xhist$density, axes=FALSE, ylim=c(0, max(xhist$density, xy)),
            space=0) # barplot
    lines(seq(from=0, to=lhist-1, length.out=num.dnorm), xy, col=dcol) # line
    ## barplot and line for y (right)
    par(mar=c(pext, 0, 0, 0))
    barplot(yhist$density, axes=FALSE, xlim=c(0, max(yhist$density, yy)),
            space=0, horiz=TRUE) # barplot
    lines(yy, seq(from=0, to=lhist-1, length.out=num.dnorm), col=dcol) # line
    ## restore parameters
    par(par.)
}

require(mvtnorm)
X <- rmvnorm(1000, c(0,0), matrix(c(1, 0.8, 0.8, 1), 2, 2))
scatterBarNorm(X, xlab=expression(italic(X[1])), ylab=expression(italic(X[2])))
-------------------------------------------------------------------------------------------------------
layout m <- matrix(c(1,2,3,3,4,5,6,6),ncol = 2,byrow = TRUE)
layout(m,widths = c(0.5,0.5),heights = c(0.45,0.05,0.45,0.05))

par(mar = c(2,4,4,2) + 0.1)
hist(x1, xlab="", main="Group A")
hist(x2, xlab="", main="Group B")

par(mar = c(0,0,0,0)) 
plot(1,1,type = "n",frame.plot = FALSE,axes = FALSE)
u <- par("usr")
text(1,u[4],labels = "Here",col = "red",pos = 1)

par(mar = c(2,4,2,2) + 0.1)
hist(x3, xlab="", main="")
hist(x4, xlab="", main="")

par(mar = c(0,0,0,0)) 
plot(1,1,type = "n",frame.plot = FALSE,axes = FALSE)
u <- par("usr")
text(1,u[4],labels = "Here",col = "red",pos = 1)
-------------------------------------------------------------------------------------------------------
fig.keep fig.keep = 'last' require(knitr)
temp <- "```{r junkislands, fig.width=8, fig.height=5, fig.keep = 'last'}
layout(t(1:2))
pie(islands)
barplot(islands)
```"
cat(temp, file="junk.Rmd")
knit("junk.Rmd", "junk.md") ```r
layout(t(1:2))
pie(islands)
barplot(islands)
```

![plot of chunk junkislands](figure/junkislands.png)
-------------------------------------------------------------------------------------------------------
```{r fig.width=8, fig.height=5, fig.keep = 'last', echo=FALSE}
suppressMessages(library(PerformanceAnalytics))
layout(t(1:2))
textplot('plot(1:10)')
plot(1:10)
```
-------------------------------------------------------------------------------------------------------
gformlayout gWidgets2 gtable library(gWidgets2)
options("guiToolkit"="RGtk2")

f <- function(file, max.rows){
    dat <- read.table(file, nrows=max.rows)
    message("Calling max")
    print(max(dat[,]))
}

## containers
w <- gwindow("Example", visible=FALSE)
fr <- gframe("Arguments", horizontal=FALSE, cont=w)       # optional frame
fl <- gformlayout(cont=fr)
## widgets
select_file <- gfilebrowse(cont=fl, label="File")
max_rows <- gedit(-1, cont=fl, label="maximum number of rows", coerce.with=as.numeric)
## button
bg <- ggroup(cont=fr)
addSpring(bg)
btn <- gbutton("ok", cont=bg)

addHandlerClicked(btn, function(h,...) {
  l <- svalue(fl) ## a named list by the labels,
  do.call(f, setNames(l, c("file", "max.rows"))) ## change names for do.call
})
visible(w) <- TRUE gWidgets2 gWidgets
-------------------------------------------------------------------------------------------------------
`dprint` +  `knitr` Examples to create table images
===========

```{r}
library(dprint)
# creating the sytle object to be used
CBs <- style(frmt.bdy=frmt(fontfamily="HersheySans"), 
             frmt.tbl=frmt(bty="o", lwd=1),
        frmt.col=frmt(fontfamily="HersheySans", bg="khaki", 
                      fontface="bold", lwd=2, bty="_"),
        frmt.grp=frmt(fontfamily="HersheySans",bg="khaki", 
                      fontface="bold"),
        frmt.main=frmt(fontfamily="HersheySans", fontface="bold", 
                       fontsize=12),
        frmt.ftn=frmt(fontfamily="HersheySans"),
        justify="right", tbl.buf=0)

# creating a setup function to setup printing a table (will probably put this function into my .Rprofile file)
setup.table <- function(df,width=10, style.obj='CBs'){
  require(dprint)
  table.style <- get(style.obj)
  a <- tbl.struct(~., df)
  b <- char.dim(a, style=table.style)
  p <- pagelayout(dtype = "rgraphics", pg.dim = NULL, margins = NULL)
  f <- size.simp(a[[1]], char.dim.obj=b, loc.y=0, pagelayout=p)
  # now to work out the natural table width to height ratio (w.2.h.r) GIVEN the style
  w.2.h.r <- as.numeric(f$tbl.width/(f$tbl.height +b$linespace.col+ b$linespace.main))
  height <- width/w.2.h.r

  table.width <- width
  table.height <- height

  # Setting chunk options to have right fig dimensions for the next chunk
  opts_chunk$set('fig.width'=as.numeric(width+0.1))
  opts_chunk$set('fig.height'=as.numeric(height+0.1))

  # assigning relevant variables to be used when printing
  assign("table.width",table.width, envir=.GlobalEnv)
  assign("table.height",table.height, envir=.GlobalEnv)
  assign("table.style", table.style, envir=.GlobalEnv)
}

# function to print the table (will probably put this function into my .Rprofile file as well)
print.table <- function(df, row.2.hl='2012-04-30', colour='lightblue',...) {
  x <-dprint(~., data=df, style=table.style, pg.dim=c(table.width,table.height), ..., newpage=TRUE,fit.width=TRUE, row.hl=row.hl(which(df[,1]==row.2.hl), col=colour))
}
```

```{r}
# Giving it a go!
# Setting up two differnt size tables
small.df <- data.frame(matrix(1:100, 10,10))
big.df <- data.frame(matrix(1:800,40,20))
```


```{r}
# Using the created setup.table function
setup.table(df=small.df, width=10, style.obj='CBs')
```

```{r}
# Using the print.table function
print.table(small.df,4,'lightblue',main='table title string') # highlighting row 4
```

```{r}
setup.table(big.df,13,'CBs') # now setting up a large table
```

```{r}
print.table(big.df,38,'orange', main='the big table!') # highlighting row 38 in orange
```

```{r}
d <- style() # the default style this time will be used
setup.table(big.df,15,'d')
```

```{r}
print.table(big.df, 23, 'indianred1') # this time higlihting row 23
```
-------------------------------------------------------------------------------------------------------
library(TeachingDemos)
x <- pmin(3, pmax(-3, stats::rnorm(50)))
y <- pmin(3, pmax(-3, stats::rnorm(50)))
xhist <- hist(x, breaks=seq(-3,3,0.5), plot=FALSE)
yhist <- hist(y, breaks=seq(-3,3,0.5), plot=FALSE)
top <- max(c(xhist$density, yhist$density))
xrange <- c(-3,3)
yrange <- c(-3,3)
nf <- layout(matrix(c(2,0,1,3),2,2,byrow=TRUE), c(3,1), c(1,3), TRUE)
layout.show(nf)

par(mar=c(3,3,1,1))
plot(x, y, xlim=xrange, ylim=yrange, xlab="", ylab="")
par(mar=c(0,3,1,1))
bx.out <- barplot(xhist$density, axes=FALSE, ylim=c(0, top), space=0)
updateusr( bx.out[1:2], 0:1, xhist$mids[1:2], 0:1 )
xdens <- density(x)
lines(xdens$x, xdens$y, col='blue')
par(mar=c(3,0,1,1))
by.out <- barplot(yhist$density, axes=FALSE, xlim=c(0, top), space=0, horiz=TRUE)
updateusr( 0:1, by.out[1:2], 0:1, yhist$mids[1:2] )
ydens <- density(y)
lines(ydens$y, ydens$x, col='blue') counts density updateusr updateusr width xlim barplot
-------------------------------------------------------------------------------------------------------
dat dat ## fake a list of data frames, here, 4, each with two columns
dat <- list(file1 = data.frame(X = runif(20), Y = rnorm(20)),
            file2 = data.frame(X = runif(20), Y = runif(20)),
            file3 = data.frame(X = runif(20),
                               Y = rnorm(20) + rnorm(20, mean = 2, sd = 2)),
            file4 = data.frame(X = runif(20), Y = rnorm(20, mean = 4)))

## extract the second column from each
## (this is the same as your code extracting the 14 column)
tmp <- lapply(dat, `[[`, 2) R> str(tmp)
List of 4
 $ file1: num [1:20] -1.0225 -0.0302 -0.0987 1.977 0.2579 ...
 $ file2: num [1:20] 0.84583 0.49525 0.12287 0.43929 0.00132 ...
 $ file3: num [1:20] 2.03 5.27 1.57 2.72 1.12 ...
 $ file4: num [1:20] 4.54 4.08 4.28 4.48 6.36 ... tmp hist(tmp[[1]]) layout(matrix(1:4, ncol = 2))
for(p in seq_along(tmp)) {
    hist(tmp[[p]])
}
layout(1) lapply() layout(matrix(1:4, ncol = 2))
lapply(tmp, function(x) {hist(x); invisible()})
layout(1)
-------------------------------------------------------------------------------------------------------
size.range/2 size.range <- c(.1, 1) # Min and max radius of circles, in cm

# Calculate the relative radius of each circle
radii <- sqrt(agData$freq)
radii <- diff(size.range)*(radii - min(radii))/diff(range(radii)) + size.range[1]

# Plot in two panels
mar0 <- par("mar")
layout(t(1:2), widths=c(4,1))

# Panel 1: The circles
par(mar=c(mar0[1:3],.5))
symbols(agData$class, agData$drv, radii, inches=size.range[2]/cm(1), bg="black")

# Panel 2: The legend
par(mar=c(mar0[1],.5,mar0[3:4]))
symbols(c(0,0), 1:2, size.range, xlim=c(-4, 4), ylim=c(-2,4),
        inches=1/cm(1), bg="black", axes=FALSE, xlab="", ylab="")
text(0, 3, "Freq")
text(c(2,0), 1:2, range(agData$freq), col=c("black", "white"))

# Reset par settings
par(mar=mar0) agData$freq with(agData, symbols(class, drv, sqrt(freq),
     inches=size.range[2]/cm(1), bg="black"))
with(agData, text(class, drv, freq, col="white"))
-------------------------------------------------------------------------------------------------------
library(party)
data(iris)
attach(iris)

ctree <- ctree(Species ~ Sepal.Length + Sepal.Width 
               + Petal.Length + Petal.Width, data = iris)

# getting ctree's class

> class(ctree)
[1] "BinaryTree"
attr(,"package")
[1] "party" ?'plot.BinaryTree' terminal_panel ?node_barplot plot(ctree, terminal_panel = node_barplot(ctree)) horizontal horiz node_barplot node_barplot # Note inclusion of horiz = FALSE
alt_node_barplot <- function (ctreeobj, col = "black", fill = NULL, beside = NULL, 
    ymax = NULL, ylines = NULL, widths = 1, gap = NULL, reverse = NULL, 
    id = TRUE, horiz = FALSE)
{
    getMaxPred <- function(x) {
        mp <- max(x$prediction)
        mpl <- ifelse(x$terminal, 0, getMaxPred(x$left))
        mpr <- ifelse(x$terminal, 0, getMaxPred(x$right))
        return(max(c(mp, mpl, mpr)))
    }
    y <- response(ctreeobj)[[1]]
    if (is.factor(y) || class(y) == "was_ordered") {
        ylevels <- levels(y)
        if (is.null(beside)) 
            beside <- if (length(ylevels) < 3) 
                FALSE
            else TRUE
        if (is.null(ymax)) 
            ymax <- if (beside) 
                1.1
            else 1
        if (is.null(gap)) 
            gap <- if (beside) 
                0.1
            else 0
    }
    else {
        if (is.null(beside)) 
            beside <- FALSE
        if (is.null(ymax)) 
            ymax <- getMaxPred(ctreeobj@tree) * 1.1
        ylevels <- seq(along = ctreeobj@tree$prediction)
        if (length(ylevels) < 2) 
            ylevels <- ""
        if (is.null(gap)) 
            gap <- 1
    }
    if (is.null(reverse)) 
        reverse <- !beside
    if (is.null(fill)) 
        fill <- gray.colors(length(ylevels))
    if (is.null(ylines)) 
        ylines <- if (beside) 
            c(3, 2)
        else c(1.5, 2.5)
    # My edit do not work if beside is not true
    #################################################
    if(!beside) horiz = FALSE
    #################################################

    rval <- function(node) {
        pred <- node$prediction
        if (reverse) {
            pred <- rev(pred)
            ylevels <- rev(ylevels)
        }
        np <- length(pred)
        nc <- if (beside) 
            np
        else 1
        fill <- rep(fill, length.out = np)
        widths <- rep(widths, length.out = nc)
        col <- rep(col, length.out = nc)
        ylines <- rep(ylines, length.out = 2)
        gap <- gap * sum(widths)
        #######################################################
        if (!horiz){
            yscale <- c(0, ymax)
            xscale <- c(0, sum(widths) + (nc + 1) * gap)
        } else {
            xscale <- c(0, ymax)
            yscale <- c(0, sum(widths) + (nc + 1) * gap)
        }                    
        #######################################################
        top_vp <- viewport(layout = grid.
layout(nrow = 2, ncol = 3, widths = unit(), heights = unit(), width = unit(), height = unit(), name = paste())
        pushViewport(top_vp)
        grid.rect(gp = gpar(fill = "white", col = 0))
        top <- viewport(layout.pos.col = 2, layout.pos.row = 1)
        pushViewport(top)
        mainlab <- paste(ifelse(id, paste("Node", node$nodeID, 
            "(n = "), "n = "), sum(node$weights), ifelse(id, 
            ")", ""), sep = "")
        grid.text(mainlab)
        popViewport()
        plot <- viewport(layout.pos.col = 2, layout.pos.row = 2, 
            xscale = xscale, yscale = yscale, name = paste("node_barplot", 
                node$nodeID, "plot", sep = ""))
        pushViewport(plot)
        if (beside) {
            #############################################################
            if(!horiz){
                xcenter <- cumsum(widths + gap) - widths/2
                for (i in 1:np) {
                    grid.rect(x = xcenter[i], y = 0, height = pred[i], 
                      width = widths[i], just = c("center", "bottom"), 
                      default.units = "native", gp = gpar(col = col[i], 
                        fill = fill[i]))
                }
                if (length(xcenter) > 1) 
                    grid.xaxis(at = xcenter, label = FALSE)
                grid.text(ylevels, x = xcenter, y = unit(-1, "lines"), 
                    just = c("center", "top"), default.units = "native", 
                    check.overlap = TRUE)
                grid.yaxis()
            } else {
                ycenter <- cumsum(widths + gap) - widths/2
                for (i in 1:np) {
                    grid.rect(y = ycenter[i], x = 0, width = pred[i], 
                    height = widths[i], just = c("left", "center"), 
                    default.units = "native", gp = gpar(col = col[i], 
                     fill = fill[i]))
                }
                if (length(ycenter) > 1) 
                    grid.yaxis(at = ycenter, label = FALSE)
                        grid.text(ylevels, y = ycenter, x = unit(-1, "lines"), 
                        just = c("right", "center"), default.units = "native", 
                         check.overlap = TRUE)
                grid.xaxis()
            }
        #############################################################
        }
        else {
            ycenter <- cumsum(pred) - pred
            for (i in 1:np) {
                grid.rect(x = xscale[2]/2, y = ycenter[i], height = min(pred[i], 
                  ymax - ycenter[i]), width = widths[1], just = c("center", 
                  "bottom"), default.units = "native", gp = gpar(col = col[i], 
                  fill = fill[i]))
            }
            if (np > 1) {
                grid.text(ylevels[1], x = unit(-1, "lines"), 
                  y = 0, just = c("left", "center"), rot = 90, 
                  default.units = "native", check.overlap = TRUE)
                grid.text(ylevels[np], x = unit(-1, "lines"), 
                  y = ymax, just = c("right", "center"), rot = 90, 
                  default.units = "native", check.overlap = TRUE)
            }
            if (np > 2) {
                grid.text(ylevels[-c(1, np)], x = unit(-1, "lines"), 
                  y = ycenter[-c(1, np)], just = "center", rot = 90, 
                  default.units = "native", check.overlap = TRUE)
            }
            grid.yaxis(main = FALSE)
        }
        grid.rect(gp = gpar(fill = "transparent"))
        upViewport(2)
    }
    return(rval)
} plot(ctree, terminal_panel = alt_node_barplot(ctree, horiz = TRUE)) beside horiz beside ?viewport ?grid.rect reverse
-------------------------------------------------------------------------------------------------------
library("grid")
library("gridBase")
library("lattice")

# example from levelplot help page
x <- seq(pi/4, 5 * pi, length.out = 100)
y <- seq(pi/4, 5 * pi, length.out = 100)
r <- as.vector(sqrt(outer(x^2, y^2, "+")))
g <- expand.grid(x=x, y=y)
g$z <- cos(r^2) * exp(-r/(pi^3))
p <- levelplot(z~x*y, g, cuts = 50, scales=list(log="e"), xlab="",
               ylab="", main="lattice levelplot",
               colorkey=FALSE, region=TRUE)

grid.newpage()
pushViewport(viewport(layout=grid.layout(2, 1,heights=unit(c(2, 1), "null"))))
vp <- pushViewport(viewport(layout.pos.row=1, layout.pos.col=1))
par(omi=gridOMI())
# base graphics
plot(1:10, main="base graphics plot")
popViewport()
# lattice plot
vp <- pushViewport(viewport(layout.pos.row=2, layout.pos.col=1))
print(p, vp=vp, newpage=FALSE)
popViewport()
popViewport()
-------------------------------------------------------------------------------------------------------
plot(TreeResults,tp_args = list(beside=F)) node_barplot() altbp<-function (ctreeobj, col = "black", fill = NULL, beside = NULL, 
    ymax = NULL, ylines = NULL, widths = 1, gap = NULL, reverse = NULL, 
    id = TRUE,rot=45) 
{
    getMaxPred <- function(x) {
        mp <- max(x$prediction)
        mpl <- ifelse(x$terminal, 0, getMaxPred(x$left))
        mpr <- ifelse(x$terminal, 0, getMaxPred(x$right))
        return(max(c(mp, mpl, mpr)))
    }
    y <- response(ctreeobj)[[1]]
    if (is.factor(y) || class(y) == "was_ordered") {
        ylevels <- levels(y)
        if (is.null(beside)) 
            beside <- if (length(ylevels) < 3) 
                FALSE
            else TRUE
        if (is.null(ymax)) 
            ymax <- if (beside) 
                1.1
            else 1
        if (is.null(gap)) 
            gap <- if (beside) 
                0.1
            else 0
    }
    else {
        if (is.null(beside)) 
            beside <- FALSE
        if (is.null(ymax)) 
            ymax <- getMaxPred(ctreeobj@tree) * 1.1
        ylevels <- seq(along = ctreeobj@tree$prediction)
        if (length(ylevels) < 2) 
            ylevels <- ""
        if (is.null(gap)) 
            gap <- 1
    }
    if (is.null(reverse)) 
        reverse <- !beside
    if (is.null(fill)) 
        fill <- gray.colors(length(ylevels))
    if (is.null(ylines)) 
        ylines <- if (beside) 
            c(3, 2)
        else c(1.5, 2.5)
    rval <- function(node) {
        pred <- node$prediction
        if (reverse) {
            pred <- rev(pred)
            ylevels <- rev(ylevels)
        }
        np <- length(pred)
        nc <- if (beside) 
            np
        else 1
        fill <- rep(fill, length.out = np)
        widths <- rep(widths, length.out = nc)
        col <- rep(col, length.out = nc)
        ylines <- rep(ylines, length.out = 2)
        gap <- gap * sum(widths)
        yscale <- c(0, ymax)
        xscale <- c(0, sum(widths) + (nc + 1) * gap)
        top_vp <- viewport(layout = 
grid.layout(nrow = 2, ncol = 3, widths = unit(), heights = unit(), width = unit(), height = unit()), name = paste())
        pushViewport(top_vp)
        grid.rect(gp = gpar(fill = "white", col = 0))
        top <- viewport(layout.pos.col = 2, layout.pos.row = 1)
        pushViewport(top)
        mainlab <- paste(ifelse(id, paste("Node", node$nodeID, 
            "(n = "), "n = "), sum(node$weights), ifelse(id, 
            ")", ""), sep = "")
        grid.text(mainlab)
        popViewport()
        plot <- viewport(layout.pos.col = 2, layout.pos.row = 2, 
            xscale = xscale, yscale = yscale, name = paste("node_barplot", 
                node$nodeID, "plot", sep = ""))
        pushViewport(plot)
        if (beside) {
            xcenter <- cumsum(widths + gap) - widths/2
            for (i in 1:np) {
                grid.rect(x = xcenter[i], y = 0, height = pred[i], 
                  width = widths[i], just = c("center", "bottom"), 
                  default.units = "native", gp = gpar(col = col[i], 
                    fill = fill[i]))
            }
            if (length(xcenter) > 1) 
                grid.xaxis(at = xcenter, label = FALSE)
            grid.text(ylevels, x = xcenter, y = unit(-1, "lines"), 
                just = c("center", "top"), default.units = "native", 
                check.overlap = TRUE,rot=rot)
            grid.yaxis()
        }
        else {
            ycenter <- cumsum(pred) - pred
            for (i in 1:np) {
                grid.rect(x = xscale[2]/2, y = ycenter[i], height = min(pred[i], 
                  ymax - ycenter[i]), width = widths[1], just = c("center", 
                  "bottom"), default.units = "native", gp = gpar(col = col[i], 
                  fill = fill[i]))
            }
            if (np > 1) {
                grid.text(ylevels[1], x = unit(-1, "lines"), 
                  y = 0, just = c("left", "center"), rot = 90, 
                  default.units = "native", check.overlap = TRUE)
                grid.text(ylevels[np], x = unit(-1, "lines"), 
                  y = ymax, just = c("right", "center"), rot = 90, 
                  default.units = "native", check.overlap = TRUE)
            }
            if (np > 2) {
                grid.text(ylevels[-c(1, np)], x = unit(-1, "lines"), 
                  y = ycenter[-c(1, np)], just = "center", rot = 90, 
                  default.units = "native", check.overlap = TRUE)
            }
            grid.yaxis(main = FALSE)
        }
        grid.rect(gp = gpar(fill = "transparent"))
        upViewport(2)
    }
    return(rval)
} rot= grid.text beside=T plot(TreeResults,terminal_panel=altbp(TreeResults,ylines=1.2, gap=0.05,rot=45)) node_barplot altbp<-node_barplot
body(altbp)[[8]][[3]][[3]][[23]][[3]][[5]]<-substitute(
grid.text(ylevels, x = xcenter, y = unit(-1, "lines"), just = c("center", 
    "top"), default.units = "native", check.overlap = TRUE,rot=45)
)
plot(TreeResults,terminal_panel=altbp(TreeResults)) altbp
-------------------------------------------------------------------------------------------------------
layout(mat)
map('state')
par(mar=c(0,0,0,0))
map('worldHires', region='USA:Alaska', xlim=c(-175,-120), col="blue")
par(mar=c(0,0,0,0))
map('worldHires', region='Hawaii', xlim=c(-161,-154.5), col="blue")
-------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------
viewport layout() rescale asp plot.igraph() leg t8g legend <- g_legend(leg)
vpleg <- viewport(width = 0.1, height = 0.1, x=0.85,y=0.5)
layout(matrix(c(1,2),1,2,byrow=T),widths=c(3,1))
plot(t8g,edge.width=1,edge.arrow.size=0.1,vertex.label.cex=0.2,main="b2_top10")
pushViewport(vpleg)
grid.draw(legend)
-------------------------------------------------------------------------------------------------------
pdf("attempt1.pdf", ....)
layout(matrix(1:4, ncol = 2, byrow = FALSE)) ## byrow = TRUE for fill-by-row
## all 4 plot calls go in here
layout(1)
dev.off() pdf() cex.??? pdf("attempt2.pdf", height = 3.4, width = 3.4, pointsize = 10)
op <- par(mar = c(4,3,3,1) + 0.1) ## one line less per marging
## your single plotting call here
par(op)
dev.off() ?par cex.foo pdf()
-------------------------------------------------------------------------------------------------------
par(oma=c(3,3,0,0)) par(mar=...) scatterhist = function(x, y, xlab="", ylab=""){
    zones=matrix(c(2,0,1,3), ncol=2, byrow=TRUE)
    layout(zones, widths=c(4/5,1/5), heights=c(1/5,4/5))
    par(oma=c(3,3,0,0))

    xhist = hist(x, plot=F, breaks=10)
    yhist = hist(y, plot=F, breaks=10)
    top = max(c(xhist$counts, yhist$counts))

    par(mar=c(3,3,1,1))
    plot(x, y)

    par(mar=c(0,3,1,1))
    barplot(xhist$counts, axes=FALSE, ylim=c(0, top), space=0)

    par(mar=c(3,0,1,1))
    barplot(yhist$counts, axes=FALSE, xlim=c(0, top), space=0, horiz=TRUE)

    mtext(xlab, side=1, line=1, outer=TRUE, adj=0, 
        at=.8 * (mean(x)-min(x))/(max(x)-min(x)))
    mtext(ylab, side=2, line=1, outer=TRUE, adj=0, 
        at=.8 * (mean(y)-min(y))/(max(y)-min(y)))
    }
-------------------------------------------------------------------------------------------------------
layout() ylim=c(min,max) text arrow layout()
-------------------------------------------------------------------------------------------------------
par=mfrow(...) layout() layout(matrix(c(1,2,3,3), ncol=2, byrow=TRUE), heights=c(4, 1))

par(mai=rep(0.5, 4))
plot(1:3,4:6,main="plot 1")
plot(1:3,4:6,main="plot 2")

par(mai=c(0,0,0,0))
plot.new()
legend(x="center", ncol=3,legend=c("0-1 km","1-5 km","outside barrier"),
       fill=c("green","orange","red"), title="Fetch")
-------------------------------------------------------------------------------------------------------
ylim=(...) xlim=(...) layout(matrix(1:2, ncol=1))
par(mai=c(0.5, 1, 0.5, 1))

plot(c(-6, 6), 0:1, type="n", ylim=c(0, 1), xlab="", ylab="")
lines(density(x1), ylim=c(0, 1))

plot(c(-6, 6), 0:1, type="n", ylim=c(1, 0), xlab="", ylab="")
lines(density(x2), col="red", ylim=c(1, 0))
-------------------------------------------------------------------------------------------------------
angle=90 \documentclass{article}
\begin{document}

<<out.extra='angle=90'>>=
library(ggplot2)
library(grid)
df <- data.frame(x = 1:100, y =rnorm(100))
plota <- ggplot(df, aes(x, y)) + geom_point(size = 4)

pushViewport(viewport(layout = grid.layout(3, 5)))
vplayout <- function(x, y) viewport(layout.pos.row = x, layout.pos.col = y) 
        print(plota, vp = vplayout(1:2, 1:2)) 
        print(plota, vp = vplayout(1, 3)) 
        print(plota, vp = vplayout(1, 4))
        print(plota, vp = vplayout(1, 5))
        print(plota, vp = vplayout(2, 3)) 
        print(plota, vp = vplayout(2, 4))
        print(plota, vp = vplayout(2, 5))
        print(plota, vp = vplayout(3, 1))
        print(plota, vp = vplayout(3, 2))
        print(plota, vp = vplayout(3, 3))
        print(plota, vp = vplayout(3, 4))
        print(plota, vp = vplayout(3, 5))
@

\end{document}
-------------------------------------------------------------------------------------------------------
# First two dummy clusters (since you didn't provide with some...)
hc1 <- hclust(dist(USArrests), "average")
hc2 <- hclust(dist(USArrests), "complete")

l <- length(hc1$order)

# The matrix to draw the arrows:
cbind((1:l)[order(hc1$order)],(1:l)[order(hc2$order)]) -> ord_arrow

# The two vectors of ordered leave labels:
hc1$labels[hc1$order]->leaves1
hc2$labels[hc2$order]->leaves2

# And the plot:
layout(matrix(1:5,nrow=1),width=c(5,2,3,2,5))

# The first dendrogram:
par(mar=c(3,3,3,0))
plot(as.dendrogram(hc1),horiz=TRUE,leaflab="none", ylim=c(0,l))

# The first serie of labels (i draw them separately because, for the second serie, I didn't find a simple way to draw them nicely on the cluster):
par(mar=c(3,0,3,0))
plot(NA, bty="n",axes=FALSE,xlim=c(0,1), ylim=c(0,l),ylab="",xlab="")
sapply(1:l,function(x)text(x=0,y=x,labels=leaves1[x], pos=4, cex=0.8))

# The arrows:
par(mar=c(3,0,3,0))
plot(NA, bty="n",axes=FALSE,xlim=c(0,1), ylim=c(0,l),ylab="",xlab="")
apply(ord_arrow,1,function(x){arrows(0,x[1],1,x[2],code=3, length=0.05, col="blue")})

# The second serie of labels:
par(mar=c(3,0,3,0))
plot(NA, bty="n",axes=FALSE, xlim=c(0,1), ylim=c(0,l), ylab="",xlab="")
sapply(1:l,function(x)text(x=1,y=x,labels=leaves2[x], pos=2, cex=0.8))

# And the second dendrogram (to reverse it I reversed the xlim vector:
par(mar=c(3,0,3,3))
plot(as.dendrogram(hc2),horiz=TRUE, xlim=c(0,max(dist(USArrests))), leaflab="none", ylim=c(0,l)) ape
-------------------------------------------------------------------------------------------------------
annotation_custom annotation-custom grid grid.show.layout() layout.pos.row layout.pos.col library(ggplot2)
library(png)
library(grid)

# Get the logo
img <- readPNG(system.file("img", "Rlogo.png", package="png"))
g <- rasterGrob(img)

# Set the size of the viewport to contain the logo
size = unit(2, "cm")

# Get the graph
d <- ggplot(diamonds, aes(carat, price, fill = ..density..)) + 
     xlim(0, 2) + 
     stat_binhex(na.rm = TRUE) + 
     labs(title = 'Title') +
     theme(aspect.ratio = 1) + 
     facet_wrap(~ color, scales = "free_x")

# Set up the layout for grid 
heights = unit.c(size, unit(1, "npc") - size)
widths = unit.c(unit(1, "npc") - size, size)
lo = grid.layout(2, 2, widths = widths, heights = heights)
# Show the layout
grid.show.layout(lo)

# Position the elements within the viewports
grid.newpage()
pushViewport(viewport(layout = lo))

    # The plot
pushViewport(viewport(layout.pos.row=1:2, layout.pos.col = 1:2))
print(d, newpage=FALSE)
popViewport()

    # The logo
pushViewport(viewport(layout.pos.row=1, layout.pos.col = 2))
print(grid.draw(g), newpage=FALSE)
popViewport()
popViewport() # Get the logo
img <- readPNG(system.file("img", "Rlogo.png", package="png"))
g <- rasterGrob(img)

# Set the size of the viewport to contain the logo
size = unit(2, "cm")

# Get the graph
d <- ggplot(diamonds, aes(carat, price, fill = ..density..)) + 
     xlim(0, 2) + 
     stat_binhex(na.rm = TRUE) + 
     # labs(title = 'Title') +
     theme(aspect.ratio = 1) + 
     facet_wrap(~ color, scales = "free_x")

# and the title
title = textGrob("Title", gp = gpar(face = "bold", cex = 2))

# Set up the layout for grid 
heights = unit.c(size, unit(1, "npc") - size)
widths = unit.c(unit(1, "npc") - 1.5*size, size)
lo = grid.layout(2, 2, widths = widths, heights = heights)
# Show the layout
grid.show.layout(lo)

# Position the elements within the viewports
grid.newpage()
pushViewport(viewport(layout = lo))

    # The plot
pushViewport(viewport(layout.pos.row=2, layout.pos.col = 1:2))
print(d, newpage=FALSE)
popViewport()

    # The logo
pushViewport(viewport(layout.pos.row=1, layout.pos.col = 2))
print(grid.draw(g), newpage=FALSE)
popViewport()

    # The title
pushViewport(viewport(layout.pos.row=1, layout.pos.col = 1))
print(grid.draw(title), newpage=FALSE)
popViewport()
popViewport()
-------------------------------------------------------------------------------------------------------
ggplot2 0.9.2 grid gtable expression(Y[1]) library(ggplot2); library(grid); library(gtable)
d <- ggplot(diamonds, aes(carat, price, fill = ..density..)) +
    xlim(0, 2) + stat_binhex(na.rm = TRUE) + theme(aspect.ratio = 1)
(d <- d + facet_wrap(~color, ncol = 4))    
# The aim is to change the strip text "D" to expression(Y[1])

# Winston's accessor function:
gt_getgrob <- function(gt, pattern) {
  idx <- grep(pattern, gt$layout$name)
  if (length(idx) > 1)
    stop("More than one match for pattern '", pattern, "'")
  gt$grobs[[idx]]
}

g = ggplotGrob(d)
g$layout    # We want "strip_t-1"
strip <- gt_getgrob(g, "t-1")        # Use the accessor function to extract it.
str(strip)     # Scroll down to "strip.text.x.text.xxx".
               # There you will see the label "D".
               # The label "D" needs to be changed.
               # Take note of the set of numbers "xxx".
               # This is messy - the numbers change.
               # Substitute the numbers for "xxx" in the line below.
               # To do: gsub can be applied here.
strip$children$strip.text.x.text.xxx$label = expression(Y[1])    # Change the label.
grid.draw(strip)       # Yes, it's worked

gt <- ggplot_gtable(ggplot_build(d))  
gtable_show_layout(gt)       # Get the layout of the original plot.

gt = gtable_add_grob(gt, strip, t=3, l=4, b=3, r=4)  # Insert the modified strip element into the plot.
grid.newpage()
grid.draw(gt)
-------------------------------------------------------------------------------------------------------
layout() par(mar = rep(2, 4)) image(as.matrix(leg),col=cx,axes=T) par() par() par() op <- par(oma=c(5,7,1,1)) par(op)
-------------------------------------------------------------------------------------------------------
graphics # Faking the data, since you didn't provide any
Gene <- data.frame(matrix(rweibull(100*4, 1), 100))
names(Gene) <- paste0("Ind", 1:4)
Gene <- rep(list(Gene), 4)

# Setup the panels
layout(t(1:4))
par(oma=c(2, 4, 4, 0), mar=rep(1, 4), cex=1)
# `mar` controls the space around each boxplot group

# Calculating the range so that the panels are comparable
my.ylim <- c(min(sapply(Gene, min)), max(sapply(Gene, max)))

# Plot all the boxes
for(i in 1:length(Gene)){
    boxplot(Gene[[i]], ylim=my.ylim, axes=FALSE)
    mtext(paste("Gene", i), 1, 0)
    if(i == 1){
        axis(2, las=1)
        mtext("Expression or what you have", 2, 3)
    }
}
title("Look at all my genes!", outer=TRUE) Gene[[i]] get(paste0("Gene", i)) my.ylim <- ... min(c(min(Gene1), min(Gene2) ...
-------------------------------------------------------------------------------------------------------
# Some sample data
testMat <- matrix(1:20, ncol = 5)
testMatDF <- as.data.frame(testMat)
names(testMatDF) <- c("Hey there", "Column 2", 
                      "Some * Symbols", "And ^ More", 
                      "Final Column")
rownames(testMatDF) <- paste("Group", 1:4)

# Load the package
library(gplots)
# Set par for plotting a three-row plot
par(mfrow = c(3, 1))
curve(dnorm, -3, +4)
textplot(testMat)
textplot(testMatDF) layout() par(mfrow...) layout(matrix(c(1, 1, 2, 3, 3, 3), 
              2, 3, byrow = TRUE))
curve(dnorm, -3, +4)
textplot(testMat)
textplot(testMatDF)
-------------------------------------------------------------------------------------------------------
plotrix addtable2plot library(plotrix)
testdf<-data.frame(Before=c(10,7,5),During=c(8,6,2),After=c(5,3,4))
rownames(testdf)<-c("Red","Green","Blue")
barp(testdf,main="Test addtable2plot",ylab="Value",
     names.arg=colnames(testdf),col=2:4)
# show most of the options
addtable2plot(2,8,testdf,bty="o",display.rownames=TRUE,hlines=TRUE,
              title="The table") library(plotrix)

layout(matrix(c(1,2), 2, 1, byrow = TRUE),
       widths=c(1,1), heights=c(2,1))


testdf<-data.frame(Before=c(10,7,5),During=c(8,6,2),After=c(5,3,4))
rownames(testdf)<-c("Red","Green","Blue")
barp(testdf,main="Test addtable2plot",ylab="Value",
     names.arg=colnames(testdf),col=2:4)

plot.new()
addtable2plot(0,0,testdf,bty="o",display.rownames=TRUE,hlines=TRUE,
              title="The table")
-------------------------------------------------------------------------------------------------------
library(ggplot2);library(grid)

counts  <- c(80, 27, 66, 94, 33)
defects <- c("price code", "schedule date", "supplier code", "contact num.", "part num.")
dat <- data.frame(count = counts, defect = defects, stringsAsFactors=FALSE )
dat <- dat[order(dat$count, decreasing=TRUE),]
dat$defect <- factor(dat$defect, levels=dat$defect)
dat$cum <- cumsum(dat$count)
count.sum<-sum(dat$count)
dat$cum_perc<-100*dat$cum/count.sum

p1<-ggplot(dat, aes(x=defect, y=cum_perc, group=1))
p1<-p1 + geom_point(aes(colour=defect), size=4) + geom_path()

p1<-p1+ ggtitle('Pareto Chart')+ theme(axis.ticks.x = element_blank(), axis.title.x = element_blank(),axis.text.x = element_blank())
p1<-p1+theme(legend.position="none")

p2<-ggplot(dat, aes(x=defect, y=count,colour=defect, fill=defect))
p2<- p2 + geom_bar()

p2<-p2+theme(legend.position="none")

plot.new()
grid.newpage()
pushViewport(viewport(layout = grid.layout(2, 1)))
print(p1, vp = viewport(layout.pos.row = 1,layout.pos.col = 1))
print(p2, vp = viewport(layout.pos.row = 2,layout.pos.col = 1))
-------------------------------------------------------------------------------------------------------
nf <- layout( c( 1, 2 ), heights= c( 10, 2 ) )
plot( ... )
plot( .... ) matrix( c( 1, 2 ), nrow=2, ncol=1 )
-------------------------------------------------------------------------------------------------------
layout() par(mfrow...) layout layout.show() 1 2 0 [,1] [,2] [,3] [,4]
[1,]    1    1    1    1
[2,]    0    2    2    0 layout() layout(matrix(c(1, 1, 1, 1, 0, 2, 2, 0), 2, 4, byrow=TRUE))
plot(rnorm(n = 10), col = "blue", main = "plot 1", 
     cex.lab = 1.1, ylab="yname", xlab='')
plot(rnorm(n = 10), col = "red", main = "", cex.lab = 1.1, 
     xaxt='n', yaxt='n', xlab="xname", ylab="") heights layout(matrix(c(1, 1, 1, 1, 0, 2, 2, 0), 2, 4, byrow=TRUE), 
       heights = c(7, 3))
plot(rnorm(n = 10), col = "blue", main = "plot 1", 
     cex.lab = 1.1, ylab="yname", xlab='')
plot(rnorm(n = 10), col = "red", main = "", cex.lab = 1.1, 
     xaxt='n', yaxt='n', xlab="xname", ylab="") layout(matrix(c(1, 1, 2, 3), 2, 2, byrow=TRUE))
plot(rnorm(n = 10), col = "blue", main = "plot 1", 
     cex.lab = 1.1, ylab="yname", xlab='')
plot(rnorm(n = 10), col = "red", main = "", cex.lab = 1.1, 
     xaxt='n', yaxt='n', xlab="xname", ylab="")
plot(rnorm(n = 10), col = "green", main = "", cex.lab = 1.1, 
     xaxt='n', yaxt='n', xlab="zname", ylab="")
-------------------------------------------------------------------------------------------------------
gWidgets glayout tbl <- glayout(cont=parent_container)
tbl[1,1] <- "Type" ## or  glabel("Type ", container = tbl)
tbl[1,2] <- (insert.type.input1 <- gradio(items=c("Quantitative", "Qualitative"), container = tbl)) gWidgets2 gformlayout flyt <- gformlayout(cont=parent_container)
insert.type.input1 <- gradio(items=c("Quantitative", "Qualitative"), 
  horizontal=FALSE,
  label = "Type", container = flyt) gWidgets2RGtk2 get_labels <- function(fl) {
  children <- Map(function(x) x$getWidget(), fl$widget$getChildren())
  labels <- Filter(function(x) is(x, "GtkLabel"), children)
  names(labels) <- sapply(labels, function(x) x$getText())
  labels
}

## Then to set the font of a label you can do:
labels <- get_labels(flyt)  
flyt$set_rgtk2_font(labels[["Type"]], list(weight="bold")) set_formlayout_font <- function(fl, value, row) {
  l = tcl("grid", "slaves", fl$widget, row=row-1, column=0)
  fl$set_font_ttk(value, l)
}
set_formlayout_font(fl, list(color="blue"), 2) ## 2nd row
-------------------------------------------------------------------------------------------------------
glayout do_expand=FALSE size<- library(gWidgets)
options(guiToolkit="RGtk2")
w <- gwindow()
g <- ggroup(cont=w)
do_expand=TRUE
options <- glayout(cont=g, spacing=5, expand=do_expand)
items <- ""

options[1,1] = "vanilla"
options[1,2] <- gcombobox(items, cont=options)

options[2,1] = "expand"
options[2,2, expand=TRUE] <- gcombobox(items, cont=options)

options[3,1] = "expand, fill"
options[3,2, expand=TRUE, fill="y"] <- gcombobox(items, cont=options)

options[4,1] = "size"
options[4,2] <- (cb <- gcombobox(items, cont=options))
size(cb) <- c(250, -1)

## populate comboboxes 
items <- state.name 
sapply(options[,2], function(i) i[] <- items)
-------------------------------------------------------------------------------------------------------
Pandas scatter_matrix import numpy as np
import pandas as pd
import matplotlib.pyplot as plt 

df = pd.DataFrame(np.random.randn(1000, 4), columns=['A','B','C','D'])
axes = pd.tools.plotting.scatter_matrix(df, alpha=0.2)
plt.tight_layout()
plt.savefig('scatter_matrix.png') pandas R
-------------------------------------------------------------------------------------------------------
grid.show.layout(gl, vp=viewport(width=1.25, height=1.25))
-------------------------------------------------------------------------------------------------------
gridBase library(grid)
library(gridBase)
library(ggplot2)

# start new page
plot.new() 

# setup layout
gl <- grid.layout(nrow=1, ncol=2)
# grid.show.layout(gl)

# setup viewports
vp.1 <- viewport(layout.pos.col=1, layout.pos.row=1) 
vp.2 <- viewport(layout.pos.col=2, layout.pos.row=1) 
# init layout
pushViewport(viewport(layout=gl))
# access the first position
pushViewport(vp.1)

# start new base graphics in first viewport
par(new=TRUE, fig=gridFIG())

plot(x = 1:10, y = 10:1)

# done with the first viewport
popViewport()

# move to the next viewport
pushViewport(vp.2)

ggplotted <- qplot(x=1:10,y=10:1, 'point')
# print our ggplot graphics here
print(ggplotted, newpage = FALSE)

# done with this viewport
popViewport(1)
-------------------------------------------------------------------------------------------------------
d1 d28 # Get the submatrices
I <- unlist(lapply(0:6, function(a) a:6))
J <- rep(0:6, 7:1)
d2 <- mapply(function(i,j) d[1:6+6*i, 1:6+6*j], I, J, SIMPLIFY=FALSE)

# Setup the layout and add an outer margin for the title and axis labels
layout(matrix(c(1:28, 0, 0), 5, 6))
par(oma=c(3,3,3,1), mar=c(2,2,1,1))

# Plot all the matrices oriented the same way they appear in text
# i.e. the first (vertical) dimension is plotted along the Y-axis
for(k in 1:length(d2)){
    x <- 1:6+6*J[k]
    y <- 1:6+6*I[k]

    # Heatmap & grid
    image(x, y, t(d2[[k]][nrow(d2[[k]]):1,]), las=1, axes=FALSE,
          breaks=c(-1e10, -5.45, -4.65, 4.65, 5.45, 1e10),
          col=c("red","orange","white","orange","red"))
    xg <- apply(!is.na(d2[[k]]), 2, sum)
    yg <- rev(apply(!is.na(d2[[k]]), 1, sum))
    segments(c(x[1]-1, x)+.5, min(y)-.5,
             c(x[1]-1, x)+.5, min(y)+c(6, yg)-.5, xpd=TRUE)
    segments(min(x)-.5,         c(y[1]-1, y)+.5,
             min(x)+c(6,xg)-.5, c(y[1]-1, y)+.5, xpd=TRUE)

    # X & Y-axis values
    mtext(x, 1, .1, at=x, cex=.5)
    mtext(rev(y), 2, .2, at=y, las=1, cex=.5)

    # Values of each cell
    text(rep(x, each=6), rep(rev(y), 6),
     sub("NA", "", sprintf("%.2f", d2[[k]])), cex=.3)
}

# Add title and axis labels
title("All 28 submatrices", outer=TRUE)
mtext("Columns", outer=TRUE, 1, 1)
mtext("Rows", outer=TRUE, 2, 1) xpd segments
-------------------------------------------------------------------------------------------------------
par(mfcol=c(2,1)) varImpPlot layout par data(mtcars)
library(randomForest)

mtcars.rf <- randomForest(mpg ~ ., data=mtcars, ntree=1000, keep.forest=FALSE,
                          importance=TRUE)
varImpData <- varImpPlot(mtcars.rf) # calculate this outside the plot

png("rf1.png", width=6, height=6, units="in", res=100)
layout(matrix(c(1,2,3,3), 2, 2, byrow = TRUE))
dotchart(varImpData[,c(1)])
dotchart(varImpData[,c(2)])
plot(mtcars.rf, log="y")
dev.off()
-------------------------------------------------------------------------------------------------------
layout() layout(matrix(1:4, ncol = 2))
for(i in 1:4)
    plot(1:10)
layout() # reset layout() R> matrix(1:4, ncol = 2)
     [,1] [,2]
[1,]    1    3
[2,]    2    4 byrow = TRUE matrix() R> matrix(1:4, ncol = 2, byrow = TRUE)
     [,1] [,2]
[1,]    1    2
[2,]    3    4 matrix(c(0,1,
         2,2,
         3,4), ncol = 2, byrow = TRUE) 
layout(matrix(c(0,1,2,2,3,4), ncol = 2, byrow = TRUE))
for(i in 1:4)
    plot(1:10)
layout(1) # reset split.screen() mfrow mfcol op <- par(mfrow = c(2,2))
for(i in 1:4)
    plot(1:10)
par(op)  # reset split.screen() split.screen(c(2,2))
for(i in 1:4) {
    screen(i)
    plot(1:10)
}
close.screen(all = TRUE) # reset split.screen() layout() ?par mar png(file = "foo.png", .....) ## the ..... is where you place options, see ?png

## plotting commands here

dev.off() png("layout.png", height = 600, width = 600, pointsize = 14)
layout(matrix(c(0,1,2,2,3,4), ncol = 2, byrow = TRUE))
for(i in 1:4)
    plot(1:10)
layout(1) # reset
dev.off()
-------------------------------------------------------------------------------------------------------
gWidgets RGtk2 Qt library(gWidgets)
options(guiToolkit="RGtk2")
w <- gwindow("test")
pg <- gpanedgroup(cont=w)
fl <- glayout(cont=pg)
gg <- ggraphics(cont=pg)
size(gg) <- c(600, 600)

fl[1,1] <- "No. points"
fl[1,2] <- no_pts <- gedit("10", cont=fl, coerce.with=as.numeric)
fl[2,2] <- gbutton("click me", cont=fl, label="", handler=function(h,...) {
  n <- svalue(no_pts)
  plot(rnorm(n), rnorm(n))
}) cranvas rgl
-------------------------------------------------------------------------------------------------------
rasterImage grDevices layout layout(matrix(1:2,ncol=2), width = c(2,1),height = c(1,1))
plot(1:20, 1:20, pch = 19, cex=2, col = colfunc(20))

legend_image <- as.raster(matrix(colfunc(20), ncol=1))
plot(c(0,2),c(0,1),type = 'n', axes = F,xlab = '', ylab = '', main = 'legend title')
text(x=1.5, y = seq(0,1,l=5), labels = seq(0,1,l=5))
rasterImage(legend_image, 0, 0, 1,1)
-------------------------------------------------------------------------------------------------------
layout(matrix(1:2,nrow=1),widths=c(0.8,0.2))
colfunc <- colorRampPalette(c("white","black"))

par(mar=c(5.1,4.1,4.1,2.1))
plot(1:10,ann=FALSE,type="n")
grid()
points(1:10,col=colfunc(10),pch=19,cex=1.5)

xl <- 1
yb <- 1
xr <- 1.5
yt <- 2

par(mar=c(5.1,0.5,4.1,0.5))
plot(NA,type="n",ann=FALSE,xlim=c(1,2),ylim=c(1,2),xaxt="n",yaxt="n",bty="n")
rect(
     xl,
     head(seq(yb,yt,(yt-yb)/10),-1),
     xr,
     tail(seq(yb,yt,(yt-yb)/10),-1),
     col=colfunc(10)
    )

mtext(1:10,side=2,at=tail(seq(yb,yt,(yt-yb)/10),-1)-0.05,las=2,cex=0.7)
-------------------------------------------------------------------------------------------------------
#name each of your plots
p2 <- ggplot(subset(dfr_melt, variable=="a"),aes(x=d,y=value)) + facet_grid(variable~.,scales="free")+
  geom_line(subset=.(variable=="a")) + geom_line(subset=.(variable=="b"))

#Upper plot should look like this
p1 <- ggplot(dfr,aes(x=d,y=a)) + geom_line() + geom_line(aes(y=c,color="c"))+
  geom_hline(aes(yintercept=1),linetype="dashed")+
  geom_hline(aes(yintercept=-2),linetype="dashed")

#From Wickham ggplot2, p154
vplayout <- function(x,y) {
  viewport(layout.pos.row=x, layout.pos.col=y)
}

require(grid)
png("myplot.png", width = 600, height = 300) #or use a different device, e.g. quartz for onscreen display on a mac
grid.newpage()
pushViewport(viewport(layout=grid.layout(2, 1)))
print(p1, vp=vplayout(1, 1))
print(p2, vp=vplayout(2, 1))
dev.off()
-------------------------------------------------------------------------------------------------------
layout par widths layout(matrix(c(1,2),nrow=1), widths=c(2,1)) ?layout
-------------------------------------------------------------------------------------------------------
multiplot coefplot multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  require(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}
-------------------------------------------------------------------------------------------------------
plot() plot.eff() par() allEffects() plot() plot.efflist() effLogitFrogs <- allEffects(predictorName, logitFrogs)
plot(effLogitFrogs) for() grid grid.newpage() pushViewport() pushViewport() popViewport() library(lattice)
  library(grid)

  n.col=2
  n.row= 4 
  grid.newpage()      
  pushViewport(viewport(layout = grid.layout(n.row,n.col)))

  predictorName <- attr(logitFrogs$terms, "term.labels")

  for (i in 1:length(predictorName)) {
    print(predictorName[i])
    effLogitFrogs <- effect(predictorName[i], logitFrogs)
    pushViewport(viewport(layout.pos.col=ceiling(i/n.row), layout.pos.row=ifelse(i-n.row<=0,i,i-n.row)))
    p<-plot(effLogitFrogs)
    print(p,newpage=FALSE)
    popViewport(1)
  }
-------------------------------------------------------------------------------------------------------
library(grid) polar <- read.table(text ='
degree value
1    120  0.50
2     30  0.20
3   160  0.20
4     35  0.50
5    150  0.40
6    90  0.14
7    70  0.50
8      20  0.60',header=T)


## function to create axis label
axis.text <- function(col,row,text,angle){
  pushViewport(viewport(layout.pos.col=col,layout.pos.row=row,just=c('top')))
  grid.text(angle,vjust=0) 
  grid.text(text,vjust=2)         
  popViewport()
}

## function to create the arrows, Here I use the data
arrow.custom <- function(polar){
  pushViewport(viewport(layout.pos.col=2,layout.pos.row=2))
  apply(polar,1,function(x){
       pushViewport(viewport(angle=x['degree']))  
          grid.segments(x0=0.5,y0=0.5,x1=0.5+x['value']*0.8,y1=0.5,
          arrow=arrow(type='closed'),gp=gpar(fill='grey'))
       popViewport()
  })
  popViewport()
}


## The global layout 3*3 matrix
lyt=grhs= unit(c(4,15,4), "lines"),heights=unit(c(4,15,4), "lines"),just='center')
pushViewport(viewport(layout=lyt,xscale=2*extendrange(polar$value)))
 ## the central part : circles , arrows and axes
pushViewport(viewport(layout.pos.col=2,layout.pos.row=2))
grid.circle(r=c(0.5,0.3),gp = gpar(ltw=c(3,2),col=c('black','grey')))
arrow.custom(polar)
grid.segments(x0=0.5,y0=0,x1=0.5,y=1,gp=gpar(col='grey'))
grid.segments(x0=0,y0=0.5,x1=1,y=0.5,gp=gpar(col='grey'))
popViewport()

## the axis labels 
axis.text(1,2,'Phragmites',expression(270 * degree))
axis.text(3,2,'Spartina',expression(90 * degree))
axis.text(2,1,'Increasing tropic position',expression(0 * degree))
axis.text(2,3,'Decreasing tropic position',expression(180 * degree))
-------------------------------------------------------------------------------------------------------
my1 <- data.frame (company = rep(c("A", "B", "C"), each = 7), skillsDg = rep(c("Basic", "HighSc", "Undgd", "MAST", "PHD", "EXPD", "EXECT"), 3), number = c(200, 100, 40, 30, 10, 0, 0, 220, 110, 35, 10, 0, 4, 1, 140, 80, 120, 50, 52, 52, 3) )

my2 <- split(my1,my1$company) #split your dataframe into a list where each element is a company
# The next line create the layout
layout(matrix(1:(length(my2)+1), nrow=1), width=c(1,rep(4,length(my2))))
# Then we draw the x-axis:
par(mar=c(3,0,3,0))
plot(NA,axes=F, xlim=c(0,1),ylim=c(1,nlevels(my1$skillsDg)))
axis(side=4,tick=F,labels=unique(my1$skillsDg),
     at=seq_along(unique(my1$skillsDg)), las=2, line=-4)
# Then we apply a graphing function to each company:
lapply(my2,function(x){
    par(mar=c(3,0,3,0))
    plot(NA, xlim=c(-max(my1$number),max(my1$number)), 
             ylim=c(1,nlevels(my1$skillsDg)),axes=F)
    title(sub=x$company[1],line=1)
    abline(h=seq_along(x$skillsDg), col="grey80")
    polygon(x=c(x$number,rev(-1*x$number)), 
            y=c(seq_along(x$skillsDg),rev(seq_along(x$skillsDg))), 
            col=as.numeric(x$company))
    }) lapply layout(matrix(1:(length(my2)+1), nrow=1), width=c(1,rep(4,length(my2))))
par(mar=c(3,0,3,0))
plot(NA,axes=F, xlim=c(0,1),ylim=c(1,nlevels(my1$skillsDg)))
axis(side=4,tick=F,labels=unique(my1$skillsDg),
    at=seq_along(unique(my1$skillsDg)), las=2, line=-4)
lapply(my2,function(x){
    par(mar=c(3,0,3,0))
    plot(NA, xlim=c(-max(my1$number)-50,max(my1$number)+50), 
        ylim=c(1,nlevels(my1$skillsDg)),axes=F)
    title(sub=x$company[1],line=1)
    abline(h=seq_along(x$skillsDg), col="grey80")
    text(x=x$number+5, y=seq_along(x$skillsDg)+.1, label=x$number, pos=4)
    polygon(x=c(x$number,rev(-1*x$number)), 
        y=c(seq_along(x$skillsDg),rev(seq_along(x$skillsDg))), 
        col=as.numeric(x$company))
    })
-------------------------------------------------------------------------------------------------------
ggplot2 layout par(mai = c(0,0,0,0))
layout(c(1,2),heights=c(0.3,1))
plot.new()
legend("bottom", legend = xx, fill=colors, bty="n")
pie(numb, col=colors, labels=numb_labels, clockwise=TRUE)
-------------------------------------------------------------------------------------------------------
knitr ```{r fig.width=10, fig.height=9}
layout( cbind( c(0,0,1,1,1,1,1,0,0), rep(2,9) ) )
plot(...)
plot(...)
```
-------------------------------------------------------------------------------------------------------
mylabd <- data.frame (company = rep(c("A", "B", "C"), each = 7),
                      skillsDg = rep(c("Basic", "HighSc", "Undgd", "MAST", "PHD", "EXPD", "EXECT"), 3),
                      number = c(200, 100, 40, 30, 10, 0, 0,
                                 220, 110, 35, 10, 0, 4, 1,
                                 140, 80, 120, 50, 52, 52, 3)
)



## to comapre we need o have the same scales for all organizations
nskills <- nlevels(mylabd$skillsDg)
ncompany <- nlevels(mylabd$company)
barYscale <- c(0,  nskills) * 1.05
barXscale <- c(0, max(mylabd$number) )* 1.05
## the global scene
vp <- plotViewport(c(5, 4, 4, 1),
                   yscale = barYscale,
                   layout = grid.layout(nrow=1,ncol=nbars))

pushViewport(vp)
grid.rect()
grid.yaxis(at=c(1:nlevels(mylabd$skillsDg)),label=unique(mylabd$skillsDg))
grid.grill()

## split data by companya
data.splitted <- split(mylabd,f=mylabd$company)
lapply(1:3,function(company){

  x <- data.splitted[[company]]
  vv <- x$number
  companyName <- unique(x$company)

  pushViewport(viewport(layout.pos.col=company,    
                        xscale = barXscale,
                        yscale = barYscale))
  grid.rect()
 # grid.xaxis(at= mean(x$number),label = companyName)
  grid.xaxis()
  grid.polygon(x  = unit.c(unit(0.5,'npc')-unit(vv/2,'native'),
                           unit(0.5,'npc')+unit(rev(vv)/2,'native')),
               y  = unit.c(unit(1:nmeasures,'native'),
                           unit(rev(1:nmeasures),'native')),
               gp=gpar(fill = rainbow(nmeasures)[company]))
  grid.polygon(x  = unit.c(unit(0.5,'npc')-unit(vv/2,'native'),
                           unit(0.5,'npc')+unit(rev(vv)/2,'native')),
               y  = unit.c(unit(1:nmeasures,'native'),
                           unit(rev(1:nmeasures),'native')),
               id = c(1:nmeasures,rev(1:nmeasures)),
               gp=gpar(fill = NA))

  grid.text( x = unit(0.5,'npc'),
             y = unit(0.5,'native'),
             label = unique(x$company))

  popViewport()

})

popViewport()
-------------------------------------------------------------------------------------------------------
grid ## transform the jpeg to raster grobs
library(jpeg)
names.axis <-  c("Interphase", "Prophase", "Metaphase", "Anaphase", "Telophase")
images <- lapply(names.axis,function(x){
  img <- readJPEG(paste('lily_',x,'.jpg',sep=''), native=TRUE)
  img <- rasterGrob(img, interpolate=TRUE)
  img
  } )
## main viewports, I divide the scene in 10 rows ans 5 columns(5 pictures)
pushViewport(plotViewport(margins = c(1,1,1,1),
             layout=grid.layout(nrow=10, ncol=5),xscale =c(1,5)))
## I put in the 1:7 rows the plot without axis
## I define my nested viewport then I plot it as a grob.
pushViewport(plotViewport(layout.pos.col=1:5, layout.pos.row=1:7,
             margins = c(1,1,1,1)))
pp <- ggplot() +
  geom_bar(data=myd, aes(y = value, x = phase, fill = cat), 
                 stat="identity",position='dodge') +
  theme_bw()+theme(legend.position="none", axis.title.y=element_blank(),
                   axis.title.x=element_blank(),axis.text.x=element_blank())
gg <- ggplotGrob(pp)
grid.draw(gg)
upViewport()
## I draw my pictures in between rows 8/9 ( visual choice)
## I define a nested Viewport for each picture than I draw it.
sapply(1:5,function(x){
  pushViewport(viewport(layout.pos.col=x, layout.pos.row=8:9,just=c('top')))
  pushViewport(plotViewport(margins = c(5.2,3,4,3)))
  grid.draw(images[[x]])
  upViewport(2)
  ## I do same thing for text 
  pushViewport(viewport(layout.pos.col=x, layout.pos.row=10,just=c('top')))
  pushViewport(plotViewport(margins = c(1,3,1,1)))
    grid.text(names.axis[x],gp = gpar(cex=1.5))
  upViewport(2)
})
pushViewport(plotViewport(layout.pos.col=1:5, layout.pos.row=1:9,
             margins = c(1,1,1,1)))
grid.rect(gp=gpar(fill=NA))
upViewport(2)
-------------------------------------------------------------------------------------------------------
[ handler=function(h,...){  
         browser()
         label <- h$obj[]
         if(!svalue(h$obj)) ## I remove the item
            GraphFiles <<- GraphFiles[GraphFiles!=label]   ## note the use of the global 
                                                              operator
         else               ## I add the item
            GraphFiles  <<- c(GraphFiles,FileNamesOrig[FileNamesOrig==label])

 }) library(gWidgetsRGtk2)
FileNamesOrig <- paste('file',1:3,sep='')
GraphFiles <- FileNamesOrig
w <- gwindow("Tag Density Checkboxes")
g <- ggroup(container = w)
lyt <- glayout(cont = g, horizontal = T)
for(x in seq_along(FileNamesOrig)){
  gcheckbox(FileNamesOrig[x], 
            container=g, 
            checked=TRUE, 
            handler=function(h,...){  
                  label <- h$obj[]
                  if(!svalue(h$obj)) GraphFiles <<- GraphFiles[GraphFiles!=label]
                  else GraphFiles  <<- c(GraphFiles,FileNamesOrig[FileNamesOrig==label])
                 print(GraphFiles) ## edit to show the changes
            })
}
-------------------------------------------------------------------------------------------------------
## I define my plot
p <- ggplot(MeanFrameMelt, aes(x=variable, y=value, color=Legend, group=Legend))+ 
  geom_line()+ 
  theme(panel.background = element_rect(fill='NA', colour='black', size = 1), 
        legend.position = "none")+ 
  ylab("Tag Density (mean coverage/bp)")+ 
  xlab("Distance from reference side (bp)")
## init gwidgets
library(gWidgetsRGtk2)
w   <- gwindow("Tag Density Checkboxes", width = 1000)
g   <- ggroup(container = w, horizontal = FALSE)
gg  <- ggraphics(container=g)
lyt <- glayout(container = g, horizontal = FALSE)
## I plot it the first time 
print(p)
## I add a handler
ID <- addHandlerChanged(gg, handler=function(h,...) {
   p <-  p + scale_x_discrete(breaks=c("V1", "V200", "V400"), 
                     labels=c("-1000", "0", "1000"))
   print(p)
})
print(p)
-------------------------------------------------------------------------------------------------------
image() #using image() function
x<-c(0, 5, 30, 80, 1000)
y<-c(150, 2000, 2010, 3000)
grd <- expand.grid(x=x, y=y)
z<-matrix(grd$x*2-grd$y*3, nrow=length(x), ncol=length(y), byrow=TRUE)
image(x=x, y=y, z=z, col=rainbow(20))

#another option with z-scale
source("image.scale.r") #http://menugget.blogspot.de/2011/08/adding-scale-to-image-plot.html
x11(width=5, height=4)
layout(matrix(1:2, nrow=1, ncol=2), widths=c(4,1), heights=4, respect=TRUE)
layout.show(2)
par(mar=c(4,4,1,1))
image(x=x, y=y, z=z, col=rainbow(20))
par(mar=c(4,0,1,4))
image.scale(z, col=rainbow(20), horiz=FALSE, xlab="", ylab="", xaxt="n", yaxt="n")
axis(4)
box()
-------------------------------------------------------------------------------------------------------
g2 <- delete.edges(g, E(g)[ V(g)[xaulist_att == 'second'] %--% 
                            V(g)[xaulist_att == 'main'  ] ])

## plot the results
coords <- layout.auto(g)
layout(rbind(1:2))
plot(g, layout=coords, main="g")
plot(g2, layout=coords, main="g2") ?iterators
-------------------------------------------------------------------------------------------------------
grid plot ggplot2 ggplot library(ggplot2)
library(grid)

set.seed(23456)
mydf <- data.frame(mydate = seq(as.Date('2012-01-01'), as.Date('2012-12-01'), by = '1 month'),
                   run1 = runif(12, 100, 200),
                   run2 = runif(12, 300, 400),
                   run3 = runif(12, 1000, 2000),
                   run4 = runif(12, 2000, 3000))

p1 <- ggplot(data = mydf) +
         geom_line(aes(x = mydate, y = run1))

p2 <- ggplot(data = mydf) +
         geom_line(aes(x = mydate, y = run2))

p3 <- ggplot(data = mydf) +
         geom_line(aes(x = mydate, y = run3))

p4 <- ggplot(data = mydf) +
         geom_line(aes(x = mydate, y = run4))


png(filename = paste("multipleplot.png", sep = ""), width = 600, height = 600, units = "px", res = NA)
grid.newpage()
pushViewport(viewport(layout = grid.layout(2, 2, widths = c(300, 300))))

vplayout <- function(x, y)
    viewport(layout.pos.row = x, layout.pos.col = y)

print(p1, vp = vplayout(1,1))
print(p2, vp = vplayout(1,2))
print(p3, vp = vplayout(2,1))
print(p4, vp = vplayout(2,2))
dev.off()
-------------------------------------------------------------------------------------------------------
matplotlibrc xtick.direction : out ytick.direction : out import numpy as np
import matplotlib
import matplotlib.pyplot as plt
# Data to be represented
X = np.random.randn(256)

# Actual plotting
fig = plt.figure(figsize=(8,6), dpi=72, facecolor="white")
axes = plt.subplot(111)
heights, positions, patches = axes.hist(X, color='white')

axes.spines['right'].set_color('none')
axes.spines['top'].set_color('none')
axes.xaxis.set_ticks_position('bottom')

# was: axes.spines['bottom'].set_position(('data',1.1*X.min()))
axes.spines['bottom'].set_position(('axes', -0.05))
axes.yaxis.set_ticks_position('left')
axes.spines['left'].set_position(('axes', -0.05))

axes.set_xlim([np.floor(positions.min()), np.ceil(positions.max())])
axes.set_ylim([0,70])
axes.xaxis.grid(False)
axes.yaxis.grid(False)
fig.tight_layout()
plt.show() axes.spines['bottom'].set_position?
-------------------------------------------------------------------------------------------------------
layout(matrix(c(1, 2, 1, 3), ncol=2, byrow=TRUE), widths=c(2, 1)) layout(matrix(c(1, 2, 1, 3), ncol=2, byrow=TRUE), widths=c(2, 1))
color2D.matplot(x=Mvalues, show.values=2, cellcolors=Mcolors, 
                                xlab="x", ylab="y", axes=FALSE, vcex=0.4)
gg2 <- ggplot(diamonds, aes(clarity, fill=cut)) + geom_bar(position="dodge") 
ta <- do.call(arrangeGrob, list(gg2,gg2)) vp <- viewport(height=unit(1, "npc"), width=unit(0.33, "npc"), 
               just="right", x=1, y=0.5) print(ta, vp=vp)
-------------------------------------------------------------------------------------------------------
interp akima age2100 <- read.table("temp.csv",header=TRUE,sep=",")

x <- age2100$x
y <- age2100$y
z <- age2100$z

require(akima)

fld <- interp(x,y,z)

par(mar=c(5,5,1,1))
filled.contour(fld) image image.scale source("image.scale.R") # http://menugget.blogspot.de/2011/08/adding-scale-to-image-plot.html

x11(width=5, height=6)
layout(matrix(c(1,2), nrow=1, ncol=2), widths=c(4,1), height=6, respect=TRUE)
layout.show(2)

par(mar=c(4,4,1,1))
image(fld)
contour(fld, add=TRUE)
points(age2100$x,age2100$y, pch=".", cex=2)

par(mar=c(4,0,1,4))
image.scale(fld$z, xlab="", ylab="", xaxt="n", yaxt="n", horiz=FALSE)
box()
axis(4)
mtext("text", side=4, line=2.5)
-------------------------------------------------------------------------------------------------------
#You need to create an object called my data with your data.frame
#the process will create charts of correlations for the first column versus all others
#and then arrange them in a lattice patter.
#It uses the multiplot function that I found as well as ggplot2

mydata<-mtcars

library(ggplot2)
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  require(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                     ncol = cols, nrow = ceiling(numPlots/cols))
  }

  if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}

mychart <- function(x) {
  c <- round(cor(mydata[,1],mydata[x]),3)
  xmax <-ceiling(max(mydata[,x]))
  xmin <- floor(min(mydata[,x]))
  xpos = floor(max(mydata[,x])*(8/10))
  ypos = floor(max(mydata[,1])*(8/10))
  t = paste("rho ==",c,sep="")
  t1 <- annotate("text",x=xpos,y=ypos,label=t,parse=TRUE,color="red")
  p <- qplot(mydata[,x],mydata[,1],xlab=x,ylab=names(mydata)[1],color=I("blue"))
  s <- stat_smooth(aes(x=mydata[,x],y=mydata[,1]),method="lm",color="red",se=FALSE)
  a <- annotate("text",x=xpos,y=ypos,label=t,parse=TRUE,color="red")
  p<- p+s+a+xlim(xmin,xmax)

}


charts <- NULL
l1 <- NULL
for (i in 2:(length(mydata))) {
  charts[[i]]<- mychart(names(mydata)[i])
}

numcols <- ceiling(sqrt(length(mydata)-1))

multiplot(plotlist=charts[2:length(mydata)],cols=numcols)
-------------------------------------------------------------------------------------------------------
df$c <- factor(df$c, levels=levels(df$c)[order(df$d)]) grid.newpage()
pushViewport(viewport(layout = grid.layout(1, 2))) a_df <- df[df$a=="A",]
a_df$c <- factor(a_df$c, levels=levels(a_df$c)[order(a_df$d)])

a_p <- ggplot(a_df, aes(x=1:10, y=d, fill=b)) +
facet_grid(. ~ a) +
geom_bar(stat="identity", position="dodge")

print(a_p, vp = viewport(layout.pos.row=1, layout.pos.col=1)) b_df <- df[df$a=="B",]
b_df$c <- factor(b_df$c, levels=levels(b_df$c)[order(b_df$d)])

b_p <- ggplot(b_df, aes(x=1:10, y=d, fill=b)) +
facet_grid(. ~ a) +
geom_bar(stat="identity", position="dodge")

print(b_p, vp = viewport(layout.pos.row=1, layout.pos.col=2))
-------------------------------------------------------------------------------------------------------
###   The bowl
win     <- gwindow( "Fruits")
gui     <- glayout( container = win )

###   Fruit salad  
tmp <- list(
  t1 = gui[1,1] <- glabel( "Apple", cont = gui ),
  t2 = gui[1,2] <- gbutton( "Change", cont = gui ) )

nav1 <- function( tmp )
{
  svalue( tmp$t1 ) <- "Banana" 
}

addHandlerClicked( tmp$t2, handler = function( h, ... )
{ 
  nav1( tmp )
})
-------------------------------------------------------------------------------------------------------
layout() matrix() plot.new() text() x<-1:10
par(mar=c(2.5,2.5,1,1))
layout(matrix(c(1,2,3,4,1,5,3,6),ncol=2),heights=c(1,3,1,3))
plot.new()
text(0.5,0.5,"First title",cex=2,font=2)
plot(x)
plot.new()
text(0.5,0.5,"Second title",cex=2,font=2)
hist(x)
boxplot(x)
barplot(x)
-------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------
layout(matrix(1:8, nrow=2, ncol=4, byrow=TRUE)) # Graph matrix
sapply(names(mtcars[1:8]), FUN=function(X) plot(mtcars[[X]], main=X))
-------------------------------------------------------------------------------------------------------
layout layout mfrow mfcol par(mfrow = c(1, 4)) layout(matrix(c(1, 3, 2, 4), byrow=TRUE, ncol=4)) layout(matrix(c(1, 2, 3, 4), byrow=TRUE, ncol=4)) layout.show() layout.show(4)
-------------------------------------------------------------------------------------------------------
Arial <- Type1Font(family = "Arial", metrics = c("C:/R_Fonts/ArialPlain.afm", "C:/R_Fonts/ArialBold.afm", "C:/R_Fonts/ArialItalic.afm", "C:/R_Fonts/ArialBoldItalic.afm"))
pdfFonts(Arial = Arial)

setwd("C:/PDFCrop")
D1<-matrix(c(1,2,3,4,6,3),3,2)
D2<-matrix(c(1,2,3,5,3,1),3,2)

pdf("Test_Auto.pdf", width=8.3, height=12, family = "Arial")
#win.graph(8.3,12,12)
layout(matrix(c(1,2),1,2,byrow=TRUE))
plot(D1,type="l",main="Gobble R")
plot(D2,type="l",main="Gobble R")
dev.off()
-------------------------------------------------------------------------------------------------------
add.my.layout <- function(g) {
    g + scale_fill_gradientn(guide="colourbar",colours=costum.colorbar_sand.blue.green)+
      theme (legend.title = element_text(size = 15,family="Arial"))+
      theme (legend.text = element_text(size = 12,family="Arial",angle=45))+
      theme (legend.position = "bottom")+
      coord_map(projection="mercator")
} myggplot <- ggplot(...)
add.my.layout(myggplot)
-------------------------------------------------------------------------------------------------------
from rpy2.robjects.lib import ggplot2
from rpy2.robjects import r, Formula

iris = r('iris')

p = ggplot2.ggplot(iris) + \
    ggplot2.geom_point(ggplot2.aes_string(x="Sepal.Length", y="Sepal.Width")) + \
    ggplot2.facet_wrap(Formula('~ Species'), ncol=2, nrow = 2) + \
    ggplot2.GBaseObject(r('ggplot2::coord_fixed')()) # aspect ratio
# coord_fixed() missing from the interface, 
# therefore the hack. This should be fixed in rpy2-2.3.3

p.plot() par(mfrow(c(2,2)) par(mfcol(c(2,2))) grid from rpy2.robjects.vectors import FloatVector

from rpy2.robjects.lib import grid
grid.newpage()
lt = grid.layout(2,2) # 2x2 layout
vp = grid.viewport(layout = lt)
vp.push()


# limits for axes and tickmarks have to be known or computed beforehand
xlims = FloatVector((4, 9))
xbreaks = FloatVector((4,6,8))
ylims = FloatVector((-3, 3))
ybreaks = FloatVector((-2, 0, 2))

# first panel
vp_p = grid.viewport(**{'layout.pos.col':1, 'layout.pos.row': 1})
p = ggplot2.ggplot(iris) + \
    ggplot2.geom_point(ggplot2.aes_string(x="Sepal.Length",
                                          y="rnorm(nrow(iris))")) + \
    ggplot2.GBaseObject(r('ggplot2::coord_fixed')()) + \
    ggplot2.scale_x_continuous(limits = xlims, breaks = xbreaks) + \
    ggplot2.scale_y_continuous(limits = ylims, breaks = ybreaks)
p.plot(vp = vp_p)
# third panel
vp_p = grid.viewport(**{'layout.pos.col':2, 'layout.pos.row': 2})
p = ggplot2.ggplot(iris) + \
    ggplot2.geom_point(ggplot2.aes_string(x="Sepal.Length",
                                          y="rnorm(nrow(iris))")) + \
    ggplot2.GBaseObject(r('ggplot2::coord_fixed')()) + \
    ggplot2.scale_x_continuous(limits = xlims, breaks = xbreaks) + \
    ggplot2.scale_y_continuous(limits = ylims, breaks = ybreaks)
p.plot(vp = vp_p)
-------------------------------------------------------------------------------------------------------
vplayout <- function(x, y) viewport(layout.pos.row = x, layout.pos.col = y)
grid.newpage()
pushViewport(viewport(layout = grid.layout(1, 2)))
print(a, vp = vplayout(1,1))
print(b, vp = vplayout(1,2)) a b a, b, ... tmPlot grid.newpage new.page FALSE newpage
-------------------------------------------------------------------------------------------------------
grid.arrange layout library(ggplot2)
library(gridExtra)
ch1 <- qplot(1,2)
ch2 <- qplot(1,2)
ch3 <- qplot(1,2)
ch4 <- qplot(1,2)

png(filename = "fname.png", width = 900, height = 600, units = 'px')
grid.arrange(ch1,ch2,ch3,ch4, ncol = 2)
dev.off() layout "" png(filename = "fname.png", width = 900, height = 600, units = 'px')
layout(matrix(c(1,2,3,4), 2, 2, byrow = TRUE))
plot(1,2)
plot(1,2)
plot(1,2)
plot(1,2)
dev.off()
-------------------------------------------------------------------------------------------------------
vplayout <- function(x, y) viewport(layout.pos.row = x, layout.pos.col = y)
grid.newpage()
pushViewport(viewport(layout = grid.layout(1, 2)))
tmPlot(GNI2010,
  index="continent",
  vSize="population",
  vColor="GNI",
  type="value",
  vp = vplayout(1,1))
tmPlot(GNI2010,
  index=c("continent", "iso3"),
  vSize="population",
  vColor="GNI",
  type="value",
  vp = vplayout(1,2))
-------------------------------------------------------------------------------------------------------
#Set alignment for tow plots. Extra zeros are needed to get space for axis at bottom.
layout(matrix(c(0,1,2,0),ncol=1),heights=c(1,3,3,1))

#Set spaces around plot (0 for bottom and top)
par(mar=c(0,5,0,5))

#1. plot
plot(df$V2~df$TIME2,type="l",xlim=c(1000,2000),axes=F,ylab="")

#Two rectangles - y coordinates are larger to ensure that all space is taken  
rect(1100,-15000,1300,15000,col="red",border="red")
rect(1800,-15000,1850,15000,col="red",border="red")

#plot again the same line (to show line over rectangle)
par(new=TRUE)
plot(df$V2~df$TIME2,type="l",xlim=c(1000,2000),axes=F,ylab="")

#set axis
axis(1,at=seq(800,2200,200),labels=NA)
axis(4,at=seq(-15000,10000,5000),las=2)


#The same for plot 2. rev() in ylim= ensures reverse axis.
plot(df$VARIABLE1~df$TIME1,type="l",ylim=rev(range(df$VARIABLE1)+c(-0.1,0.1)),xlim=c(1000,2000),axes=F,ylab="")
rect(1100,-15000,1300,15000,col="red",border="red")
rect(1800,-15000,1850,15000,col="red",border="red")
par(new=TRUE)
plot(df$VARIABLE1~df$TIME1,type="l",ylim=rev(range(df$VARIABLE1)+c(-0.1,0.1)),xlim=c(1000,2000),axes=F,ylab="")
axis(1,at=seq(800,2200,200))
axis(2,at=seq(-6.4,-8.4,-0.4),las=2) rect1<- data.frame (xmin=1100, xmax=1300, ymin=-Inf, ymax=Inf)
rect2 <- data.frame (xmin=1800, xmax=1850, ymin=-Inf, ymax=Inf) data aes geom_line() geom_rect() plot.margin= theme() -1 p1 p2 p2 library(ggplot2)
library(grid)
library(gridExtra)
p1<- ggplot() + geom_line(data=df, aes(TIME1, VARIABLE1)) + 
  scale_y_reverse() + 
  labs(x="AGE") + 
  scale_x_continuous(breaks = seq(1000,2000,200), limits = c(1000,2000)) + 
   geom_rect(data=rect1,aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymax),alpha=0.1,fill="blue")+
   geom_rect(data=rect2,aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymax),alpha=0.1,fill="blue")+
   theme(plot.margin = unit(c(-1,0.5,0.5,0.5), "lines"))

p2<- ggplot() + geom_line(data=df, aes(TIME2, V2)) + labs(x=NULL) + 
  scale_x_continuous(breaks = seq(1000,2000,200), limits = c(1000,2000)) + 
  scale_y_continuous(limits=c(-14000,10000))+
  geom_rect(data=rect1,aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymax),alpha=0.1,fill="blue")+
  geom_rect(data=rect2,aes(xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymax),alpha=0.1,fill="blue")+
  theme(axis.text.x=element_blank(),
        axis.title.x=element_blank(),
        plot.title=element_blank(),
        axis.ticks.x=element_blank(),
        plot.margin = unit(c(0.5,0.5,-1,0.5), "lines"))


gp1<- ggplot_gtable(ggplot_build(p1))
gp2<- ggplot_gtable(ggplot_build(p2))
maxWidth = unit.pmax(gp1$widths[2:3], gp2$widths[2:3])
gp1$widths[2:3] <- maxWidth
gp2$widths[2:3] <- maxWidth
grid.arrange(gp2, gp1)
-------------------------------------------------------------------------------------------------------
layout [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
[1,]    1    1    1    1    1    1    1    1    1     1
[2,]    2    3    4    5    6    7    8    9   10    11


layout(matrix(c(rep(1,10),2:11),nrow=2,byrow=T))
 x=c(1,2,3324,324)
 y=c(1,2,32,2323)
 plot(x,y)
 replicate(n=10,plot(x,y)) mat <- matrix(c(rep(1,10),2:11),nrow=2,byrow=T)
layout(mat, widths = c(rep(1,5),rep(2,3),rep(3,2))) layout.show layout.show(n = 11)
-------------------------------------------------------------------------------------------------------
par() layout() plot() layout(matrix(c(rep(1,10),2:11),nrow=2,byrow=T),width=c(1,2,1,1,1,1,1,1,1,1,1))
par(mar=c(0,0,0,0))      
plot(1:10, xaxt='n',yaxt='n', ann=FALSE)
......
-------------------------------------------------------------------------------------------------------
mtext par(bg="lightyellow", mar=c(2,2,2,2))
 layout(matrix(c(rep(1,12),2:13),nrow=2,byrow=T))

 replicate(13,
           {  plot(x=1:5,y=cumsum(1:5),type="l",xaxt="n",yaxt="n",ann=FALSE)
              mtext(text='TEST',side=1,line=1)
              mtext(text='dsads',side=2,line=1)

              }) par(bg="lightyellow", mar=c(2,2,2,0))
 layout(matrix(c(rep(1,12),2:13),nrow=2,byrow=T))
 for(i in 1:13){  
              if (i %in% 1:2){
                plot(x=1:5,y=cumsum(1:5),type="l",xaxt="n",yaxt="n",ann=FALSE)
                  mtext(text='TEST',side=1,line=1)
                  mtext(text='dsads',side=2,line=1)
              }else{
                par( mar=c(2,0,2,0))
                plot(x=1:5,y=cumsum(1:5),type="l",xaxt="n",yaxt="n",ann=FALSE)
              }
          }
-------------------------------------------------------------------------------------------------------
widths= 1 months widths=months months<-c( 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)    
layout(matrix(c(rep(1,12),2:13),nrow=2,byrow=T),widths=months)
layout.show(n = 13)
-------------------------------------------------------------------------------------------------------
xts monthly.apply library(xts)
days <- seq.Date( as.Date("2011-01-01"), as.Date("2011-12-31") ,1)
dat <- xts(rnorm(365),days)

## I use monthly apply to compute months widths.
## no need to give them by hand.
widths <-  coredata(apply.monthly(dat,length))
par(bg="lightyellow", mar=c(2,2,2,0))
layout(matrix(c(rep(1,12),2:13),nrow=2,byrow=T),widths=widths*2)

mon <- months(days,abbreviate=T)
plot(dat,main = 'my year time series')

apply.monthly(dat,function(x) {
  if(unique(format((index(x)),'%m')) =='01') {#JAN
    par(mar=c(2,2,2,0))   ## special case of JAN because it contians y axis 
    plot(x,main='')
  }
  else{
    par( mar=c(2,0,2,0))
    plot(x,main='',ylab='')
  }
})
-------------------------------------------------------------------------------------------------------
ape phylo library(ape)
dat <- read.tree(file="your/newick/file")
#or
dat <- read.tree(text="((A:4.2,B:4.2):3.1,C:7.3);") dendrogram data(bird.orders) #This is already a phylo object
hc <- as.hclust(bird.orders) #Compulsory step as as.dendrogram doesn't have a method for phylo objects.
dend <- as.dendrogram(hc)
plot(dend, horiz=TRUE) mat <- matrix(rnorm(23*23),nrow=23, dimnames=list(sample(bird.orders$tip, 23), sample(bird.orders$tip, 23))) #Some random data to plot ord.mat <- mat[bird.orders$tip,bird.orders$tip] heatmap heatmap(ord.mat, Rowv=dend, Colv=dend) heatmap.phylo <- function(x, Rowp, Colp, ...){
    # x numeric matrix
    # Rowp: phylogenetic tree (class phylo) to be used in rows
    # Colp: phylogenetic tree (class phylo) to be used in columns
    # ... additional arguments to be passed to image function
    x <- x[Rowp$tip, Colp$tip]
    xl <- c(0.5, ncol(x)+0.5)
    yl <- c(0.5, nrow(x)+0.5)
    layout(matrix(c(0,1,0,2,3,4,0,5,0),nrow=3, byrow=TRUE),
                  width=c(1,3,1), height=c(1,3,1))
    par(mar=rep(0,4))
    plot(Colp, direction="downwards", show.tip.label=FALSE,
               xlab="",ylab="", xaxs="i", x.lim=xl)
    par(mar=rep(0,4))
    plot(Rowp, direction="rightwards", show.tip.label=FALSE, 
               xlab="",ylab="", yaxs="i", y.lim=yl)
    par(mar=rep(0,4), xpd=TRUE)
    image((1:nrow(x))-0.5, (1:ncol(x))-0.5, x, 
           xaxs="i", yaxs="i", axes=FALSE, xlab="",ylab="", ...)
    par(mar=rep(0,4))
    plot(NA, axes=FALSE, ylab="", xlab="", yaxs="i", xlim=c(0,2), ylim=yl)
    text(rep(0,nrow(x)),1:nrow(x),Rowp$tip, pos=4)
    par(mar=rep(0,4))
    plot(NA, axes=FALSE, ylab="", xlab="", xaxs="i", ylim=c(0,2), xlim=xl)
    text(1:ncol(x),rep(2,ncol(x)),Colp$tip, srt=90, pos=2)
    } heatmap.phylo(mat, bird.orders, bird.orders) cat("owls(((Strix_aluco:4.2,Asio_otus:4.2):3.1,Athene_noctua:7.3):6.3,Tyto_alba:13.5);",
    file = "ex.tre", sep = "\n")
tree.owls <- read.tree("ex.tre")
mat2 <- matrix(rnorm(4*4),nrow=4, 
             dimnames=list(sample(tree.owls$tip,4),sample(tree.owls$tip,4)))
is.ultrametric(tree.owls)
[1] FALSE
heatmap.phylo(mat2,tree.owls,tree.owls)
-------------------------------------------------------------------------------------------------------
# Making some fake data
plot1 <- data.frame(x=sample(x=1:10,10,replace=FALSE),
                    y=sample(x=1:10,10,replace=FALSE))
plot2 <- data.frame(x=sample(x=1:10,10,replace=FALSE),
                    y=sample(x=1:10,10,replace=FALSE))
plot3 <- data.frame(x=sample(x=1:10,10,replace=FALSE),
                    y=sample(x=1:10,10,replace=FALSE))

layout(matrix(c(2,1,1,3,1,1),2,3,byrow=TRUE))
plot(plot1$x,plot1$y)
plot(plot2$x,plot2$y)
plot(plot3$x,plot3$y) matrix layout matrix(c(2,1,1,3,1,1),byrow=TRUE) [,1] [,2] [,3]
[1,]    2    1    1
[2,]    3    1    1 layout layout(matrix(c(1,1,2,1,1,1),2,3,byrow=TRUE))
plot1 <- data.frame(x=1:10,y=c(9,10,8,7,3,4,1,2,5,6))
plot2 <- data.frame(x=1:10,y=c(6,7,5,1,2,8,3,10,9,4))
plot(plot1$x,plot1$y,type="o",col="red")
plot(plot2$x,plot2$y,type="o",xlab="",ylab="",main="",sub="",col="blue") [,1] [,2] [,3]
[1,]    1    1    2
[2,]    1    1    1
-------------------------------------------------------------------------------------------------------
wordcloud() wordcloud par(mfrow=...) layout() text() layout() ?wordcloud library(tm)
library(wordcloud)

x <- "Many years ago the great British explorer George Mallory, who 
was to die on Mount Everest, was asked why did he want to climb 
it. He said, \"Because it is there.\"

Well, space is there, and we're going to climb it, and the 
moon and the planets are there, and new hopes for knowledge 
and peace are there. And, therefore, as we set sail we ask 
God's blessing on the most hazardous and dangerous and greatest 
adventure on which man has ever embarked."

layout(matrix(c(1, 2), nrow=2), heights=c(1, 4))
par(mar=rep(0, 4))
plot.new()
text(x=0.5, y=0.5, "Title of my first plot")
wordcloud(x, main="Title")
-------------------------------------------------------------------------------------------------------
ggplot2 library('ggplot2')
qplot(x = carat, data = diamonds, geom = "histogram", binwidth = 0.1) library('grid')
a <- qplot(x = carat, data = diamonds, geom = "histogram", binwidth = 0.1)
b <- qplot(x = carat, data = diamonds, geom = "histogram", binwidth = 0.1)

vplayout <- function(x, y) viewport(layout.pos.row = x, layout.pos.col = y)
grid.newpage()
pushViewport(viewport(layout = grid.layout(2, 1)))
print(a, vp = vplayout(1,1))
print(b, vp = vplayout(2,1))
-------------------------------------------------------------------------------------------------------
makevp.eqsc trace("makevp.eqsc",edit=TRUE) function (xrange, yrange) 
{
    pushViewport(plotViewport(name = "Vennmar", c(1, 1, 1, 1)))
    pushViewport(viewport(name = "Vennlay", layout =
 grid.layout(1, 1, widths = diff(xrange), heights = diff(yrange), respect = TRUE)))
    pushViewport(viewport(name = "Vennvp", layout.pos.row = 1, 
        layout.pos.col = 1, xscale = xrange, yscale = yrange))
} grid.layout function (xrange, yrange) 
{
    pushViewport(plotViewport(name = "Vennmar", c(1, 1, 1, 1)))
    pushViewport(viewport(name = "Vennlay", layout = 
grid.layout(2, 1, widths = diff(xrange), heights = diff(yrange), respect = TRUE)))
    pushViewport(viewport(name = "Vennvp", layout.pos.row = number, 
        layout.pos.col = 1, xscale = xrange, yscale = yrange))
} number<-1 #change the argument inside of makevp.eqsc
plot(VennCompare, doWeights=FALSE)
number<-2
plot(VennCompare, doWeights=TRUE, 
  show = list(SetLabels = TRUE, Faces = FALSE),add=TRUE) #note add=TRUE makevp.eqsc
-------------------------------------------------------------------------------------------------------
# Some vector of upper bounds for each plot which you can determine beforehand
ul <- c(20,25,30,35)
# Layout for printing plots (obviously you can handle this part however you like, this is just an example)
vplayout <- function(x, y) viewport(layout.pos.row = x, layout.pos.col = y)

# Make some sensible number of rows/columns for plot page
x <- floor(sqrt(length(ul)))
y <- ceiling( length(ul) / x )

# Make list to hold plots
plots <- as.list( 1:length(ul) )
dim( plots ) <- c( x , y )


# Store plots with variable upper limit variable each time 
for( i in plots ){
        plots[[i]] <- ggplot(mtcars, aes(wt, mpg)) + geom_point()  + scale_y_continuous( limits = c( 15,ul[i]) , expand = c( 0 , 0 ) )
}


# Print the plots
grid.newpage()
pushViewport(viewport(layout = grid.layout(x, y)))
for( i in 1:x){
    for( j in 1:y){
        print( plots[[ i , j ]] , vp = vplayout( i , j ) )
        }
    }
-------------------------------------------------------------------------------------------------------
heatmap.2 lmat lhei lwid heatmap.2 layout layout(mat = lmat, widths = lwid, heights = lhei) lmat lmat lmat > rbind(4:3,2:1)
     [,1] [,2]
[1,]    4    3
[2,]    2    1 > lmat = rbind(c(0,3),c(2,1),c(0,4))
> lmat
     [,1] [,2]
[1,]    0    3
[2,]    2    1
[3,]    0    4 lwid lhei c(1.5,4) lmat >lwid = c(1.5,4)
>lhei = c(1.5,4,1) >heatmap.2(x,...,lmat = lmat, lwid = lwid, lhei = lhei) ?layout layout
-------------------------------------------------------------------------------------------------------
layout(matrix(c(1,2),nrow=1),width=c(4,1)) #Divide your plotting region in two inequal part
par(mar=c(5,4,4,0)) #Get rid of the margin on the right side
plot(NA,xlim=c(0,1),ylim=c(0,1),
     xlab=expression(delta),ylab="K", xaxs="i",yaxs="i") # Here's your delta
a1 <- curve((x+x^7-x^2-x^4)/(1+x-x^3-x^4), from=0, n=450000, add = TRUE)

...

par(mar=c(5,0,4,2)) #No margin on the left side
plot(c(0,1),type="n", axes=F, xlab="", ylab="") #Empty plot
legend("top",legend=c("1","2","3","4","5"), 
       density=c(20,20,20,20,NA), angle=c(90,0,45,135,NA), 
       col=c(NA,NA,NA,NA,"black"), bty="n", cex=1.5) text mtext locator par(mar=c(5,4,4,8))
plot(NA,xlim=c(0,1),ylim=c(0,1),
     xlab=expression(delta),ylab="K", xaxs="i",yaxs="i") # Here's your delta
     a1 <- curve((x+x^7-x^2-x^4)/(1+x-x^3-x^4), from=0, n=450000, add = TRUE)

...

legend(1,1,legend=c("1","2","3","4","5"), 
   density=c(20,20,20,20,NA), angle=c(90,0,45,135,NA), 
   col=c(NA,NA,NA,NA,"black"), bty="n", cex=1.5, xpd=TRUE)
-------------------------------------------------------------------------------------------------------
axis() axis.Date() axis.POSIXct() ## example with axis.Date
layout(matrix(c(1,2),nrow=2,byrow=TRUE))
random.dates <- as.Date("2001/1/1") + 70*sort(stats::runif(100))
plot(random.dates, 1:100, xaxt="n",main='pretty axes dates')
axis.Date(1, at=seq(as.Date("2001/1/1"), max(random.dates)+6, "weeks"))
### example with axis.POSIXct
with(beaver1, {
  time <- strptime(paste(1990, day, time %/% 100, time %% 100),
                   "%Y %j %H %M")
  # now label every hour on the time axis
  plot(time, temp, type="l", xaxt="n",main='pretty axes times')
  r <- as.POSIXct(round(range(time), "hours"))
  axis.POSIXct(1, at=seq(r[1], r[2], by="hour"), format="%H:%M")
})
-------------------------------------------------------------------------------------------------------
spline splinefun layout(matrix(c(1,2,3),nrow=3,byrow=TRUE))
plot(NA,xlim=c(0,1),ylim=c(0,0.2),xlab="delta",ylab="K", xaxs="i",yaxs="i",
     main='orginal plot with 45000 points') # Empty plot
a1 <- curve((x+x^7-x^2-x^4)/(1+x-x^3-x^4), from=0, n=45000, add = TRUE)
x <- seq(0,1,length.out=1000)
y <- (x+x^7-x^2-x^4)/(1+x-x^3-x^4)
f <- splinefun(x, y)
plot(NA,xlim=c(0,1),ylim=c(0,0.2),xlab="delta",ylab="K", xaxs="i",yaxs="i",
     main='splinefun plot with 1000 points') 
curve(f(x),0, 1, col = "green", lwd = 1.5,add=TRUE)
plot(NA,xlim=c(0,1),ylim=c(0,0.2),xlab="delta",ylab="K", xaxs="i",yaxs="i",
     main='spline plot with 1000 points') 
lines(spline(x,y), col = 2)
-------------------------------------------------------------------------------------------------------
```{r fig.width=7, fig.height=6}
library(grid)
library(ggplot2)
grid.newpage()
pushViewport(viewport(layout = grid.layout(1, 2)))
vplayout <- function(x, y)
  viewport(layout.pos.row = x, layout.pos.col = y)
k1 <- ggplot(mtcars, aes(factor(cyl), mpg))  + geom_boxplot()
print(k1, vp = vplayout(1, 1))
print(k1, vp = vplayout(1,2))
```
-------------------------------------------------------------------------------------------------------
grid.rect viewport pushViewport(plotViewport(c(5,5,5,5)))
grid.rect()
grid.rect(width=unit(1, "npc")-unit(0.5,'lines'),
          height=unit(1, "npc")-unit(0.5,'lines'))
pushViewport(plotViewport(c(1,1,1,1),
                      layout = grid.layout(4, 2, heights =     unit(c(1,5,5,5), "null")))) 
grid.text("Summer Clear Day- August 2, 2012", 
          vp = viewport(layout.pos.row = 1, layout.pos.col = 1:2))
k1 <- ggplot(mtcars, aes(factor(cyl), mpg))  + geom_boxplot()

print(k1, vp = viewport(layout.pos.row = 2, layout.pos.col = 1))
print(k1, vp = viewport(layout.pos.row = 2, layout.pos.col = 2))
print(k1, vp = viewport(layout.pos.row = 3, layout.pos.col = 1))
print(k1, vp = viewport(layout.pos.row = 3, layout.pos.col = 2))
print(k1, vp = viewport(layout.pos.row = 4, layout.pos.col = 1))
print(k1, vp = viewport(layout.pos.row = 4, layout.pos.col = 2))
upViewport(2)
-------------------------------------------------------------------------------------------------------
lapply ids <- unique(positions$ID)
layout(matrix(1:(length(ids)*3),ncol=3,byrow=TRUE)) lapply(ids,function(myID){
  number1 <-subset(positions,subset=(ID==myID))
  .....

  # GForce calculation
  plot(number1$Timestamp,GForce)    ## I change one line 

   ...
  sum(GForce[3:max])
})
-------------------------------------------------------------------------------------------------------
cors<-round(cor(samples),2) #correlations

# make layout for plot layout
laymat<-diag(1:5) #histograms
laymat[upper.tri(laymat)]<-6:15 #correlations
laymat[lower.tri(laymat)]<-16:25 #heatmaps

layout(laymat) #define layout using laymat

par(mar=c(2,2,2,2)) #define marginals etc.

# Draw histograms, tweak arguments of hist to make nicer figures
for(i in 1:5) 
  hist(samples[,i],main=names(samples)[i])

# Write correlations to upper diagonal part of the graph
# Again, tweak accordingly
for(i in 1:4)
  for(j in (i+1):5){
    plot(-1:1,-1:1, type = "n",xlab="",ylab="",xaxt="n",yaxt="n")
    text(x=0,y=0,labels=paste(cors[i,j]),cex=2)
    }

# Plot heatmaps, here I use kde2d function for density estimation
# image function for generating heatmaps
library(MASS)
for(i in 2:5)
  for(j in 1:(i-1)){
     k <- kde2d(samples[,i],samples[,j])
     image(k,col=heat.colors(1000))
    }
-------------------------------------------------------------------------------------------------------
layout layout(rbind(c(1, 2),c(3, 3),c(4, 5)),heights=c(3, 1.5, 3),respect=FALSE)
tN <- table(Ni <- stats::rpois(100, lambda = 5))
barplot(tN, col = 2:3)
barplot(tN, col = 2:3)
plot.new()
#box()
text(0.5,0.5,'legend in center',cex=3)
barplot(tN, col = 2:3)
barplot(tN, col = 2:3)
-------------------------------------------------------------------------------------------------------
grid grid.layout pushViewport(plotViewport(layout=grid.layout(1, 2),gp=gpar(cex=2)))
pushViewport(plotViewport(layout.pos.col=1))
  grid.draw(getPlot())
popViewport()
pushViewport(plotViewport(layout.pos.col=2, clip="on"))
  grid.draw(getPlot(col.fill='black',col.text='red',text='Rouge',x=0))
popViewport()
popViewport() getPlot gList getPlot <- function(col.fill="red",col.text='black',text="Noir",x=1){
  rect1 <- rectGrob(gp=gpar(fill=col.fill))
  text1 <- textGrob(text,gp=gpar(col=col.text))
  text2 <- textGrob("&", x=x,gp=gpar(col=col.text))
  gList(rect1,text1,text2)
}
-------------------------------------------------------------------------------------------------------
layout layout layout( matrix(c(1,1,1,2,3,3,3,3), 4, 2, byrow = TRUE) )
## show the regions that have been allocated to each plot
layout.show(3) subplot library(TeachingDemos)
layout(matrix(c(1,1,0,2),2,2,TRUE))
plot(1)
subplot(plot(1), x = c(1.2),y=0.8)
plot(2)
-------------------------------------------------------------------------------------------------------
# libraries
library(VennDiagram)
library(grid)
library(gridBase)
library(lattice)

# create the diagrams
temp1 <- venn.diagram(list(B = 1:1800, A = 1571:2020),
    fill = c("red", "green"), alpha = c(0.5, 0.5), cex = 1,cat.fontface = 2,
    lty =2, filename = NULL)
temp2 <- venn.diagram(list(A = 1:1800, B = 1571:2020),
    fill = c("red", "green"), alpha = c(0.5, 0.5), cex = 1,cat.fontface = 2,
    lty =2, filename = NULL)    


# start new page
plot.new() 

pdf("testpdf", width = 14, height = 7)
# setup layout
gl <- grid.layout(nrow=1, ncol=2)
# grid.show.layout(gl)

# setup viewports
vp.1 <- viewport(layout.pos.col=1, layout.pos.row=1) 
vp.2 <- viewport(layout.pos.col=2, layout.pos.row=1) 

# init layout
pushViewport(viewport(layout=gl))
# access the first position
pushViewport(vp.1)

# start new base graphics in first viewport
par(new=TRUE, fig=gridFIG())

grid.draw(temp2)

# done with the first viewport
popViewport()

# move to the next viewport
pushViewport(vp.2)

  grid.draw(temp2)

# done with this viewport
popViewport(1)

dev.off()
-------------------------------------------------------------------------------------------------------
layout layout(matrix(c(4,1,3,2),nrow=2))
for (i in 1:4) {
  plot(seq_len(i))
}
-------------------------------------------------------------------------------------------------------
par(xpd=NA) grconvertX grconvertY layout( matrix( c(1,2,3,2), 2 ) )
par(xpd=NA)
with(iris, plot(Sepal.Width, Sepal.Length, col=Species) )
save1.x <- grconvertX( 0.25, from='npc', to='ndc' )
save2.x <- grconvertX( iris$Sepal.Width[1], to='ndc' )
save2.y <- grconvertY( iris$Sepal.Length[1], to='ndc' )
with(iris, plot(Petal.Width, Petal.Length, col=Species) )
with(iris, arrows( Petal.Width[1], Petal.Length[1], 
   grconvertX( save2.x, from='ndc' ), 
   grconvertY( save2.y, from='ndc' ), col='orange' ) )
with( iris, plot( Petal.Length, Sepal.Length, col=Species ) )
segments( grconvertX( 0.75, from='npc' ), grconvertY(0.9, from='npc'),
   grconvertX( save1.x, from='ndc'), col='purple' )
-------------------------------------------------------------------------------------------------------
ylab select layout(matrix(1:4, ncol = 2, byrow = TRUE)
plot(shark.gamFINAL, select = 1, ylab = "foo")
plot(shark.gamFINAL, select = 2, ylab = "bar")
plot(shark.gamFINAL, select = 3, ylab = "foobar")
layout(1) predict type = "terms" predict "constant" predict predict(shark.gamFINAL, newdata = NEW, type = "terms") NEW
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(reshape2)
library(grid)

 df <- structure(list(City = structure(c(2L,
     3L, 1L), .Label = c("Minneapolis", "Phoenix",
     "Raleigh"), class = "factor"), January = c(52.1,
     40.5, 12.2), February = c(55.1, 42.2, 16.5),
     March = c(59.7, 49.2, 28.3), April = c(67.7,
         59.5, 45.1), May = c(76.3, 67.4, 57.1),
     June = c(84.6, 74.4, 66.9), July = c(91.2,
         77.5, 71.9), August = c(89.1, 76.5,
         70.2), September = c(83.8, 70.6, 60),
     October = c(72.2, 60.2, 50), November = c(59.8,
         50, 32.4), December = c(52.5, 41.2,
         18.6)), .Names = c("City", "January",
     "February", "March", "April", "May", "June",
     "July", "August", "September", "October",
     "November", "December"), class = "data.frame",
     row.names = c(NA, -3L))

dfm <- melt(df, variable = "month")

 levels(dfm$month) <- month.abb
 p <- ggplot(dfm, aes(month, value, group = City,
     colour = City))
 p1 <- p + geom_line(size = 1) + theme(legend.position = "top") + xlab("") none <- element_blank()
data_table <- ggplot(dfm, aes(x = month, y = factor(City),
     label = format(value, nsmall = 1), colour = City)) +
     geom_text(size = 3.5) +
  scale_y_discrete(labels = abbreviate)+ theme_bw()  +
     theme(panel.grid.major = none, legend.position = "none",
         panel.border = none, axis.text.x = none,
         axis.ticks = none) + theme(plot.margin = unit(c(-0.5,
     1, 0, 0.5), "lines")) + xlab(NULL) + ylab(NULL) Layout <- 
grid.layout(nrow = 2, ncol = 1, heights = unit(c(2,0.25), c("null", "null")))
grid.show.layout(Layout)
vplayout <- function(...) {
     grid.newpage()
     pushViewport(viewport(layout = Layout))
 }

subplot <- function(x, y) viewport(layout.pos.row = x,
     layout.pos.col = y)

mmplot <- function(a, b) {
     vplayout()
     print(a, vp = subplot(1, 1))
     print(b, vp = subplot(2, 1))
 }

mmplot(p1, data_table) library(grid)
library(gridExtra)
library(ggplot2)
xta=data.frame(f=rnorm(37,mean=400,sd=50))
xta$n=0
for(i in 1:37){xta$n[i]<-paste(sample(letters,4),collapse='')}
xta$c=0
for(i in 1:37){xta$c[i]<-sample((1:6),1)}
rect=data.frame(xmi=seq(0.5,36.5,1),xma=seq(1.5,37.5,1),ymi=0,yma=10)
xta=cbind(xta,rect)
a = ggplot(data=xta,aes(x=n,y=f,fill=c)) + geom_bar(stat='identity')+ theme(legend.position = "top")+xlab("")

none <- element_blank()
z=ggplot(xta, aes(x = n, y = "fvalues",
     label = round(f,1)) )+
     geom_text(size = 3)+ theme_bw()  +
     theme(panel.grid.major = none, legend.position = "none",
         panel.border = none, axis.text.x = none,
         axis.ticks = none) + theme(plot.margin = unit(c(-0.5,
     1, 0, 0.5), "lines")) + xlab(NULL) + ylab(NULL)

Layout <- grid.layout(nrow = 2, ncol = 1, heights = unit(c(2,0.25), c("null", "null")))
grid.show.layout(Layout)
vplayout <- function(...) {
     grid.newpage()
     pushViewport(viewport(layout = Layout))
 }

subplot <- function(x, y) viewport(layout.pos.row = x,
     layout.pos.col = y)

mmplot <- function(a, b) {
     vplayout()
     print(a, vp = subplot(1, 1))
     print(b, vp = subplot(2, 1))
 }

mmplot(a, z) + coord_flip() ggplot(xta, aes(x=n,y=f,fill=c)) +
   geom_bar() +
   labs(color = "c") +
   geom_text(aes(y = max(f)+30, label = round(f, 1)), size = 3, color = "black") + coord_flip()
-------------------------------------------------------------------------------------------------------
plot.gam library(mgcv)
set.seed(2)
a <- rnorm(100)
b <- runif(100)
y <- a*b/(a+b)
dat <- data.frame(y = y, a = a, b = b)

mod <- gam(y~s(a)+s(b), data = dat) pdat <- with(dat,
             data.frame(a = c(seq(min(a), max(a), length = 100),
                              rep(mean(a), 100)),
                        b = c(rep(mean(b), 100),
                              seq(min(b), max(b), length = 100)))) pred <- predict(mod, pdat, type = "response", se.fit = TRUE)

> lapply(pred, head)
$fit
        1         2         3         4         5         6 
0.5842966 0.5929591 0.6008068 0.6070248 0.6108644 0.6118970 

$se.fit
       1        2        3        4        5        6 
2.158220 1.947661 1.753051 1.579777 1.433241 1.318022 $fit pdat b a a b fitted upper lower pdat <- transform(pdat, fitted = pred$fit)
pdat <- transform(pdat, upper = fitted + (1.96 * pred$se.fit),
                        lower = fitted - (1.96 * pred$se.fit)) 1:100 a 101:200 b layout(matrix(1:2, ncol = 2))
## plot 1
want <- 1:100
ylim <- with(pdat, range(fitted[want], upper[want], lower[want]))
plot(fitted ~ a, data = pdat, subset = want, type = "l", ylim = ylim)
lines(upper ~ a, data = pdat, subset = want, lty = "dashed")
lines(lower ~ a, data = pdat, subset = want, lty = "dashed")
## plot 2
want <- 101:200
ylim <- with(pdat, range(fitted[want], upper[want], lower[want]))
plot(fitted ~ b, data = pdat, subset = want, type = "l", ylim = ylim)
lines(upper ~ b, data = pdat, subset = want, lty = "dashed")
lines(lower ~ b, data = pdat, subset = want, lty = "dashed")
layout(1) ylim ylim <- with(pdat, range(fitted, upper, lower)) type = "terms" pred2 <- predict(mod, pdat, type = "terms", se.fit = TRUE) $fit $se.fit > lapply(pred2, head)
$fit
        s(a)       s(b)
1 -0.2509313 -0.1058385
2 -0.2422688 -0.1058385
3 -0.2344211 -0.1058385
4 -0.2282031 -0.1058385
5 -0.2243635 -0.1058385
6 -0.2233309 -0.1058385

$se.fit
      s(a)      s(b)
1 2.115990 0.1880968
2 1.901272 0.1880968
3 1.701945 0.1880968
4 1.523536 0.1880968
5 1.371776 0.1880968
6 1.251803 0.1880968 $fit pdat pdat <- transform(pdat, fitted = c(pred2$fit[1:100, 1], 
                                   pred2$fit[101:200, 2]))
pdat <- transform(pdat, upper = fitted + (1.96 * c(pred2$se.fit[1:100, 1], 
                                                   pred2$se.fit[101:200, 2])),
                        lower = fitted - (1.96 * c(pred2$se.fit[1:100, 1], 
                                                   pred2$se.fit[101:200, 2]))) 1:100 a 101:200 b layout(matrix(1:2, ncol = 2))
## plot 1
want <- 1:100
ylim <- with(pdat, range(fitted[want], upper[want], lower[want]))
plot(fitted ~ a, data = pdat, subset = want, type = "l", ylim = ylim)
lines(upper ~ a, data = pdat, subset = want, lty = "dashed")
lines(lower ~ a, data = pdat, subset = want, lty = "dashed")
## plot 2
want <- 101:200
ylim <- with(pdat, range(fitted[want], upper[want], lower[want]))
plot(fitted ~ b, data = pdat, subset = want, type = "l", ylim = ylim)
lines(upper ~ b, data = pdat, subset = want, lty = "dashed")
lines(lower ~ b, data = pdat, subset = want, lty = "dashed")
layout(1) b a
-------------------------------------------------------------------------------------------------------
set.seed(1)
dat <- data.frame(y = rnorm(100))
dat <- transform(dat,
                 x1 = 0.2 + (0.4 * y) + rnorm(100),
                 x2 = 2.4 + (2.3 * y) + rnorm(100)) mod <- lm(y ~ x1 + x2, data = dat) pdatx1 <- with(dat, data.frame(x1 = seq(min(x1), max(x1), length = 100),
                               x2 = rep(mean(x2), 100)))
pdatx2 <- with(dat, data.frame(x1 = rep(mean(x1), 100),
                               x2 = seq(min(x2), max(x2), length = 100))) pdatx1 <- transform(pdatx1, yhat = predict(mod, pdatx1))
pdatx2 <- transform(pdatx2, yhat = predict(mod, pdatx2)) y ylim <- range(pdatx1$y, pdatx2$y, dat$y) layout(matrix(1:2, ncol = 2))
plot(y ~ x1, data = dat)
lines(yhat ~ x1, data = pdatx1, col = "red", lwd = 2)
plot(y ~ x2, data = dat)
lines(yhat ~ x2, data = pdatx2, col = "red", lwd = 2)
layout(1)
-------------------------------------------------------------------------------------------------------
ggplot2 viewport() grid.layout() px py geom_tile() theme() color="white" #Scatter plot without axis titles
p<-ggplot(myd, aes(x=X, y=Y)) +    geom_point(shape=1)  + 
  theme_bw() + theme(axis.title=element_blank())

#tile plot for the x axis
px<-ggplot(myd,aes(x=xcat,y=1,fill=xcat))+geom_tile()+
  scale_x_discrete(expand=c(0,0))+
  scale_fill_hue(h=c(0,180))+
  scale_y_continuous(expand=c(0,0),breaks=1,labels="10")+
  theme(legend.position="none",
        axis.title=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.text.y=element_text(color="white"),
        axis.ticks.y=element_line(color="white"))

#tile plot for the y axis
py<-ggplot(myd,aes(x=1,y=ycat,fill=ycat))+geom_tile()+
  scale_y_discrete(expand=c(0,0))+
  scale_x_continuous(expand=c(0,0),breaks=1,labels="1")+
  scale_fill_hue(h=c(181,360))+
  theme(legend.position="none",
        axis.title=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        axis.text.x=element_text(color="white"),
        axis.ticks.x=element_line(color="white"))

#Define layout for the plots (2 rows, 2 columns)
layt<-grid.layout(nrow=2,ncol=2,heights=c(7/8,1/8),widths=c(1/8,7/8),default.units=c('null','null'))
#View the layout of plots
grid.show.layout(layt)

#Draw plots one by one in their positions
grid.newpage()
pushViewport(viewport(layout=layt))
print(py,vp=viewport(layout.pos.row=1,layout.pos.col=1))
print(p,vp=viewport(layout.pos.row=1,layout.pos.col=2))
print(px,vp=viewport(layout.pos.row=2,layout.pos.col=2))
-------------------------------------------------------------------------------------------------------
base brX <- seq(min(myd$X),max(myd$X),length=11)
brY <- seq(min(myd$Y),max(myd$Y),length=11)

layout(matrix(c(1,0,2,3),nrow=2),width=c(2,8),height=c(8,2))
par(mar=c(0,3,5,0))
plot(NA,ylim=range(myd$Y),xlim=c(0,1),axes=F,ann=F,xaxs="i")
rect(0,brY[-length(brY)],1,brY[-1], 
     col=colorRampPalette(c("red","yellow","green"))(length(brY)-1))

par(mar=c(0,0,5,5))
plot(NA,xlim=range(myd$X),ylim=range(myd$Y),ann=F,xaxt="n",yaxt="n")
abline(h=pretty(myd$Y),v=pretty(myd$X), col="grey95")
points(myd$X,myd$Y,pch=21)
axis(3)
axis(4)

par(mar=c(3,0,0,5))
plot(NA,xlim=range(myd$X),ylim=c(0,1),axes=F,ann=F,yaxs="i")
rect(brX[-length(brX)],0,brX[-1],1, 
     col=colorRampPalette(c("blue","white","red"))(length(brX)-1))
-------------------------------------------------------------------------------------------------------
ylim= boxplot() xlim= hist() set.seed(123)
data <- rnorm(1000)
nf <- layout(mat = matrix(c(1,2),2,1, byrow=TRUE),  height = c(1,3))
par(mar=c(5.1, 4.1, 1.1, 2.1))
boxplot(data, horizontal=TRUE,  outline=FALSE,ylim=c(-4,4))
hist(data,xlim=c(-4,4))
-------------------------------------------------------------------------------------------------------
randgen <- function(n,mu) {
  x <- rpois(n,mu)
  y <- rpois(n,mu)

  d <- sum(y)-sum(x)

  if (d<0) {
    ind <- sample(seq_along(y),-d)
    y[ind] <- y[ind]+1
  } else {
    ind <- sample(seq_along(x),d)
    x[ind] <- x[ind]+1
  }

 cbind(x=as.integer(x),y=as.integer(y))
}

set.seed(42)
rand <- randgen(1000,15)

layout(c(1,2))    
qqnorm(rand[,1]); qqline(rand[,1])
qqnorm(rand[,2]); qqline(rand[,2]) is.integer(rand)
#[1] TRUE

sum(rand<0)
#[1] 0

colSums(rand)
#x     y 
#15084 15084

mean(rand[,1])
#[1] 15.084
mean(rand[,2])
#[1] 15.084

sd(rand[,1])
#[1] 4.086275
sd(rand[,2])
#[1] 3.741249
-------------------------------------------------------------------------------------------------------
ctl <- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)
trt <- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)
group <- gl(2,10,20, labels=c("Ctl","Trt"))
weight <- c(ctl, trt)
lm.D9 <- lm(weight ~ group)
layout(matrix(1:4,2,2))
plot(lm.D9) caption ?plot.lm ## taken from ?plot.lm
capList <- list("Residuals vs Fitted", "Normal Q-Q",
        "Scale-Location", "Cook's distance",
        "Residuals vs Leverage",
        expression("Cook's dist vs Leverage  " * h[ii] / (1 - h[ii])))
## or equivalently
capList <- eval(formals(plot.lm)$caption)
## modify the third element
capList[[3]] <- "hello world"
plot(lm.D9, caption = capList) plot(lm.D9, which=1); plot(lm.D9, which=2)
-------------------------------------------------------------------------------------------------------
# no alignment (plots are centered)
grid.arrange(set_panel_size(p1, w=unit(0.4,"npc")),
             set_panel_size(p2, w=unit(0.4,"npc")))

# with alignment
align_plots(p1, p2, width=unit(0.8,"npc")) library(ggplot2)
library(gridExtra)

set_panel_size <- function(p=NULL, g=ggplotGrob(p), width=unit(3, "cm"), height=unit(3, "cm")){
  panel_index_w<- g$layout$l[g$layout$name=="panel"]
  panel_index_h<- g$layout$t[g$layout$name=="panel"]
  g$widths[[panel_index_w]] <- width
  g$heights[[panel_index_h]] <- height
  class(g) <- c("fixed", class(g), "ggplot")
  g
}

print.fixed <- function(x) grid.draw(x)

left_width <- function(g){
  axis_l_index <- g$layout$r[g$layout$name=="axis-l"]
  ylab_index <- g$layout$r[g$layout$name=="ylab"]
  g$widths[[axis_l_index]] + g$widths[[ylab_index]]
}

full_width <- function(g){
  sum(g$widths)
}


align_plots <- function(..., width=unit(3, "cm"), height=unit(1, "null")){

  pl <- list(...)
  gl <- lapply(pl, set_panel_size, width=width, height=height)

  left <- lapply(gl, left_width)
  max_left <- max(do.call(unit.c, left))

  widths <- lapply(gl, full_width)
  max_width <- max(do.call(unit.c, widths))

  lay <- grid.layout(nrow=length(gl), ncol=1)
  vp <- viewport(layout=lay)
  pushViewport(vp)

  for(ii in seq_along(gl)){
    pushViewport(viewport(layout.pos.row=ii))
    pushViewport(viewport(x=unit(0.5, "npc") - 0.5*max_width + max_left - left[[ii]],
                          just="left", width=widths[[ii]]))
    grid.draw(gl[[ii]])
    upViewport(2)
  }
  upViewport()
}

p1 = 
ggplot(data.frame(x=c("a","b","c"),y=c("happy","sad","ambivalent about life")),aes(x=factor(0),fill=x)) + geom_bar()

p2=
ggplot(data.frame(x=c("a","b","c"),y=c("happy","sad","ambivalent about life")),aes(x=factor(0),fill=y)) + geom_bar()
-------------------------------------------------------------------------------------------------------
heights widths grid.layout pushViewport(viewport(layout = grid.layout(heights = unit(0.2 , "npc" ) ,nrow = 1, ncol = 4))) 'npc'
-------------------------------------------------------------------------------------------------------
theme() theme( axis.text.x=element_text(size=20) ,  axis.title.x = element_text(size = 20 , colour = "red" ) ) pushViewport grid.newpage()
# Create a grid arangement of viewports to 'put' the plots into...
# widths and heights are normalised parent coordinates which scale from 0 to 1 with 1 being the entire width of the plot page
# The respect argument forces widths and heights to respect each other as they are set
pushViewport( viewport( layout = grid.layout( 2 , 3 , heights = unit( c( 0.02 , 0.45 ) , "npc" ) , widths = unit( c( 0.4 , 0.4 , 0.1 ) , "npc" ) , respect = matrix(rep(1,6),2) ) ) ) 
# We print plots to particular 'cells' on our page specified by the layout.pos.row and layout.pos.col
print( p1 + theme(legend.position="none") , vp = viewport( layout.pos.row = 2 , layout.pos.col = 1 ) )
print( p2 + theme(legend.position="none") , vp = viewport( layout.pos.row = 2, layout.pos.col = 2 ) )
# The grid.text is output to row one, and breaks across columns 1:2
grid.text("The main figure title is also small and hard to align left"  , just = "left" , x = unit(0.01, "npc"), y = unit(0.5, "npc"), vp = viewport( layout.pos.row = 1, layout.pos.col = 1:2) )
# We use upViewport to go up a level to the parent viewport
upViewport(0)
# We then define a new viewport for the legend which is a table grob.
# I had difficulty with this one so we set x and y coordinates and make it narrow but tall (0.1 npc width and 0.75 noc height)
vp3 <- viewport( width = unit(0.1,"npc") , height = unit(0.75 ,"npc") , x = 0.93, y = .5)
# We then activate this viewport
pushViewport(vp3)
# we output the legend which is a tableGrob to this viewport
grid.draw( mylegend )
popViewport()
-------------------------------------------------------------------------------------------------------
tableGrob ## Make a tableGrob of your legend
tmp <- ggplot_gtable(ggplot_build(p2))
leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
legend <- tmp$grobs[[leg]]

# Plot objects using widths and height and respect to fix aspect ratios
# We make a grid layout with 3 columns, one each for the plots and one for the legend
grid.newpage()
pushViewport( viewport( layout = grid.layout( 1 , 3 , widths = unit( c( 0.4 , 0.4 , 0.2 ) , "npc" ) ,heights = unit( c( 0.45 , 0.45 , 0.45 ) , "npc" ) , respect = matrix(rep(1,3),1) ) ) ) 
print( p1 + theme(legend.position="none") , vp = viewport( layout.pos.row = 1 , layout.pos.col = 1 ) )
print( p2 + theme(legend.position="none") , vp = viewport( layout.pos.row = 1, layout.pos.col = 2 ) )
upViewport(0)
vp3 <- viewport( width = unit(0.2,"npc") , x = 0.9 , y = 0.5)
pushViewport(vp3)
grid.draw( legend )
popViewport()
-------------------------------------------------------------------------------------------------------
dm <- data.frame(number=c(2,2,2,3,3,3,3,4,4,4,4),
        value=c(2,3,4,2,3,5,4,4,4,4,4),
        day=c("21/3/2010 00:01:00",
              "21/3/2010 00:02:00",
              "21/3/2010 00:03:00",
              "21/3/2010 00:01:00",
              "21/3/2010 00:02:00",
              "21/3/2010 00:03:00",
              "21/3/2010 00:04:00",
              "21/3/2010 00:01:00",
              "21/3/2010 00:02:00",
              "21/3/2010 00:03:00",
              "21/3/2010 00:04:00"), stringsAsFactors=FALSE)
layout(matrix(1:length(unique(dm$number)),nrow=1, ncol=length(unique(dm$number))))
z <- sapply(unique(dm$number), FUN=function(x) 
    plot(dm$value[dm$number==x],as.factor(dm$day[dm$number==x]), ylab="Value", xaxt="n", xlab="Day", main=paste0("Day ",x), type="l") )
rm(z)
-------------------------------------------------------------------------------------------------------
plot() graph getMethod("plot", "graph") getMethod("plot", "Ragraph") oldpars <- par(mai = c(sheight, 0, mheight, 0))
on.exit(par(oldpars), add = TRUE) layout graph layout(matrix(1:3, nrow=1), widths=c(1,5,1))
par(xpd=NA)                    ## turn off all clipping
plot.new()                     ## blank plot in Panel 1
plot(g1, edgeAttrs = eAttrs)   ## graph in Panel 2
plot.new()                     ## blank plot in Panel 3
-------------------------------------------------------------------------------------------------------
layout(mat = lmat, widths = lwid, heights = lhei) heatmap.2(x, 
    Rowv=NA, 
    Colv=NA, 
    scale="none", 
    main="This title will be cut off by the white space where the non-existant key is supposed to go.", 
    col=gray((255:0)/255), 
    dendrogram="none",
    trace="none", 
    key=FALSE, 
    lmat=rbind(c(2),c(3),c(1),c(4)), 
    lhei=c(1,1,9,0), 
    lwid=c(1)
    ); ?layout
-------------------------------------------------------------------------------------------------------
#' Plot two dimensional histogram
#'
#' @param hist matrix or two dimensional array containing the number of counts
#' in each of the bins.
#' @param borders_x the x-borders of the bins in the histogram. Should be a
#' numeric vector with lenght one longer than the number of columns of
#' \code{hist}
#' @param borders_y the y-borders of the bins in the histogram. Should be a
#' numeric vector with lenght one longer than the number of rows of
#' \code{hist}
#' @param type a character specifying the type of plot. Valid values are "text",
#' "area" and "color". See details for more information.
#' @param add add the plot to an existing one or create a new plot.
#' @param add_lines logical specifying whether or not lines should be drawn
#' between the bins.
#' @param draw_empty if \code{FALSE} empty bins (numer of counts equal to zero)
#' are not drawn. They are shown using the background color.
#' @param col for types "area" and "text" the color of the boxes and text.
#' @param line_col the color of the lines between the bins.
#' @param background_col the background color of the bins.
#' @param lty the line type of the lines between the bins.
#' @param text_cex the text size used for type "text". See \code{\link{par}} for
#' more information.
#' @param col_range the color scale used for type "color". Should be a function
#' which accepts as first argument the number of colors that should be
#' generated. The first color generated is used for the zero counts; the
#' last color for the highest number of counts in the histogram.
#' @param ... additional arguments are passed on to \code{\link{plot}}.
#'
#' @details
#' There are three plot types: "area", "text", and "color". In case of "area"
#' rectangles are drawn inside the bins with area proportional to the number of
#' counts in the bins. In case of text the number of counts is shown as text in
#' the bins. In case of color a color scale is used (by default heat.colors) to
#' show the number of counts.
#'
#' @seealso \code{\link{image}} which can be used to create plots similar to
#' type "color". \code{\link{contour}} may also be of interest.
#'
#' @examples
#' histplot2(volcano - min(volcano), type="color")
#' histplot2(volcano - min(volcano), add_lines=FALSE, type="area")
#' histplot2(volcano - min(volcano), type="text", text_cex=0.5)
#'
#' @export
histplot2 <- function(hist, borders_x=seq(0, ncol(hist)),
        borders_y=seq(0, nrow(hist)), type="area", add=FALSE, add_lines=TRUE,
        draw_empty=FALSE, col="black", line_col="#00000030",
        background_col="white", lty=1, text_cex=0.6, col_range=heat.colors, ...) {
    # create new plot
    rangex <- c(min(borders_x), max(borders_x))
    rangey <- c(min(borders_y), max(borders_y))
    if (add == FALSE) {
        plot(rangex, rangey, type='n', xaxs='i', yaxs='i', ...)
        rect(rangex[1], rangey[1], rangex[2], rangey[2], col=background_col,
            border=NA)
    }
    # prepare data
    nx <- length(borders_x)-1
    ny <- length(borders_y)-1
    wx <- rep(diff(borders_x), each=ny)
    wy <- rep(diff(borders_y), times=nx)
    sx <- 0.95*min(wx)/sqrt(max(hist))
    sy <- 0.95*min(wy)/sqrt(max(hist))
    x <- rep((borders_x[-length(borders_x)] + borders_x[-1])/2, each=ny)
    y <- rep((borders_y[-length(borders_y)] + borders_y[-1])/2, times=nx)
    h <- as.numeric(hist)
    # plot type "area"
    if (type == "area") {
        dx <- sqrt(h)*sx*0.5
        dy <- sqrt(h)*sy*0.5
        rect(x-dx, y-dy, x+dx, y+dy, col=col, border=NA)
    # plot type "text"
    } else if (type == "text") {
        if (draw_empty) {
            text(x, y, format(h), cex=text_cex, col=col)
        } else {
            text(x[h!=0], y[h!=0], format(h[h!=0]), cex=text_cex, col=col)
        }
    # plot type "color"
    } else if (type == "color" | type == "colour") {
        #h <- h/(wx*wy)
        col <- col_range(200)
        col <- col[floor(h/max(h)*200*(1-.Machine$double.eps))+1]
        sel <- rep(TRUE, length(x))
        if (!draw_empty) sel <- h > 0
        rect(x[sel]-wx[sel]/2, y[sel]-wy[sel]/2, x[sel]+wx[sel]/2,
            y[sel]+wy[sel]/2, col=col[sel], border=NA)
    } else {
        stop("Unknown plot type: options are 'area', 'text' and 'color'.")
    }
    # add_lines
    if (add_lines) {
        lines(rbind(borders_x, borders_x, NA),
            rbind(rep(rangey[1], nx+1), rep(rangey[2], nx+1), NA),
            col=line_col, lty=lty)
        lines(rbind(rep(rangex[1], ny+1), rep(rangex[2], ny+1), NA),
            rbind(borders_y, borders_y, NA), col=line_col, lty=lty)
    }
    # add border
    if (add == FALSE) box()
} X <- matrix(nrow=3, ncol=3)
X[1,] <- c(0.3, 0.4, 0.45)
X[2,] <- c(0.3, 0.7, 0.65)
X[3,] <- c(0.3, 0.4, 0.45)
centers <- c(1.5, 3, 4)

centers_to_borders <- function(centers) {
    nc <- length(centers)
    d0 <- centers[2]-centers[1]
    d1 <- centers[nc]-centers[nc-1]
    c(centers[1]-d0/2, 
      (centers[2:nc] + centers[1:(nc-1)])/2, centers[nc]+d1/2)
}

histplot2(X, centers_to_borders(centers), 
    centers_to_borders(centers), type="color") plot_range <- function(hist, col_range = heat.colors) {
    r <- range(c(0, X))
    par(cex=0.7, mar=c(8, 1, 8, 2.5))
    plot(0, 0, type='n', xlim=c(0,1), ylim=r, xaxs='i',
        yaxs='i', bty='n', xaxt='n', yaxt='n', xlab='', ylab='')
    axis(4)
    y <- seq(r[1], r[2], length.out=200)
    yc <- floor(y/max(y)*5*(1-.Machine$double.eps))+1
    col <- col_range(5)[yc]
    b <- centers_to_borders(y)
    rect(rep(0, length(y)), b[-length(b)], rep(1, length(y)), 
        b[-1], col=col, border=NA)
} layout layout(matrix(c(1,2), nrow = 1), widths = c(0.9, 0.1))
par(mar = c(5, 4, 4, 2) + 0.1)
histplot2(X, centers_to_borders(centers), 
    centers_to_borders(centers), type="color")
plot_range(X) histplot2 h <- h/(wx*wy)
-------------------------------------------------------------------------------------------------------
filled.contour filled.contour my.filled.contour <-
function (x = seq(0, 1, length.out = nrow(z)), y = seq(0, 1,
    length.out = ncol(z)), z, xlim = range(x, finite = TRUE),
    ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE),
    levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors,
    col = color.palette(length(levels) - 1), plot.title, plot.axes,
    key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1,
    axes = TRUE, frame.plot = axes, ...)
{
    if (missing(z)) {
        if (!missing(x)) {
            if (is.list(x)) {
                z <- x$z
                y <- x$y
                x <- x$x
            }
            else {
                z <- x
                x <- seq.int(0, 1, length.out = nrow(z))
            }
        }
        else stop("no 'z' matrix specified")
    }
    else if (is.list(x)) {
        y <- x$y
        x <- x$x
    }
    if (any(diff(x) <= 0) || any(diff(y) <= 0))
        stop("increasing 'x' and 'y' values expected")
    mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar
    on.exit(par(par.orig))
    w <- (3 + mar.orig[2L]) * par("csi") * 2.54
    layout(matrix(c(2, 1), ncol = 2L), widths = c(1, lcm(w)))
    par(las = las)
    mar <- mar.orig
    mar[4L] <- mar[2L]
    mar[2L] <- 1
    par(mar = mar)
    plot.new()
    plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i",
        yaxs = "i")
#    rect(0, levels[-length(levels)], 1, levels[-1L], col = col)
#    if (missing(key.axes)) {
#        if (axes)
#            axis(4)
#    }
#    else key.axes
#    box()
    if (!missing(key.title))
        key.title
    mar <- mar.orig
    mar[4L] <- 1
    par(mar = mar)
    plot.new()
    plot.window(xlim, ylim, "", xaxs = xaxs, yaxs = yaxs, asp = asp)
    if (!is.matrix(z) || nrow(z) <= 1L || ncol(z) <= 1L)
        stop("no proper 'z' matrix specified")
    if (!is.double(z))
        storage.mode(z) <- "double"
    .Internal(filledcontour(as.double(x), as.double(y), z, as.double(levels),
        col = col))
    if (missing(plot.axes)) {
        if (axes) {
            title(main = "", xlab = "", ylab = "")
            Axis(x, side = 1)
            Axis(y, side = 2)
        }
    }
    else plot.axes
    if (frame.plot)
        box()
    if (missing(plot.title))
        title(...)
    else plot.title
    invisible()
} my.filled.contour(x=x, y=y, z=z,
               levels=levels,
               col=colorpanel(length(levels) + 1, "white", "grey10"),
               xlim=rev(range(x)),
               ylim=rev(range(y)),
               plot.axes={axis(1, c(0.18, 0.01), label=TRUE, tcl=-0.5)
                          axis(2, c(0.18, 0.01), label=TRUE, tcl=-0.5)
                          draw.contour()},
               xlab="x",
               frame=FALSE)
-------------------------------------------------------------------------------------------------------
gtable library(gtable)
gtable_add_grobs <- gtable_add_grob #misleading name

g <- gtable(widths = unit(rep(1, 6), "null"), # need lcm(3,2)=6 for the matrix rows
            heights = unit(rep(1, 2), "null"))

#gtable_show_layout(g)

g <- gtable_add_grobs(g, lapply(list(p1, p2, p3, p4, p5), ggplotGrob),
                     t = c(1, 1, 1, 2, 2),
                     l = c(1, 3, 5, 2, 4),
                     r = c(2, 4, 6, 3, 5))

grid.newpage()
grid.draw(g) g <- gtable_add_grobs(g, lapply(list(p1, p2, p3, p4, p5), ggplotGrob),
                      t = c(1, 1, 1, 2, 2),
                      l = c(1, 3, 5, 1, 4),
                      r = c(2, 4, 6, 3, 6))
-------------------------------------------------------------------------------------------------------
layout layout(matrix(1:4,nrow=2))
-------------------------------------------------------------------------------------------------------
spatstat blur() library(jpeg)
library(fields)
library(spatstat)

picture <- readJPEG("~/Downloads/spectrogram.png.jpeg")
picture2 <- as.matrix(blur(as.im(picture), sigma=6))

layout(matrix(c(1:4), nrow=2))
image.plot(picture, col=gray.colors(50), main="original image", asp=1)
image.plot(picture2, col=gray.colors(50), main="blurred with sigma = 6", asp=1)
drape.plot(1:nrow(picture), 1:ncol(picture), picture, border=NA, theta=0, phi=45, main="original spectrogram")
drape.plot(1:nrow(picture), 1:ncol(picture), picture2, border=NA, theta=0, phi=45, main="blurred with sigma = 6")
-------------------------------------------------------------------------------------------------------
ll <- lapply(LETTERS[1:4],function(let){
  dat.let <- dat[,grepl(let,colnames(dat))]
  dd <- reshape(dat.let,direction ='long',
                v.names=c('TimeVariable','Variable'),
                varying=1:6)
  dd$time <- factor(dd$time)
  dd$Type <- let
  dd
}
) head(ll[[1]])
 time TimeVariable Variable id Type
1.1    1            0        0  1    A
2.1    1            0        5  2    A
3.1    1            8      110  3    A
4.1    1           16        0  4    A
5.1    1           NA       NA  5    A
6.1    1           NA       NA  6    A layout(matrix(1:4, 2, 2, byrow = TRUE))
lapply(ll,function(data){
  label1=c(0,100,200,300)
  Type <- unique(dat$Type)
  dat <- subset(data,time==2)
  x.mm <- max(dat$Variable,na.rm=TRUE)
  plot(dat$TimeVariable,dat$Variable,axes=FALSE,ylab="",xlab="",xlim=c(0,x.mm),
       ylim=c(0,2.4),xaxs="i",yaxs="i",pch=19)
  dat <- subset(data,time==2)
  lines(dat$TimeVariable,dat$Variable)
  axis(2,tick=T,at=seq(0.0,2.4,by=0.6),label= seq(0.0,2.4,by=0.6))
  axis(1,tick=T,at=seq(0,x.mm,by=6),label=seq(0,x.mm,by=6))
  mtext(Type,side=1,outer=F,line=-10,adj=0.8)
  minor.tick(nx=5,ny=5)
  par(new=TRUE)
  dat <- subset(data,time==1)
  plot(dat$TimeVariable,dat$Variable,axes=FALSE,xlab="",ylab="",type="l",
       ylim=c(800,0),xaxs="i",yaxs="i")
  axis(3,xlim=c(0,24),tick=TRUE,at= seq(0,24,by=6),label=seq(0,24,by=6),col.axis="violetred4",col="violetred4")
  axis(4,tick=TRUE,at= label1,label=label1,col.axis="violetred4",col="violetred4")
  polygon(dat$TimeVariable,dat$Variable,col='violetred4',border=NA)
}) `ggplot2 facet_wrap ## transform your data to a data.frame
 dat.l <- do.call(rbind,ll)
 library(ggplot2)
 ggplot(subset(dat.l,time !=1)) +
  geom_line(aes(x=TimeVariable,y=Variable,group=time,color=time))+
  geom_polygon(data=subset(dat.l,time ==1),
              aes(x=TimeVariable,y=60-Variable/10,fill=Type))+
  geom_line(data=subset(dat.l,time ==1),
               aes(x=TimeVariable,y=Variable,fill=Type))+
  facet_wrap(~Type,scales='free')
-------------------------------------------------------------------------------------------------------
viewport grid.layout library(grid)
pushViewport(plotViewport(c(1,1,1,1),layout = grid.layout(2, 1)))
print(p2, vp = viewport(layout.pos.row = 2, layout.pos.col = 1))
pushViewport(viewport(layout.pos.row=1,
  layout = grid.layout(1, 2,widths = unit(c(1,1),c("null",'lines')))))
print(p1, vp = viewport(layout.pos.row = 1, layout.pos.col = 1))
upViewport(2)
-------------------------------------------------------------------------------------------------------
layout(1:2, heights=c(1, 5))

# Legend panel
par(mar=rep(0,4))
plot(0, 0, type="n", ann=FALSE, axes=FALSE)
legend("center", c("5-10 cm", "15-20 cm", "25-30 cm"), horiz=TRUE,
       lty=2:4, col=1:3)

# Plot panel
par(mar=c(5,4,0,2))
plot(1:20, cumsum(rnorm(20))) par(new=TRUE) par(mar=c(5,4,5,2))
plot(1:20, cumsum(rnorm(20)))

par(new=TRUE, mar=c(0,0,1,0))
plot(0, 0, type="n", ann=FALSE, axes=FALSE)
legend("top", c("5-10 cm", "15-20 cm", "25-30 cm"), horiz=TRUE,
       lty=2:4, col=1:3)
-------------------------------------------------------------------------------------------------------
x$MonthNum <- sapply(x$Month, function(x) which(x==month.name)) plot(NA, xaxt="n", xlab="Month", xlim=c(0,13),
    ylim=c(.96*min(x$Value),1.04*max(x$Value)), type="l")
z <- sapply(1996:1998, function(y) with(x[x$Year==y,], lines(MonthNum, Value1)))
axis(1, at=1:12, labels=month.name) xlabpos <- tapply(x$MonthNum, x$Year, max)
ylabpos <- mapply(function(mon, year) x$Value1[x$MonthNum==mon & x$Year==year],     
    xlabpos, dimnames(xlabpos)[[1]])
text(x=xlabpos+.5, y=ylabpos, labels=dimnames(xlabpos)[[1]]) layout par(mar=c(2,4,1,1))
layout(matrix(1:3))
z <- sapply(1996:1998, function(y) {
    with(x[x$Year==y,], plot(Value1 ~ MonthNum, xaxt="n", xlab="Month", ylab=y,
        xlim=c(0,13), ylim=c(.96*min(x$Value),1.04*max(x$Value)), type="l"))
    axis(1, at=1:12, labels=month.name)
})
-------------------------------------------------------------------------------------------------------
layout() matrix(1:2,nrow=1) widths=c(1,2) layout(matrix(1:2,nrow=1),widths=c(1,2))
-------------------------------------------------------------------------------------------------------
mfrow layout library(vioplot)
N <- 60
par(mar=rep(2,4))  
layout(matrix(c(1:N),
              nrow=10,byrow=T))
dat <- data.frame(bin_with_regard_to_strand=gl(N,10),CLONE3=rnorm(10*N))
with(dat , 
     tapply(CLONE3,bin_with_regard_to_strand ,vioplot))
-------------------------------------------------------------------------------------------------------
layout layout(matrix(1:4,1,4))
plot(1)
plot(2)
plot(3)
plot(4) dev.new() plot(1)
dev.new()
plot(2)
dev.new()
plot(3)
dev.new()
plot(4)
-------------------------------------------------------------------------------------------------------
ggplot2 boxplot bxp xypolygon my.bxp <- function (all.bxp.argument,angle,density, ...) {
    .....#### bxp code
    xypolygon(xx, yy, lty = boxlty[i], lwd = boxlwd[i], 
    border = boxcol[i],angle[i],density[i])  
    .......## bxp code after
    xypolygon(xx, yy, lty = "blank", col = boxfill[i],angle[i],density[i])      
    ......

} require(stats)
set.seed(753)
(bx.p <- boxplot(split(rt(100, 4), gl(5, 20))))
layout(matrix(c(1,2),nrow=1),width=c(4,1)) 
angles=c(60,30,40,50,60)
densities=c(50,30,40,50,30)
par(mar=c(5,4,4,0)) #Get rid of the margin on the right side
my.bxp(bx.p,angle=angles,density=densities)
par(mar=c(5,0,4,2)) #No margin on the left side
plot(c(0,1),type="n", axes=F, xlab="", ylab="")
legend("top", paste("region", 1:5),
       angle=angles,density=densities)
-------------------------------------------------------------------------------------------------------
op <- par(no.readonly = TRUE)

set.seed(42)
plot(rnorm(100), runif(100))

par(new=TRUE, oma=c(3,1,1,2))
layout(matrix(1:4,2))

plot(rnorm(100), runif(100), col="blue", xlab="", ylab="")

par(op)
-------------------------------------------------------------------------------------------------------
filled contour image image.scale source("image.scale.R") # http://menugget.blogspot.de/2011/08/adding-scale-to-image-plot.html

x = c(20:200/100)
y = c(20:200/100)
z = as.matrix(exp(x^2)) %*% exp(y^2)

pal <- colorRampPalette(c('green','yellow','red'))
breaks <- c(1:60/3,30,50,150,250,1000,3000)
ncolors <- length(breaks)-1
labs <- c(0.5, 1, 3,30,50,150,250,1000,3000)

#x11(width=6, height=6)
layout(matrix(1:2, nrow=1, ncol=2), widths=c(5,1), heights=c(6))
layout.show(2)

par(mar=c(5,5,1,1))
image(x=x,y=y,z=log(z), col=pal(ncolors), breaks=log(breaks))
box()

par(mar=c(5,0,1,4))
image.scale(log(z), col=pal(ncolors), breaks=log(breaks), horiz=FALSE, xlab="", ylab="", xaxt="n", yaxt="n")
axis(4, at=log(labs), labels=labs)
box()
-------------------------------------------------------------------------------------------------------
ylim xlim c(0, 3) op <- par(no.readonly = TRUE)

lin <- data.frame(x = c(0:6), y = c(0.3, 0.1, 0.9, 3.1, 5, 4.9, 6.2))
linm <- lm(y ~ x, data = lin, subset = 2:4)
plot(y ~ x, data = lin)
abline(linm)

par(new=TRUE, oma=c(3,1,1,2))
layout(matrix(1:4,2))

lin <- data.frame(x = c(0:6), y = c(0.3, 0.1, 0.9, 3.1, 5, 4.9, 6.2))
linm <- lm(y ~ x, data = lin, subset = 2:4)
plot(y ~ x, data = lin, ylim=c(0,3), xlim=c(0, 3))
abline(linm)

par(op)
-------------------------------------------------------------------------------------------------------
layout heatmap.2 ?heatmap.2 image axis library(gplots)

 heatmap3 <- function(mat1){
  image(mat1, Rowv=F, Colv=F,col=greenred(200), scale="row",
        key=TRUE, xlab=colnames(mat1), ylab=rownames(mat1), keysize=0.8)
  axis(1, at = seq(0, 1, length.out = dim(mat1)[1]), labels = gs, 
       las = 2)
  axis(2, at = seq(0, 1, length.out = dim(mat1)[1]), labels = gs, 
       las = 2)
  }
nf <- layout(matrix(c(1,2,3),3,1), widths = lcm(5), heights = lcm(5), TRUE)
heatmap3(mat1)
heatmap3(mat2)
heatmap3(mat3)
-------------------------------------------------------------------------------------------------------
grid.multipanel() require(grid)
require(mvtnorm)

set.seed(271)
X <- rmvnorm(100, mean=1:4, sigma=diag(4:1)) # goal: draw this in a pairs plot

panelGrob <- function(x=runif(10, -10, 10), y=runif(10, -10, 100), ...,
  xlim = range(x), ylim=range(y),
  axis.x=TRUE, axis.y=TRUE){
  xx <- pretty(x) ; yy <- pretty(y)
  xx <- xx[xx <= xlim[2] & xx >= xlim[1]]
  yy <- yy[yy <= ylim[2] & yy >= ylim[1]]

  r <- rectGrob()
  dvp <- dataViewport(xData=xx, yData=yy)
  p <- pointsGrob(x, y, pch=".", gp=gpar(col="red"), default.units="native",
                  vp = dvp)

  ax <- if(axis.x) xaxisGrob(at=xx, vp=dvp) else nullGrob()
  ay <- if(axis.y) yaxisGrob(at=yy, vp=dvp) else nullGrob()

  grobTree(r, ax, ay, p, ...)
}

grid.panel <- function(...)
  grid.draw(panelGrob(...))

grid.newpage()
grid.panel(vp=viewport(width=0.8, height=0.8))


pairsGrob <- function(X, ..., name=NULL, gp=NULL, vp=NULL){

  N <- NCOL(X)
  layout <- grid.layout(N+1, N+1, widths=unit(c(2, rep(1, N)), c("lines", rep("null", N))), heights = unit(c(rep(1, N), 2), c(rep("null", N), "lines")))


  wrap <- function(ii, jj, ...){
    panelGrob(X[,ii], X[,jj], ..., axis.x= ii == N, axis.y = jj == 1,
              vp=viewport(layout.pos.row=ii, layout.pos.col=jj+1))
  }

  rowcol <- expand.grid(ii=seq_len(N), jj=seq_len(N))
  gl <- mapply(wrap, ii=rowcol[,"ii"], jj=rowcol[,"jj"], MoreArgs=list(...),
               SIMPLIFY=FALSE)

  gTree(children=do.call(gList, gl), vp=viewport(layout=layout))
}

grid.pairs <- function(...) grid.draw(pairsGrob(...))

grid.newpage()
grid.pairs(X, xlim=c(-10,10), ylim=c(-10,10)) args(lattice::panel.xyplot)
-------------------------------------------------------------------------------------------------------
pyramide <- function(data,laxis,raxis) {
  a <- as.character(data$A)
  m<-data$m
  f<-data$f
  ff<- -m

  par(mai=c(1,1,1,.2))
  layout(matrix(1:2,nrow=1))
  barplot(ff,
          horiz=T,main="Hommes",
          space=0,
          col="grey",
          xlim=c(-1,0),
          axes=F,
          axisnames=F,
          cex.axis =0.7,
          xaxt="n", yaxt="n")
  axis(1,
       at=-laxis,
       labels=sprintf("%1.1f",laxis),
       cex.axis =0.7)

  par(mai=c(1,.3,1,1))
  barplot(f,
          horiz=T,
          main="Femmes",
          space=0,col="grey",
          xlim=c(0,1),
          axes=F,axisnames=F,
          cex.axis =0.7)
  axis(1,
       at=laxis,
       labels=sprintf("%1.1f",laxis),
       cex.axis =0.7)
  axis(2,
       at=as.numeric(a),
       labels=a,
       las=1,tcl=0,
       lty=0,
       cex.axis =0.5)
}

ages <- agelabels
l <-seq(1,0,by=-0.2)
r <-seq(0,1,by=0.2)
x <- data.frame(A=ages, m=pop.M, f=pop.F)

pyramide(x,l,r)
-------------------------------------------------------------------------------------------------------
lin <- data.frame(x = c(0:6), y = c(0.3, 0.1, 0.9, 3.1, 5, 4.9, 6.2))
linm <- lm(y ~ x, data = lin, subset = 2:4)
plot(y ~ x, data = lin)
abline(linm)
## to overlap the 2 plots
par(new=TRUE, oma=c(3,1,1,2))
## create a layout to plot the subplot in the right bottom corner
layout(matrix(1:4,2))
## use xlim and ylim to zoom the subplot
plot(y ~ x, data = lin,xlim=c(0,2), ylim=c(0,2))
abline(linm)
-------------------------------------------------------------------------------------------------------
multiplot # Multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  require(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
} p1 <- ggplot(...)
p2 <- ggplot(...)
# etc. multiplot multiplot(p1, p2, ..., cols = n)
-------------------------------------------------------------------------------------------------------
?par ‘mfg’ A numerical vector of the form ‘c(i, j)’ where ‘i’ and ‘j’
      indicate which figure in an array of figures is to be drawn
      next (if setting) or is being drawn (if enquiring).  The
      array must already have been set by ‘mfcol’ or ‘mfrow’. par("mfg")[1:2] par("mfg")[1:2] 2**par("mfg")[1] * 3**par("mfg")[2] Pid <- function(ij, test.id=NA){
        mi <- ij[1]
        mj <- ij[2]
        ijd <- 2**mi * 3**mj
        if (!is.na(test.id)) ijd <- ijd == test.id
        return(ijd)
} layout(matrix(c(1,3,2,3), 2))
x0 <- par("mfg")  # 2 1 2 2
id <- Pid(x0)     # 12
plot(rnorm(10))
x1 <- par("mfg")
p1 <- Pid(x1, id) # FALSE (layout is not full)
plot(rnorm(10))
x2 <- par("mfg")
p2 <- Pid(x2, id) # FALSE (layout is not full)
plot(rnorm(10))
x3 <- par("mfg")
p3 <- Pid(x3, id) # TRUE (layout is now full)
#
rbind(p1,p2,p3)
#    [,1]
#p1 FALSE
#p2 FALSE
#p3  TRUE id
-------------------------------------------------------------------------------------------------------

layout par(mfrow=...) layout par layout(matrix(1:6, nrow=3, byrow=TRUE))
plot(...)
plot(...)
plot(...)
... plot layout(matrix(1:6, 2))
plot(...)
plot(...)
plot(...)
...
-------------------------------------------------------------------------------------------------------
layout(matrix(c(1,1,1,2,3,4), 2, 3, byrow = TRUE)) 1
-------------------------------------------------------------------------------------------------------
grid.newpage()
grid.rect()
pushViewport(viewport(layout=grid.layout(3, 1)))


do_treemap <- function(ind){
    vp <- viewport(layout.pos.col=1, layout.pos.row=ind)
    pushViewport(vp)
    treemap(business, index=c("NACE1", "NACE2", "NACE3"), vSize="turnover", type="index",vp=vp)
    popViewport()
    popViewport() #treemap doees not seem to pop corretly
    popViewport() #and one more!
}

lapply(1:3, do_treemap)
-------------------------------------------------------------------------------------------------------
require(grid)
grid.newpage()

data(business)
numVars <- c("turnover", "turnover.prev", "employees", "employees.prev")

pushViewport(viewport(layout=grid.layout(length(numVars), 1)))
do_treemap <- function(ind){
    vp <- viewport(layout.pos.col=1, layout.pos.row=ind)
    treemap(business, index=c("NACE1", "NACE2"), vSize=numVars[ind],
    type="index",vp=vp) 
    upViewport(2) # Needed in version 2.0.1 due to bug. Not needed in later versions (i.e. github)
}

lapply(seq_along(numVars), do_treemap) require(grid)
grid.newpage()

data(business)
numVars <- c("turnover", "turnover.prev", "employees", "employees.prev")

pushViewport(viewport(layout=grid.layout(2, 2, widths=c(0.4,0.6), heights=c(0.7,0.3))))

for (i in 1:2) {
     for (j in 1:2) {
         vp <- viewport(layout.pos.col=i, layout.pos.row=j)
         treemap(business, index=c("NACE1", "NACE2"), vSize=numVars[i+(j-1)*2],
                 type="index",vp=vp)
         upViewport(2) # Needed in version 2.0.1 due to bug. Not needed in later versions (i.e. github)
     }
}
-------------------------------------------------------------------------------------------------------
gtable_layout <- function(grobs, widths = NULL, heights = NULL,
                          m, ...){

  if(is.null(widths))
    widths <- unit(rep(1,ncol(m)), "null")
  if(is.null(heights))
    heights <- unit(rep(1,nrow(m)), "null")

  cells <- sort(unique(c(m)))

  ## left/right/top/bottom borders for given id
  range_cell <- function(ii){
    ind <- which(m == ii, arr.ind=TRUE)
    data.frame(l=min(ind[,"col"]),
               r=max(ind[,"col"]),
               t=min(ind[,"row"]),
               b=max(ind[,"row"]))
  }


  layout <- data.frame(t(sapply(cells, range_cell)))

  gt <- gtable(widths = widths, heights = heights, ...)

  gtable_add_grobs <- gtable_add_grob # alias
  with(layout, gtable_add_grobs(gt, grobs, t=t, l=l, b=b, r=r))

}

## example    
gl <- lapply(1:9, function(ii) grobTree(textGrob(ii), rectGrob()))

gt <- gtable_layout(gl, m=rbind(c(1,1,1,2,3),c(1,1,1,4,5),c(6,7,8,9,9)))
grid.newpage()
grid.draw(gt)
-------------------------------------------------------------------------------------------------------
library(ggplot2)
p1 <- qplot(x=wt,y=mpg,geom="point",main="Scatterplot of wt vs. mpg", data=mtcars)
p2 <- qplot(x=wt,y=disp,geom="point",main="Scatterplot of wt vs disp", data=mtcars)
p3 <- qplot(wt,data=mtcars)
p4 <- qplot(wt,mpg,data=mtcars,geom="boxplot")
p5 <- qplot(wt,data=mtcars)
p6 <- qplot(mpg,data=mtcars)
p7 <- qplot(disp,data=mtcars)
p8 <- qplot(disp, y=..density.., geom="density", data=mtcars)
p9 <- qplot(mpg, y=..density.., geom="density", data=mtcars)

vplayout <- function(x, y) viewport(layout.pos.row = x, layout.pos.col = y)

grid.newpage()
pushViewport(viewport(layout = grid.layout(3, 5))) # 3 rows, 5 columns
print(p1, vp = vplayout(1:2, 1:3))  # the big plot covers rows 1:2 and cols 1:3
print(p2, vp = vplayout(1, 4))
print(p3, vp = vplayout(1, 5))
print(p4, vp = vplayout(2, 4))
print(p5, vp = vplayout(2, 5))
print(p6, vp = vplayout(3, 1))
print(p7, vp = vplayout(3, 2))
print(p8, vp = vplayout(3, 3))
print(p9, vp = vplayout(3, 4:5))
-------------------------------------------------------------------------------------------------------
baseViewports() par("usr") require(grid)
require(gridBase)

bgGrob <- function(v, h, gp=gpar(fill="grey90", col="red"), vp=NULL, def="native")
  grobTree(rectGrob(),
           segmentsGrob(v, unit(0, "npc"), v, unit(1, "npc"), def=def),
           segmentsGrob(unit(0, "npc"), h, unit(1, "npc"), h, def=def),
           vp=vp, gp=gp)

grid.bg = function(...)
  grid.draw(bgGrob(...))

## data
x <- 1:10
y <- rev(x)

## layout, par (for using base graphics)
grid.newpage()
plot.new()
gl <- grid.layout(nrow=1, ncol=1, widths=0.8, heights=0.8,default.units="npc")
pushViewport(viewport(layout=gl))
vp <- viewport(layout.pos.row=1, layout.pos.col=1)
pushViewport(vp)
par(plt=gridPLT(), new=TRUE)

## set up coordinate system
plot.window(range(x), range(y), log="y")
# suppressWarnings(base <- baseViewports())
## get tick locations
v <- axTicks(1, axp=par("xaxp"), log=par("xlog")) # x values of vertical lines
h <- axTicks(2, axp=par("yaxp"), log=par("ylog")) # y values of horizontal lines

if(par("xlog")) v <- log10(v)
if(par("ylog")) h <- log10(h)

usr <- par("usr")
## draw background
grid.bg(v=v, h=h, vp=viewport(xscale=usr[1:2], yscale=usr[3:4]))

## draw base graphics on top of the background
plot(x, y, type="b", log="y")
-------------------------------------------------------------------------------------------------------
layout x <- rnorm(1000)
jpeg("normdist.jpg")
layout(mat=matrix(c(1,1,2,3,4,4),nrow=3,ncol=2,byrow=T))
boxplot(x, horizontal=T)
hist(x)
plot(density(x))
plot(x)
dev.off() ?layout layout
-------------------------------------------------------------------------------------------------------
par(mar=c(1,1,1,1)); 
layout(matrix(c(0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,6,6,0,1,2,2,5,5,6,0,1,2,2,1,0,0,0,1,1,1,3,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,3,4,0,0,0,0,0,4,4), nrow=9, byrow=TRUE)); 

pie(x=c(0.4,0.3,0.2,0.1), labels = NA); 
pie(x=c(0.4,0.3,0.2,0.1), labels = NA); 

plot(x=1, y=1, type='n', axes = FALSE, xlim = c(0,100), ylim = c(0,100))
arrows(x0=0, y0=100, x1 = 80, y1 = 20, length=0.25)

pie(x=c(0.4,0.3,0.2,0.1), labels = NA); 

plot(x=1, y=1, type='n', axes = FALSE, xlim = c(0,100), ylim = c(0,100))
arrows(x0=0, y0=0, x1 = 80, y1 = 90)

pie(x=c(0.4,0.3,0.2,0.1), labels = NA); plot layout arrows arrows pie plot arrows pie
-------------------------------------------------------------------------------------------------------
pdf() width height colorstrip <- function(colors) {
  count <- length(colors)
  m <- matrix(1:count, count, 1)
  par(mai=c(0.2, 2, 1, 2), cex.axis=2, ann=T, tck=-1)
  image(m, col=colors, ylab="", axes=FALSE)
  axis(side=3, at=seq(from=-0.165, to=1.22, by=0.332),
       labels=letters[1:5])
}

library(igraph)
g <- graph.ring(10)

pdf("test_igraph.pdf", width=7, height=7)
layout(matrix(c(1,2), nrow=2), heights=c(2,0.5))
plot(g)
colorstrip(c("red", "mediumseagreen", "yellow", "blue"))
dev.off()
-------------------------------------------------------------------------------------------------------
library(raster)
r1 <- raster(nrows=500, ncols=500, 
         ext=extent(c(-20, 60.00893, -40.00893, 40)),
         crs='+proj=longlat +datum=WGS84')
r1[] <- rnorm(500*500,0,1)

r2 <- raster(nrows=50, ncols=50, 
         ext=extent(c(355500, 428500, 2879500, 2952500)),
         crs='+proj=utm +zone=36 +datum=WGS84 +units=m')
r2[] <- rnorm(50*50,0,1) library(rgdal) 
# Make a SpatialPolygon from the extent of r2
r2extent <- as(extent(r2), 'SpatialPolygons')
# Assign this SpatialPolygon the good projection
proj4string(r2extent) <- proj4string(r2)
# Transform the projection to that of r1
r2extr1proj <- spTransform(r2extent, CRS(proj4string(r1))) r1crop <- crop(r1, r2extr1proj)
layout(matrix(c(1:2), nrow=1))
plot(r1crop)
plot(r2)
-------------------------------------------------------------------------------------------------------
# some fake data
n <- 5
x <- y <- seq_len(n)
z <- outer(x, y, "/")*rnorm(n) # create a matrix of values

# color palette function
pal <- colorRampPalette(c("green", "red"))

# setup plotting regions
layout(matrix(1:2), heights=c(0.7,0.3))

# make an image of the matrix
# ("n" turns off the axis labeling)
image(x, y, z, xaxt="n", yaxt="n", col=pal(11), asp=1, pty="s")
axis(1, x, letters[1:5])
axis(2, y, letters[6:10])

# add a cheap colorbar...
cz <- pretty(range(z))
cx <- seq_along(cz)
image(x=cx, z=matrix(cz), xaxt="n", yaxt="n", col=pal(11))
axis(1, cx, cz) z
-------------------------------------------------------------------------------------------------------
par(oma=...) ann=FALSE mtext(..., outer=TRUE) layout(matrix(1:2,ncol=1),widths=1,heights=c(2,2),respect=FALSE)
par(mar = rep(0, 4), oma=c(4, 4, 4, 2), las=1)
plot(rnorm(100), type='l', ann=FALSE, xaxt='n')
plot(rnorm(100), type='l', ann=FALSE)

title("Hi", outer=TRUE)
mtext("x-axis", 1, 3, outer=TRUE)
mtext("y-axis", 2, 3, outer=TRUE, las=0) las
-------------------------------------------------------------------------------------------------------
layout par(mfrow=...) layout(matrix(1:8,ncol=2))
par(mar = c(0, 4.1, 4.1, 2.1))
plot(rnorm(100),main="Hi1",type='l',ylab='',xaxt='n')
par(mar = c(4.1, 4.1, 0, 2.1))
plot(rnorm(100),main="",xlab="Hi1",type='l',ylab='')

par(mar = c(0, 4.1, 4.1, 2.1))
plot(rnorm(100),main="Hi2",type='l',ylab='',xaxt='n')
par(mar = c(4.1, 4.1, 0, 2.1))
plot(rnorm(100),main="",xlab="Hi2",type='l',ylab='')

par(mar = c(0, 4.1, 4.1, 2.1))
plot(rnorm(100),main="Hi3",type='l',ylab='',xaxt='n')
par(mar = c(4.1, 4.1, 0, 2.1))
plot(rnorm(100),main="",xlab="Hi3",type='l',ylab='')

par(mar = c(0, 4.1, 4.1, 2.1))
plot(rnorm(100),main="Hi4",type='l',ylab='',xaxt='n')
par(mar = c(4.1, 4.1, 0, 2.1))
plot(rnorm(100),main="",xlab="Hi4",type='l',ylab='') matrix(1:8,ncol=2)
     [,1] [,2]
[1,]    1    5
[2,]    2    6
[3,]    3    7
[4,]    4    8
-------------------------------------------------------------------------------------------------------
plot.modwt plot.modwt my.plot.modwt nf = layout(matrix(c(3, 1, 4, 2, 7, 5,8, 6), 4, 2, byrow = TRUE), 
     c(2,2), c(2,1, 2, 1), TRUE)
layout.show(nf) my.plot.modwt(modwt(dat1))
my.plot.modwt(modwt(dat2))
my.plot.modwt(modwt(dat3))
my.plot.modwt(modwt(dat4)) y.plot.modwt = function (x, levels = NULL, draw.boundary = FALSE, type = "stack", 
          col.plot = "black", col.boundary = "red", X.xtick.at = NULL, 
          X.ytick.at = NULL, Stack.xtick.at = NULL, Stack.ytick.at = NULL, 
          X.xlab = "t", y.rlabs = TRUE, plot.X = TRUE, plot.W = TRUE, 
          plot.V = TRUE, ...) 
{
  stackplot.modwt <- function(x, w.range, v.range, col.plot, 
                              col.boundary, draw.boundary, X.xtick.at, X.ytick.at, 
                              Stack.xtick.at, Stack.ytick.at, X.xlab = "t", plot.X = TRUE) {
    innerplot <- function(x, y, type = "l", xtick.at, ytick.at) {
      if (is.null(xtick.at) == FALSE || is.null(ytick.at) == 
            FALSE) {
        plot(x, y, type = "l", axes = FALSE, frame.plot = TRUE)
        <snip>

if (plot.X) {
      #nf <- layout(matrix(c(2, 2, 1, 1), 2, 2, byrow = TRUE), c(1, 2), c(2, 1), TRUE)
      par(mai = c(0.6, 0.4, 0.1, 0.6))

<snip>
}
-------------------------------------------------------------------------------------------------------
library(rworldmap)
newmap <- getMap(resolution = "coarse") #'low' or even 'coarse' resolution map may be sufficient

#example data for 2 years 6 months each
month <- c(1:6,1:6)
year <- c(rep(2012,6),rep(2013,6))
lon <- c(120:131)
lat <- c(-35:-24)
p1 <- data.frame(month=month,year=year,lon=lon,lat=lat)

months <- unique(p1$month)
years <- unique(p1$year)

oldPar <- par(mar=c(2, 0, 0, 2)) #margins top,bottom,left,right

#use layout to create multiple panels including space at top for a title
nPanels <- layout( cbind(c(0,1:6),c(0,7:12)), heights=c(lcm(1),rep(1,6)), respect=F )


for( yrNum in 1:length(years) )
{
  yr <- years[yrNum]
  for( moNum in 1:length(months) )
  {
    mo <- months[moNum]

    cat(yr,mo,"\n")

    plot(newmap, xlim = c(110, 155), ylim = c(-35, -20), asp = 1)
    mtext( paste(yr,"month",mo), cex=0.7) #add titile to subplot

    pMoYr <- p1[ p1$year==yr & p1$month==mo, ]

    points(pMoYr$lon, pMoYr$lat, col = "red", cex = 3)
  }
}

mtext("rworldmap layout demo",outer=TRUE,line=-2)

par(oldPar)
-------------------------------------------------------------------------------------------------------
data(varespec)
data(varechem)

ord <- rda(varespec)

set.seed(1)
(fit <- envfit(ord, varechem, perm = 999))

## make up a fake `status`
status <- factor(rep(c("Class1","Class2"), times = nrow(varespec) / 2))

> head(status)
[1] Class1 Class2 Class1 Class2 Class1 Class2 layout(matrix(1:2, ncol = 2))
## auto version
plot(fit, add = FALSE)

## manual version with extra things
colvec <-  c("red","green")
scl <- -1
plot(ord, type = "n", scaling = scl)
points(ord, display = "sites", col = colvec[status], pch = (1:2)[status])
points(ord, display = "species", pch = "+")
plot(fit, add = TRUE, col = "black")
layout(1) envfit
-------------------------------------------------------------------------------------------------------
#Your data
formdate <- read.table(text="
ISO3\tCountry\tFormation Date
DZA\tAlgeria\t07-03-1962
AGO\tAngola\t11-11-1975
BWA\tBotswana\t09-30-1966
CMR\tCameroon\t01-01-1960
BGD\tBangladesh\t03-26-1971
IND\tIndia\t08-15-1947
ISR\tIsrael\t05-14-1948
LOS\tLaos\t10-22-1953
MYS\tMalaysia\t09-16-1963
SGP\tSingapore\t08-09-1965"
,sep="\t",header=TRUE)

#just using year as a first step
formdate$Formation.Year<-year(formdate$Formation.Date)

#sPDF <- joinCountryData2Map( formdate, joinCode="ISO3", nameJoinColumn="ISO3")
#joining by country name works better because of incorrect ISO3 code for Laos in the data
sPDF <- joinCountryData2Map( formdate, joinCode="NAME", nameJoinColumn="Country")

#Using defaults, change catMethod, numCats & colourPalette to change map appearance
mapCountryData(sPDF, nameColumnToPlot="Formation.Year") #I've used these breaks that work with your sample data, 
#simply cahnge to work with full dataset
yearBreak1 <- 1960
yearBreak2 <- 1970

oldPar <- par(mar=c(0.7, 0, 0, 0)) #set margins for subplots top,bottom,left,right
#use layout to set up 3 panels
nPanels <- layout( cbind(c(0,1:3)), heights=c(lcm(0.5),c(1,1,1)), respect=F )

#add a constant column to allow plotting all countries the same colour 
formdate$constant <- 1

#subet data by yearBreaks
dF1 <- formdate[ formdate$Formation.Year <= yearBreak1, ]  
dF2 <- formdate[ formdate$Formation.Year > yearBreak1 & formdate$Formation.Year <= yearBreak2, ]                          
dF3 <- formdate[ formdate$Formation.Year > yearBreak2, ]                          

#join to a map
sPDF1 <- joinCountryData2Map( dF1, joinCode="NAME", nameJoinColumn="Country")
sPDF2 <- joinCountryData2Map( dF2, joinCode="NAME", nameJoinColumn="Country")
sPDF3 <- joinCountryData2Map( dF3, joinCode="NAME", nameJoinColumn="Country")

#plot & add titles
mapCountryData(sPDF1, nameColumnToPlot="constant", catMethod='categorical', addLegend=FALSE, mapTitle="" )
mtext(paste("<=",yearBreak1))
mapCountryData(sPDF2, nameColumnToPlot="constant", catMethod='categorical', addLegend=FALSE, mapTitle="" )
mtext(paste(">",yearBreak1,"& <=",yearBreak1))
mapCountryData(sPDF3, nameColumnToPlot="constant", catMethod='categorical', addLegend=FALSE, mapTitle="" )     
mtext(paste(">",yearBreak2))
-------------------------------------------------------------------------------------------------------
layout filled contour layout(matrix(c(1,2),nrow=1), width=c(4,1) )
# your plot code here

#
plot(1,1, xlim=c(0,.21), ylim=c(0,100), type="n", mar=c(0,0,0,0),
   oma=c(0,0,0,0) , axes=FALSE, ylab="", xlab="")
levels<-facetcol; rect(0, levels[-length(facetcol)], 1, levels[-1], col = color)
-------------------------------------------------------------------------------------------------------
griddg Tps xvals <- seq(-10, 4, len=20)
yvals <- seq(49, 63, len=20)
griddf <- expand.grid(lon=xvals, lat=yvals)
griddg <- predict(fit, x=as.matrix(griddf) )

dat2 <- cbind(griddf, mm=griddg)
head(dat2)
fit <- Tps(cbind(dat2$lon, dat2$lat), dat2$mm, scale.type="unscaled")
surface (fit, nx=100, ny=100)
world(add=TRUE) Tps #option 2
source("matrix.poly.r") #http://menugget.blogspot.de/2012/04/create-polygons-from-matrix.html
source("val2col.R") # http://menugget.blogspot.de/2011/09/converting-values-to-color-levels.html
source("image.scale.R") # http://menugget.blogspot.de/2011/08/adding-scale-to-image-plot.html

#new grid and predition
xvals <- seq(-10, 4, len=100)
yvals <- seq(49, 63, len=100)
griddf <- expand.grid(lon=xvals, lat=yvals)
griddg <- predict(fit, x=as.matrix(griddf) )

#make polygons for new grid, calculate color levels
mat <- matrix(griddg, nrow=length(xvals), ncol=length(yvals))
poly <- matrix.poly(xvals, yvals, z=mat, n=seq(mat))
pal <- colorRampPalette(c("blue", "cyan", "yellow", "red"))
COL <- val2col(mat, col=pal(100))

#required packages
library(maps)
library(mapproj)

#plot
png("tmp.png", width=5, height=4, res=400, units="in")
layout(matrix(1:2, nrow=1, ncol=2), widths=c(4,1), heights=4)
par(mar=c(1,1,1,1))
map("world", proj="stereographic", orient=c(mean(yvals),mean(xvals),0), par=NULL, t="n", xlim=range(xvals), ylim=range(yvals))
for(i in seq(poly)){
 polygon(mapproject(poly[[i]]), col=COL[i], border=COL[i], lwd=0.3)
}
map("world", proj="stereographic", orient=c(mean(yvals),mean(xvals),0), par=NULL, add=T)
map.grid(col=rgb(0,0,0,0.5), labels=F)
box()

par(mar=c(5,0,5,4))
image.scale(mat, col=pal(100), horiz=FALSE, axes=FALSE, xlab="", ylab="")
axis(4)
mtext("mm", side=4, line=2.5)
box()

dev.off()
-------------------------------------------------------------------------------------------------------
library(raster)
# Create a reproducible example
r1 <- raster(ncol=10, nrow=10)
# The first 2 rows are filled with NAs (no value)
r1[] <- c(rep(NA,20),21:100) plot(r1)
r1CropExtent <- drawExtent() r2 <- crop(r1, r1CropExtent) layout(matrix(1:2, nrow=1))
plot(r1)
plot(r2) extent() r1NaM <- is.na(as.matrix(r1)) colNotNA <- which(colSums(r1NaM) != ncol(r1))
rowNotNA <- which(rowSums(r1NaM) != nrow(r1)) crop() r3Extent <- extent(r1, rowNotNA[1], rowNotNA[length(rowNotNA)],
   colNotNA[1], colNotNA[length(colNotNA)])
r3 <- crop(r1, r3Extent) layout(matrix(1:2, nrow=1))
plot(r1)
plot(r3)
-------------------------------------------------------------------------------------------------------
base grid.table library(gridExtra)

layout(matrix(c(1,0,2,0), 2))
hist(iris$Sepal.Length, col="lightblue")
hist(iris$Sepal.Width, col="lightblue")

pushViewport(viewport(y=.25,height=.5))
grid.table(head(iris), h.even.alpha=1, h.odd.alpha=1,
           v.even.alpha=0.5, v.odd.alpha=1) viewport grid.rect()
-------------------------------------------------------------------------------------------------------
layout(matrix(1:2, nrow=1))
barchart(data_derm$PP_SD_ARBVLZ=="1")
barchart(data_derm$PP_SD_ARBTLZ=="1")
-------------------------------------------------------------------------------------------------------
layout() par(new=TRUE) par(plt=...) library("maps")

par(list(mar=c(0,0,4,0), bg="black"))
plot(0:1, 0:1, type="n", xlab="", ylab="", axes=FALSE)
title("Trois cartes de France se chevauchant", col.main="white")

# Random colors to highlight the overlapping.
set.seed(13)

par(list(new=TRUE, plt=c(.6, 1, .1, .9)))
plot(map("france", plot=FALSE), type="l", axes=FALSE, xlab="", ylab="", col=sample(c("white", "blue", "red"), 1))
par(list(new=TRUE, plt=c(.3, .7, .1, .9)))
plot(map("france", plot=FALSE), type="l", axes=FALSE, xlab="", ylab="", col=sample(c("white", "blue", "red"), 1))
par(list(new=TRUE, plt=c(0, .4, .1, .9)))
plot(map("france", plot=FALSE), type="l", axes=FALSE, xlab="", ylab="", col=sample(c("white", "blue", "red"), 1))
-------------------------------------------------------------------------------------------------------
scatter_fill <- function (x, y, z,xlim=c(min(x),max(x)),ylim=c(min(y),max(y)),zlim=c(min(z),max(z)),
                          nlevels = 20, plot.title, plot.axes, 
                          key.title, key.axes, asp = NA, xaxs = "i", 
                          yaxs = "i", las = 1, 
                          axes = TRUE, frame.plot = axes, ...) 
{
  mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar
  on.exit(par(par.orig))
  w <- (3 + mar.orig[2L]) * par("csi") * 2.54
  layout(matrix(c(2, 1), ncol = 2L), widths = c(1, lcm(w)))
  par(las = las)
  mar <- mar.orig
  mar[4L] <- mar[2L]
  mar[2L] <- 1
  par(mar = mar)

# choose colors to interpolate
levels <- seq(zlim[1],zlim[2],length.out = nlevels)
col <- colorRampPalette(c("red","yellow","dark green"))(nlevels)  
colz <- col[cut(z,nlevels)]  
#   
plot.new()
plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i", yaxs = "i")

rect(0, levels[-length(levels)], 1, levels[-1L],col=col,border=col) 
if (missing(key.axes)) {if (axes){axis(4)}}
       else key.axes
   box()
   if (!missing(key.title)) 
     key.title
   mar <- mar.orig
   mar[4L] <- 1
   par(mar = mar)

   # points
   plot(x,y,type = "n",xaxt='n',yaxt='n',xlab="",ylab="",xlim=xlim,ylim=ylim,bty="n")
   points(x,y,col = colz,xaxt='n',yaxt='n',xlab="",ylab="",bty="n",...)

   ## options to make mapping more customizable

        if (missing(plot.axes)) {
          if (axes) {
            title(main = "", xlab = "", ylab = "")
            Axis(x, side = 1)
            Axis(y, side = 2)
          }
        }
        else plot.axes
        if (frame.plot) 
          box()
        if (missing(plot.title)) 
          title(...)
        else plot.title
        invisible()
 } # random vectors
vx <- rnorm(40,0,1)
vy <- rnorm(40,0,1)
vz <- rnorm(40,10,10)

scatter_fill(vx,vy,vz,nlevels=15,xlim=c(-1,1),ylim=c(-1,5),zlim=c(-10,10),main="TEST",pch=".",cex=8)
-------------------------------------------------------------------------------------------------------
def.par <- par(no.readonly = TRUE)

## divide device into two rows and 1 column 
## allocate figure 1  for barplot
## allocate figure 2 for barplot labels
## respect relations between widths and heights

nf <- layout(matrix(c(1,1,2,2),2,2,byrow = TRUE), c(1,3), c(3,1), TRUE)
layout.show(nf)

## barplot 
par(mar = c(0,1,1,1))
set.seed(1)
nKol <- 8  ## you can change here but more than 11 cols 
           ## the solution is not really readable
data <- matrix(sample(1:4,nKol*4,rep=TRUE),ncol=nKol)
xx <- barplot(data, beside=TRUE,
              col=c("darkred","red","grey20","grey40"))

## labels , create d ummy plot for sacles
par(mar = c(1,1,0,1))
plot(seq_len(length(xx)),rep(1,length(xx)),type='n',axes=FALSE)
## Create some text labels 
labels <- paste("Label", seq_len(ncol(xx)), sep = " ")
## Plot text labels with some rotation at the top of the current figure
text(seq_len(length(xx)),rep(1.4,length(xx)), srt = 90, adj = 1,
     labels = labels, xpd = TRUE,cex=0.8,srt=60,
     col=c("darkred","red","grey20","grey40"))

par(def.par)  #- reset to default
-------------------------------------------------------------------------------------------------------
grid.text('plot1', vp=vplayout(1,1)) grid.newpage()
pushViewport(viewport(layout = grid.layout(1,2)))

plot1 <- qplot(rnorm(100))
print(plot1,vp=vplayout(1,1))
grid.text('plot1', x=.5, y=.95, vp=vplayout(1,1))

plot2 <- qplot(rnorm(10))
print(plot2,vp=vplayout(1,2))
grid.text('plot2', x=.5, y=.95, vp=vplayout(1,2)) ggtitle grid.text gridExtra require(gridExtra)
grid.arrange(
  plot1 + ggtitle('plot1'), 
  plot2 + ggtitle('plot2'),
  nrow=1)
-------------------------------------------------------------------------------------------------------
plot.new frame() cat('\\newpage') <<,fig=TRUE,echo=FALSE>>=
plotSingle <- function(x) {
   plot.new()   ##  ~ frame()
   plot(0)
}
for(i in 1:3) plotSingle(mtcars)
@ <<,echo=FALSE>>=

plotSingle <- function(x) {

   layout(matrix(1:3,nrow=3))
   plot(0,main=x)          ## the 3 plots statement here are different
   plot(1,main=x)          ## you can just change the title also and it will works
   plot(2,main=x)          ## keep in mind to give knitr different plot statement.

}

 for(i in 1:5)  plotSingle(i)  ## you have also to give different iodex here
                               ## plotSingle(0) will not work for example.
@
-------------------------------------------------------------------------------------------------------
matplot library(randomForest)
model = randomForest(Species ~., data=iris, ntree=100, proximity=T)
layout(matrix(c(1,2),nrow=1),
       width=c(4,1)) 
par(mar=c(5,4,4,0)) #No margin on the right side
plot(model, log="y")
par(mar=c(5,0,4,2)) #No margin on the left side
plot(c(0,1),type="n", axes=F, xlab="", ylab="")
legend("top", colnames(model$err.rate),col=1:4,cex=0.8,fill=1:4)
-------------------------------------------------------------------------------------------------------
scatterplot() layout par("mfg") abline() set.seed(1)
d <- data.frame(x=rnorm(10,mean=10),y=rnorm(10,mean=12))
library(car) scatterplot(y~x,data=d,reset.par=FALSE)
k <- 1              
for (i in 1:2) {
   for (j in 1:2) {
      par(mfg=c(i,j,2,2))
        abline(0,1,lwd=3,col=k)
        k <- k+1
  } scatterplot() scatterplot(y~x,data=d)
 uu <- par("usr")
 ## mimic layout frolm car:::scatterplot.default.  Would be different if we were drawing only one
 ## of x-boxes or y-boxes
 layout(matrix(c(1, 0, 3, 2), 2, 2), widths = c(5, 95), heights = c(95, 5))
 oldmar <- par(mar=rep(0,4))  ## zero out margins so we can plot in sub-boxes without errors
 ## now skip through the first two sub-plots
 par(new=TRUE); plot.new(); par(new=TRUE); plot.new()
 par(oldmar)  ## reset margins
 ## blank plot with user limits set and 'interior' axis calculations
 plot(0:1,0:1,xlab="",ylab="",xlim=uu[1:2],ylim=uu[3:4],xaxs="i",yaxs="i")
 ## add annotation
 abline(a=0,b=1,col=4,lwd=3) scatterplot abline()
-------------------------------------------------------------------------------------------------------
x <- get(varchoice, myData) hist(x, col="blue") library(gWidgets2)
options(guiToolkit="tcltk")

myData <- mtcars
w <- gwindow("Make a histogram", visible=FALSE)
lyt <- glayout(cont=w)
lyt[1,1] <- "Variables"
lyt[2,1] <- "Choose one"
lyt[2,2:4] <- (tbl <- gtable(names(myData), cont=lyt))
size(tbl) <- c(200, 100)
lyt[3,1] <- (btn <- gbutton("ok", cont=lyt))

addHandlerClicked(btn, handler=function(h,...) {
  x <- get(svalue(tbl), myData)
  hist(x, col="blue")
})
visible(w) <- TRUE
-------------------------------------------------------------------------------------------------------
set.seed(10)
N <- 1000
B = rt(N,df=10)
C = rchisq(N,df=10)
op <- layout(matrix(c(1,2),ncol=2,nrow=1))
qqnorm(B,col='green',ylab='student')
qqline(B, col = 2)
qqnorm(C,col='blue',ylab=expression( chi^2 ))
qqline(C, col = 2)
-------------------------------------------------------------------------------------------------------
image.plot fields image.plot image graphics library(grid)
x=1:10
y=1:10
z=matrix(-50:49,10,10)

layout(matrix(c(1,2),ncol=2), widths=c(2,1))         
par(mar=c(5,3,5,3))
image(x,y,z,yaxt="n",xaxt="n", ylab="", xlab="",col=heat.colors(50)) 
cap <- grid.cap()
grid.newpage()
grid.raster(cap, x=unit(0.6,'npc'), #You can modify that if the plot 
            y=unit(0.5,'npc'),      #ends up outside the figure area
            vp=viewport(angle=36))
mtext("Some fancy title",side=3,cex=1.5,line=2) #Plot your title
par(mar=c(5,8,5,3))
plot(NA,ax=F,ann=F,type="n",xlim=c(0,1),ylim=c(0,50),yaxs="i")
for(i in 1:50)rect(0,i-1,1,i,col=heat.colors(50)[i],border=NA)
box()
axis(4,las=2,at=seq(0,50,by=10),labels=seq(-50,50,by=20))
-------------------------------------------------------------------------------------------------------
library(rgdal)
library(ggplot2)
library(RColorBrewer)
library(reshape)
library(gridExtra)

setwd("<directory with all your files...>")

get.centroids = function(x){   # extract centroids from polygon with given ID
  poly = wmap@polygons[[x]]
  ID   = poly@ID
  centroid = as.numeric(poly@labpt)
  return(c(id=ID, c.long=centroid[1], c.lat=centroid[2]))
}

wmap   <- readOGR(dsn=".", layer="ne_110m_admin_0_countries")
wyield <- read.csv(file = "AllWorldCountries_CCShocksGTAP.csv", header=TRUE)
wyield <- transform(wyield, ID_1 = substr(ID_1,3,10))  #strip leading "TR"

# wmap@data and wyield have common, unique field: name
wdata  <- data.frame(id=rownames(wmap@data),name=wmap@data$name)
wdata  <- merge(wdata,wyield, by="name")
labs   <- do.call(rbind,lapply(1:17,get.centroids)) # extract polygon IDs and centroids from shapefile
wdata  <- merge(wdata,labs,by="id")
wdata[c("c.lat","c.long")] <- sapply(wdata[c("c.lat","c.long")],function(x) as.numeric(as.character(x)))

wmap.df <- fortify(wmap)                # data frame for world map
wmap.df <- merge(wmap.df,wdata,by="id") # merge data to fill polygons

palette <- brewer.pal(11,"Spectral")    # ColorBrewewr.org spectral palette, 11 colors
ggmap   <- ggplot(wmap.df, aes(x=long, y=lat, group=group))
ggmap   <- ggmap + geom_polygon(aes(fill=AVG))
ggmap   <- ggmap + geom_path(colour="grey50", size=.1)
ggmap   <- ggmap + geom_text(aes(x=c.long, y=c.lat, label=ID_1),size=3)
ggmap   <- ggmap + scale_fill_gradientn(name="% Change",colours=rev(palette))
ggmap   <- ggmap + theme(plot.title=element_text(face="bold"),legend.position="left")
ggmap   <- ggmap + coord_fixed()
ggmap   <- ggmap + labs(x="",y="",title="Average Yield Impacts across SRES Scenarios (% Change)")
ggmap   <- ggmap + theme(plot.margin=unit(c(0,0.03,0,0.05),units="npc"))
ggmap

box.df       <- wdata[order(as.numeric(wdata$ID_1)),]    # order by ID_1
box.df$label <- with(box.df, paste0(name_long," [",ID_1,"]")) # create labels for boxplot
box.df       <- melt(box.df,id.vars="label",measure.vars=c("A1B","A1BLow","A1F","A1T","A2","B1","B1Low","B2"))
box.df$label <- factor(box.df$label,levels=unique(box.df$label)) # need this so orderin is maintained in ggplot

ggbox   <- ggplot(box.df,aes(x=label, y=value))
ggbox   <- ggbox + geom_boxplot(fill="grey", outlier.colour = "blue", outlier.shape = 16, outlier.size = 4)
ggbox   <- ggbox + stat_summary(fun.y=mean, geom="point", shape=21, size= 4, color= "red")
ggbox   <- ggbox + coord_flip()
ggbox   <- ggbox + labs(x="", y="% Change", title="Distribution of Yield Impacts by GTAP region")
ggbox   <- ggbox + theme(plot.title=element_text(face="bold"), axis.text=element_text(color="black"))
ggbox   <- ggbox + theme(plot.margin=unit(c(0,0.03,0,0.0),units="npc"))
ggbox

grid.newpage()
pushViewport(viewport(layout=grid.layout(2,1,heights=c(0.40,0.60))))
print(ggmap, vp=viewport(layout.pos.row=1,layout.pos.col=1))
print(ggbox, vp=viewport(layout.pos.row=2,layout.pos.col=1)) ggplot coord_fixed() ## re-order the shapefile
wyield <- cbind(id=rownames(wmap@data),wyield) wmap@data wyield wyield name wmp.df id wdata  <- data.frame(id=rownames(wmap@data),name=wmap@data$name)
wdata  <- merge(wdata,wyield, by="name")
...
wmap.df <- fortify(wmap)                # data frame for world map
wmap.df <- merge(wmap.df,wdata,by="id") # merge data to fill polygons
-------------------------------------------------------------------------------------------------------
m <- matrix(c(1,1,1,
              2,3,4,
              5,6,7), ncol=3, by=T)
l <- layout(m)
layout.show(l)  # show layout to doublecheck

# layout cells are filled in the order of the numbers
# set par, e.g. mar each time if required

for (i in 1:7) {
  par(mar=c(i,i,i,i))
  hist(rnorm(100), col=i)
}
-------------------------------------------------------------------------------------------------------
set.seed(1618)
multiplot(height = 8, width = 6, rows = 5, cols = 3, matrix = c(1,1,1, 1,1,1, 2,3,4,5,6,7,8,9,10))
for (i in 11:20) {
  plot(rcauchy(i), pch = 19, col = i)
}
dev.copy2pdf(file = "./tmp.pdf") multiplot <- function(width = 8.5, height = 11, rows, cols, matrix = c(1, 1)) {
    x11(width, height)
    layout(matrix(c(matrix), rows, cols, byrow = TRUE))
}
-------------------------------------------------------------------------------------------------------
cut() time <- c(1:200)
temp <- (time %% 51) * (-1)^(time %/% 51) + rnorm(200)
data <- data.frame(time,temp) 

layout(matrix(c(1, 1, 2, 2, 3, 4, 5 ,6), nrow=2))
plot(data, main='All data')

time2 <- cut(time, c(0, 50, 101, 152, 200))
plot(data, col=time2, main='All data, by time2')
data2 <- split(data, time2)

for (i in 1:4) {
 plot(data2[[i]], main=names(data2)[i])
} time <- c(1:200)
temp <- (time %% 51) * (-1)^(time %/% 51) + rnorm(200)
data <- data.frame(time,temp) 

layout(matrix(c(1, 1, 2, 2, 3, 4, 5 ,6), nrow=2))
plot(data, main='All data')


tol <- 10 # Here you set the minimum value to consider as a structural break
time2 <- cut(time, c(0, which(abs(diff(data$temp)) >= tol), max(time)), rigth=FALSE)

plot(data, col=time2, main='All data, by time2')
data2 <- split(data, time2)

for (i in 1:4) {
 plot(data2[[i]], main=names(data2)[i])
}
-------------------------------------------------------------------------------------------------------
layout() m <- matrix(c(1,1,0,0,
              1,1,0,0,
              2,2,2,2,
              2,2,2,2,
              2,2,2,2,
              2,2,2,2), ncol  = 4, byrow = TRUE)
layout(m)
plot(1:10)
plot(rnorm(10000), rnorm(10000))
layout(1) 0 1 2 layout.show() layout(m)
layout.show(n = 2) ## next `n` plots widths heights
-------------------------------------------------------------------------------------------------------
z <- LETTERS[1:7]

df <- list(
  data.frame(ID=LETTERS[1:3],
             LON=c(1,10,12),
             LAT=c(1,14,13)),
  data.frame(ID=LETTERS[3:5],
             LON=c(2,11,18),
             LAT=c(2,9,20))
  )


layout(t(1:2))
for (i in 1:2){  
  plot(df[[i]]$LON, df[[i]]$LAT, 
       col = rainbow(length(z))[match(df[[i]]$ID,z)], 
       pch=16)
  legend("topleft", 
         legend=z, 
         col=rainbow(length(z)),
         pch=16)
}
-------------------------------------------------------------------------------------------------------
## 'base' plot
p1 <- ggplot(data=LakeLevels) + geom_line(aes(x=Elevation,y=Day)) + 
    scale_x_continuous(name="Elevation (m)",limits=c(75,125))

## plot with "transformed" axis
p2<-ggplot(data=LakeLevels)+geom_line(aes(x=Elevation, y=Day))+
    scale_x_continuous(name="Elevation (ft)", limits=c(75,125),
                   breaks=c(90,101,120),
                   labels=round(c(90,101,120)*3.24084) ## labels convert to feet
                   )

## extract gtable
g1 <- ggplot_gtable(ggplot_build(p1))
g2 <- ggplot_gtable(ggplot_build(p2))

## overlap the panel of the 2nd plot on that of the 1st plot
pp <- c(subset(g1$layout, name=="panel", se=t:r))

g <- gtable_add_grob(g1, g2$grobs[[which(g2$layout$name=="panel")]], pp$t, pp$l, pp$b, 
               pp$l) g <- gtable_add_grob(g1, g1$grobs[[which(g1$layout$name=="panel")]], pp$t, pp$l, pp$b, pp$l) ## steal axis from second plot and modify
ia <- which(g2$layout$name == "axis-b")
ga <- g2$grobs[[ia]]
ax <- ga$children[[2]] whatever_grob$heights gtable_add_rows() y x ## switch position of ticks and labels
ax$heights <- rev(ax$heights)
ax$grobs <- rev(ax$grobs)
ax$grobs[[2]]$y <- ax$grobs[[2]]$y - unit(1, "npc") + unit(0.15, "cm")

## modify existing row to be tall enough for axis
g$heights[[2]] <- g$heights[g2$layout[ia,]$t]

## add new axis
g <- gtable_add_grob(g, ax, 2, 4, 2, 4)

## add new row for upper axis label
g <- gtable_add_rows(g, g2$heights[1], 1)
g <- gtable_add_grob(g, g2$grob[[6]], 2, 4, 2, 4)

# draw it
grid.draw(g) gtable_show_layout()
-------------------------------------------------------------------------------------------------------
require(plyr)  
require(grid)

# FIRST TRY PLOT INDIVIDUAL TEXT GROBS
qplot(0:1000,0:1000,geom="blank") +
  alply(textdf,1,function(x){
  annotation_custom(textGrob(label=x$label,0,0,c("center","center"),gp=gpar(cex=x$size)),x$x,x$x,x$y,x$y)  
}) # THEN USE wordcloud() TO GET CO-ORDS
plot.new()
wordlayout(textdf$x,textdf$y,words=textdf$label,cex=textdf$size,xlim=c(min(textdf$x),max(textdf$x)),ylim=c(min(textdf$y),max(textdf$y)))
plotdata<-cbind(data.frame(rownames(w)),w)
colnames(plotdata)=c("word","x","y","w","h")

# PLOT WORDCLOUD DATA
qplot(0:1000,0:1000,geom="blank") +
  alply(plotdata,1,function(x){
    annotation_custom(textGrob(label=x$word,0,0,c("center","center"),gp=gpar(cex=x$h*40)),x$x,x$x,x$y,x$y)  
  }) # make a png file of just the panel
plot.new()
png(filename="bgplot.png")
par(mar=c(0.01,0.01,0.01,0.01))
textplot(textdf$x,textdf$y,textdf$label,textdf$size,xaxt="n",yaxt="n",xlab="",ylab="",asp=1)
dev.off()

# library to get PNG file
require(png)  

# then plot it behind the panel
qplot(0:1000,0:1000,geom="blank") + 
  annotation_custom(rasterGrob(readPNG("bgplot.png"),0,0,1,1,just=c("left","bottom")),0,1000,0,1000) +
  coord_fixed(1,c(0,1000),c(0,1000))
-------------------------------------------------------------------------------------------------------
