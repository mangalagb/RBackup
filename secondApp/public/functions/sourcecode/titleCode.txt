library(maptools)
substitute your shapefiles here
state.map <- readShapeSpatial("BRASIL.shp")
counties.map <- readShapeSpatial("55mu2500gsd.shp")
## this is the variable we will be plotting
counties.map@data$noise <- rnorm(nrow(counties.map@data)) plot.heat <- function(counties.map,state.map,z,title=NULL,breaks=NULL,reverse=FALSE,cex.legend=1,bw=.2,col.vec=NULL,plot.legend=TRUE) {
  ##Break down the value variable
  if (is.null(breaks)) {
    breaks=
      seq(
          floor(min(counties.map@data[,z],na.rm=TRUE)*10)/10
          ,
          ceiling(max(counties.map@data[,z],na.rm=TRUE)*10)/10
          ,.1)
  }
  counties.map@data$zCat <- cut(counties.map@data[,z],breaks,include.lowest=TRUE)
  cutpoints <- levels(counties.map@data$zCat)
  if (is.null(col.vec)) col.vec <- heat.colors(length(levels(counties.map@data$zCat)))
  if (reverse) {
    cutpointsColors <- rev(col.vec)
  } else {
    cutpointsColors <- col.vec
  }
  levels(counties.map@data$zCat) <- cutpointsColors
  plot(counties.map,border=gray(.8), lwd=bw,axes = FALSE, las = 1,col=as.character(counties.map@data$zCat))
  if (!is.null(state.map)) {
    plot(state.map,add=TRUE,lwd=1)
  }
  ##with(counties.map.c,text(x,y,name,cex=0.75))
  if (plot.legend) legend("bottomleft", cutpoints, fill = cutpointsColors,bty="n",title=title,cex=cex.legend)
  ##title("Cartogram")
} plot.heat(counties.map,state.map,z="noise",breaks=c(-Inf,-2,-1,0,1,2,Inf))
-------------------------------------------------------------------------------------------------------
abcplot<-plot(pc) title(main='abc',xlab='xx',ylab='yy')

sdfplot<-plot(pcs) title(main='sdf',xlab='sdf',ylab='xcv')

abcplot # Displays the abc plot
sdfplot # Displays the sdf plot
abcplot # Displays the abc plot again
-------------------------------------------------------------------------------------------------------
R test <- read.table("/tmp/test.txt", header=TRUE)
png(filename="/tmp/test.png", height=750, width=1000, 
    bg="white", res=300)
par(mar=c(2.5,2.5,0.75,0.75), 
    family="Gill Sans", font=1, # font 2 would be bold
    cex=0.75, cex.lab=0.75, cex.axis=0.75) 
mymax <- max(test$Region1, test$Region2)*1.25

plot(test$Region1, type="b", col="#304E67", 
     ylim=c(0, mymax), lwd=3,
     bty="l", axes=FALSE, ann=FALSE, cex=1.0, tck=1)

axis(1, lwd.ticks=0, at=1:length(test$Year), lab=test$Year)
axis(2, lwd=0, las=1, at=c(0,25,50,75,100), yaxp=c(0,100,4))
# grid(nx = NA, ny = 5, col = "lightgray") # wrong, see axTicks
for(y in c(25, 50, 75, 100)) {
  lines(rep(y, length(test$Region1)), type="l", col="lightgray", lwd=1)
}

lines(test$Region1, type="b", col="#304E67", lwd=3)
lines(test$Region2, type="b", col="#974449", lwd=3)

# title(xlab="Year", col.lab=rgb(0,0.5,0))
# title(ylab="Output", col.lab=rgb(0,0.5,0))
legend(1, mymax+8, c("Region 1","Region 2"), cex=0.75, 
       col=c("#304E67" ,"#974449"), 
       pch=1:1, # circles
       lty=1:1, # solid 
       lwd=1.5, # line width
       bty="n") # no box around

dev.off() Year Region1 Region2
2007 17 55
2008 26 43
2009 53 70
2010 96 58
-------------------------------------------------------------------------------------------------------
library(maps);
library(RColorBrewer);

# Create Dummy Data Frame to Play With

d = rbind(c('fairfield','connecticut',17),c('westchester','new york',70), c('luzerne','pennsylvania',1));
d = data.frame(d);
names(d) = c("county", "state", "count");
d$count = as.numeric(as.character(d$count));
d$stcon = paste(d$state, d$county, sep=",");

# Extract mapnames for States

mapnames2 = map("county",c("new york","new jersey", "connecticut", "pennsylvania"),plot=FALSE)[4]$names;
mapnames2 = data.frame(mapnames2);
names(mapnames2) = "stcon";

# Merge with d

d = merge(mapnames2, d, all = T);
d$count[is.na(d$count)] = 0;


# Color bins
colors = brewer.pal(5, "PuBu");
d$colorBuckets = as.factor(as.numeric(cut(d$count,c(0,10,20,30,40,50,300))));

map("county"
  ,c("new york","new jersey", "connecticut", "pennsylvania")
  ,col = colors[d$colorBuckets]
  ,fill = TRUE
  ,resolution = 0
  ,lty = 0
  ,lwd= 0.5
)
map("state"
  ,c("new york","new jersey", "connecticut", "pennsylvania")
  ,col = "black"
  ,fill=FALSE
  ,add=TRUE
  ,lty=1
  ,lwd=2
)

map("county"
   ,c("new york","new jersey", "connecticut", "pennsylvania")
   ,col = "black"
   ,fill=FALSE
   ,add=TRUE
  , lty=1
  , lwd=.5
)
title(main="Respondent Home ZIP Codes by County")
-------------------------------------------------------------------------------------------------------
TRUE/FALSE lm() predict() severity.lm ## Dataset from 
#  apsnet.org/education/advancedplantpath/topics/
#    RModules/doc1/04_Linear_regression.html

## Disease severity as a function of temperature

# Response variable, disease severity
diseasesev<-c(1.9,3.1,3.3,4.8,5.3,6.1,6.4,7.6,9.8,12.4)

# Predictor variable, (Centigrade)
temperature<-c(2,1,5,5,20,20,23,10,30,25)

## For convenience, the data may be formatted into a dataframe
severity <- as.data.frame(cbind(diseasesev,temperature))

## Fit a linear model for the data and summarize the output from function lm()
severity.lm <- lm(diseasesev~temperature,data=severity)

## Get datapoints predicted by best fit line and confidence bands
## at every 0.01 interval
xRange=data.frame(temperature=seq(min(temperature),max(temperature),0.01))
pred4plot <- predict(
  severity.lm,
  xRange,
  level=0.95,
  interval="confidence"
) modelConfInt <- predict(
  severity.lm,
  level = 0.95,
  interval = "confidence"
)

insideInterval <- modelConfInt[,'lwr'] < severity[['diseasesev']] &
  severity[['diseasesev']] < modelConfInt[,'upr'] plot() points() matplot() par(new=TRUE) add=TRUE par(new=TRUE) add par() # Take a look at the data- those points inside the interval
plot(
  diseasesev~temperature,
  data=severity[ insideInterval,],
  xlab="Temperature",
  ylab="% Disease Severity",
  pch=16,
  pty="s",
  xlim=c(0,30),
  ylim=c(0,30)
)
title(main="Graph of % Disease Severity vs Temperature")

# Add points outside the interval, color differently
points(
  diseasesev~temperature,
  pch = 16,
  col = 'red',
  data = severity[ !insideInterval,]
)

# Add regression line and confidence intervals
matplot(
  xRange,
  pred4plot,
  lty=c(1,2,2),   #vector of line types and widths
  type="l",       #type of plot for each column of y
  add = TRUE
)
-------------------------------------------------------------------------------------------------------
def pair(data, labels=None):
    """ Generate something similar to R `pair` """

    nVariables = data.shape[1]
    if labels is None:
        labels = ['var%d'%i for i in range(nVariables)]
    fig = pl.figure()
    for i in range(nVariables):
        for j in range(nVariables):
            nSub = i * nVariables + j + 1
            ax = fig.add_subplot(nVariables, nVariables, nSub)
            if i == j:
                ax.hist(data[:,i])
                ax.set_title(labels[i])
            else:
                ax.plot(data[:,i], data[:,j], '.k')

    return fig
-------------------------------------------------------------------------------------------------------
diseasesev<-c(1.9,3.1,3.3,4.8,5.3,6.1,6.4,7.6,9.8,12.4)

# Predictor variable, (Centigrade)
temperature<-c(2,1,5,5,20,20,23,10,30,25)

## For convenience, the data may be formatted into a dataframe
severity <- as.data.frame(cbind(diseasesev,temperature))

## Fit a linear model for the data and summarize the output from function lm()
severity.lm <- lm(diseasesev~temperature,data=severity)

line1 <- severity.lm$coefficients * c(1,2)
line2 <- severity.lm$coefficients * c(1,.5)

df <- as.data.frame(severity.lm[[12]])
df2 <- adply(df,1,function(x) cbind(line1[2]*x[[2]]+line1[1], line2[2]*x[[2]]+line2[1]))

plot(
  df2[df2[,1] >= min(df2[,c(3,4)]) & df2[,1] <= max(df2[,c(3,4)]),c(2,1)],
  xlab="Temperature",
  ylab="% Disease Severity",
  pch=16,
  pty="s",
  xlim=c(0,30),
  ylim=c(0,30)
)
title(main="Graph of % Disease Severity vs Temperature")
par(new=TRUE) # don't start a new plot
abline(severity.lm, col="blue")
abline(line1, col="cyan")
abline(line2, col="cyan")
points(df2[df2[,1] < min(df2[,c(3,4)]) | df2[,1] > max(df2[,c(3,4)]),c(2,1)], pch = 16, col = 'red')
-------------------------------------------------------------------------------------------------------
help(polygon) example(polygon) demo(graphics) ## An example showing how to fill between curves.

par(bg="white")
n <- 100
x <- c(0,cumsum(rnorm(n)))
y <- c(0,cumsum(rnorm(n)))
xx <- c(0:n, n:0)
yy <- c(x, rev(y))
plot(xx, yy, type="n", xlab="Time", ylab="Distance")
polygon(xx, yy, col="gray")
title("Distance Between Brownian Motions")
-------------------------------------------------------------------------------------------------------
#loess and error curves almost just like ggplot2
op <- par(las=1, mar = c(3,3,1,1))
n <- 30
x <- sort(rnorm(n)) #(varying density in predictor)
x <- x + abs(min(x))
x <- x/max(x)*2*pi 
y <- sin(x)+rnorm(n) #(curvy)
m <- loess(y~x)
xx <- seq(min(x), max(x), (max(x)-min(x))/1000) #increase density of values to predict over to increase quality of curve
f <- predict(m, xx, se = TRUE)
ci <- f$se * qt(0.975, f$df)
cih <- f$fit + ci
cil <- f$fit - ci
plot(x,y, ylim = c(min(cil,y), max(cih,y)), cex.axis = 0.85, xlab = '', ylab = '', type = 'n')
title(xlab = 'x', ylab = 'y',line = 2)
grid(col = 'gray')
points(x,y, pch = 19, cex = 0.65)
lines(xx, f$fit, col = 'blue', lwd = 1.2)
xx <- c(xx, rev(xx))
yy <- c(cil, rev(cih))
polygon(xx, yy, col=rgb(0.1,0.1,0.1,0.25), border = NA)
par(op)

#qplot(x,y, geom = 'point') + stat_smooth()
-------------------------------------------------------------------------------------------------------
png("pngfile.png")
plot(foo)
title(main="bar")
dev.off() sink("foo.file")
-------------------------------------------------------------------------------------------------------
mtcars pdf("foo.pdf")
boxplot(mpg ~ cyl, data = mtcars, ylab = "Potrošnja goriva", xlab = "Broj cilindara", main = "Dijagram raspršenja")
dev.off() Warning messages:
1: In title(ylab = "Potrošnja goriva", xlab = "Broj cilindara", main = "Dijagram raspršenja") :
  conversion failure on 'Dijagram raspršenja' in 'mbcsToSbcs': dot substituted for <c5>
2: In title(ylab = "Potrošnja goriva", xlab = "Broj cilindara", main = "Dijagram raspršenja") :
  conversion failure on 'Dijagram raspršenja' in 'mbcsToSbcs': dot substituted for <a1>
3: In title(ylab = "Potrošnja goriva", xlab = "Broj cilindara", main = "Dijagram raspršenja") :
  conversion failure on 'Dijagram raspršenja' in 'mbcsToSbcs': dot substituted for <c5>
4: In title(ylab = "Potrošnja goriva", xlab = "Broj cilindara", main = "Dijagram raspršenja") :
  conversion failure on 'Dijagram raspršenja' in 'mbcsToSbcs': dot substituted for <a1>
5: In title(ylab = "Potrošnja goriva", xlab = "Broj cilindara", main = "Dijagram raspršenja") :
  conversion failure on 'Potrošnja goriva' in 'mbcsToSbcs': dot substituted for <c5>
6: In title(ylab = "Potrošnja goriva", xlab = "Broj cilindara", main = "Dijagram raspršenja") :
  conversion failure on 'Potrošnja goriva' in 'mbcsToSbcs': dot substituted for <a1>
7: In title(ylab = "Potrošnja goriva", xlab = "Broj cilindara", main = "Dijagram raspršenja") :
  conversion failure on 'Potrošnja goriva' in 'mbcsToSbcs': dot substituted for <c5>
8: In title(ylab = "Potrošnja goriva", xlab = "Broj cilindara", main = "Dijagram raspršenja") :
  conversion failure on 'Potrošnja goriva' in 'mbcsToSbcs': dot substituted for <a1> options(encoding = "CP1250") pdf.options(encoding = "CP1250") pdf(file = "foo.pdf", encoding = "CP1250") options(encoding = "native.enc") pdf.options pdf.options <<setOptions, echo = FALSE, results = hide>>==
pdf.options(encoding = "CP1250")
@ <<plotTheFigure, echo = TRUE, fig = TRUE>>==
# I've set echo to TRUE intentionally, to prove my point here
boxplot(mpg ~ cyl, data = mtcars, ylab = "Potrošnja goriva", xlab = "Broj cilindara", main = "Dijagram raspršenja")
@
-------------------------------------------------------------------------------------------------------
ttkcombobox require(tcltk)
tt <- tktoplevel()
tkwm.title(tt, "Fruits!")
tkwm.geometry(tt, "200x150+300+300") 

onOK <- function()
    {
    fav <- tclvalue(favFruit)
    worst <- tclvalue(worstFruit)

    if (fav != "Choose one")
        tkmessageBox(title="Favorite fruit", message = paste("Your favorite fruit is", fav))
    if (worst != "Choose one")
        tkmessageBox(title="Worst fruit", message = paste("The fruit you like the least is", worst))

    if (fav == "Choose one" & worst == "Choose one")
        tkmessageBox(title="Well...", message = "Select a fruit!")
    }

label1 <- tklabel(tt, text="What's your favorite fruit?")
label2 <- tklabel(tt, text="What fruit you like the least?")

fruits <- c("Choose one", "Apple", "Orange", "Banana", "Pear")
# Default selections for the two combo boxes
favFruit <- tclVar("Choose one")
worstFruit <- tclVar("Choose one")

# 1st box
combo.1 <- ttkcombobox(tt, values=fruits, textvariable=favFruit, state="readonly") 
# 2nd box
combo.2 <- ttkcombobox(tt, values=fruits, textvariable=worstFruit, state="readonly") 
# If you need to do something when the user changes selection just use
# tkbind(combo.1, "<<ComboboxSelected>>", functionname)

OK.but <- tkbutton(tt,text="   OK   ", command = onOK)

tkpack(label1, combo.1)
tkpack(label2, combo.2)
tkpack(OK.but)

tkfocus(tt) tcltk RGtk2
-------------------------------------------------------------------------------------------------------
xts zoo zoo > x <- zoo(rnorm(5),sprintf("FY%02d",1:5))
> y <- zoo(rnorm(5),sprintf("FY%02d",1:5))
> merge(x,y)
               x           y
FY01  0.32707886 -1.81414982
FY02 -0.95177700  0.37772862
FY03 -0.03052571 -1.13047719
FY04  1.19139973  0.96962871
FY05 -0.76484142 -0.08187144 quantmod::chartSeries xts library(quantmod)
symbols=c("DGS1","DGS2","DGS3","DGS5","DGS7","DGS10","DGS20")
getSymbols(symbols,src="FRED")
all <- na.omit(merge(DGS1,DGS2,DGS3,DGS5,DGS7,DGS10,DGS20))

years <- c(1,2,3,5,7,10,20)
# use xts indexing, since getSymbols returns xts
histDate <- "2007-09-01/2007-09-10"
# create zoo objects for non-time-based indexing
hist <- zoo(t(all[histDate]), order.by=years)
curr <- zoo(t(last(all)), order.by=years)

currHist <- merge(curr,hist)
plotCol <- rainbow(NCOL(currHist))
plot(currHist, screens=1, col=plotCol, pch=20, type="o", ann=FALSE)
title(main="Term Structure of Interest Rates",col.main="red", font.main=4)
title(xlab="Years to Maturity",ylab="Interest Rate",col.lab=rgb(0,0.5,0))
legend(15,1.5,colnames(currHist),cex=0.8,col=plotCol,pch=20)
-------------------------------------------------------------------------------------------------------
textplot() # show R version information
textplot(version)
# show the alphabet as a single string
textplot( paste(letters[1:26], collapse=" ") )

# show the alphabet as a matrix 
textplot( matrix(letters[1:26], ncol=2))

### Make a nice 4 way display with two plots and two text summaries 
data(iris)  
par(mfrow=c(2,2))   
plot( Sepal.Length ~ Species, data=iris, border="blue", col="cyan",   
      main="Boxplot of Sepal Length by Species" )    
plotmeans(Sepal.Length ~ Species, data=iris, barwidth=2, connect=FALSE,
          main="Means and 95\% Confidence Intervals\nof Sepal Length by Species")

info <- sapply(split(iris$Sepal.Length, iris$Species),
               function(x) round(c(Mean=mean(x), SD=sd(x), N=gdata::nobs(x)),2))

textplot( info, valign="top"  )
title("Sepal Length by Species")

reg <- lm( Sepal.Length ~ Species, data=iris )
textplot( capture.output(summary(reg)), valign="top")
title("Regression of Sepal Length by Species")

par(mfrow=c(1,1))
-------------------------------------------------------------------------------------------------------
load fisheriris            %# load some data
%#meas = zscore(meas);     %# to normalize the attributes
h = plot(meas');            %'# plot
set(gca, 'XTick',1:4, 'XTickLabel',{'SL' 'SW' 'PL' 'PW'}, 'XGrid','on')
ylabel('feature value'), title('Parallel Coordinates')

%# color according to class label
c = grp2idx(species);
clr = lines( numel(c) );
arrayfun(@(k) set(h(c==k),'Color',clr(k,:)), unique(c))
-------------------------------------------------------------------------------------------------------
bigmacprice <- data.frame(
    country = c("Switzerland", "Brazil", "Euro area",
        "Canada", "Japan", "United States",
        "Britain", "Singapore", "South Korea",
        "South Africa", "Mexico", "Thailand",
        "Russia", "Malaysia", "China"),
    price = c(6.78, 5.26, 4.79, 4.18, 3.91, 3.71,
              3.63, 3.46, 3.03, 2.79, 2.58, 2.44,
              2.39, 2.25, 2.18)
)


plotbigmac <- function(mac, base = "United States", xlim = c(-40, 100)) {
    mac <- mac[order(mac$price),]
    base = which(mac$country == base)
    height <- (mac$price / mac[base, "price"] - 1) * 100
    par(bg = "#d0e0e7", col.main = "#262324", col.axis = "#393E46",
        mar = c(8, 8, 6, 6), las = 1)
    barplot(height, width = .1, space = .4,
        names.arg = mac$country, #cex.names = .8,
        col = "#01516c", border = "#7199a8", # border = "#577784",
        horiz = TRUE, xlim = c(-40, 100), axes = FALSE)
    axis(3, lty = 0)
    title(main = "Bunfight\nBig Mac index", col = "#393E46")

    abline(v = seq(-100, 100, 10), col = "white", lwd = 2)
    abline(v = 0, col = "#c8454e", lwd = 2)
    par(xpd = TRUE)
    for (i in 1:nrow(mac)) {
        rect(105, (i - 1) / 7, 118, i / 7 - 0.05,
        col = "white", border = "#7199a8")
        text(112, (i - 1) / 7 + 0.05, mac$price[i], cex = 0.8, col = "#393E46")
    }
    rect(-120, 2.5, -90, 3, col = "#c8454e", border = "#c8454e")
    text(-68, -.2, "Sources:", col = "#393E46")
    text(-64, -.3, "McDonald's;", col = "#393E46")
    text(-60, -.4, "The Economist", col = "#393E46")
}

plotbigmac(bigmacprice) barplot barplot plotBigMac <- function(mac, base = "United States") {
    old.par <- par(no.readonly = TRUE)
    on.exit(par(old.par))
    # Create data:
    mac <- mac[order(mac$price),]
    base = which(mac$country == base)
    height <- (mac$price / mac[base, "price"] - 1) * 100
    # Costume 'barplot'
    NN <- length(height)
    width <- rep(1, length.out = NN)
    delta <- width / 2
    w.r <- cumsum(width + 0.5)
    w.m <- w.r - delta
    w.l <- w.m - delta
    xlim <- c(range(-.01 * height, height)[1], 100)
    ylim <- c(min(w.l), max(w.r))
    par(bg = "#d0e0e7", col.main = "#262324", col.axis = "#393E46",
        mar = c(8, 8, 6, 6), las = 1, cex = 0.9)
    plot.new()
    plot.window(xlim, ylim)
    abline(v = seq(-100, 100, 20), col = "white", lwd = 2)
    rect(0, w.l, height, w.r, col = "#01516c", border = "#7199a8", lwd = 1)

    # Lines and axis
    abline(v = 0, col = "#c8454e", lwd = 2)
    axis(3, axTicks(3), abs(axTicks(3)), lty = 0)
    axis(2, labels = mac$country, at = w.m, lty = 0)

    # Move outside of plot area
    par(xpd = TRUE)

    # Text misc.
    text(5, (w.l[base] + w.r[base]) / 2, "nil", font = 3)
    text(8, w.r[NN] + 2.3, "+")
    text(-8, w.r[NN] + 2.3, "-")

    # Create price boxes:
    rect(105, w.l, 125, w.r,
        col = "white", border = "#7199a8", lwd = 1)
    text(115, (w.r + w.l)/2, mac$price, cex = 0.8, col = "#393E46")

}
-------------------------------------------------------------------------------------------------------
... plot legend legend foo.plot <- function(x,y,...) {
    plot(x,y,...)
    legend("bottomleft", "bar", pch = 1, ...)
} > foo.plot(1, 1, xjust = 0.5)
Warning messages:
1: In plot.window(...) : "xjust" is not a graphical parameter
2: In plot.xy(xy, type, ...) : "xjust" is not a graphical parameter
3: In axis(side = side, at = at, labels = labels, ...) :
  "xjust" is not a graphical parameter
4: In axis(side = side, at = at, labels = labels, ...) :
  "xjust" is not a graphical parameter
5: In box(...) : "xjust" is not a graphical parameter
6: In title(...) : "xjust" is not a graphical parameter plot.default axis box localPlot() plot() bar.plot <- function(x, y, pch = 1, ...) {
    localPlot <- function(..., legend, fill, border, angle, density,
                          xjust, yjust, x.intersp, y.intersp,
                          text.width, text.col, merge, trace, plot = TRUE, ncol,
                          horiz, title, inset, title.col, box.lwd,
                          box.lty, box.col, pt.bg, pt.cex, pt.lwd) plot(...)
    localPlot(x, y, pch = pch, ...)
    legend(x = "bottomleft", legend = "bar", pch = pch, ...)
} 'plot' TRUE bar.plot(1, 1, xjust = 0.5, title = "foobar", pch = 3) bty bty 'pch' bar.plot() 'pch' lme() la.args <- function(x = "bottomleft", legend = "bar", pch = 1, ...)
    c(list(x = x, legend = legend, pch = pch), list(...))

foo.plot <- function(x,y, legend.args = la.args(), ...) {
    plot(x, y, ...)
    do.call(legend, legend.args)
} foo.plot(1,1, xaxt = "n", legend.args=la.args(bg = "yellow", title = "legend")) la.args() la.args()
-------------------------------------------------------------------------------------------------------
x <- 10*(1:nrow(volcano))
 y <- 10*(1:ncol(volcano))
 image(x, y, volcano, col = terrain.colors( length(seq(90, 200, by = 5))-1), axes = FALSE, breaks= seq(90, 200, by = 5) )
 axis(1, at = seq(100, 800, by = 100))
 axis(2, at = seq(100, 600, by = 100))
 box()
 title(main = "Maunga Whau Volcano", font.main = 4)



 x <- 10*(1:nrow(volcano))
 y <- 10*(1:ncol(volcano))
 image(x, y, volcano, col = terrain.colors( length(seq(150, 200, by = 5))-1), axes = FALSE, breaks= seq(150, 200, by = 5) )
 axis(1, at = seq(100, 800, by = 100))
 axis(2, at = seq(100, 600, by = 100))
 box()
 title(main = "Maunga Whau Volcano Restricted to elevations above 150", font.main = 4)
-------------------------------------------------------------------------------------------------------
plot.TukeyHSD2 <- function (x, ...) {
    for (i in seq_along(x)) {
        xi <- x[[i]][, -4, drop = FALSE]
        yvals <- nrow(xi):1
        plot(c(xi[, "lwr"], xi[, "upr"]), rep.int(yvals, 2), 
            type = "n", axes = FALSE, xlab = "", ylab = "", ...)
        axis(1, ...)
        axis(2, at = nrow(xi):1, labels = dimnames(xi)[[1L]], 
            srt = 0, ...)
        abline(h = yvals, lty = 1, lwd = 1, col = "lightgray")
        abline(v = 0, lty = 2, lwd = 1, ...)
        segments(xi[, "lwr"], yvals, xi[, "upr"], yvals, col="black", ...)
        segments(as.vector(xi), rep.int(yvals - 0.1, 3), as.vector(xi), 
            rep.int(yvals + 0.1, 3), col="black", ...)
        title(main = paste(format(100 * attr(x, "conf.level"), 
            2), "% family-wise confidence level\n", sep = ""), 
            xlab = paste("Differences in mean levels of", names(x)[i]))
        box()
    }
}
-------------------------------------------------------------------------------------------------------
import random 
import networkx as nx
z=[int(random.gammavariate(alpha=9.0,beta=2.0)) for i in range(100)]
G=nx.configuration_model(z) Notes
-----
As described by Newman [1]_.

A non-graphical degree sequence (not realizable by some simple
graph) is allowed since this function returns graphs with self
loops and parallel edges.  An exception is raised if the degree
sequence does not have an even sum.

This configuration model construction process can lead to
duplicate edges and loops.  You can remove the self-loops and
parallel edges (see below) which will likely result in a graph
that doesn't have the exact degree sequence specified.  This
"finite-size effect" decreases as the size of the graph increases.

References
----------
.. [1] M.E.J. Newman, "The structure and function
       of complex networks", SIAM REVIEW 45-2, pp 167-256, 2003.

Examples
--------
>>> from networkx.utils import powerlaw_sequence
>>> z=nx.create_degree_sequence(100,powerlaw_sequence)
>>> G=nx.configuration_model(z)

To remove parallel edges:

>>> G=nx.Graph(G)

To remove self loops:

>>> G.remove_edges_from(G.selfloop_edges()) #!/usr/bin/env python
import random
import matplotlib.pyplot as plt
import networkx as nx

def seq(n):
    return [random.gammavariate(alpha=2.0,beta=1.0) for i in range(100)]    
z=nx.create_degree_sequence(100,seq)
nx.is_valid_degree_sequence(z)
G=nx.configuration_model(z)  # configuration model

degree_sequence=sorted(nx.degree(G).values(),reverse=True) # degree sequence
print "Degree sequence", degree_sequence
dmax=max(degree_sequence)

plt.hist(degree_sequence,bins=dmax)
plt.title("Degree histogram")
plt.ylabel("count")
plt.xlabel("degree")

# draw graph in inset 
plt.axes([0.45,0.45,0.45,0.45])
Gcc=nx.connected_component_subgraphs(G)[0]
pos=nx.spring_layout(Gcc)
plt.axis('off')
nx.draw_networkx_nodes(Gcc,pos,node_size=20)
nx.draw_networkx_edges(Gcc,pos,alpha=0.4)

plt.savefig("degree_histogram.png")
plt.show()
-------------------------------------------------------------------------------------------------------
TkBuildDist <- function(  x=seq(min+(max-min)/nbin/2,
                                max-(max-min)/nbin/2,
                                length.out=nbin),
                          min=0, max=10, nbin=10, logspline=TRUE,
                          intervals=FALSE) {

    if(logspline) logspline <- require(logspline)
    require(tkrplot)

    xxx <- x

    brks <- seq(min, max, length.out=nbin+1)
    nx <- seq( min(brks), max(brks), length.out=250 )

    lx <- ux <- 0
    first <- TRUE

    replot <- if(logspline) {
        if(intervals) {
            function() {
                hist(xxx, breaks=brks, probability=TRUE,xlab='', main='')
                xx <- cut(xxx, brks, labels=FALSE)
                fit <- oldlogspline( interval = cbind(brks[xx], brks[xx+1]) )
                lines( nx, doldlogspline(nx,fit), lwd=3 )
                if(first) {
                    first <<- FALSE
                    lx <<- grconvertX(min, to='ndc')
                    ux <<- grconvertX(max, to='ndc')
                }
            }
        } else {
            function() {
                hist(xxx, breaks=brks, probability=TRUE,xlab='', main='')
                fit <- logspline( xxx )
                lines( nx, dlogspline(nx,fit), lwd=3 )
                if(first) {
                    first <<- FALSE
                    lx <<- grconvertX(min, to='ndc')
                    ux <<- grconvertX(max, to='ndc')
                }
            }
        }
    } else {
        function() {
            hist(xxx, breaks=brks, probability=TRUE,xlab='',main='')
            if(first) {
                first <<- FALSE
                lx <<- grconvertX(min, to='ndc')
                ux <<- grconvertX(max, to='ndc')
            }
        }
    }

    tt <- tktoplevel()
    tkwm.title(tt, "Distribution Builder")

    img <- tkrplot(tt, replot, vscale=1.5, hscale=1.5)
    tkpack(img, side='top')

    tkpack( tkbutton(tt, text='Quit', command=function() tkdestroy(tt)),
           side='right')

    iw <- as.numeric(tcl('image','width',tkcget(img,'-image')))

    mouse1.down <- function(x,y) {
        tx <- (as.numeric(x)-1)/iw
        ux <- (tx-lx)/(ux-lx)*(max-min)+min
        xxx <<- c(xxx,ux)
        tkrreplot(img)
    }

    mouse2.down <- function(x,y) {
        if(length(xxx)) {
            tx <- (as.numeric(x)-1)/iw
            ux <- (tx-lx)/(ux-lx)*(max-min)+min
            w <- which.min( abs(xxx-ux) )
            xxx <<- xxx[-w]
            tkrreplot(img)
        }
    }

    tkbind(img, '<ButtonPress-1>', mouse1.down)
    tkbind(img, '<ButtonPress-2>', mouse2.down)
    tkbind(img, '<ButtonPress-3>', mouse2.down)

    tkwait.window(tt)

    out <- list(x=xxx)
    if(logspline) {
        if( intervals ) {
            xx <- cut(xxx, brks, labels=FALSE)
            out$logspline <- oldlogspline( interval = cbind(brks[xx], brks[xx+1]) )
        } else {
            out$logspline <- logspline(xxx)
        }
    }

    if(intervals) {
        out$intervals <- table(cut(xxx, brks))
    }

    out$breaks <- brks

    return(out)
} TkBuildDist2 <- function( min=0, max=1, nbin=10, logspline=TRUE) {
    if(logspline) logspline <- require(logspline)
    require(tkrplot)

    xxx <- rep( 1/nbin, nbin )

    brks <- seq(min, max, length.out=nbin+1)
    nx <- seq( min, max, length.out=250 )

    lx <- ux <- ly <- uy <- 0
    first <- TRUE

    replot <- if(logspline) {
        function() {
            barplot(xxx, width=diff(brks), xlim=c(min,max), space=0,
                    ylim=c(0,0.5), col=NA)
            axis(1,at=brks)
            xx <- rep( 1:nbin, round(xxx*100) )
            capture.output(fit <- oldlogspline( interval = cbind(brks[xx], brks[xx+1]) ))
            lines( nx, doldlogspline(nx,fit)*(max-min)/nbin, lwd=3 )

            if(first) {
                first <<- FALSE
                lx <<- grconvertX(min, to='ndc')
                ly <<- grconvertY(0,   to='ndc')
                ux <<- grconvertX(max, to='ndc')
                uy <<- grconvertY(0.5, to='ndc')
            }
        }
    } else {
        function() {
            barplot(xxx, width=diff(brks), xlim=range(brks), space=0,
                    ylim=c(0,0.5), col=NA)
            axis(at=brks)
            if(first) {
                first <<- FALSE
                lx <<- grconvertX(min, to='ndc')
                ly <<- grconvertY(0,   to='ndc')
                ux <<- grconvertX(max, to='ndc')
                uy <<- grconvertY(0.5, to='ndc')
            }
        }
    }

    tt <- tktoplevel()
    tkwm.title(tt, "Distribution Builder")

    img <- tkrplot(tt, replot, vscale=1.5, hscale=1.5)
    tkpack(img, side='top')

    tkpack( tkbutton(tt, text='Quit', command=function() tkdestroy(tt)),
           side='right')

    iw <- as.numeric(tcl('image','width',tkcget(img,'-image')))
    ih <- as.numeric(tcl('image','height',tkcget(img,'-image')))



    md <- FALSE

    mouse.move <- function(x,y) {
        if(md) {
            tx <- (as.numeric(x)-1)/iw
            ty <- 1-(as.numeric(y)-1)/ih

            w <- findInterval(tx, seq(lx,ux, length=nbin+1))

            if( w > 0 && w <= nbin && ty >= ly && ty <= uy ) {
                 xxx[w] <<- 0.5*(ty-ly)/(uy-ly)
                xxx[-w] <<- (1-xxx[w])*xxx[-w]/sum(xxx[-w])

                tkrreplot(img)
            }
        }
    }

    mouse.down <- function(x,y) {
        md <<- TRUE
        mouse.move(x,y)
    }

    mouse.up <- function(x,y) {
        md <<- FALSE
    }

    tkbind(img, '<Motion>', mouse.move)
    tkbind(img, '<ButtonPress-1>', mouse.down)
    tkbind(img, '<ButtonRelease-1>', mouse.up)

    tkwait.window(tt)

    out <- list(breaks=brks, probs=xxx)
    if(logspline) {
        xx <- rep( 1:nbin, round(xxx*100) )
        out$logspline <- oldlogspline( interval = cbind(brks[xx], brks[xx+1]) )
    }

    return(out)
}
-------------------------------------------------------------------------------------------------------
## dummy data
dat <- data.frame(Depth = sample(c(3:6), 20, replace = TRUE), OM = 5 * runif(20)) side = 2 ## margin for side 2 is 7 lines in size
op <- par(mar = c(5,7,4,2) + 0.1) ## default is c(5,4,4,2) + 0.1 ## draw the plot but without annotation
boxplot(OM ~ Depth, data = dat, axes = FALSE, ann = FALSE)
## add axes
axis(1, at = 1:4, labels = c(" ", "Shallow", "Deep", " "), cex.axis = 1.5)
axis(2, cex.axis = 2)
## now draw the y-axis annotation on a different line out from the plot
## using the extra margin space:
title(ylab = "Loss of Percent Organic Matter per Year", cex.lab = 1.5,line = 4.5)
## draw the box to finish off
box() par(op) ylab op <- par(mar = c(5,7,4,2) + 0.1) ## default is c(5,4,4,2) + 0.1 op title()
 title(ylab = "Loss of Percent Organic Matter per Year", cex.lab = 1.5,line = 4.5) 4.5 5 'line' 'line' title()
-------------------------------------------------------------------------------------------------------
object1 myfunction = function(input.data, title.str) {
    plot(input.data)
    title(main = title.str)
}

object1 <- data.frame(x = runif(10), y = runif(10))
myfunction(object1, "foo")
-------------------------------------------------------------------------------------------------------
Date dates tbl <- within(tbl, Date <- as.Date(Date, "%d/%m/%Y")) op <- par(mar = c(6,4,4,2) + 0.1) ## larger bottom margin
## plot data but suppress axes and annotation
plot(Version ~ Date, data = tbl, type = "o", axes = FALSE, ann = FALSE)
## Use Axis to plot the Date axis, in 1 month increments
## format the sequence of dates `ds` as abbreviated month name and Year
with(tbl, Axis(Date, at = (ds <- seq(min(Date), max(Date), by = "months")),
               side = 1, labels = format(ds, format = "%b %Y"), las = 2))
## Add y-axis and plot frame
axis(2)
box()
## add on the axis labels
title(ylab = "Version", main = "Releases")
title(xlab = "Date", line = 5) ## pushing the x-axis label down a bit
par(op) ## reset the pars with(tbl, Axis(Date, at = (ds <- seq(min(Date), max(Date), by = "2 months")),
               side = 1, labels = format(ds, format = "%b %y"), las = 2)) with(....)
-------------------------------------------------------------------------------------------------------
start <- as.Date("01/01/2008", "%d/%m/%Y")
end <- as.Date("01/12/2011", "%d/%m/%Y")
x_breaks <- seq(start, end, by = "month") dates Date dates <- as.Date(as.character(tbl$Date), "%d/%m/%Y") las = 3 mar par(las = 3, mar = c(7, 5, 3, 1)) plot(dates,tbl$Version,type="o",main="Releases", xlab="", ylab="Version", xaxt = "n")
axis(side = 1, at = as.numeric(x_breaks), labels = strftime(x_breaks, "%b %Y"))
title(xlab = "Date", line = 5)
-------------------------------------------------------------------------------------------------------
> dput(redata)
structure(c(1093L, 1182L, 1299L, 1372L, 1319L, 1362L, 1239L, 
1162L, 1059L, 921L, 815L, 720L, 835L, 853L, 1034L, 1030L, 1240L, 
1388L, 1429L, 1319L, 1231L, 1184L, 1076L, 825L, 991L, 1093L, 
854L, 808L, 1079L, 1092L, 1220L, 1251L, 1130L, 1131L, 1052L, 
951L, 950L, 1006L, 1112L, 1119L, 1250L, 1322L, 1347L, 1310L, 
1215L, 1128L, 1035L, 992L, 1079L, 1018L, 1112L, 1224L, 1323L, 
1344L, 1326L, 1267L, 1171L, 1075L, 916L, 932L, 888L, 904L, 939L, 
1018L, 1140L, 1174L, 1285L, 1311L, 1298L, 1231L, 1091L, 1088L, 
991L, 1028L, 1177L, 1322L, 1322L, 1398L, 1389L, 1174L, 1196L, 
1115L, 756L, 496L, 693L, 673L, 748L, 777L, 820L, 948L, 966L, 
1027L, 960L, 865L, 767L, 675L, 765L, 732L, 613L, 632L, 659L, 
705L, 684L, 734L, 715L, 626L, 551L, 487L, 500L, 536L, 575L, 595L, 
736L, 798L, 832L, 797L, 792L, 726L, 650L, 584L, 567L, 524L, 574L, 
571L, 591L, 657L, 699L, 756L, 867L, 795L, 760L, 685L, 609L, 588L, 
521L, 581L, 614L, 623L, 668L, 702L, 777L, 697L, 647L, 562L, 523L, 
508L, 493L, 504L, 534L, 586L, 621L, 620L, 636L, 600L, 549L, 557L
), .Dim = 12:13, .Dimnames = list(c("Jan", "Feb", "Mar", "Apr", 
"May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"), c("X1993", 
"X1994", "X1995", "X1996", "X1997", "X1998", "X1999", "X2000", 
"X2001", "X2002", "X2003", "X2004", "X2005"))) monthnames <- c(
"Jan",
"Feb",
"Mar",
"Apr",
"May",
"Jun",
"Jul",
"Aug",
"Sep",
"Oct",
"Nov",
"Dec"
)


# size of window
windows(w=6,h=3)

# margins
par(
mar=c(5.1,5.1,2.1,2.1),
cex.axis=0.7
)

# set up plot with the number of categories and the y limits 
# yaxs="i" sets the yaxis as having no separation from the corner point

ylimlp <-  c(0,max(redata))*1.06
plot(1:156, type="n", xaxt="n", ylim=ylimlp, ann=FALSE, yaxs="i", xaxs="i", bty="l", las="1")

abline(v=seq(13,156,13),lty=1,col="grey")

title(xlab="Month", col.lab=rgb(0,0,0), font.lab=2, cex.lab=0.75)
title(ylab="Listings", col.lab=rgb(0,0,0), font.lab=2, cex.lab=0.75)

lines(redata[1,],type="l",pch=NA,lwd=1,col="grey")
lines(c(rep(NA,13*1),redata[2,]),type="l",pch=NA,lwd=1,col="grey")
lines(c(rep(NA,13*2),redata[3,]),type="l",pch=NA,lwd=1,col="grey")
lines(c(rep(NA,13*3),redata[4,]),type="l",pch=NA,lwd=1,col="grey")
lines(c(rep(NA,13*4),redata[5,]),type="l",pch=NA,lwd=1,col="grey")
lines(c(rep(NA,13*5),redata[6,]),type="l",pch=NA,lwd=1,col="grey")
lines(c(rep(NA,13*6),redata[7,]),type="l",pch=NA,lwd=1,col="grey")
lines(c(rep(NA,13*7),redata[8,]),type="l",pch=NA,lwd=1,col="grey")
lines(c(rep(NA,13*8),redata[9,]),type="l",pch=NA,lwd=1,col="grey")
lines(c(rep(NA,13*9),redata[10,]),type="l",pch=NA,lwd=1,col="grey")
lines(c(rep(NA,13*10),redata[11,]),type="l",pch=NA,lwd=1,col="grey")
lines(c(rep(NA,13*11),redata[12,]),type="l",pch=NA,lwd=1,col="grey")

redatamonthmean <- apply(redata,1,mean)

lines(rep(redatamonthmean[1],13),type="l",pch=NA,lwd=1,col="black")
lines(c(rep(NA,13*1),rep(redatamonthmean[2],13)),type="l",pch=NA,lwd=1,col="black")
lines(c(rep(NA,13*2),rep(redatamonthmean[3],13)),type="l",pch=NA,lwd=1,col="black")
lines(c(rep(NA,13*3),rep(redatamonthmean[4],13)),type="l",pch=NA,lwd=1,col="black")
lines(c(rep(NA,13*4),rep(redatamonthmean[5],13)),type="l",pch=NA,lwd=1,col="black")
lines(c(rep(NA,13*5),rep(redatamonthmean[6],13)),type="l",pch=NA,lwd=1,col="black")
lines(c(rep(NA,13*6),rep(redatamonthmean[7],13)),type="l",pch=NA,lwd=1,col="black")
lines(c(rep(NA,13*7),rep(redatamonthmean[8],13)),type="l",pch=NA,lwd=1,col="black")
lines(c(rep(NA,13*8),rep(redatamonthmean[9],13)),type="l",pch=NA,lwd=1,col="black")
lines(c(rep(NA,13*9),rep(redatamonthmean[10],13)),type="l",pch=NA,lwd=1,col="black")
lines(c(rep(NA,13*10),rep(redatamonthmean[11],13)),type="l",pch=NA,lwd=1,col="black")
lines(c(rep(NA,13*11),rep(redatamonthmean[12],13)),type="l",pch=NA,lwd=1,col="black")

mtext(monthnames[1], side=1, cex=0.7, at=6.5)
mtext(monthnames[2], side=1, cex=0.7, at=6.5*3)
mtext(monthnames[3], side=1, cex=0.7, at=6.5*5)
mtext(monthnames[4], side=1, cex=0.7, at=6.5*7)
mtext(monthnames[5], side=1, cex=0.7, at=6.5*9)
mtext(monthnames[6], side=1, cex=0.7, at=6.5*11)
mtext(monthnames[7], side=1, cex=0.7, at=6.5*13)
mtext(monthnames[8], side=1, cex=0.7, at=6.5*15)
mtext(monthnames[9], side=1, cex=0.7, at=6.5*17)
mtext(monthnames[10], side=1, cex=0.7, at=6.5*19)
mtext(monthnames[11], side=1, cex=0.7, at=6.5*21)
mtext(monthnames[12], side=1, cex=0.7, at=6.5*23)
-------------------------------------------------------------------------------------------------------
arrange <- function(..., nrow=NULL, ncol=NULL, as.table=FALSE, 
                    main=NULL, sub=NULL, plot=TRUE) { 
  dots <- list(...) 
  n <- length(dots) 
  if(is.null(nrow) & is.null(ncol)) { nrow = floor(n/2) ; ncol = ceiling(n/nrow)} 
  if(is.null(nrow)) { nrow = ceiling(n/ncol)} 
  if(is.null(ncol)) { ncol = ceiling(n/nrow)} 
  fg <- frameGrob(layout=grid.layout(nrow,ncol)) 
  ii.p <- 1 
  for(ii.row in seq(1, nrow)){ 
    ii.table.row <- ii.row       
    if(as.table) {ii.table.row <- nrow - ii.table.row + 1} 
    for(ii.col in seq(1, ncol)){ 
      ii.table <- ii.p 
      if(ii.p > n) break 
      fg <- placeGrob(fg, ggplotGrob(dots[[ii.table]]), 
                      row=ii.table.row, col=ii.col) 
      ii.p <- ii.p + 1 
    } 
  } 
  if(!is.null(main) | !is.null(sub)){ 
    g <- frameGrob() # large frame to place title(s) and content 
    g <- packGrob(g, fg) 
    if (!is.null(main)) 
      g <- packGrob(g, textGrob(main), side="top") 
    if (!is.null(sub)) 
      g <- packGrob(g, textGrob(sub), side="bottom") 
  } else { 
    g <- fg 
  } 
  if(plot) grid.draw(g) 
  invisible(g) 
} 

library(ggplot2) 
plots <- llply(1:2, function(.x) qplot(1:10,rnorm(10), main=paste("plot",.x))) 
arrange(plots[[1]],plots[[2]], nrow=1, ncol = 2, as.table=TRUE, main="test main",   
        sub="subtitle test")
-------------------------------------------------------------------------------------------------------
# splits title of plot if to long
splittitle=function(title,linelength=40)
{
    spltitle<-strsplit(title,' ')
    splt<-as.data.frame(spltitle)
    title2<-NULL
    title3<-NULL
    titlelength<-round(nchar(title)/round(nchar(title)/linelength))
    dimsplt<-dim(splt)
    n=1
    doonce2=0
    for(m in 1:round(nchar(title)/linelength)){
  doonce=0
    doonce2=0
    for(l in n:dimsplt[1]){
        if(doonce==0){title2<-title3}
        title2=paste(title2,splt[l,],sep=' ')
        if(doonce2==0){if(nchar(title2)>=(titlelength*m)){title3=paste(title2,'\n',sep='')
        n<-(l+1)
        doonce2=1}
        }
        doonce=1
    }
    }
    title2
}

lab <- "A really really long string!A really really long string!A really really long string!A really really long string!A really really long string!A really really long string!A really really long string!A really really long string!"
lab2<-splittitle(lab)
cat(lab)
cat(lab2)


library('ggplot2') dat <- data.frame(grp = paste(1:6,lab2),x=1:6,y=runif(6))

ggplot(dat,aes(x=x,y=y,colour=grp)) + geom_point() + 
    opts(legend.position="bottom",legend.direction="horizontal") dat <- data.frame(grp = paste(1:6,lab2),x=1:6,y=runif(6))
ggplot(dat,aes(x=x,y=y,colour=grp)) + geom_point() + 
    opts(legend.position="bottom",legend.direction="horizontal")
-------------------------------------------------------------------------------------------------------
with(bruth, plot(p, predict(mod), type="l" )  )
 with(bruth, points(p, g,  col="red") )
 with(bruth, lines(p, predict(mod2), lty=3, lwd=2, col="red") )
 title(main="Different uses of I() and interaction")
-------------------------------------------------------------------------------------------------------
plot(1:1)
dev.new()
plot(2,2)
dev.set(dev.prev()) # go back to first
title(main="test dev 1")

dev.set(dev.next()) # go to second
title(main="test dev 2")
-------------------------------------------------------------------------------------------------------
help(survplot) require(rms)
n <- 1000
set.seed(731)
age <- 50 + 12*rnorm(n)
label(age) <- "Age"
sex <- factor(sample(c('male','female'), n, TRUE))
cens <- 15*runif(n)
h <- .02*exp(.04*(age-50)+.8*(sex=='female'))
dt <- -log(runif(n))/h
label(dt) <- 'Follow-up Time'
e <- ifelse(dt <= cens,1,0)
dt <- pmin(dt, cens)
units(dt) <- "Year"
dd <- datadist(age, sex)
options(datadist='dd')
S <- Surv(dt,e)

# When age is in the model by itself and we predict at the mean age,
# approximate confidence intervals are ok

survplot(f, age=mean(age), conf.int=.95, 
               n.risk=TRUE, adj.n.risk=.75, y.n.risk=-0.15,
               xlab="")
title(main="Simulated Survival Plot Demonstrating Annotation of N-at-risk")
mtext("Follow-up Years", side=1, line=2)
-------------------------------------------------------------------------------------------------------
dataEllipse ellipse dataEllipse
function(x,y, ....
...
else {
        shape <- var(cbind(x, y))
        center <- c(mean(x), mean(y))
    }
    for (level in levels) {
        radius <- sqrt(dfn * qf(level, dfn, dfd) ellipse
function (center, shape, radius, ....)
....
 angles <- (0:segments) * 2 * pi/segments
    unit.circle <- cbind(cos(angles), sin(angles))
    ellipse <- t(center + radius * t(unit.circle %*% chol(shape)))
    colnames(ellipse) <- c("x", "y") getEparams <-function(x,y, level) { dfn <- 2
        dfd <- length(x) - 1
        shape <- var(cbind(x, y))
        center <- c(mean(x), mean(y))
        radius <- sqrt(dfn * qf(level, dfn, dfd))
        return(list(center=center, shape=shape, radius=radius) ) }

ellcalc <- function (center, shape, radius, segments=51){segments=segments
    angles <- (0:segments) * 2 * pi/segments
    unit.circle <- cbind(cos(angles), sin(angles))
    ellipse <- t(center + radius * t(unit.circle %*% chol(shape)))
    colnames(ellipse) <- c("x", "y")
    return(ellipse)}

evals <- getEparams(Query$X, Query$Y, 0.80)
plot(ellcalc(evals[["center"]], evals[["shape"]], evals[["radius"]]))
title(main='Output of plot(ellcalc(evals[["center"]], evals[["shape"]], evals[["radius"]]))\nStackOverflow Demonstration')
 points(Query$X, Query$Y, cex=0.3, col="red") ellcalc
-------------------------------------------------------------------------------------------------------
set.seed(2)
dat <- rnorm(100, mean = 3, sd = 3) sdat <- summary(dat) paste() collapse summStr <- paste(names(sdat), format(sdat, digits = 2), collapse = "; ") format() title() op <- par(mar = c(7,4,4,2) + 0.1)
hist(dat)
title(sub = summStr, line = 5.5)
par(op) line
-------------------------------------------------------------------------------------------------------
qgraph library("qgraph")
data(big5)
data(big5groups)
qgraph(cor(big5),minimum=0.25,cut=0.4,vsize=2,groups=big5groups,legend=TRUE,borders=FALSE)
title("Big 5 correlations",line=-2,cex.main=2)
-------------------------------------------------------------------------------------------------------
# Compare MPG distributions for cars with 
# 4,6, or 8 cylinders
library(sm)
attach(mtcars)

# create value labels 
cyl.f <- factor(cyl, levels= c(4,6,8),
    labels = c("4 cylinder", "6 cylinder", "8 cylinder")) 

# plot densities 
sm.density.compare(mpg, cyl, xlab="Miles Per Gallon")
title(main="MPG Distribution by Car Cylinders")

# add legend via mouse click
colfill<-c(2:(2+length(levels(cyl.f)))) 
legend(locator(1), levels(cyl.f), fill=colfill)
-------------------------------------------------------------------------------------------------------
y <- rnorm(1000, 0, 1) 
x <- rnorm(1000, 0.5, 2) 
DF <- data.frame("Group"=c(rep(c("y","x"), each=1000)), "Value"=c(y,x))

library(sm)

with(DF, sm.density.compare(Value, Group, xlab="Grouping"))
title(main="Comparative Density Graph")
legend(-9, .4, levels(DF$Group), fill=c("red", "darkgreen"))
-------------------------------------------------------------------------------------------------------
cal <- function(month, year) {

        if(!require(chron)) stop('Unable to load chron package')

     if(missing(year) && missing(month)) {
         tmp <- month.day.year(Sys.Date())
         year <- tmp$year
         month <- tmp$month
     }


    if(missing(year) || missing(month)){  # year calendar
        if(missing(year)) year <- month
        par(mfrow=c(4,3))
        tmp <- seq.dates( from=julian(1,1,year), to=julian(12,31,year) )
        tmp2 <- month.day.year(tmp)
        wd <- do.call(day.of.week, tmp2)
        par(mar=c(1.5,1.5,2.5,1.5))
        for(i in 1:12){
            w <- tmp2$month == i
            cs <- cumsum(wd[w]==0)
            if(cs[1] > 0) cs <- cs - 1
            nr <- max( cs ) + 1
            plot.new()
            plot.window( xlim=c(0,6), ylim=c(0,nr+1) )
            text( wd[w], nr - cs -0.5 , tmp2$day[w] )
            title( main=month.name[i] )
            text( 0:6, nr+0.5, c('S','M','T','W','T','F','S') )
        }

    } else {  # month calendar

        ld <- seq.dates( from=julian(month,1,year), length=2, by='months')[2]-1
        days <- seq.dates( from=julian(month,1,year), to=ld)
        tmp <- month.day.year(days)
        wd <- do.call(day.of.week, tmp)
        cs <- cumsum(wd == 0)
        if(cs[1] > 0) cs <- cs - 1
        nr <- max(cs) + 1
        par(oma=c(0.1,0.1,4.6,0.1))
        par(mfrow=c(nr,7))
        par(mar=c(0,0,0,0))
        for(i in seq_len(wd[1])){ 
            plot.new()
            #box()
        }
        day.name <- c('Sun','Mon','Tues','Wed','Thur','Fri','Sat')
        for(i in tmp$day){
            plot.new()
            box()
            text(0,1, i, adj=c(0,1))
            if(i < 8) mtext( day.name[wd[i]+1], line=0.5,
                at=grconvertX(0.5,to='ndc'), outer=TRUE ) 
        }
        mtext(month.name[month], line=2.5, at=0.5, cex=1.75, outer=TRUE)
        #box('inner') #optional 
    }
} par(mfg=c(r,c)) updateusr subplot TeachingDemos cal(10,2011)
par(mfg=c(3,2))  # monday oct 10
text(.5,.5, 'Some\nText', cex=2)

par(mfg=c(2,3)) #Tues oct 4
text(1,1, 'Top Right', adj=c(1,1))

par(mfg=c(2,4)) # Wed oct 5
text(0,0, 'Bottom Left', adj=c(0,0))

par(mfg=c(6,2)) # oct 31
tmp.x <- runif(25)
tmp.y <- rnorm(25,tmp.x,.1)
par(usr=c( range(tmp.x), range(tmp.y) ) )
points(tmp.x,tmp.y)
-------------------------------------------------------------------------------------------------------
line draw.cont.line persp.lm <- 
function (x, form, at, bounds, zlim, zlab, xlabs, col = "white", xlab=xlab,
    contours = NULL, hook, atpos = 3, theta = -25, phi = 20, 
    r = 4, border = NULL, box = TRUE, ticktype = "detailed", ylab,
    ... ) 
{
    draw.cont.line = function(line) {
        if (cont.varycol) {
            cont.col = col
            if (length(col) > 1) 
                cont.col = col[cut(c(line$level, dat$zlim), length(col))][1]
        }
        polygon(trans3d(line$x, line$y, cont.z, transf), col = cont.col, 
            lwd = cont.lwd)
    }
    plot.data = contour.lm(x, form, at, bounds, zlim, xlabs, 
        atpos = atpos, plot.it = FALSE)
    transf = list()
    if (missing(zlab)) 
        zlab = ""
    facet.col = col
    cont = !is.null(contours)
    if (mode(contours) == "logical") 
        cont = contours
    cont.first = cont
    cont.z = cz = plot.data[[1]]$zlim[1]
    cont.col = 1
    cont.varycol = FALSE
    cont.lwd = 1
    if (is.character(contours)) {
        idx = charmatch(contours, c("top", "bottom", "colors"), 
            0)
        if (idx == 1) {
            cont.first = FALSE
            cont.z = plot.data[[1]]$zlim[2]
        }
        else if (idx == 2) {
        }
        else if (idx == 3) {
            cont.varycol = TRUE
            if (length(col) < 2) 
                col = rainbow(40)
        }
        else cont.col = contours
    }
    else if (is.list(contours)) {
        if (!is.null(contours$z)) 
            cz = contours$z
        if (is.numeric(cz)) 
            cont.z = cz
        else if (cz == "top") {
            cont.first = FALSE
            cont.z = plot.data[[1]]$zlim[2]
        }
        if (!is.null(contours$col)) 
            cont.col = contours$col
        if (!is.null(contours$lwd)) 
            cont.lwd = contours$lwd
        if (charmatch(cont.col, "colors", 0) == 1) {
            cont.varycol = TRUE
            if (length(col) < 2) 
                col = rainbow(40)
        }
    }
    for (i in 1:length(plot.data)) {
        dat = plot.data[[i]]
        cont.lines = NULL
        if (!missing(hook)) 
            if (!is.null(hook$pre.plot)) 
                hook$pre.plot(dat$labs)
        if (cont) 
            cont.lines = contourLines(dat$x, dat$y, dat$z)
        if (cont && cont.first) {
            transf = persp(dat$x, dat$y, dat$z, zlim = dat$zlim, xlab=ylab,
                theta = theta, phi = phi, r = r, col = NA, border = NA, 
                box = FALSE)
            lapply(cont.lines, draw.cont.line)
            par(new = TRUE)
        }
        if (length(col) > 1) {
            nrz = nrow(dat$z)
            ncz = ncol(dat$z)
            zfacet = dat$z[-1, -1] + dat$z[-1, -ncz] + dat$z[-nrz, 
                -1] + dat$z[-nrz, -ncz]
            zfacet = c(zfacet/4, dat$zlim)
            facet.col = cut(zfacet, length(col))
            facet.col = col[facet.col]
        }
        transf = persp(dat$x, dat$y, dat$z, xlab = xlab, 
             zlab = zlab, zlim = dat$zlim, ylab=ylab,
            col = facet.col, border = border, box = box, theta = theta, 
            phi = phi, r = r, ticktype = ticktype)
        if (atpos == 3) 
            title(sub = dat$labs[5])
        if (cont && !cont.first) 
            lapply(cont.lines, draw.cont.line)
        if (!missing(hook)) 
            if (!is.null(hook$post.plot)) 
                hook$post.plot(dat$labs)
        plot.data[[i]]$transf = transf
    }
    invisible(plot.data)
}

persp(ct.rsm, Conc ~ kGy, col=rainbow(50), theta=60, xlab="Something",
    phi=0, r = 3, d=1, border = NULL, ltheta = -135, lphi = 0
    , shade = 0.75, zlab="CT",ylab="Concentration %", col.axis=37, font.lab=2,col.lab=33,
    contour=("colors"))
-------------------------------------------------------------------------------------------------------
text(axTicks(1), par("usr")[3] - 2, srt=45, adj=1, labels=lab, xpd=T, cex=0.8) axTicks(1) > axTicks(1)
[1]  5 10 15 1:19 text(1:19, par("usr")[3] - 2, srt=45, adj=1, labels=lab, xpd=T, cex=0.8) Runtime <- c(579,0,581,610,830,828,592,651,596,596,591,581,587,
             594,604,606,447,434,445)
g_range <- range(0,Runtime)
lab <- c('2011-07-20','2011-08-03','2011-08-10','2011-08-17','2011-08-24',
         '2011-08-25','2011-08-27','2011-08-31','2011-09-07','2011-09-10',
         '2011-09-14','2011-09-21','2011-09-28','2011-10-05','2011-10-06',
         '2011-10-07','2011-10-13','2011-10-19','2011-10-31')
## plot
op <- par(mar = c(6,4,4,2) + 0.1) ## bigger bottom margin
plot(Runtime, type="o", col="blue", ylim=g_range, axes=FALSE, ann=FALSE)
box()
axis(1, at=1:19, lab=FALSE)
text(1:19, par("usr")[3] - 40, srt=45, adj=1.2, labels=lab, xpd=T, cex=0.7)
axis(2, las=1, at=500*0:g_range[2])
title(main="Runtime", col.main="red", font.main=4)
title(xlab="Build", col.lab=rgb(0,0.5,0), line = 4.5)
title(ylab="MS", col.lab=rgb(0,0.5,0))
legend("topright", c("AveElapsedTime"), cex=0.8, col=c("blue"), pch=21, lty=1)
## reset par
par(op) y y ## load gridBase
require(gridBase)

## do the base plot parts
op <- par(mar = c(6,4,4,2) + 0.1) ## bigger bottom margin
plot(1:19, Runtime, type="o", col="blue", ylim=g_range, axes=FALSE, ann=FALSE)
box()
axis(1, at=1:19, lab=FALSE)
axis(2, las=1, at=500*0:g_range[2])
title(main="Runtime", col.main="red", font.main=4)
title(xlab="Build", col.lab=rgb(0,0.5,0), line = 4.5)
title(ylab="MS", col.lab=rgb(0,0.5,0))
legend("topright", c("AveElapsedTime"), cex=0.8, col=c("blue"), pch=21, lty=1)
## at this point, DO NOT alter the dimensions of the plotting window

## now do the grid business
vps <- baseViewports()
pushViewport(vps$inner, vps$figure, vps$plot)
## this adds the text
grid.text(lab, x = unit(1:19, "native"), y = unit(-1, "lines"),
          just = "right", rot = 60, gp = gpar(cex = 0.7))
## this finishes off the viewport - you have to do this or things will go wrong:
popViewport(3)
## reset par
par(op) pdf()
-------------------------------------------------------------------------------------------------------
as.expression(z) drawGraph <- function(x, y, z) {
    g_range <- range(0,x)
    plot(x, type="o", col="blue", ylim=g_range,axes=FALSE, ann=FALSE)
    box()
    axis(1, at=1:19, lab=FALSE)
    text(1:19, labels=y,par("usr")[3] - 2, srt=45, adj=1.2, xpd=T, cex=0.3)
    axis(2, las=1, at=500*0:g_range[2])
    main_title<-as.expression(z)
    title(main=main_title, col.main="red", font.main=4)
    title(xlab="Build", col.lab=rgb(0,0.5,0))
    title(ylab="MS", col.lab=rgb(0,0.5,0))
    legend("topright", g_range[2], c("z"), cex=0.8, col=c("blue"), pch=21, lty=1);
}
x <- rpois(19, 4)
AveElapsedTime=paste("The average time with ranges:", 
                       round(range(x)[1], 3), 
                        "to" , round(range(x), 3)[1])
lab=1:19
drawGraph(AET, lab, AveElapsedTime)
-------------------------------------------------------------------------------------------------------
plot(1)
title(main="This is \nTitle") plot(1, main=paste("X:",1," ","Y:", 2," ","\nZ:",3))
-------------------------------------------------------------------------------------------------------
x=1:length(ev)
 plot(x,ev)
 lxy <- loess(ev~x )
 lines(predict(lxy, x=1:length(y)))
 title(main="loess() fit of ev") x=1:length(y); y=c(356.83, 
 973.5, 0, 240.43, 1232.07, 1440, 1329.67, 1096.87, 1331.37, 1305.03, 
 1328.03, 1246.03, 1182.3, 1054.53, 723.03, 1171.53, 1263.17, 
 1200.37, 1054.8, 971.4, 936.4, 968.57, 897.93, 1099.87, 876.43, 
 1095.47, 1132, 774.4, 1075.13, 982.57, 947.33, 1096.97, 929.83, 
 1246.9, 1398.2, 1063.83, 1223.73, 1174.37, 1248.5, 1171.63, 1280.57, 
 1183.33, 1016.23, 1082.1, 795.37, 900.83, 1159.2, 992.5, 967.3, 
 1440, 804.13, 418.17, 559.57, 563.87, 562.97, 1113.1, 954.87, 
 883.8, 1207.1, 1046.83, 995.77, 803.93, 1036.63, 946.9, 887.33, 
 727.97, 733.93, 979.2, 1176.8, 1241.3, 1435.6)

 lxyhi <- loess(y~x)
 plot(x,y)
 lines(predict(lxyhi, x=1:length(y)))
-------------------------------------------------------------------------------------------------------
filled.contour scatter.fill <- function (x, y, z, 
                              nlevels = 20, plot.title, plot.axes, 
                              key.title, key.axes, asp = NA, xaxs = "i", 
                              yaxs = "i", las = 1, 
                              axes = TRUE, frame.plot = axes, ...) 
    {
        mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar
        on.exit(par(par.orig))
        w <- (3 + mar.orig[2L]) * par("csi") * 2.54
        layout(matrix(c(2, 1), ncol = 2L), widths = c(1, lcm(w)))
        par(las = las)
        mar <- mar.orig
        mar[4L] <- mar[2L]
        mar[2L] <- 1
        par(mar = mar)

        #Some simplified level/color picking
        levels <- seq(min(z),max(z),length.out = nlevels)
  col <- colorRampPalette(c("blue","red"))(nlevels)[rank(z)]

        plot.new()
        plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i", 
            yaxs = "i")
  rect(0, levels[-length(levels)], 1, levels[-1L], col = colorRampPalette(c("blue","red"))(nlevels)
        if (missing(key.axes)) {
            if (axes) 
                axis(4)
        }
        else key.axes
        box()
        if (!missing(key.title)) 
            key.title
        mar <- mar.orig
        mar[4L] <- 1
        par(mar = mar)

        #Simplified scatter plot construction
        plot(x,y,type = "n")
        points(x,y,col = col,...)

        if (missing(plot.axes)) {
            if (axes) {
                title(main = "", xlab = "", ylab = "")
                Axis(x, side = 1)
                Axis(y, side = 2)
            }
        }
        else plot.axes
        if (frame.plot) 
            box()
        if (missing(plot.title)) 
            title(...)
        else plot.title
        invisible()
    } x <- runif(40)
y <- runif(40)
z <- runif(40)
scatter.fill(x,y,z,nlevels = 40,pch = 20) filled.contour
-------------------------------------------------------------------------------------------------------
scipen ?options las ?par x <- rnorm(20)^2 * 10000000
layout(matrix(1:2, ncol = 2))
plot(x)
getOption("scipen")
opt <- options("scipen" = 20)
getOption("scipen")
plot(x)
options(opt)
layout(1) plot(x / 10000000, axes = FALSE)
axis(1)
pts <- pretty(x / 10000000)
axis(2, at = pts, labels = paste(pts, "MM", sep = ""))
box() pretty() plot() axis() box() opt <- options("scipen" = 20)
op <- par(mar = c(5,7,4,2) + 0.1) ## extra margin to accommodate tick labs
x <- rnorm(20)^2 * 10000000
plot(x, las = 1, ylab = "")       ## no y-axis label 
title(ylab = "label", line = 5.5) ## need to plot the axis label
par(op)
options(opt) las plot() las = 1 axis() op <- par(mar = c(5,5,4,2) + 0.1)
plot(x / 10000000, axes = FALSE, ylab = "")
axis(1)
pts <- pretty(x / 10000000)
axis(2, at = pts, labels = paste(pts, "MM", sep = ""), las = 1)
title(ylab = "my label", line = 4)
box()
par(op)
-------------------------------------------------------------------------------------------------------
is.OHLC plot plot.xts2 <- function (x, y = NULL, type = "l", auto.grid = TRUE, major.ticks = "auto", 
    minor.ticks = TRUE, major.format = TRUE, bar.col = "grey", 
    candle.col = "white", ann = TRUE, axes = TRUE, col = "black", ...) 
{
    series.title <- deparse(substitute(x))
    ep <- axTicksByTime(x, major.ticks, format = major.format)
    otype <- type
    if (xts:::is.OHLC(x) && type %in% c("candles", "bars")) {
        x <- x[, xts:::has.OHLC(x, TRUE)]
        xycoords <- list(x = .index(x), y = seq(min(x), max(x), 
                length.out = NROW(x)))
        type <- "n"
    }
    else {
        if (NCOL(x) > 1) 
            warning("only the univariate series will be plotted")
        if (is.null(y)) 
            xycoords <- xy.coords(.index(x), x[, 1])
    }
    plot(xycoords$x, xycoords$y, type = type, axes = FALSE, ann = FALSE, 
        col = col, ...)
    if (auto.grid) {
        abline(v = xycoords$x[ep], col = "grey", lty = 4)
        grid(NA, NULL)
    }
    if (xts:::is.OHLC(x) && otype == "candles") 
        plot.ohlc.candles(x, bar.col = bar.col, candle.col = candle.col, 
            ...)
    dots <- list(...)
    if (axes) {
        if (minor.ticks) 
            axis(1, at = xycoords$x, labels = FALSE, col = "#BBBBBB", 
                ...)
        axis(1, at = xycoords$x[ep], labels = names(ep), las = 1, 
            lwd = 1, mgp = c(3, 2, 0), ...)
        axis(2, ...)
    }
    box()
    if (!"main" %in% names(dots)) 
        title(main = series.title)
    do.call("title", list(...))
    assign(".plot.xts", recordPlot(), .GlobalEnv)
}

plot.xts2(as.xts(sample_matrix[,1]), col = "blue")
-------------------------------------------------------------------------------------------------------
set.seed(1)
    # make data.frame just with info for the lines you'll actually draw
    # your data was mostly zeros, no need for those lines
    position <- sort(sample(1:4563,45,replace = FALSE))
    # but the x position needs to be shaved down!
    # modulars are the real x positions on the plot:
    xpos <- position%%600
    # line direction appeared in your example but not in your text
    posorneg <- sample(c(-1,1),45,replace = TRUE,prob=c(.05,.95))
    # oxidant concentration for line width- just rescale the oxidant concentration
    # values you have to fall between say .5 and 3, or whatever is nice and visible
    oxconc   <- (.5+runif(45))^2
    # oxidant type determines line type- you mention 2
    # just assign these types to lines types (integers in R)
    oxitype  <- sample(c(1,2),45,replace = TRUE) 
    # let's say there's another dimension you want to map color to
    # in your example png, but not in your description.
    color <- sample(c("green","black","blue"),45,replace=TRUE)

    # and finally, which level does each segment need to belong to?
    # you have 8 line levels in your example png. This works, might take
    # some staring though:
    level <- 0
    for (i in 0:7){
    level[position %in% ((i*600):(i*600+599))] <- 8-i
    }

    # now stick into data.drame:
    AminoData <-data.frame(position = position, xpos = xpos, posorneg = posorneg, 
         oxconc = oxconc, oxitype = oxitype, level = level, color = color) # now we draw the base plot:
    par(mar=c(3,3,3,3))
    plot(NULL, type = "n", axes = FALSE, xlab = "", ylab = "", 
         ylim =  c(0,9), xlim = c(-10,609))
    # horizontal segments:
    segments(0,1:8,599,1:8,gray(.5))
    # some ticks: (also not pretty)
    segments(rep(c((0:5)*100,599),8), rep(1:8,each=7)-.05, rep(c((0:5)*100,599),8), 
       rep(1:8,each=7)+.05, col=gray(.5))
    # label endpoints:
    text(rep(10,8)+.2,1:8-.2,(7:0)*600,pos=2,cex=.8)
    text(rep(589,8)+.2,1:8-.2,(7:0)*600+599,pos=4,cex=.8)
    # now the amino line segments, remember segments() is vectorized
    segments(AminoData$xpos, AminoData$level, AminoData$xpos, 
       AminoData$level + .5 * AminoData$posorneg, lty = AminoData$oxitype, 
       lwd = AminoData$oxconc, col = as.character(AminoData$color))
    title("mostly you just need to reshape and prepare\nyour data to do this easily in base")
-------------------------------------------------------------------------------------------------------
bquote() x <- 1:10
y <- 3
z <- 5
plot(x,x)
title(main = bquote(sigma[v] == .(y) ~~ rho == .(z)))
-------------------------------------------------------------------------------------------------------
fields:::image.plot par("fg" = NA)
    plot(r, xlim = c(xmin(r), xmax(r)), ylim = c(ymin(r), ymax(r)), axes = FALSE)
    par(new = TRUE,"fg" = "black")
    plot(r, xlim = c(xmin(r), xmax(r)), ylim = c(ymin(r), ymax(r)), axes = FALSE, legend.only = TRUE)
    axis(1, pos = -90, xpd = TRUE)
    rect(-180,-90,180,90,xpd = TRUE)
    ticks <- (ymin(r):ymax(r))[(ymin(r):ymax(r)) %% 20 == 0]
    segments(xmin(r),ticks,xmin(r)-5,ticks, xpd = TRUE)
    text(xmin(r),ticks,ticks,xpd=TRUE,pos=2)
        title("sorry, this could probably be done in some more elegant way")
-------------------------------------------------------------------------------------------------------
library(ggplot2)

# Define function. Fitted parameters included as default values.
HillFunction = function(x, ec50=0.01, hill=0.7, rmax=1.0) {
    result = rmax / (1 + (ec50 / x)^hill)
    return(result)
} 

# Create x such that points are evenly spread in log space.
x = 10^seq(-5, 5, 0.2) 
y_fit = HillFunction(x)
y_raw = y_fit + rnorm(length(y_fit), sd=0.05)

dat = data.frame(x, y_fit, y_raw)

plot_1 = ggplot(data=dat, aes(x=x, y=y_raw)) +
         geom_point() +
         geom_line(data=dat, aes(x=x, y=y_fit), colour="red") +
         scale_x_log10() +
         opts(title="Figure 1. Proposed workaround.")

png("plot_1.png", height=450, width=450)
print(plot_1)
dev.off() stat_function() HillFunction() x missing values HillFunction() x x scale_x_log10() stat_function() y_fit plot_2 = ggplot(dat, aes(x=x, y=y_fit)) +
         geom_point() +
         stat_function(fun=HillFunction, colour="red") +
         scale_x_log10() +
         opts(title="Figure 2. stat_function() misbehaving?")

png("plot_2.png", height=450, width=450)
print(plot_2)
dev.off()


png("plot_3.png", height=450, width=450)

plot(x, y_fit, pch=20, log="x")
curve(HillFunction, col="red", add=TRUE)
title("Figure 3. curve() behaving as expected.")

dev.off()
-------------------------------------------------------------------------------------------------------
fm plot.rqs trace par <- list par plot.summary.rqs par library(quantreg)
example(plot.rqs) # fm to use in example

# plot.rqs
plot.rqs <- quantreg::plot.rqs
trace("plot.rqs", quote(par <- list), print = FALSE)

# plot.summary.rqs
plot.summary.rqs <- quantreg::plot.summary.rqs
trace("plot.summary.rqs", quote(par <- list), print = FALSE)

# test it out
op <- par(mfrow = c(2, 2))

plot(summary(fm))
plot(fm)
title("My Plots", outer = TRUE, line = -1)

par(op) plot.summary.rqs
-------------------------------------------------------------------------------------------------------
# make a data series
my.stat <- rnorm(100,sd=2.5)
# get its standard dev:
my.sd <- sd(my.stat)
# convert series to distance in sd:
my.lj.stat <- (my.stat - mean(my.stat)) / my.sd

plot(1:100, my.lj.stat, type = "o", pch = 19, col = "blue", ylab = "sd", xlab = "observation",
    main = paste("mean value of", round(mean(my.stat),3),"\nstandard deviation of",round(my.sd,3)))

# a low tech L-J chart function:
LJchart <- function(series, ...){
    xbar        <- mean(series)
    se          <- sd(series)
    conv.series <- (my.stat - xbar) / se

    plot(1:length(series), conv.series, type = "o", pch = 19, col = "blue", ylab = "sd", xlab = "observation",
        main = paste("mean value of", round(xbar,3), "\nstandard deviation of", round(se,3)), ...)
}

LJchart(rnorm(100,sd=2.5)) ... ... LJchart <- function(series, ...){
    xbar        <- mean(series)
    se          <- sd(series)
    conv.series <- (my.stat - xbar) / se

    plot(1:length(series), conv.series, type = "n", ...)
    rect(0, -1, length(series)+1, 1, col = gray(.9), border = NA)
    lines(1:length(series), conv.series, ...)
    points(1:length(series), conv.series, ...)
    if (! "main" %in% names(list(...))) {
        title(paste("mean value of", round(xbar,3), "\nstandard deviation of", round(se,3)))
    }
}

LJchart(rnorm(100,sd=2.5), xlab = "observations", ylab = "sd", col = "blue", pch = 19)
-------------------------------------------------------------------------------------------------------
plot (
x, y, type="o",
xlab = "",         #Don't include xlab in main plot
ylab = "Y values",
cex.axis = "2",
cex.lab = "2",
las = 1
)
title(xlab="X values",mgp=c(6,1,0))    #Set the distance of title from plot to 6 (default is 3).
-------------------------------------------------------------------------------------------------------
i "i" for (i in c("JUL","AUG","SEPT","OCT","NOV","DEC")){
  plot(Thorny.Lmm[["r",i]], Thorny.Lmm[["Lmm",i]], type="l")
  abline(h=0, lty=2) 
  title(main=paste("Thorny skate in", i))
}
dev.off()
-------------------------------------------------------------------------------------------------------
for (i in c("JUL","AUG","SEPT","OCT","NOV","DEC")){
  plot(Thorny.Lmm[["r",i]], Thorny.Lmm[["Lmm", i]], type="l")
  abline(h=0, lty=2) 
  title(main=paste("Thorny skate in", i))
}
dev.off() plotter <- function(month){
    plot(Thorny.Lmm[["r",month]], Thorny.Lmm[["Lmm",month]], type="l")
    abline(h=0, lty=2)
    title(main=paste("Thorny" month))
}

lapply(colnames(Thorny.Lmm), plotter)
-------------------------------------------------------------------------------------------------------
par(mfrow = c(2,1), mar = c(4,4,1,1), oma=c(2,2,2,2))
stuff <- c("ed", "bla")
cols <- c("red", "blue")
for(i in 1:length(stuff)) {
x <- rnorm(10,3,2)
y <- seq(1,10)
plot(x,y, type = "o", col = cols[i], xlab = paste("stuff about", stuff[i]))}
legend("bottomright", legend = stuff, col = cols, lwd = 1, bty = "n")
par(mfrow=c(1,1))
title(main = "ed & bla", outer = T)
mtext("This is a plot", 3, line=0.5, adj=1.0, cex=1, outer=TRUE)
-------------------------------------------------------------------------------------------------------
%# read file lines
fid = fopen('data.txt', 'rt', 'native', 'UTF-8');
C = textscan(fid, '%s', 'Delimiter','\n');
fclose(fid);
C = C{1};

%# split into labels/data
labels = C(1:2:end);
data = cellfun(@str2num, C(2:2:end), 'UniformOutput',false);
data = cell2mat(data);

%# HACK: MATLAB has issues displaying unicode text
labels = num2str((1:size(data,1))', 'Point %d'); %# you might need to normalize the attributes
%#data = zscore(data);

plot(data');            %'# plot lines
set(gca, 'XTick',1:numDim, 'XGrid','on')
xlabel('Features'), ylabel('Feature value')
title('Parallel Coordinates')
legend(labels)          %# show legend of labels %# parallel coordinates (similar the above)
parallelcoords(data, 'Group',labels)

%# glyph plot (stars)
glyphplot(data, 'obslabels',labels, 'glyph','star') %# glyph plot (Chernoff faces)
glyphplot(data, 'obslabels',labels, 'glyph','face') %# Andrews curves
andrewsplot(data, 'Group',labels)
-------------------------------------------------------------------------------------------------------
ex1221new ex1221 Sleuth2 ggplot ggplot data.frame xlab() ylab() scale_*.* library("Sleuth2")
library("ggplot2")
ggplot(ex1221, aes(Discharge, Area)) +
  geom_point(aes(size=NO3)) + 
  scale_size_area() + 
  xlab("My x label") +
  ylab("My y label") +
  ggtitle("Weighted Scatterplot of Watershed Area vs. Discharge and Nitrogen Levels (PPM)") ggplot(ex1221, aes(Discharge, Area)) +
  geom_point(aes(size=NO3)) + 
  scale_size_area("Nitrogen") + 
  scale_x_continuous("My x label") +
  scale_y_continuous("My y label") +
  ggtitle("Weighted Scatterplot of Watershed Area vs. Discharge and Nitrogen Levels (PPM)") labs ggplot(ex1221, aes(Discharge, Area)) +
  geom_point(aes(size=NO3)) + 
  scale_size_area() + 
  labs(size= "Nitrogen",
       x = "My x label",
       y = "My y label",
       title = "Weighted Scatterplot of Watershed Area vs. Discharge and Nitrogen Levels (PPM)")
-------------------------------------------------------------------------------------------------------
> splittitle("abc defg hi jkl m", 6) [1] " abc defg\n hi\n jkl m" RGraphics::splitString library(RGraphics)
multiLines <- function(text, maxWidth=11) {
  textLen = nchar(text)
  maxHeight = ceiling(textLen/maxWidth)*1.5
  vp=viewport(width=maxWidth,height=maxHeight, default.units="char")
  pushViewport(vp) #activate the viewport
  text2 = splitString(text) #given vp, split the text
  popViewport() #get rid of it
  return(text2)
}
-------------------------------------------------------------------------------------------------------
setHeader(header='Content-Disposition', 'attachment; filename=rpdf.pdf')
setContentType("application/pdf")
t <- tempfile()
pdf(t)
attach(mtcars)
plot(wt, mpg)
abline(lm(mpg~wt))
title("PDF Report")
dev.off()
setHeader('Content-Length',file.info(t)$size)
sendBin(readBin(t,'raw',n=file.info(t)$size))
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(plyr)
library(gridExtra)

plotone = function(d) ggplot(d, aes(x, y)) + 
                        geom_point() + 
                        ggtitle(unique(d$z))
p = dlply(dat, "z", plotone)
g = do.call(marrangeGrob, c(p, list(nrow=3, ncol=3)))
g
ggsave("multipage.pdf", g)
-------------------------------------------------------------------------------------------------------
f <- c('1', '2', '3')
d <- lapply(f, read.table)
names(d) <- f # optionally some other names

MyFunc <- function(dat, nam) {
  plot(dat[1]~dat[2])
  title(main=nam)
  dat.new <- some.manipulations(dat)
  write.csv(dat.new, file=paste(nam, ".csv", sep=""))
}

lapply(names(d), function(n) MyFunc(d[[n]], n))
-------------------------------------------------------------------------------------------------------
atop expression m <-  ggplot(melt.d, aes(x=x, y=y)) + 
     geom_bar(fill="darkblue", stat = "identity") + 
     labs(x="Weather    stations", y="Accumulated Rainfall [mm]") + 
     ggtitle(expression(atop("Rainfall", atop(italic("Location"), "")))) +
     theme(axis.text.x = element_text(angle=-45, hjust=0, vjust=1), 
     #plot.margin = unit(c(1.5, 1, 1, 1), "cm"), 
     plot.title = element_text(size = 25, face = "bold", colour = "black", vjust = -1))
-------------------------------------------------------------------------------------------------------
barplot() ?barplot bar axis() axis() labels at at bar las = 2 cex.axis = 0.6 title() line mar line title() op <- par(mar= c(15,4,4,2) + 0.1)
bar <- barplot(58:1, xaxt="n", xlab="", ylab="Frequency", col=gray(5:0/5))
axis(1, labels = paste("Long Species Name", 1:58), at = bar,
     las = 2, cex.axis = 0.6)
title(xlab = "Species", line=11)
par(op)
-------------------------------------------------------------------------------------------------------
myfun mydialog <- function(){

       xvar <- tclVar("1")
       yvar <- tclVar("2")
       zvar <- tclVar("3")

       tt <- tktoplevel()
       tkwm.title(tt,"MYTEST")
       x.entry <- tkentry(tt, textvariable=xvar)
       y.entry <- tkentry(tt, textvariable=yvar)
       z.entry <- tkentry(tt, textvariable=zvar)

       reset <- function()
        {
         tclvalue(xvar)<-""
         tclvalue(yvar)<-""
         tclvalue(zvar)<-""
        }

       reset.but <- tkbutton(tt, text="Reset", command=reset)

       submit <- function() {
         x <- as.numeric(tclvalue(xvar))
         y <- as.numeric(tclvalue(yvar))
         z <- as.numeric(tclvalue(zvar))
         print(x+y+z)
         tkmessageBox(message="Done!")
         #tkdestroy(tt)
       }
       submit.but <- tkbutton(tt, text="submit", command=submit)

       tkgrid(tklabel(tt,text="MYTEST"),columnspan=2)
       tkgrid(tklabel(tt,text="x variable"), x.entry)
       tkgrid(tklabel(tt,text="y variable"), y.entry)
       tkgrid(tklabel(tt,text="z variable"), z.entry)
       tkgrid(submit.but, reset.but)

    }

mydialog()
-------------------------------------------------------------------------------------------------------
library(tcltk)  
library(tcltk2)

tkinput <- function(parent, title, label, okButLabel="Ok", posx=NULL, posy=NULL) {
  if(!require(tcltk2)) stop("This function requires the package tcltk2.")
  if(!require(tcltk)) stop("This function requires the package tcltk.")

  # param checks
  if(!is.character(title)) stop("invalid title argument - character required.")
  if(!is.character(label)) stop("invalid label argument - character required.")

  # toplevel
  tclServiceMode(FALSE) # don't display until complete
  win <- tktoplevel(parent)
  #win <- .Tk.subwin(parent)
  tkwm.title(win, title)
  tkwm.resizable(win, 0,0)
  #tkconfigure(win, width=width, height=height)

  # commands
  okCommand <- function() if(!tclvalue(bookmVar)=="") tkdestroy(win) else tkfocus(te)
  cancelCommand <- function () {
    tclvalue(bookmVar) <- ""
    tkdestroy(win)
  }
  tkwm.protocol(win, "WM_DELETE_WINDOW", cancelCommand)

  # pack 
  f <- tk2frame(win)
  w <- tk2label(f, text=label, justify="right")
  tkpack(w, side="left", padx=5)
  bookmVar <- tclVar("")
  te <- tk2entry(f, textvariable=bookmVar, width=40)
  tkpack(te, side="left", padx=5, fill="x", expand=1)
  tkpack(f, pady=5)
  f <- tk2frame(win)
  w <- tk2button(f, text=okButLabel, command=okCommand)
  tkpack(w, side="left", padx=5)
  w <- tk2button(f, text="Cancel", command=cancelCommand)
  tkpack(w, side="left", padx=5)
  tkpack(f, pady=5)

  # position
  if(is.null(posx)) posx <- as.integer((as.integer(tkwinfo("screenwidth", win)) - as.integer(tkwinfo("width", win))) / 2.)
  if(is.null(posy)) posy <- as.integer((as.integer(tkwinfo("screenheight", win)) - as.integer(tkwinfo("height", win))) / 2.)
  geom <- sprintf("+%d+%d", posx, posy)
  #print(geom)
  tkwm.geometry(win, geom)

  # run
  tclServiceMode(TRUE)
  ico <- tk2ico.load(file.path(R.home(), "bin", "R.exe"), res = "R")
  tk2ico.set(win, ico)
  tk2ico.destroy(ico)
  tkfocus(te)
  tkbind(win, "<Return>", okCommand)
  tkbind(win, "<Escape>", cancelCommand)
  tkwait.window(win)
  tkfocus(parent)
  return(tclvalue(bookmVar))
} tkrplot library(tkrplot)

heat_example <- function() {
    x  <- as.matrix(mtcars)
    rc <- rainbow(nrow(x), start=0, end=.3)
    cc <- rainbow(ncol(x), start=0, end=.3)
    hv <- heatmap(x, col = cm.colors(256), scale="column", 
        RowSideColors = rc, ColSideColors = cc, margins=c(5,10),
        xlab = "specification variables", ylab= "Car Models",
        main = "heatmap(<Mtcars data>, ..., scale = \"column\")")
}

launchDialog <- function() {  
    ReturnVal <- tkinput(parent=ttMain, title="First Gene", label="Enter A Gene Name")  
    if (ReturnVal == "") return()  

    hmwin <- tktoplevel(ttMain)
    img <- tkrplot(hmwin, heat_example)
    tkpack(img, hmwin)
}   

ttMain <- tktoplevel()  
tktitle(ttMain) <- "ttMain"  
launchDlg.button <- tkbutton(ttMain, text = "Launch Dialog", command = launchDialog)  
tkpack(launchDlg.button, ttMain)
-------------------------------------------------------------------------------------------------------
plot.default # need a helper function for this
 tweak <- function(x) c(range(x)[1], range(x)[2]+.00001)
 # Replace xy <- xy.coords(x, y, xlabel, ylabel, log)
 xy <- xy.coords(x[findInterval(x, tweak(xlim))==1], 
                 y[findInterval(x, tweak(xlim))==1], 
                 xlabel, ylabel, log) plotsub <- function(x,y = NULL, type = "p", xlim = NULL, ylim = NULL, 
    log = "", main = NULL, sub = NULL, xlab = NULL, ylab = NULL, 
    ann = par("ann"), axes = TRUE, frame.plot = axes, panel.first = NULL, 
    panel.last = NULL, asp = NA, ...) 
{   ylim=range(y);  tweak <- function(x) c(range(x)[1], range(x)[2]+.00001)
    localAxis <- function(..., col, bg, pch, cex, lty, lwd) Axis(...)
    localBox <- function(..., col, bg, pch, cex, lty, lwd) box(...)
    localWindow <- function(..., col, bg, pch, cex, lty, lwd) plot.window(...)
    localTitle <- function(..., col, bg, pch, cex, lty, lwd) title(...)
    xlabel <- if (!missing(x)) 
        deparse(substitute(x))
    ylabel <- if (!missing(y)) 
        deparse(substitute(y))
    xy <- xy.coords(x[findInterval(x, tweak(xlim))==1], y[findInterval(x,tweak(xlim))==1], xlabel, ylabel, log)
    xlab <- if (is.null(xlab)) 
        xy$xlab
    else xlab
    ylab <- if (is.null(ylab)) 
        xy$ylab
    else ylab
    xlim <- if (is.null(xlim)) 
        range(xy$x[is.finite(xy$x)])
    else xlim
    ylim <- if (is.null(ylim)) 
        range(xy$y[is.finite(xy$y)])
    else ylim
    dev.hold()
    on.exit(dev.flush())
    plot.new()
    localWindow(xlim, ylim, log, asp, ...)
    panel.first
    plot.xy(xy, type, ...)
    panel.last
    if (axes) {
        localAxis(if (is.null(y)) 
            xy$x
        else x, side = 1, ...)
        localAxis(if (is.null(y)) 
            x
        else y, side = 2, ...)
    }
    if (frame.plot) 
        localBox(...)
    if (ann) 
        localTitle(main = main, sub = sub, xlab = xlab, ylab = ylab, 
            ...)
    invisible()
} plotsub(1:10, 1:10, type = "l", xlim = c(1, 5), ylim=c(1,10) )
-------------------------------------------------------------------------------------------------------
dat <- data.frame(values = c(rnorm(100, mean = 1), rnorm(100, mean = 3),
                             rnorm(100, mean = 4, sd = 3)),
                  groups = factor(rep(c("aaa","bbb","ccc"), each = 100))) ?plotmath plotmath bold() boxplot(values ~ groups, data = dat,
        ylab = expression(bold(Value~axis)),
        xlab = expression(bold(Single~sample))) boxplot(values ~ groups, data = dat,
        ylab = expression(bold("Value axis")),
        xlab = expression(bold("Single sample"))) title() boxplot(values ~ groups, data = dat)
title(ylab = "Value axis", xlab = "Single sample", font.lab = 2) font.lab ?par
-------------------------------------------------------------------------------------------------------
qgraph library("qgraph")
data(big5)
data(big5groups)
qgraph(cor(big5),minimum=0.25,cut=0.4,vsize=2,groups=big5groups,legend=TRUE,borders=FALSE)
title("Big 5 correlations",line=-2,cex.main=2)
-------------------------------------------------------------------------------------------------------
i <- seq(1 : length(y))
m <- cumsum(y)/i

se_y <- sqrt((1/(i-1)*cumsum(y^2) - i/(i-1)*m^2))

error <- qnorm(0.975)*se_y/sqrt(i)
lower <- m - error
upper <- m + error

# equivalent (slightly slower) methods for getting the std. errors

# method2:
se_2 <- rep(NA, length(y))
for (n in 1:length(y))  {
  se_2[n] <- sd(y[1:n])
}
# method3:
se_3 <- sapply(1:length(y), FUN= function(x) sd(y[1:x])) # plotting means and ci's against sample size (= up to 10000)
plot(x=i, y=m, xlab="Number of iterations (sample size)", 
title("Convergence of the ENVP's mean"), 
ylab="E[y] estimates and 95% CI's (EUR millions)", cex=0.4, ylim=c(2620, 2665))
lines(lower, col="gold")
lines(upper, col="gold")
legend("bottomright", legend=c("envp's mean", "95% ci"),
cex=0.8, col=c("black", "gold"), lwd=2, lty=1, bty="n")

dev.copy(tiff, file="mc_envp.tiff", height=6, width=6, units="in", res=200)
dev.off(); dev.off()
windows.options(reset=TRUE)
-------------------------------------------------------------------------------------------------------
# I'm using the example data you gave.
# but you'd be reading in a csv file or something similar.

df <- read.table(textConnection("    xStart  xEnd    yStart  yEnd
a   100     200     70      90  
b   40      120     60      200"), header = T)

# add the row names as a column
df$cols <- rownames(df)

> df
  xStart xEnd yStart yEnd cols
a    100  200     70   90    a
b     40  120     60  200    b

library(plyr)
# instead of gnuplot (which I don't use), I'm using ggplot2
# see http://had.co.nz for more info about the package.
# below, the function ddply (in plyr) splits the data by cols (a or b)
# then plots those data and returns it to a list named plots.
# the length of plots will be equal to the number of unique groups in your data
library(ggplot2)
# change the plot type below to whatever you like.
plots <- dlply(df, .(cols), function(x){
    data <- data.frame(x1 = as.numeric(x[, 1:2]), y1 = as.numeric(x[, 3:4]))
    ggplot(data, aes(x1, y1)) + geom_point() + ggtitle(unique(x$cols))
    })

plots[1]
# to see the first plot
plots[2]
# to see the second one
length(plots) # to see how many plots were generated
-------------------------------------------------------------------------------------------------------
quantile() rug() set.seed(1)
X <- rnorm(200)
boxplot(X, yaxt = "n")

## compute the required quantiles
qntl <- quantile(X, probs = c(0.85, 0.90))

## add them as a rgu plot to the left hand side
rug(qntl, side = 2, col = "blue", lwd = 2)

## add the box and axes
axis(2)
box() str() set.seed(1) ## make reproducible
HWD <- data.frame(Hour = rep(0:23, 10),
                  Houston_Load = rnorm(24*10)) Hour Hour quantile() quants <- sapply(split(HWD$Houston_Load, list(HWD$Hour)),
                 quantile, probs = c(0.85, 0.9)) R> quants <- sapply(split(HWD$Houston_Load, list(HWD$Hour)),
+                  quantile, probs = c(0.85, 0.9))
R> quants
            0         1        2         3         4         5        6
85% 0.3576510 0.8633506 1.581443 0.2264709 0.4164411 0.2864026 1.053742
90% 0.6116363 0.9273008 2.109248 0.4218297 0.5554147 0.4474140 1.366114
            7         8        9       10        11        12       13       14
85% 0.5352211 0.5175485 1.790593 1.394988 0.7280584 0.8578999 1.437778 1.087101
90% 0.8625322 0.5969672 1.830352 1.519262 0.9399476 1.1401877 1.763725 1.102516
           15        16        17        18       19        20       21
85% 0.6855288 0.4874499 0.5493679 0.9754414 1.095362 0.7936225 1.824002
90% 0.8737872 0.6121487 0.6078405 1.0990935 1.233637 0.9431199 2.175961
          22        23
85% 1.058648 0.6950166
90% 1.145783 0.8436541 boxplot(Houston_Load ~ Hour, data = HWD, axes = FALSE)
xlocs <- 1:24 ## where to draw marks
tickl <- 0.15 ## length of marks used
for(i in seq_len(ncol(quants))) {
    segments(x0 = rep(xlocs[i] - 0.15, 2), y0 = quants[, i],
             x1 = rep(xlocs[i] + 0.15, 2), y1 = quants[, i],
             col = c("red", "blue"), lwd = 2)
}
title(xlab = "Hour", ylab = "Houston Load")
axis(1, at = xlocs, labels = xlocs - 1)
axis(2)
box()
legend("bottomleft", legend = paste(c("0.85", "0.90"), "quantile"),
       bty = "n", lty = "solid", lwd = 2, col = c("red", "blue"))
-------------------------------------------------------------------------------------------------------
cex 1 par(mfrow=c(3,2), mar=c(.5,4,4,0.5)+0.1, cex=1) oma par(mar=...) plot ann=FALSE las=1 par(mfrow=c(3,2), oma=c(4.5, 4, 4, 2.5), mar=rep(.1, 4), cex=1, las=1)
plot(x=rnorm(10), y=rnorm(10), ann=FALSE, xaxt="n")
plot(x=rnorm(10), y=rnorm(10), ann=FALSE, xaxt="n", yaxt="n")
plot(x=rnorm(10), y=rnorm(10), ann=FALSE, xaxt="n")
plot(x=rnorm(10), y=rnorm(10), ann=FALSE, xaxt="n", yaxt="n")
plot(x=rnorm(10), y=rnorm(10), ann=FALSE)
plot(x=rnorm(10), y=rnorm(10), ann=FALSE, yaxt="n")
title("My plot", outer=TRUE)
mtext("X-axis label", 1, 3, outer=TRUE)
mtext("Y-axis label", 2, 3, outer=TRUE, las=0)
-------------------------------------------------------------------------------------------------------
polygon y98 = aggregate(gcdata$Pause.s. ~ hours, data=gcdata, FUN=q98)
y02 = aggregate(gcdata$Pause.s. ~ hours, data=gcdata, FUN=q02)
ymax = aggregate(gcdata$Pause.s. ~ hours, data=gcdata, FUN=max)
ymin = aggregate(gcdata$Pause.s. ~ hours, data=gcdata, FUN=min)
ymean = aggregate(gcdata$Pause.s. ~ hours, data=gcdata, FUN=mean)

x = ymean[,1]
y1 = cbind(y02[,2], ymean[,2], y98[,2])
y2 = cbind(ymin[,2], ymean[,2], ymax[,2])

plotAreaCI(x,y2, ylim=c(0,2), xlab="time", ylab="variable")
plotAreaCI(x,y1, ylim=c(0,2), poly.col="blue", add=TRUE) plotAreaCI(x,y2, ylim=c(0,2), xlab="time", ylab="variable", nice.x = TRUE)
plotAreaCI(x,y1, ylim=c(0,2), mean.lwd=2, poly.col="blue", add=TRUE) plotAreaCI plotAreaCI = function(x, y, add=FALSE, nice.x = FALSE,
                          xlim=NULL, ylim=NULL,
                          mean.col="black", mean.lwd=1.5,
                          poly.col="gray", poly.lty=3,
                          xlab=NULL, ylab=NULL, main="",
                          ...) {
      isFactorX = isClass("factor", x)
      if(isFactorX) {
        x.label = x
        x = as.numeric(x)
      }
      if(is.null(xlim)) xlim=range(x, na.rm=TRUE)
      if(is.null(ylim)) ylim=range(y, na.rm=TRUE)
      x.pol = c(x, rev(x), x[1])
      y.pol = c(y[,1], rev(y[,3]), y[,1][3])
      if(!add) {
        plot.new()
        plot.window(xlim=xlim, ylim=ylim, ...)
        if(!nice.x & isFactorX) {
          axis(1, at=x, labels=x.label)
        } else {
          xticks = axTicks(1)
          if(isFactorX) {
            xticks = xticks[xticks>=1]
            axis(1, at=xticks, labels=x.label[xticks])
          } else {
            axis(1)
          }
        }
            axis(2, las=1)
        box()
        title(xlab=xlab, ylab=ylab, main=main)
      }
      polygon(x.pol, y.pol, col=poly.col, lty=poly.lty)
      lines(x, y[,2], col=mean.col, lwd=mean.lwd)
      return(invisible())
    }
-------------------------------------------------------------------------------------------------------
plotAreaCorridor = function(x, y, col.poly1="lightgray", col.poly2="gray",...) {
   x.pol = c(x, rev(x), x[1])
   y.pol = c(y[,1], rev(y[,5]),y[,1][1])
   plot(x, y[,6]+1, type="n", ...) # ugly since type="n" does not work for factor
   polygon(x.pol, y.pol, col=col.poly1, lty=0)

   x.pol = c(x, rev(x), x[1])
   y.pol = c(y[,2], rev(y[,4]), y[,1][1])
   polygon(x.pol, y.pol, col=col.poly2, lty=0)

   lines(x, y[,3], col="blue") # median
   lines(x, y[,6], col="red")  # max

   return(invisible())
}
pause = gcdata$Pause.s.
hours = droplevels(cut(gcdata$date, breaks="hours")) # can I have 2 hours?
agg = aggregate(pause ~ hours, FUN=quantile, probs=c(5,20,50,80,95,100)/100)
x = agg$hours
ys = agg$pause
q99 <- function(x, ...) {  x <- quantile(x,probs=c(0.99)) }  
v99 = q99(gcdata$Pause.s.)
vmed = median(gcdata$Pause.s.)
plotAreaCorridor(x, ys,ylim=c(0,v99*1.5))
abline(h=vmed, col="lightblue")
abline(h=v99, col="grey")
label=paste("99%=",round(v99,digits=3),"s n=", length(gcdata$date),sep="")
text(x=30, y=v99, label, col="grey", pos=3)
title("NewPar Collection Activity")
-------------------------------------------------------------------------------------------------------
extrafont xkcdFontURL <- "http://simonsoftware.se/other/xkcd.ttf"
   download.file(xkcdFontURL,dest="xkcd.ttf") library(extrafont) font_import(".")   ## because we downloaded to working directory
loadfonts() library(ggplot2)
p <- ggplot(mtcars, aes(x=wt, y=mpg)) + geom_point() +
  ggtitle("Fuel Efficiency of 32 Cars") +
  xlab("Weight (x1000 lb)") + ylab("Miles per Gallon") +
  theme(text=element_text(size=16, family="xkcd"))

ggsave("xkcd_ggplot.pdf", plot=p,  width=4, height=4)
## needed for Windows:
##   Sys.setenv(R_GSCMD = "C:/Program Files/gs/gs9.05/bin/gswin32c.exe")
embed_fonts("xkcd_ggplot.pdf")
-------------------------------------------------------------------------------------------------------
graphics # Faking the data, since you didn't provide any
Gene <- data.frame(matrix(rweibull(100*4, 1), 100))
names(Gene) <- paste0("Ind", 1:4)
Gene <- rep(list(Gene), 4)

# Setup the panels
layout(t(1:4))
par(oma=c(2, 4, 4, 0), mar=rep(1, 4), cex=1)
# `mar` controls the space around each boxplot group

# Calculating the range so that the panels are comparable
my.ylim <- c(min(sapply(Gene, min)), max(sapply(Gene, max)))

# Plot all the boxes
for(i in 1:length(Gene)){
    boxplot(Gene[[i]], ylim=my.ylim, axes=FALSE)
    mtext(paste("Gene", i), 1, 0)
    if(i == 1){
        axis(2, las=1)
        mtext("Expression or what you have", 2, 3)
    }
}
title("Look at all my genes!", outer=TRUE) Gene[[i]] get(paste0("Gene", i)) my.ylim <- ... min(c(min(Gene1), min(Gene2) ...
-------------------------------------------------------------------------------------------------------
0.5*pi 1.5*pi geom_polygon geom_path circleFun <- function(center=c(0,0), diameter=1, npoints=100, start=0, end=2){
  tt <- seq(start*pi, end*pi, length.out=npoints)
  data.frame(
    x = center[1] + diameter / 2 * cos(tt),
    y = center[2] + diameter / 2 * sin(tt)
  )
}

dat <- circleFun(c(1,-1), 2.3, start=0.5, end=1.5)
ggplot(dat,aes(x,y)) + 
  geom_polygon(color="black") + 
  ggtitle("half circle") +
  coord_equal()
-------------------------------------------------------------------------------------------------------
library(ggplot2);library(grid)

counts  <- c(80, 27, 66, 94, 33)
defects <- c("price code", "schedule date", "supplier code", "contact num.", "part num.")
dat <- data.frame(count = counts, defect = defects, stringsAsFactors=FALSE )
dat <- dat[order(dat$count, decreasing=TRUE),]
dat$defect <- factor(dat$defect, levels=dat$defect)
dat$cum <- cumsum(dat$count)
count.sum<-sum(dat$count)
dat$cum_perc<-100*dat$cum/count.sum

p1<-ggplot(dat, aes(x=defect, y=cum_perc, group=1))
p1<-p1 + geom_point(aes(colour=defect), size=4) + geom_path()

p1<-p1+ ggtitle('Pareto Chart')+ theme(axis.ticks.x = element_blank(), axis.title.x = element_blank(),axis.text.x = element_blank())
p1<-p1+theme(legend.position="none")

p2<-ggplot(dat, aes(x=defect, y=count,colour=defect, fill=defect))
p2<- p2 + geom_bar()

p2<-p2+theme(legend.position="none")

plot.new()
grid.newpage()
pushViewport(viewport(layout = grid.layout(2, 1)))
print(p1, vp = viewport(layout.pos.row = 1,layout.pos.col = 1))
print(p2, vp = viewport(layout.pos.row = 2,layout.pos.col = 1))
-------------------------------------------------------------------------------------------------------
theme(panel.border = element_blank(), axis.line = element_line()) dat <- structure(list(x = c(0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1, 1.05, 
    1.1, 1.15, 1.2, 1.25, 1.3), y1 = c(34, 30, 26, 23, 21, 19, 17, 
    16, 15, 13, 12, 12, 11), y2 = c(45, 39, 34, 31, 28, 25, 23, 21, 
    19, 17, 16, 15, 14)), .Names = c("x", "y1", "y2"), row.names = c(NA, 
    -13L), class = "data.frame")


library(reshape2); library(ggplot2)
dat2 <- melt(dat, id='x')

ggplot(data=dat2, aes(x=x, y=value, color=variable)) + 
    geom_point(size=3) + geom_line(size=.5) +
    theme(panel.border = element_blank(), axis.line = element_line())

# or using the template you used from talkstats...
ggplot(data=dat2, aes(x=x, y=value, color=variable)) + 
    geom_point(size=3) + geom_line(size=1.5) +
    scale_y_continuous(breaks=seq(0, 45, by=5)) +
    scale_x_continuous(breaks=seq(.7, 1.3, by=.05)) +
    theme_bw() + ylab("Sample Size") + xlab("Mean Difference") +
    theme(legend.position="bottom", legend.title=element_blank(),
        legend.key = element_rect(colour = 'white'), 
        legend.background = element_rect(colour = "black")) +
    ggtitle("Sample Size vs. Mean Difference by Power") +
    theme(panel.border = element_blank(), axis.line = element_line())
-------------------------------------------------------------------------------------------------------
plot(1:length(sample.list),ylim=c(0,max(unlist(sample.list))),xaxt="n",ann=FALSE)
axis(1,at=1:length(sample.list),labels=1:length(sample.list))

invisible(
  sapply(
      1:length(sample.list),
      function(x) {
        tmp2plot <- sample.list[[x]]
        points(rep(x,length(tmp2plot)),unlist(tmp2plot),col=1:length(tmp2plot),pch=19)
      }
  )
)

title(xlab="Index",ylab="Value")
-------------------------------------------------------------------------------------------------------
ggplot2 require(ggplot2)
df <- data.frame(x=x, y=y, z=z) #ggplot2 only likes to deal with data frames
ggplot2(df, aes(x=x, y=y, colour=z) + #create the 'base layer' of the plot
  geom_point() + #represent the data with points
  scale_colour_gradient(low="black", high="green") + #you have lots of options for color mapping
  scale_x_continuous("column x") + #you can use scale_... to modify the scale in lots of other ways
  scale_y_continuous("column y") +
  ggtitle("Title")
-------------------------------------------------------------------------------------------------------
title( main = "New Orleans area: \n residents 65 and over by ZIP")
-------------------------------------------------------------------------------------------------------
d1 d28 # Get the submatrices
I <- unlist(lapply(0:6, function(a) a:6))
J <- rep(0:6, 7:1)
d2 <- mapply(function(i,j) d[1:6+6*i, 1:6+6*j], I, J, SIMPLIFY=FALSE)

# Setup the layout and add an outer margin for the title and axis labels
layout(matrix(c(1:28, 0, 0), 5, 6))
par(oma=c(3,3,3,1), mar=c(2,2,1,1))

# Plot all the matrices oriented the same way they appear in text
# i.e. the first (vertical) dimension is plotted along the Y-axis
for(k in 1:length(d2)){
    x <- 1:6+6*J[k]
    y <- 1:6+6*I[k]

    # Heatmap & grid
    image(x, y, t(d2[[k]][nrow(d2[[k]]):1,]), las=1, axes=FALSE,
          breaks=c(-1e10, -5.45, -4.65, 4.65, 5.45, 1e10),
          col=c("red","orange","white","orange","red"))
    xg <- apply(!is.na(d2[[k]]), 2, sum)
    yg <- rev(apply(!is.na(d2[[k]]), 1, sum))
    segments(c(x[1]-1, x)+.5, min(y)-.5,
             c(x[1]-1, x)+.5, min(y)+c(6, yg)-.5, xpd=TRUE)
    segments(min(x)-.5,         c(y[1]-1, y)+.5,
             min(x)+c(6,xg)-.5, c(y[1]-1, y)+.5, xpd=TRUE)

    # X & Y-axis values
    mtext(x, 1, .1, at=x, cex=.5)
    mtext(rev(y), 2, .2, at=y, las=1, cex=.5)

    # Values of each cell
    text(rep(x, each=6), rep(rev(y), 6),
     sub("NA", "", sprintf("%.2f", d2[[k]])), cex=.3)
}

# Add title and axis labels
title("All 28 submatrices", outer=TRUE)
mtext("Columns", outer=TRUE, 1, 1)
mtext("Rows", outer=TRUE, 2, 1) xpd segments
-------------------------------------------------------------------------------------------------------
require(tikzDevice)

tikz('normal.tex', standAlone = TRUE, width=5, height=5)

# Normal distribution curve
x <- seq(-4.5,4.5,length.out=100)
y <- dnorm(x)

# Integration points
xi <- seq(-2,2,length.out=30)
yi <- dnorm(xi)

# plot the curve
plot(x,y,type='l',col='blue',ylab='$p(x)$',xlab='$x$')
# plot the panels
lines(xi,yi,type='s')
lines(range(xi),c(0,0))
lines(xi,yi,type='h')

#Add some equations as labels
title(main="$p(x)=\\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{x^2}{2}}$")
int <- integrate(dnorm,min(xi),max(xi),subdivisions=length(xi))
text(2.8, 0.3, paste("\\small$\\displaystyle\\int_{", min(xi),
    "}^{", max(xi), "}p(x)dx\\approx", round(int[['value']],3),
    '$', sep=''))

#Close the device
dev.off()

# Compile the tex file
tools::texi2dvi('normal.tex',pdf=T)
-------------------------------------------------------------------------------------------------------
# note that .formula is either an expression or a character
# string that would define a valid expression
maketitle <- function(.formula, .other){
  .expression <- sprintf('%s ~ "%s"',as.character(.formula), .other)
  evalq(parse(text = .expression))
}


f <- expression(H[2]*O)
o <- 'blah blah'

plot(1:10, main = maketitle(f, o)) eval(parse(text = ...))
-------------------------------------------------------------------------------------------------------
cex.main par(cex.main = 6)
charts.PerformanceSummary(xts(v,Sys.Date()-(100:1)),main="random title") title() # Set `main` to `""`
charts.PerformanceSummary(xts(v,Sys.Date()-(100:1)), main = "")
# You'll have to experiment with the best combination of `line` and `cex.main`
title(main="random title", line = -2, outer = TRUE, cex.main=3)
-------------------------------------------------------------------------------------------------------
 outer = TRUE op <- par(mfrow = c(2,2),oma = c(5,4,0,0) + 0.1,mar = c(0,0,1,1) + 0.1) op 5 4 mar mar for() 
title(xlab = "Some Categories",ylab = "Some Values",outer = TRUE, line = 3) 
catA <- factor(c("m100", "m500", "m1000", "m2000", "m3000", "m5000"))
catB <- factor(20:28)
samples <- 100
rsample <- function(v) v[ceiling(runif(samples, max=length(v)))]
Tab <- data.frame(catA = rsample(catA),
                  catB = rsample(catB),
                  valA = rnorm(samples, 150, 8),
                  valB = pmin(1,pmax(0,rnorm(samples, 0.5, 0.3))))
op <- par(mfrow = c(2,2),
          oma = c(5,4,0,0) + 0.1,
          mar = c(0,0,1,1) + 0.1)
for (i in 0:3) {
  x <- Tab[[1 + i %% 2]]
  plot(x, Tab[[3 + i %/% 2]], axes = FALSE)
  axis(side = 1,
       at=1:nlevels(x),
       labels = if (i %/% 2 == 1) levels(x) else FALSE)
  axis(side = 2, labels = (i %% 2 == 0))
  box(which = "plot", bty = "l")
}
title(xlab = "Some Categories",ylab = "Some Values",outer = TRUE, line = 3)
par(op)
-------------------------------------------------------------------------------------------------------
output$plot_Total <- reactivePlot(function() { 
  plot.new()
   plot.window(xlim=c(1850,2020), ylim = c(0,5000000))
   axis(1)
   axis(2)
   title(main="Numbers over the years")
   title(xlab="Year")
   title(ylab="Number of people")
   box()
   points(dat$Year, dat$Total, col="red")
   lines(dat$Year, dat$Total, col="red")
  if (input$RC) {   lines(dat$Year, dat$dat)}
  })
-------------------------------------------------------------------------------------------------------
p <- qplot(mpg, wt, data = mtcars)
  p <- p + ggtitle("whatever \n comes after this") + 
  theme(plot.title = element_text(lineheight=.1))
  p
-------------------------------------------------------------------------------------------------------
plottitle .... opts( title=plottile, size=10) Warning messages:
1: 'opts' is deprecated.
Use 'theme' instead.
See help("Deprecated") 
2: 'theme_text' is deprecated.
Use 'element_text' instead.
See help("Deprecated") 
3: 'theme_text' is deprecated.
Use 'element_text' instead.
See help("Deprecated") 
4: In opts(title = plottitle, axis.title.x = theme_text(size = 8, colour = "black"),  :
  Setting the plot title with opts(title="...") is deprecated. Use labs(title="...") or ggtitle("...") instead.
-------------------------------------------------------------------------------------------------------
x4.can.t.m x4.can.t.m$YearQuarter <- format(as.Date(x4.can.t.m$YearQuarter),"%b-%y")

library("scales")
ggplot(data=x4.can.t.m, aes(x=YearQuarter, y=value, fill=NR_CAT)) + 
  geom_bar(stat="identity", position = "dodge") +
  geom_text(aes(label = paste(round(value*100,0),"%",sep=""), group=NR_CAT), 
            position=position_dodge(width=0.9), 
            vjust=-0.25, size=3)  +
  scale_y_continuous("Percentage", labels=percent, limits=c(0,1)) +
  labs(x="Year Quarter") +
  scale_fill_discrete("Canopy Indicators") + 
  facet_wrap(~TYPE,ncol=1) +
  ggtitle("Canopy Indicator: All Customers portout for Network Issues") +
  theme(plot.title = element_text(size=rel(1.2))) YearQuarter scale_y_continuous labels library("scales")
-------------------------------------------------------------------------------------------------------
require(reshape2)

meltpath <- function(x){
  require(data.table)
  x <- melt(data = x, id.vars = 'id', measure.vars = names(x)[-1])
  names(x) <- c('id','year','category')
  x$year <- factor(x$year)
  id <- unique(x$id)
  idtable <- data.table(id = id, count = 1:length(id))
  x <- x[order(x$id), ]
  x <- merge(x, idtable, by='id')
  return(x)
}

carpath <- function(datatable, max_x = max(datatable$count)){
  require(ggplot2)
  p = ggplot(datatable, aes(x = count, y = year, fill = category)) + 
    geom_tile() +
    scale_y_discrete(name = "year\n", 
                     breaks = rev(levels(datatable$year))) + 
    scale_x_continuous(name = "cumulative count", 
                      limits = c(0,max_x)) +
    guides(fill = guide_legend(title="Career stage\n",
                               reverse=TRUE)) +
    theme(panel.grid.major = element_blank(), 
         panel.background = element_blank(), 
         axis.ticks = element_blank(),
         plot.title = element_text(vjust = 1.2, face="bold", size=20),
         axis.title.y = element_text(size=15, face="bold"),
         axis.text.y = element_text(size=15, colour="black"),
         legend.title = element_text(size = 15),
         legend.text = element_text(size = 15)) +
         scale_fill_brewer(palette = "Dark2") +
    ggtitle("Career path of individual Students by year")
  p
}

test <- structure(list(
  id = 1:6,
  y2002 = c("freshman","freshman","freshman","sophomore","sophomore","senior"),
  y2003 = c("freshman","junior","sophomore","sophomore","sophomore","senior"),
  y2004 = c("junior","sophomore","sophomore","senior","senior",NA),
  y2005 = c("senior","senior","senior",NA, NA, NA)), 
                  .Names = c("id","2002","2003","2004","2005"),
                  row.names = c(c(1:6)),
                  class = "data.frame")
# Grow dataset
testg = data.frame()
for (i in rownames(test)) {
  test0 <- test[rep(i, each=abs(floor(rnorm(1)*100))),]
  testg <- rbind(testg, test0)
}
testg$id <- 1:nrow(testg)
# Munge
test0 <- testg
test1 <- melt(data = test0, id.vars = 'id', measure.vars = names(test0)[-1])
names(test1) <- c('id','year','category')
test1$category[test1$category == 'freshman'] <- 1
test1$category[test1$category == 'junior'] <- 2
test1$category[test1$category == 'sophomore'] <- 3
test1$category[test1$category == 'senior'] <- 4
test1$category <- factor(test1$category, levels=1:4, labels = c('1. freshman','2. junior','3. sophomore','4. senior'))
test1 <- test1[order(test1$category), ]
test1 <- dcast(test1, id ~ year)
test1 <- test1[order(test1$'2005',test1$'2004',test1$'2003',test1$'2002'), ]
test2 <- meltpath(test1)
carpath(test2)
-------------------------------------------------------------------------------------------------------
#Sample data in a dataframe since that works best with ggplot
set.seed(13013)
testdf <- data.frame(x <- rnorm(100, 1),y <- 1:100) ggplot(testdf , aes(x = x, y = y)) + geom_point()+
   stat_smooth(method="loess")+
   xlab("buckshot hole distance(from sign edge)")+
   ylab("speed of car (mph)")+
   ggtitle("Individual Points fit with LOESS (± 1 SD)") size=3 ggplot(testdf , aes(x = x, y = y)) + geom_point()+
   stat_smooth(method="loess")+
   xlab("buckshot hole distance (from sign edge)")+
   ylab("speed of car (mph)")+
   annotate("text", x = max(testdf$x)-1, y = mean(testdf$y), 
   label = "LOESS fit with 68% CI region", colour="blue")
-------------------------------------------------------------------------------------------------------
library(scales)
library(ggplot2)
###data 
x4.1.m$YearQuarter <- as.Date(x4.1.m$YearQuarter)
x4.1.m$label       <- paste(round(x4.1.m$value*100,0), "%", sep="")

### plot
x4.line <- ggplot(data=x4.1.m, aes(x=YearQuarter, y=value,colour=Var.1,group = Var.1))
x4.line <- x4.line + geom_smooth(se=F, size=1.5)
x4.line <- x4.line + geom_text(aes(label = label),size = 3, hjust = 0.5, vjust =1.5) 

### theme  
x4.line <- x4.line +  theme(axis.line = element_line(colour = "black"),
       panel.grid.major = element_blank(),
       panel.background=element_blank(),
       panel.grid.minor = element_blank(),
       panel.border = element_blank()) 

x4.line <- x4.line +  ggtitle("Percentages:Main Reasons for Leaving 2degrees by Quarter") +
  theme(plot.title = element_text(size=rel(1.2)))+ 
scale_y_continuous(labels=percent, limits=c(0,0.5)) +
  scale_x_date(labels = date_format("%b-%y"))+
  labs(y="Percentage",x="Year Quarter")

x4.line
-------------------------------------------------------------------------------------------------------
breaks scale_x_date # your breaks 
d <- unique(x4.1.m[['YearQuarter']])
themestuff <-  theme(axis.line = element_line(colour = "black"),
                        panel.grid.major = element_blank(),
                        panel.background=element_blank(),
                        panel.grid.minor = element_blank(),
                        panel.border = element_blank())  

x4.line <- ggplot(data=x4.1.m, aes(x=YearQuarter, y=value,colour=Var.1)) +
 geom_smooth(se=F, size=1.5) + 
 geom_text(aes(label = label),size = 3, hjust = 0.5, vjust =1.5) +
 themestuff +  ggtitle("Percentages:Main Reasons for Leaving Vodafone by Quarter") +
 theme(plot.title = element_text(size=rel(1.2))) +
 scale_y_continuous(labels=percent, limits=c(0,0.5)) +
 scale_x_date(labels = date_format("%b-%y"), breaks = d)+
 labs(y="Percentage",x="Year Quarter")
x4.line
-------------------------------------------------------------------------------------------------------
mtext() image.plot() title() image.plot(x,y,z) title("") mtext("Title",side=3)
-------------------------------------------------------------------------------------------------------
rollmean() zoo p29$dt=strptime(p29$dt, "%Y-%m-%d %H:%M:%S")

library(zoo)
#Make zoo object of data
temp.zoo<-zoo(p29$ambtemp,p29$dt)

#Calculate moving average with window 3 and make first and last value as NA (to ensure identical length of vectors)
m.av<-rollmean(temp.zoo, 3,fill = list(NA, NULL, NA))

#Add calculated moving averages to existing data frame
p29$amb.av=coredata(m.av)

#Add additional line for moving average in red
ggplot(p29, aes(dt, ambtemp)) + geom_line() + 
  geom_line(aes(dt,amb.av),color="red") + 
  scale_x_datetime(breaks = date_breaks("5 min"),labels=date_format("%H:%M")) +
  xlab("Time 00.00 ~ 24:00 (2007-09-29)") + ylab("Tempreture")+
  ggtitle("Node 29") aes() ggplot() geom_line() scale_colour_manual() ggplot(p29, aes(dt)) + geom_line(aes(y=ambtemp,colour="real")) +
   geom_line(aes(y=amb.av,colour="moving"))+
   scale_x_datetime(breaks = date_breaks("5 min"),labels=date_format("%H:%M")) + 
   xlab("Time 00.00 ~ 24:00 (2007-09-29)") + ylab("Tempreture")+
   scale_colour_manual("Lines", values=c("real"="black", "moving"="red")) +    
   ggtitle("Node 29")
-------------------------------------------------------------------------------------------------------
ggplot library(ggplot2)
library(reshape)

set.seed(123)
foo <- list(x = 1:100, y = cumsum(rnorm(100)))

foo <- as.data.frame(foo)
foo$z <- foo$y^2
mymelt <- melt(foo, id.var = 'x')
mymelt$label <- ifelse(mymelt$variable == 'y', "Produktion", "Summa.skulder")
mymelt$line.colour <- ifelse(mymelt$variable == 'y', "red", "blue") # specify colours here

ggplot(data = mymelt, aes(x = x, y = value)) +
    geom_line(aes(colour = mymelt$line.colour)) +
    facet_wrap(~ label, ncol = 1, scales = "free_y") +
    scale_colour_manual(values = unique(mymelt$line.colour)) +
    ggtitle("TOtalProduktion VS SummaSkulder/TotaltKapital i procent") +
    theme(strip.text.x = element_text(size = 12)) +
    theme(axis.text.x = element_text(size = 9)) +
    theme(axis.text.y = element_text(size = 9)) +
    theme(axis.title.x = element_text(size = 15)) +
    theme(axis.title.y = element_text(size = 15)) +
    theme(axis.title.x = element_blank()) + # comment out this line if you want an x axis title
    theme(axis.title.y = element_blank()) + # comment out this line if you want a y axis title
    theme(legend.position = "none")
-------------------------------------------------------------------------------------------------------
for ( i in 1:length(h)) {
  name <- unlist(h[[i]][1])  
  dftemp <- as.data.frame(do.call(rbind,h[[i]][2]))
  names(dftemp) <-  c("time", "cache")
  plot(dftemp$time,dftemp$cache, type="o")
  title(main=name)
}
-------------------------------------------------------------------------------------------------------
data.m <- melt(data, id.vars = 1) data.m <- melt(data, id.vars = "N") ggplot(data.m, aes(data, value, colour=variable)) +
    geom_point(alpha=.3) +
    geom_smooth(alpha=.2, size=1) +
    ggtitle("Random array with ~25% duplicate values") ggplot(data.m, aes(N, value, colour=variable)) +
    geom_point(alpha=.3) +
    geom_smooth(alpha=.2, size=1) +
    ggtitle("Random array with ~25% duplicate values") aes data
-------------------------------------------------------------------------------------------------------
my1 <- data.frame (company = rep(c("A", "B", "C"), each = 7), skillsDg = rep(c("Basic", "HighSc", "Undgd", "MAST", "PHD", "EXPD", "EXECT"), 3), number = c(200, 100, 40, 30, 10, 0, 0, 220, 110, 35, 10, 0, 4, 1, 140, 80, 120, 50, 52, 52, 3) )

my2 <- split(my1,my1$company) #split your dataframe into a list where each element is a company
# The next line create the layout
layout(matrix(1:(length(my2)+1), nrow=1), width=c(1,rep(4,length(my2))))
# Then we draw the x-axis:
par(mar=c(3,0,3,0))
plot(NA,axes=F, xlim=c(0,1),ylim=c(1,nlevels(my1$skillsDg)))
axis(side=4,tick=F,labels=unique(my1$skillsDg),
     at=seq_along(unique(my1$skillsDg)), las=2, line=-4)
# Then we apply a graphing function to each company:
lapply(my2,function(x){
    par(mar=c(3,0,3,0))
    plot(NA, xlim=c(-max(my1$number),max(my1$number)), 
             ylim=c(1,nlevels(my1$skillsDg)),axes=F)
    title(sub=x$company[1],line=1)
    abline(h=seq_along(x$skillsDg), col="grey80")
    polygon(x=c(x$number,rev(-1*x$number)), 
            y=c(seq_along(x$skillsDg),rev(seq_along(x$skillsDg))), 
            col=as.numeric(x$company))
    }) lapply layout(matrix(1:(length(my2)+1), nrow=1), width=c(1,rep(4,length(my2))))
par(mar=c(3,0,3,0))
plot(NA,axes=F, xlim=c(0,1),ylim=c(1,nlevels(my1$skillsDg)))
axis(side=4,tick=F,labels=unique(my1$skillsDg),
    at=seq_along(unique(my1$skillsDg)), las=2, line=-4)
lapply(my2,function(x){
    par(mar=c(3,0,3,0))
    plot(NA, xlim=c(-max(my1$number)-50,max(my1$number)+50), 
        ylim=c(1,nlevels(my1$skillsDg)),axes=F)
    title(sub=x$company[1],line=1)
    abline(h=seq_along(x$skillsDg), col="grey80")
    text(x=x$number+5, y=seq_along(x$skillsDg)+.1, label=x$number, pos=4)
    polygon(x=c(x$number,rev(-1*x$number)), 
        y=c(seq_along(x$skillsDg),rev(seq_along(x$skillsDg))), 
        col=as.numeric(x$company))
    })
-------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------
main="..." plot() plot(...) title() cex.main= cex.col= plot(g, layout =  layout.kamada.kawai,  vertex.label = V(g)$name,  vertex.label.color= "white",edge.arrow.size=0.5,  edge.curved=T, edge.label=E(g)$Freq, edge.label.color="pink", edge.label.font=5,vertex.shape="circle",edge.color="white", vertex.color="red", asp=0)
title("This is my first igraph",cex.main=3,col.main="green")
-------------------------------------------------------------------------------------------------------
# Compare MPG distributions for cars with 
# 4,6, or 8 cylinders
library(sm)
attach(mtcars)

# create value labels 
cyl.f <- factor(cyl, levels= c(4,6,8),
  labels = c("4 cylinder", "6 cylinder", "8 cylinder")) 

# plot densities 
sm.density.compare(mpg, cyl, xlab="Miles Per Gallon")
title(main="MPG Distribution by Car Cylinders")

# add legend via mouse click
colfill<-c(2:(2+length(levels(cyl.f)))) 
legend(locator(1), levels(cyl.f), fill=colfill)
-------------------------------------------------------------------------------------------------------
library(sp)
library(rgeos)
library(rgdal)

###
# Read in Area Unit (AU) boundaries
au <- readOGR("C:/Users/Peter Ellis/Documents/NZ", layer="AU12")

# Read in Territorial Authority (TA) boundaries
ta <- readOGR("C:/Users/Peter Ellis/Documents/NZ", layer="TA12")

###
# First cut - works ok when only one TA per area unit
x1 <- over(au, ta)
au_to_ta <- data.frame(au@data, TAid = x1)

###
# Second cut - find those with multiple intersections
# and replace TAid with that with the greatest area.

x2 <- over(au, ta, returnList=TRUE)

# This next loop takes around 10 minutes to run:
for (i in 1:nrow(au_to_ta)){
    tmp <- length(x2[[i]])
    if (tmp>1){
        areas <- numeric(tmp)
        for (j in 1:tmp){
            areas[j] <- gArea(gIntersection(au[i,], ta[x2[[i]][j],]))
            }
#       Next line adds some tiny random jittering because
#       there is a case (Kawerau) which is an exact tie
#       in intersection area with two TAs - Rotorua and Whakatane

        areas <- areas * rnorm(tmp,1,0.0001)

        au_to_ta[i, "TAid"] <- x2[[i]][which(areas==max(areas))]
    }

}


# Add names of TAs
au_to_ta$TA <- ta@data[au_to_ta$TAid, "NAME"]

####
# Draw map to check came out ok
png("check NZ maps for TAs.png", 900, 600, res=80)
par(mfrow=c(1,2), fg="grey")
plot(ta, col=ta@data$NAME)

title(main="Original TA boundaries")
par(fg=NA)
plot(au, col=au_to_ta$TAid)
title(main="TA boundaries from aggregated\nArea Unit boundaries")
dev.off()
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(quantmod)
getSymbols("^GSPC", from ="2000-01-01")

oldata <-GSPC[,6]
oldata <-na.omit(oldata)

lastprice <-tail(olddata,1)
oldsteps <- tail(diff(log(oldata)),-1)
head(oldsteps)
n_days =100
percent <- exp(cumsum(rnorm(n_days,mean(oldsteps), apply(oldsteps, 2, sd))))
path2 <- exp(cumsum(rnorm(n_days,mean(oldsteps), apply(oldsteps, 2, sd))))
path3 <- exp(cumsum(rnorm(n_days,mean(oldsteps), apply(oldsteps, 2, sd))))

paths <- data.frame(T=c(1:100),path1,path2,path3 )

plot1 <- ggplot(data=paths, aes(x=T,y=percent )) + geom_line()
plot1 <- plot1+ geom_line(aes(x=T,y=path2))+  geom_line(aes(x=T,y=path3))
plot1 <- plot1+ ggtitle("pathways")
plot1
-------------------------------------------------------------------------------------------------------
n n.restarts n n.restarts ... func2 <- function (lb, ub, ..., n.restarts = 5, n.sim = 10){
  writeLines(paste("Value of `n.restarts` is", n.restarts))
  arg.curve.user <- as.list(substitute(list(...)))
  output <- gosolnp(fun = func1, LB = lb, UB = ub,  n.restarts =  n.restarts, 
                    n.sim =  n.sim)$par
  func3(fun = func1, arg.curve.user = arg.curve.user)
  output
} > func2 (lb = 0, ub = 8, n.restarts = 2, n.sim = 10, n = 200,
+        from = 0, to = 8)
Value of `n.restarts` is 2          <---- Here!

Iter: 1 fn: 6.926e-15    Pars:  2.00000
Iter: 2 fn: 2.501e-15    Pars:  2.00000
solnp--> Completed in 2 iterations

Iter: 1 fn: 8.336e-16    Pars:  2.00000
Iter: 2 fn: 8.336e-16    Pars:  2.00000
solnp--> Completed in 2 iterations
[1] 2
> func2 (lb = 0, ub = 8, nrestarts = 2, n.sim = 10, n = 200,
+        from = 0, to = 8)
Value of `n.restarts` is 5          <---- Here! Default

Iter: 1 fn: 2.83e-15     Pars:  2.00000
Iter: 2 fn: 2.5e-15  Pars:  2.00000
solnp--> Completed in 2 iterations

Iter: 1 fn: 2.037e-15    Pars:  2.00000
Iter: 2 fn: 2.037e-15    Pars:  2.00000
solnp--> Completed in 2 iterations

Iter: 1 fn: 1.087e-15    Pars:  2.00000
Iter: 2 fn: 1.087e-15    Pars:  2.00000
solnp--> Completed in 2 iterations

Iter: 1 fn: 8.558e-16    Pars:  2.00000
Iter: 2 fn: 8.558e-16    Pars:  2.00000
solnp--> Completed in 2 iterations

Iter: 1 fn: 7.147e-16    Pars:  2.00000
Iter: 2 fn: 7.147e-16    Pars:  2.00000
solnp--> Completed in 2 iterations
[1] 2
Warning messages:
1: In plot.window(...) : "nrestarts" is not a graphical parameter
2: In plot.xy(xy, type, ...) : "nrestarts" is not a graphical parameter
3: In axis(side = side, at = at, labels = labels, ...) :
  "nrestarts" is not a graphical parameter
4: In axis(side = side, at = at, labels = labels, ...) :
  "nrestarts" is not a graphical parameter
5: In box(...) : "nrestarts" is not a graphical parameter
6: In title(...) : "nrestarts" is not a graphical parameter
-------------------------------------------------------------------------------------------------------
library(Rsolnp)

func1 <- function (x) (x-2)^2

func3 <- function (fun, col = "blue", n = 1000, main = "This is a test", ...){
  curve(func1, ..., n = n, col = col, main = main)
}

# optimizes func1 and call func2 to plot func1
func2 <- function (lb, ub, n.restarts = 5, n.sim = 10, ...){
  output <- gosolnp(fun = func1, LB = lb, UB = ub, n.restarts = n.restarts, 
  n.sim =  n.sim)$par
  func3(fun = func1, ...)
  return(output)
} func2 ( lb = 0, ub = 8, nrestarts = 5, n.sim = 10, n = 200, from = 0, to = 8) Warning messages:
1: In plot.window(...) : "nrestarts" is not a graphical parameter
2: In plot.xy(xy, type, ...) : "nrestarts" is not a graphical parameter
3: In axis(side = side, at = at, labels = labels, ...) :
  "nrestarts" is not a graphical parameter
4: In axis(side = side, at = at, labels = labels, ...) :
  "nrestarts" is not a graphical parameter
5: In box(...) : "nrestarts" is not a graphical parameter
6: In title(...) : "nrestarts" is not a graphical parameter
-------------------------------------------------------------------------------------------------------
znode25 = data.frame(second_data_results_node25[2:24,])

df <- data.frame(z25$avg,z28$avg,z29$avg,z31$avg,z32$avg,sdtt$dt,znode25$outside)
names(df) <-  c("Node 25","Node 28","Node 29","Node 31","Node 32","Time_Date", "Results")
df.m <- melt(df, names(df)[6:7], names(df)[1:5])
df.m$Results <- factor(df.m$Results)
df.m$Time_Date <- strptime(as.character(df.m$Time_Date), format = "%Y-%m-%d %H:%M:%S")
p <- ggplot(df.m, aes(x = Time_Date, y = value, group = variable, color = variable, linetype=variable))
p <- p + geom_point(aes(shape = Results), cex=4)
p <- p + scale_shape_manual(values=c(22,20))
p <- p + geom_line()
p <- p + theme(axis.text.x = element_text(angle = 90, hjust = 1))
p <- p + scale_color_manual(values=c("#000099","red","darkgray",'blue',"darkred"))
p <- p + ylim(-1,8)
p <- p + xlab('Date and Time') 
p <- p + ylab('Temprature') 
p <- p + ggtitle("Spatial Outliers of Node 25 ") + theme(plot.title = element_text(lineheight=3, face="bold", color="black"))
p
-------------------------------------------------------------------------------------------------------
theme p <- ggplot(df.m, aes(x = HMn25_30.h, y = value, group = variable, color = variable))
    p <- p + scale_shape_manual(values=c(20,22))
    p <- p + geom_point(aes(shape = Results), cex=4, color= "blue3")
    p <- p + geom_line(size=.8)
    p <- p + theme(axis.text.x = element_text(angle = 90, hjust = 1, size=13,color="darkred"))
    p <- p + scale_color_manual(values=c("Red"))
    p <- p + ylim(-1,8)
    p <- p + theme_bw()
    p <- p + xlab('Date and Time') 
    p <- p + ylab('Temprature') 
    p <- p + ggtitle("Temporal Outliers of Node 25 ") + theme(plot.title = element_text(lineheight=3, face="bold", color="black", size=29))
    p <- p + labs(x = "Date-Time ", y = "Temprature  ")
    p <- p + theme(axis.title.y = element_text(size = rel(1.8), angle = 90))
    p <- p + theme(axis.title.x = element_text(size = rel(1.8), angle = 00))
    p
-------------------------------------------------------------------------------------------------------
title() xlab ylab main sub
-------------------------------------------------------------------------------------------------------
Results == "Outlier" geom_point p <- p + geom_point(data = df.m[df.m$Results == "Outlier",], 
                    cex=9, color= "blue3", shape = 22) scale_shape_manual library(ggplot2)
p <- ggplot(df.m,
            aes(x = HMn25_30.h, y = value, group = variable, color = variable))
#p <- p + scale_shape_manual(values=c(20,22))                 # command removed
p <- p + geom_point(data = df.m[df.m$Results == "Outlier",], 
                    cex=9, color= "blue3", shape = 22)        # command modified
p <- p + theme(axis.text.x = element_text(angle = 90, hjust = 1, size=13,
               color="darkred"))
p <- p + scale_color_manual(values=c("Red"))
p <- p + ylim(-1,8)
p <- p + theme_bw()
p <- p + xlab('Date and Time') 
p <- p + ylab('Temprature') 
p <- p + ggtitle("Temporal Outliers of Node 25 ") + 
         theme(plot.title = element_text(lineheight=3, face="bold", 
               color="black", size=29))
p <- p + theme(legend.text = element_text(colour="darkred", size = 25))
p <- p + theme(legend.title = element_text(colour="brown", size=25))
p <- p + theme(axis.title.x = element_text(face="bold",colour="darkred" size=16),
               axis.text.x  = element_text(angle=90, vjust=0.5, size=26))
p <- p + theme(axis.title.x = element_text(face="bold",colour="darkred",size=14),
               axis.text.y  = element_text(angle=00, vjust=0.5, size=20))
p <- p + labs(x = "Date-Time [UTC] \ 2007-09-30 ", y = "Temprature  ")
p <- p + theme(axis.title.y = element_text(size = rel(2.1), angle = 90))
p <- p + theme(axis.title.x = element_text(size = rel(2.1), angle = 00))
p <- p + geom_line(size=1.9)
p
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(reshape)
library(car)

G1 <- 1:10
G2 <- 11:20
G3 <- 21:30
G4 <- 31:35
G5 <- 36:41

sdata <- read.csv("http://dl.dropbox.com/u/58164604/sdata.csv", stringsAsFactors = FALSE)
pdata<-melt(sdata, id.vars="Var")
jdata <-pdata

pdata$group <- recode(pdata$Var, "G1 = 'A'; G2 = 'B'; G3 = 'C'; G4 = 'D'; G5 = 'E'")

VarArea <- data.frame(unique(pdata$Var))
VarFinalArea <-c()
for (g in 1:max(VarArea))
{
VarNum<-pdata[which(pdata$Var==g),1:c(ncol(pdata))]
VarMin <- min(VarNum$value)
VarMax <- max(VarNum$value)
VarMinMax <- cbind(VarMin, VarMax)
VarFinalArea <- rbind(VarFinalArea,VarMinMax)
}
VarFinal <- data.frame(cbind(VarArea,VarFinalArea))
colnames(VarFinal)<-c("Variable", "Min", "Max")
VarFinal$group <- recode(VarFinal$Variable, "G1 = 'A'; G2 = 'B'; G3 = 'C'; G4 = 'D'; G5 = 'E'")

VarArea <- data.frame(unique(jdata$Var))
NumV <- max(VarArea)
VarFinalMin <-c()
for (g in 1:NumV)
{
VarNum<-jdata[which(jdata$Var==g),1:c(ncol(jdata))]
VarN <- g
VarMin <- min(VarNum$value)
VarMinN <- cbind(VarN, VarMin)
VarFinalMin <- rbind(VarFinalMin,VarMinN)
}
VFinalMin <- data.frame(VarFinalMin)
colnames(VFinalMin)<-c("Variable", "Value")
VFinalMin_Max<-max(VFinalMin$Value)

VarFinalMax <-c()
for (g in 1:NumV)
{
VarNum<-jdata[which(jdata$Var==g),1:c(ncol(jdata))]
VarN <- g
VarMax <- max(VarNum$value)
VarMaxN <- cbind(VarN, VarMax)
VarFinalMax <- rbind(VarFinalMax,VarMaxN)
}
VFinalMax <- data.frame(VarFinalMax)
colnames(VFinalMax)<-c("Variable", "Value")
VFinalMax_Min<-min(VFinalMax$Value)

VFinal<-rbind(VFinalMin, VFinalMax)
VFinal$Group <- recode(VFinal$Variable, "G1 = 'A'; G2 = 'B'; G3 = 'C'; G4 = 'D'; G5 = 'E'")

VLarge <- VFinal[which(VFinal$Value >= VFinalMax_Min),]
VLarge <- VLarge[order(-VLarge$Variable, VLarge$Group),]
VSmall <- VFinal[which(VFinal$Value <= VFinalMin_Max),]
VSmall <- VSmall[order(VSmall$Variable, VSmall$Group),]
VFinal <- rbind(VSmall, VLarge)

AMin <-min(jdata$value)
AMax <-max(jdata$value)

AMinValue<-round_any(AMin,1000, f =floor)
AMaxValue<-round_any(AMax,1000, f =ceiling)

ggplot(VFinal, aes(Variable, Value, colour = Group)) + geom_polygon(colour=NA, aes(fill=Group), alpha=0.5) +scale_x_discrete(name="Missing Variable Number", limits=c(1:NumV)) + theme(axis.text.x=element_text(angle=270, vjust=0.5, hjust=0.0))+ scale_y_continuous(name="Within Cluster Sum of Squares", limits=c(AMinValue, AMaxValue), breaks = seq(AMinValue, AMaxValue, 1000)) + guides(fill=guide_legend(title="Variable Groups"))+ scale_fill_manual("Variable Groups", values = c("A" = "red", "B" = "blue", "C" = "purple", "D" = "salmon", "E" = "orange"))

last_plot()+geom_line(data=subset(pdata,variable =='Mean'), alpha=0.5, aes(Var, value, size= ''), colour="black", inherit.aes = FALSE)+ guides (size = guide_legend(title = "Mean", override.aes = list(size = 1.5, colour = "black")))

last_plot()+geom_line(data=subset(pdata,variable!='Mean'),size=0.5, alpha=0.5, aes(Var, value, shape=variable), colour='black', inherit.aes = FALSE) 

last_plot()+geom_point(data=subset(pdata,variable!='Mean'), aes(Var, value, shape = variable, col=group),alpha=1.0, inherit.aes = FALSE) + labs (shape = "Number of Clusters") + guides(scale_alpha(guide='none')) + guides(colour = "none") + scale_colour_manual("Variable Groups", values = c("A" = "red", "B" = "blue", "C" = "purple", "D" = "salmon", "E" = "orange"))

last_plot()+ ggtitle("Clusters with Missing Variables") + theme(plot.title = element_text(size = 14, colour = "black", face = "bold"))
-------------------------------------------------------------------------------------------------------
require(reshape2)
df <- read.csv("TestData.csv", header=T)
# melting by "Label". `melt is from the reshape2 package. 
# do ?melt to see what other things it can do (you will surely need it)
df.m <- melt(df, id.var = "Label")
> df.m # pasting some rows of the melted data.frame

#     Label variable      value
# 1    Good       F1 0.64778924
# 2    Good       F1 0.54608791
# 3    Good       F1 0.46134200
# 4    Good       F1 0.79421221
# 5    Good       F1 0.56919951
# 6    Good       F1 0.73568570
# 7    Good       F1 0.65094207
# 8    Good       F1 0.45749702
# 9    Good       F1 0.80861929
# 10   Good       F1 0.67310067
# 11   Good       F1 0.68781739
# 12   Good       F1 0.47009455
# 13   Good       F1 0.95859182
# 14   Good       F1 1.00000000
# 15   Good       F1 0.46908343
# 16    Bad       F1 0.57875528
# 17    Bad       F1 0.28938046
# 18    Bad       F1 0.68511766

require(ggplot2)
ggplot(data = df.m, aes(x=variable, y=value)) + geom_boxplot(aes(fill=Label)) p <- ggplot(data = df.m, aes(x=variable, y=value)) + 
             geom_boxplot(aes(fill=Label))
p + facet_wrap( ~ variable, scales="free") x-labels y-labels title legend heading jitter p <- ggplot(data = df.m, aes(x=variable, y=value)) 
p <- p + geom_boxplot(aes(fill=Label))
p <- p + geom_jitter()
p <- p + facet_wrap( ~ variable, scales="free")
p <- p + xlab("x-axis") + ylab("y-axis") + ggtitle("Title")
p <- p + guides(fill=guide_legend(title="Legend_Title"))
p geom_point() position_dodge require(ggplot2)
p <- ggplot(data = df.m, aes(x=variable, y=value)) 
p <- p + geom_boxplot(aes(fill = Label))
# if you want color for points replace group with colour=Label
p <- p + geom_point(aes(y=value, group=Label), position = position_dodge(width=0.75))
p <- p + facet_wrap( ~ variable, scales="free")
p <- p + xlab("x-axis") + ylab("y-axis") + ggtitle("Title")
p <- p + guides(fill=guide_legend(title="Legend_Title"))
p
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(gridExtra)
title <- "Default title"
data(movies)

## Init dialog
require(tkrplot)
if (!exists("slider.env")) slider.env <<- new.env(parent = .GlobalEnv)
require(tcltk)
nt <- tktoplevel()
tkwm.title(nt, title)
tkwm.geometry(nt, "480x600+0+10")
assign("tktop.slider", nt, envir = slider.env)
"relax"
nt.bak <- nt
sl.frame <- tkframe(nt)
gr.frame <- tkframe(nt)
tx.frame <- tkframe(nt)
tkpack(sl.frame, tx.frame, gr.frame, side = "bottom")
## First default plot
newpl <- function(...) {
  dummydf <- data.frame('x'=1:10, 'y'=1:10)
  dummy <- ggplot(dummydf, aes(x=x, y=y)) + geom_point(size=0) + xlim(0, 10) + ylim(0, 100) + 
    geom_text(aes(label='Generating plot...', x=5, y=50), size=9)
  print(dummy)
  }
img <- tkrplot::tkrplot(gr.frame, newpl, vscale = 1, hscale = 1)
tkpack(img, side = "top")
assign("img", img, envir = slider.env)
tkpack(fr <- tkframe(sl.frame), side = 'top')

## Creating slider, textbox and labels
sc <- tkscale(fr, from = 0, to = 5, showvalue = TRUE, resolution = 0.1, orient = "horiz")
tb <- tkentry(fr, width=4)
lab <- tklabel(fr, text = 'Select binwidth ', width = "16")
orlabel <- tklabel(fr, text=' or ', width='4')
tkpack(lab, sc, orlabel, tb, side = 'left')
tkpack(textinfo <- tkframe(tx.frame), side = 'top')


## Creating objects and variables associated with slider and textbox
assign("sc", sc, envir = slider.env)
assign("tb", tb, envir = slider.env)
assign('inputsc', tclVar(2.5), envir=slider.env)
assign('inputtb', tclVar('2.5'), envir=slider.env)
eval(parse(text = "tkconfigure(sc, variable=inputsc)"), envir = slider.env)
eval(parse(text = "tkconfigure(tb, textvariable=inputtb)"), envir = slider.env)

## Function to update the textbox value when the slider has changed
sync_textbox <- function() {
  bwidth_sl <- tclvalue(get('inputsc', envir=slider.env))
  assign('inputtb', tclVar(bwidth_sl), envir=slider.env)
  eval(parse(text = "tkconfigure(tb, textvariable=inputtb)"), envir = slider.env)
}

## Function to update the slider value when the textbox has changed
sync_slider <- function() {
  bwidth_tb <- tclvalue(get('inputtb', envir=slider.env))
  assign('inputsc', tclVar(bwidth_tb), envir=slider.env)
  eval(parse(text = "tkconfigure(sc, variable=inputsc)"), envir = slider.env)
}

## Function to refresh the plot
refresh <- function(bwidth) {
  histplot <- ggplot(data=movies, aes_string(x="rating")) +
     geom_histogram(binwidth=bwidth, 
                    aes(y = ..density..), fill='skyblue') + 
                      theme(axis.title.x=element_text(size=15), axis.title.y=element_text(size=15), 
                            axis.text.x=element_text(size=10, colour='black'),
                            axis.text.y=element_text(size=10, colour='black'))
  print(histplot)
}

## Bindings : association of certain functions to certain events for the slider
## and the textbox

tkbind(sc, "<ButtonRelease>", function(...) {
  bwidth <- as.numeric(tclvalue(get('inputsc', envir=slider.env)))
  tkrreplot(get('img',envir=slider.env),fun=function() { refresh(bwidth); sync_textbox()})
})

tkbind(tb, "<Return>", function(...) {
  bwidth <- as.numeric(tclvalue(get('inputtb', envir=slider.env)))
  tkrreplot(get('img',envir=slider.env),fun=function() { refresh(bwidth); sync_slider()})
})
-------------------------------------------------------------------------------------------------------
species <- levels(raw$SpCode)
for(i in 1:length(species))  
            {
            #open the file for writing
             pdf(paste0(species[i],".pdf"),width=5,height=4)
             plot (wrld_simpl, xlim=c(-100,-55), ylim=c(23,63), axes=TRUE, col='light grey')
             box() #adds box around map
             title(main=species[i]) #adds main title to map which should be the species name associated with the data
             points(raw$longitude[raw$SpCode == species[i]],raw$latitude[raw$SpCode == species[i]], col='black', pch=21, bg="red", cex=0.85)
             dev.off()
             }
-------------------------------------------------------------------------------------------------------
opts + ggtitle(expression(atop("Top line", atop(italic("2nd line"), ""))))
-------------------------------------------------------------------------------------------------------
x <- rnorm(1000, mean=3, sd=2)
y <- rnorm(500, mean=3.5, sd=3)

dx <- density(x)
dy <- density(y)

plot.new()
plot.window(xlim=range(c(dx$x, dy$x)), ylim=range(c(dx$y, dy$y)))
with(dx, lines(x, y))
with(dy, lines(x, y, lty=2))
axis(1)
axis(2)
legend(topright, lty=1:2, c('x', 'y'))
mtext(side=1, line=2, 'Observed values')
mtext(side=2, line=2, 'Estimated probability mass')
title('Smoothed Density Estimates for 2-sample experiment')
-------------------------------------------------------------------------------------------------------
par(mfrow=c(2,1))
par(mar=c(2,1,3,1))

x = seq(0,50,by=0.005)
y = runif(length(x),2,5)
colors = rainbow(length(x))
plot(x,y,cex=0.2,pch=16,col=colors)
title(main="old")

crp.rg <- colorRampPalette(c("red","yellow","cyan","blue","red"))
colors = crp.rg(length(x))
plot(x,y,cex=0.2,pch=16,col=colors)
title(main="new") par(mfrow=c(2,1))
par(mar=c(2,1,3,1))

x = seq(0,50,by=0.005)
y = runif(length(x),2,5)
colors = rainbow(length(x))
plot(x,y,cex=0.2,pch=16,col=colors)
title(main="old")


crp.step1 <- colorRampPalette(c("red","yellow"))
crp.step2 <- colorRampPalette(c("yellow","green"))
crp.step3 <- colorRampPalette(c("green","cyan"))
crp.step4 <- colorRampPalette(c("cyan","blue"))
crp.step5 <- colorRampPalette(c("blue","red"))

colors <-   c(
           crp.step1(2666),
           crp.step2(1000),
           crp.step3(1000),
           crp.step4(2666),
           crp.step5(2667)
        )

plot(x,y,cex=0.2,pch=16,col=colors)
title(main="new")
-------------------------------------------------------------------------------------------------------
apply(MSA, 2, function(x1) {
  apply(MSA, 2, function(x2) {
    t.test(x1, x2)
  })
}) cis <- apply(MSA, 2, function(x) mean(x) + c(-1, 1) * sd(x) * 1.96)
plot.new()
plot.window(xlim=c(1, ncol(cis)), ylim=range(cis))
segments(1:ncol(cis), cis[1, ], 1:ncol(cis), cis[2, ])
axis(1, at=1:ncol(cis), labels=colnames(MSA))
axis(2)
box()
abline(h=mean(MSA), lty='dashed')
title('Forest plot of 95% confidence intervals of MSA')
-------------------------------------------------------------------------------------------------------
gtable library(PtProcess)
library(ggplot2)
library(gtable)
library(gridExtra)

set.seed(1)
lambda <- 1.5
a <- 1
pareto <- rpareto(1000,lambda=lambda,a=a)
x_pareto <- seq(from=min(pareto),to=max(pareto),length=1000)
y_pareto <- 1-ppareto(x_pareto,lambda,a)
df1 <- data.frame(x=x_pareto,cdf=y_pareto)

set.seed(1)
mean <- 3
norm <- rnorm(1000,mean=mean)
x_norm <- seq(from=min(norm),to=max(norm),length=1000)
y_norm <- pnorm(x_norm,mean=mean)
df2 <- data.frame(x=x_norm,cdf=y_norm)

p1 <- ggplot(df1,aes(x=x,y=cdf)) + geom_line() + scale_x_log10() +
      theme(plot.margin = unit(c(0,-.5,0,.5), "lines"),
            plot.background = element_blank()) +
      ggtitle("pareto")
p2 <- ggplot(df2,aes(x=x,y=cdf)) + geom_line() + 
      theme(axis.text.y = element_blank(), 
            axis.ticks.y = element_blank(), 
            axis.title.y = element_blank(),
            plot.margin = unit(c(0,1,0,-1), "lines"),
            plot.background = element_blank()) +
      ggtitle("norm")

gt1 <- ggplot_gtable(ggplot_build(p1))
gt2 <- ggplot_gtable(ggplot_build(p2))

newWidth = unit.pmax(gt1$widths[2:3], gt2$widths[2:3])

gt1$widths[2:3] = as.list(newWidth)
gt2$widths[2:3] = as.list(newWidth)

grid.arrange(gt1, gt2, ncol=2) p1 <- ggplot(df1,aes(x=x,y=cdf)) + geom_line() + scale_x_log10() +
      theme(plot.margin = unit(c(0,-2,0,0), "lines"),
            plot.background = element_blank()) +
      ggtitle("pareto")
p2 <- ggplot(df2,aes(x=x,y=cdf)) + geom_line() + 
      theme(axis.text.y = element_blank(), 
            axis.ticks.y = element_blank(), 
            axis.title.y = element_blank(),
            plot.margin = unit(c(0,-2,0,0), "lines"),
            plot.background = element_blank()) +
      ggtitle("norm")

gt1 <- ggplot_gtable(ggplot_build(p1))
gt2 <- ggplot_gtable(ggplot_build(p2))

newWidth = unit.pmax(gt1$widths[2:3], gt2$widths[2:3])

gt1$widths[2:3] = as.list(newWidth)
gt2$widths[2:3] = as.list(newWidth)

 # New gtable with space for the three plots plus a right-hand margin
gt = gtable(widths = unit(c(1, 1, 1, .3), "null"), height = unit(1, "null"))

# Instert gt1, gt2 and gt2 into the new gtable
gt <- gtable_add_grob(gt, gt1, 1, 1)
gt <- gtable_add_grob(gt, gt2, 1, 2)
gt <- gtable_add_grob(gt, gt2, 1, 3)

grid.newpage()
grid.draw(gt)
-------------------------------------------------------------------------------------------------------
ggtitle(deparse(substitute(dataframe))) deparse() substitute()
-------------------------------------------------------------------------------------------------------
n=10000
x.=sample(-4:4,n,rep=T)
y.=sample(-4:4,n,rep=T)
x=cumsum(x.)
y=cumsum(y.)

coord=data.frame(x,y) rw <- ggplot(coord, aes(x=x, y=y))
rw + geom_path() + 
  ggtitle(paste(n, "walks")) + 
  geom_point(aes(x=0, y =0), color="green", size=I(5)) +
  geom_point(aes(x=startx, y =starty), color="red", size=I(5))
-------------------------------------------------------------------------------------------------------
initi 0.005 facet_wrap() facet_grid initi reshaped_data$initi <- factor(reshaped_data$initi) + facet_wrap(~ initi) graph_AB<-ggplot(reshaped_data,aes(x = A, y = B, colour = initi, group = L1)) +  
    geom_point(size = 5)+
    geom_line() +
    ggtitle("DATA1 vs DATA2")

graph_AB dput dput(reshaped_data) structure(list(initi = c(0.005, 0.005, 0.005, 1, 1, 1, 2, 2, 
2), A = c(1L, 2L, 3L, 1L, 2L, 3L, 1L, 2L, 3L), B = c(23.7, 31.2, 
35.8, 6.2, 10.1, 11.2, 14.2, 15.9, 16), C = c(1, 2, 3.1, 1, 2, 
3, 8, 7, 6.2), D = c(1, 2.1, 3.2, 1, 2.1, 3.5, 14.3, 13, 12.4
), E = c(24.7, 31.2, 35.6, 6.2, 7, 7, 5.2, 5.5, 5.8), L1 = structure(c(2L, 
2L, 2L, 1L, 1L, 1L, 1L, 1L, 1L), .Label = c("d1", "d2"), class = "factor")), .Names = c("initi", 
"A", "B", "C", "D", "E", "L1"), class = "data.frame", row.names = c(NA, 
-9L))
-------------------------------------------------------------------------------------------------------
?as.Date as.integer(as.Date("0/1/1"))
[1] -719528

as.integer(seq(as.Date("0/1/1"),length=2,by="-10000 years"))
[1]  -719528 -4371953

seq(as.Date(-4371953,origin="1970-01-01"),Sys.Date(),by="1000 years")
# nonsense
 [1] "0000-01-01" "'000-01-01" "(000-01-01" ")000-01-01" "*000-01-01"
 [6] "+000-01-01" ",000-01-01" "-000-01-01" ".000-01-01" "/000-01-01"
[11] "0000-01-01" "1000-01-01" "2000-01-01"

> as.integer(seq(as.Date(-4371953,origin="1970-01-01"),Sys.Date(),by="1000 years"))
# also possibly nonsense
 [1] -4371953 -4006710 -3641468 -3276225 -2910983 -2545740 -2180498 -1815255
 [9] -1450013 -1084770  -719528  -354285    10957 yrs1000 <- seq(as.Date(-4371953,origin="1970-01-01"),Sys.Date(),by="1000 years")
plot(yrs1000,rep(1,length(yrs1000)),axes=FALSE,ann=FALSE)
box()
axis(2)
axis(1,at=yrs1000,labels=c(paste(seq(10000,1000,by=-1000),"BC",sep=""),"0AD","1000AD","2000AD"))
title(xlab="Year",ylab="Value")
-------------------------------------------------------------------------------------------------------
vioplot if(length(col)==1) col <- rep(col,n) vioplot(x1, x2, x3, names=c("4 cyl", "6 cyl", "8 cyl"), col="gold") 
title("Violin Plots of Miles Per Gallon") 
my.vioplot(x1, x2, x3, names=c("4 cyl", "6 cyl", "8 cyl"), col=c("gold","red","blue")) 
title("Violin Plots of Miles Per Gallon multi colors")
-------------------------------------------------------------------------------------------------------
dlist <- list(d1 =data1 ,d2 = data2) 
reshaped_data <- melt(dlist, id.vars = c('initi','A','B','C','D','E')) 
graph_AB<-ggplot(reshaped_data,aes(x = A, y = B, colour = initi)) +  
geom_point(size = 5)+
ggtitle("DATA1 vs DATA2") 
print(graph_AB)
-------------------------------------------------------------------------------------------------------
plot.lm
 # snipping the rather long output top and bottom and showing hte relevant section
 if (show[2L]) {
    ylim <- range(rs, na.rm = TRUE)
    ylim[2L] <- ylim[2L] + diff(ylim) * 0.075
    dev.hold()
    qq <- qqnorm(rs, main = main, ylab = ylab23, ylim = ylim, 
        ...)
    if (qqline) 
        qqline(rs, lty = 3, col = "gray50")
    if (one.fig) 
        title(sub = sub.caption, ...)
    mtext(getCaption(2), 3, 0.25, cex = cex.caption)
    if (id.n > 0) 
        text.id(qq$x[show.rs], qq$y[show.rs], show.rs)
    dev.flush()
-------------------------------------------------------------------------------------------------------
op <- par(mfrow=c(2, 2))
hist(islands,main=NULL)
title("Histogram of islands",adj=1)
utils::str(hist(islands, col="gray", labels = TRUE,main=NULL))
title("Histogram of islands",adj=1)
-------------------------------------------------------------------------------------------------------
plot(x, y, type="b")
title(main=paste("Plot of \u03A6 of:", lab, "\nFunctional form:", form), adj=0)
-------------------------------------------------------------------------------------------------------
points title(main=column)
-------------------------------------------------------------------------------------------------------
onefile = TRUE rankedtRapdf <- as.data.frame(testM1)
rankedMashdf <- as.data.frame(testM2)
l <- ggplot( rankedtRapdf  )+
  geom_point( aes( x = tRapAffinities , y = score ) ) + 
  scale_x_log10() + 
  scale_y_log10()

t <- ggplot( rankedMashdf )+
  geom_point(aes( mashAffinities , y = score ), colour = "red")

k <- ggplot( rankedMashdf ) +
  geom_point( aes( mashAffinities , y = log10( rankedtRapdf$tRapAffinities ), colour = "darkred"))+
  ggtitle('Measured Mash affinities VS. measured tRap affinities') +
  theme_bw() + labs(x="MASH affinities", y="log10() tRap affinities") +
  theme(axis.title=element_text(face="bold.italic", size="12", color="brown"), legend.position="top")



# Print all plots to pdf
pdf( "~/myplots.pdf" , onefile = TRUE )
print(l)
print(t)
print(k)
dev.off()
-------------------------------------------------------------------------------------------------------
plot(1:10, 1:10, xlab="")
windowsFonts(script=windowsFont("Script MT Bold"))
title(xlab=expression(theta[l]), family="script")
-------------------------------------------------------------------------------------------------------
"Date" f <- c(2,1,5,4,8,9,5,2,1,4,7)
dates <- seq(as.Date("04/01/2012", format = "%d/%m/%Y"),
             by = "days", length = length(f))

plot(dates, f) dates > dates
 [1] "2012-01-04" "2012-01-05" "2012-01-06" "2012-01-07" "2012-01-08"
 [6] "2012-01-09" "2012-01-10" "2012-01-11" "2012-01-12" "2012-01-13"
[11] "2012-01-14" axis.Date plot(dates, f, xaxt = "n")
axis.Date(side = 1, dates, format = "%d/%m/%Y") las = 2 ?axis.Date ?strftime ?as.Date axis.Date at set.seed(53)
f <- rnorm(700, 2)
dates <- seq(as.Date("04/01/2012", format = "%d/%m/%Y"),
             by = "days", length = length(f))
head(f) op <- par(mar = c(7,4,4,2) + 0.1) ## more space for the labels
plot(dates, f, xaxt = "n", ann = FALSE)
labDates <- seq(as.Date("01/01/2012", format = "%d/%m/%Y"), tail(dates, 1),
                by = "months")
axis.Date(side = 1, dates, at = labDates, format = "%b %y", las = 2)
title(ylab = "f") ## draw the axis labels
title(xlab = "dates", line = 5) ## push this one down a bit in larger margin
par(op) ## reset margin op <- par(mar = c(7,4,4,2) + 0.1) ## more space for the labels
plot(dates, f, xaxt = "n", ann = FALSE)
labDates <- seq(as.Date("01/01/2012", format = "%d/%m/%Y"), tail(dates, 1),
                by = "2 months")
## new dates for minor ticks
minor <- seq(as.Date("01/02/2012", format = "%d/%m/%Y"), tail(dates, 1),
             by = "2 months")
axis.Date(side = 1, dates, at = labDates, format = "%b %y", las = 2)
## add minor ticks with no labels, shorter tick length
axis.Date(side = 1, dates, at = minor, labels = FALSE, tcl = -0.25)
title(ylab = "f") ## draw the axis labels
title(xlab = "dates", line = 5) ## push this one down a bit in larger margin
par(op) ## reset margin
-------------------------------------------------------------------------------------------------------
plot(1,1, xlab=expression(theta))
title(xlab="    \u2113",line=3.2,cex.lab=.7)
-------------------------------------------------------------------------------------------------------
test <- with(df1,table(age,income))
test <- as.matrix(as.data.frame.matrix(test))
plot(
  row(test),
  col(test),
  cex=test/3,pch=20,
  xlim=c(0.5,nrow(test)+0.5),
  ylim=c(0.5,ncol(test)+0.5),
  axes=FALSE,
  ann=FALSE
)
axis(1,at=1:nrow(test),labels=rownames(test),cex.axis=0.8)
axis(2,at=1:ncol(test),labels=colnames(test),cex.axis=0.8)
title(xlab="Age Group",ylab="Income")
box()
-------------------------------------------------------------------------------------------------------
ggtitle theme df = data.frame(gp = factor(rep(letters[1:3], each = 10)), y = rnorm(30))
p = ggplot(df) + geom_point(aes(x = gp, y = y)) + ggtitle('a') + theme(plot.title=element_text(hjust=0))
p2 = ggplot(df) + geom_point(aes(x = y, y = gp)) + ggtitle('b') + theme(plot.title=element_text(hjust=0))
grid.arrange(p, p2, ncol = 2)
-------------------------------------------------------------------------------------------------------
require(xts)

X.stock.rtns <- xts(rnorm(1000,0.00001,0.0003), Sys.Date()-(1000:1))
Y.stock.rtns <- xts(rnorm(1000,0.00003,0.0004), Sys.Date()-(1000:1))
Z.stock.rtns <- xts(rnorm(1000,0.00005,0.0005), Sys.Date()-(1000:1))
rtn.obj <- merge(X.stock.rtns , Y.stock.rtns, Z.stock.rtns)
colnames(rtn.obj) <- c("x","y","z")

# advanced charts.PerforanceSummary based on ggplot
gg.charts.PerformanceSummary <- function(rtn.obj, geometric = TRUE, main = "", plot = TRUE)
  {

    # load libraries
    suppressPackageStartupMessages(require(ggplot2))
    suppressPackageStartupMessages(require(scales))
    suppressPackageStartupMessages(require(reshape))
    suppressPackageStartupMessages(require(PerformanceAnalytics))

    # create function to clean returns if having NAs in data
    clean.rtn.xts <- function(univ.rtn.xts.obj,na.replace=0){
    univ.rtn.xts.obj[is.na(univ.rtn.xts.obj)]<- na.replace
    univ.rtn.xts.obj  
  }

    # Create cumulative return function
    cum.rtn <- function(clean.xts.obj, g = TRUE)
    {
      x <- clean.xts.obj
      if(g == TRUE){y <- cumprod(x+1)-1} else {y <- cumsum(x)}
      y
    }

    # Create function to calculate drawdowns
    dd.xts <- function(clean.xts.obj, g = TRUE)
    {
      x <- clean.xts.obj
      if(g == TRUE){y <- Drawdowns(x)} else {y <- Drawdowns(x,geometric = FALSE)}
      y
    }

    # create a function to create a dataframe to be usable in ggplot to replicate charts.PerformanceSummary
    cps.df <- function(xts.obj,geometric)
    {
      x <- clean.rtn.xts(xts.obj)
      series.name <- colnames(xts.obj)[1]
      tmp <- cum.rtn(x,geometric)
      tmp$rtn <- x
      tmp$dd <- dd.xts(x,geometric)
      colnames(tmp) <- c("Index","Return","Drawdown") # names with space
      tmp.df <- as.data.frame(coredata(tmp))
      tmp.df$Date <- as.POSIXct(index(tmp))
      tmp.df.long <- melt(tmp.df,id.var="Date")
      tmp.df.long$asset <- rep(series.name,nrow(tmp.df.long))
      tmp.df.long
    }

    # A conditional statement altering the plot according to the number of assets
    if(ncol(rtn.obj)==1)
    {
      # using the cps.df function
      df <- cps.df(rtn.obj,geometric)
      # adding in a title string if need be
      if(main == ""){
        title.string <- paste("Asset Performance")
      } else {
        title.string <- main
      }

    gg.xts <- ggplot(df, aes_string( x = "Date", y = "value", group = "variable" )) +
      facet_grid(variable ~ ., scales = "free_y", space = "fixed") +
      geom_line(data = subset(df, variable == "Index")) +
      geom_bar(data = subset(df, variable == "Return"), stat = "identity") +
      geom_line(data = subset(df, variable == "Drawdown")) +
      geom_hline(yintercept = 0, size = 0.5, colour = "black") +
      ggtitle(title.string) +
      theme(axis.text.x = element_text(angle = 0, hjust = 1)) +
      scale_x_datetime(breaks = date_breaks("6 months"), labels = date_format("%m/%Y")) +
      ylab("") +
      xlab("")

  } 
 else 
  {
    # a few extra bits to deal with the added rtn columns
    no.of.assets <- ncol(rtn.obj)
    asset.names <- colnames(rtn.obj)
    df <- do.call(rbind,lapply(1:no.of.assets, function(x){cps.df(rtn.obj[,x],geometric)}))
    df$asset <- ordered(df$asset, levels=asset.names)
    if(main == ""){
      title.string <- paste("Asset",asset.names[1],asset.names[2],asset.names[3],"Performance")
    } else {
      title.string <- main
    }

    if(no.of.assets>5){legend.rows <- 5} else {legend.rows <- no.of.assets}

      gg.xts <- ggplot(df, aes_string(x = "Date", y = "value" )) +

      # panel layout
      facet_grid(variable~., scales = "free_y", space = "fixed", shrink = TRUE, drop = TRUE, margin = 
                 , labeller = label_value) + # label_value is default

      # display points for Index and Drawdown, but not for Return
      geom_point(data = subset(df, variable == c("Index","Drawdown"))
                 , aes(colour = factor(asset), shape = factor(asset)), size = 1.2, show_guide = TRUE) + 

      # manually select shape of geom_point
      scale_shape_manual(values = c(1,2,3)) + 

      # line colours for the Index
      geom_line(data = subset(df, variable == "Index"), aes(colour = factor(asset)), show_guide = FALSE) +

      # bar colours for the Return
      geom_bar(data = subset(df,variable == "Return"), stat = "identity"
           , aes(fill = factor(asset), colour = factor(asset)), position = "dodge", show_guide = FALSE) +

      # line colours for the Drawdown
      geom_line(data = subset(df, variable == "Drawdown"), aes(colour = factor(asset)), show_guide = FALSE) +

      # horizontal line to indicate zero values
      geom_hline(yintercept = 0, size = 0.5, colour = "black") +

      # horizontal ticks
      scale_x_datetime(breaks = date_breaks("6 months"), labels = date_format("%m/%Y")) +

      # main y-axis title
      ylab("") +

      # main x-axis title
      xlab("") +

      # main chart title
      ggtitle(title.string)

      # legend 

      gglegend <- guide_legend(override.aes = list(size = 3))

      gg.xts <- gg.xts + guides(colour = gglegend, size = "none") +

      # gglegend <- guide_legend(override.aes = list(size = 3), direction = "horizontal") # direction overwritten by legend.box?
      # gg.xts <- gg.xts + guides(colour = gglegend, size = "none", shape = gglegend) + # Warning: "Duplicated override.aes is ignored"

      theme( legend.title = element_blank()
             , legend.position = c(0,1)
             , legend.justification = c(0,1)
             , legend.background = element_rect()
             , legend.box = "horizontal" # not working?
             , axis.text.x = element_text(angle = 0, hjust = 1)
            )

}

assign("gg.xts", gg.xts,envir=.GlobalEnv)
if(plot == TRUE){
    plot(gg.xts)
} else {}

}

# display chart
gg.charts.PerformanceSummary(rtn.obj, geometric = TRUE) # create a function to store fancy axis labels 

    my_labeller <- function(var, value){ # from the R Cookbook
        value <- as.character(value)
        if (var=="variable") 
        {
              value[value=="Index"] <- "Cumulative Returns"
              value[value=="Return"] <- "Daily Returns"
              value[value=="Drawdown"] <- "Drawdown"
        }
        return(value)
    } theme( legend.title = element_blank()
         , legend.position = c(0,1)
         , legend.justification = c(0,1)
         , legend.background = element_rect()
         #, legend.key = element_rect(fill="white",colour="white")# added as afterthought
         , legend.box = "horizontal" # not working?
         , axis.text.x = element_text(angle = 0, hjust = 1)
         #, axis.title.y = element_text(size=2,colour="black")
         , strip.background = element_rect(fill = 'white')
         , panel.background = element_rect(fill = 'white', colour = 'white')
         , panel.grid.major = element_line(colour = "grey", size = 0.5) 
         , panel.grid.minor = element_line(colour = NA, size = 0.0)
        )
-------------------------------------------------------------------------------------------------------
internetImportance Category <- c("Electronics", "Appliances", "Books", "Music", "Clothing", 
        "Cars", "Food/Beverages", "Personal Hygiene", 
        "Personal Health/OTC", "Hair Care")
Percent <- c(81, 77, 70, 69, 69, 68, 62, 62, 61, 60)

internetImportance <- data.frame(Category,Percent)

len <- 4
df2 <- data.frame(Category = letters[1:len], Percent = rep(0, len), 
                                 Category2 = rep("", len))
internetImportance$Category2 <- 
 paste0(internetImportance$Category," - ",internetImportance$Percent,"%")

# append number to category name
internetImportance <- rbind(internetImportance, df2)

# set factor so it will plot in descending order 
internetImportance$Category <-
    factor(internetImportance$Category, 
    levels=rev(internetImportance$Category)) ggplot2 fill=category2 ggplot(internetImportance, aes(x = Category, y = Percent,
    fill = Category2)) + 
    geom_bar(width = 0.9, stat="identity") + 
    coord_polar(theta = "y") +
    xlab("") + ylab("") +
    ylim(c(0,100)) +
    ggtitle("Top Product Categories Influenced by Internet") +
    geom_text(data = internetImportance, hjust = 1, size = 3,
              aes(x = Category, y = 0, label = Category2)) +
    theme_minimal() +
    theme(legend.position = "none",
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.line = element_blank(),
          axis.text.y = element_blank(),
          axis.text.x = element_blank(),
          axis.ticks = element_blank()) geom_text(label="GLOBAL", x=.5, y=.5, size=4) + theme_minimal GLOBAL
-------------------------------------------------------------------------------------------------------
# > ret
#       x       y xmin xmax ymin ymax
# 1 test1 success    0    3    0    1
# 2 test2 success    0    3    1    2
# 3 test3 failure    3    6    0    1
# 4 test4 success    3    6    1    2 ggplot(ret, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax)) + 
          geom_rect(colour="white", alpha = 0.5, aes(fill=y)) + 
          scale_fill_manual(values=c("red", "green"), guide=FALSE) + 
          geom_text(aes(x=(xmin+xmax)/2, y=(ymin+ymax)/2, label=x)) + 
          theme_bw() + theme(axis.text.y = element_blank(), 
          axis.text.x = element_blank(), axis.ticks.x = element_blank(), 
          axis.ticks.y = element_blank(), panel.grid.major.x = element_blank(), 
          panel.grid.major.y = element_blank(), panel.grid.minor.x = element_blank(), 
          panel.grid.minor.y = element_blank()) + xlab("") + ylab("") + 
          ggtitle("My tests")
-------------------------------------------------------------------------------------------------------
par(new=TRUE) (axes=FALSE) data <- matrix(rnorm(4*100),ncol=4)
 par(mar=c(5, 6, 2, 4))
 plot(1:100,data[,3], lwd=3, col="green", ann=FALSE, las=2,type='l')
 mtext("I am at left", side=2, line=3.5)
 par(new=TRUE)
 plot(1:100,data[,2], ann=FALSE, axes=FALSE,col='red',type='l')
 mtext("I am at right)", side=4, line=2)
 title("Using par(new=TRUE) \n same X and different or not Y axis ")
 axis(4)
-------------------------------------------------------------------------------------------------------
ggtitle ggtitle for (i in 1:length(names)) {
  df.tax <- subset(df, df[,c(counter)] != 0)
  counter = counter + 1L
  meta <- subset(df.tax, select=c(1:16))
  meltmeta <- melt(meta, id=c("Collector", "Year","Week","Cities","Provinces"))
  ppv <- ggplot(meltmeta, aes(factor(Provinces), value))
  ppv <- ppv + geom_boxplot() 
  ppv <- ppv + geom_boxplot(aes(fill=Collector), alpha=I(0.5)) 
  ppv <- ppv + geom_point(aes(color=Collector), size=1) 
  ppv <- ppv + facet_wrap(~variable, scale="free")
  ppv <- ppv + ggtitle(paste(names[i]))
  ggsave(file = paste(names[i], sep=".","provinces_vs_climate.pdf"), width=16, height=8)
}
-------------------------------------------------------------------------------------------------------
format= striptime() format = "%m/%d/%Y %H:%M" df.m$dt_hmn.dt <- strptime(as.character(df.m$dt_hmn.dt), format = "%m/%d/%Y %H:%M") ggplot() color="blue" geom_point() scale_color_manual() color=variable aes() scale_shape_manual() 27 17 theme_bw() theme() theme_bw() ggplot(df.m, aes(x = dt_hmn.dt, y = value, group = variable)) + 
  geom_point(aes(shape = Results), cex=13, color= "blue")+
  scale_shape_manual(values=c(17,20))+
  ylim(-1,8)+
  theme_bw()+
  xlab('Date and Time') +
  ylab('Temprature')+
  ggtitle("Temporal Outliers of Node 25 ") + 
  theme(plot.title = element_text(lineheight=3, face="bold", color="black", size=29))+
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size=13,color="darkred"))
-------------------------------------------------------------------------------------------------------
xy.coords lines plot(beforeandafterdata[,1],type="l",col="black",xlim=c(0.9,2.1),ylim=ylimits,
     ann=FALSE,axes=FALSE) 
title(ylab=ylabel, cex.lab=1.4) 
axis(1,at=1:2,lab=c("Preop.","Postop."),cex.axis=1.5)
axis(2,labels=TRUE) 
x<-c(1*2:6) 
x 
lapply(x, function(x){
lines(xy.coords(x=c(1, 2), y=c(beforeandafterdata[,x])), type="l", col="black", 
      xlim=c(0.9,2.1),ylim=ylimits,ann=FALSE)
})
-------------------------------------------------------------------------------------------------------
ggplot(pd[pd$score1 != 0,], aes(x=x, y=species)) +
  coord_fixed(ratio = 1.5, xlim=c(0.5,16.5), ylim=c(0.5, 3.5)) +
  geom_tile(aes(fill=score1)) +
  scale_fill_gradient2("Score 1", limits=c(0,4),low="#762A83", mid="white", high="#1B7837", guide=guide_colorbar(title.position="top")) +
  geom_text(data=pd, aes(label=letters, size = score2, color=factor(change)), family="mono") +
  scale_size_continuous(range = c(4, 8)) +
  scale_color_manual("Change", values=c("black", "#F2A11F"), labels=c("None", "Some"), guide=guide_legend(direction="vertical", title.position="top", override.aes=list(shape = "A"))) +
  theme(panel.background=element_rect(fill="white", colour="white"),
        axis.title = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.y = element_text(family="mono", size=rel(2)),
        axis.text.x = element_text(size=rel(0.7)),
        legend.text = element_text(size=rel(0.7)),
        legend.key.size = unit(0.7, "lines"),
        legend.position = "bottom", legend.box = "horizontal") +
  ggtitle("What about Score2?") library(ggplot2)
library(grid)
library(proto)

GeomTile2 <- proto(ggplot2:::GeomTile, {
  reparameterise <- function(., df, params) {
    df <- .$.super$reparameterise(df, params)
    if (params$ud == "u") 
      transform(df, ymin = y) 
    else 
        transform(df, ymax = (y-ymin)*0.8 + ymin, ymin = (y-ymin)*0.2 + ymin)
  }
  draw <- function(..., ud) {.$.super$draw(..., ud)}
})
geom_tile2 <- function (mapping = NULL, data = NULL, stat = "identity", position = "identity", ..., ud = "u") { 
  GeomTile2$new(mapping = mapping, data = data, stat = stat, position = position, ..., ud = ud)
}

ggplot(pd, aes(x=x, y=species)) +
  coord_fixed(ratio = 1.5, xlim=c(0.5,16.5), ylim=c(0.5, 3.5)) +
  geom_tile2(aes(fill=score1), ud = "u") +
  geom_tile2(aes(fill = score2), ud = "d") +
  scale_fill_gradient2("Score 1", limits=c(0,4),low="#762A83", mid="white", high="#1B7837", guide=guide_colorbar(title.position="top")) +
  geom_text(data=pd, aes(label=letters, color=factor(change)), size=rel(5), family="mono") +
  scale_color_manual("Change", values=c("black", "#F2A11F"), labels=c("None", "Some"), guide=guide_legend(direction="vertical", title.position="top", override.aes=list(shape = "A"))) +
  theme(panel.background=element_rect(fill="white", colour="white"),
        axis.title = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.y = element_text(family="mono", size=rel(2)),
        axis.text.x = element_text(size=rel(0.7)),
        legend.text = element_text(size=rel(0.7)),
        legend.key.size = unit(0.7, "lines"),
        legend.position = "bottom", legend.box = "horizontal") +
  ggtitle("What about Score2?")
-------------------------------------------------------------------------------------------------------
graphics.off() dev.copy dev.off() graphics.off() dev.off() ggsave print last_plot ggplot p ggsave('filname.png') for (i in 1:2){
  if (1){
    hist(rnorm(100))
    dev.copy(file="MyHist.png",device=png, bg="white",  width=640, height=352) 
    graphics.off()

    p <- ggplot(bin.ts.avg, aes(x, tt)) + geom_point() +geom_line() + facet_grid(.~depday)
    p <- p + ggtitle("10 minute averages")+ xlab("Hour") + ylab("Values")    
    p <- p + scale_x_continuous(breaks=c(min(bin.ts.avg$x), max(bin.ts.avg$x)), labels=c("7", "10"))
   # no need to print p
   ggsave(filename="MyGGPlot.png")
   # note specifying p is redundant but explicit.
   # ggsave(filename = 'MyGGplot.png', plot = p)
  }
}
-------------------------------------------------------------------------------------------------------
NA geom_text geom_text(data = out[!is.na(out$V1),], label = "test") rownames plotAll<-function(data){
  combs <- expand.grid(names(data), names(data))
  out <- do.call(rbind, apply(combs, 1, function(x) {
    tt <- data[, x]; names(tt) <- c("V1", "V2")
    tt <- cbind(tt, id1 = x[1], id2 = x[2])
  }))

  library(plyr)
  df.text=ddply(out[out$id1==out$id2,],.(id1,id2),summarise,
                pos=max(V1)-(max(V1)-min(V1))/2)
  out[out$id1==out$id2,c("V1","V2")]<-NA
  out$labels <- rownames(out)
  ggplot(data = out, aes(x = V2, y = V1)) + geom_text(data = out[!is.na(out$V1),], aes(label = labels)) +
    facet_grid(id1 ~ id2,scales="fixed")+
    geom_text(data=df.text,aes(pos,pos,label=id1)) + geom_abline( slope=1 ) + 
    ggtitle("Corralation between measured & calculated affinities") +
    ylab("") + xlab("") + theme(panel.grid.minor.x=element_blank(), panel.grid.major.x=element_blank())
}
plotAll(data)
-------------------------------------------------------------------------------------------------------
s() te() fx = TRUE ?te # following shows how tensor pruduct deals nicely with 
# badly scaled covariates (range of x 5% of range of z )
require(mgcv)
test1 <- function(x, z ,sx=0.3, sz=0.4) { 
  x <- x*20
  (pi ** sx * sz) * (1.2 * exp(-(x - 0.2)^2 / sx^2 - ( z - 0.3)^2 / sz^2) +
  0.8 * exp(-(x - 0.7)^2 / sx^2 -(z - 0.8)^2 / sz^2))
}
n <- 500

old.par<-par(mfrow=c(2,2))
x <- runif(n) / 20
z<-runif(n)
xs <- seq(0, 1, length=30) / 20
zs <- seq(0, 1, length=30)
pr <- data.frame(x=rep(xs, 30), z=rep(zs, rep(30, 30)))
truth <- matrix(test1(pr$x, pr$z), 30, 30)
f <- test1(x, z)
y <- f + rnorm(n) * 0.2

## model 1 with s() smooths
b1 <- gam(y ~ s(x,z))
persp(xs, zs, truth)
title("truth")
vis.gam(b1)
title("t.p.r.s")

## model 2 with te() smooths
b2 <- gam(y ~ te(x, z))
vis.gam(b2)
title("tensor product")

## model 3 te() smooths specifying margin bases
b3 <- gam(y ~ te(x, z, bs=c("tp", "tp")))
vis.gam(b3)
title("tensor product")
par(old.par)
-------------------------------------------------------------------------------------------------------
filled.contour filled.contour my.filled.contour <-
function (x = seq(0, 1, length.out = nrow(z)), y = seq(0, 1,
    length.out = ncol(z)), z, xlim = range(x, finite = TRUE),
    ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE),
    levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors,
    col = color.palette(length(levels) - 1), plot.title, plot.axes,
    key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1,
    axes = TRUE, frame.plot = axes, ...)
{
    if (missing(z)) {
        if (!missing(x)) {
            if (is.list(x)) {
                z <- x$z
                y <- x$y
                x <- x$x
            }
            else {
                z <- x
                x <- seq.int(0, 1, length.out = nrow(z))
            }
        }
        else stop("no 'z' matrix specified")
    }
    else if (is.list(x)) {
        y <- x$y
        x <- x$x
    }
    if (any(diff(x) <= 0) || any(diff(y) <= 0))
        stop("increasing 'x' and 'y' values expected")
    mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar
    on.exit(par(par.orig))
    w <- (3 + mar.orig[2L]) * par("csi") * 2.54
    layout(matrix(c(2, 1), ncol = 2L), widths = c(1, lcm(w)))
    par(las = las)
    mar <- mar.orig
    mar[4L] <- mar[2L]
    mar[2L] <- 1
    par(mar = mar)
    plot.new()
    plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i",
        yaxs = "i")
#    rect(0, levels[-length(levels)], 1, levels[-1L], col = col)
#    if (missing(key.axes)) {
#        if (axes)
#            axis(4)
#    }
#    else key.axes
#    box()
    if (!missing(key.title))
        key.title
    mar <- mar.orig
    mar[4L] <- 1
    par(mar = mar)
    plot.new()
    plot.window(xlim, ylim, "", xaxs = xaxs, yaxs = yaxs, asp = asp)
    if (!is.matrix(z) || nrow(z) <= 1L || ncol(z) <= 1L)
        stop("no proper 'z' matrix specified")
    if (!is.double(z))
        storage.mode(z) <- "double"
    .Internal(filledcontour(as.double(x), as.double(y), z, as.double(levels),
        col = col))
    if (missing(plot.axes)) {
        if (axes) {
            title(main = "", xlab = "", ylab = "")
            Axis(x, side = 1)
            Axis(y, side = 2)
        }
    }
    else plot.axes
    if (frame.plot)
        box()
    if (missing(plot.title))
        title(...)
    else plot.title
    invisible()
} my.filled.contour(x=x, y=y, z=z,
               levels=levels,
               col=colorpanel(length(levels) + 1, "white", "grey10"),
               xlim=rev(range(x)),
               ylim=rev(range(y)),
               plot.axes={axis(1, c(0.18, 0.01), label=TRUE, tcl=-0.5)
                          axis(2, c(0.18, 0.01), label=TRUE, tcl=-0.5)
                          draw.contour()},
               xlab="x",
               frame=FALSE)
-------------------------------------------------------------------------------------------------------
bquote plot(1:10, 1:10)
title(main = bquote(.(number[1]) ~ "plot, units are in km" ~ m^-3))
-------------------------------------------------------------------------------------------------------
ggplot(RQA, aes(x = Type, y = engagementPercent)) + 
geom_boxplot(aes(fill = Type),alpha = .6,size = 1) + 
scale_fill_brewer(palette = "Set2") + 
stat_summary(fun.y = "mean", geom = "text", label="----", size= 10, color= "white") +
ggtitle("Participation distribution by type") + 
theme(axis.title.y=element_blank()) + theme(axis.title.x=element_blank())
-------------------------------------------------------------------------------------------------------
inputs <- function(){

   xvar <- tclVar("")
   yvar <- tclVar("")

   tt <- tktoplevel()
   tkwm.title(tt,"Input Numbers")
   x.entry <- tkentry(tt, textvariable=xvar)
   y.entry <- tkentry(tt, textvariable=yvar)

   reset <- function()
    {
     tclvalue(xvar)<-""
     tclvalue(yvar)<-""
    }

   reset.but <- tkbutton(tt, text="Reset", command=reset)

   submit <- function() {
     x <- as.numeric(tclvalue(xvar))
     y <- as.numeric(tclvalue(yvar))
     e <- parent.env(environment())
     e$x <- x
     e$y <- y
     tkdestroy(tt)
   }
   submit.but <- tkbutton(tt, text="submit", command=submit)

   tkgrid(tklabel(tt,text="Enter Two Inputs"),columnspan=2)
   tkgrid(tklabel(tt,text="Input1"), x.entry, pady = 10, padx =10)
   tkgrid(tklabel(tt,text="Input2"), y.entry, pady = 10, padx =10)
   tkgrid(submit.but, reset.but)

  tkwait.window(tt)
  return(c(x,y))
} myvals <- inputs() myvals
-------------------------------------------------------------------------------------------------------
library(rugarch)
data(sp500ret)
spec <- ugarchspec(distribution.model = "std")
mod <- ugarchroll(spec, data = sp500ret[1:2000,], n.ahead = 1, 
                 n.start = 1000,  refit.every = 100, refit.window = "moving", 
                 solver = "hybrid", fit.control = list(),
                 calculate.VaR = TRUE, VaR.alpha = c(0.01, 0.025, 0.05),
                 keep.coef = TRUE) plot(mod, which = 5) getMethod("plot", c(x = "uGARCHroll", y = "missing")) .intergarchrollPlot(x, choices = choices, plotFUN = paste(".plot.garchroll", 
            1:5, sep = "."), which = which, VaR.alpha = VaR.alpha, 
            density.support = density.support, ...) choices "Fit Coefficients (with s.e. bands)" rugarch:::.intergarchrollPlot rugarch:::.plot.garchroll.5 library(xts)
x <- mod
vmodel = x@model$spec@model$modeldesc$vmodel
if (!x@model$keep.coef) 
  stop("\n\nplot-->error: keep.coef set to FALSE in estimation\n")
coefs = x@model$coef
m = dim(coefs[[1]]$coef)[1]
N = length(coefs)
Z = matrix(NA, ncol = m, nrow = N)
Zup = matrix(NA, ncol = m, nrow = N)
Zdn = matrix(NA, ncol = m, nrow = N)
for (i in 1:m) {
  Z[, i] = sapply(coefs, FUN = function(y) y$coef[i, 1])
  Zup[, i] = Z[, i] + sapply(coefs, FUN = function(y) y$coef[i, 
                                                             2])
  Zdn[, i] = Z[, i] - sapply(coefs, FUN = function(y) y$coef[i, 
                                                             2])
}
dt = sapply(coefs, FUN = function(y) as.character(y$index))
cnames = rownames(coefs[[1]]$coef)
np = rugarch:::.divisortable(m) # added rugarch::: i plotFun <- function(i){
  plot(xts(Z[, i], as.POSIXct(dt)), type = "l", 
       ylim = c(min(Zdn[, i]), max(Zup[, i])), ylab = "value", xlab = "", main = "", 
       minor.ticks = FALSE, ann = FALSE, auto.grid = FALSE)
  lines(xts(Zdn[, i], as.POSIXct(dt)), col = 2)
  lines(xts(Zup[, i], as.POSIXct(dt)), col = 2)
  title(cnames[i], line = 0.4, cex = 0.9)
  grid()
} plotFun(1)
plotFun(2)
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(grid)

pd = data.frame(
  letters = strsplit("AGTGACCGACTATCATAGTGACCCAGAATCATAGTGACCGAGTATGAT", "")[[1]],
  species = rep(c("Human", "Armadillo", "Porcupine"), each=16),
  x       = rep(1:16, 3),
  change  = c(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
              0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,
              0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0),
  score1  = c(0,0,0,0,0,0,1,1,2,2,2,3,3,3,4,3,
              0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,
              0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),
  score2  = c(0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,
              0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,
              0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0)
)


p1=ggplot(pd[pd$score1 != 0,], aes(x=x, y=species)) +
  coord_fixed(ratio = 1.5, xlim=c(0.5,16.5), ylim=c(0.5, 3.5)) +
  geom_tile(aes(fill=score1)) +
  scale_fill_gradient2("Score 1", limits=c(0,4),low="#762A83", mid="white", high="#1B7837", guide=guide_colorbar(title.position="top")) +
  geom_text(data=pd, aes(label=letters, color=factor(change)), size=rel(5), family="mono") +
  scale_color_manual("Change", values=c("black", "#F2A11F"), labels=c("None", "Some"), guide=guide_legend(direction="vertical", title.position="top", override.aes=list(shape = "A"))) +
  theme(panel.background=element_rect(fill="white", colour="white"),
        axis.title = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.y = element_text(family="mono", size=rel(2)),
        axis.text.x = element_text(size=rel(0.7)),
        legend.text = element_text(size=rel(0.7)),
        legend.key.size = unit(0.7, "lines"),
        legend.position = "bottom", legend.box = "horizontal") +
  ggtitle("Voila, the Score2!")

p2=ggplot(pd[pd$score2 != 0,], aes(x=x, y=species)) +
  coord_fixed(ratio = 1.5, xlim=c(0.5,16.5), ylim=c(0.5, 3.5)) +
  geom_tile(aes(fill=score2)) +
  scale_fill_gradient2("Score 2", limits=c(0,3),low="#1B7837", mid="white", high="#762A83", guide=guide_colorbar(title.position="top")) +
  geom_text(data=pd, aes(label=letters, color=factor(change)), size=rel(5), family="mono") +
  scale_color_manual("Change", values=c("black", "#F2A11F"), labels=c("None", "Some"), guide=guide_legend(direction="vertical", title.position="top", override.aes=list(shape = "A"))) +
  theme(panel.background=element_rect(fill="white", colour="white"),
        axis.title = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.y = element_text(family="mono", size=rel(2)),
        axis.text.x = element_text(size=rel(0.7)),
        legend.text = element_text(size=rel(0.7)),
        legend.key.size = unit(0.7, "lines"),
        legend.position = "bottom", legend.box = "horizontal") +
  ggtitle("What about Score2?")


p1g=ggplotGrob(p1)
p2g=ggplotGrob(p2)

combo.grob = p1g

combo.grob$grobs[[8]] = cbind(p1g$grobs[[8]][,1:4], 
                              p2g$grobs[[8]][,3:5], 
                              size="first")

combo.grob$grobs[[4]] = reorderGrob(
                          addGrob(p1g$grobs[[4]], 
                                  getGrob(p2g$grobs[[4]], 
                                          "geom_rect.rect", 
                                          grep=TRUE)), 
                          c(1,2,5,3,4))
grid.newpage()
grid.draw(combo.grob)
-------------------------------------------------------------------------------------------------------
ggplot2 library(ggplot2)
ggplot(data = C, aes(x = Site, y = TN.TP, colour = Land.Use)) +
  facet_wrap( ~ Seasonal.Flow, ncol = 1) +
  geom_boxplot() +
  scale_colour_hue("Land use") +
  ggtitle("Collie River TN:TP") +
  ylab("ratio") +
  xlab("Site + Flow regime")
-------------------------------------------------------------------------------------------------------
plot(x, y)
title(expression("title (" * phantom("slope=1)") * ")"), col.main = "black")
title(expression(phantom("title (") * "slope=1"), col.main = "red")
-------------------------------------------------------------------------------------------------------
group.colors <- c(A = "#333BFF", B = "#CC6600", C ="#9633FF", D = "#E2FF33", E = "#E3DB71")

simplePlot <- function(DT, tit) 
  ggplot(DT ,aes(x=Name, y=Value, fill=Group)) +
  geom_bar(stat="identity") + xlab("") + ggtitle(tit) +
  #Specify colours
  scale_fill_manual(values=Colorsv) grid.arrange(ncol=2,  simplePlot(DT1, tit="Plot 1"), 
  simplePlot(DT2, tit="Plot 2")) scale_fill_manual() ColorsDT <-  data.table(Group=LETTERS[1:5], Color=c("#333BFF", "#CC6600", "#9633FF", "#E2FF33", "#E3DB71"), key="Group")
ColorsDT
#   Group   Color
#1:     A #333BFF
#2:     B #CC6600
#3:     C #9633FF
#4:     D #E2FF33
#5:     E #E3DB71 ColorsDT.name <-  data.table(A = "#333BFF", B = "#CC6600", C = "#9633FF", D = "#E2FF33", E =  "#E3DB71")
ColorsDT.name
#          A       B       C       D       E
# 1: #333BFF #CC6600 #9633FF #E2FF33 #E3DB71
-------------------------------------------------------------------------------------------------------
cex par() plot() # example from ?hclust
hc <- hclust(dist(USArrests), "ave")

# default label size
plot(hc, xlab="xlab", ylab="ylab", main="main", sub="")

# reduced label size
par(cex=0.3, mar=c(5, 8, 4, 1))
plot(hc, xlab="", ylab="", main="", sub="", axes=FALSE)
par(cex=1)
title(xlab="xlab", ylab="ylab", main="main")
axis(2)
-------------------------------------------------------------------------------------------------------
+ - ggplot(combined.data, aes(x = region, y = expression, fill = species)) +
    geom_boxplot() +
    scale_fill_manual(values = c("yellow", "orange")) + 
    ggtitle("Expression comparisons for ACTB") + 
    theme(axis.text.x = element_text(angle=90, face="bold", colour="black")) +
-------------------------------------------------------------------------------------------------------
ggplot(dtfr, aes(x=Year, y=Value)) +
    geom_line(aes(group=Sector, color=Sector)) +
    geom_point(aes(color=Sector, shape=Sector)) +
    stat_summary(aes(colour="mean",shape="mean",group=1), fun.y=mean, geom="line", size=1.1) +
    scale_color_manual(values=c("#004E00", "#33FF00", "#FF9966", "#3399FF", "#FF004C")) +
    scale_shape_manual(values=c(1:4, 32)) +
    ggtitle("Test for ggplot2 graph")
-------------------------------------------------------------------------------------------------------
xlim() scale_x_discrete() scale_x_discrete() ggplot(df, aes(x=df$days, y=ecdf(df$days)(ComplianceDateDiff$days)))+ 
  geom_step(size=2.2,color="red")+geom_step(color="cyan",size=1.5)+
  scale_y_continuous(labels = percent_format(), limits=c(0,1))+ 
  labs(x="Time (days)", y="% Total")+
  ggtitle("Cumulative Distritubtion Function")+
  scale_x_discrete(breaks = c(0,1,2,3,4,6,7), limits = c(-1, 8)
-------------------------------------------------------------------------------------------------------
ggplot(df, aes(x=df$days, y=ecdf(df$days)(df$days)))+ 
  geom_step(size=1.2,color="red",alpha=0.8)+geom_step(color="cyan")+
  scale_x_continuous(limits=c(-1,8),breaks=c(0,1,2,3,4,5,6,7))+ 
  scale_y_continuous(labels = percent_format(), limits=c(0,1),breaks=c(.0,.33,.5,.75,1))+ 
  labs(x="Time (days)", y="% Compliance")+
  ggtitle("Cumulative Distritubtion Function")
  #scale_x_discrete(breaks = c(0,1,2,3,4,6,7), limits = c(-1, 7))
  #geom_hline(yintercept = .3333, color="orange",size=1,linetype = "dashed")
-------------------------------------------------------------------------------------------------------
plot.title plot.axes key.title key.axes ?filled.contour ...: additional graphical parameters, currently only passed to
      ‘title()’. x=1:10
y=1:10
z=array(rnorm(100),dim=c(10,10))

filled.contour(x,y,z,las=0,
  plot.axes={
              axis(1,cex.axis=2)
              axis(2,cex.axis=2)
            },
  plot.title={
              title(xlab="x",cex.lab=2)
              mtext("y",2,cex=2,line=3,las=1)
  }
)
-------------------------------------------------------------------------------------------------------
list_of_graphs i i plot(...)
title(i) main plot plot(..., main=i) titles <- c("Title 1", "Title 2", "Title 3", "Title 4")
for (i in seq_along(list_of_graphs)) {
   old.i <- list_of_graphs[i]  # This is `i` in your current code
   plot(get(old.i), layout=layout.old, main=titles[i])
}
-------------------------------------------------------------------------------------------------------
ggplot_build render_plot <- ggplot_build(p + ggtitle("Don't want this plot"))
-------------------------------------------------------------------------------------------------------
df$location <- c("North","South","North","West","West")

p2 <- ggplot(df,aes(lev.names,Output,shape=location)) +
  geom_errorbar(aes(ymin=Output-Errors, ymax=Output+Errors), 
                width=0,color="gray40", lty=1, size=0) +
  geom_point(size=3) + 
  theme_bw() + xlab(" ") + ylab("Output") +
  ggtitle(expression("Production")) +
  coord_flip()
print(p2) opts size
-------------------------------------------------------------------------------------------------------
plot(1:10, rnorm(10), ylim=c(0,1), ylim=c(-1,100))
Error in plot.default(1:10, rnorm(10), ylim = c(0, 1), ylim = c(-1, 100)) : 
  formal argument "ylim" matched by multiple actual arguments hist(x, prob = TRUE, main = main2, xlab = xlab2, ylim = c(0, maxy), ...) maxy <- max(max(a$density), 0.3989 * mix.object$lambda/mix.object$sigma) library(mixtools)
wait = faithful$waiting
mixmdl = normalmixEM(wait)
plot.new()
plot.window(xlim=c(25,110), ylim=c(0,0.5))
plot(mixmdl, which = 2, nclass=20, add = TRUE)
lines(density(wait), lty = 2, lwd = 2)
box(); axis(1); axis(2); title(xlab="Data", ylab="Density")
-------------------------------------------------------------------------------------------------------
a2.25 ggplot(a2.25[2:24,], aes(x=V1, y=V2)) + geom_point() +
  theme(plot.margin = unit(c(0,0,0,0), "lines"),
        plot.background = element_blank(),
        axis.title.y = element_blank(),
        axis.title.x = element_blank()) +
  ggtitle("a2_25")
-------------------------------------------------------------------------------------------------------
plots <- dlply(df, .(Method), function (x1) {
    ggplot(subset(melt(cor(x1[sapply(x1,is.numeric)]))[lower.tri(c),],Var1 != Var2),
           aes(x=Var1,y=Var2,fill=value)) + geom_tile(aes(fill = value),colour = "white") +
        geom_text(aes(label = sprintf("%1.2f",value)), vjust = 1) + 
        theme_bw() +
        scale_fill_gradient2(name="R^2",midpoint=0.7,low = "white", high = "red") + xlab(NULL)+ylab(NULL) + theme(axis.text.x=element_blank(),axis.text.y=element_blank(), axis.ticks=element_blank(),panel.border=element_blank()) + ggtitle(x1$Method) + theme(plot.title = element_text(lineheight=1,face="bold")) + geom_text(data = subset(melt(cor(x1[sapply(x1,is.numeric)])),Var1==Var2),aes(label=Var1),vjust=3 ) })

#Function to grab legend
g_legend<-function(a.gplot){
    tmp <- ggplot_gtable(ggplot_build(a.gplot))
    leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
    legend <- tmp$grobs[[leg]]
    legend
}

legend <- g_legend(plots$WIG_Method)


grid.arrange(legend,plots$Single_ROI+theme(legend.position='none'), plots$Simple_2_ROI+theme(legend.position='none'),plots$WIG_Method+theme(legend.position='none'), plots$WIG_drawn_bg+theme(legend.position='none'), ncol=5, nrow=1, widths=c(1/17,4/17,4/17,4/17,4/17))
-------------------------------------------------------------------------------------------------------
plot.spei plot.spei <- 
function (x, ...) 
{
    ## label <- ifelse(as.character(x$call)[1] == "spei", "SPEI", 
    ##     "SPI")

    ser <- ts(as.matrix(x$fitted[-c(1:x$scale), ]), end = end(x$fitted), 
        frequency = frequency(x$fitted))
    ser[is.nan(ser - ser)] <- 0
    se <- ifelse(ser == 0, ser, NA)
    tit <- dimnames(x$coefficients)[2][[1]]
    if (start(ser)[2] == 1) {
        ns <- c(start(ser)[1] - 1, 12)
    }
    else {
        ns <- c(start(ser)[1], start(ser)[2] - 1)
    }
    if (end(ser)[2] == 12) {
        ne <- c(end(ser)[1] + 1, 1)
    }
    else {
        ne <- c(end(ser)[1], end(ser)[2] + 1)
    }
    n <- ncol(ser)
    if (is.null(n)) 
        n <- 1
    par(mar = c(4, 4, 2, 1) + 0.1)
    if (n > 1 & n < 5) 
        par(mfrow = c(n, 1))
    if (n > 1 & n >= 5) 
        par(mfrow = c({
            n + 1
        }%/%2, 2))
    for (i in 1:n) {
        datt <- ts(c(0, ser[, i], 0), frequency = frequency(ser), 
            start = ns, end = ne)
        datt.pos <- ifelse(datt > 0, datt, 0)
        datt.neg <- ifelse(datt <= 0, datt, 0)
        plot(datt, type = "n", xlab = "", main = tit[i], ...)
        if (!is.null(x$ref.period)) {
            k <- ts(5, start = x$ref.period[1, ], end = x$ref.period[2, 
                ], frequency = 12)
            k[1] <- k[length(k)] <- -5
            polygon(k, col = "light grey", border = NA, density = 20)
            abline(v = x$ref.period[1, 1] + (x$ref.period[1, 
                2] - 1)/12, col = "grey")
            abline(v = x$ref.period[2, 1] + (x$ref.period[2, 
                2] - 1)/12, col = "grey")
        }
        grid(col = "black")
        polygon(datt.pos, col = "blue", border = NA)
        polygon(datt.neg, col = "red", border = NA)
        lines(datt, col = "dark grey")
        abline(h = 0)
        points(se, pch = 21, col = "white", bg = "black")
    }
} ylab plot(spi1, ylab = "SPI") ts par(mfrow = c(3, 4))
listofmonths <- split(fitted(spi1), cycle(fitted(spi1)))
names(listofmonths) <- month.abb

require(plyr)
l_ply(seq_along(listofmonths), function(x) {
       plot(x = seq_along(listofmonths[[x]]), y = listofmonths[[x]],
            type = "l", xlab = "", ylab = "SPI")
       title(names(listofmonths)[x])
   }) monthplot(fitted(spi1), labels = month.abb, cex.axis = 0.8)
boxplot(fitted(spi1) ~ cycle(fitted(spi1)), names = month.abb, cex.axis = 0.8)
-------------------------------------------------------------------------------------------------------
plot ggplot(data.frame(week=seq(length(gr)), gr), aes(x=week,y=gr*100)) + geom_point() + geom_smooth(method='loess') + coord_cartesian(xlim = c(.95, 10.05)) + scale_x_discrete() + ggtitle('week over week growth rate, from Apr 1') + ylab('growth rate %') df_net <- ddply(df_all, .(date), summarise, gpv=sum(gpv))  # df_all has my daily data.
df_net$week_num <- strftime(df_net$date, "%U") #get the week # to 'group by' in ddply
df_weekly <- ddply(df_net, .(week_num), summarize, gpv=sum(gov))

gr <- diff(df_weekly$gpv)/df_weekly$gpv[-length(df_weekly$gpv)]  #seems correct, but this I don't understand via: http://stackoverflow.com/questions/15356121/how-to-identify-the-virality-growth-rate-in-time-series-data-using-r
plot(gr, type='l', xlab='week #', ylab='growth rate percent', main='Week/Week Growth Rate')
-------------------------------------------------------------------------------------------------------
library(ggplot2)

   set.seed(5872)

   x<-seq(-7.5,7.5,0.1)
   l<-length(x)
   df<-data.frame(P=factor(rep(c("Mean: -1, SD: 0.5","Mean: 0, SD: 1","Mean: 1, SD: 1.5"),
            each=l) ),
   X=(c(x,x,x)), 
   Y=(c(dnorm(x,-1,0.5),dnorm(x,0,1),dnorm(x,1,1.5))))

   Normal<-ggplot(data=df,aes(X,Y,group=P,color=P))+
   geom_path()+
   scale_x_continuous("")+
   scale_y_continuous("f(x)")+
   scale_color_discrete("Parameters")+
   ggtitle("Normal") + 
   theme(plot.title = element_text(size=25,lineheight=.8, face="bold"))

   print(Normal)
-------------------------------------------------------------------------------------------------------
plot.title title text p <- ggplot(mtcars, aes(factor(cyl), mpg))

p + 
  geom_boxplot() + 
  ggtitle("Boxplot") p + 
  geom_boxplot() + 
  ggtitle("Boxplot") +
  theme_grey(base_size = 20) #default is 12
-------------------------------------------------------------------------------------------------------
inDf <- read.table(text="crop     sowing  emergence  flowering   maturity harvesting
                         Spring barley 27/04/2013 12/05/2013 27/06/2013  1/08/2013  5/08/2013
                         Oats 27/04/2013 10/05/2013 29/06/2013  6/08/2013  8/08/2013
                         Maize 25/05/2013  6/06/2013 18/08/2013 10/09/2013 12/09/2013", header=TRUE)

inDf[, "sowing"]     <- as.Date(inDf[, "sowing"], format = '%d/%m/%Y')
inDf[, "emergence"]  <- as.Date(inDf[, "emergence"], format = '%d/%m/%Y')
inDf[, "flowering"]  <- as.Date(inDf[, "flowering"], format = '%d/%m/%Y')
inDf[, "maturity"]   <- as.Date(inDf[, "maturity"], format = '%d/%m/%Y')
inDf[, "harvesting"] <- as.Date(inDf[, "harvesting"], format = '%d/%m/%Y')

ggplot(inDf, aes(x=crop)) +
geom_linerange(aes(ymin=sowing, ymax=emergence), color="green", size=5) +
geom_linerange(aes(ymin=emergence, ymax=flowering), color="green3", size=5) +
geom_linerange(aes(ymin=flowering, ymax=maturity), color="yellow", size=5) +
geom_linerange(aes(ymin=maturity, ymax=harvesting), color="red", size=5) +
coord_flip() +  scale_y_date(lim = c(as.Date("2012-08-15"), as.Date("2013-09-01")),breaks=date_breaks(width = "1 month"), labels = date_format("%b"))+
ggtitle('Crop Calendar')+ xlab("")+ylab("")
-------------------------------------------------------------------------------------------------------
matplot df 1997 1993 df[df==0] <- NA
matplot(as.numeric(names(df)),t(as.matrix(df)), type="o",pch=19,lty=1,ann=FALSE)
title(xlab="Years",ylab="Values") df <- read.table(textConnection("
       1989  1990  1991  1992  1997
    A  -30   -16     0     0     0
    B   12    32     7     0     0
    C    0     0     0     0     0
    D    0     3    -8    -6     6
    E    0     0     0     0    -7
"),header=T,check.names=FALSE)
-------------------------------------------------------------------------------------------------------
cw_trials_f <- ddply(cw_trials_f, .(session_id, difficulty), .fun = function(X) transform(X, movrt = rollmean(X$reaction_time, 50, na.pad=T, align="right"), movacc = rollmean(as.numeric(X$correct)-1, 50, na.pad=T, align="right"))) ggplot(cw_trials_f, aes(x=trial_number, y=movacc, col=difficulty)) + geom_line() + facet_wrap(~session_id) + ggtitle("Stroop Task")
-------------------------------------------------------------------------------------------------------
> print(data.frame(n=2:3, x=1:6))
- n x
1 2 1
2 3 2
3 2 3
4 3 4
5 2 5
6 3 6 > print(expand.grid(x=1:5, n=2:3))
-  x n
1  1 2
2  2 2
3  3 2
4  4 2
5  5 2
6  1 3
7  2 3
8  3 3
9  4 3
10 5 3 lapply(2:3, FUN=function(n) (f(n, x=1:5)))
#[[1]]
#[1] 0.0004981910 0.0006066275 0.0007328627 0.0008786344 0.0010456478
#
#[[2]]
#[1] 0.0007464956 0.0009087272 0.0010974595 0.0013152213 0.0015644676 wrapper <- function(i, x, n, fti){
    # As was provided by OP
    g<-function(x) {do.call(paste("d",i,sep=""),c(list(x=x),fti$estimate))}

    G<-function(x) {do.call(paste("p",i,sep=""),c(list(q=x),fti$estimate))}
    # does the i in fti refer to fit of i:th distribution, i.e. should it be a list where i:th location in ft is i:th distribution estimates?

    f<-function(n,x) {n*g(x)*(1-G(x))^(n-1)}
    # was missing a '-' and a '}'

    h<- function(n) {integrate(function(x) {x*f(n,x)},0,Inf)}

    list(gres = g(x), Gres = G(x), fres = f(n,x), hres = h(n))
}

# Example data
require("fitdistrplus")
data(groundbeef)
serving <- groundbeef$serving

# Gumbel distribution
d1 <- function(x, a, b) 1/b*exp((a-x)/b)*exp(-exp((a-x)/b))
p1 <- function(q, a, b) exp(-exp((a-q)/b))
q1 <- function(p, a, b) a-b*log(-log(p))

fti1 <- fitdist(serving, "1", start=list(a=10, b=10))
#> fti1$estimate
#       a        b 
#56.95893 29.07871

# Normal distribution

# dnorm, pnorm and qnorm are available in the default environment
d2 <- dnorm
p2 <- pnorm
q2 <- qnorm

fti2 <- fitdist(serving, "2", start=list(mean=0, sd=1))
#> fti2$estimate
#    mean       sd 
#73.67743 35.92581

# Sequence of x-values
xs <- seq(-100, 100, by=1)

print((resultdist1n2 <- wrapper(i=1, x=xs, n=2, fti=fti1))$hres)
print((resultdist1n3 <- wrapper(i=1, x=xs, n=3, fti=fti1))$hres)
print((resultdist2n2 <- wrapper(i=2, x=xs, n=2, fti=fti2))$hres)
print((resultdist2n3 <- wrapper(i=2, x=xs, n=3, fti=fti2))$hres)

plot(xs, resultdist1n2$fres, col=1, type="l", ylim=c(0,0.025), xlab="x", ylab="f(n, x)")
points(xs, resultdist1n3$fres, col=2, type="l")
points(xs, resultdist2n2$fres, col=3, type="l")
points(xs, resultdist2n3$fres, col=4, type="l")
legend("topleft", legend=c("Gamma (i=1) n=2", "Gamma (i=1) n=3", "Normal (i=2) n=2", "Normal (i=2) n=3"), col=1:4, lty=1) h(n=2) for distribution i=1:
53.59385 with absolute error < 0.00022
h(n=3) for distribution i=1:
45.23146 with absolute error < 4.5e-05
h(n=2) for distribution i=2:
53.93748 with absolute error < 1.1e-05
h(n=3) for distribution i=2:
44.06331 with absolute error < 2e-05 ns <- 0:256
res1 <- lapply(ns, FUN=function(nseq) wrapper(i=1, x=xs, n=nseq, fti=fti1))
par(mfrow=c(1,2))
plot.new()
plot.window(xlim=c(-100,100), ylim=c(0, 0.05))
box(); axis(1); axis(2); title(xlab="x", ylab="f(n,x)", main="f(n,x) for gamma (i=1), n=0:256")
for(i in 1:length(ns)) points(xs, res1[[i]]$fres, col=rainbow(257)[i], type="l")
# perform similarly for the other distributions by calling with i=2, fti=fti2
# h as a function of n for dist i=1
plot(ns, unlist(lapply(res1, FUN=function(x) x$hres$value)), col=rainbow(257), xlab="n", ylab="h(n)", main="h(n) for gamma (i=1), n=0:256")
-------------------------------------------------------------------------------------------------------
for(i in mars){
for(j in 1:5){
    tryCatch({
        negRets <- -table1.matrix[,j]
        tauSigma <- gpd(negRets,threshold=i)
        tau <- tauSigma$par.ests[1]
        sigma <- tauSigma$par.ests[2]
        #cat("For ", reitPort[j], "portfolio and MAR=", i, "the parameter estimats are:", "\n")
        #cat("Tau= ", tau, "Sigma= ", sigma, "\n")
        exceedence.vector <- sort(subset(negRets, negRets > i))
        returns.sorted <- sort(negRets)
        pdf(paste("C:\\Users\\John Broussard\\Dropbox\\evtHandbookProject\\figuresTables\\mar_",i,"_",reitPort[j],".pdf",sep=""))
            plot(returns.sorted, dgpd(returns.sorted, xi = tau, beta = sigma), type ="l", col="blue", ylim=c(0,90))
            title(main=cat("Tau= ", tau, " Sigma= ", sigma), ylab=" ")
        dev.off()
        #print(j)
        #print(i)
    }, error = function(e) {

    })
}
}
-------------------------------------------------------------------------------------------------------
histo<-hist(yourvariable)
barplot(histo$counts/n,col="white",space=0)->bp   # n=length(yourvariable)
axis(1,at=c(bp),labels=histo$mids)
title(ylab="Relative Frequency",xlab="Your Variable Name")
-------------------------------------------------------------------------------------------------------
new_dat <- melt(list(trial.df,trial.df),id.vars = 1:2)
new_dat$trial.id <- factor(new_dat$trial.id)
new_dat$surv <- factor(new_dat$surv)
ggplot() +
    facet_wrap(~L1,nrow = 2,scales = "free_y") + 
    geom_bar(data = subset(new_dat,L1 == 1),
             aes(x = trial.id , fill = surv),
             stat = "bin", 
             position = "fill") +
    geom_bar(data = subset(new_dat,L1 == 2),
             aes(x = trial.id , fill = surv),
             stat = "bin") +
    ggtitle("Surival by Trial\n") +
    labs(x = "\nTrial", y = "Patients (%)\n") +
    scale_fill_discrete(name = "Survival")
-------------------------------------------------------------------------------------------------------
"color=.." aes() geom_linerange() scale_color_identity() guide="legend" labels= minor_breaks=NULL scale_y_date() ggplot(inDf, aes(x=crop)) +
  geom_linerange(aes(ymin=sowing, ymax=emergence, color="green"), size=5) +
  geom_linerange(aes(ymin=emergence, ymax=flowering, color="green3"), size=5) +
  geom_linerange(aes(ymin=flowering, ymax=maturity, color="yellow"), size=5) +
  geom_linerange(aes(ymin=maturity, ymax=harvesting, color="red"), size=5) +
  coord_flip() +  
  scale_y_date(lim = c(as.Date("2012-08-15"), as.Date("2013-09-01")),
               breaks=date_breaks(width = "1 month"), labels = date_format("%b"),
               minor_breaks=NULL)+
  ggtitle('Crop Calendar')+ xlab("")+ylab("")+
  scale_color_identity("",guide="legend",
                       labels=c("emergence","flowering","maturity","harvesting"))
-------------------------------------------------------------------------------------------------------
library(scales)
ggplot(f1, aes(x=V,y=EFAnoxE3, colour=NormaGEuro3))+
geom_point(size=4)+
  stat_function(fun = m5noxe3, size=1, colour="green")+
  stat_function(fun = c4noxe3, size=1, colour="green")+
  stat_function(fun = unoxe3, size=1, colour="red")+
scale_colour_manual(values = c("green", "blue", "green","red"),
                      name = "",
                      labels = c("MODEM 5 Euro 3","HBEFA 3 Euro 3", "COPERT 4 Euro 3","UNTEC Euro 3"))+
theme(plot.title = element_text(lineheight=.8, face="bold"),
axis.text.x=element_text(size=12, face="bold"),
axis.text.y=element_text(size=12, face="bold"),
legend.position=c(1,0.82),legend.justification=c(1,1),
legend.background = element_rect(fill=alpha("grey", 0.2)))+
ggtitle("Factores de Emisión NOx Vehiculos \n Particulares Gasolineros (g/km)")+
ylab("(g/km)") +
xlab("Velocidad Promedio (km/h)")+
annotate("rect", xmin = 25, xmax = 35, ymin = 0, ymax = 0.6, alpha = .2)
-------------------------------------------------------------------------------------------------------
ylab(NULL) grid unit() library(grid)
g.mid<-ggplot(DATA,aes(x=1,y=state))+geom_text(aes(label=state))+
  geom_segment(aes(x=0.94,xend=0.96,yend=state))+
  geom_segment(aes(x=1.04,xend=1.065,yend=state))+
  ggtitle("")+
  ylab(NULL)+
  scale_x_continuous(expand=c(0,0),limits=c(0.94,1.065))+
  theme(axis.title=element_blank(),
        panel.grid=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        panel.background=element_blank(),
        axis.text.x=element_text(color=NA),
        axis.ticks.x=element_line(color=NA),
        plot.margin = unit(c(1,-1,1,-1), "mm")) g1 <- ggplot(data = DATA, aes(x = state, y = sales_staff)) +
  geom_bar(stat = "identity") + ggtitle("Number of sales staff") +
  theme(axis.title.x = element_blank(), 
        axis.title.y = element_blank(), 
        axis.text.y = element_blank(), 
        axis.ticks.y = element_blank(), 
        plot.margin = unit(c(1,-1,1,0), "mm")) +
  scale_y_reverse() + coord_flip()

g2 <- ggplot(data = DATA, aes(x = state, y = sales)) +xlab(NULL)+
  geom_bar(stat = "identity") + ggtitle("Sales (x $1000)") +
  theme(axis.title.x = element_blank(), axis.title.y = element_blank(), 
        axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        plot.margin = unit(c(1,0,1,-1), "mm")) +
  coord_flip() gridExtra grid.arrange() library(gridExtra)
gg1 <- ggplot_gtable(ggplot_build(g1))
gg2 <- ggplot_gtable(ggplot_build(g2))
gg.mid <- ggplot_gtable(ggplot_build(g.mid))

grid.arrange(gg1,gg.mid,gg2,ncol=3,widths=c(4/9,1/9,4/9))
-------------------------------------------------------------------------------------------------------
z_axis new$Count <- factor(new$z_axis) new drop=FALSE scale_color_discrete ggplot(data=new[new$Count!="2", ], aes(x_axis,y_axis, colour=Count), size=z_axis) +                                 
  geom_point(size=5) +
  ggtitle("PB1-PB1") +
  scale_colour_discrete(name="Counts", drop=FALSE) +
  theme_bw()
-------------------------------------------------------------------------------------------------------
rcorr Hmisc jitter mydf=df
mydf[,2:5] = sapply(mydf[,2:5],jitter,amount=20)
mydf=mydf[c(1:5,20:24,39:43,58:62),] library(Hmisc)

# calculate r
c = rcorr(as.matrix(mydf[sapply(mydf,is.numeric)]))$r

# calculate p values
p = rcorr(as.matrix(mydf[sapply(mydf,is.numeric)]))$P plots <- dlply(mydf, .(Method), function (x1) {
  ggplot(data.frame(subset(melt(rcorr(as.matrix(x1[sapply(x1,is.numeric)]))$r)[lower.tri(c),],Var1 != Var2),
                    pvalue=subset(melt(rcorr(as.matrix(x1[sapply(x1,is.numeric)]))$P)[lower.tri(p),],Var1 != Var2)$value),
         aes(x=Var1,y=Var2,fill=value)) +
    geom_tile(aes(fill = value),colour = "white") +
    geom_text(aes(label = sprintf("%1.2f",value)), vjust = 0) + 
    geom_text(aes(label = sprintf("%1.2f",pvalue)), vjust = 1) + 
    theme_bw() +
    scale_fill_gradient2(name="R^2",midpoint=0.25,low = "blue", high = "red") + 
    xlab(NULL) + 
    ylab(NULL) + 
    theme(axis.text.x=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks=element_blank(),
          panel.border=element_blank()) + 
    ggtitle(x1$Method) + theme(plot.title = element_text(lineheight=1,face="bold")) + 
    geom_text(data = subset(melt(rcorr(as.matrix(x1[sapply(x1,is.numeric)]))$r),Var1==Var2),
              aes(label=Var1),vjust=1 ) 
}) grid.arrange(plots$Single_ROI + theme(legend.position='none'), 
             plots$Simple_2_ROI + theme(legend.position='none'),
             plots$WIG_Method + theme(legend.position='none'), 
             plots$WIG_drawn_bg + theme(legend.position='none'),
             ncol=2, 
             nrow=2) library(Hmisc)
library(car)

mydf=df
set.seed(12345)
mydf[,2:5] = sapply(mydf[,2:5],jitter,amount=15)
mydf=mydf[c(1:10,20:29,39:48,58:67),] # calculate r
c = rcorr(as.matrix(mydf[sapply(mydf,is.numeric)]))$r

# calculate p values
p = rcorr(as.matrix(mydf[sapply(mydf,is.numeric)]))$P

plots <- dlply(mydf, .(Method), function (x1) {
  ggplot(data.frame(subset(melt(rcorr(as.matrix(x1[sapply(x1,is.numeric)]))$r)[lower.tri(c),],Var1 != Var2),
                    pvalue=Recode(subset(melt(rcorr(as.matrix(x1[sapply(x1,is.numeric)]))$P)[lower.tri(p),],Var1 != Var2)$value , "lo:0.01 = '***'; 0.01:0.05 = '*'; else = ' ';")),
         aes(x=Var1,y=Var2,fill=value)) +
    geom_tile(aes(fill = value),colour = "white") +
    geom_text(aes(label = sprintf("%1.2f",value)), vjust = 0) + 
    geom_text(aes(label = pvalue), vjust = 1) +
    theme_bw() +
    scale_fill_gradient2(name="R^2",midpoint=0.25,low = "blue", high = "red") + 
    xlab(NULL) + 
    ylab(NULL) + 
    theme(axis.text.x=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks=element_blank(),
          panel.border=element_blank()) + 
    ggtitle(x1$Method) + theme(plot.title = element_text(lineheight=1,face="bold")) + 
    geom_text(data = subset(melt(rcorr(as.matrix(x1[sapply(x1,is.numeric)]))$r),Var1==Var2),
              aes(label=Var1),vjust=1 ) 
}) grid.arrange(plots$Single_ROI + theme(legend.position='none'), 
             plots$Simple_2_ROI + theme(legend.position='none'),
             plots$WIG_Method + theme(legend.position='none'), 
             plots$WIG_drawn_bg + theme(legend.position='none'),
             ncol=2, 
             nrow=2)
-------------------------------------------------------------------------------------------------------
?tkrgl::spinControl install.packages("tkrgl")  # also by Duncan Murdoch
library("tkrgl")
plot3d(wt, disp, mpg, col="red", size=5)
win1 <- rgl.cur()
rgl.bringtotop(TRUE)
#Warning message:
#In rgl.bringtotop(TRUE) : stay not implemented
 base <- tktoplevel()
 tkwm.title(base, "Spinners")
# <Tcl>  
 con1 <- spinControl(base, dev=c(win1))
 tkpack(con1)
#<Tcl>  
 base <- tktoplevel()
 tkwm.title(base, "Spinners")
 con1 <- spinControl(base, dev=c(win1))
 tkpack(con1)
-------------------------------------------------------------------------------------------------------
library(gtable)

gl <- lapply(1:9, function(ii) grobTree(textGrob(ii), rectGrob()))
# gl <- lapply(1:9, function(ii) ggplotGrob(qplot(1,1) + ggtitle(ii)))

gt <- gtable(widths=unit(rep(1,5), "null"),
             heights=unit(rep(1,3), "null"))

gtable_add_grobs <- gtable_add_grob # alias

gt <- gtable_add_grobs(gt, gl, 
                       l=c(1,4,5,4,5,1,2,3,4),
                       r=c(3,4,5,4,5,1,2,3,5),
                       t=c(1,1,1,2,2,3,3,3,3),
                       b=c(2,1,1,2,2,3,3,3,3))
grid.newpage()
grid.draw(gt)
-------------------------------------------------------------------------------------------------------
scale_x_discrete(labels=national.fare.long$Year_Quarter_lab) library(reshape)
library(ggplot2)
national.fare <- read.csv("http://www.rita.dot.gov/bts/airfares/national/csv", 
              header = TRUE)[ , 1:4]

names(national.fare) <- c("Year", "Quarter", "US_Average_Current", "US_Average_Inflation-Adjusted")

# Convert Year and Quarter as characters
national.fare$Year <- as.character(national.fare$Year)
national.fare$Quarter <- as.character(national.fare$Quarter)

# Convert to Long-version
national.fare.long <- melt(national.fare, measure.vars = c("US_Average_Current", "US_Average_Inflation-Adjusted"))

# Combine Year and Quarter for Graph
national.fare.long$Year_Quarter <- as.character(paste(national.fare.long$Year, "Q", national.fare.long$Quarter, sep = ""))
# Create a vector of labels with every fourth label
skip <- 0:(dim(national.fare.long)[1]-1)%%4
national.fare.long$Year_Quarter_lab <- ifelse(skip==0,as.character(paste(national.fare.long$Year, "\nQ", national.fare.long$Quarter, sep = "")),"")


# Chart: National Average Domestic Fare Current and Inflation-Adjusted

p <- ggplot(national.fare.long, aes(x = Year_Quarter, y = value, group = variable))

p + geom_line(aes(color = variable), size = 1.5) +
  scale_color_manual(values = c("navy", "red")) +
  scale_x_discrete(labels=national.fare.long$Year_Quarter_lab) +
  ylim(250, 500) +
  ggtitle("National Average Domestic Fare 1995 - 2013") +
  xlab("Year-Quarter") +
  ylab("Average Domestic Fare") +
  theme(legend.position = "top", 
        legend.key = element_rect(fill = "transparent", color = NA),
        legend.title = element_blank(),
        axis.title = element_text(family = "sans", color = "grey50", face = "bold"),
        axis.line.x = element_line(color = "grey"),
        axis.text.y = element_text(family = "sans"),
        axis.text.x = element_text(family = "sans", face = "plain", hjust = .5, vjust = 1, angle = 0),
        axis.ticks.x = element_line(),
        panel.grid.major.y = element_line(color = "grey", size = 0.5, linetype = "dashed"),
        panel.background = element_rect(fill = "transparent", color = NA),
        plot.background = element_rect(fill = "transparent", color = NA),
        plot.title = element_text(family = "sans", size = 18, face = "bold"))
-------------------------------------------------------------------------------------------------------
library(gsubfn)
national.fare.long$Year_Q_Date <- gsubfn("Q.*", 
    list('Q1' = '-01-01', 'Q2' = '-04-01', 'Q3' = '-06-01', 'Q4' = '-10-01'), 
    national.fare.long$Year_Quarter)
national.fare.long$Year_Q_Date <- as.Date(national.fare.long$Year_Q_Date)
firstObs <- national.fare.long$Year_Q_Date[1]
lastObs <- national.fare.long$Year_Q_Date[length(national.fare.long$Year_Q_Date)] dateticks <- seq(firstObs, lastObs, by="8 month") library(scales)

p <- ggplot(national.fare.long, aes(x = Year_Q_Date, y = value, group = variable))

p + geom_line(aes(color = variable), size = 1.5, ) +
  scale_color_manual(values = c("navy", "red")) +
  ylim(250, 500) +
  ggtitle("National Average Domestic Fare 2001 - 2012") +
  xlab("Year-Quater") +
  ylab("Average Domestic Fare") +
  scale_x_date(breaks=dateticks, labels=date_format("%Y %b")) +
  theme(legend.position = "top", 
      legend.key = element_rect(fill = "transparent", color = NA),
      legend.title = element_blank(),
      axis.title = element_text(family = "sans", color = "grey50", face = "bold"),
      axis.line.x = element_line(color = "grey"),
      axis.text.y = element_text(family = "sans"),
      axis.text.x = element_text(family = "sans", face = "plain", hjust = 0, vjust = 1, angle = 285),
      axis.ticks.x = element_line(),
      panel.grid.major.y = element_line(color = "grey", size = 0.5, linetype = "dashed"),
      panel.background = element_rect(fill = "transparent", color = NA),
      plot.background = element_rect(fill = "transparent", color = NA),
      plot.title = element_text(family = "sans", size = 18, face = "bold"))
-------------------------------------------------------------------------------------------------------
ggplot() facets <- c("CenKal_ShWoodl", "HlShl_ShDens", "NKal_ShWoodl", "ThShl_ShDens")
an.trends.sub <- ggplot(tndvilong.anomalies[tndvilong.anomalies$VEG %in% facets,])+
  geom_smooth(method="lm" aes(x=year, y=NDVIan, colour=TenureZone,
                                                     group=TenureZone))+
  scale_color_manual(values=miscol) + 
  ggtitle("anomalies' trends") +
  facet_wrap(~VEG,ncol=2)
-------------------------------------------------------------------------------------------------------
library(ggplot2)

f <- read.table("I:/ggplot.txt",header=T)
f <- f[order(f$Num),]
f$Num <- as.factor(f$Num)
tp_code <-unique(f$Var1[order(f$Num)])
for(i in 1:length(unique(f$pltype))){
f$Pct[f$pltype==unique(f$pltype)[i]] <- f$Freq[f$pltype==unique(f$pltype)[i]]*100/sum(f$Freq[f$pltype==unique(f$pltype)[i]])
f$cumPct[f$pltype==unique(f$pltype)[i]] <- cumsum(f$Pct[f$pltype==unique(f$pltype)[i]])
}

    #Ordered characters by numbers and plotted them
    p1 <- ggplot(f,aes(x=pltype,y=Pct,fill=Num))+
      geom_bar(stat="identity")
    p1+scale_fill_brewer(palette="Pastel1",label=tp_code)+
      theme(axis.text.x = element_text(angle = 30, hjust = 1, vjust=1)) + 
      xlab("Question")+ylab("Percentage")+geom_text(aes(x=pltype,y=cumPct,label=Freq,vjust=1))+
      ggtitle(names(df)[exp]) vjust=1
-------------------------------------------------------------------------------------------------------
axis() bp <- barplot(...) oldpar <-par(mar=c(7,5.1,4.1,2.1))

bp <- barplot(a,
        col=c("blue","red","purple"),
        ylab="Frequency of Interpretation",
        xlab="",
        main="Frequency of BrP and AmE Interpretations \n of NPs in Neutral Environments",
        axisnames=FALSE
       ) bp line=... axis() avgpts <- tapply(bp,rep(1:3,each=2),mean)
grps <- c("Bare NP","Singular-Marked NP","Plural-Marked NP")
subgrps <- c("BrP","AmE")
axis(1,at=bp,labels=rep(subgrps,3), cex.axis=0.7)
axis(1,at=avgpts,labels=grps, cex.axis=0.7,line=1.5,lwd=0)

title(xlab="Form of NP and Native Language",line=4.5)
-------------------------------------------------------------------------------------------------------
textGrob gtable_arrange <- function(..., grobs=list(), as.table=TRUE,
                           top = NULL, bottom = NULL, 
                           left = NULL, right = NULL, draw=TRUE){
  require(gtable)
  # alias
  gtable_add_grobs <- gtable_add_grob

  dots <- list(...)
  params <- c("nrow", "ncol", "widths", "heights",
              "respect", "just", "z") # TODO currently ignored

  layout.call <- intersect(names(dots), params)
  params.layout <- dots[layout.call]

  if(is.null(names(dots)))
    not.grobnames <- FALSE else
      not.grobnames <- names(dots) %in% layout.call

  if(!length(grobs))
  grobs <- dots[! not.grobnames ]

  ## figure out the layout
  n <- length(grobs)
  nm <- n2mfrow(n)

  if(is.null(params.layout$nrow) & is.null(params.layout$ncol)) 
  {
    params.layout$nrow = nm[1]
    params.layout$ncol = nm[2]
  }
  if(is.null(params.layout$nrow))
    params.layout$nrow = ceiling(n/params.layout$ncol)
  if(is.null(params.layout$ncol))
    params.layout$ncol = ceiling(n/params.layout$nrow)

  if(is.null(params.layout$widths))
    params.layout$widths <- unit(rep(1, params.layout$ncol), "null")
  if(is.null(params.layout$heights))
    params.layout$heights <- unit(rep(1,params.layout$nrow), "null")

  positions <- expand.grid(row = seq_len(params.layout$nrow), 
                           col = seq_len(params.layout$ncol))
  if(as.table) # fill table by rows
    positions <- positions[order(positions$row),]

  positions <- positions[seq_along(grobs), ] # n might be < ncol*nrow

  ## build the gtable, similar steps to gtable_matrix

  gt <- gtable(name="table")
  gt <- gtable_add_cols(gt, params.layout$widths)
  gt <- gtable_add_rows(gt, params.layout$heights)
  gt <- gtable_add_grobs(gt, grobs, t = positions$row, 
                            l = positions$col)

  ## titles given as strings are converted to text grobs
  if (is.character(top)) 
    top <- textGrob(top)
  if (is.character(bottom)) 
    bottom <- textGrob(bottom)
  if (is.character(right)) 
    right <- textGrob(right, rot = -90)
  if (is.character(left)) 
    left <- textGrob(left, rot = 90)

  if(!is.null(top)){
    gt <- gtable_add_rows(gt, heights=grobHeight(top), 0)
    gt <- gtable_add_grobs(gt, top, t=1, l=1, r=ncol(gt))
  }
  if(!is.null(bottom)){
    gt <- gtable_add_rows(gt, heights=grobHeight(bottom), -1)
    gt <- gtable_add_grobs(gt, bottom, t=nrow(gt), l=1, r=ncol(gt))
  }
  if(!is.null(left)){
    gt <- gtable_add_cols(gt, widths=grobWidth(left), 0)
    gt <- gtable_add_grobs(gt, left, t=1, b=nrow(gt), l=1, r=1)
  }
  if(!is.null(right)){
    gt <- gtable_add_cols(gt, widths=grobWidth(right), -1)
    gt <- gtable_add_grobs(gt, right, t=1, b=nrow(gt), l=ncol(gt), r=ncol(gt))
  }

  if(draw){
   grid.newpage()
   grid.draw(gt)
  }
  gt # load needed libraries
library(ggplot2)

# Set loop counter and create list to store objects
imax=37
plist <- list()
p <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_line() 

for(i in 1:imax){
  plist[[i]] <- p + ggtitle(i)
}

# build list of grobs
grob.list <- lapply(plist, ggplotGrob)

# prepare titles
title.main <- textGrob("Main title")
title.sub <- textGrob("Subtitle")

# then arrange as required
g <- gtable_arrange(ncol=6, grobs=grob.list, 
                    top=title.main, bottom=title.sub, draw=FALSE)
ann <- grobTree(rectGrob(), textGrob("Annotation box here"))
g <- gtable_add_grobs(g, ann, t=nrow(g)-1, l=2, r=ncol(g))

# save it all together
png(file = "out.png",width=1000, height=710, units = "px")
grid.draw(g)
dev.off()
-------------------------------------------------------------------------------------------------------
# Make a fake dataset since it is inconvenient to copy & paste the data you show
set.seed(13)
False <- rnorm(10, mean=50, sd=10)
True <- rnorm(10, mean=50, sd=10)
MotifId <- letters[1:10]
Dataset <- data.frame(False, True, MotifId) Dataset$stderr <- 7 # This will recycle to the number of rows of Dataset arrow plot(Dataset$True,Dataset$False, 
     xlim=c(0,100), ylim=c(0,100), 
     main="Average % of disorder", 
     xlab="True", ylab="False", 
     pch=19,col= "blue")
text(Dataset$True,Dataset$False, 
     labels=Dataset$MotifId, 
     cex= 0.7, pos=3)
abline(0,1)
arrows(x0=Dataset$True, y0=Dataset$False - Dataset$stderr, 
       x1=Dataset$True, y1=Dataset$False + Dataset$stderr, 
       angle=90, code=3, length=0.05) ggplot2 require(ggplot2)
# Build the plot from layers 
p <- ggplot(Dataset, aes(x=True, y=False, label=MotifId)) + 
       geom_point() + 
       geom_text(, vjust=1, hjust=1) +
       geom_errorbar(aes(ymin=False-stderr, ymax=False+stderr), width=1) +
       geom_abline(slope=1, intercept=0) +
       xlim(c(0, 100)) +
       ylim(c(0, 100)) +
       ggtitle("Average % of disorder") +
       theme_bw()
print(p)
-------------------------------------------------------------------------------------------------------
ahat a title(substitute(hat(a) == ahat, list(ahat = ahat))) ‘==’ ‘=’ bquote() title(bquote(hat(a) = .(ahat))) ‘.()’ demo(plotmath) title(substitute(R^2 = rsq, list(rsq = format(rsquarelm2, digits = 2)))) title(bquote(R^2 == .(format(rsquarelm2, digits = 2)))) format round
-------------------------------------------------------------------------------------------------------
Método Estimativa0 stat_summary Estimativa0 geom_boxplot stat_summary aes(fill=factor(Estimativa0)) fill=factor(Estimativa0) aes(Método, NM.Intra1, fill=factor(Estimativa0)) p <- ggplot(data, aes(Método, NM.Intra1, fill=factor(Estimativa0)))
p <- p + geom_boxplot() + ylab('Vício') + xlab('Método') + scale_fill_discrete("Estatística") + ggtitle('Gráfico maluco da Greice') + geom_hline(yintercept=0)
p + stat_summary(fun.y=mean, colour="red", geom="point", position=position_dodge(width=0.75), shape=2)
-------------------------------------------------------------------------------------------------------
ggthemes coord_cartesian scale_colour_discrete ggtitle theme_wsj() theme_wsj() R theme() ggplot2 install.packages("ggthemes")
library(ggthemes)

ph1 = c(5, 6, 7, 8, 9)
ph2 = ph3 = ph1

e1 = c(0.191, 0.154, 0.179, 0.073, 0.009)
e2 = c(0, 0.029, 0.054, 0.055, 0.024)
e3 = c(0.019, 0.027, 0.063, 0.029, 0.039)

set.seed(1)
df1 <- data.frame(e1 = sort(runif(5, 0.05, 0.25)),
                  e2 = sort(runif(5, 0.05, 0.25)),
                  e3 = sort(runif(5, 0.05, 0.25)),
                  ph1 = sort(runif(1, 5, 9)),
                  ph2 = sort(runif(1, 5, 9)),
                  ph3 = sort(runif(1, 5, 9))
)

df2 <- with(df1,
            as.data.frame(cbind( c(ph1, ph2, ph3),
                                 c(e1, e2, e3),
                                 rep(seq(3), each=5) )
            ))
colnames(df2) <- c("ph", "maltose_in_mg", "team")
df2$team <- as.factor(df2$team)
library(ggplot2)
ggplot(df2, aes(x = ph, y = maltose_in_mg, colour = team)) + 
  geom_line(size = 2) +
  coord_cartesian(xlim = c(5, 9)) + # this is how you limit the axis range displayed, you can do the y, too with ylim = c(0, 1)
  scale_colour_discrete(name = "Team") + 
  theme_wsj() + # find more themes here: https://github.com/jrnold/ggthemes
  ggtitle("pH by Team") +
  ylab("Maltose in Milligrams") +
  xlab("pH") +
  theme(axis.title = element_text(angle = 90, vjust = -0.075),
        axis.text = element_text(size = 20),
        legend.text = element_text(size = 15))
-------------------------------------------------------------------------------------------------------
ggplot(pipeline,aes(x=Longitude,y=Latitude))+
  geom_hex(bins=12)+
  stat_binhex(aes(label=..count..), geom="text", bins=12, colour="white") +
  coord_equal(ratio = 1/1)+
  theme_bw()+
  ggtitle('San Francisco Development Pipeline\nQ2 2013')
-------------------------------------------------------------------------------------------------------
chart_Series mar oma mtext sub title line chart_Series name = NULL ?chart_Series par(oma = c(5, 0, 0, 0))
chart_Series(SPY, name = NULL)

title("S&P Index", cex.main = 2, font.main = 4, col.main = "blue")

mtext(text = "text1\n\text2\ntext3",
      side = 1, line = 9, cex = 0.75, font = 3, col = "red")
-------------------------------------------------------------------------------------------------------
chartSeries cspy <- chart_Series(SPY, name = NULL)
cspy$Env$actions[[4]] <- NULL
cspy cs$Env$name <- name
    text.exp <- c(expression(text(1 - 1/3, 0.5, name, font = 2, 
        col = "#444444", offset = 0, cex = 1.1, pos = 4)), 
                  expression(text(NROW(xdata[xsubset]), 
        0.5, paste(start(xdata[xsubset]), end(xdata[xsubset]), 
            sep = " / "), col = 1, adj = c(0, 0), pos = 2)))
    cs$add(text.exp, env = cs$Env, expr = TRUE) cspy$Env$actions chart_Series(SPY, name = NULL) png("out.png")
 myoma <- par("oma")
 myoma[1] <- 3
 par("oma" =myoma)
 cspy
 title("S&P Index",  cex.main = 2,  font.main= 4, col.main= "blue")
   mtext(text= "text1\ntext2\ntext3", side=1, cex = 0.75, font = 3, col = "red",line=7)
 dev.off()
-------------------------------------------------------------------------------------------------------
grid.arrange facet_grid facet_grid ### no. levels of factor group1 not equal to 'NONE' = 4
sum(!levels(a.df$group1)=="NONE")
### define list to store results
list1 <- vector("list", 8)
### subset to remove "none"
df1 <- a.df[!a.df$group1=="NONE", ]
for (i in 1:4){
### subset per level
    df2 <- df1[df1$group1==unique(df1$group1)[i], ]
### plot and title
    g1 <- ggplot(df2, aes(x=var1)) + 
        geom_density() +
            ggtitle(unique(df1$group1)[i])
        list1[[2*i-1]] <- g1
}
### plots of NONE
df1 <- a.df[a.df$group1=="NONE", ] 
g2 <- ggplot(df1, aes(x=var1)) +
    geom_density() +
    ggtitle("NONE")
list1[[2]] <- list1[[4]] <- list1[[6]] <- list1[[8]] <- g2
### 
library(gridExtra)
do.call(grid.arrange, c(list1, list(nrow=2, ncol=4)))
-------------------------------------------------------------------------------------------------------
plot.xts add plot.xts plot.xtsMODIFIED<-function (x, y = NULL, type = "l", auto.grid = TRUE, major.ticks = "auto", 
    minor.ticks = TRUE, major.format = TRUE, bar.col = "grey", 
    candle.col = "white", ann = TRUE, axes = TRUE, ...) 
{
    series.title <- deparse(substitute(x))
    ep <- axTicksByTime(x, major.ticks, format.labels = major.format)
    otype <- type
    if (is.OHLC(x) && type %in% c("candles", "bars")) {
        x <- x[, has.OHLC(x, TRUE)]
        xycoords <- list(x = .index(x), y = seq(min(x), max(x), 
            length.out = NROW(x)))
        type <- "n"
    }
    else {
        if (NCOL(x) > 1) 
            warning("only the univariate series will be plotted")
        if (is.null(y)) 
            xycoords <- xy.coords(.index(x), x[, 1])
    }
    ###The next three lines are the only modifications i made to the function####
    plot(xycoords$x, xycoords$y, type = "n", axes = FALSE, ann = FALSE) 
    rect(par("usr")[1], par("usr")[3], par("usr")[2], par("usr")[4], col ="white")
    if(type=="l"){lines(xycoords$x, xycoords$y, ...)}

    if (auto.grid) {
        abline(v = xycoords$x[ep], col = "grey", lty = 4)
        grid(NA, NULL)
    }
    if (is.OHLC(x) && otype == "candles") 
        plot.ohlc.candles(x, bar.col = bar.col, candle.col = candle.col, 
            ...)
    dots <- list(...)
    if (axes) {
        if (minor.ticks) 
            axis(1, at = xycoords$x, labels = FALSE, col = "#BBBBBB", 
                ...)
        axis(1, at = xycoords$x[ep], labels = names(ep), las = 1, 
            lwd = 1, mgp = c(3, 2, 0), ...)
        axis(2, ...)
    }
    box()
    if (!"main" %in% names(dots)) 
        title(main = series.title)
    do.call("title", list(...))
    assign(".plot.xts", recordPlot(), .GlobalEnv)
} library(quantmod)
getSymbols('SPY', from='1998-01-01', to='2011-07-31', adjust=T)

GRAPH_BLUE<-rgb(43/255, 71/255,153/255)
GRAPH_BACKGROUND<-rgb(180/255, 226/255, 244/255)

par(bg=GRAPH_BACKGROUND)

plot.xtsMODIFIED(SPY, col=GRAPH_BLUE) Error in axis(1, at = xycoords$x, labels = FALSE, col = "#BBBBBB", ...) : formal argument "col" matched by multiple actual arguments. plot.xts ... col axis plot lines ...
axis(1, at = xycoords$x, labels = FALSE, col = "#BBBBBB", 
            ...)
... ...
axis(1, at = xycoords$x, labels = FALSE, ...)
... plot.xts plot.xtsMODIFIED<-function (x, y = NULL, type = "l", auto.grid = TRUE, major.ticks = "auto", 
                             minor.ticks = TRUE, major.format = TRUE, bar.col = "grey", 
                             candle.col = "white", ann = TRUE, axes = TRUE, 
                             lcol, ...) 
{
...
if(type=="l"){lines(xycoords$x, xycoords$y, lcol, ...)}
...
} plot.xtsMODIFIED(SPY, lcol=GRAPH_BLUE)
-------------------------------------------------------------------------------------------------------
library(akima)

# interpolation
fld <- with(df, interp(x = Lon, y = Lat, z = Rain))

filled.contour(x = fld$x,
               y = fld$y,
               z = fld$z,
               color.palette =
                 colorRampPalette(c("white", "blue")),
               xlab = "Longitude",
               ylab = "Latitude",
               main = "Rwandan rainfall",
               key.title = title(main = "Rain (mm)", cex.main = 1)) library(ggplot)
library(reshape2)

# prepare data in long format
df <- melt(fld$z, na.rm = TRUE)
names(df) <- c("x", "y", "Rain")
df$Lon <- fld$x[df$x]
df$Lat <- fld$y[df$y]

ggplot(data = df, aes(x = Lon, y = Lat, z = Rain)) +
  geom_tile(aes(fill = Rain)) +
  stat_contour() +
  ggtitle("Rwandan rainfall") +
  xlab("Longitude") +
  ylab("Latitude") +
  scale_fill_continuous(name = "Rain (mm)",
                        low = "white", high = "blue") +
  theme(plot.title = element_text(size = 25, face = "bold"),
        legend.title = element_text(size = 15),
        axis.text = element_text(size = 15),
        axis.title.x = element_text(size = 20, vjust = -0.5),
        axis.title.y = element_text(size = 20, vjust = 0.2),
        legend.text = element_text(size = 10)) ggmap # grab a map. get_map creates a raster object
library(ggmap)
rwanda1 <- get_map(location = c(lon = 29.75, lat = -2),
                  zoom = 9,
                  maptype = "toner",
                  source = "stamen")
# alternative map
# rwanda2 <- get_map(location = c(lon = 29.75, lat = -2),
#                   zoom = 9,
#                   maptype = "terrain")

# plot the raster map
g1 <- ggmap(rwanda1)
g1

# plot map and rain data
# use coord_map with default mercator projection
g1 + 
  geom_tile(data = df, aes(x = Lon, y = Lat, z = Rain, fill = Rain), alpha = 0.8) +
  stat_contour(data = df, aes(x = Lon, y = Lat, z = Rain)) +
  ggtitle("Rwandan rainfall") +
  xlab("Longitude") +
  ylab("Latitude") +
  scale_fill_continuous(name = "Rain (mm)",
                        low = "white", high = "blue") +
  theme(plot.title = element_text(size = 25, face = "bold"),
        legend.title = element_text(size = 15),
        axis.text = element_text(size = 15),
        axis.title.x = element_text(size = 20, vjust = -0.5),
        axis.title.y = element_text(size = 20, vjust = 0.2),
        legend.text = element_text(size = 10)) +
  coord_map() # Since I don't have your map object, I do like this instead:
# get map data from
# http://biogeo.ucdavis.edu/data/diva/adm/RWA_adm.zip
# unzip files to folder named "rwanda"

# read shapefile with rgdal::readOGR
# just try the first out of three shapefiles, which seemed to work.
# 'dsn' (data source name) is the folder where the shapefile is located
# 'layer' is the name of the shapefile without the .shp extension.

library(rgdal)
rwa <- readOGR(dsn = "rwanda", layer = "RWA_adm0")
class(rwa)
# [1] "SpatialPolygonsDataFrame"

# convert SpatialPolygonsDataFrame object to data.frame
rwa2 <- fortify(rwa)
class(rwa2)
# [1] "data.frame"

# plot map and raindata  
ggplot() + 
  geom_polygon(data = rwa2, aes(x = long, y = lat, group = group),
               colour = "black", size = 0.5, fill = "white") +
  geom_tile(data = df, aes(x = Lon, y = Lat, z = Rain, fill = Rain), alpha = 0.8) +
  stat_contour(data = df, aes(x = Lon, y = Lat, z = Rain)) +
  ggtitle("Rwandan rainfall") +
  xlab("Longitude") +
  ylab("Latitude") +
  scale_fill_continuous(name = "Rain (mm)",
                        low = "white", high = "blue") +
  theme_bw() +
  theme(plot.title = element_text(size = 25, face = "bold"),
        legend.title = element_text(size = 15),
        axis.text = element_text(size = 15),
        axis.title.x = element_text(size = 20, vjust = -0.5),
        axis.title.y = element_text(size = 20, vjust = 0.2),
        legend.text = element_text(size = 10)) +
  coord_map()
-------------------------------------------------------------------------------------------------------
plot ylab='' xlab='' with(dat, plot(NA, xlim=c(min(x1),max(x2)),
                   ylim=c(min(y),max(y)+.15),
                   type="n", xlab='', ylab='')) # <- specify xlab and ylab here
with(dat, rect(x1,y,x2,y+0.1))
title(xlab="chrX Position", ylab="Divergence")
-------------------------------------------------------------------------------------------------------
Error in eval(expr, envir, enclos) : object 'label' not found color=label shape=label ggplot() df_error_all inherit.aes=FALSE geom_segment() ggplot(df_all, mapping=aes(x=t, y=value, color=label, shape=label)) +  
  geom_point() + ggtitle('Test vs. Predicted') + geom_line() + facet_grid(. ~ group) +
  geom_segment(data=df_error_all, aes(x=x,y=y,xend=xend,yend=yend), 
                                size=0.3,inherit.aes=FALSE)
-------------------------------------------------------------------------------------------------------
par(oma=...) ann=FALSE mtext(..., outer=TRUE) layout(matrix(1:2,ncol=1),widths=1,heights=c(2,2),respect=FALSE)
par(mar = rep(0, 4), oma=c(4, 4, 4, 2), las=1)
plot(rnorm(100), type='l', ann=FALSE, xaxt='n')
plot(rnorm(100), type='l', ann=FALSE)

title("Hi", outer=TRUE)
mtext("x-axis", 1, 3, outer=TRUE)
mtext("y-axis", 2, 3, outer=TRUE, las=0) las
-------------------------------------------------------------------------------------------------------
\documentclass{report}

\begin{document}
\title{Sequencing Quality Report}
\author{Deep Sequencing Group - SFB655}
\maketitle


<<knitr_option, cache=FALSE, echo=FALSE, results='hide'>>=
library(knitr)
## set global chunk options
opts_chunk$set(fig.align='center', fig.width=14, fig.heigth=8, out.width="1.2\\textwidth",  par=TRUE)
@


<<R_arguments, cache=FALSE, echo=FALSE, include=FALSE>>=

###### Libraries ######
library(reshape)
library(ggplot2)
theme_set(theme_bw(16)) # removes grey grid and increases letter size. Ideal for presentations
library(RColorBrewer)
library(plyr)
library(scales) # for natural numbers in axis
library(xtable)
library(rattle) # needed to generate a table in knitr?
#######################


###### Function definitions ######
## ggplot theme with extra space between legends and axis
gg.axis.space <- theme(axis.title.y=element_text(vjust=0.2), axis.title.x=element_text(vjust=0.2))

@


\chapter{Preamble}

This an automated quality control report generated for the following fastq files:

<<table_files, echo=FALSE, results="asis">>=
##############################################
## loop over fastQC folder and parse txt files:

## list and read fastqc_data.temp old files
# testing #
# setwd("/projects/seq-work/analysis/martinad/p0196-totalRNA/")
folder <- "./"
filenames <- list.files(path=folder, pattern="fastqc_data.temp", recursive=TRUE) 
fq_fastqc.folders <- unique(dirname(filenames)) # the folders that contain fastQC
fastq.libs <- data.frame(Libraries = gsub(".*/(L.*)\\.fq_fastqc", "\\1", fq_fastqc.folders, perl=T))
xtable(fastq.libs)
@



\chapter{FastQC}

<<loop_n_plots, echo=FALSE, results="asis">>=
## do the plotting
# sapply(fq_fastqc.folders[1:3], ReturnStatsPlotsAndTables)
for (fqc.folder in fq_fastqc.folders[1:2]){
   # for(fqc.folder in fq_fastqc.folders){
   ######################################
   ## for each folder in the vector will
   ## plot stats and 
   ## print tables of fastQC results
#    print(fqc.folder)
   ## which library is being analysed?
   fastq.lib <- data.frame(Libraries = gsub(".*/(L.*)\\.fq_fastqc", "\\1", fqc.folder, perl=T))
   print(xtable(fastq.lib))

   ## Basic statistics - table ##
   stats.path <- paste(fqc.folder, "/", "Basic_Statistics_fastqc_data.temp", sep="")
   basic.stats <- read.table(stats.path, header = TRUE, sep = "\t", stringsAsFactors = FALSE)
#    basic.stats[ ,1:2]
   print(xtable(basic.stats[ ,1:2])) 


   ## Summary of filters - table ##
   stats.path <- paste(fqc.folder, "/", "filters_summary_fastqc_data.temp", sep="")
   summary.filters <-  read.table(stats.path, 
      header = TRUE, sep = "\t", stringsAsFactors = FALSE)
#    summary.filters
   print(xtable(summary.filters))


   ## Per base sequence quality ##
   stats.path <- paste(fqc.folder, "/", "Per_base_sequence_quality_fastqc_data.temp", sep="")
   base.qual <- read.table(stats.path, 
      header = TRUE, sep = "\t", stringsAsFactors = FALSE)


   base.qual$Base <- factor(base.qual$Base, as.character(base.qual$Base)) # re-order the levels by order of appearance in DF

   plot.new()
   base.qual.p <- ggplot(base.qual, aes(x = Base, ymin = X10th.Percentile, lower = Lower.Quartile, middle = Median, upper = Upper.Quartile, ymax = X90th.Percentile, fill = Lower.Quartile)) + geom_boxplot(stat = "identity") + 
      theme(axis.text.x = element_text(angle=30, hjust=1, vjust=1)) + 
      annotate("rect", xmin=-Inf, xmax=Inf, ymin=0, ymax=20, alpha=0.1, fill="red") +
      annotate("rect", xmin=-Inf, xmax=Inf, ymin=20, ymax=28, alpha=0.1, fill="yellow") +
      annotate("rect", xmin=-Inf, xmax=Inf, ymin=28, ymax=Inf, alpha=0.1, fill="green") +
      ggtitle("Per base sequence quality") + ylab("Quality score (Phred score) ") + xlab("Position of base in read")

   print(base.qual.p)

}
@

\end{document}
-------------------------------------------------------------------------------------------------------
image #matrix with the part of your data 10x10 you uploaded
mat <- as.matrix(read.table(text = "0 0 0 0 0 0 0 0 0 0
41 10 2 0 0 0 0 0 0 0
75 36 20 9 4 2 1 0 0 0
91 65 47 31 20 13 8 5 3 2
97 78 64 47 35 25 18 12 8 5
99 88 76 63 50 39 29 22 16 11
99 93 85 74 63 52 42 32 25 19
99 96 91 83 73 64 53 44 35 28
99 98 94 88 81 72 64 54 46 37
99 98 96 92 87 80 72 64 55 47"))

#neccessary step to `image` the expected. read `?image`
t_mat <- t(mat[ncol(mat):1,])

#basic plot
image(t_mat, col = colorRampPalette(c("blue", "red"))(10), axes = F)

#creaty matrix with `NA`s and fill 
#only the values you want to appear yellow.
#here: say 45 to 55
yellows <- matrix(nrow = nrow(t_mat), ncol = ncol(t_mat))
yellows[which(t_mat > 45 & t_mat < 55)] <- t_mat[which(t_mat > 45 & t_mat < 55)] 

#overlay "yellows" to basic plot
image(yellows, col = rgb(1,1,0,1/2), add = T) legend title(main = "imageplot", xlab = "x axis", ylab = "y axis")
legend(x = 0.6, y = 1.15, legend = c("<45", "45-55", ">55"), 
           fill = c("blue", rgb(1,1,0,1/2), "red"), xpd = T, ncol = 3) #I guess you'll need to use `axis(1, at = seq(0,1,0.0101), labels = seq(1, 100, 1))` 
#but I'm not sure
axis(1, at = seq(0,1,0.11), labels = seq(1, 10, 1)) 
axis(2, at = seq(0,1,0.11), labels = seq(1, 10, 1))
-------------------------------------------------------------------------------------------------------
ggplot data.frame geom_bar library(ggplot2)
ggplot(data = Arthritis, aes(x = Treatment, fill = Improved)) +
  geom_bar() +
  scale_fill_manual(values = c("green","yellow", "blue")) +
  ggtitle("Improvements in Treated vs Placebo") +
  xlab("Treatment") +
  ylab("Frequency")
-------------------------------------------------------------------------------------------------------
stringsAsFactors=F str(parkride) scale_x_continous
-------------------------------------------------------------------------------------------------------
lubridate paste date Date require(lubridate)
bktst.plotdata$date2 = as.Date(with(bktst.plotdata, 
                                    paste(year(date), month(date), "01", sep = "-"))) scales require(scales)
ggplot(data=bktst.plotdata, aes(x = date2, y=Percent_error, colour=method)) +
    facet_grid(product~type,scales="free_y") +
    ggtitle("Percent Error - Month-over-Month") +
    xlab("Date") + ylab("Error (%)") +
    geom_line() +
    scale_x_date(labels=date_format(format = "%m-%Y"))
-------------------------------------------------------------------------------------------------------
bar ## second try--facet by county

N = 100
industry = ['a','b','c']
city = ['x','y','z']
ind = np.random.choice(industry, N)
cty = np.random.choice(city, N)
jobs = np.random.randint(low=1,high=250,size=N)
df_city =pd.DataFrame({'industry':ind,'city':cty,'jobs':jobs})

## how many panels do we need?
cols =df_city.city.value_counts().shape[0]
fig, axes = plt.subplots(1, cols, figsize=(8, 8))

for x, city in enumerate(df_city.city.value_counts().index.values):
    data = df_city[(df_city['city'] == city)]
    data = data.groupby(['industry']).jobs.sum()
    print (data)
    print type(data.index)
    left=  [k[0] for k in enumerate(data)]
    right=  [k[1] for k in enumerate(data)]

    axes[x].bar(left,right,label="%s" % (city))
    axes[x].set_xticks(left, minor=False)
    axes[x].set_xticklabels(data.index.values)

    axes[x].legend(loc='best')
    axes[x].grid(True)
    fig.suptitle('Employment By Industry By City', fontsize=20)
-------------------------------------------------------------------------------------------------------
theme(plot.title = element_text(hjust = 0)) theme opts a <- qplot(date, unemploy, data = economics, geom = "line") + ggtitle("A") +
  theme(plot.title = element_text(hjust = 0)) opts a <- qplot(date, unemploy, data = economics, geom = "line") + 
  opts(title = "A", plot.title = element_text(hjust = 0))
-------------------------------------------------------------------------------------------------------
outer=TRUE outer=FALSE outer = FALSE

line = -2
cex = 2
adj  = 0.025

par(mfrow=c(3,1))
plot(rnorm(100),col="red")
title(outer=outer,adj=adj,main="A",cex.main=cex,col="black",font=2,line=line)
plot(rnorm(100),col="blue")
title(outer=outer,adj=adj,main="B",cex.main=cex,col="black",font=2,line=line)
plot(rnorm(100),col="green")
title(outer=outer,adj=adj,main="C",cex.main=cex,col="black",font=2,line=line) mtext title line = 6
cex = 2
las = 2

par(mfrow=c(3,1), oma=c(1,6,1,1))

plot(rnorm(100),col="red")
mtext("A", side=2, line=line, cex=cex, las=las)
plot(rnorm(100),col="blue")
mtext("B", side=2, line=line, cex=cex, las=las)
plot(rnorm(100),col="green")
mtext("C", side=2, line=line, cex=cex, las=las)
-------------------------------------------------------------------------------------------------------
TukeyHSD > plot(TukeyHSD(fm1, "tension"), ylab="")
Error in plot.default(c(xi[, "lwr"], xi[, "upr"]), rep.int(yvals, 2L),  : 
  formal argument "ylab" matched by multiple actual arguments plot.TukeyHSD mtext title(xlab="TESTE", line=4)
-------------------------------------------------------------------------------------------------------
library(ggplot2)

df = read.table(text = 
                  "id      year    transition1 transition2 
1           2000    0   1
1           2001    1   0
1           2002    0   0
1           2003    0   0
2           2000    0   0
2           2002    0   0
2           2003    1   1
3           2000    0   0
3           2001    0   0
3           2002    1   0
3           2003    0   1 ", sep = "", header = TRUE)

# get transition names
trans.names <- names(df[3:4])

# add up the numbers in the data columns
df$total <- apply(df[,c(3:4)], 1, sum)

# for the columns where there is only on transition figure out which type it is
df$total2[which(df$total==1)] <- apply(df[which(df$total==1),c(3:4)], 1, which.max)

#set up the type variable to recieve data
df$type <- ""

# put in the names of the variable where it is one or the other
df$type <- trans.names[df$total2]

# overwrite that data with observation for those ones with no data
df$type[which(df$total==0)] <- "Observation"

# for the ones with both, mark as such
df$type[which(df$total==2)] <- "transition 1 and 2"

# cleanup, remove calculation columns
df <- df[,c("id","year","type")]

# reorder the factors in the 'type' data
df$type <- factor(df$type,levels=c("Observation","transition1", "transition2","transition 1 and 2"))

# make other variables into factors
df$id <- as.factor(df$id)
df$year <- as.factor(df$year)

#plot data
p <- ggplot(df, aes(y=id,x=year,color=type)) +
  geom_point(size=10) +
  scale_color_manual(name="Legend Name Goes Here",values=c("black", "red", "yellow","purple"))+
  theme(legend.position="bottom")+
  ggtitle("Title Goes Here")+
  ylab("y label")+
  xlab("x label")

#show plot
p
-------------------------------------------------------------------------------------------------------
plot.new()
plot.window(xlim=c(0,100),ylim=c(0,100))
lines(c(0,50,100), c(50,0,0))
axis(1)
axis(2)
title(main="Graph")
title(xlab="X")
title(ylab="Y")
box()
-------------------------------------------------------------------------------------------------------
segments Draw line segments between pairs of points. plot.new()
plot.window(xlim=c(0,100),ylim=c(0,100))
#abline(a=50,b=-1)
#abline(a=0,b=0)
segments(0,50,50,0)
segments(50,0,100,0)
axis(1)
axis(2)
title(main="Graph")
title(xlab="X")
title(ylab="Y")
box()
-------------------------------------------------------------------------------------------------------
aes() ggplot(df, aes(x=Date)) +
  geom_line(aes(y=closed_this_year_cum_gv, color="this", linetype="closed")) +
  geom_line(aes(y=opened_this_year_cum_gv, color="this", linetype="opened")) +
  geom_line(aes(y=closed_last_year_cum_gv, color="last", linetype="closed")) +
  geom_line(aes(y=opened_last_year_cum_gv, color="last", linetype="opened")) +
  xlab("Date") +
  ylab("Millions of Dollars") +
  ggtitle("Cummulative Sum of TGV for Opened and Closed Cases - 2013 vs. 2012") +
  scale_colour_manual(name="year", values=c("this"="blue", "last"="red")) +
  scale_linetype_manual(name="type", values=c(2, 1))
-------------------------------------------------------------------------------------------------------
stat_density2d() geom="polygon" alpha n h bins df = read.table(header=TRUE, text=
"                         PC1           PC2 aa
A_akallopisos    0.043272525  0.0151023307  2
A_akindynos     -0.020707141 -0.0158198405  1
A_allardi       -0.020277664 -0.0221016281  2
A_barberi       -0.023165596  0.0389906701  2
A_bicinctus     -0.025354572 -0.0059122384  2
A_chrysogaster   0.012608835 -0.0339330213  2
A_chrysopterus  -0.022402365 -0.0092476009  1
A_clarkii       -0.014474658 -0.0127024469  1
A_ephippium     -0.016859412  0.0320034231  2
A_frenatus      -0.024190876  0.0238499714  2
A_latezonatus   -0.010718845 -0.0289904165  1
A_latifasciatus -0.005645811 -0.0183202248  2
A_mccullochi    -0.031664307 -0.0096059126  2
A_melanopus     -0.026915545  0.0308399009  2
A_nigripes       0.023420045  0.0293801537  2
A_ocellaris      0.052042539  0.0126144250  2
A_omanensis     -0.020387101  0.0010944998  2
A_pacificus      0.042406273 -0.0260308092  2
A_percula        0.034591721  0.0071153133  2
A_perideraion    0.052830132  0.0064495142  2
A_polymnus       0.030902254 -0.0005091421  2
A_rubrocinctus  -0.033318659  0.0474995722  2
A_sandaracinos   0.055839755  0.0093724082  2
A_sebae          0.021767793 -0.0218640814  2
A_tricinctus    -0.016230301 -0.0018526482  1
P_biaculeatus   -0.014466403  0.0024864574  2")


library(ggplot2)

p1 = ggplot(data=df, aes(x=PC1, y=PC2, color=factor(aa), label=rownames(df))) + 
     ggtitle(paste('Site n° ',sep='')) +
     stat_density2d(aes(fill=factor(aa), alpha = ..level..), 
                    geom="polygon", color=NA, n=200, h=0.03, bins=4) + 
     geom_smooth(se=F, method='lm') + 
     geom_point() + 
     scale_color_manual(name='mutation', 
                        values = c("darkorange2","cornflowerblue"), 
                        labels = c("A","S")) + 
     scale_fill_manual( name='mutation', 
                        values = c("darkorange2","cornflowerblue"), 
                        labels = c("A","S")) + 
     geom_text(hjust=0.5, vjust=-1 ,size=3, color="black") + 
     scale_x_continuous(expand=c(0.3, 0)) + # Zooms out so that density polygons
     scale_y_continuous(expand=c(0.3, 0)) + # don't reach edges of plot.
     coord_cartesian(xlim=c(-0.05, 0.07),
                     ylim=c(-0.04, 0.05)) # Zooms back in for the final plot.


p2 = ggplot(data=df, aes(x=PC1, y=PC2, color=factor(aa), label=rownames(df))) + 
     ggtitle(paste('Site n° ',sep='')) +
     stat_density2d(aes(fill=factor(aa)), alpha=0.2,
                    geom="polygon", color=NA, n=200, h=0.045, bins=2) + 
     geom_smooth(se=F, method='lm', size=1) + 
     geom_point(size=2) + 
     scale_color_manual(name='mutation', 
                        values = c("darkorange2","cornflowerblue"), 
                        labels = c("A","S")) + 
     scale_fill_manual( name='mutation', 
                        values = c("darkorange2","cornflowerblue"), 
                        labels = c("A","S")) + 
     geom_text(hjust=0.5, vjust=-1 ,size=3) + 
     scale_x_continuous(expand=c(0.3, 0)) + # Zooms out so that density polygons
     scale_y_continuous(expand=c(0.3, 0)) + # don't reach edges of plot.
     coord_cartesian(xlim=c(-0.05, 0.07),
                     ylim=c(-0.04, 0.05)) # Zooms back in for the final plot.

library(gridExtra)
ggsave("plots.png", plot=arrangeGrob(p1, p2, ncol=1), width=8, height=11, dpi=120)
-------------------------------------------------------------------------------------------------------
setwd("C:/my-csv-files") df <- lapply(1:100, function(i) data.frame(cbind(1:500, matrix(sample(1000), 500, 5)))) lapply(1:length(df), function(i) write.csv(df[[i]],file=paste("df",i,"csv",sep="."))) # create a list of all CSV files in all the folders 
files <- (dir("C:/my-csv-files", recursive=TRUE, full.names=TRUE, pattern="\\.(csv|CSV)$"))
# read in the CSV files and add the filename of each file as a column to
# each dataset so we can trace back dodgy data 
# so, create a function to read the CSV and get filenames
read.tables <- function(file.names, ...) {
  require(plyr)
  ldply(file.names, function(fn) data.frame(Filename=fn, read.csv(fn, ...)),.progress = 'text')
}
# execute function to read in data from each CSV, including file names of file that data comes from
mydata <- read.tables(files, stringsAsFactors = FALSE) X1 X2 X5 require(reshape2)
dat <- melt(mydata, id.vars = c("X1"), measure.vars = c("X2", "X3", "X4", "X5")) require(ggplot2)
ggplot(dat, aes(X1, value)) +
  geom_point(aes(colour = factor(variable))) ?ggsave ggsave(file="myplot.pdf")
ggsave(file="myplot.png") getwd() listcsvs <- lapply(files,function(i) read.csv(i,  stringsAsFactors = FALSE))
names(listcsvs) <- files
require(reshape2)
require(ggplot2)
for (i in 1:length(files)) { 
  tmp <- melt(listcsvs[[i]], id.vars = "X1", measure.vars = c("X2", "X3", "X4", "X5"))
  print(ggplot(tmp,aes(X1, value)) + 
          geom_point(aes(colour = factor(variable))) +
          ggtitle(names(listcsvs[i]))
        )
}
-------------------------------------------------------------------------------------------------------
dat <- read.csv('Rates.csv', stringsAsFactors = FALSE, skip = 19)
colnames(dat)[which(names(dat) %in% c("y", "y.1", "y.2", "y.3"))] <- c("Age", "Revenge", "Homicide", "Hunger")

require(reshape2)
tmp <- melt(dat, id.vars = "x", measure.vars = c("Age", "Revenge", "Homicide", "Hunger"))
require(ggplot2)
ggplot(tmp,aes(x, value)) + 
        geom_point(aes(colour = factor(variable))) +
        xlab("time") +
        ylab("units") +
        ggtitle("My CSV file") +
        labs(colour = "my variables") files <- (dir("C:/my-csv-files", recursive=TRUE, full.names=TRUE, pattern="\\.(csv|CSV)$"))
listcsvs <- lapply(files, function(i) read.csv(i,  stringsAsFactors = FALSE, skip = 19))
names(listcsvs) <- files
require(reshape2)
require(ggplot2)
for (i in 1:length(files)) { 
  tmp <- melt(dat, id.vars = "x", measure.vars = c("y", "y.1", "y.2", "y.3"))
  print( ggplot(tmp,aes(x, value)) + 
    geom_point(aes(colour = factor(variable))) +
    xlab("time") +
    ylab("units") +
    ggtitle(names(listcsvs[i])) )
  )
}
-------------------------------------------------------------------------------------------------------
a<-ifelse(data$ICS==10,"a",ifelse(data$ICS==11,"b",ifelse(data$ICS==12,"c",ifelse(data$ICS==13,"d",ifelse(data$ICS==14,"e","f"))))) #ICS as characters
cls<-c(2,"orange",7,3,6,4) [factor(a)] #10-11-12-13-14-15: red,orange,yellow,green,purple,blue
b<-data$Site
shapes<-c(0,1,2,8)[factor(b)] #Square is RDC liv, Circle is RDC V, Triangle is RVC V, Star is RVC CCJ
BAplot <- function(x,y,yAxisLim=c(-50,50),xlab="Average", ylab="Difference",col=cls,pch=shapes) {
  d <- ((x + y)/2)
  diff <- x - y        
  plot(diff ~ d,ylim=yAxisLim,xlim=c(0,60),xlab=xlab,ylab=ylab,col=cls,pch=shapes)
  abline(h=(mean(na.omit(diff))-c(-0.96,0,0.96)*sd(na.omit(diff))),lty=2)
}
plot.ops<-BAplot(data$Op.1,data$Op.2,xlab="(Op1 vs Op 2)/2", ylab="Op1-mean of Op1+Op2",col=cls,pch=shapes)
title(main="Bland-Altman plots of Op1 vs Op2")
legend (34,53,legend=c("RDC Liver","RDC V","RVC V","RVC CCJ"), pch=c(0,1,2,8), pt.cex=2, y.intersp=0.8) #legend for shape
legend (49,53,legend=c("10th ICS","11th ICS","12th ICS","13th ICS","14th ICS","15th ICS"), pch=22, pt.cex=2, pt.bg=c(2,"orange",7,3,6,4), y.intersp=0.6) #legend for the colours shapes<-c(0,1,2,8)[factor(data$Site)] b<-data$Site
shapes<-c(0,1,2,8)[factor(b)]
-------------------------------------------------------------------------------------------------------
bquote() expression() .() plot.title = 'TITLE'
plot.subtitle = 'SUBTITLE'

ggplot(mtcars,aes(disp,mpg))+geom_point()+
  ggtitle(bquote(atop(.(plot.title), atop(italic(.(plot.subtitle)), ""))))
-------------------------------------------------------------------------------------------------------
layout() par(new=TRUE) par(plt=...) library("maps")

par(list(mar=c(0,0,4,0), bg="black"))
plot(0:1, 0:1, type="n", xlab="", ylab="", axes=FALSE)
title("Trois cartes de France se chevauchant", col.main="white")

# Random colors to highlight the overlapping.
set.seed(13)

par(list(new=TRUE, plt=c(.6, 1, .1, .9)))
plot(map("france", plot=FALSE), type="l", axes=FALSE, xlab="", ylab="", col=sample(c("white", "blue", "red"), 1))
par(list(new=TRUE, plt=c(.3, .7, .1, .9)))
plot(map("france", plot=FALSE), type="l", axes=FALSE, xlab="", ylab="", col=sample(c("white", "blue", "red"), 1))
par(list(new=TRUE, plt=c(0, .4, .1, .9)))
plot(map("france", plot=FALSE), type="l", axes=FALSE, xlab="", ylab="", col=sample(c("white", "blue", "red"), 1))
-------------------------------------------------------------------------------------------------------
myplotSVM <- e1071:::plot.svm
environment(myplotSVM)  <- .GlobalEnv
fix(myplotSVM) function (x, data, formula = NULL, fill = TRUE, grid = 50, slice = list(), 
  symbolPalette = palette(), svSymbol = "x", dataSymbol = "o", 
  main="SVN classification plot", ...) plot.title = 
title(main = main, # <----- change this part!!!  xlab = names(lis)[2], ylab = names(lis)[1]), ...) main myplotSVM(svmfit,dat[train,], main="FooBar")
-------------------------------------------------------------------------------------------------------
scatter_fill <- function (x, y, z,xlim=c(min(x),max(x)),ylim=c(min(y),max(y)),zlim=c(min(z),max(z)),
                          nlevels = 20, plot.title, plot.axes, 
                          key.title, key.axes, asp = NA, xaxs = "i", 
                          yaxs = "i", las = 1, 
                          axes = TRUE, frame.plot = axes, ...) 
{
  mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar
  on.exit(par(par.orig))
  w <- (3 + mar.orig[2L]) * par("csi") * 2.54
  layout(matrix(c(2, 1), ncol = 2L), widths = c(1, lcm(w)))
  par(las = las)
  mar <- mar.orig
  mar[4L] <- mar[2L]
  mar[2L] <- 1
  par(mar = mar)

# choose colors to interpolate
levels <- seq(zlim[1],zlim[2],length.out = nlevels)
col <- colorRampPalette(c("red","yellow","dark green"))(nlevels)  
colz <- col[cut(z,nlevels)]  
#   
plot.new()
plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i", yaxs = "i")

rect(0, levels[-length(levels)], 1, levels[-1L],col=col,border=col) 
if (missing(key.axes)) {if (axes){axis(4)}}
       else key.axes
   box()
   if (!missing(key.title)) 
     key.title
   mar <- mar.orig
   mar[4L] <- 1
   par(mar = mar)

   # points
   plot(x,y,type = "n",xaxt='n',yaxt='n',xlab="",ylab="",xlim=xlim,ylim=ylim,bty="n")
   points(x,y,col = colz,xaxt='n',yaxt='n',xlab="",ylab="",bty="n",...)

   ## options to make mapping more customizable

        if (missing(plot.axes)) {
          if (axes) {
            title(main = "", xlab = "", ylab = "")
            Axis(x, side = 1)
            Axis(y, side = 2)
          }
        }
        else plot.axes
        if (frame.plot) 
          box()
        if (missing(plot.title)) 
          title(...)
        else plot.title
        invisible()
 } # random vectors
vx <- rnorm(40,0,1)
vy <- rnorm(40,0,1)
vz <- rnorm(40,10,10)

scatter_fill(vx,vy,vz,nlevels=15,xlim=c(-1,1),ylim=c(-1,5),zlim=c(-10,10),main="TEST",pch=".",cex=8)
-------------------------------------------------------------------------------------------------------
library("shiny")
shinyUI(pageWithSidebar(

  headerPanel('Comparación de zonas - Temperatura'),

  sidebarPanel(
    selectInput("panel1", "Zona:",
                           list("Zona 1" = "1", 
                                "Zona 2" = "2", 
                                "Zona 3" = "3")),
    selectInput("panel2", "Zona:",
                list("Zona 1" = "1", 
                     "Zona 2" = "2", 
                     "Zona 3" = "3")),
    selectInput("var", "Variable:",
                list("tempc" = "tempc", 
                     "relhum" = "relhum")),    
  helpText('Al seleccionar la zona se crearán automáticamente
   el gráfico de evolución temporal.')
  ),

  mainPanel(
    conditionalPanel(condition = "inputId == 'panel1'",plotOutput(outputId='myplot1')),
    conditionalPanel(condition = "inputId == 'panel2'",plotOutput(outputId='myplot2'))
  )  
)) library(shiny)
library(plyr)
library(ggplot2)

shinyServer(function(input, output) {

  datos=read.table("data.dat",header=T)
  pobles=read.table("pobles-zona.dat",header=T)

  data=as.data.frame(datos)
  places=as.data.frame(pobles)

  data$time[data$time == "0"] = "000000"
  data$time[data$time == "10000"] = "010000"
  data$time[data$time == "20000"] = "020000"
  data$time[data$time == "30000"] = "030000"
  data$time[data$time == "40000"] = "040000"
  data$time[data$time == "50000"] = "050000"
  data$time[data$time == "60000"] = "060000"
  data$time[data$time == "70000"] = "070000"
  data$time[data$time == "80000"] = "080000"
  data$time[data$time == "90000"] = "090000"

  data=within(data, datetime <- as.POSIXct(paste(date, time),format = "%Y%m%d %H%M%S"))

  formulaText <- reactive(function() {
    paste("Gràfica de ggplot: Zona ", input$panel1, input$panel2, input$var)
  })

  # Return the formula text for printing as a caption
  output$caption <- reactiveText(function() {
    formulaText()
  })

  rams1 <- reactive({ 
    subset(data,data$stat_id %in% places$stat_id[places$Zona == input$panel1])    
  })  
  rams2 <- reactive({ 
    subset(data,data$stat_id %in% places$stat_id[places$Zona == input$panel2])    
  })  

  p <- function(data){
  p=ggplot(data(),aes_string(x="datetime", y=input$var,colour="as.character(stat_id)")) +
    geom_line()  
  }

   output$myplot1 <- reactivePlot(function() {

    gtitol=paste("Zona ",input$panel1)
    yx=round(max(rams1()$tempc)+2)
    yn=round(min(rams1()$tempc)-2)

    plot=p(rams1) 

    if ( input$var == "tempc" ) {
      plot=plot + ylab("Temperatura (ºC)") + xlab(" ") +
      ggtitle(gtitol) + theme(legend.title=element_blank()) + theme(legend.position="bottom") +
      scale_y_continuous(limits = c(yn,yx),breaks=c(seq(yn,yx,by=2)))
   }

    if ( input$var == "relhum"  ){
      plot=plot + ylab("Humedad relativa (%)") + xlab(" ") +  
      ggtitle(gtitol) + theme(legend.title=element_blank()) + theme(legend.position="bottom") + 
      scale_y_continuous(limits = c(0,100),breaks=c(seq(0,100,by=5)))
    }
    print(plot)
  })

  output$myplot2 <- reactivePlot(function() {

      gtitol=paste("Zona ",input$panel2)
      yx=round(max(rams2()$tempc)+2)
      yn=round(min(rams2()$tempc)-2)     

      plot=p(rams2) 

      if ( input$var == "tempc" ) {
        ylim=max(rams2()$tempc)+2
        plot=plot + ylab("Temperatura (ºC)") + xlab(" ") +
        ggtitle(gtitol) + theme(legend.title=element_blank()) + theme(legend.position="bottom") +
        scale_y_continuous(limits = c(yn,yx),breaks=c(seq(yn,yx,by=2)))
      }
      if ( input$var == "relhum"  ) {
        ylim=100
        plot=plot + ylab("Humedad relativa (%)") + xlab(" ") +  
        ggtitle(gtitol) + theme(legend.title=element_blank()) + theme(legend.position="bottom") + 
        scale_y_continuous(limits = c(0,100),breaks=c(seq(0,100,by=5)))
      }
    print(plot)
  })
})
-------------------------------------------------------------------------------------------------------
facet_wrap(~SIC,nrow=2) ggplot(dacc, aes(x = PER)) + 
  geom_line(aes(y = MEAN, group = NLEAD, color = NLEADMEAN)) +
  geom_line(aes(y = MED, group = NLEAD, color = NLEADMED)) +
  xlab("(Total Asset Percentile Cutoff To Define Big Firms)") +
  ylab("Mean Absolute Discretioary Accrual For Different Groups") +
  ggtitle(paste("Mean ADA Across Groups For SIC = ", unique(x$SIC))) +
  ylim(0, ymax/2) +
  facet_wrap(~SIC,nrow=2)
-------------------------------------------------------------------------------------------------------
vioplot ylab="" title(ylab="response", xlab="colours") title ?title
-------------------------------------------------------------------------------------------------------
# Loop over list of data frames and create plots
for (i in seq(titlenames)) {
  plot(x=(l[[i]]$a[l[[i]]$c==0]),y=(l[[i]]$b[l[[i]]$c==0]),main="",xlab="",ylab="")
  title(main=titlenames[i])
} l
-------------------------------------------------------------------------------------------------------
N <- 10000
 x <- rnbinom(N, 10, .5)
 hist(x, 
 xlim=c(min(x),max(x)), probability=T, nclass=max(x)-min(x)+1, 
   col='lightblue', xlab=' ', ylab=' ', axes=F,
   main='Positive Skewed')
lines(density(x,bw=1), col='red', lwd=3) curve(dbeta(x,8,4),xlim=c(0,1))
title(main="posterior distrobution of p")
-------------------------------------------------------------------------------------------------------
grid.text('plot1', vp=vplayout(1,1)) grid.newpage()
pushViewport(viewport(layout = grid.layout(1,2)))

plot1 <- qplot(rnorm(100))
print(plot1,vp=vplayout(1,1))
grid.text('plot1', x=.5, y=.95, vp=vplayout(1,1))

plot2 <- qplot(rnorm(10))
print(plot2,vp=vplayout(1,2))
grid.text('plot2', x=.5, y=.95, vp=vplayout(1,2)) ggtitle grid.text gridExtra require(gridExtra)
grid.arrange(
  plot1 + ggtitle('plot1'), 
  plot2 + ggtitle('plot2'),
  nrow=1)
-------------------------------------------------------------------------------------------------------
ggplot2 geom_raster() require(ggplot2)
require(plyr)

## CREATE REASONABLE SIZE GRID 30x30
dfe<-expand.grid(ENT_LATITU=seq(415000,418000,100),
            ENT_LONGIT=seq(630000,633000,100),
            CSK=0)
## FILL WITH RANDOM DATA
dfe$CSK=round(rnorm(nrow(dfe),200,50),0)

#######################################################
#####  VALUES TO CHANGE IN THIS BLOCK             #####
#######################################################
## TRIM ORIGINAL DATASET
lat.max<-Inf       # change items to trim data
lat.min<-0       
long.max<-Inf    
long.min<-631000      
dfe.trim<-dfe[findInterval(dfe$ENT_LATITU,c(lat.min,lat.max))*findInterval(dfe$ENT_LONGIT,c(long.min,long.max))==1,]
## SUMMARIZE TO NEW X/Y GRID
xblocks<-6
yblocks<-8

## GRAPH COLOR AND TEXT CONTROLS
showText<-TRUE
txtSize<-3
heatmap.low<-"lightgreen"
heatmap.high<-"orangered"
#######################################################
#####                                             #####
#######################################################

## BASIC PLOT (ALL DATA POINTS)
ggplot(dfe) +
  geom_raster(aes(ENT_LATITU,ENT_LONGIT,fill=CSK)) + theme_bw() +
  scale_fill_gradient(low=heatmap.low, high=heatmap.high) +
  geom_text(aes(ENT_LATITU,ENT_LONGIT,label=CSK,fontface="bold"),
            color="black",
            size=2.5) ## CALL ddply to roll-up the data and calculate summary means, SDs,ec
dfe.plot<-ddply(dfe.trim,
      .(lat=cut(dfe.trim$ENT_LATITU,xblocks),
        long=cut(dfe.trim$ENT_LONGIT,yblocks)),
      summarize,
      mean=mean(CSK),
      sd=sd(CSK),
      sum=sum(CSK),
      range=paste(min(CSK),max(CSK),sep="-"))

## BUILD THE SUMMARY CHART
g<-ggplot(dfe.plot) +
  geom_raster(aes(lat,long,fill=sum),alpha=0.75) +
  scale_fill_gradient(low=heatmap.low, high=heatmap.high) +
  theme_bw() + theme(axis.text.x=element_text(angle=-90)) +
  ggtitle(paste(xblocks,
                " X ",
                yblocks,
                " grid of Catch Data\nbetween ( ",
                min(dfe.trim$ENT_LATITU),
                " : ",
                min(dfe.trim$ENT_LONGIT),
                " ) and ( ",
                max(dfe.trim$ENT_LATITU),
                " : ",
                max(dfe.trim$ENT_LONGIT),
                " )\n\n",
                sep=""))

## ADD THE LABELS IF NEEDED
if(showText)g<-g+geom_text(aes(lat,long,label=paste("SUM=",round(sum,0),
                                            "\nMEAN=",round(mean,1),
                                            "\nSD=",round(sd,1),
                                            "\nRNG=",range,sep=""),
                                  fontface=c("italic")),
                                  color="black",size=txtSize)

## FUDGE THE LABELS TO MAKE MORE READABLE
## REPLACE "," with newline and "]" with ")"
g$data[,1:2]<-gsub("[,]",replacement=" to\n",x=as.matrix(g$data[,1:2]))
g$data[,1:2]<-gsub("]",replacement=")",x=as.matrix(g$data[,1:2]))

## PLOT THE CHART
g + labs(x="\nLatitude", y="Longitude\n", fill="Sum\nBlock\n")

## SHOW HEADER OF data.plot
head(dfe.plot)
-------------------------------------------------------------------------------------------------------
ggsave invisible(by(df, df$ID, function(i) {
    p <- ggplot(i, aes(Date, EC))+
        geom_line() +
        geom_point() +
        ggtitle(unique(i$ID))
    ggsave(sprintf("file%s.pdf", unique(i$ID)),p)
}))
-------------------------------------------------------------------------------------------------------
plot(1,1)
title("Title", line = -2)
-------------------------------------------------------------------------------------------------------
linetype= aes() stat_density() colors= scale_linetype_manual() ggplot(data=df)+
  stat_density(aes(x=R1, colour="rho = -0,6",linetype="rho = -0,6"), 
                     adjust=4, lwd=0.5, geom="line", position="identity")+
  stat_density(aes(x=R2, colour="rho = 0,6",linetype="rho = 0,6"), 
                     adjust=4, lwd=0.5, geom="line", position="identity")+
  stat_density(aes(x=R3, colour="rho = 0", linetype="rho = 0"), 
                     adjust=4, lwd=0.5, geom="line", position="identity")+
  xlim(-0.5, 0.5)+
  xlab("Renditen")+
  ylab("Dichte")+
  ggtitle("Renditeverteilung im Heston-Modell")+
  theme(plot.title=element_text(face="bold", size=16, vjust=2),  
        axis.title.x=element_text(vjust=-1, size=12), 
        axis.title.y=element_text(vjust=-0.25, size=12), 
        legend.text=element_text(size=12), legend.title=element_text(size=12),
        legend.margin=unit(1.5, "cm"),
        legend.key.height=unit(1.2, "line"), 
        legend.key.size=unit(0.4, "cm"), 
        legend.key=element_rect(fill=NA), 
        legend.background=element_rect(colour="darkgrey"),
        plot.margin=unit(c(1,1,1,1), "cm"))+
  scale_colour_manual(values=c("rho = -0,6"="red", "rho = 0,6"="blue", 
                                "rho = 0"="black"), name="Korrelation")+
  scale_linetype_manual(values=c("rho = -0,6"=1, "rho = 0,6"=1, 
                                "rho = 0"=2), name="Korrelation")
-------------------------------------------------------------------------------------------------------
df2 <- stack(df)
df2$ind <- as.character(df2$ind) value1 = 0.8
value2 = 0.8
value3 = 0
greeks <- list(bquote(rho==.(value1)), bquote(rho==.(value2)), bquote(rho==.(value3)))

ggplot(data=df2)+
  stat_density(aes(x=values, group=ind, color=ind), 
               adjust=4, lwd=0.5, geom="line", position="identity")+
  xlim(-3, 3)+
  xlab("Renditen")+
  ylab("Dichte")+
  ggtitle("Renditeverteilung im Heston-Modell")+
  theme(plot.title=element_text(face="bold", size=16, vjust=2, family="Times New Roman"),  
        axis.title.x=element_text(vjust=-1, size=14, family="Times New Roman"),
        axis.title.y=element_text(vjust=-0.25, size=14, family="Times New Roman"), 
        legend.text=element_text(size=14, family="Times New Roman"), 
            legend.title=element_blank(),
        legend.margin=unit(1, "cm"),
        legend.key.height=unit(1, "line"), 
        legend.key.size=unit(0.4, "cm"), 
        legend.key=element_rect(fill=NA), 
        legend.background=element_blank(),
        plot.margin=unit(c(1,1,1,1), "cm"))+
  scale_colour_manual(values=1:3, labels=greeks) 
 +guides(colour=guide_legend(override.aes=list(linetype=1:3)))
-------------------------------------------------------------------------------------------------------
Date ggplot2 geom_line(aes(group=Genus)) geom_line(aes(x=as.numeric(Date))) DensityE <- data.frame(
    Date=c("1-Jul","16-Jul","22-Jul","3-Jun","17-Jun"),
    Genus=c("Epeorus","Epeorus","Epeorus","Rhyacophila","Rhyacophila"),
    Density=c(3.5,3.25,1,1,0.75)) theme_blank element_blank opt theme ggplot2 library(ggplot2)
 ggplot(data=DensityE, aes(Date,Density)) + 
    geom_point(aes(shape = factor(Genus)), size = 4)+
    geom_line(aes(group=Genus))+
 theme_bw() + xlab("Date") +
 ylab("Density per m2") + ggtitle("COP 1992") +
 theme(legend.key = element_blank()) + 
 theme(legend.title = element_blank())+
 theme(legend.text = element_text(size=9))
-------------------------------------------------------------------------------------------------------
heatmap.2 title(main, cex.main = 1.5 * op[["cex.main"]]) cex.main par par(cex.main=0.5) ## this will affect also legend title font size
-------------------------------------------------------------------------------------------------------
open <- subset(data1, Physicians_Out == "Open")
restr <- subset(data1, Physicians_Out == "Restricted")
closed <- subset(data1, Physicians_Out == "Closed") labs.open <- paste(gsub("/","-\n",names(table(open$Physicians_In)),fixed=T),
               "\n(N=",table(open$Physicians_In),")",sep="")
labs.restr <- paste(gsub("/","-\n",names(table(restr$Physicians_In)),fixed=T),
               "\n(N=",table(restr$Physicians_In),")",sep="")
labs.closed <- paste(gsub("/","-\n",names(table(closed$Physicians_In)),fixed=T),
               "\n(N=",table(closed$Physicians_In),")",sep="") mytheme <- theme(
  axis.title.y = element_blank(),
  axis.text.y = element_blank(),
  axis.ticks.y = element_blank()
) p1 <- ggplot(open,aes(x=Physicians_In,y=share,fill=Physicians_In)) +
  geom_boxplot() + stat_sum_single(mean) + 
  geom_jitter(position = position_jitter(width = .2),color="blue") +
  guides(fill=FALSE) +
  ggtitle(paste("Physician Access (Out): Open\nN = (", nrow(open), ")\n")) +
  scale_y_continuous("Gammagard Share",labels=percent) +
  scale_x_discrete("\nPhysician Access (In Hospital)",labels=labs.open) +
  theme_bw()

p2 <- ggplot(restr,aes(x=Physicians_In,y=share,fill=Physicians_In)) +
  geom_boxplot() + stat_sum_single(mean) + 
  geom_jitter(position = position_jitter(width = .2),color="blue") +
  guides(fill=FALSE) +
  ggtitle(paste("Physician Access (Out): Restricted\nN = (", nrow(restr), ")\n")) +
  scale_x_discrete("\nPhysician Access (In Hospital)",labels=labs.restr) +
  theme_bw() + mytheme

p3 <- ggplot(closed,aes(x=Physicians_In,y=share,fill=Physicians_In)) +
  geom_boxplot() + stat_sum_single(mean) + 
  geom_jitter(position = position_jitter(width = .2),color="blue") +
  guides(fill=FALSE) +
  ggtitle(paste("Physician Access (Out): Closed\nN = (", nrow(closed), ")\n")) +
  scale_x_discrete("\nPhysician Access (In Hospital)",labels=labs.closed) +
  theme_bw() + mytheme

library(gridExtra)

grid.arrange(p1, p2, p3, ncol=3)
-------------------------------------------------------------------------------------------------------
bquote(atop("first line",
            "second line" ~ x ^ 2)) bquote expression demo(plotmath) atop boxplot boxplot(data, main = '')
title(bquote(atop("first line", "second line" ~ x ^ 2)))
-------------------------------------------------------------------------------------------------------
x = 1:400
y = x^2
plot(x, y, type="l", col="red")
title(main="Funzioni", col.main="blue", font.main=4) x = 1:400
y = x^2
plot(x, y, type="l", col="red", xlim=c(-400, 400), ylim=c(-16000, 16000))
abline(h=0)
abline(v=0)
title(main="Funzioni", col.main="blue", font.main=4)
-------------------------------------------------------------------------------------------------------
# Load data
data(Feldspar)

# Sort it by decreasing pressure 
# (so small grobs sit on top of large grobs
Feldspar <- Feldspar[with(Feldspar, order(-P.Gpa)), ]

# Build and Render the Plot
ggtern(data = Feldspar, aes(x = An, y = Ab, z = Or)) + 
#the layer
geom_point(aes(fill = T.C, 
               size = P.Gpa, 
               shape = Feldspar)) + 
#scales
scale_shape_manual(values = c(21, 24)) + 
scale_size_continuous(range = c(2.5, 7.5)) + 
scale_fill_gradient(low = "green", high = "red") + 

#theme tweaks
theme_tern_bw()  + 
theme(legend.position      = c(0, 1), 
      legend.justification = c(0, 1), 
      legend.box.just      = "left") + 

#tweak guides
guides(shape= guide_legend(order   =1,
                           override.aes=list(size=5)),
       size = guide_legend(order   =2),
       fill = guide_colourbar(order=3)) +

#labels and title
labs(size = "Pressure/GPa", 
     fill = "Temperature/C") + 
ggtitle("Feldspar - Elkins and Grove 1990") ggtern(data=Feldspar,aes(An,Ab,Or)) +
  geom_confidence(aes(group=Feldspar,
                      fill=..level..,
                      alpha=1-..level..),
                      n=2000,
                  breaks=c(0.01,0.02,0.03,0.04,
                           seq(0.05,0.95,by=0.1),
                           0.99,0.995,0.9995),
                  color=NA,linetype=1) +
  geom_density2d(aes(color=..level..)) + 
  geom_point(fill="white",aes(shape=Feldspar),size=5) +  
  theme_tern_bw() + 
  theme_tern_nogrid() + 
  theme(ternary.options=element_ternary(padding=0.2),
                        legend.position=c(0,1),
                        legend.justification=c(0,1),
                        legend.box.just="left") +
  labs(color="Density",fill="Confidence",
   title="Feldspar - Elkins and Grove 1990 + Confidence Levels + Density") +
  scale_color_gradient(low="gray",high="magenta") +
  scale_fill_gradient2(low="red",mid="orange",high="green",
                       midpoint=0.8) +
  scale_shape_manual(values=c(21,24)) + 
  guides(shape= guide_legend(order   =1,
                             override.aes=list(size=5)),
         size = guide_legend(order   =2),
         fill = guide_colourbar(order=3),
         color= guide_colourbar(order=4),
         alpha= "none")
-------------------------------------------------------------------------------------------------------
par(mai = c(1,2,1,0.7), xaxs='i',yaxs='i', xpd = F)
plot( na.trim(h1.zoo), main="", xlab="Date", ylab="", yaxt = "n", bty = "n", cex.axis = 0.6, ylim=c(-0.0135,-0.0128))
axis(2, las = 2, cex.axis = 0.6, at = seq(-.014,-.012,.0001))
title(ylab = "Contribution to Expected Return (in %)", line = 3) ylim= plot(...) (-0.0134,-0.0129) -0.02 to 0 axis(...) plot(...) xpd=F par(...)
-------------------------------------------------------------------------------------------------------
size geom_text aes Data$size <- size

p <- ggplot(data = Data, aes(x = factor(''), y = Freq, fill = Var1)) +
       geom_bar(stat = "identity",position = "fill", width = 1) +
       scale_fill_brewer(palette = 3) +
       geom_text(aes(y = y, label = label, 
                     position ="identity", face = "bold", size = size), hjust=0.5, 
                     vjust=0.5) +
       xlab('') + ylab('') + labs(fill = '') + ggtitle('Example') +
       theme(axis.text.y = element_text(size=14,face="bold"),
             panel.background = element_blank(),
             plot.title = element_text(size = 20, colour = "black", face = "bold")) + 
             facet_grid(facets = . ~ Var2) + 
             guides(size=FALSE) + guides(size=FALSE) size Var2 size + scale_size(range=c(6,10)) 6,10
-------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------
aes_string plot.label <- function(var){
  ggplot(data = qs) + geom_bar(aes_string(x = var)) + 
    ggtitle(attr(qs, "variable.labels")[grep(var, names(qs))])
  }
-------------------------------------------------------------------------------------------------------
Model2 sub <- subset(dat, Gene == '3_RH2B')
df <- sub[with(sub, order(Model2)), ]


ggplot(df, aes(x = Morpho, y = Weights, fill = Model2)) + 
  geom_bar(stat = 'identity') + ggtitle('RH2B') stat = 'identity' Weights ggplot(sub, aes(x = Morpho, fill = Model2)) + geom_bar() + ggtitle('RH2B')
-------------------------------------------------------------------------------------------------------
na.value NA set.seed(1)
library(ggplot2)
rawdata <- data.frame(doforaliving=as.factor(c(sample(1:4, 100, replace=T), rep(NA, 10))))
ggplot(rawdata, aes(x=doforaliving)) + 
  geom_histogram(binwidth=.5) + xlab("") + 
  ylab("Number of Participants") + 
  ggtitle("Are you working or studying?") + 
  scale_x_discrete(breaks=c("1", "2", "3", "4",NA), 
                   labels=c("Working", "Searching for work", "Continuing my studies", "Other", "NA"))
-------------------------------------------------------------------------------------------------------
ylab=expression("Photosynthetically available radiation (µE m"^-2~d^-1*")")) group plot(1,1, ylab="")
title(ylab=expression("Photosynthetically available radiation (µE m"^-2~d^-1*")"),
      line=2)
-------------------------------------------------------------------------------------------------------
stat = 'identity' geom_bar stat='identity' Model2 dat = read.table(text = "      Gene    Morpho Model     Weights Model2
29 3_RH2B Morph_PC1   BM1 0.301666667    BMx
32 3_RH2B Morph_PC1   OUM 0.066666667   OUMx
30 3_RH2B Morph_PC1   BMS 0.478333333    BMx
31 3_RH2B Morph_PC1   OU1 0.091666667    OU1
33 3_RH2B Morph_PC1  OUMA 0.028333333   OUMx
34 3_RH2B Morph_PC1  OUMV 0.023333333   OUMx
35 3_RH2B Morph_PC1 OUMVA 0.008333333   OUMx
36 3_RH2B Morph_PC2   OUM 0.246666667   OUMx
37 3_RH2B Morph_PC2  OUMA 0.171666667   OUMx
38 3_RH2B Morph_PC2  OUMV 0.096666667   OUMx
39 3_RH2B Morph_PC2   BMS 0.106666667    BMx
40 3_RH2B Morph_PC2   OU1 0.213333333    OU1
41 3_RH2B Morph_PC2   BM1 0.140000000    BMx
42 3_RH2B Morph_PC2 OUMVA 0.025000000   OUMx", header = TRUE, sep = "") datRevised = aggregate(Weights ~ Morpho + Model2, data = dat, FUN = "sum")
ggplot(datRevised, aes(x=Morpho, y=Weights, fill=Model2)) + geom_bar(stat='identity') + ggtitle('RH2B') weight ggplot(dat, aes(x=Morpho, weight=Weights, fill=Model2)) + geom_bar() + ggtitle('RH2B')
-------------------------------------------------------------------------------------------------------
ylab ylab = expression(bold(Density)) hist(faithful$waiting, ylab = expression(bold(Density))) font.lab hist(faithful$waiting, ylab = "")
title(ylab = "Density", font.lab = 2) ylab hist(faithful$waiting, ylab = "Density", font.lab = 2)
-------------------------------------------------------------------------------------------------------
library(ggplot2)

ggplot(df, aes(x=vector)) +   
   geom_histogram(breaks=breaks,aes(y=..density..),colour="black",fill=c("red","orange","yellow","lightgreen","green","darkgreen","blue","darkblue","purple","pink")) + 
   geom_density(aes(y=..density..)) +
   scale_x_continuous(breaks=c(-3,-2,-1,0,1,2,3)) +
   ylab("Density") + xlab("df$vector") + ggtitle("Histogram of df$vector") +
   theme_bw() + theme(plot.title=element_text(size=20),
                      axis.title.y=element_text(size = 16, vjust=+0.2),
                      axis.title.x=element_text(size = 16, vjust=-0.2),
                      axis.text.y=element_text(size = 14),
                      axis.text.x=element_text(size = 14),
                      panel.grid.major = element_blank(),
                      panel.grid.minor = element_blank())
-------------------------------------------------------------------------------------------------------
theme_xx() element_xx() theme_segment() theme_line() opts() theme() opts(title = "mytitle") labs(title = "mytitle") ggtitle("mytitle")
-------------------------------------------------------------------------------------------------------
