## use stack() to reshape the data frame to a long format
## <time> <stock> <price>
stackdat <- stack(dat,select=-t) 
names(stackdat) <- c('price','symbol')

## create a column of date & bind to the new data frame
nsymbol <- length(levels(stackdat$symbol))  
date <- rep(dat$t, nsymbol)  
newdat <- cbind(date,stackdat)

## plot it with lattice
library(lattice)
xyplot(price ~ date | symbol,  ## model conditions on 'symbol' to lattice
       data=newdat,            ## data source
       type='l',               ## line
       layout=c(nsymbol,1))    ## put it on a single line

## or plot it with ggplot2
library(ggplot2)
qplot(date, price, data = newdat, geom="line") + facet_grid(. ~ symbol)
-------------------------------------------------------------------------------------------------------
library(ggplot2)
wide <- data.frame(x = rnorm(100), eps = rnorm(100, 0, .2))
wide$first <- with(wide, 3 * x + eps)
wide$second <- with(wide, 2 * x + eps)
long <- melt(wide, id.vars = c("x", "eps"))
ggplot(long, aes(x = x, y = value)) + geom_smooth() + geom_point() + facet_grid(.~ variable)
-------------------------------------------------------------------------------------------------------
expand.grid() interArray=function(X){
    n=ncol(X)
    ind=expand.grid(1:n,1:n)
    return(X[,ind[,1]]*X[,ind[,2]])
}

> X
          X1         X2
1 0.96852363 0.33827107
2 0.08012755 0.69159828
3 0.10167545 0.38119304
4 0.06699458 0.41756415
5 0.08187816 0.09805104

> interArray(X)
           X1          X2        X1.1        X2.1
1 0.938038022 0.327623524 0.327623524 0.114427316
2 0.006420424 0.055416073 0.055416073 0.478308177
3 0.010337897 0.038757974 0.038757974 0.145308137
4 0.004488274 0.027974536 0.027974536 0.174359821
5 0.006704033 0.008028239 0.008028239 0.009614007
-------------------------------------------------------------------------------------------------------
expand.grid() thedata <- data.frame(predict(thelm), thelm$model$x, thelm$model$f)

ggplot(thedata, aes(x = x, y = yhat, group = f, color = f)) + geom_line()
-------------------------------------------------------------------------------------------------------
by() R> set.seed(42)
R> testdf <- data.frame(var1=rnorm(100), var2=rnorm(100,2), var3=rnorm(100,3),  
                        group=as.factor(sample(letters[1:10],100,replace=T)),  
                        year=as.factor(sample(c(2007,2009),100,replace=T)))
R> summary(testdf)
      var1              var2              var3          group      year   
 Min.   :-2.9931   Min.   :-0.0247   Min.   :0.30   e      :15   2007:50  
 1st Qu.:-0.6167   1st Qu.: 1.4085   1st Qu.:2.29   c      :14   2009:50  
 Median : 0.0898   Median : 1.9307   Median :2.98   f      :12            
 Mean   : 0.0325   Mean   : 1.9125   Mean   :2.99   h      :12            
 3rd Qu.: 0.6616   3rd Qu.: 2.4618   3rd Qu.:3.65   d      :11            
 Max.   : 2.2866   Max.   : 4.7019   Max.   :5.46   b      :10            
                                                    (Other):26 by() R> by(testdf[,1:3], testdf$year, mean)
testdf$year: 2007
   var1    var2    var3 
0.04681 1.77638 3.00122 
--------------------------------------------------------------------- 
testdf$year: 2009
   var1    var2    var3 
0.01822 2.04865 2.97805 
R> by(testdf[,1:3], list(testdf$group, testdf$year), mean)  
## longer answer by group and year suppressed R> foo <- by(testdf[,1:3], list(testdf$group, testdf$year), mean)  
R> do.call(rbind, foo)
          var1   var2  var3
 [1,]  0.62352 0.2549 3.157
 [2,]  0.08867 1.8313 3.607
 [3,] -0.69093 2.5431 3.094
 [4,]  0.02792 2.8068 3.181
 [5,] -0.26423 1.3269 2.781
 [6,]  0.07119 1.9453 3.284
 [7,] -0.10438 2.1181 3.783
 [8,]  0.21147 1.6345 2.470
 [9,]  1.17986 1.6518 2.362
[10,] -0.42708 1.5683 3.144
[11,] -0.82681 1.9528 2.740
[12,] -0.27191 1.8333 3.090
[13,]  0.15854 2.2830 2.949
[14,]  0.16438 2.2455 3.100
[15,]  0.07489 2.1798 2.451
[16,] -0.03479 1.6800 3.099
[17,]  0.48082 1.8883 2.569
[18,]  0.32381 2.4015 3.332
[19,] -0.47319 1.5016 2.903
[20,]  0.11743 2.2645 3.452
R> do.call(rbind, dimnames(foo))
     [,1]   [,2]   [,3]   [,4]   [,5]   [,6]   [,7]   [,8]   [,9]   [,10] 
[1,] "a"    "b"    "c"    "d"    "e"    "f"    "g"    "h"    "i"    "j"   
[2,] "2007" "2009" "2007" "2009" "2007" "2009" "2007" "2009" "2007" "2009" dimnames R> expand.grid(dimnames(foo))
   Var1 Var2
1     a 2007
2     b 2007
3     c 2007
4     d 2007
5     e 2007
6     f 2007
7     g 2007
8     h 2007
9     i 2007
10    j 2007
11    a 2009
12    b 2009
13    c 2009
14    d 2009
15    e 2009
16    f 2009
17    g 2009
18    h 2009
19    i 2009
20    j 2009
R> data.frame R> data.frame(cbind(expand.grid(dimnames(foo)), do.call(rbind, foo)))
   Var1 Var2     var1   var2  var3
1     a 2007  0.62352 0.2549 3.157
2     b 2007  0.08867 1.8313 3.607
3     c 2007 -0.69093 2.5431 3.094
4     d 2007  0.02792 2.8068 3.181
5     e 2007 -0.26423 1.3269 2.781
6     f 2007  0.07119 1.9453 3.284
7     g 2007 -0.10438 2.1181 3.783
8     h 2007  0.21147 1.6345 2.470
9     i 2007  1.17986 1.6518 2.362
10    j 2007 -0.42708 1.5683 3.144
11    a 2009 -0.82681 1.9528 2.740
12    b 2009 -0.27191 1.8333 3.090
13    c 2009  0.15854 2.2830 2.949
14    d 2009  0.16438 2.2455 3.100
15    e 2009  0.07489 2.1798 2.451
16    f 2009 -0.03479 1.6800 3.099
17    g 2009  0.48082 1.8883 2.569
18    h 2009  0.32381 2.4015 3.332
19    i 2009 -0.47319 1.5016 2.903
20    j 2009  0.11743 2.2645 3.452
R>
-------------------------------------------------------------------------------------------------------
expand.grid(x[,1],x[,2])
-------------------------------------------------------------------------------------------------------
expand.grid() R> GG <- expand.grid(1:10,1:10)
R> GG <- GG[GG[,1]>=GG[,2],]     # trim it to your 55 pairs
R> dim(GG)
[1] 55  2
R> head(GG)
  Var1 Var2
1    1    1
2    2    1
3    3    1
4    4    1
5    5    1
6    6    1
R>
-------------------------------------------------------------------------------------------------------
idx <- expand.grid(1:nrow(x), 1:nrow(x))
idx<-idx[idx[,1] >= idx[,2],]
N <- cbind(x[idx[,2],], x[idx[,1],])

> all(M == N)
[1] TRUE
-------------------------------------------------------------------------------------------------------
> gsub('^', 'q', gsub(' ', '', 
    apply(expand.grid(1:10,letters),1,
           function(r) paste(r, sep='', collapse='')
         )))
  [1] "q1a"  "q2a"  "q3a"  "q4a"  "q5a"  "q6a"  "q7a"  "q8a"  "q9a"  "q10a"
 [11] "q1b"  "q2b"  "q3b"  "q4b"  "q5b"  "q6b"  "q7b"  "q8b"  "q9b"  "q10b"
 [21] "q1c"  "q2c"  "q3c"  "q4c"  "q5c"  "q6c"  "q7c"  "q8c"  "q9c"  "q10c"
 [31] "q1d"  "q2d"  "q3d"  "q4d"  "q5d"  "q6d"  "q7d"  "q8d"  "q9d"  "q10d"
 [41] "q1e"  "q2e"  "q3e"  "q4e"  "q5e"  "q6e"  "q7e"  "q8e"  "q9e"  "q10e"
 [51] "q1f"  "q2f"  "q3f"  "q4f"  "q5f"  "q6f"  "q7f"  "q8f"  "q9f"  "q10f"
 [61] "q1g"  "q2g"  "q3g"  "q4g"  "q5g"  "q6g"  "q7g"  "q8g"  "q9g"  "q10g"
 [71] "q1h"  "q2h"  "q3h"  "q4h"  "q5h"  "q6h"  "q7h"  "q8h"  "q9h"  "q10h"
 [81] "q1i"  "q2i"  "q3i"  "q4i"  "q5i"  "q6i"  "q7i"  "q8i"  "q9i"  "q10i"
 [91] "q1j"  "q2j"  "q3j"  "q4j"  "q5j"  "q6j"  "q7j"  "q8j"  "q9j"  "q10j"
 ... analyzeQuestion <- function (prefix)
{
  q <- d1[,grep(prefix,colnames(d1))] ## Pull in everything matching q4a_X
  q <- melt(q) ## restructure data for post-hoc

  qaaov <- aov(formula=value~variable,data=q4a) ## anova
  return (LTukey(q4aaov,which="",conf.level=0.95)) ## Tukey's post-hoc
} aov(..., data=q4a) sapply() analyzeQuestion
-------------------------------------------------------------------------------------------------------
contour x <- seq(-3,3)
y <- seq(-3,3)

z <- outer(x,y, function(x,y,...) x^2 + y^2 ) contour(x,y,z, lty=1) library("fields")
contour(predict.surface(Tps(as.matrix(expand.grid(x=x,y=y)),as.vector(z)))) Tps() contour lattice ggplot2 geom_contour() ds <- matrix(rnorm(100), nrow = 10) 
library(reshape) 
molten <- melt(data = ds) 
library(ggplot2) 
ggplot(molten, aes(x = X1, y = X2, z = value)) + geom_contour()
-------------------------------------------------------------------------------------------------------
R> for (i in 1:3) for (j in 1:3) cat(i,j,i*j, "\n")
1 1 1 
1 2 2 
1 3 3 
2 1 2 
2 2 4 
2 3 6 
3 1 3 
3 2 6 
3 3 9 
R> R> outer(1:3,1:3, "*")
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    2    4    6
[3,]    3    6    9
R> R> X <- expand.grid(x=1:3, y=1:3)
R> X <- X[ X$x >= X$y, ]
R> outer(X$x, X$y, "*")
     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    1    1    2    2    3
[2,]    2    2    2    4    4    6
[3,]    3    3    3    6    6    9
[4,]    2    2    2    4    4    6
[5,]    3    3    3    6    6    9
[6,]    3    3    3    6    6    9
R>
-------------------------------------------------------------------------------------------------------
N <- 5
for (i in 0:(2*N)) {
   for (j in i:N) {
        print(paste(i,j,sep=","))
    }
} for (i in 1:6) {
    for (j in i:3) {
        if(j > 3) break()
        print(paste(i,j,sep=","))
    }
} x <- cbind(rep(c(1,2,3), 3),
    rep(c(1,2,3), each=3)) x <- expand.grid(x=1:3, y=1:3) x[x[,1] >= x[,2],]
-------------------------------------------------------------------------------------------------------
dev.new plot(1:10)
dev.new()
plot(10:1) mfrow par(mfrow = c(2,1))
plot(1:10)
plot(10:1) library(lattice)
dfr <- data.frame(
  x   = rep(1:10, 2), 
  y   = c(1:10, 10:1), 
  grp = rep(letters[1:2], each = 10)
)
xyplot(y ~ x | grp, data = dfr) library(ggplot2)
qplot(x, y, data = dfr, facets = grp ~ .)
#or equivalently
ggplot(dfr, aes(x, y)) + geom_point() + facet_grid(grp ~ .)
-------------------------------------------------------------------------------------------------------
p <- qplot(data = data.frame(x = x, y = y),
           x, y,   
           xlab = "Radius [km]", 
           ylab = "Services [log]",
           xlim = x_range,
           ylim = c(0,10),
           main = paste("Sample",i)
           ) + geom_abline(intercept = inter, slope = slop, colour = "red", size = 1) > summary(pltList[["a1"]])
data: x, y [50x2]
mapping:  x = x, y = y
scales:   x, y 
faceting: facet_grid(. ~ ., FALSE)
-----------------------------------
geom_point:  
stat_identity:  
position_identity: (width = NULL, height = NULL)

mapping: group = 1 
geom_abline: colour = red, size = 1 
stat_abline: intercept = 2.55595281266726, slope = 0.05543539319091 
position_identity: (width = NULL, height = NULL) data data: [0x0]
mapping:  x = x, y = y
scales:   x, y 
faceting: facet_grid(. ~ ., FALSE)
-----------------------------------
geom_point:  
stat_identity:  
position_identity: (width = NULL, height = NULL)

mapping: group = 1 
geom_abline: colour = red, size = 1 
stat_abline: intercept = 2.55595281266726, slope = 0.05543539319091 
position_identity: (width = NULL, height = NULL) x y
-------------------------------------------------------------------------------------------------------
all_combs <- expand.grid(
  ID = unique(data$ID),
  Date = unique(data$Date))

data <- merge(data, all_combs, by = c("ID", "Date"), all = T)
# Ensure data ordered by date
data <- data[with(data, order(ID, Date)), ] library(plyr)
data <- ddply(data, "ID", transform, delta = c(NA, diff(Value))) changed <- subset(data, !is.na(delta))
changed <- changed[with(changed, order(ID, delta)), ]

# Select top 100 for each
top10 <- ddply(changed, "ID", function(df) {
 rbind(head(df, 10), tail(df, 10))
})
-------------------------------------------------------------------------------------------------------
sales <- expand.grid(country = c('USA', 'UK', 'FR'),
                     product = c(1, 2, 3))
sales$revenue <- rnorm(dim(sales)[1], mean=100, sd=10)

> sales
  country product   revenue
1     USA       1 108.45965
2      UK       1  97.07981
3      FR       1  99.66225
4     USA       2 100.34754
5      UK       2  87.12262
6      FR       2 112.86084
7     USA       3  95.87880
8      UK       3  96.43581
9      FR       3  94.59259 ## transform currency to euros
usd2eur <- 1.434
transform(sales, euro = revenue * usd2eur)

>
  country product   revenue     euro
1     USA       1 108.45965 155.5311
2      UK       1  97.07981 139.2125
3      FR       1  99.66225 142.9157
... subset(sales, 
       country == 'USA' & product %in% c(1, 2), 
       select = c('product', 'revenue'))

>
  product  revenue
1       1 108.4597
4       2 100.3475 ##  recast the previous subset() expression in SQL
sqldf('SELECT product, revenue FROM sales \
       WHERE country = "USA" \
       AND product IN (1,2)')

>
  product  revenue
1       1 108.4597
2       2 100.3475 sqldf('select country, sum(revenue) revenue \ 
       FROM sales \
       GROUP BY country')

>
  country  revenue
1      FR 307.1157
2      UK 280.6382
3     USA 304.6860
-------------------------------------------------------------------------------------------------------
help(grid) R> set.seed(42)
R> plot(cumsum(rnorm(100)), type='l')
R> grid() panel.grid() help.search("something")
-------------------------------------------------------------------------------------------------------
R test <- read.table("/tmp/test.txt", header=TRUE)
png(filename="/tmp/test.png", height=750, width=1000, 
    bg="white", res=300)
par(mar=c(2.5,2.5,0.75,0.75), 
    family="Gill Sans", font=1, # font 2 would be bold
    cex=0.75, cex.lab=0.75, cex.axis=0.75) 
mymax <- max(test$Region1, test$Region2)*1.25

plot(test$Region1, type="b", col="#304E67", 
     ylim=c(0, mymax), lwd=3,
     bty="l", axes=FALSE, ann=FALSE, cex=1.0, tck=1)

axis(1, lwd.ticks=0, at=1:length(test$Year), lab=test$Year)
axis(2, lwd=0, las=1, at=c(0,25,50,75,100), yaxp=c(0,100,4))
# grid(nx = NA, ny = 5, col = "lightgray") # wrong, see axTicks
for(y in c(25, 50, 75, 100)) {
  lines(rep(y, length(test$Region1)), type="l", col="lightgray", lwd=1)
}

lines(test$Region1, type="b", col="#304E67", lwd=3)
lines(test$Region2, type="b", col="#974449", lwd=3)

# title(xlab="Year", col.lab=rgb(0,0.5,0))
# title(ylab="Output", col.lab=rgb(0,0.5,0))
legend(1, mymax+8, c("Region 1","Region 2"), cex=0.75, 
       col=c("#304E67" ,"#974449"), 
       pch=1:1, # circles
       lty=1:1, # solid 
       lwd=1.5, # line width
       bty="n") # no box around

dev.off() Year Region1 Region2
2007 17 55
2008 26 43
2009 53 70
2010 96 58
-------------------------------------------------------------------------------------------------------
pairs <- expand.grid(alpha, beta)
names(pairs) <- c("alpha", "beta")
mapply(predict, pairs$alpha, pairs$beta, 
    MoreArgs=list(object=classifier.out, data=validation.data))
-------------------------------------------------------------------------------------------------------
ggplot(df) + geom_histogram(mapping=aes(x=val)) 
  + geom_vline(data=aggregate(df[3], df[c(1,2)], mean), 
      mapping=aes(xintercept=val), color="red") 
  + facet_grid(cat1~cat2) plyr require(plyr) ggplot(df) + geom_histogram(mapping=aes(x=val)) 
  + geom_vline(data=ddply(df, cat1~cat2, numcolwise(mean)), 
      mapping=aes(xintercept=val), color="red") 
  + facet_grid(cat1~cat2)
-------------------------------------------------------------------------------------------------------
ggplot require(ggplot2) rdata = read.csv("data.csv", 
# options: load '-' as na, ignore first comment line #Solar,
# strip whitespace that ends line, accept numbers as col headings
  na.strings="-", skip=1, strip.white=T, check.names=F)
# Convert to long format and check years are numeric
data = melt(rdata)
data = transform(data,year=as.numeric(as.character(variable)))
# geom_ribbon hates NAs.
data = data[!is.na(data$value),]

> summary(data)
           Country       variable       value             year     
 Austria       : 12   1996   : 25   Min.   :  0.00   Min.   :1996  
 Belgium       : 12   1997   : 25   1st Qu.:  0.00   1st Qu.:1999  
 Croatia       : 12   1998   : 25   Median :  7.00   Median :2002  
 Cyprus        : 12   1999   : 25   Mean   : 36.73   Mean   :2002  
 Czech Republic: 12   2000   : 25   3rd Qu.: 30.00   3rd Qu.:2004  
 Denmark       : 12   2001   : 25   Max.   :580.00   Max.   :2007  
 (Other)       :228   (Other):150 ggplot(data=data, aes(fill=Country)) +
  facet_grid(Country~.,space="free", scales="free_y") +
  opts(legend.position="none") +
  geom_ribbon(aes(x=year,ymin=-value,ymax=+value))
-------------------------------------------------------------------------------------------------------
df<-expand.grid(x=1:10,y=1:6)
df<-cbind(df,val=runif(60))
df$fx<-factor(df$x)
df$fy<-factor(df$y)
qplot(fy,val,fill=fx,data=df,geom='bar')
-------------------------------------------------------------------------------------------------------
dt dt <- expand.grid(X=1:3, Y=1:2)
dt$p <- runif(6)
dt$p <- dt$p / sum(dt$p)  # get fake probabilities
idx <- sample(1:nrow(dt), size=8, replace=TRUE, prob=dt$p)
sampled.x <- dt$X[idx]
sampled.y <- dt$Y[idx]
-------------------------------------------------------------------------------------------------------
makeTuples <- function( x, n ){

  # Very inefficient way to loop... but what the heck
  tuples <- list()

  for( i in 1:n ){

    tuples[[i]] <- x[i:(length(x)-n+i)]

  }

  return(tuples)

} makeTuples() table() do.call() do.call( table, makeTuples(s,3) )

, ,  = 0


    0 1
  0 4 1
  1 3 1

, ,  = 1


    0 1
  0 2 1
  1 0 1 makeTuples() , ,  = 0


    0 1
  0 4 1
  1 3 1 0 1
  00 4 1
  01 3 1 table table() expand.grid() permute <- function( population, n ){

  permutations <- do.call( expand.grid, rep( list(population), n ) )

  permutations <- apply( permutations, 1, paste, collapse = '' )

  return( permutations )

} countFrequency <- function(permutation,tuples,population){

  permutations <- paste( permutation, population, sep = '' )

  # Inner lapply applies the equality operator `==` to each
  # permutation and returns a list of TRUE/FALSE vectors.
  # Outer lapply sums the number of TRUE values in each vector. 
  frequencies <- lapply(lapply(permutations,`==`,tuples),sum)

  names( frequencies ) <- as.character( population )

  return( unlist(frequencies) )

} ldply() plyr permutationFrequency <- function( vector, n, population = unique( vector ) ){

  # Split the vector into tuples.
  tuples <- makeTuples( vector, n )

  # Coerce and compact the tuples to a vector of strings.
  tuples <- do.call(cbind,tuples)
  tuples <- apply( tuples, 1, paste, collapse = '' )

  # Generate permutations of n-1 elements from the population.
  # Turn into a named list for ldply() to work it's magic.
  permutations <- permute( population, n-1 )
  names( permutations ) <- permutations

  frequencies <- ldply( permutations, countFrequency,
    tuples = tuples, population = population )

  return( frequencies )

} require( plyr )
permutationFrequency( s, 2 )
  .id 1 0
1   1 2 3
2   0 2 7

permutationFrequency( s, 3 )
  .id 1 0
1  11 1 1
2  01 1 1
3  10 0 3
4  00 2 4

permutationFrequency( s, 4 )
  .id 1 0
1 111 0 1
2 011 1 0
3 101 0 0
4 001 1 1
5 110 0 1
6 010 0 1
7 100 0 2
8 000 2 2

permutationFrequency( sample( -1:1, 10, replace = T ), 2 )
  .id 1 -1 0
1   1 1  2 0
2  -1 0  1 2
3   0 1  0 2
-------------------------------------------------------------------------------------------------------
Week = c(rep(1:8,4))
Total = rnorm(32,1000,600)
Alarm = c(  rep("BELTWEIGHER HIGH HIGH",8), 
        rep("MICROWAVE LHS",8),
        rep("HI PRESS FILTER 2 CLOG SW",8),
        rep("LOW PRESS FILTER 2 CLOG SW",8))        )
spark <- data.frame(Week, Alarm, Total)

s <- ggplot(spark, aes(Week, Total)) +         
     opts(
        panel.background = theme_rect(size = 1, colour = "lightgray"),
        panel.grid.major = theme_blank(),
        panel.grid.minor = theme_blank(),
        axis.line = theme_blank(),
        axis.text.x = theme_blank(),
        axis.text.y = theme_blank(),
        axis.title.x = theme_blank(),
        axis.title.y = theme_blank(), 
        axis.ticks = theme_blank(),
        strip.background = theme_blank(),
        strip.text.y = theme_blank()
        #strip.text.y = theme_text(size = 7, colour = "red", angle = 90)
    )

s + facet_grid(Alarm ~.) + geom_line()
-------------------------------------------------------------------------------------------------------
p + facet_grid(fy ~ fx, labeller = label_parsed)
-------------------------------------------------------------------------------------------------------
pl <- ggplot(funny, aes(Mndr, y=Data, group=Type, col=Type))+geom_line()
      +facet_grid(.~Institution)   #your plot
nd <- data.frame(Institution=c("Q-branch","Some-Ville"),  #panel
                 Type=c("Unknown", "Tastes good"),        #color
                 Mndr=c(7,12),                            #x-coordinate of label
                 Data= c(170,50),                         #y-coordinate of label
                 Text=c("Label 1", "Label 2"))            #label text
# add labels to plot:
pl <- pl + geom_text(aes(label=Text), data=nd, hjust=0, legend=FALSE)
pl legend=FALSE geom_text
-------------------------------------------------------------------------------------------------------
spark$Alarm<-factor(spark$Alarm, levels(spark$Alarm)[c(1,4,2,3)]) lbl.fn <- function(variable, value) {  paste(spark$Rank[which(as.character(spark$Alarm)==as.character(value))],as.character(value)) }
s + facet_grid(Alarm ~ ., labeller="lbl.fn") + geom_line()
-------------------------------------------------------------------------------------------------------
label_parseall <- function(variable, value) {
    plyr::llply(value, function(x) parse(text = paste(variable, 
        x, sep = "==")))
} data <- data.frame(x = runif(10), y = runif(10), 
    gamma = sample(c("gamma[0]", "gamma[1]"), 10, rep = T))
ggplot(data, aes(x, y)) + geom_point() + facet_grid(~gamma, 
    labeller = label_parselabel)
-------------------------------------------------------------------------------------------------------
fill geom_bar ggplot(data.PE5, aes(ybands)) + geom_bar(aes(fill=factor(decide)),position="dodge") + facet_grid(~group_label) ggplot2
-------------------------------------------------------------------------------------------------------
ggplot(exstatus, aes(x=art, fill=art))+
  geom_bar(aes(y=..count../sum(..count..))) + 
  facet_grid(~type,scales="free",space="free")
-------------------------------------------------------------------------------------------------------
strip.text.x strip.text.y theme_text() qplot(hwy, cty, data = mpg) + 
      facet_grid(. ~ manufacturer) + 
      opts(strip.text.x = theme_text(size = 8, colour = "red", angle = 90)) qplot(hwy, cty, data = mpg) + 
      facet_grid(. ~ manufacturer) + 
      theme(strip.text.x = element_text(size = 8, colour = "red", angle = 90))
-------------------------------------------------------------------------------------------------------
# functions we'll need...
add.num.before.and.after <- function(vec, num = NULL)
{
    # this will add a number before and after every number in a vector.
    # the deafult adds the number which is one more then the length of the vector 
        # assuming that later we will add a zero column to a data.frame and will use that column to add the zero columns...
    if(is.null(num)) num <- rep(length(vec) +1, length(vec))
    if(length(num)==1) num <- rep(num, length(vec))

    #x <- as.list(vec)
    list.num.x.num <- sapply(seq_along(vec) , function(i) c(num[i], vec[i], num[i]),  simplify = F)
    num.x.num <- unlist(list.num.x.num)

    return(num.x.num)
}

add.0.columns.to.DF <- function(DF, zero.column.name = " ")
{
    # this function gets a data frame
    # and returns a data.frame with extra two columns (of zeros) before and after every column

    zero.column <- rep(0, dim(DF)[1])   # the column of zeros
    column.seq <- seq_len(dim(DF)[2])   # the column ID for the original data.frame

    DF.new.order <- add.num.before.and.after(column.seq)    # add the last column id before and after every element in the column id vector

    DF.and.zero <- cbind(DF, zero.column)   # making a new data.frame with a zero column at the end

    new.DF <- DF.and.zero[,DF.new.order]    # moving the zero column (and replicating it) before and after every column in the data.frame

    # renaming the zero columns to be " "
    columns.to.erase.names <- ! (colnames(new.DF) %in% colnames(DF))        
    colnames(new.DF)[columns.to.erase.names] <- zero.column.name

    return(new.DF)
}


angles.by.weight <-  function(angles,  weights = NULL)
{

    angles <- angles[-1]    # remove the 0 from "angles"
    angles <- c(angles, 2*pi) # add last slice angle
    number.of.slices = length(angles)
    if(is.null(weights)) weights <- rep(.6, number.of.slices)   # Just for the example

    slice.angle <- diff(angles)[1]

    #new.angles <- rep(0, 3*length(angles))
    new.angles <- numeric()

    for(i in seq_along(angles))
    {
        weighted.slice.angle <- slice.angle*weights[i]
        half.leftover.weighted.slice.angle <- slice.angle* ((1-weights[i])/2)

        angle1 <- angles[i] - (weighted.slice.angle + half.leftover.weighted.slice.angle)
        angle2 <- angles[i] - half.leftover.weighted.slice.angle
        angle3 <- angles[i]

        new.angles <- c(new.angles,
                        angle1,angle2,angle3)                       
    }

    new.angles.length <- length(new.angles)
    new.angles <- c(0, new.angles[-new.angles.length])

    return(new.angles)
}

# The updated stars function
stars2 <-
    function (x, full = TRUE, scale = TRUE, radius = TRUE, labels =
            dimnames(x)[[1L]], 
                locations = NULL, nrow = NULL, ncol = NULL, len = 1, key.loc = NULL, 
                key.labels = dimnames(x)[[2L]], key.xpd = TRUE, xlim = NULL, 
                ylim = NULL, flip.labels = NULL, draw.segments = FALSE, col.segments = 1L:n.seg, 
                col.stars = NA, axes = FALSE, frame.plot = axes, main = NULL, 
                sub = NULL, xlab = "", ylab = "", cex = 0.8, lwd = 0.25, 
                lty = par("lty"), xpd = FALSE, mar = pmin(par("mar"), 1.1 + 
                    c(2 * axes + (xlab != ""), 2 * axes + (ylab != ""), 1, 
            #            0)), add = FALSE, plot = TRUE, ...) 
                        0)), add = FALSE, plot = TRUE, col.radius = NA, polygon = TRUE, 
                        key.len = len,
                        segment.weights = NULL, 
                        ...)
{
    if (is.data.frame(x)) 
        x <- data.matrix(x)
    else if (!is.matrix(x)) 
        stop("'x' must be a matrix or a data frame")
    if (!is.numeric(x)) 
        stop("data in 'x' must be numeric")


    # this code was moved here so that the angles will be proparly created...
    n.seg <- ncol(x) # this will be changed to the ncol of the new x - in a few rows...
    # creates the angles
    angles <- if (full) 
        seq.int(0, 2 * pi, length.out = n.seg + 1)[-(n.seg + 1)]
    else if (draw.segments) 
        seq.int(0, pi, length.out = n.seg + 1)[-(n.seg + 1)]
    else seq.int(0, pi, length.out = n.seg)
    if (length(angles) != n.seg) 
        stop("length of 'angles' must equal 'ncol(x)'")

    # changing to allow weighted segments
    angles <- angles.by.weight(angles, segment.weights)
    #angles <- angles.by.weight.2(angles)   # try2
    # try3 
    # weights <- sample(c(.3,.9), length(angles)-1, replace = T)
    # angles <- weights / sum(weights) * 2 * pi
    # angles <- c(0,angles )




    # changing to allow weighted segments
     col.segments <- add.num.before.and.after(col.segments, "white") # for colors
     x <- add.0.columns.to.DF(x)







    n.loc <- nrow(x)
    n.seg <- ncol(x)
    if (is.null(locations)) {
        if (is.null(nrow)) 
            nrow <- ceiling(if (!is.numeric(ncol)) sqrt(n.loc) else n.loc/ncol)
        if (is.null(ncol)) 
            ncol <- ceiling(n.loc/nrow)
        if (nrow * ncol < n.loc) 
            stop("nrow * ncol <  number of observations")
        ff <- if (!is.null(labels)) 
            2.3
        else 2.1
        locations <- expand.grid(ff * 1L:ncol, ff * nrow:1)[1L:n.loc, 
            ]
        if (!is.null(labels) && (missing(flip.labels) ||
!is.logical(flip.labels))) 
            flip.labels <- ncol * mean(nchar(labels, type = "c")) > 
                30
    }
    else {
        if (is.numeric(locations) && length(locations) == 2) {
            locations <- cbind(rep.int(locations[1L], n.loc), 
                rep.int(locations[2L], n.loc))
            if (!missing(labels) && n.loc > 1) 
                warning("labels do not make sense for a single location")
            else labels <- NULL
        }
        else {
            if (is.data.frame(locations)) 
                locations <- data.matrix(locations)
            if (!is.matrix(locations) || ncol(locations) != 2) 
                stop("'locations' must be a 2-column matrix.")
            if (n.loc != nrow(locations)) 
                stop("number of rows of 'locations' and 'x' must be equal.")
        }
        if (missing(flip.labels) || !is.logical(flip.labels)) 
            flip.labels <- FALSE
    }
    xloc <- locations[, 1]
    yloc <- locations[, 2]

    # Here we created the angles, but I moved it to the beginning of the code


    if (scale) {
        x <- apply(x, 2L, function(x) (x - min(x, na.rm = TRUE))/diff(range(x, 
            na.rm = TRUE)))
    }
    x[is.na(x)] <- 0
    mx <- max(x <- x * len)
    if (is.null(xlim)) 
        xlim <- range(xloc) + c(-mx, mx)
    if (is.null(ylim)) 
        ylim <- range(yloc) + c(-mx, mx)
    deg <- pi/180
    op <- par(mar = mar, xpd = xpd)
    on.exit(par(op))
    if (plot && !add) 
        plot(0, type = "n", ..., xlim = xlim, ylim = ylim, main = main, 
            sub = sub, xlab = xlab, ylab = ylab, asp = 1, axes = axes)
    if (!plot) 
        return(locations)
    s.x <- xloc + x * rep.int(cos(angles), rep.int(n.loc, n.seg))
    s.y <- yloc + x * rep.int(sin(angles), rep.int(n.loc, n.seg))
    if (draw.segments) {
        aangl <- c(angles, if (full) 2 * pi else pi)
        for (i in 1L:n.loc) {
            px <- py <- numeric()
            for (j in 1L:n.seg) {
                k <- seq.int(from = aangl[j], to = aangl[j + 
                  1], by = 1 * deg)
                px <- c(px, xloc[i], s.x[i, j], x[i, j] * cos(k) + 
                  xloc[i], NA)
                py <- c(py, yloc[i], s.y[i, j], x[i, j] * sin(k) + 
                  yloc[i], NA)
            }
            polygon3(px, py, col = col.segments, lwd = lwd, lty = lty)
        }
    }
    else {
        for (i in 1L:n.loc) {
#            polygon3(s.x[i, ], s.y[i, ], lwd = lwd, lty = lty, 
#                col = col.stars[i])
            if (polygon)
                polygon3(s.x[i, ], s.y[i, ], lwd = lwd, lty = lty, 
                  col = col.stars[i])
            if (radius) 
                segments(rep.int(xloc[i], n.seg), rep.int(yloc[i], 
#                  n.seg), s.x[i, ], s.y[i, ], lwd = lwd, lty = lty)
                  n.seg), s.x[i, ], s.y[i, ], lwd = lwd, lty = lty, col =
col.radius)
        }
    }
    if (!is.null(labels)) {
        y.off <- mx * (if (full) 
            1
        else 0.1)
        if (flip.labels) 
            y.off <- y.off + cex * par("cxy")[2L] * ((1L:n.loc)%%2 - 
                if (full) 
                  0.4
                else 0)
        text(xloc, yloc - y.off, labels, cex = cex, adj = c(0.5, 
            1))
    }
    if (!is.null(key.loc)) {
        par(xpd = key.xpd)
        key.x <- key.len * cos(angles) + key.loc[1L]
        key.y <- key.len * sin(angles) + key.loc[2L]
        if (draw.segments) {
            px <- py <- numeric()
            for (j in 1L:n.seg) {
                k <- seq.int(from = aangl[j], to = aangl[j + 
                  1], by = 1 * deg)
                px <- c(px, key.loc[1L], key.x[j], key.len * cos(k) + 
                  key.loc[1L], NA)
                py <- c(py, key.loc[2L], key.y[j], key.len * sin(k) + 
                  key.loc[2L], NA)
            }
            polygon3(px, py, col = col.segments, lwd = lwd, lty = lty)
        }
        else {
#            polygon3(key.x, key.y, lwd = lwd, lty = lty)
            if (polygon)
                polygon3(key.x, key.y, lwd = lwd, lty = lty)
            if (radius) 
                segments(rep.int(key.loc[1L], n.seg), rep.int(key.loc[2L], 
#                  n.seg), key.x, key.y, lwd = lwd, lty = lty)
                  n.seg), key.x, key.y, lwd = lwd, lty = lty, col = col.radius)
        }


        lab.angl <- angles + if (draw.segments) 
            (angles[2L] - angles[1L])/2
        else 0
        label.x <- 1.1 * key.len * cos(lab.angl) + key.loc[1L]
        label.y <- 1.1 * key.len * sin(lab.angl) + key.loc[2L]
        for (k in 1L:n.seg) {
            text.adj <- c(if (lab.angl[k] < 90 * deg || lab.angl[k] > 
                270 * deg) 0 else if (lab.angl[k] > 90 * deg && 
                lab.angl[k] < 270 * deg) 1 else 0.5, if (lab.angl[k] <= 
                90 * deg) (1 - lab.angl[k]/(90 * deg))/2 else if (lab.angl[k] <=
                270 * deg) (lab.angl[k] - 90 * deg)/(180 * deg) else 1 - 
                (lab.angl[k] - 270 * deg)/(180 * deg))
            text(label.x[k], label.y[k], labels = key.labels[k], 
                cex = cex, adj = text.adj)
        }
    }
    if (frame.plot) 
        box(...)
    invisible(locations)
} #require(debug)
# mtrace(stars2)
stars(mtcars[1:3, 1:8],
        draw.segments = T,
        main = "Motor Trend Cars : stars(*, full = F)", full = T, col.segments = 1:2)

stars2(mtcars[1:3, 1:8],
        draw.segments = T,
        main = "Motor Trend Cars : stars(*, full = F)", full = T, col.segments = 0:3,
        segment.weights = c(.2,.2,1,1,.4,.4,.6,.9))
-------------------------------------------------------------------------------------------------------
comb <- t(as.matrix(expand.grid(5, 5, c(1:4,6),c(1:4,6))))
perms <- t(permutations(4,4))
ans <- apply(comb,2,function(x) x[perms])
ans <- unique(matrix(as.vector(ans), ncol = 4, byrow = TRUE))
-------------------------------------------------------------------------------------------------------
require(combinat)

# Returns the sums of all the possible subsets for a single combination
comb <- function(values)
    {
    sums <- NULL

    # Sum each combination of 1,2,... n-1 dice
    for (i in 1:(length(values)-1))
        {
        c <- combn(values, i)
        sums <- c(sums, colSums(c))
        }

    # Also sum all the dice
    sums <- c(sums, sum(values))

    comb <- sums
    }

# Returns TRUE if the array contains a certain value
hasVal <- function(values, n)
    {
    hasVal <- (length(which(values == n)) > 0)
    }

dice <- as.matrix(expand.grid(1:6, 1:6, 1:6, 1:6))
theSum <- 5

# Get the sums of all the subsets for each line
sums <- apply(z, 1, comb)
# See which columns of sums contain 5 
has5 <- apply(sums, 2, hasVal, theSum)
# Now count them :)
print(paste(length(which(has5 == TRUE)), " combinations over ", 
        length(has5), " have a subset that sums to ", theSum))
-------------------------------------------------------------------------------------------------------
expand.grid unique X <- expand.grid(1:6,1:6,1:6,1:6)
dim(unique(t(apply(X,1,sort))))
#[1] 126   4 X <- expand.grid(1:6,1:6,1:6,1:6)
dim(subset(X, Var1>=Var2 & Var2>=Var3 & Var3>=Var4))
# [1] 126   4
-------------------------------------------------------------------------------------------------------
f<-function(x,y){if(x=="speed"){c(y[-length(y)], "Total")} else y}
ggplot(cars, aes(x=dist))+geom_bar()+facet_grid(.~speed, margin=T, labeller=f)
-------------------------------------------------------------------------------------------------------
>>> xi = linspace(min(X), max(X))
>>> yi = linspace(min(Y), max(Y))
>>> zi = griddata(X, Y, Z, xi, yi)
>>> contour(xi, yi, zi) >>> from mpl_toolkits.mplot3d import Axes3D
>>> fig = figure()
>>> ax = Axes3D(fig)
>>> xim, yim = meshgrid(xi, yi)
>>> ax.plot_surface(xim, yim, zi)
>>> show()

>>> help(meshgrid(x, y))
    Return coordinate matrices from two coordinate vectors.
    [...]
    Examples
    --------
    >>> X, Y = np.meshgrid([1,2,3], [4,5,6,7])
    >>> X
    array([[1, 2, 3],
           [1, 2, 3],
           [1, 2, 3],
           [1, 2, 3]])
    >>> Y
    array([[4, 4, 4],
           [5, 5, 5],
           [6, 6, 6],
           [7, 7, 7]]) >>> fig = figure()
>>> ax = Axes3D(fig)
>>> ax.contour(xi, yi, zi) # ax.contourf for filled contours
>>> show()
-------------------------------------------------------------------------------------------------------
# You will probably read these from an external file or a database
goodWords <- c("candesartan cilexetil", "glyburide", "nifedipine", "digoxin", "blabla", "warfarin", "hydrochlorothiazide")
badWords <- c("no significant", "other drugs")

mytext <- "no significant drug interactions have been reported in studies of candesartan cilexetil given with other drugs such as glyburide, nifedipine, digoxin, warfarin, hydrochlorothiazide."
mytext <- tolower(mytext) # Let's make life a little bit easier...

goodPos <- NULL
badPos <- NULL

# First we find the good words
for (w in goodWords)
    {
    pos <- regexpr(w, mytext)
    if (pos != -1)
        {
        cat(paste(w, "found at position", pos, "\n"))
        }
    else    
        {
        pos <- NA
        cat(paste(w, "not found\n"))
        }

    goodPos <- c(goodPos, pos)
    }

# And then the bad words
for (w in badWords)
    {
    pos <- regexpr(w, mytext)
    if (pos != -1)
        {
        cat(paste(w, "found at position", pos, "\n"))
        }
    else    
        {
        pos <- NA
        cat(paste(w, "not found\n"))
        }

    badPos <- c(badPos, pos)
    }

# Note that we use -badPos so that when can calculate the distance with rowSums
comb <- expand.grid(goodPos, -badPos)
wordcomb <- expand.grid(goodWords, badWords)
dst <- cbind(wordcomb, abs(rowSums(comb)))

mn <- which.min(dst[,3])
cat(paste("The closest good-bad word pair is: ", dst[mn, 1],"-", dst[mn, 2],"\n"))
-------------------------------------------------------------------------------------------------------
Rncurses getPass<-function(){  
  require(tcltk);  
  wnd<-tktoplevel();tclVar("")->passVar;  
  #Label  
  tkgrid(tklabel(wnd,text="Enter password:"));  
  #Password box  
  tkgrid(tkentry(wnd,textvariable=passVar,show="*")->passBox);  
  #Hitting return will also submit password  
  tkbind(passBox,"<Return>",function() tkdestroy(wnd));  
  #OK button  
  tkgrid(tkbutton(wnd,text="OK",command=function() tkdestroy(wnd)));  
  #Wait for user to click OK  
  tkwait.window(wnd);  
  password<-tclvalue(passVar);  
  return(password);  
}
-------------------------------------------------------------------------------------------------------
#loess and error curves almost just like ggplot2
op <- par(las=1, mar = c(3,3,1,1))
n <- 30
x <- sort(rnorm(n)) #(varying density in predictor)
x <- x + abs(min(x))
x <- x/max(x)*2*pi 
y <- sin(x)+rnorm(n) #(curvy)
m <- loess(y~x)
xx <- seq(min(x), max(x), (max(x)-min(x))/1000) #increase density of values to predict over to increase quality of curve
f <- predict(m, xx, se = TRUE)
ci <- f$se * qt(0.975, f$df)
cih <- f$fit + ci
cil <- f$fit - ci
plot(x,y, ylim = c(min(cil,y), max(cih,y)), cex.axis = 0.85, xlab = '', ylab = '', type = 'n')
title(xlab = 'x', ylab = 'y',line = 2)
grid(col = 'gray')
points(x,y, pch = 19, cex = 0.65)
lines(xx, f$fit, col = 'blue', lwd = 1.2)
xx <- c(xx, rev(xx))
yy <- c(cil, rev(cih))
polygon(xx, yy, col=rgb(0.1,0.1,0.1,0.25), border = NA)
par(op)

#qplot(x,y, geom = 'point') + stat_smooth()
-------------------------------------------------------------------------------------------------------
half=FALSE panel.axis(side=c("bottom"),
           at=c(0, 25, 50, 75, 100),
           labels=c("0%", "25%", "50%", "75%", "100%"),
           rot=0, half=FALSE, ticks=TRUE) panel.grid panel.abline panel.barchart() panel.grid(h=FALSE, v=-1)
-------------------------------------------------------------------------------------------------------
R> qplot(hwy, cty, data = mpg) + 
       facet_grid(. ~ manufacturer) + 
       theme(strip.text.x = element_text(size = 8, colour = "orange", angle = 90))
-------------------------------------------------------------------------------------------------------
gri <- expand.grid(ran1,ran2,ran3,ran4,ran5)
gri[,6] <- NA
gri <- as.matrix(gri) gri[,6]<- apply (Rrecon, 1, function(x){
    delta_S(Ro=as.vector(x)
    ,Rr=data_base$bck, Ir=data_base$Ir, S1=data_base$s1
    ,S2=data_base$s2, S3=data_base$s3, S4=data_base$s4
    ,chromaty="tetra")
    })
-------------------------------------------------------------------------------------------------------
stat_function library(ggplot2)
reg.fun <- function(x, par1, par2){exp(-x*par1) + par2} #functional form
reg <- data.frame(g=factor(1:3), par1=(1:3)/10, par2=1:3)  #parameters for 3 groups

#generate data from reg.fun
dd <- expand.grid(x=0:9, g=reg$g)         #set x values, and 3 groups from reg
dd <- merge(dd, reg)                      #"import" parameters
dd$mn <- with(dd, reg.fun(x, par1, par2)) #value of function for given x's
dd$y <- rnorm(30, mean=dd$mn, sd=0.5)     #add variability
dd <- subset(dd, select=c(g,x,y))         #remove auxiliary variables 

#similarly to above generate values for the function on a fine grid of x values
pred.dd <- expand.grid(x=seq(0,9, length=101), g=levels(dd$g))
pred.dd <- merge(pred.dd, reg)
pred.dd$y <- with(pred.dd, reg.fun(x, par1, par2))

#draw the plot
p <- qplot(x,y, colour=g, data=dd)  #scatterplot of data
p + geom_line(data=pred.dd)         #add the curves of the functions
-------------------------------------------------------------------------------------------------------
reshape n_questions <- 100
n_responses <- c(North = 89, East = 37, South = 57, West = 71)
n_locations <- length(n_responses)
total_responses <- sum(n_responses)

survey <- data.frame(
  question = unlist(lapply(n_responses, function(x) rep(seq_len(n_questions), each = x))),      
  location = rep(c("North", "East", "South", "West"), times = n_questions * n_responses),
  score = sample(n_questions, n_questions * total_responses, replace = TRUE)
) library(lattice)
library(latticeExtra)
useOuterStrips(histogram(~ score | question * location, data = survey)) library(ggplot2)
ggplot(survey, aes(score)) + geom_histogram() + facet_grid(location ~ question)
-------------------------------------------------------------------------------------------------------
# Using the Iris data
> i <- iris
> levels(i$Species)
[1] "setosa"     "versicolor" "virginica" 
> levels(i$Species) <- c("S", "Ve", "Vi")
> ggplot(i, aes(Petal.Length)) + stat_bin() + facet_grid(Species ~ .)
-------------------------------------------------------------------------------------------------------
library(ggplot2)
value<-c(rpois(500,1.5))
group<-rep(c("A","B"),250)
data<-data.frame(value,group)
ggplot(data,aes(value)) + 
        geom_histogram(aes(y=..density..), binwidth=1,position="identity") + 
        facet_grid(.~group) + 
        stat_function(geom = "line", fun = dpois, arg = list(lambda = 1.5), colour = "red", fill = NA, n = 9) ggplot(data,aes(value)) + 
        geom_histogram(aes(y=..count..), binwidth=1,position="identity") + 
        facet_grid(.~group) + 
        stat_function(geom = "line", fun = function(..., total){dpois(...) * total}, arg = list(lambda = 1.5, total = 250), colour = "red", fill = NA, n = 9)
-------------------------------------------------------------------------------------------------------
X2 data geom_text library(ggplot2)

#create data with the desired structure
dd <- expand.grid(facet=LETTERS[1:4], group=letters[1:5], subject=factor(1:10))
dd$value <- exp(rnorm(nrow(dd)))

#calculate CV's
ddcv <- ddply(dd, .(facet,group), 
     function(x)c(CV=sd(x$value)/mean(x$value), maxX=max(x$value)))
ddcv$CV <- round(ddcv$CV,1)

#make plots
p <- qplot(group, value, colour=subject, data=dd) + facet_wrap(~facet)
p + geom_text(aes(x=group, y=maxX+1, label=CV), colour="black", data=ddcv)
-------------------------------------------------------------------------------------------------------
carrots <- rnorm(100000,5,2)
cukes <- rnorm(50000,7,2.5) ## calculate the density - don't plot yet
densCarrot <- density(carrots)
densCuke <- density(cukes)
## calculate the range of the graph
xlim <- range(densCuke$x,densCarrot$x)
ylim <- range(0,densCuke$y, densCarrot$y)
#pick the colours
carrotCol <- rgb(1,0,0,0.2)
cukeCol <- rgb(0,0,1,0.2)
## plot the carrots and set up most of the plot parameters
plot(densCarrot, xlim = xlim, ylim = ylim, xlab = 'Lengths',
     main = 'Distribution of carrots and cucumbers', 
     panel.first = grid())
#put our density plots in
polygon(densCarrot, density = -1, col = carrotCol)
polygon(densCuke, density = -1, col = cukeCol)
## add a legend in the corner
legend('topleft',c('Carrots','Cucumbers'),
       fill = c(carrotCol, cukeCol), bty = 'n',
       border = NA)
-------------------------------------------------------------------------------------------------------
nrows <- 6
A <- data.frame(a = runif(nrows), b = runif(nrows), c = runif(nrows))
B <- data.frame(z = rnorm(nrows), y = rnorm(nrows)) expand.grid counter <- expand.grid(seq_along(A), seq_along(B))
f <- function(x) 
{
  cor.test(A[, x["Var1"]], B[, x["Var2"]])$estimate
} apply stats <- apply(counter, 1, f)
names(stats) <- paste(names(A)[counter$Var1], names(B)[counter$Var2], sep = ",")
stats
-------------------------------------------------------------------------------------------------------
mt + facet_grid(cyl ~ ., scales="free")
-------------------------------------------------------------------------------------------------------
#Assume ID, and Ward are factors, and WRES. shouldn't be
pkso$ID<-as.factor(pkso$ID)
pkso$WARD<-as.factor(pkso$WARD)
pkso$WRES<-as.numeric(pkso$WRES.)

#display clean data for SO fans
dput(pkso)

library(ggplot2)

#draw a graph TAD Vs IPRE,DV,PRED as a whole which i have no issues in producing them.
#first melt the data into a narrow format, then plot
pksomelt<-melt(pkso, id.vars=c("ID","TIME","TAD","AMT","BL","WARD"))
pksomelt$value<-as.numeric(pksomelt$value)
#now subset that data for what we want
pksomelt<-subset(pksomelt,variable %in% c("IPRE","DV","PRED"))
#now plot, using facet_wrap to seperate variables
pkplot1<-ggplot(pksomelt, aes(TAD, value)) + 
        geom_point() +
        scale_shape(solid = FALSE) + 
        facet_wrap( ~ variable)

print(pkplot1)
#Second part is I am trying to produce an individual graph for ID (n=35) so 35 graph for (TAD Vs IPRE,DV,PRED)
#so, for an individual plot
pkplot2<-ggplot(subset(pksomelt, ID == "1"), aes(TAD, value)) + 
        geom_point() +
        scale_shape(solid = FALSE) + 
        facet_wrap( ~ variable)

print(pkplot2)
#  or, for presenting, you could do all 35 spread across 6 plots, but seperated, by using facet_grid
i<-ceiling(max(as.numeric(pksomelt$ID))/6)  #  Calculate number of ID's per plot

pkplot3<-ggplot(subset(pksomelt, as.numeric(pksomelt$ID) > (i*0) & as.numeric(pksomelt$ID) < (i*1)+1), 
                aes(TAD, value)) + 
        geom_point() +
        scale_shape(solid = FALSE) + 
        facet_grid(ID ~ variable)

print(pkplot3)

pkplot4<-ggplot(subset(pksomelt, as.numeric(pksomelt$ID) > (i*1) & as.numeric(pksomelt$ID) < (i*2)+1), 
                aes(TAD, value)) + 
        geom_point() +
        scale_shape(solid = FALSE) + 
        facet_grid(ID ~ variable)

print(pkplot4) #  ect etc
#Third Part is to try and produce a graph based on Ward (TAD Vs IPRE,DV,PRED) which will have 5 graphs.
#Again, use Facet_grid to seperate different wards, let's also add lines to show it's possible
pkplot5<-ggplot(pksomelt, aes(TAD, value)) + 
        geom_point(aes(colour=ID)) + geom_line(aes(colour=ID)) + 
        scale_shape(solid = FALSE) + 
        facet_grid(WARD ~ variable, scales="free")

print(pkplot5)
-------------------------------------------------------------------------------------------------------
x <- sort(rnorm(1000))
y <- rnorm(1000)
z <- rnorm(1000) + atan2(x,y)
plot3d(x, y, z, col=rainbow(1000)) grp <- gl(5, 200) ## 5 groups 200 members each
## now select the colours we want
cols <- 1:5

## Now plot
plot3d(x, y, z, col=cols[grp]) X <- 1:10
Y <- 1:10
## Z is now a 100 row object of X,Y combinations
Z <- expand.grid(X = X, Y = Y)
## Add in Z1, which is the 3rd variable
## X,Y,Z1 define the surface, which we colour according to
## 4th variable Z2
Z <- within(Z, {
    Z1 <- 1.2 + (1.4 * X) + (-1.9 * Y)
    Z2 <- 1.2 + (1.4 * X) - (1.2 * X^2) + (1.9 * Y) + (-1.3 * Y^2)
    Z3 <- 1.2 + (1.4 * X) + (-1.9 * Y) + (-X^2) + (-Y^2)})
## show the data
head(Z)
## Set-up the rgl device
with(Z, plot3d(X, Y, Z1, type = "n"))
## Need a scale for Z2 to display as colours
## Here I choose 10 equally spaced colours from a palette
cols <- heat.colors(10)
## Break Z2 into 10 equal regions
cuts <- with(Z, cut(Z2, breaks = 10))
## Add in the surface, colouring by Z2
with(Z, surface3d(1:10,1:10, matrix(Z1, ncol = 10),
                   color = cols[cuts], back = "fill"))
with(Z, points3d(X, Y, Z1, size = 5)) ## show grid X,Y,Z1 Z1 Z3 ## Set-up the rgl device plotting Z3, a curved surface
with(Z, plot3d(X, Y, Z3, type = "n"))
with(Z, surface3d(1:10,1:10, matrix(Z3, ncol = 10),
                   color = cols[cuts], back = "fill")) Z2
-------------------------------------------------------------------------------------------------------
expand.grid(c(-1,1), c(-1,1), c(-1,1), c(-1,1), c(-1,1))
-------------------------------------------------------------------------------------------------------
N   <- 5
vec <- c(-1, 1)
lst <- lapply(numeric(N), function(x) vec)
as.matrix(expand.grid(lst))
-------------------------------------------------------------------------------------------------------
expand.grid() apply() R> work <- expand.grid(1:3,1:3)
R> work
  Var1 Var2
1    1    1
2    2    1
3    3    1
4    1    2
5    2    2
6    3    2
7    1    3
8    2    3
9    3    3
R> apply(work, 1, function(z) prod(z))
[1] 1 2 3 2 4 6 3 6 9
R>
-------------------------------------------------------------------------------------------------------
scales="free_y" qplot(x, value, data=df, geom=c("smooth")) + facet_grid(~variable, scales="free_y")
-------------------------------------------------------------------------------------------------------
a<-data.frame("/../vertical_value.csv",sep=",",header=F)
am<-melt(t(a))
am <- na.omit(am) ## ADD THIS LINE
dataset<-expand.grid(X = 1:500, H = seq(1,25,by=1))
dataset$axp<-am$value
g<-ggplot(dataset, aes(x = X, y = H, fill = axp)) + geom_tile()
-------------------------------------------------------------------------------------------------------
df$x group jitter ggplot(data=df, aes(x=group,y=y,color=group)) + geom_point() +
geom_jitter(position = position_jitter(width = 0.4)) +
geom_errorbar(stat = "hline", yintercept = "mean",
  width=0.8,aes(ymax=..y..,ymin=..y..)) df$x = factor(df$x)

ggplot(data = df, aes(x, y, group=group)) + 
facet_grid(.~group,space="free",scales="free_x") + 
geom_point() + 
geom_line(stat = "hline", yintercept = "mean")
-------------------------------------------------------------------------------------------------------
expand.grid(A, B, C) d = expand.grid(x = A, y = B, z = C)
d = mdply(d, f) d = mdply(d, 'paste', sep = '+');
-------------------------------------------------------------------------------------------------------
expand.grid f <- function(x,y,z) paste(x,y,z,sep="+")
d <- expand.grid(x=A, y=B, z=C)
d$D <- do.call(f, d) do.call d data.frame list do.call d f
-------------------------------------------------------------------------------------------------------
library(reshape2) # from CRAN

# sample data
d <- data.frame(expand.grid(state=gl(2,2),gender=gl(2,1, labels=c("Men","Wemon"))),
  salaly=runif(8))

d2 <- dcast(d, state~gender, sum)
d2$frac <- d2$Wemon/(d2$Men+d2$Wemon)
-------------------------------------------------------------------------------------------------------
gamma <- 1:3 
beta <- 1:4
gb.df <-expand.grid(gamma=gamma, beta=beta)
mfun <- dt
mapply ("mfun", x=gb.df$gamma, df=gb.df$beta, MoreArgs=list(ncp=1, log=FALSE) )
    [1] 0.26355595 0.14379745 0.07896827 0.31785177 0.17910975 0.08636815
    [7] 0.34118167 0.19555939 0.08572842 0.35411486 0.20513016 0.08355531
-------------------------------------------------------------------------------------------------------
a <- expand.grid(x=1:3, y=1:2)
f <- function(df){qplot(x, y, data=a, main=deparse(substitute(df)))}
f(a)
-------------------------------------------------------------------------------------------------------
slo<-0.5 #slope of underlying trend
sta<--0.5 #starting y value
amp<-0.2 #amplitude of sine wave
fre<-3 #frequency of sine wave
noi<-0.8 #amplitude of noise term
x<-seq(0,2,0.01)
y<-sta+(slo*x)+(amp*sin(fre*x)) #y no noise
ywnoise<-y+(noi*(runif(length(x))-0.5)) #y with noise

plot(x,ywnoise)
lines(x,y, col="orange")
grid()
-------------------------------------------------------------------------------------------------------
ggplot2 dts <- as.Date("20050101", '%Y%m%d') + seq(0,1000,15)
A <- data.frame( Dates = dts, Gas = 4000 + cumsum(abs( rnorm(length(dts), 100, 30)))) A DayOfYear GasDiff A <- transform( A,               
               Year = format(Dates, '%Y'),
               DayOfYear = as.numeric( format(Dates, '%j')),
               GasDiff = c(diff( Gas ),NA)) ggplot2 require(ggplot2)
ggplot(A, aes(Dates, GasDiff)) + geom_line( aes(colour = Year)) ggplot(A, aes(DayOfYear, GasDiff)) + geom_line( )  + facet_grid(Year ~ .) ggplot(A, aes(DayOfYear, GasDiff)) + 
  geom_line( aes(colour = Year) )  + 
  geom_point( aes(shape = Year))
-------------------------------------------------------------------------------------------------------
..density.. y aesthetic scale_x_discrete test2 ggplot(data = test, aes(x = as.numeric(test2)))+ 
geom_bar(aes(y = ..density..), binwidth = .5)+ 
scale_x_discrete(limits = sort(unique(test$test2))) + 
facet_grid(~test1) + xlab("Test 2") + ylab("Density") test <- data.frame(
    test1 = sample(letters[1:2], 100, replace = TRUE), 
    test2 = sample(letters[3:8], 100, replace = TRUE)
)
-------------------------------------------------------------------------------------------------------
# first make a dataframe with frequencies
df <- as.data.frame(with(test, table(test1,test2)))
# or with count() from plyr package as Hadley suggested
df <- count(test, vars=c('test1', 'test2'))
# next: compute percentages per group
df <- ddply(df, .(test1), transform, p = Freq/sum(Freq))
# and plot
ggplot(df, aes(test2, p))+geom_bar()+facet_grid(~test1) + scale_y_continuous(formatter = "percent") + scale_y_continuous(labels = percent_format())
-------------------------------------------------------------------------------------------------------
ggplot(test, aes(test2)) + 
    geom_bar(aes(y = (..count..)/sum(..count..))) + 
    facet_grid(~test1) aes(y = (..count..)/sum(..count..)) ggplot(test, aes(test2)) +
    geom_bar(aes(y = (..count..)/sum(..count..))) + 
    facet_grid(~test1) +
    scale_y_continuous('', formatter="percent") formatter = "percent") scale_y_continuous(labels = percent_format())
-------------------------------------------------------------------------------------------------------
library(rpanel)    

lvm.draw <- function(panel) {    
  x=0:20    
  plot(x, panel$int + (panel$slo*x), ylim=panel$data, ylab="y", main="Adam's Super Duper Interactive Graph", typ="l", lwd=3, col="red")    
  grid()    
  panel    
}    

ylimdat<-c(-50,50)    
panel <- rp.control(title = "Adam's Panel", data=ylimdat, slo=0.5, int=1.0, size=c(300, 160))    
rp.slider(panel, var=slo, from=-5, to=5, action=lvm.draw, title="Slope", pos=c(5, 5, 290, 70), showvalue=TRUE)    
rp.slider(panel, var=int, from=-50, to=50, action=lvm.draw, title="Intercept", pos=c(5, 70, 290, 90), showvalue=TRUE)
-------------------------------------------------------------------------------------------------------
g <- ggplot(df2, aes(x=Y, y=label)) + geom_point()
# add manual scale
g <- g+ scale_y_discrete(limits=c("0","1","1 cent","5 cent","6"))
g <- g + facet_grid(incentive ~ .,   scale="free")
g <- g + geom_errorbarh(aes(xmax = Y + se, xmin = Y - se))  
g <- g + geom_vline(xintercept=1/6, linetype=2, colour="red") 
g <- g + opts(title="% Subjects Choosing Non-Focal Image",
      strip.text.y = theme_text()
      ) + xlab("%") + ylab("Groups")
-------------------------------------------------------------------------------------------------------
grid.newpage() ## If you're using ggplot

grid() ## If you just want to activate the device.
-------------------------------------------------------------------------------------------------------
import matplotlib.pyplot as PLT
from matplotlib.offsetbox import AnnotationBbox, OffsetImage
from matplotlib._png import read_png

fig = PLT.gcf()
fig.clf()
ax = PLT.subplot(111)

# add a first image
arr_hand = read_png('/path/to/this/image.png')
imagebox = OffsetImage(arr_hand, zoom=.1)
xy = [0.25, 0.45]               # coordinates to position this image

ab = AnnotationBbox(imagebox, xy,
    xybox=(30., -30.),
    xycoords='data',
    boxcoords="offset points")                                  
ax.add_artist(ab)

# add second image
arr_vic = read_png('/path/to/this/image2.png')
imagebox = OffsetImage(arr_vic, zoom=.1)
xy = [.6, .3]                  # coordinates to position 2nd image

ab = AnnotationBbox(imagebox, xy,
    xybox=(30, -30),
    xycoords='data',
    boxcoords="offset points")
ax.add_artist(ab)

# rest is just standard matplotlib boilerplate
ax.grid(True)
PLT.draw()
PLT.show()
-------------------------------------------------------------------------------------------------------
ggplot2 require(ggplot2)
require(reshape)
df <- data.frame(time = 1:10,
                 a = cumsum(rnorm(10)),
                 b = cumsum(rnorm(10)),
                 c = cumsum(rnorm(10)))
df <- melt(df ,  id = 'time', variable_name = 'series')

# plot on same grid, each series colored differently -- 
# good if the series have same scale
ggplot(df, aes(time,value)) + geom_line(aes(colour = series))

# or plot on different plots
ggplot(df, aes(time,value)) + geom_line() + facet_grid(series ~ .)
-------------------------------------------------------------------------------------------------------
a b c a b c expand.grid(a, b, c) slice.expand <- function(..., dimension = 1) {
    L <- lapply(list(...), seq_along)
        n <- length(L)
    ix <- rowSums(do.call(expand.grid, L) == n) >= (n-dimension)
    expand.grid(...)[ix, ]
}

# test
a <- b <- c <- LETTERS[1:3]
slice.expand(a, b, c, dimension = 1)
slice.expand(a, b, c, dimension = 2)
slice.expand(a, b, c, dimension = 3)
-------------------------------------------------------------------------------------------------------
library(faraway)
data(pima)
plot(Species ~ Area, data=gala)
grid(nx= NULL, ny = NULL, lty = 1, lwd = 1, col="gray60",equilogs = TRUE)
-------------------------------------------------------------------------------------------------------
install.packages("geozoo")
library(geozoo) p = 4
n = 1000

# Cube with points on it's face.  
# A 3D version would be a box with solid walls and a hollow interior.
cube.face(p)

# Hollow sphere
sphere.hollow(p, n)


# Solid cube
cube.solid.random(p, n)
cube.solid.grid(p, 10) # evenly spaced points

# Solid Sphere
sphere.solid.random(p, n)
sphere.solid.grid(p, 10) # evenly spaced points # Cube with points along it's edges.  
cube.dotline(4)
-------------------------------------------------------------------------------------------------------
data("economics")
dat.m <- melt(economics, measure.vars=c("pop", "unemploy")) ggplot(dat.m, aes(x=date, y=value)) + geom_line() + facet_grid(variable~., scales="free_y")
-------------------------------------------------------------------------------------------------------
library(rpanel)

#Generate the x1 and x2 data
n1 <- rnorm(500)
n2 <- rnorm(200)
x1 <- c(n1, rep(0,100), n2, rep(0,150))
x2 <- c(rep(0,50), 2*n1, rep(0,150), 3*n2, rep(0,50))

#Build the panel function that will draw/update the graph
lvm.draw <- function(panel) {
       plot(x=(1:length(panel$dat3))+panel$off, y=panel$dat3, ylim=panel$dat1, xlab="", ylab="y", main=paste("Alignment Graph   Offset = ", panel$off, "   Scale = ", panel$sca, sep=""), typ="l")
       lines(x=1:length(panel$dat3), y=panel$sca*panel$dat4, col="red")
       grid()
       panel
}

#Build the panel
xlimdat <- c(1, length(x1))
ylimdat <- c(-5, 5)
panel <- rp.control(title = "Eye-Ball-It", dat1=ylimdat, dat2=xlimdat, dat3=x1, dat4=x2, off=100, sca=1.0, size=c(300, 160))
rp.slider(panel, var=off, from=-500, to=500, action=lvm.draw, title="Offset", pos=c(5, 5, 290, 70), showvalue=TRUE)
rp.slider(panel, var=sca, from=0, to=2, action=lvm.draw, title="Scale", pos=c(5, 70, 290, 90), showvalue=TRUE)
-------------------------------------------------------------------------------------------------------
m m <- ggplot(mydata, aes(x=T_MEAN))
m + geom_histogram(aes(y = ..density..)) + geom_density() + facet_grid(~ POSCAT) m <- ggplot(mydata, aes(x=T_MEAN))
m <- m + geom_histogram(aes(y = ..density..)) + geom_density() 
m + facet_grid(~ POSCAT)
-------------------------------------------------------------------------------------------------------
p1 p2 ggplot colour faceting melt melt melted test.m <- melt(test, id.var = "Type") > str(test.m)
'data.frame':   12 obs. of  3 variables:
 $ Type    : Factor w/ 3 levels "One","Three",..: 1 3 1 1 2 2 1 3 1 1 ...
 $ variable: Factor w/ 2 levels "RatingA","RatingB": 1 1 1 1 1 1 2 2 2 2 ...
 $ value   : int  3 5 5 7 4 8 36 53 57 74 ... test.m$Type <- factor(test.m$Type, c("One", "Three", "Two"), c("One", "Two", "Three")) ggplot(test.m, aes(x = Type, y = value, group = variable, colour = variable)) + 
stat_summary(fun.y = "mean", geom = "point") ggplot(test.m, aes(x = Type, y = value, group = variable)) + 
stat_summary(fun.y = "mean", geom = "point") +
facet_grid(variable ~ ., scales = "free") scales = "free"
-------------------------------------------------------------------------------------------------------
nr <- length(rname)
nc <- length(cname)

m <- matrix(list(), nr, nc, dimnames = list(rname, cname))

m[["u", "ave"]] <- ave.u

# etc. rnm cnm g m rnm <- c("euclidean", "maximum", "manhattan")
cnm <- c("ave", "single")
g <- expand.grid(rnm, cnm)
f <- function(i) hclust(dist(USArrests, g[i,1]), g[i,2])
m <- matrix(lapply(1:nrow(g), f), length(rnm), dimnames = list(rnm, cnm)) > m[["euclidean", "single"]]

Call:
hclust(d = dist(USArrests, g[i, 1]), method = g[i, 2])

Cluster method   : single 
Distance         : euclidean 
Number of objects: 50
-------------------------------------------------------------------------------------------------------
d <- data.frame(expand.grid(x=letters[1:2], co=letters[3:4]), y=runif(4))
d <- transform(d, Lo=y-1, Hi=y+1)

ggplot(d, aes(x, y, colour=co)) + 
  geom_point(position=position_dodge(width=0.3)) +
  geom_errorbar(aes(ymin=Lo, ymax=Hi), width=0.15, 
    position=position_dodge(width=0.3))
-------------------------------------------------------------------------------------------------------
mgcv sp::overlay in.out() library(mgcv)
data(columb.polys)
bnd <- columb.polys[[2]]
plot(bnd,type="n")
polygon(bnd)
x <- seq(7.9,8.7,length=20)
y <- seq(13.7,14.3,length=20)
gr <- as.matrix(expand.grid(x,y))
inside <- in.out(bnd,gr)
points(gr,pch=as.numeric(inside)+1)
-------------------------------------------------------------------------------------------------------
fill scale_colour_manual colour #Sample data
df <- data.frame(
    divergence = rnorm(10), 
    exons = paste("E", sample(1:20, 10, TRUE), sep = ""), 
    probset_id = sample(letters, 10, FALSE) 
)

#Binary flag for fill
df$fill <- with(df, ifelse(divergence > .3, 1,0))


ggplot(data = df, aes(as.character(exons), divergence, fill = factor(fill))) +
    geom_histogram(colour = "red", legend = FALSE) +
    scale_fill_manual(values = c("1" = "red", "0" = "white"), legend = FALSE) +
    facet_grid(~ probset_id, scales="free_x", space= "free") +
    theme_bw() + opts(title="GRP78/HSPA5  (HRN vs LR)") set.seed()
-------------------------------------------------------------------------------------------------------
min() max() ggplot(df, aes(x=x)) + 
  geom_bar(binwidth=0.5) + 
  facet_grid(~fac) + 
  scale_x_continuous(breaks = c(min(df$x), 0, max(df$x))
    , labels = c(paste( 100 * round(min(df$x),2), "%", sep = ""), paste(0, "%", sep = ""), paste( 100 * round(max(df$x),2), "%", sep = ""))
    ) opts(axis.text.x = theme_text(angle = 90, hjust = 0)) breaks labels scale_x_continuous myBreaks <- function(x){
    breaks <- c(min(x),median(x),max(x))
    names(breaks) <- attr(breaks,"labels")
    breaks
}

ggplot(df, aes(x=x)) + 
  geom_bar(binwidth=0.5) + 
  facet_grid(~fac) + 
  scale_x_continuous(breaks = myBreaks,labels = percent_format()) + 
  opts(axis.text.x = theme_text(angle = 90, hjust = 1,size = 5))
-------------------------------------------------------------------------------------------------------
a if(sum(id) !=0) { ... } xx <- apply(outcomes,1,function(p){
    id <- apply(regulationtable,1,function(i)
      sum(i != p ) == 0)
    if(sum(id) !=0)
     cbind(as.data.frame(id[id]),t(p))
})

write.table(do.call(rbind,xx),file="file") outcomes <- expand.grid(c(0,1),c(0,1),c(0,1),c(0,1))

regulationtable <- data.frame(
    t1=sample(0:1,10,replace=T),
    t2=sample(0:1,10,replace=T),
    t3=sample(0:1,10,replace=T),
    t4=sample(0:1,10,replace=T)
)
rownames(regulationtable) <- paste("Gene",1:10,sep="-")
-------------------------------------------------------------------------------------------------------
# add a height rank variable to the data frame
two_groups = ddply(two_groups, .(group), transform, hrank = rank(height));

# plot the graph

p_two_groups <- ggplot(two_groups, aes(-hrank, height)) +
  geom_bar(stat = "identity") +
  facet_grid(. ~ group, scales = "free_x") +
  opts(axis.text.x = theme_blank()) +
  geom_text(aes(y = 0, label = category, vjust = 1.5))
-------------------------------------------------------------------------------------------------------
two_groups <- transform(two_groups, category2 = factor(paste(group, category)))
two_groups <- transform(two_groups, category2 = reorder(category2, rank(height)))

ggplot(two_groups, aes(category2, height)) +
  geom_bar(stat = "identity") +
  facet_grid(. ~ group, scales = "free_x") +
  scale_x_discrete(labels=two_groups$category, breaks=two_groups$category2)
-------------------------------------------------------------------------------------------------------
expGPA  <- outer(relGPA, avgGPA, FUN=f) # See below for way to make this "work" expand.grid expGPA2 <-expand.grid(relGPA, avgGPA)
expGPA2$fn <- apply(expGPA2, 1, f) Vectorize apply sum x > expGPA2$fn <- apply(expGPA2, 1, function(x) x[1]/x[2])
> str(expGPA2)
'data.frame':   48 obs. of  3 variables:
 $ Var1: num  -1.5 -1.3 -1.1 -0.9 -0.7 ...
 $ Var2: num  -2 -2 -2 -2 -2 -2 -2 -2 -2 -2 ...
 $ fn  : num  0.75 0.65 0.55 0.45 0.35 ...
 - attr(*, "out.attrs")=List of 2
  ..$ dim     : int  16 3
  ..$ dimnames:List of 2
  .. ..$ Var1: chr  "Var1=-1.5" "Var1=-1.3" "Var1=-1.1" "Var1=-0.9" ...
  .. ..$ Var2: chr  "Var2=-2" "Var2= 0" "Var2= 2" sum 1/(1+exp( relGPA*pred.model$coef[1] + avgGPA*pred.model$coef[2]) # all vectorized fns
-------------------------------------------------------------------------------------------------------
t <- structure(list(A = 0.286945, C = 0.322006, G = "0.1473610.2436880.081520-0.4466031.130529NC_000846", T = "Chordata", `(A-T)/(A+T)` = "Rheiformes", `(G-C)/(G+T)` = "Aves", `(A+T)/(G+C)` = 0.39562, accession = "0.1334170.0917400.3792240.021160-0.0884933.441356NC_000857", Phylum = "Arthropoda", Order = "Diptera", Class = "Insecta"), .Names = c("A", "C", "G", "T", "(A-T)/(A+T)", "(G-C)/(G+T)", "(A+T)/(G+C)", "accession", "Phylum", "Order", "Class"), class = "data.frame", row.names = c(NA, -1L)) dev.off t=read.table("txt-part.txt", stringsAsFactors=FALSE)
names( t ) <- c("A","C","G","T","(A-T)/(A+T)","(G-C)/(G+T)","(A+T)/(G+C)","accession","Phylum","Order","Class")
phy=unique(t$Phylum)

for (x in phy){ 
    if(x != "???:???") {
    test<-subset(t, Phylum==x)
    dat <- melt(test, measure=c("A", "C" , "G" , "T" , "(A-T)/(A+T)", "(G-C)/(G+T)","(A+T)/(G+C)"))
    p <- ggplot(dat, aes(Class,value , color=variable))  + geom_boxplot() +geom_jitter()   +  facet_grid(variable~., scales="free_y")
    ggsave(paste(x,".pdf"), p, width=25, height=15)
    }}
-------------------------------------------------------------------------------------------------------
plotmatrix(data = wind) + geom_smooth(method="lm") plotmatrix() geom_point() plotmatrix() ggplot() plotmatrix() Expand <- function(data) {
    grid <- expand.grid(x = 1:ncol(data), y = 1:ncol(data))
    grid <- subset(grid, x != y)
    all <- do.call("rbind", lapply(1:nrow(grid), function(i) {
        xcol <- grid[i, "x"]
        ycol <- grid[i, "y"]
        data.frame(xvar = names(data)[ycol], yvar = names(data)[xcol], 
                   x = data[, xcol], y = data[, ycol], data)
    }))
    all$xvar <- factor(all$xvar, levels = names(data))
    all$yvar <- factor(all$yvar, levels = names(data))
    all
} plotmatrix() wind2 <- Expand(wind) ggplot() ggplot(wind2, aes(x = x, y = y)) + 
    geom_point(alpha = I(1/10), shape = I(20), size = I(1)) + 
    facet_grid(xvar ~ yvar, scales = "free") makeDensities <- function(data) {
    densities <- do.call("rbind", lapply(1:ncol(data), function(i) {
        data.frame(xvar = names(data)[i], yvar = names(data)[i], 
                   x = data[, i])
    }))
    densities
} dens <- makeDensities(wind) plotmatrix() ggplot(wind2, aes(x = x, y = y)) + 
       geom_point(alpha = I(1/10), shape = I(20), size = I(1)) + 
       facet_grid(xvar ~ yvar, scales = "free")+
       stat_density(aes(x = x, y = ..scaled.. * diff(range(x)) + min(x)),
                    data = dens, position = "identity", colour = "grey20", 
                    geom = "line") ggplot(wind2, aes(x = x, y = y)) + 
       geom_point(alpha = I(1/10), shape = I(20), size = I(1)) + 
       facet_grid(xvar ~ yvar, scales = "free")+
       stat_density(aes(x = x, y = ..scaled.. * diff(range(x)) + min(x)),
                    data = dens, position = "identity", colour = "grey20", 
                    geom = "line") +
       geom_smooth(method="lm")
-------------------------------------------------------------------------------------------------------
gr.sc <- function(var.name.1, var.name.2) {
  ggplot(results, aes_string(x = var.name.1, y = var.name.2)) +
  geom_point(alpha = 1/5) +
  opts(aspect.ratio = 1) +
  facet_grid(. ~ name)
}

gr.sc("sum.All", "sum.Empl")
-------------------------------------------------------------------------------------------------------
xtpcse vcovBK() cluster='time' pcse pcse pcse2 pcse library(Matrix)
pcse2 <- function(object, groupN, groupT, pairwise=TRUE){
  ## Extract basic model info
  groupT <- tail(as.character((match.call()$groupT)), 1)
  groupN <- tail(as.character((match.call()$groupN)), 1)
  dat <- eval(parse(text=object$call$data))

  ## Sanity checks
  if(!"lm" %in% class(object)){stop("Formula object must be of class 'lm'.")}
  if(!groupT %in% colnames(dat)){stop(paste(groupT, 'was not found in data', object$call$data))}
  if(!groupN %in% colnames(dat)){stop(paste(groupN, 'was not found in data', object$call$data))}
  if(anyDuplicated(paste(dat[,groupN], dat[,groupT]))>0){stop(paste('There are duplicate groupN-groupT observations in', object$call$data))}
  if(length(dat[is.na(dat[,groupT]),groupT])>0){stop('There are missing unit indices in the data.')}
  if(length(dat[is.na(dat[,groupN]),groupN])>0){stop('There are missing time indices in the data.')}

  ## Expand model frame to include groupT, groupN, resid columns.
  f <- as.formula(object$call$formula)
  f.expanded <- update.formula(f, paste(". ~ .", groupN, groupT, sep=" + "))
  dat.pcse <- model.frame(f.expanded, dat) 
  dat.pcse$e <- resid(object)  

  ## Extract basic model info (part II)
  N <- length(unique(dat.pcse[,groupN]))
  T <- length(unique(dat.pcse[,groupT]))
  nobs <- nrow(dat.pcse)
  is.balanced <- length(resid(object)) == N * T

  ## If balanced dataset, calculate as in Beck & Katz (1995)
  if(is.balanced){
    dat.pcse <- dat.pcse[order(dat.pcse[,groupN], dat.pcse[,groupT]),]
    X <- model.matrix(f, dat.pcse)
    E <- t(matrix(dat.pcse$e, N, T, byrow=TRUE))
    Omega <- kronecker((crossprod(E) / T), Matrix(diag(1, T)) )

  ## If unbalanced and pairwise, calculate as in Franzese (1996)
  }else if(pairwise==TRUE){
    ## Rectangularize
    rectangle <- expand.grid(unique(dat.pcse[,groupN]), unique(dat.pcse[,groupT]))
    names(rectangle) <- c(groupN, groupT)
    rectangle <- merge(rectangle, dat.pcse, all.x=TRUE)
    rectangle <- rectangle[order(rectangle[,groupN], rectangle[,groupT]),]
    valid <- ifelse(is.na(rectangle$e),0,1) 
    rectangle[is.na(rectangle)] <- 0
    X <- model.matrix(f, rectangle)
    X[valid==0,1] <- 0

    ## Calculate pcse
    E <- crossprod(t(matrix(rectangle$e, N, T, byrow=TRUE)))
    V <- crossprod(t(matrix(valid, N, T, byrow=TRUE)))
    if (length(V[V==0]) > 0){stop("Error! A CS-unit exists without any obs or without any obs in a common period with another CS-unit. You must remove that unit from the data passed to pcse().")}
    Omega <-  kronecker(E/V, Matrix(diag(1, T)))

  ## If unbalanced and casewise, caluate based on largest rectangular subset of data
  }else{ 
    ## Rectangularize
    rectangle <- expand.grid(unique(dat.pcse[,groupN]), unique(dat.pcse[,groupT]))
    names(rectangle) <- c(groupN, groupT)
    rectangle <- merge(rectangle, dat.pcse, all.x=TRUE)
    rectangle <- rectangle[order(rectangle[,groupN], rectangle[,groupT]),]
    valid <- ifelse(is.na(rectangle$e),0,1) 
    rectangle[is.na(rectangle)] <- 0
    X <- model.matrix(f, rectangle)
    X[valid==0,1] <- 0

    ## Keep only years for which we have the max number of observations
    large.panels <- by(dat.pcse, dat.pcse[,groupT], nrow) # How many valid observations per year?
    if(max(large.panels) < N){warning('There is no time period during which all units are observed. Consider using pairwise estimation.')}
    T.balanced <- names(large.panels[large.panels==max(large.panels)]) # Which years have max(valid observations)?
    T.casewise <- length(T.balanced)
    dat.balanced <- dat.pcse[dat.pcse[,groupT] %in% T.balanced,] # Extract biggest rectangular subset
    dat.balanced <- dat.balanced[order(dat.balanced[,groupN], dat.balanced[,groupT]),]
    e <- dat.balanced$e

    ## Calculate pcse as in Beck & Katz (1995)
    E <- t(matrix(dat.balanced$e, N, T.casewise, byrow=TRUE))
    Omega <- kronecker((crossprod(E) / T.casewise), Matrix(diag(1, T)))
  }

  ## Finish evaluation, clean and output
  salami <- t(X) %*% Omega %*% X
  bread <- solve(crossprod(X))
  sandwich <- bread %*% salami %*% bread
  colnames(sandwich) <- names(coef(object))
  row.names(sandwich) <- names(coef(object))
  pcse <- sqrt(diag(sandwich))
  b <- coef(object)
  tstats <- b/pcse
  df <- nobs - ncol(X)
  pval <- 2*pt(abs(tstats), df, lower.tail=FALSE)
  res <- list(vcov=sandwich, pcse=pcse, b=b, tstats=tstats, df=df, pval=pval, pairwise=pairwise, 
              nobs=nobs, nmiss=(N*T)-nobs, call=match.call())
  class(res) <- "pcse"
  return(res)
}
-------------------------------------------------------------------------------------------------------
#Build the data
 t <- 1:1000
 x1 <- 100 * sin(0.01 * t)
 x2 <- 200 * cos(0.04 * t)

 #Set up the plot area for two "crammed" plots
 par(pty="m", plt=c(0.1, 1, 0, 1), omd=c(0.1,0.9,0.1,0.9))
 par(mfrow = c(2, 1))

 #Plot x1 and x2 together
 plot(t, x1, type="l", ylim = 1.5 * range(x1, x2), xaxt="n", xlab="", ylab="", main="", col="blue", las=2)
 lines(t, x2, lwd=1, col="red")
 mtext(side=2, "Top Plot", line=5.3, cex=0.8)
 mtext(side=2, "(units)", line=4, cex=0.8)
 grid()
 mtext(side=3, "2 Plots Crammed Together", line=1.5, cex=1.2)
 legend("topright", legend=c("100 * sin(0.01 * t)", "200 * cos(0.4 * t)"), bg="white", lwd=c(1, 1), col=c("blue", "red"), cex=0.9)

 #Place the 1st x-axis
 axis(side = 1, col="blue", col.axis="blue")
 linloc <- par()$usr[3]
 abline(h=linloc, col="blue")
 mtext(side=1, "First X-Axis", line=2.5, cex=0.8, col="blue")

 #Place the fake 2nd x-axis
 xaxis2 <- 1:10
 par(plt=c(0.1,1,0.6,1))
 plot(xaxis2, type="n", xaxt="n", xlab="", yaxt="n", ylab="", xlim=range(xaxis2), bty="n")
 axis(side = 1, col="red", col.axis="red")
 linloc <- par()$usr[3]
 abline(h=linloc, col="red")
 mtext(side=1, "Second X-Axis", line=2.5, cex=0.8, col="red")
-------------------------------------------------------------------------------------------------------
set.seed(123)
lambda<-as.matrix(runif(2),nrow=2)
a<-matrix(runif(10),ncol=2)
y<-runif(5)

fun = function(lambda) {-y %*% log(a %*% lambda) + lambda %*% apply(a,2,sum)}

#Create grid 
lambda.grid<-expand.grid(1:10,1:10)
names(lambda.grid)<-c("lambda_1","lambda_2")

z<-apply(lambda.grid,1,fun) #Evaluate function for each row

#Change z into matrix form for persp plots

z.mat<-matrix(z,ncol=10,byrow=FALSE)

persp(x=1:10,y=1:10,z.mat,xlab="lambda_1",ylab="lambda_2",zlab="f(lambda_1,lambda_2)")
-------------------------------------------------------------------------------------------------------
all.comb.dfrm  <- expand.grid(a=1:10, b=1:10, p=1:10, q=1:10)
all.comb.dfrm$Y <- with(all.comb.dfrm, f(a,b,p,q) )
-------------------------------------------------------------------------------------------------------
df2 <- expand.grid(A=LETTERS[1:5], B=LETTERS[1:5])
 df2$N <- 1:25
 mtx <- outer(X=LETTERS[1:5],Y=LETTERS[1:5], FUN=function(x,y){
                        df2[intersect(which(df2$A==x), which(df2$B==y)), "N"] })
 colnames(mtx)<-LETTERS[1:5]; rownames(mtx)<-LETTERS[1:5]
 mtx
  A  B  C  D  E
A 1  6 11 16 21
B 2  7 12 17 22
C 3  8 13 18 23
D 4  9 14 19 24
E 5 10 15 20 25 reshape dcast
-------------------------------------------------------------------------------------------------------
apply expand.grid fac1 <- seq(5, 15, 5)
fac2 <- seq(50, 80, 15)

Out <- apply(expand.grid(fac1,fac2),1,function(x){
  GLD$fast     <- SMA(Cl(GLD), n=x[1])
  GLD$slow     <- SMA(Cl(GLD), n=x[2])

  golden_cross <- Lag(ifelse(GLD$fast > GLD$slow, 1, -1))
  golden_cross <- na.locf(golden_cross, na.rm=TRUE)

  coin         <- ROC(Cl(GLD))*golden_cross

  coin_box     <- cumprod(1+coin)
  last_coin    <- coin_box[NROW(coin_box),]

  coin_value   <- round((last_coin-1)*100, digits=2)

return(c(x[1],x[2],Value=coin_value))
})
as.data.frame(t(Out)) Var1 Var2  Value
1    5   50   9.96
2   10   50   3.09
3   15   50  -6.48
4    5   65 -26.37
5   10   65 -13.55
6   15   65 -21.79
7    5   80 -21.92
8   10   80 -17.98
9   15   80  -9.73
-------------------------------------------------------------------------------------------------------
lattice library(lattice)
xyplot(lat ~ long | cut(depth, 3),
        data = quakes, 
        aspect = "iso", 
        pch = ".", 
        cex = 2, 
        type = c("p", "g"), 
        xlab = "Longitude", 
        ylab = "Latitude", 
        strip = strip.custom(strip.names = TRUE, var.name = "Depth")) library(ggplot2)
df <- quakes
df$cut_depth <- cut(quakes$depth, 3)
ggplot(quakes, aes(x=long, y=lat)) + geom_point() + facet_grid(.~cut_depth)
-------------------------------------------------------------------------------------------------------
expand.grid(dfx$projectScore, dfx$highestRankingGroup, wrk[[1]]) a <- c("41","42","44","45","97","99","100","101","102","103","105", "123","124","126","127","130","132","135","136","137","138","139","140","141","158","159","160","161","162","163","221","223","224")
wrk <-list(a, a)
dfx <- data.frame(projectScore=c(0.8852, 0.8845), highestRankingGroup=c(1,2))
listOut <- expand.grid(dfx$projectScore, dfx$highestRankingGroup, wrk[[1]])
names(listOut) <- c("projectScore", "highestRankingGroup", "wrk")
listOut[order(-listOut$projectScore,listOut$highestRankingGroup, listOut$wrk),]
-------------------------------------------------------------------------------------------------------
curves <- subset(curves, !(curves$p==2 & (curves$value>4 | curves$value<0)))
curves <- subset(curves, !(curves$p==4 & (curves$value>8 | curves$value<0)))

ggplot(curves, aes(x, value, color = variable)) +
        geom_line() +
        facet_grid(p ~ c, scales="free_y")
-------------------------------------------------------------------------------------------------------
ylimits <- c(  floor(min(curves$value[curves$variable == "y1"])),
             ceiling(max(curves$value[curves$variable == "y1"])) )

ggplot(curves, aes(x, value, color = variable)) +
    geom_line() +
    facet_grid(p ~ c, scales = "free_y") +
    scale_y_continuous(breaks = ylimits[1]:ylimits[2]) +
    coord_cartesian(ylim = ylimits)
-------------------------------------------------------------------------------------------------------
ggplot aov data.frame ggplot library(ggplot2)

df <- data.frame(
  value = runif(300),
  yr = rep(1:10, each=3),
  trt = rep(LETTERS[1:4], each=75),
  third = rep(c("T", "P", "Q"), each=100)
)

ggplot(df, aes(x=yr, y=value, colour=trt)) + 
  stat_summary(fun.y=mean, geom="line", size=2) +
  stat_summary(fun.ymin=min, fun.ymax=max, geom="errorbar") +
  facet_grid(~third) ggplot(df, aes(x=yr, y=value, colour=trt)) + 
  stat_summary(fun.y=mean, geom="line", size=2) +
  stat_summary(fun.ymin=min, fun.ymax=max, geom="errorbar") +
  facet_grid(trt~third)
-------------------------------------------------------------------------------------------------------
ggplot2 lattice library(ggplot2)
gales_long <- melt(gales, id.vars = "year")

p_gales_ggplot2 <- ggplot(gales_long, aes(year, value)) +
  geom_line() +
  facet_grid(variable ~ ., scales = "free_y")
p_gales_ggplot2 p_gales_lattice <- xyplot(
  value ~ year | variable,
  gales_long,
  type = "l",
  scales = list(y = list(relation = "free")),
  layout = c(1, 2)
)
p_gales_lattice
-------------------------------------------------------------------------------------------------------
d <- data.frame(expand.grid(x=1:4, rep=1:3), y=rnorm(4*3))
ggplot(d, aes(x, y)) + 
  stat_summary(mapping=aes(colour=factor(ifelse(min(..y..)==..y.., 1, ifelse(max(..y..)==..y.., 3, 2))
)), fun.y=mean, geom="point")
-------------------------------------------------------------------------------------------------------
# generate dummy data

df = data.frame(
       Sum = rnorm(10), 
       source_id = sample(10, 5, replace = T), 
       type_id   = sample(10, 5, replace = T), 
       variety   = sample(10, 5, replace = T)
     )

index = names(df)[-1]
temp  = expand.grid(0:1, 0:1, 0:1)[-1,]

require(plyr)
cubedf = adply(temp, 1, function(x) 
   ddply(df, index[x == 1], summarize, SUM = sum(Sum))) library(plyr)
# list factor variables
index  = names(df)[-1]

# generate all combinations of factor variables
combs  = unlist(llply(1:3, combn, x = index, simplify = F), recursive = F)

# calculate sum for each combination
cubedf = ldply(combs, function(var) 
            ddply(df, var, summarize, SUM = sum(Sum)))
-------------------------------------------------------------------------------------------------------
opts(legend.direction="horizontal") scale_fill_manual(values=c("white", "grey20", "grey70")) opts(axis.text.x = theme_text(angle=45)) opts(axis.title.y = theme_blank()) year trt grp gp dat.df <- data.frame(
    gp = gl(3, 36, 108, labels=c("A", "B", "C")),
    yr = sample(2000:2010, 108, replace=TRUE),
    A=runif(108),
    B=runif(108, min=1, max=10),
    C=runif(108, min=100, max=200),
    D=runif(108, min=1000, max=1500)
)
dat.m <- melt(dat.df)

ggplot(dat.m, aes(x=wt, y=value, group=pl, facet=gp, fill=pl))+
    stat_summary(fun.y=mean, geom="bar", size=2, position="dodge")+
    stat_summary(fun.ymin=function(x)(mean(x)-sd(x)/sqrt(length(x))), geom="errorbar", 
        fun.ymax=function(x)(mean(x)+sd(x)/sqrt(length(x))), position="dodge")+#, position="dodge"
    facet_grid(variable~facet, scale="free_y")+
    scale_fill_manual(values=c("white", "grey20", "grey70")) +
    opts(
        legend.position="top", 
        legend.direction="horizontal",
        axis.text.x = theme_text(angle=45),
        axis.title.y = theme_blank()
    )
-------------------------------------------------------------------------------------------------------
ggplot ddply ggplot library(lubridate)
library(plyr)
library(ggplot2)

df$month <- factor(month(df$dates), levels=1:12, labels=month.abb, ordered=TRUE)
df$year  <- year(df$dates)

hline.data <- ddply(df, .(month), summarize, avgvalue=mean(values))


ggplot() + 
  geom_line(aes(x=year, y=values, group=month), data=df, colour="blue") +
  geom_hline(aes(yintercept=avgvalue), data=hline.data, colour="blue", size=2) + 
  facet_grid(~month) +
  opts(axis.text.x = theme_blank()) +
  xlab("") df <- structure(list(dates = structure(c(8415, 8446, 8474, 8505, 8535, 
                8566, 8596, 8627, 8658, 8688, 8719, 8749, 8780, 8811, 8839, 8870, 
                8900, 8931, 8961, 8992, 9023, 9053, 9084, 9114, 9145, 9176, 9204, 
                9235, 9265, 9296, 9326, 9357, 9388, 9418, 9449, 9479, 9510, 9541, 
                9570, 9601, 9631, 9662, 9692, 9723, 9754, 9784, 9815, 9845, 9876, 
                9907, 9935, 9966, 9996, 10027, 10057, 10088, 10119, 10149, 10180, 
                10210, 10241, 10272, 10300, 10331, 10361, 10392, 10422, 10453, 
                10484, 10514, 10545, 10575, 10606, 10637, 10665, 10696, 10726, 
                10757, 10787, 10818, 10849, 10879, 10910, 10940, 10971, 11002, 
                11031, 11062, 11092, 11123, 11153, 11184, 11215, 11245, 11276, 
                11306, 11337, 11368, 11396, 11427, 11457, 11488, 11518, 11549, 
                11580, 11610, 11641, 11671, 11702, 11733, 11761, 11792, 11822, 
                11853, 11883, 11914, 11945, 11975, 12006, 12036, 12067, 12098, 
                12126, 12157, 12187, 12218, 12248, 12279, 12310, 12340, 12371, 
                12401, 12432, 12463, 12492, 12523, 12553, 12584, 12614, 12645, 
                12676, 12706, 12737, 12767, 12798, 12829, 12857, 12888, 12918, 
                12949, 12979, 13010, 13041, 13071, 13102, 13132), class = "Date"), 
    values = c(1093, 1182, 1299, 1372, 1319, 1362, 1239, 1162, 
        1059, 921, 815, 720, 835, 853, 1034, 1030, 1240, 1388, 1429, 
        1319, 1231, 1184, 1076, 825, 991, 1093, 854, 808, 1079, 1092, 
        1220, 1251, 1130, 1131, 1052, 951, 950, 1006, 1112, 1119, 
        1250, 1322, 1347, 1310, 1215, 1128, 1035, 992, 1079, 1018, 
        1112, 1224, 1323, 1344, 1326, 1267, 1171, 1075, 916, 932, 
        888, 904, 939, 1018, 1140, 1174, 1285, 1311, 1298, 1231, 
        1091, 1088, 991, 1028, 1177, 1322, 1322, 1398, 1389, 1174, 
        1196, 1115, 756, 496, 693, 673, 748, 777, 820, 948, 966, 
        1027, 960, 865, 767, 675, 765, 732, 613, 632, 659, 705, 684, 
        734, 715, 626, 551, 487, 500, 536, 575, 595, 736, 798, 832, 
        797, 792, 726, 650, 584, 567, 524, 574, 571, 591, 657, 699, 
        756, 867, 795, 760, 685, 609, 588, 521, 581, 614, 623, 668, 
        702, 777, 697, 647, 562, 523, 508, 493, 504, 534, 586, 621, 
        620, 636, 600, 549, 557)), .Names = c("dates", "values"), row.names = c(NA, 
    -156L), class = "data.frame")
-------------------------------------------------------------------------------------------------------
for(a in A) for(b in B) something(x[a,b]) something_vectorized(x[as.matrix(expand.grid(A,B))]) > system.time(replicate(100,sum(sapply(1:1000,function(x) x^2))))
   user  system elapsed 
  0.385   0.001   0.388 
> system.time(replicate(100,sum((1:1000)^2)))
   user  system elapsed 
  0.002   0.001   0.003
-------------------------------------------------------------------------------------------------------
require(reshape)
Opt1 <- as.data.frame(cast(Data, Date ~ county + State, value="Val"))
rownames(Opt1) <- Opt1$Date
Opt1$Date <- NULL
as.xts(Opt1) Opt2 <- 
  with(Data,
    by(Data,list(county,State,year),
      function(x){
        rownames(x) <- x$Date
        x <- x["Val"]
        as.xts(x)
      }
    )
  ) Opt2[["d","b","2012"]] counties <- dimnames(Opt2)[[1]]
states <- dimnames(Opt2)[[2]]
years <- dimnames(Opt2)[[3]]

op <- par(mfrow=c(3,6))
apply(
  expand.grid(counties,states,years),1,
  function(i){
    plot(Opt2[[i[1],i[2],i[3]]],main=paste(i,collapse="-"))
    invisible()
  }
)
par(op) Data <- data.frame( State = rep(letters[1:3],each=90),
            county = rep(letters[4:6],90),
            Date = rep(seq(as.Date("2011-01-01"),by="month",length.out=30),each=3),
            Val = runif(270)
)
Data$year <- as.POSIXlt(Data$Date)$year + 1900
-------------------------------------------------------------------------------------------------------
labels x = seq(0, 10, by = 0.5)
 y = seq(0, 10, by = 0.5)
 z <- outer(x, y)
 d3 <- expand.grid(x=x,y=y); d3$z <- as.vector(z)
 contourplot(z~x+y, data=d3)
 # labeled '5'-'90'
 contourplot(z~x+y, data=d3, 
    at=seq(5,90, by=5),
    labels=c(seq(5,25, by=5),rep("", 16) ),
    main="Labels only at the first 5 contour lines")
 # contourplot seems to ignore 'extra' labels
 # c() will coerce the 'numeric' elements to 'character' if any others are 'character'
 ?contourplot   # and follow the link in the info about labels to ?panel.levelplot
-------------------------------------------------------------------------------------------------------
colour ?geom_tile pp <- function (n,r=4) {
      x <- seq(-r*pi, r*pi, len=n)
      df <- expand.grid(x=x, y=x)
      df$r <- sqrt(df$x^2 + df$y^2)
      df$z <- cos(df$r^2)*exp(-df$r/6)
      df
     }
p <- ggplot(pp(20), aes(x=x,y=y)) + 
  geom_tile(aes(fill = z), colour = "black")
p scale_fill_manual dfr <- pp(20)
dfr$discrete_z <- cut(dfr$z, c(-1, 0, 1)) # makes z a factor

p <- ggplot(dfr, aes(x=x,y=y)) + 
  geom_tile(aes(fill = discrete_z)) + 
  scale_fill_manual(
    values = c("red", "blue")
  )
p
-------------------------------------------------------------------------------------------------------
library(sfsmisc)

#Generate the data
x <- 1:100000
y <- 1:100000

#Setup the plot area
par(pty="m", plt=c(0.1, 1, 0.1, 1), omd=c(0.1,0.9,0.1,0.9))

#Plot a blank graph without completing the x or y axis
plot(x, y, type = "n", xaxt = "n", yaxt="n", xlab="", ylab="", log = "x", col="blue")
mtext(side=3, text="Test Plot", line=1.2, cex=1.5)

#Complete the x axis
eaxis(1, padj=-0.5, cex.axis=0.8)
mtext(side=1, text="x", line=2.5)

#Complete the y axis and add the grid
aty <- seq(par("yaxp")[1], par("yaxp")[2], (par("yaxp")[2] - par("yaxp")[1])/par("yaxp")[3])
axis(2, at=aty, labels=format(aty, scientific=FALSE), hadj=0.9, cex.axis=0.8, las=2)
mtext(side=2, text="y", line=4.5)
grid()

#Add the line last so it will be on top of the grid
lines(x, y, col="blue")
-------------------------------------------------------------------------------------------------------
italic require(lattice)
require(grid)
x <- seq(pi/4, 5 * pi, length.out = 100)
y <- seq(pi/4, 5 * pi, length.out = 100)
r <- as.vector(sqrt(outer(x^2, y^2, "+")))
grid <- expand.grid(x=x, y=y)
grid$z <- cos(r^2) * exp(-r/(pi^3))

contourplot(z~x*y, grid, cuts = 1,
  colorkey = FALSE, region = TRUE,
  xlab=expression(italic(U)),
  ylab=expression(italic('\u03ba')))
grid.gedit("text", gp=gpar(fontfamily="serif"))
grid.gedit("xlab", gp=gpar(fontfamily="serif"))
grid.gedit("ylab", gp=gpar(fontfamily="serif"))
-------------------------------------------------------------------------------------------------------
## Top 3 cuts
tmp <- names(sort(summary(diamonds$cut), decreasing = T))[1:3]
tmp <- droplevels(subset(diamonds, cut == tmp))
ggplot(tmp, aes(price, color=cut)) + geom_density() ggplot(diamonds, aes(price, color=cut)) + geom_density() + facet_grid(~cut)
-------------------------------------------------------------------------------------------------------
ggplot(subset(diamonds, cut %in% arrange(count(diamonds, .(cut)), desc(freq))[1:3,]$cut),
  aes(price, colour=cut)) + 
  geom_density() + facet_grid(~cut) count arrange desc %in%
-------------------------------------------------------------------------------------------------------
t1 <- "Time Value
1.023   5.786
2.564   10.675
3.678   14.678
5.023   17.456"

t2 <- "Time Value
0.787   1.765
1.567   3.456
3.011   5.879
4.598   7.768"

t3 <- "Time Value
1.208   3.780
2.478   6.890
3.823   9.091
5.125   12.769"

tex1 <- read.table(textConnection(t1), header = TRUE)
tex2 <- read.table(textConnection(t2), header = TRUE)
tex3 <- read.table(textConnection(t3), header = TRUE)

plot(tex1, type="l", xlim=range(tex1$Time, tex2$Time, tex3$Time), ylim=range(tex1$Value, tex2$Value, tex3$Value), main="Common Time Axis for 3 Data Series", col="black")
grid()
lines(tex2, col="red")
lines(tex3, col="blue")
-------------------------------------------------------------------------------------------------------
library(reshape2)
finalregstack$trade.date <- as.Date(rownames(finalregstack))
fm <- melt(finalregstack,id.var="trade.date")

library(ggplot2)
qplot(trade.date,value,data=fm,geom="line")+
  facet_grid(variable~.,scale="free_y")+
  labs(x="Trading date",y="")+
  theme_bw() ## cosmetic reshape2 scale="free_y" align.plot align.plots heights library(ggExtra)

theme_set(theme_bw())
theme_update(panel.background=theme_rect(),
              panel.grid.major=theme_blank(),
             panel.grid.minor=theme_blank())

kurth.plot <- qplot(x=trade.date, y=kurth,
                    data=finalregstack, geom='line')+
  scale_y_continuous(name='kurth')+
  scale_x_date(name='',expand=c(0,0))+
  opts(plot.margin = unit(c(1,0,0,0), "lines"))

skewh.plot <- qplot(x=trade.date, y=skewh,
                    data=finalregstack, geom='line')+
  scale_y_continuous(name='skewh')+
  scale_x_date(name='', expand=c(0,0))+
  opts(plot.margin = unit(c(-1,0,0,0), "lines"))


logpremh.plot <- qplot(x=trade.date, y=logpremh,
                       data=finalregstack, geom='line')+
  scale_y_continuous(name='logpremh')+
  scale_x_date(name='Trading date', expand=c(0,0))+
  opts(plot.margin = unit(c(-1,0,0,0), "lines"))


source(url("http://ggextra.googlecode.com/svn/trunk/R/align.r"))
grid.newpage()
align.plots(kurth.plot, skewh.plot, logpremh.plot,
            heights=unit(c(0.33,0.33,0.33),"null")) x grid.arrange align.plots
-------------------------------------------------------------------------------------------------------
ggplot library(reshape2)

finalregstack$trade.date <- 1:100
mregstack <- melt(finalregstack, id.vars="trade.date")

ggplot(mregstack, aes(x=trade.date, y=value, colour=variable)) + geom_line() +
    facet_grid(variable~.) + theme_bw()
-------------------------------------------------------------------------------------------------------
for #Set the number of bets and number of trials and % lines
numbet <- 6000 #6000 bets
numtri <- 1000 #Run 1000 trials of the 6000 bets
perlin <- 0.05 #Show the +/- 5% lines on the graph
rantri <- 60 #The 60th trial (just a random trial to be drawn)

#Fill a matrix where the rows are the cumulative bets and the columns are the trials
xcum <- matrix(NA, nrow=numbet, ncol=numtri)
for (i in 1:numtri) {
  x <- sample(c(-1,1), numbet, replace = TRUE)
  xcum[,i] <- cumsum(x)
}

#Plot the trials as transparent lines so you can see the build up
matplot(xcum, type="l", xlab="Number of Bets", ylab="Cumulative Sum", main="Cumulative Results", col=rgb(0.01, 0.01, 0.01, 0.02))
grid()

#Sort the trials of each bet so you can pick out the desired %
xcumsor <- xcum
for (i in 1:numbet) {
  xcumsor[i,] <- xcum[i,order(xcum[i,])]
}

#Draw the upper/lower limit lines and the 50% probability line     
lines(xcumsor[, perlin*numtri], type="l", lwd=2, col=rgb(1, 0.0, 0.0)) #Lower limit
lines(xcumsor[, 0.5*numtri], type="l", lwd=3, col=rgb(0, 1, 0.0)) #50% Line
lines(xcumsor[, (1-perlin)*numtri], type="l", lwd=2, col=rgb(1, 0.0, 0.0)) #Upper limit

#Show one of the trials
lines(xcum[, rantri], type="l", lwd=1, col=rgb(1, 0.8, 0)) #Random trial

#Draw the legend
legend("bottomleft", legend=c("Various Trials", "Single Trial", "50% Probability", "Upper/Lower % Limts"), bg="white", lwd=c(1, 1, 3, 2), col=c("darkgray", "orange", "green", "red")) #Set the bet sequence and the % lines
betseq <- 1:100000 #1 to 100,000 bets
perlin <- 0.05 #Show the +/- 5% lines on the graph

#Calculate the Upper and Lower limits using perlin
#qnorm() gives the multiplier for the square root
upplim <- qnorm(1-perlin)*sqrt(betseq)
lowlim <- qnorm(perlin)*sqrt(betseq)

#Get the range for y
yran <- range(upplim, lowlim)

#Plot the upper and lower limit lines
plot(betseq, upplim, ylim=yran, type="l", xlab="", ylab="")
lines(betseq, lowlim) dralim lines dralim #Set the bet sequence and the % lines
betseq <- 0:700 #0 to 700 bets
perlin <- 0.05 #Show the +/- 5% lines on the graph

#Define a function that plots the upper and lower % limit lines
dralim <- function(stax, endx, perlin) {
  lines(stax:endx, qnorm(1-perlin)*sqrt((stax:endx)-stax))
  lines(stax:endx, qnorm(perlin)*sqrt((stax:endx)-stax))
}

#Build the plot area and draw the vertical dashed lines
plot(betseq, rep(0, length(betseq)), type="l", ylim=c(-50, 50), main="", xlab="Trial Number", ylab="Cumulative Hits")
abline(h=0)
abline(v=35, lty="dashed") #Seg 1
abline(v=185, lty="dashed") #Seg 2
abline(v=385, lty="dashed") #Seg 3
abline(v=485, lty="dashed") #Seg 4
abline(v=585, lty="dashed") #Seg 5

#Draw the % limit lines that correspond to the vertical dashed lines by calling the
#new function dralim.
dralim(0, 35, perlin) #Seg 1
dralim(36, 185, perlin) #Seg 2
dralim(186, 385, perlin) #Seg 3
dralim(386, 485, perlin) #Seg 4
dralim(486, 585, perlin) #Seg 5
dralim(586, 701, perlin) #Seg 6
-------------------------------------------------------------------------------------------------------
multi.outer<-function(f,...){

  apply(expand.grid(...),1,function(x){do.call(f,as.list(x))})

}
-------------------------------------------------------------------------------------------------------
library(ggplot2)
dat.m <- melt(dat, "sex") 

ggplot(dat.m, aes(value)) + 
  geom_bar(binwidth = 0.5) + 
  facet_grid(variable ~ sex)
-------------------------------------------------------------------------------------------------------
df1 <- data.frame(col1=letters[1:26], col2=sample(1:100, 26))
df2 <- with(df1, expand.grid(col1=col1, col2=col1))
df2$col3 <- df1$col2 rep(df1$col2, 26) > head(df1, n=3)
  col1 col2
1    a   68
2    b   73
3    c   45
> tail(df1, n=3)
   col1 col2
24    x   22
25    y    4
26    z   17
> head(df2, n=3)
  col1 col2 col3
1    a    a   68
2    b    a   73
3    c    a   45
> tail(df2, n=3)
    col1 col2 col3
674    x    z   22
675    y    z    4
676    z    z   17
-------------------------------------------------------------------------------------------------------
DF1$col1 DF2$col1 DF1$col2 DF2$col3 DF1 <- data.frame(col1=letters, col2=1:26, stringsAsFactors=FALSE)
DF2 <- expand.grid(col1=letters, col2=letters, stringsAsFactors=FALSE)
DF2$col3 <- DF1$col2[match(DF2$col1,  DF1$col1)] match() DF1$col1
-------------------------------------------------------------------------------------------------------
pack pack grid pack grid pack expandTk <- function() {
  root  <- tktoplevel()
  # textbox with scroll bars
  textbox <- tk2frame(root)
  txt <- tktext(textbox, bg="white", font="courier", wrap="word", yscrollcommand=function(...)tkset(scr,...))
  scr <- tkscrollbar(textbox, repeatinterval=5, command=function(...) tkyview(txt,...))
  tkmark.set(txt,"insert","0.0")

  # Set up the geometry for the stuff inside the "textbox" frame.

  # The text and scrollbar widgets live on the same row.
  tkgrid(txt, scr)

  # The text widget should stick to all four sides of its parcel.
  tkgrid.configure(txt, sticky="nsew")

  # The scrollbar should stick to the top and bottom of its parcel, it need not stick to the
  # left and right.
  tkgrid.configure(scr, sticky="ns")

  # When the window is resized, we want surplus space to be allocated to the text widget,
  # which is in the top left corner of this frame.
  tkgrid.columnconfigure(textbox,0,weight=1)
  tkgrid.rowconfigure(textbox,0,weight=1)

  # status bar and size grip
  statusText <- tclVar("")
  l <- tk2label(root, textvariable=statusText,relief="sunken")
  sg <- ttksizegrip(root)

  # Set up the geometry for the stuff inside the "root" window.

  # First row is just the textbox frame...
  tkgrid(textbox)

  # Second row is the status label and the resize gadget
  tkgrid(l, sg)

  # The textbox widget should span 2 colums, and stick to all four sides of its parcel.
  tkgrid.configure(textbox,columnspan=2,sticky="nsew")

  # The status label should stick to all four sides of its parcel too
  tkgrid.configure(l,sticky="nsew")

  # The resize gadget should only stick to the bottom right of its parcel
  tkgrid.configure(sg,sticky="se")

  # When the window is resized, we want surplus space to go to the textbox frame (and from there
  # to the text widget itself, which it will do thanks to the grid weights we set up above).  The
  # textbox frame is in the top left corner of its parent window.
  tkgrid.columnconfigure(root,0,weight=1)
  tkgrid.rowconfigure(root,0,weight=1)
} grid
-------------------------------------------------------------------------------------------------------
generate.data <- function(rate=.3, dim=c(25,25)) {
  tmp <- rep(".", prod(dim))
  tmp[sample(1:prod(dim), ceiling(prod(dim)*rate))] <- "S"
  m <- matrix(tmp, nr=dim[1], nc=dim[2])
  return(m)
} x <- generate.data()
rownames(x) <- colnames(x) <- 1:25
capture.output(as.table(x), file="res.txt") res.txt make.table <- function(x, labels=NULL) {
  # x = matrix
  # labels = list of labels for x and y
  coord.xy <- expand.grid(x=1:nrow(x), y=1:ncol(x))
  opar <- par(mar=rep(1,4), las=1)
  plot.new() 
  plot.window(xlim=c(0, ncol(x)), ylim=c(0, nrow(x)))
  text(coord.xy$x, coord.xy$y, c(x), adj=c(0,1)) 
  if (!is.null(labels)) {
    mtext(labels[[1]], side=3, line=-1, at=seq(1, ncol(x)), cex=.8)
    mtext(labels[[2]], side=2, line=-1, at=seq(1, nrow(x)), cex=.8, padj=1)
  }
  par(opar)
} make.table(x, list(1:25, 1:25))
-------------------------------------------------------------------------------------------------------
expand.grid expand.grid(prefix, roots, suffix)

    Var1           Var2   Var3
1  cheap  car insurance  quote
2 budget  car insurance  quote
3  cheap auto insurance  quote
4 budget auto insurance  quote
5  cheap  car insurance quotes
6 budget  car insurance quotes
7  cheap auto insurance quotes
8 budget auto insurance quotes do.call paste do.call(paste, expand.grid(prefix, roots, suffix))

[1] "cheap car insurance quote"    "budget car insurance quote"  
[3] "cheap auto insurance quote"   "budget auto insurance quote" 
[5] "cheap car insurance quotes"   "budget car insurance quotes" 
[7] "cheap auto insurance quotes"  "budget auto insurance quotes"
-------------------------------------------------------------------------------------------------------
levelplot() y yholes <- c(LETTERS, sort(outer(LETTERS, LETTERS, paste, sep="")))[1:30]
xholes <- seq_along(yholes)
g <- expand.grid(X = xholes, Y = yholes)
set.seed(2)
dat <- with(g, data.frame(Y = factor(Y, levels = yholes), 
                          X = X, 
                          vals = runif(900))) R> head(dat)
  Y X      vals
1 A 1 0.1848823
2 A 2 0.7023740
3 A 3 0.5733263
4 A 4 0.1680519
5 A 5 0.9438393
6 A 6 0.9434750 expand.grid() levelplot() Y X levelplot() require(lattice)
levelplot(vals ~ X + Y, data = dat)
-------------------------------------------------------------------------------------------------------
z zF z z zz <- c(0.1, 0.5, 2)
combo <- expand.grid( x = c(1, 2, 3),
                      y = c(2, 4, 6),
                      z = zz )
combo$resp <- with(combo, x*y/z)
combo$zF <- with(combo, factor(z, levels=zz, labels=paste("z =", zz)))

levelplot(resp ~ x * y | zF, data = combo, pretty = TRUE, region = TRUE, 
          contour = FALSE)
-------------------------------------------------------------------------------------------------------
library(sfsmisc)

x <- seq(0, 1, length=1001)
y <- dbeta(x, 0.1, 0.1)
plot(x, y, type="h", log="xy", xaxt="n", yaxt="n", ylim=c(0.01, 0.5), main="Title")

atx <- c(0.0001, 0.001, 0.01, 0.1, 1, 10, 100)
eaxis(1, at=atx, labels=format(atx, drop0trailing=TRUE, scientific=FALSE), drop.1=FALSE, small.mult=10 )
aty <- c(0.01, 0.1, 0.5, 1, 10, 100)
eaxis(2, at=aty, labels=format(aty, drop0trailing=TRUE, scientific=FALSE), drop.1=FALSE, small.mult=10 )
grid()
-------------------------------------------------------------------------------------------------------
dat <- data.frame(item=rep(letters[1:3],times=3),outcome=runif(9))
dat$grp <- rep(c("grp1","grp1","grp2"),times=3)
ggplot(dat, aes(item, outcome))+
   stat_summary(fun.y=mean,aes(colour=grp), geom="point",size=3) aes ggplot(dat, aes(item, outcome)) + 
    stat_summary(fun.y=mean, geom="point",size=3) + 
    facet_grid(.~grp,scale="free_x",space="free")
-------------------------------------------------------------------------------------------------------
mlbtmp.txt selection <- read.table("mlbtmp.txt",skip=1)
names(selection) <- c("row","League","Division","Position","Team")
## arrange order/recode factors
selection <- transform(selection,
       Team=factor(Team,levels=rev(levels(Team))),
                   Position=factor(Position,levels=c("P","I","C","O"),
                                  labels=c("Pitching","Infield",
                                    "Center","Outfield"))) facet_grid facet_wrap scales coord_flip library(ggplot2)
p <- ggplot(data=selection, aes(x=Team, fill= Position))  +
  geom_bar(position="stack")
p + facet_grid(.~Division,scales="free_x") + coord_flip()  ## OK

## seems to fail with either "free_x" or "free_y"
p + facet_grid(Division~.,scales="free") + coord_flip()

## works but does not preserve 'count' axis:
p + facet_wrap(~Division,scales="free") facet_wrap(...,scales="free") ylim p + facet_wrap(~Division,scales="free") + coord_flip() +
  ylim(0,60) + opts(axis.text.y=theme_text(hjust=0)) ..density.. ..ncount.. ..ndensity.. stat_bin ..count.. ## pull out Team identification within Division and League
stab <- unique(subset(selection,select=c(Team,Division,League)))
## compute proportions by team
s2 <- melt(ddply(selection,"Team",function(x) with(x,table(Position)/nrow(x))))
## fix names
s2 <- rename(s2,c(variable="Position",value="proportion"))
## merge Division/League info back to summarized data
s3 <- merge(s2,stab)

p2 <- ggplot(data=s3, aes(x=Team, fill= Position,y=proportion))  +
  geom_bar(position="stack")+scale_y_continuous(formatter="percent")+
  geom_hline(yintercept=0.5,linetype=3)+ facet_wrap(~Division,scales="free") +
  opts(axis.text.y=theme_text(hjust=0))+coord_flip()
-------------------------------------------------------------------------------------------------------
expand.grid() expand.grid() letters() expand.grid() > expand.grid(letters[1:4], letters[5:8])
   Var1 Var2
1     a    e
2     b    e
3     c    e
4     d    e
5     a    f
6     b    f
7     c    f
8     d    f
9     a    g
10    b    g
11    c    g
12    d    g
13    a    h
14    b    h
15    c    h
16    d    h
-------------------------------------------------------------------------------------------------------
table() Frame FunSample <- function(Full, n) {
  Frame <- as.data.frame( lapply( expand.grid(lapply(dim(Full), seq)), factor) )  
  table( Frame[sample(1:nrow(Frame), n, prob = Full, replace = TRUE), ])
}   

> dim( FunSample(Full, 1))
[1] 2 2 2
> dim( FunSample(Full, 100))
[1] 2 2 2
-------------------------------------------------------------------------------------------------------
x <- runif(50, -10, 10)
y <- runif(50, -10, 10)
plot(x, y, yaxt="n") # don't plot y-axis, see ?par, section xaxt
axis(2, pos=0) # Draw y-axis at 0 line grid()
-------------------------------------------------------------------------------------------------------
dput dataset <- expand.grid(observer=LETTERS[1:3], condition=c("u","v"), 
                       stimulus1=1:2, stimulus2=1:2)
set.seed(5)
dataset$response <- sample(1:4, nrow(dataset), replace=TRUE)
datasettable <- addmargins(table(dataset), 4, FUN = sum) > datasettable[,'u',1,'sum',]
        response
observer 1 2 3 4
       A 1 1 0 0
       B 0 0 2 0
       C 0 1 0 1 reshape > library(reshape)
> dw <- cast(dataset, condition + stimulus1 + observer ~ response, 
             fun.aggregate=length, value="stimulus2")
> subset(dw, condition=="u" & stimulus1==1)
  condition stimulus1 observer 1 2 3 4
1         u         1        A 1 1 0 0
2         u         1        B 0 0 2 0
3         u         1        C 0 1 0 1 tableaccess <- function(tabl, ...) {
  d <- list(...)
  vv <- c(list(tabl), as.list(rep(TRUE, length(dim(tabl)))))
  vv[match(names(d), names(dimnames(datasettable)))+1] <- d
  do.call(`[`, vv)
} > tableaccess(datasettable, condition='u', stimulus1=1, stimulus2='sum')
        response
observer 1 2 3 4
       A 1 1 0 0
       B 0 0 2 0
       C 0 1 0 1
-------------------------------------------------------------------------------------------------------
get_all_factors <- function(n)
{
  prime_factor_tables <- lapply(n, function(i)
  {
    if(i == 1) return(table(1L))
    table(as.numeric(gmp::factorize(i)))
  })
  lapply(prime_factor_tables, function(pft)
  {
    powers <- mapply(
      function(name, value) as.numeric(name) ^ seq.int(0L, value),
      names(pft), 
      pft
    )
    power_grid <- expand.grid(powers)
    sort(apply(power_grid, 1, prod)) 
  })
}

get_all_factors(c(1L, 7L, 60, 2520))
-------------------------------------------------------------------------------------------------------
expand.grid col_pairs <- expand.grid(colnames(df1), colnames(df2)) col_sums <- apply(col_pairs, 1L, function(x) df1[, x["Var1"]] + df2[, x["Var2"]]) col_names <- apply(col_pairs, 1L, function(x) paste(x, collapse = ""))
colnames(col_sums) <- col_names
-------------------------------------------------------------------------------------------------------
with x > df <- expand.grid(A1=(1:3)*10,A2=1:3,A3=c("this","that"))
> x <- with(df, (A1 == 30 & A2 == 2 & A3 == "this"))
> subset(df, x)
  A1 A2   A3
6 30  2 this > df[x,]
  A1 A2   A3
6 30  2 this x df df$x <- with(df, (A1 == 30 & A2 == 2 & A3 == "this"))
subset(df,x)
-------------------------------------------------------------------------------------------------------
> # from ?ftable
> r <- ftable(Titanic, row.vars = 1:3)
> r
                   Survived  No Yes
Class Sex    Age                   
1st   Male   Child            0   5
             Adult          118  57

... snip ...

      Female Child            0   0
             Adult            3  20
> 
> # long format
> as.data.frame(r)
   Class    Sex   Age Survived Freq
1    1st   Male Child       No    0
2    2nd   Male Child       No    0
3    3rd   Male Child       No   35

... snip ...

30   2nd Female Adult      Yes   80
31   3rd Female Adult      Yes   76
32  Crew Female Adult      Yes   20
> 
> # wide format, but do not care the col name
> data.frame(expand.grid(rev(attr(r, "row.vars"))), unclass(r))
     Age    Sex Class  X1  X2
1  Child   Male   1st   0   5
2  Adult   Male   1st 118  57
3  Child Female   1st   0   1

... snip ...

14 Adult   Male  Crew 670 192
15 Child Female  Crew   0   0
16 Adult Female  Crew   3  20
> 
> # using reshape2 library
> library(reshape2)
> dcast(as.data.frame(r), as.formula(paste(paste(names(attr(r, "row.vars")), collapse="+"), "~", paste(names(attr(r, "col.vars"))))))
Using Freq as value column: use value_var to override.
   Class    Sex   Age  No Yes
1    1st   Male Child   0   5
2    1st   Male Adult 118  57
3    1st Female Child   0   1

... snip ...

14  Crew   Male Adult 670 192
15  Crew Female Child   0   0
16  Crew Female Adult   3  20
-------------------------------------------------------------------------------------------------------
tsc.p1 <- tsc.p + geom_rect(colour = I("grey")) +
          facet_grid(helmet~.) +
          geom_text(aes(x = c(9.0, 22.0, 33.0, 46.0, 72.0, 98.0),
                        y = 125,
                        label = c("C", "DS", "S", "ST", "Std", "T")),
                        size = 3) +
          scale_fill_brewer(palette = "Greys") +
          opts(title="Mosaic Plot of Helmet Type Use",
               legend.position="none") +
          scale_x_continuous("Percentage of Sample", expand = c(0, 0)) +
          scale_y_continuous("Percentage Responded", expand = c(0, 125)) +
          cood_cartesian(ylim = c(0, 101))
-------------------------------------------------------------------------------------------------------
dat <- data.frame(x=1:5,y1=6:10,y2=11:15)

#Collect all ordered pairs of elements of x
tmp <- expand.grid(dat$x,dat$x)
tmp <- tmp[tmp[,1] != tmp[,2],]

#Init a matrix to hold the results
rs <- as.matrix(cbind(tmp,matrix(NA,nrow(tmp),4)))

#Loop through each ordered pair
for (i in 1:nrow(rs)){
    rs[i,3:6] <- c(dat$y1[rs[i,1:2]],dat$y2[rs[i,1:2]])
}
-------------------------------------------------------------------------------------------------------
seqs <-c("seq1","seq2","seq3"); dat <- expand.grid(seqs,seqs, stringsAsFactors=FALSE)
dat
apply(dat, 1, function(seq) paste(seq[1], seq[2], sep="--") )
#[1] "seq1--seq1" "seq2--seq1" "seq3--seq1" "seq1--seq2" "seq2--seq2" "seq3--seq2" "seq1--seq3"
#[8] "seq2--seq3" "seq3--seq3" datr <- dat[dat[,1] > dat[,2] , ] datr datr$score <-  apply(datr, 1 , function(seq) {
                     score(pairwiseAlignment( seq[1], seq[2], 
                     substitutionMatrix=BLOSUM100, gapOpening=0, gapExtension=-5)) } library require
-------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------
tsc.p <- ggplot(tsc, 
                aes(ymin = ymin, ymax = ymax,
                    xmin = xmin, xmax = xmax,
                    fill = variable))
tsc.p1 <- tsc.p + geom_rect(colour = I("grey")) +
          facet_grid(helmet~.) +
          geom_text(aes(x = c(9.0, 22.0, 33.0),
                        y = 25,
                        label = ifelse(helmet == "FF",
                                       c("Cru", "DualSp", "Sport"),
                                       "")),
                        size = 3) +
          geom_text(aes(x = c(45.0, 72.0, 97.0),
                        y = 25,
                        label = ifelse(helmet == "FF",
                                       c("SptTour", "Std", "Tour"),
                                       "")),
                        size = 3) +
          scale_fill_brewer("Frequency of Helmet Use", palette = "Greys") +
          xlab("Percentage of Sample") +
          ylab("Percentage Responded") +
          opts(title="Mosaic Plot of Helmet Use by Helmet Type") +
          scale_x_continuous(expand = c(0, 0)) +
          scale_y_continuous(expand = c(0, 101)) +
          ylim(0, 101)
-------------------------------------------------------------------------------------------------------
foo<-data.frame(name=c("Bob","Sue", "Richard", "Jane"), 
    Start=as.POSIXct(c("2006-03-23 GMT", "2007-01-20 GMT", "2007-01-20 GMT", "2006-03-23 GMT")),
    End=as.POSIXct(c("2009-01-20 GMT", NA, "2006-03-23 GMT", NA)))


tmp <- expand.grid(foo$name,seq.POSIXt(as.POSIXct('2006-01-01'),
               as.POSIXct('2009-12-01'),by="month"))
colnames(tmp) <- c('name','date')
foo[is.na(foo)] <- max(tmp$date) + 1

tmp1 <- merge(tmp,foo,by="name")
tmp2 <- tmp1$Start <= tmp1$date & tmp1$End >= tmp1$date
aggregate(tmp2,by=list(date=tmp1$date),sum) seq.* paste ddply aggregate lapply
-------------------------------------------------------------------------------------------------------
help(melt.array) help(melt.data.frame) myMelt <- melt( draws, id.var = "iteration" ); ggplot(myMelt, aes(x = iteration,y = value)) + geom_point() + stat_smooth() + facet_grid(variable ~ ., scales="free")
-------------------------------------------------------------------------------------------------------
library("lattice")
x <- seq(pi/4, 5*pi, length.out=10)
y <- seq(pi/4, 5*pi, length.out=10)
r <- as.vector(sqrt(outer(x^2, y^2, "+")))
grid <- expand.grid(x=x, y=y)
grid$z <- cos(r^2)*exp(-r/(pi^3))

p <- levelplot(z~x*y, grid, 
               panel=function(...) {
                       arg <- list(...)
                       panel.levelplot(...)
                       panel.text(arg$x, arg$y, round(arg$z,1))})
print(p)
-------------------------------------------------------------------------------------------------------
ord <- do.call(order,c(dd[,20:34],decreasing=TRUE))
dd <- dd[ord,] as.list ?order do.call decreasing=TRUE c() X <- rev(expand.grid(x=1:2,y=1:3,z=1:4))
> head(X)
  z y x
1 1 1 1
2 1 1 2
3 1 2 1
4 1 2 2
5 1 3 1
6 1 3 2
ord <- do.call(order,c(X,decreasing=TRUE))
head(X[ord,])
head(X[ord,])
   z y x
24 4 3 2
23 4 3 1
22 4 2 2
21 4 2 1
20 4 1 2
19 4 1 1
-------------------------------------------------------------------------------------------------------
d <- data.frame(expand.grid(a=1:2,b=1:2,c=1:2),x=rnorm(8), y=rnorm(8)) 
p <- ggplot(d, aes(x, y)) + facet_grid(a~b) + geom_point() + 
coord_trans(x="reverse", y="reverse") + 
opts(strip.text.x=theme_text(angle=180), 
     strip.text.y=theme_text(angle=90), 
     axis.text.x=theme_text(angle=180), 
     axis.text.y=theme_text(angle=180), 
     axis.title.x=theme_text(angle=180), 
     axis.title.y=theme_text(angle=180)) 
print(p, vp=viewport(angle=180)) ... + coord_flip()
-------------------------------------------------------------------------------------------------------
set.seed(1)
n <- 100
dat <- data.frame(
    ds = sample(paste("x", 1:8, sep=""), n, replace=TRUE),
    size = runif(n, 0, 250),
    root = sample(c(TRUE, FALSE), n, replace=TRUE),
    test = sample(c("se", "cb", "cb.se"), n, replace=TRUE) 
)


head(dat)
  ds      size  root  test
1 x3 163.68098  TRUE cb.se
2 x3  88.29932  TRUE    se
3 x5  67.56504 FALSE    cb
4 x8 248.17102  TRUE    cb
5 x2 158.37332  TRUE    cb
6 x8  53.30203 FALSE cb.se

p <- ggplot(dat, aes(x=ds, y=size)) + 
  geom_jitter(aes(colour=root)) + 
  facet_grid(test~.) summarize ddply labels <- ddply(dat, .(ds, test), summarize, size=round(sum(size), 0))
head(labels)
  ds  test size
1 x1    cb  193
2 x1 cb.se  615
3 x1    se  274
4 x2    cb  272
5 x2 cb.se  341
6 x2    se 1012

p + geom_text(aes(x=ds, label=size, y=128), data=labels, size=2)
-------------------------------------------------------------------------------------------------------
expand.grid expand.grid(1:6,1:6)
expand.grid(1:6,1:6,1:4)
-------------------------------------------------------------------------------------------------------
rs <- ddply(mtcars,.(cyl),summarise,mn = mean(hp))

p + geom_hline(data=rs,aes(yintercept=mn)) ggplot stat_* geom aes ggplot geom data = ... geom geom_smooth p <- ggplot(data = mtcars,aes(x = wt, y = hp, colour = factor(cyl))) + 
    facet_grid(~cyl) + 
    geom_point() + 
    geom_smooth(se=FALSE,method="lm",formula=y~1,colour="black")
-------------------------------------------------------------------------------------------------------
d0 <- matrix(rnorm(15), ncol=3)
d1 <- matrix(rnorm(15), ncol=3)

# Using base R graphics
lmts <- range(d0,d1)

par(mfrow = c(1, 2))
boxplot(d0,ylim=lmts)
boxplot(d1,ylim=lmts) lattice ggplot2 # Using ggplot2
library(ggplot2)
d <- data.frame(d.type=c(rep(0,15),rep(1,15)),sub.type=rep(c('A','B','C'),10),val=rnorm(30))

p <- ggplot(d, aes(factor(sub.type), val)) 
p + geom_boxplot() + facet_grid(. ~ d.type) # Using lattice
library(lattice)
bwplot(~ val|sub.type+d.type ,d)
-------------------------------------------------------------------------------------------------------
#Replicate your example data
set.seed(1)
dat <- expand.grid(Study = 1:4,Experiment = 1:3, Response = LETTERS[1:4])
dat$Value1 <- runif(48)
dat$Value2 <- runif(48)

#Function to apply to each Response level
#Note the rather inefficient use of ddply 
# in a for loop to do the 'stratified' 
# subsampling you describe
myFun <- function(x,B){
    rs <- matrix(NA,B,2)
    for (i in 1:B){
        temp <- ddply(x,.(Study), .fun = function(x) x[sample(1:nrow(x),1),])
        rs[i,] <- colMeans(temp[,4:5])
    }
    c(Value1 = mean(x$Value1), quantile(rs[,1],probs=c(0.025,0.975)),
            Value2 = mean(x$Value2), quantile(rs[,2],probs=c(0.025,0.975)))
}

ddply(dat,.(Response),.fun = myFun,B=50) Response    Value1      2.5%     97.5%    Value2      2.5%     97.5%
1        A 0.4914725 0.2721876 0.8311799 0.4600546 0.2596446 0.6909686
2        B 0.5941457 0.4018281 0.8047503 0.5241470 0.2865285 0.7099486
3        C 0.4596998 0.2752685 0.6340614 0.5761497 0.3546133 0.8115933
4        D 0.5550651 0.2717772 0.7298913 0.4645609 0.1868757 0.7985816
-------------------------------------------------------------------------------------------------------
geom_tile() subset() # Generate data
pp <- function (n, r = 4) {
  x    <- seq(-r*pi, r*pi, len = n)
  df   <- expand.grid(x = x, y = x)
  df$r <- sqrt(df$x^2 + df$y^2)
  df$z <- cos(df$r^2)*exp(-df$r/6)
  df
}
pp20 <- pp(20)[sample(20*20, size = 200),]

df_grid  <- expand.grid(x = unique(pp20$x), y = unique(pp20$x))
df_merge <- merge(pp20, df_grid, by = c("x", "y"), all = TRUE)

# Missing values
ggplot(df_merge, aes(x = x, y = y)) +
  geom_tile(data = subset(df_merge, !is.na(z)), aes(fill = z)) +
  geom_tile(data = subset(df_merge,  is.na(z)), aes(colour = NA),
    linetype = 0, fill = "pink", alpha = 0.5)
-------------------------------------------------------------------------------------------------------
ggplot(dat, aes(Date,value))+ geom_point() + geom_vline(data=dat,aes(xintercept=as.numeric(event_date))) + facet_wrap(~ID)
-------------------------------------------------------------------------------------------------------
library(gridExtra)
manip <- mtcars
plot.list <- lapply(2:11, 
                    function(x)qplot(manip$mpg, y=manip[, x], 
                    ylab=names(manip)[x]))
do.call(grid.arrange, c(plot.list, nrow=10)) library(reshape2)
manip <- mtcars
mmanip <- melt(manip, id.vars="mpg")
str(mmanip)
ggplot(mmanip, aes(x=mpg, y=value)) + 
    geom_point(stat="identity") + 
    facet_grid(.~variable, scales="free")
-------------------------------------------------------------------------------------------------------
geom_text dfLab <- data.frame(variable = rep("A",3),
                    x = c(3,3,-3),
                    y = c(3,-3,-3),
                    lab = c('I','IV','III'))


ggplot(dfr,aes(x,y))+
 geom_point()+
 facet_grid(variable~.)+
 scale_x_continuous(limits=c(-6,6))+
 scale_y_continuous(limits=c(-6,6))+
 geom_hline(yintercept=0)+
 geom_vline(xintercept=0) + 
 geom_text(data = dfLab,aes(x=x,y=y,label=lab))
-------------------------------------------------------------------------------------------------------
ggplot scales="free" space="free" stat geom_bar ggplot(df, aes(x=a, fill=a)) + geom_bar() + facet_grid(~b)
-------------------------------------------------------------------------------------------------------
ggplot df = data.frame(val=rnorm(2005), class=c(rep(c('a','b'), 1000), rep('c', 5)))
dg <- data.frame(class=c("a","b","c"), value=rep(50,3))
qplot(val, ..count.., data=df, geom='density', fill=I('black')) +
    opts(strip.text.y = theme_text()) +
    facet_grid(class ~ ., scales="free", space="free") + 
    geom_blank(data=dg, aes(x=0, y=value)) geom_blank geom_point
-------------------------------------------------------------------------------------------------------
combo_kj <- expand.grid(ksym=symbol[1:k], jdates=dates[1:j])

SQLcalls <- paste('select close from stkData where symbol = ',
                   combo_kj$ksym,
                   ' and date = '
                   combo_kj$jdates,
                   sep="")
-------------------------------------------------------------------------------------------------------
questionnumbers<-c(1,2,3,4,5,6,7,8)
result1<-c(0.2,0.4,0.3,0.6,0.9,0.3,0.4,0.8)
result2<-c(0.4,0.9,0.3,0.1,0.4,0.6,0.3,0.2)

plot(questionnumbers, result2, type = 'b', ylim = c(0,0.9), col = 'green', xlab = 'Question Nunbers', ylab = '', main = 'Chart 2', panel.first = grid(nx = NA, ny = NULL))
lines(questionnumbers, result1, col = 'blue', type = 'b')
legend('bottomleft', c('result1','result2'), fill = c('blue', 'green'), cex = 0.8, bty = 'n', horiz = TRUE)
-------------------------------------------------------------------------------------------------------
dat <- read.csv("ggplot.csv")
ggplot(dat, aes(x = Optimal, y = Proportion_Choosing_Message)) + 
  facet_grid(condition~type) + 
  geom_point()
-------------------------------------------------------------------------------------------------------
ggplot2 grid stat_function ggplot2 qplot ggplot aes=aes(y=..density..)) stat_function library(ggplot2)
data <- data.frame(V1 <- rnorm(700), V2=sample(LETTERS[1:7], 700, replace=TRUE))
ggplot(data, aes(x=V1)) + 
  stat_bin(aes(y=..density..)) + 
  stat_function(fun=dnorm) + 
  facet_grid(V2~.)
-------------------------------------------------------------------------------------------------------
interpolate intamap library(intamap)
library(lattice)

# Generate an example dataset
set.seed(10)

class1 <- data.frame(lon=rnorm(50, mean=-46, sd=4), 
                     lat=rnorm(50, mean=32, sd=4), 
                     value=1)

class2 <- data.frame(lon=rnorm(50, mean=-40, sd=4), 
                     lat=rnorm(50, mean=39, sd=4), 
                     value=2)

class3 <- data.frame(lon=rnorm(50, mean=-50, sd=3), 
                     lat=rnorm(50, mean=40, sd=2), 
                     value=3)

df <- rbind(class1, class2, class3)

# Generate a 50 x 50 grid over which to predict new values
prediction.grid <- expand.grid(lon=seq(from=min(df$lon), 
                                       to=max(df$lon), 
                                       length=50),
                               lat=seq(from=min(df$lat), 
                                       to=max(df$lat), 
                                       length=50))
# Spatialize the data.frames                           
coordinates(df) <- c("lon", "lat")
gridded(prediction.grid) <- c("lon", "lat")

fit <- interpolate(df, prediction.grid)

# Built-in plots, including variogram and pertinent stats:
plot(fit)

# Pull out the fitted values into a dataframe
predictions <- as.data.frame(t(fit$outputTable))

levelplot(mean ~ x * y, data=predictions, region=TRUE, aspect="fill")
-------------------------------------------------------------------------------------------------------
plot() type = "n" abline() grid() points() x <- seq(0, 10)
y <- x
plot(x, y, type = "n")
abline(h = seq(0, 10, .5), col = 'lightgray', lty = 3)
abline(v = seq(0, 10, .5), col = 'lightgray', lty = 3)
points(x, y, col = 'red', type = 'o', lwd = 3, pch = 15) ## using `grid()`
plot(x, y, type = "n")
grid()
points(x, y, col = 'red', type = 'o', lwd = 3, pch = 15) ?grid abline()
-------------------------------------------------------------------------------------------------------
hjust vjust hjust vjust td <- expand.grid(
    hjust=c(0, 0.5, 1),
    vjust=c(0, 0.5, 1),
    angle=c(0, 45, 90),
    text="text"
)

ggplot(td, aes(x=hjust, y=vjust)) + 
    geom_point() +
    geom_text(aes(label=text, angle=angle, hjust=hjust, vjust=vjust)) + 
    facet_grid(~angle) +
    scale_x_continuous(breaks=c(0, 0.5, 1), expand=c(0, 0.2)) +
    scale_y_continuous(breaks=c(0, 0.5, 1), expand=c(0, 0.2)) hjust DF <- data.frame(x=LETTERS[1:3],y=1:3)
p <- ggplot(DF, aes(x,y)) + geom_point() + 
    ylab("Very long label for y") +
    opts(axis.title.y=theme_text(angle=0))


p1 <- p + opts(axis.title.x=theme_text(hjust=0)) + xlab("X-axis at hjust=0")
p2 <- p + opts(axis.title.x=theme_text(hjust=0.5)) + xlab("X-axis at hjust=0.5")
p3 <- p + opts(axis.title.x=theme_text(hjust=1)) + xlab("X-axis at hjust=1")

library(ggExtra)
align.plots(p1, p2, p3) vjust DF <- data.frame(x=c("a\na","b","cdefghijk","l"),y=1:4)
p <- ggplot(DF, aes(x,y)) + geom_point()

p1 <- p + opts(axis.text.x=theme_text(vjust=0, colour="red")) + 
        xlab("X-axis labels aligned with vjust=0")
p2 <- p + opts(axis.text.x=theme_text(vjust=0.5, colour="red")) + 
        xlab("X-axis labels aligned with vjust=0.5")
p3 <- p + opts(axis.text.x=theme_text(vjust=1, colour="red")) + 
        xlab("X-axis labels aligned with vjust=1")


library(ggExtra)
align.plots(p1, p2, p3)
-------------------------------------------------------------------------------------------------------
set.seed(1234)
df2 <- data.frame(year = rep(2006:2007), 
                  variable = rep(c("VX","VB","VZ","VD"), each = 2),
                  value = runif(8, 5,10),
                  vartype = rep(c("TA","TB"), each = 4)) variable vartype ggplot() > with(df2, order(vartype, variable))
[1] 3 4 1 2 7 8 5 6 vartype variable vartype variable > with(df2, reorder(variable, order(vartype, variable)))
[1] VX VX VB VB VZ VZ VD VD
attr(,"scores")
 VB  VD  VX  VZ 
1.5 5.5 3.5 7.5 
Levels: VB VX VD VZ attr(,"scores") ggplot() ggplot() decreasing = TRUE order() ## reorder `variable` on `variable` within `vartype`
df3 <- transform(df2, variable = reorder(variable, order(vartype, variable,
                                                         decreasing = TRUE))) ggplot(df3, aes(x=variable, y=value, fill=vartype)) +
       geom_bar() + 
       facet_grid(. ~ year) + 
       coord_flip()
-------------------------------------------------------------------------------------------------------
[ foo[4] foo["bias"] bias $bias $ [ station member dat <- expand.grid(station = rep(1:3,each = 2),member = rep(1:3,each = 2))
dat$bias <- sample(50:100,36,replace = TRUE)

tmp <- split(dat,dat$station)
tmp <- lapply(tmp,function(x){split(x,x$member)})

> tmp
$`1`
$`1`$`1`
  station member bias
1       1      1   87
2       1      1   82
7       1      1   51
8       1      1   60

$`1`$`2`
   station member bias
13       1      2   64
14       1      2  100
19       1      2   68
20       1      2   74
etc. tmp dat rbind newDat <- do.call(rbind,lapply(tmp,function(x){do.call(rbind,x)}))
rownames(newDat) <- NULL library(plyr)
#Find the max bias for each unique station+member
ddply(newDat,.(station,member),summarise, mx = max(bias))
  station member  mx
1       1      1  87
2       1      2 100
3       1      3  91
4       2      1  94
5       2      2  88
6       2      3  89
7       3      1  74
8       3      2  88
9       3      3  99

#Or maybe the max bias for each station across all members
ddply(newDat,.(station),summarise, mx = max(bias))
  station  mx
1       1 100
2       2  94
3       3  99
-------------------------------------------------------------------------------------------------------
?levelplot z~x*y z x y x y z~x+y z x y ?formula x <- seq(pi/4, 5 * pi, length.out = 100)
y <- seq(pi/4, 5 * pi, length.out = 100)
r <- as.vector(sqrt(outer(x^2, y^2, "+")))
grid <- expand.grid(x=x, y=y)
grid$z <- cos(r^2) * exp(-r/(pi^3))
levelplot(z~x*y, grid, cuts = 50, scales=list(log="e"), xlab="",
          ylab="", main="Weird Function", sub="with log scales",
          colorkey = FALSE, region = TRUE)
-------------------------------------------------------------------------------------------------------
dat$Gene.Name <- factor(dat$Gene.Name, levels= levels(rev(dat$Gene.Name))
a <- ggplot(dat, aes(x = expression, y = Gene.Name))
a + geom_point() + facet_grid(. ~ cell.type)
-------------------------------------------------------------------------------------------------------
plyr library(plyr); library(dynlm); library(tseries)

# FUNCTION TO RUN A SINGLE REGRESSION
foo = function(x, l) dynlm(log(GNP) ~ L(get(as.character(x)), l), data = US)

# CREATE PARAMETER GRID
params = expand.grid(x = colnames(US)[-2], l = c(0, 1, 4))

# RUN REGRESSIONS
regressions = mlply(params, foo)
-------------------------------------------------------------------------------------------------------
ggplot library(ggplot2)
library(reshape2)

x <- data.frame(
  Period = c(1,1,2,2,3,3,4,4),
  Sample = c("A","B","A","B","A","B","A","B"),
  Value1 = c(3,2,6,7,3,2,1,2),
  Value2 = c(1,0,5,2,2,0,2,5)
)

mx <- melt(x, id.vars=1:2)
ggplot(mx, aes(x=Period, y=value, fill=variable)) + 
  geom_bar(stat="identity") + 
  facet_grid(~Sample)
-------------------------------------------------------------------------------------------------------
facet_grid lat subject x.sub_ki x.sub_kn subject lat hist_K_sub <- 
ggplot() +
  geom_histogram(data=x.sub_ki, aes(x=lat, fill="inverted",     y= ..count..), binwidth=20) +
  geom_histogram(data=x.sub_kn, aes(x=lat, fill="not inverted", y=-..count..), binwidth=20) +
  facet_grid(subject ~ .) +
  scale_y_continuous(formatter="my.abs") +
  scale_fill_hue("variable") +
  coord_flip()

hist_K_sub
-------------------------------------------------------------------------------------------------------
lattice ?levelplot abline lattice panel panel.* panel.abline panel ?levelplot x <- seq(pi/4, 5 * pi, length.out = 100)
y <- seq(pi/4, 5 * pi, length.out = 100)
r <- as.vector(sqrt(outer(x^2, y^2, "+")))
grid <- expand.grid(x=x, y=y)
grid$z <- cos(r^2) * exp(-r/(pi^3))
levelplot(z~x*y, grid,
        panel = function(...){
            panel.levelplot(...)
            panel.abline(h = 2.5)
            panel.abline(v = 2.5)
        }, 
        cuts = 50, scales=list(log="e"), xlab="",
        ylab="", main="Weird Function", sub="with log scales",
        colorkey = FALSE, region = TRUE) panel.levelplot panel.abline
-------------------------------------------------------------------------------------------------------
xy <- expand.grid(mech=1:mechrow, pro=1:prorow)
ok <- (procedural[xy$pro, 16] == mechanical[xy$mech, 16] &
       procedural[xy$pro, 17] <  mechanical[xy$mech, 17] &
       procedural[xy$pro,  2] == mechanical[xy$mech,  2] &
       abs(procedural[xy$pro, 17] -  mechanical[xy$mech, 17]) < 180)
pro   <- procedural[xy$pro[ok],]
other <- mechanical[xy$mech[ok],]
numprocissues <- tapply(ok, xy$mech, sum)
-------------------------------------------------------------------------------------------------------
do.call expand.grid x <- seq(0,10, length.out=10)
> y <- seq(-1,1, length.out=5)
> d1 <- expand.grid(x=x, y=y)  
> do.call("*", d1)
 [1]   0.0000000  -1.1111111  -2.2222222  -3.3333333  -4.4444444
 [6]  -5.5555556  -6.6666667  -7.7777778  -8.8888889 -10.0000000
[11]   0.0000000  -0.5555556  -1.1111111  -1.6666667  -2.2222222
[16]  -2.7777778  -3.3333333  -3.8888889  -4.4444444  -5.0000000
[21]   0.0000000   0.0000000   0.0000000   0.0000000   0.0000000
[26]   0.0000000   0.0000000   0.0000000   0.0000000   0.0000000
[31]   0.0000000   0.5555556   1.1111111   1.6666667   2.2222222
[36]   2.7777778   3.3333333   3.8888889   4.4444444   5.0000000
[41]   0.0000000   1.1111111   2.2222222   3.3333333   4.4444444
[46]   5.5555556   6.6666667   7.7777778   8.8888889  10.0000000
-------------------------------------------------------------------------------------------------------
> ncol <- 10
> apply(expand.grid(c("a","b","c","d"),1:((ncol+3)/4)), 1,
+   function(x)paste(x,collapse=""))[1:ncol]
 [1] "a1" "b1" "c1" "d1" "a2" "b2" "c2" "d2" "a3" "b3" ncol
-------------------------------------------------------------------------------------------------------
> expand.grid(seq(ncol(a)),seq(nrow(a)))[,2:1]
   Var2 Var1
1     1    1
2     1    2
3     1    3
4     2    1
5     2    2
6     2    3
7     3    1
8     3    2
9     3    3
10    4    1
11    4    2
12    4    3
13    5    1
14    5    2
15    5    3
-------------------------------------------------------------------------------------------------------
rep data.frame(row=rep(seq(nrow(a)), each=ncol(a)), col=rep(seq(ncol(a)), nrow(a))) # Make up a huge matrix...
a <- matrix(runif(1e7), 1e4)

system.time( a1<-data.frame(row = as.vector(t(row(a))),
                            col = as.vector(t(col(a)))) ) # 0.68 secs

system.time( a2<-expand.grid(col = seq(ncol(a)),
                             row = seq(nrow(a)))[,2:1] ) # 0.49 secs

system.time( a3<-data.frame(row=rep(seq(nrow(a)), each=ncol(a)),
                            col=rep(seq(ncol(a)), nrow(a))) ) # 0.59 secs

identical(a1, a2) && identical(a1, a3) # TRUE
-------------------------------------------------------------------------------------------------------
geom_tile ggplot2 dat <- read.table(textConnection("Person,Messages
Dave,8
James,6
Dave,6
Dave,8
Dave,8
John,5
John,5
John,20
Dave,0"),sep = ",",header = TRUE)


dat <- ddply(dat,.(Person,Messages),summarise,val = length(Person))
ggplot(dat,aes(x = Messages, y = Person, fill = val)) + 
        geom_tile() image dat #Some data to pad with the missing combinations
pad <- expand.grid(unique(dat$Person),
                    min(dat$Messages):max(dat$Messages))
colnames(pad) <- c('Person','Messages')

#Aggregate the data and merge with pad data
dat <- ddply(dat,.(Person,Messages),summarise,val = length(Person))
tmp <- merge(dat,pad,all.y = TRUE)

#Convert from long to wide
rs <- cast(tmp,Person~Messages,value = 'val')

#Clean up the result
rownames(rs) <- rs$Person
rs <- rs[,-1]
rs[is.na(rs)] <- 0

> rs
      0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
Dave  1 0 0 0 0 0 1 0 3 0  0  0  0  0  0  0  0  0  0  0  0
James 0 0 0 0 0 0 1 0 0 0  0  0  0  0  0  0  0  0  0  0  0
John  0 0 0 0 0 2 0 0 0 0  0  0  0  0  0  0  0  0  0  0  1
-------------------------------------------------------------------------------------------------------
FakeData # Create all combinations of months and years
allMonths <- expand.grid(DischargeMonth=1:12, DischargeYear=2010:2011)
# Keep all month-year combinations (all.x=TRUE) and add in 'Cases' from FakeData
allData <- merge(allMonths, FakeData, all.x=TRUE)
# 'allData' contains 'NA' for missing values. Set them to 0.
allData[is.na(allData)] <- 0
# Print results
allData
-------------------------------------------------------------------------------------------------------
ggplot library(ggplot2)

blocks <- expand.grid(
  x = 1:ncol(mydes),
  y = 1:nrow(mydes)
)

blocks$label <- unname(rapply(mydes, as.character))

ggplot(blocks) + 
  geom_rect(aes(xmin=x-0.4, xmax=x+0.4, ymin=y-0.4, ymax=y+0.4), fill="cyan") +
  geom_text(aes(label=label, x=x, y=y)) +
  xlab("Blocks") + ylab("Treatments") ggplot(blocks) + 
  geom_rect(aes(xmin=x-0.4, xmax=x+0.4, ymin=y-0.4, ymax=y+0.4, fill=label)) +
  geom_text(aes(label=label, x=x, y=y)) +
  xlab("Blocks") + ylab("Treatments") +
  scale_fill_hue("Treatment", h=c(90, 150))
-------------------------------------------------------------------------------------------------------
list() c() set.seed(12345)
data = expand.grid(trial=1:10, stim1=1:5, stim2=1:3)
data = data.frame(data, response=rnorm(nrow(data)))

with(data, tapply(response, list(stim1,stim2), mean)) 1           2           3
1 -0.13294415  0.27326245 -0.11120045
2  0.28597776  0.02338804  0.21280916
3  0.08338741  0.44086561 -0.08682628
4  0.72432003  0.84250712  0.28383378
5 -0.06290978 -0.02588252 -0.36364019
-------------------------------------------------------------------------------------------------------
caret nnet size decay #Load Packages
require(quantmod) #for Lag()
require(nnet)
require(caret)

#Make toy dataset
y <- sin(seq(0, 20, 0.1))
te <- data.frame(y, x1=Lag(y), x2=Lag(y,2))
names(te) <- c("y", "x1", "x2")

#Fit model
model <- train(y ~ x1 + x2, te, method='nnet', linout=TRUE, trace = FALSE,
                #Grid of tuning parameters to try:
                tuneGrid=expand.grid(.size=c(1,5,10),.decay=c(0,0.001,0.1))) 
ps <- predict(model, te)

#Examine results
model
plot(y)
lines(ps, col=2) neuralnet RSNNS caret nnet neuralnet RSNNS caret RSNNS caret caret
-------------------------------------------------------------------------------------------------------
date data.frame FECHA.H_SOLAR datos <- source("http://ubuntuone.com/42j1RqUmNmxUuCppW4gElX")[[1]]
library(reshape2)
library(ggplot2)

datos$PRECIP[is.na(datos$PRECIP)] <- 0
dm <- melt(datos,id="FECHA.H_SOLAR")
# change FECHA.H_SOLAR to POSIXct so you get your dates right
dm$Fecha <- as.POSIXct(dm$FECHA.H_SOLAR, "%y/%m/%d %H:%M:%S", tz = "")
qplot(Fecha, value, data = dm, geom = "line", group = variable) +
  facet_grid(variable ~ ., scale = "free_y")
-------------------------------------------------------------------------------------------------------
x = 1:ncol(pval)
y = 1:nrow(pval)

# Colored backgrounds
dev.new(width=4, height=4)
image(x, y, t(as.matrix(pval)),
  col = c('red', 'yellow', 'red'),
  breaks = c(0, 0.3, 0.7, 1),
  xaxt='n', 
  yaxt='n', 
  ylim=c(max(y)+0.5, min(y)-0.5), 
  xlab='', 
  ylab='')
centers = expand.grid(y, x)
text(centers[,2], centers[,1], unlist(gen)) # Colored text
dev.new(width=4, height=4)
image(x,y, matrix(0, length(x), length(y)),
  col='white',
  xaxt='n', 
  yaxt='n', 
  ylim=c(max(y)+0.5, min(y)-0.5), 
  xlab='', 
  ylab='')
pvals = unlist(pval)
cols = rep('red', length(pvals))
cols[pvals>0.3 & pvals<=0.7] = 'yellow'
text(centers[,2], centers[,1], unlist(gen), col=cols)
grid(length(x),length(y))
-------------------------------------------------------------------------------------------------------
fields Tps require(fields)

dev.new(width=6, height=6)
set.panel(2,2)

# Plot x,y
plot(mat1)

# Model z = f(x,y) with splines
fit = Tps(mat1, z)
pred = predict.surface(fit)

# Plot fit
image(pred)
surface(pred)

# Plot standard error of fit 
xg = make.surface.grid(list(pred$x, pred$y))
pred.se = predict.se(fit, xg)

surface(as.surface(xg, pred.se))
-------------------------------------------------------------------------------------------------------
xlab(NULL) xlab(" ") opts(plot.margin = unit(c(0,0,0,0), "cm")) mdatos <- melt(datos[, -1], id.vars = "dia")
(p_all <- ggplot(mdatos, aes(dia, value)) +
  geom_line(colour = "blue") +
  facet_grid(variable ~ ., scale = "free_y") +
  xlab("Day") +
  ylab(NULL) 
)
-------------------------------------------------------------------------------------------------------
g y dfr <- data.frame(
  x = rep.int(1:10, 5),
  y = runif(50),
  g = gl(5, 10)
)
dfr$is.5 <- dfr$g == "5"
dfr$y.5 <- with(dfr, ifelse(is.5, y, NA)) 
dfr$y.not.5 <- with(dfr, ifelse(is.5, NA, y)) (p1 <- ggplot(dfr) +
  geom_line(aes(x, y.not.5)) +
  geom_point(aes(x, y.5)) +
  facet_grid(g ~ .)
) (p2 <- ggplot(dfr) +
  geom_line(aes(x, y.not.5)) +
  geom_bar(aes(y.5)) +
  facet_grid(g ~ .)
) Viewport
-------------------------------------------------------------------------------------------------------
expand.grid > colors = c("red", "green", "blue") 
> days = c("Monday", "Tuesday") 
> expand.grid(colors,days)
   Var1    Var2
1   red  Monday
2 green  Monday
3  blue  Monday
4   red Tuesday
5 green Tuesday
6  blue Tuesday
-------------------------------------------------------------------------------------------------------
facet_grid space='free' require(ggplot2)

x = 1:9
group = rep(1:3, each=3)
data = data.frame(x, group)
qplot(x, x, data=data) + facet_grid(~group, scales='free', space='free')
-------------------------------------------------------------------------------------------------------
set.seed(12345)
data = expand.grid(time=1:100, Location=factor(1:3))
data$conc = with(data, 0.1*time + as.numeric(Location)) + rnorm(nrow(data)) ?xyplot scales tick.number ylim tck
-------------------------------------------------------------------------------------------------------
with(expand.grid(a = 1:3, b = 1:3), replace(m, cbind(a, a, b), 5))
-------------------------------------------------------------------------------------------------------
set.seed(310366)

nx=5
ny=6
SOI=matrix(rnorm(nx*ny,100,50),nx,ny)

colnames(SOI)=paste("NAP_G0",sort(as.integer(runif(ny,10,99))),sep="")
rownames(SOI)=sample(2315101:(2315101+nx-1))
above150 = SOI>150
below30=SOI<30

makeRects <- function(tfMat,border){
  cAbove = expand.grid(1:nx,1:ny)[tfMat,]
  xl=cAbove[,1]-0.49
  yb=cAbove[,2]-0.49
  xr=cAbove[,1]+0.49
  yt=cAbove[,2]+0.49
  rect(xl,yb,xr,yt,border=border,lwd=3)
}

heatmap(t(SOI),Rowv = NA, Colv=NA, add.expr = {
 makeRects(above150,"red");makeRects(below30,"blue")})
-------------------------------------------------------------------------------------------------------
Call:
svm(formula = q ~ ., data = data, kernel = "linear")

Parameters:
SVM-Type:  C-classification ?svm type: ‘svm’ can be used as a classification machine, as a
      regression machine, or for novelty detection.  Depending of
      whether ‘y’ is a factor or not, the default setting for
      ‘type’ is ‘C-classification’ or ‘eps-regression’,
      respectively, but may be overwritten by setting an explicit
      value. type classification 2 > require(e1071) # for svm()                                                                                                                                                          
> require(rgl) # for 3d graphics.                                                                                                                                                                                    
> set.seed(12345)                                                                                                                                                                     
> seed <- .Random.seed                                                                                                                                                                
> t <- data.frame(x=runif(100), y=runif(100), z=runif(100), cl=NA)
> t$cl <- 2 * t$x + 3 * t$y - 5 * t$z                                                                                                                                                 
> t$cl <- as.factor(ifelse(t$cl>0,1,-1))
> t[1:4,]
           x         y         z cl
 1 0.7209039 0.2944654 0.5885923 -1
 2 0.8757732 0.6172537 0.8925918 -1
 3 0.7609823 0.9742741 0.1237949  1
 4 0.8861246 0.6182120 0.5133090  1 kernel='linear' w1*x + w2*y + w3*z - w0 svm() > svm_model <- svm(cl~x+y+z, t, type='C-classification', kernel='linear',scale=FALSE) type=C-classification scale=FALSE svm() svm_model w <- t(svm_model$coefs) %*% svm_model$SV svm_model svm_model$rho plane3d (x,y) z detalization <- 100                                                                                                                                                                 
grid <- expand.grid(seq(from=min(t$x),to=max(t$x),length.out=detalization),                                                                                                         
                    seq(from=min(t$y),to=max(t$y),length.out=detalization))                                                                                                         
z <- (svm_model$rho- w[1,1]*grid[,1] - w[1,2]*grid[,2]) / w[1,3]

plot3d(grid[,1],grid[,2],z)  # this will draw plane.
# adding of points to the graphics.
points3d(t$x[which(t$cl==-1)], t$y[which(t$cl==-1)], t$z[which(t$cl==-1)], col='red')
points3d(t$x[which(t$cl==1)], t$y[which(t$cl==1)], t$z[which(t$cl==1)], col='blue') rgl
-------------------------------------------------------------------------------------------------------
dat.vline <- data.frame(Type = c("Category1", "Category2"), xp = c(1000, 4000))
dat.text <- data.frame(Type = c("Category1", "Category2"), x = c(1000, 4000), y = c(5, 10), label = c("hoge", "boke"))

ggplot(d, aes(Time, Total)) + 
  facet_grid(Type ~ .) + 
  geom_line(aes(group = Type, colour = Type, linetype = Type), size = 1.5) +
  geom_vline(aes(xintercept = xp), data = dat.vline) +
  geom_text(aes(x, y, label = label), data = dat.text)
-------------------------------------------------------------------------------------------------------
... + opts(legend.direction="horizontal")
... + opts(legend.direction="vertical")
-------------------------------------------------------------------------------------------------------
expand.grid data.frame expand.grid(
    c(1, 2),
    c(3, 4),
    c(2, 3)
)

  Var1 Var2 Var3
1    1    3    2
2    2    3    2
3    1    4    2
4    2    4    2
5    1    3    3
6    2    3    3
7    1    4    3
8    2    4    3
-------------------------------------------------------------------------------------------------------
do.call() expand.grid() > l <- list(a = 1:2, b = 3:4, c = 2:3)
> do.call(expand.grid, l)
  a b c
1 1 3 2
2 2 3 2
3 1 4 2
4 2 4 2
5 1 3 3
6 2 3 3
7 1 4 3
8 2 4 3 expand.grid() > expand.grid(l)
  a b c
1 1 3 2
2 2 3 2
3 1 4 2
4 2 4 2
5 1 3 3
6 2 3 3
7 1 4 3
8 2 4 3
-------------------------------------------------------------------------------------------------------
ggplot set.seed(1234)
mydf <- rbind(
    data.frame(gen="Aa", yvar= rnorm(40000, 50, 10)),
    data.frame(gen="Bb", yvar=rnorm(4000, 70, 10)),
    data.frame(gen="Cc", yvar=rnorm(400, 75, 10)),
    data.frame(gen="Dd", yvar=rnorm(40, 80, 10))
)

labels <- ddply(mydf, .(gen), nrow)
means  <- ddply(mydf, .(gen), summarize, mean=mean(yvar))

ggplot(mydf, aes(x=yvar)) + 
    stat_density(fill="blue") + 
    facet_grid(gen~.) + 
    theme_bw() +
    geom_vline(data=means, aes(xintercept=mean), colour="red") + 
    geom_text(data=labels, aes(label=paste("n =", V1)), x=5, y=0, 
        hjust=0, vjust=0) +
    opts(title="Distribution")
-------------------------------------------------------------------------------------------------------
require(ggplot2)
set.seed(1234)
Aa = c(rnorm(40000, 50, 10))
Bb = c(rnorm(4000, 70, 10))
Cc = c(rnorm(400, 75, 10))
Dd = c(rnorm(40, 80, 10))
yvar = c(Aa, Bb, Cc, Dd)
gen <- c(rep("Aa", length(Aa)),rep("Bb", length(Bb)), rep("Cc", length(Cc)),
            rep("Dd", length(Dd)))
mydf <- data.frame(grp = gen,x = c(Aa,Bb,Cc,Dd))
mydf1 <- mydf 
#Calculate the densities and an indicator for the desire quantile
# for later use in subsetting
mydf <- ddply(mydf,.(grp),.fun = function(x){
    tmp <- density(x$x)
    x1 <- tmp$x
    y1 <- tmp$y
    q80 <- x1 >= quantile(x$x,0.8)
    data.frame(x=x1,y=y1,q80=q80)
})
    #Separate data frame for the means
mydfMean <- ddply(mydf,.(grp),summarise,mn = mean(x))
labels <- ddply(mydf1, .(grp), nrow)
       ggplot(mydf,aes(x = x)) + 
            facet_grid(grp~.)  +
            geom_line(aes(y = y)) + 
            geom_ribbon(data = subset(mydf,q80),aes(ymax = y),ymin = 0, 
fill = "black")            +       
 geom_vline(data = mydfMean,aes(xintercept = mn),
colour = "black") +         geom_text(data=labels, 
aes(label=paste("n =", labels$V1)), x=5, y=0,
                 hjust=0, vjust=0) +    
opts(title="Distribution") +  theme_bw()
-------------------------------------------------------------------------------------------------------
plot(x, y*10, type = 'l', ylim = range(c(y*10,y1)), yaxt = 'n', col = 'red')
axis(2, (1:6)*10, 1:6, col = 'red')
lines(x1, y1, col = 'blue')
axis(4, (1:6)*10, col = 'blue')
grid(nx = NA, ny = NULL)
-------------------------------------------------------------------------------------------------------
ggplot2 # sample data
df <- data.frame(expand.grid(x = 1:4, y = 1:4), v = runif(16, -10, 10))

# plot
ggplot(df, aes(x, y, fill = v, label = sprintf("%.1f", v))) + 
  geom_tile() + geom_text() +
  scale_fill_gradient2(low = "blue", high = "red")
-------------------------------------------------------------------------------------------------------
# From http://stackoverflow.com/questions/3063165/
#     r-building-a-simple-command-line-plotting-tool-
#     capturing-window-close-events

require(tcltk)
library(tkrplot)

## function to display plot, called by tkrplot and embedded in a window
plotIt <- function(){ plot(x=1:10, y=1:10) }
tt <- tktoplevel()       ## create top level window event handler
done <- tclVar(0)        ## variable to wait on    
## bind to the window destroy event, set done variable when destroyed
tkbind(tt,"<Destroy>",function() tclvalue(done) <- 1)
## Have tkrplot embed the plot window, then realize it with tkgrid
tkgrid(tkrplot(tt,plotIt))
tkwait.variable(done)    ## wait until done is true
## script continues, or exits, ... once plot is closed
-------------------------------------------------------------------------------------------------------
meshgrid >> [x y] = meshgrid(2:4, 3:7);
>> [x(:) y(:)]

ans =

     2     3
     2     4
     2     5
     2     6
     2     7
     3     3
     3     4
     3     5
     3     6
     3     7
     4     3
     4     4
     4     5
     4     6
     4     7
-------------------------------------------------------------------------------------------------------
nov_dates <- expand.grid(1:30, 11, 1900:2011) 
nov_dates <- apply(nov_dates, 1, paste, collapse = "-")
nov_dates <- dmy(nov_dates)
nov_wed   <- nov_dates[wday(nov_dates, label = TRUE) == 'Wed']
nov_4wed  <- nov_wed[seq_along(nov_wed) %% 4 == 0] library(plyr)
library(lubridate)
nov_dates <- expand.grid(day = 1:30, month = 11, year = 1900:2011) 
nov_dates <- transform(nov_dates, 
   date = dmy(paste(day, month, year, sep = "-"))

nov_4_wed <- ddply(nov_dates, .(year), summarize, date[wday(date) == 4][4])
-------------------------------------------------------------------------------------------------------
f <- function(x, height) {
 ans <- median(x)
 data.frame(ymin = ans-height/2, ymax = ans+height/2, y = ans)
}

df <- data.frame(x=gl(2,6), y=c(1,1,1,1,3,3, 1,1,3,3,3,3))
ggplot(df, aes(x, y)) + geom_boxplot() + 
 stat_summary(fun.data = f, geom = "crossbar", height = 0.1,
  colour = NA, fill = "skyblue", width = 0.8, alpha = 0.5) df <- data.frame(x=gl(2,6), y=c(c(1,1,1,1,3,3), c(1,1,3,3,3,3)*10))
ggplot(df, aes(x, y)) + geom_boxplot() + facet_grid(x~.)

gs <- grid.gget("geom_boxplot", grep = T)
if (inherits(gs, "grob")) gs <- list(gs)
gss <- llply(gs, function(g) g$children[[length(g$children)]])

l_ply(gss, function(g) grid.edit(g$name, grep=T, just = c("left", "center"), height = unit(0.05, "native"), gp = gpar(fill = "skyblue", alpha = 0.5, col = NA)))
-------------------------------------------------------------------------------------------------------
position_dodge(0.5) DF <- data.frame(
  expand.grid(Date=c("2006-09-01", "2007-09-01", "2008-09-01" ,"2009-09-01"),
     Type = c("A", "B")),
  Count = 1:4)
DF$Date2 <- as.Date(DF$Date)

ggplot(data=DF,aes(x=Date2,y=Count,group=Type))+ geom_point(position = position_dodge(365*0.5))
-------------------------------------------------------------------------------------------------------
library(ggplot2)
eg <- data.frame(x = c(1:50, 50:1),  
                 y = c(1:50, 1:50) + rnorm(100),  
                 g = rep(c("a","b"), each=50))  

p <- qplot(x, y, data = eg) +  
  facet_wrap(~ g) +  
  geom_smooth()

p + geom_smooth(data=within(eg, g <- NULL), fill="red") facet_grid(..., margins=TRUE) p + facet_grid(.~g, margins=TRUE)
-------------------------------------------------------------------------------------------------------
dat <- read.table(textConnection("
filename    diff RMSD
1bso.pdb    1.0 0.5645
1cj51.9.pdb 2.0 3.5596
1cj51.1.pdb 3.0 3.5573
3qzj.pdb    3.0 0.8302
1bsy.pdb    4.0 0.5387
1cj51.5.pdb 8.0 3.9864
2gj5.pdb    10.0    0.8446
1cj51.10.pdb    11.0    3.5914
1uz2.pdb    12.0    1.7741
2blg.pdb    12.0    0.5449"),
           header=TRUE)
dat <- transform(dat,filename=factor(as.character(filename),
                       levels=filename)) grid.arrange gridExtra library(lattice)
d1 <- dotplot(filename~diff, xlim=c(0, 150), xlab="CCS Difference", data=dat)

# This plots the RMSD
d2 <- dotplot(filename~RMSD, xlim=c(0, 5), xlab="RMSD", data=dat)

library(gridExtra)
grid.arrange(d1,d2,nrow=1) library(latticeExtra)
c(d1,d2) library(reshape)
m <- melt(dat)
dotplot(filename~value|variable,
       scales=list(x=list(relation="free")), xlim=list(c(0,150), c(0,5)),
       data=m) library(ggplot2)
g1 <- qplot(value,filename,data=m)+
  facet_grid(.~variable,scale="free")+theme_bw()+
  opts(panel.margin=unit(0,"lines"))
-------------------------------------------------------------------------------------------------------
paste interaction interaction > ff <- expand.grid(agegroup=factor(c("<20","20-30",">30")),
       disease.level=factor(0:2),performance=factor(c("<60",">=60")))
> combfac <- with(ff,interaction(agegroup,disease.level,performance))
> combfac
 [1] <20.0.<60    20-30.0.<60  >30.0.<60    <20.1.<60    20-30.1.<60 
 [6] >30.1.<60    <20.2.<60    20-30.2.<60  >30.2.<60    <20.0.>=60  
[11] 20-30.0.>=60 >30.0.>=60   <20.1.>=60   20-30.1.>=60 >30.1.>=60  
[16] <20.2.>=60   20-30.2.>=60 >30.2.>=60  
18 Levels: <20.0.<60 20-30.0.<60 >30.0.<60 <20.1.<60 20-30.1.<60 ... >30.2.>=60 do.call(interaction,ff) model.matrix(~combfac-1)
-------------------------------------------------------------------------------------------------------
plot(1:10,1:10,type = "n")
grid(10,10)
hist(rnorm(100,5,1),add = TRUE) type = "n" plot add = TRUE add plot.histogram hist ...
-------------------------------------------------------------------------------------------------------
d <- data.frame(x=rnorm(1000))    

library(lattice)
histogram(~x,data=d,panel=function(...) {
     panel.grid(...)
     panel.histogram(...) } 
) library(ggplot2)
qplot(x,data=d,geom="histogram",binwidth=0.1)+theme_bw()+
   labs(x="Wind speed", y="Frequency") ggplot
-------------------------------------------------------------------------------------------------------
h <- hist(y, plot = FALSE) plot(h$mids, h$counts, ylim = c(0, max(h$counts)), xlim = range(h$mids)*1.1, 
    type = 'n', bty = 'n', xlab = 'y', ylab = 'Counts', main = 'Histogram of y') grid() hist(y, add = TRUE) hist(y)
grid()
hist(y, add = TRUE, col = 'white')
-------------------------------------------------------------------------------------------------------
getbest <- function(x) {
  # get the sums of all possible ranges
  n <- length(x)
  m <- as.data.frame(t(combn(n, 2)))
  names(m) <- c("lo","hi")
  m$sum <- sapply(1:nrow(m), function(i) {
    sum(x[m$lo[i]:m$hi[i]])
  })
  # then get the ranges of positive and negative sums that don't overlap
  neg <- m[m$sum<0,]
  pos <- m[m$sum>0,]
  use <- expand.grid(neg=1:nrow(neg), pos=1:nrow(pos))
  use <- use[(neg$hi[use$neg] < pos$lo[use$pos]) | 
                  (neg$lo[use$neg] > pos$hi[use$pos]),]
  # finally get the absolute value for all ranges that don't overlap,
  # and choose the largest
  abs <- pos$sum[use$pos] - neg$sum[use$neg]
  use <- use[which.max(abs),]
  as.matrix(rbind(positive=pos[use$pos,], negative=neg[use$neg,]))
} df$ind 1:n x <- rnorm(100)
getbest(x)
-------------------------------------------------------------------------------------------------------
ggplot(df) +
  aes(long, lat, group=group) +
  coord_equal() +
  geom_polygon(aes(fill = as.factor(community))) +
  facet_grid(facets= id ~.)
-------------------------------------------------------------------------------------------------------
TRUE / FALSE set.seed(1)
dat <- data.frame(v1 = sample(c(T,F), 10, TRUE),
                  v2 = sample(c(T,F), 10, TRUE),
                  v3 = sample(c(T,F), 10, TRUE),
                  v4 = sample(c(T,F), 10, TRUE)
                  )
#End fake data
#Multiple T/F times the column index
dat <- dat * rep(seq_len(ncol(dat)), each = nrow(dat))
#Paste together in a new column
dat$v5 <- apply(dat, 1, function(x) paste(x, collapse = ""))

> dat
   v1 v2 v3 v4   v5
1   0  0  3  4 0034
2   0  2  0  4 0204
... expand.grid() set.seed(1)
dat <- data.frame(v1 = sample(c(T,F), 10, TRUE),
                  v2 = sample(c(T,F), 10, TRUE)
       )

#Thanks @Joshua
dat$comp <- as.character(apply(1 * dat, 1, paste, collapse=""))

#Look up table
lookup <- data.frame(comp = apply(expand.grid(0:1, 0:1), 1, paste, collapse = ""),
                     text = c("none", "v1 only", "v2 only", "all"),
                     stringsAsFactors = FALSE
)

#Use merge to join the look up table to your data. Note the consistent naming of the comp column
> merge(dat, lookup)
   comp    v1    v2    text
1    00 FALSE FALSE    none
2    00 FALSE FALSE    none
3    01 FALSE  TRUE v2 only
....
-------------------------------------------------------------------------------------------------------
FALSE/TRUE v1 v2 v3 chmod *NIX # CONSTRUCT VECTOR OF DESCRIPTIONS
description <- c("None", "v1", "v2", "v1 and v2",
                 "v3", "v1 and v3", "v2 and v3", "All")

# DEFINE DESCRIPTION FUNCTION
getDescription <- function(X) {
    index <- 1 + sum(X*c(1,2,4))
    description[index]
}

# TRY IT OUT ON ALL COMBOS OF v1, v2, and v3
df <- expand.grid(v1=c(FALSE, TRUE),
                  v2=c(FALSE, TRUE),
                  v3=c(FALSE, TRUE))
df$description <- apply(df, 1, getDescription)

# YEP, IT WORKS.
df
#      v1    v2    v3 description
# 1 FALSE FALSE FALSE        None
# 2  TRUE FALSE FALSE          v1
# 3 FALSE  TRUE FALSE          v2
# 4  TRUE  TRUE FALSE   v1 and v2
# 5 FALSE FALSE  TRUE          v3
# 6  TRUE FALSE  TRUE   v1 and v3
# 7 FALSE  TRUE  TRUE   v2 and v3
# 8  TRUE  TRUE  TRUE         All
-------------------------------------------------------------------------------------------------------
library(ggplot2)
ggplot(melt(array4hm), aes(x=X1,y=X2,fill=value))+geom_tile()+facet_grid(.~X3)
-------------------------------------------------------------------------------------------------------
diamonds ggplot(diamonds, aes(x = carat, y = price)) + 
  geom_point(aes(colour = cut)) + 
  facet_grid(color ~ clarity) + 
  scale_colour_discrete(breaks = levels(diamonds$cut), 
                        labels = c(expression(Cut[1]),
                                   expression(Cut[2]),
                                   expression(Cut[3]),
                                   expression(Cut[4]),
                                   expression(Cut[5])))
-------------------------------------------------------------------------------------------------------
ggplot(mydata, aes(x=strength/2, y = val, fill = widget, width = strength)) +
  geom_bar(position="fill", stat="identity") + 
  facet_grid(side1 ~ side2) + 
  coord_polar("y") + 
  opts(axis.text.x = theme_blank())
-------------------------------------------------------------------------------------------------------
tu <- expand.grid(Land       = gl(2, 1, labels = c("DE", "BB")),
                  Altersgr   = gl(5, 1, labels = letters[1:5]),
                  Geschlecht = gl(2, 1, labels = c('m', 'w')),
                  Jahr       = 2000:2009)

set.seed(42)
tu$Wert <- unclass(tu$Altersgr) * 200 + rnorm(200, 0, 10)

ggplot(tu, aes(x = Jahr, y = Wert, color = Altersgr, group = Altersgr)) + 
  geom_point() + geom_line() + 
  facet_grid(Geschlecht ~ Land)
-------------------------------------------------------------------------------------------------------
> length(Y)
[1] 30
> length(2:25)
[1] 24 plot(1, 1, xlim=c(108,172), axes=FALSE, type='n', ylim=c(1,30),
    xlab="Average number of syllables per 100 words", 
    ylab="Average number of sentences per 100 words", 
    main="Fry Graph for Estimating Reading Ages (grade level)",
    xaxs = 'i', yaxs = 'i')

axis(1, at = 108:172, labels = TRUE)
axis(2, at = 1:30,  labels=Y, las=2)
grid(nx=64, ny=46, lty="solid", col="gold")
grid(nx=32, ny=23, lty="solid", col="gray65")
box()
-------------------------------------------------------------------------------------------------------
position <- c(0, 1, 3, 4, 5, 7, 8, 9,   0, 1, 2, 4.5, 7, 8, 9)
group <- c(1, 1, 1,  1, 1, 1, 1, 1,   2, 2, 2, 2, 2, 2, 2)
barheight <- c(0.5, 0.4, 0.4, 0.4, 0.6,  0.3, 0.4, 1, 0.75, 0.75, 0.75, 1, 0.8, 0.2, 0.6)
mydf <- data.frame (position, group, barheight)

library(ggplot2)
ggplot(mydf, aes(position, barheight)) + geom_bar(stat = "identity") + 
  facet_grid(group ~ .)
-------------------------------------------------------------------------------------------------------
lineend lineend xy <- data.frame(x = rep(c(1:3,3:9), times=3), y = rep(10:1, times=3), 
                 type = rep(LETTERS[1:2], each=5), type2 = rep(LETTERS[3:5], each=10))
 myplot <- ggplot(data = xy)+
                  geom_path(aes(x = x, y = y), size=4, lineend="butt", 
                             linejoin="mitre")+facet_grid(type ~ type2)
 myplot linejoin lineend
-------------------------------------------------------------------------------------------------------
library(reshape2)
foo <- data.frame(x = c('a', 'a', 'a', 'b', 'b', 'b'), 
                  y = c('ab', 'ac', 'ad', 'ae', 'fx', 'fy'))
bar <- data.frame(x = c('c', 'c', 'c', 'd', 'd', 'd'), 
                  y = c('ab', 'xy', 'xz', 'xy', 'fx', 'xz'))

# Create a function that counts the number of common elements in two groups
nShared <- function(A, B) {
    length(intersect(with(foo, y[x==A]), with(bar, y[x==B])))
}

# Enumerate all combinations of groups in foo and bar
(combos <- expand.grid(foo.x=unique(foo$x), bar.x=unique(bar$x)))
#   foo.x bar.x
# 1     a     c
# 2     b     c
# 3     a     d
# 4     b     d

# Find number of elements in common among all pairs of groups
combos$n <- mapply(nShared, A=combos$foo.x, B=combos$bar.x)

# Reshape results into matrix form
dcast(combos, foo.x ~ bar.x)
#   foo.x c d
# 1     a 1 0
# 2     b 0 1
-------------------------------------------------------------------------------------------------------
library(lattice)
barchart( count ~ time | name, data=d )

library(ggplot2)
ggplot(d, aes(x=time, y=count)) + 
  geom_bar(stat="identity") + 
  facet_grid( ~ name )
-------------------------------------------------------------------------------------------------------
grid.arrange() gridExtra p1 <- pw + geom_point() + facet_grid(.~g, scales='fixed') + coord_equal() +   
      stat_smooth(method='lm')
p2 <- px + geom_point() + facet_grid(.~g, scales='fixed') + coord_equal() + 
      stat_smooth(method='lm')
p3 <- pz + geom_point() + facet_grid(.~g, scales='fixed') + coord_equal() +   
      stat_smooth(method='lm')

grid.arrange(p1, p2, p3, ncol=1)
-------------------------------------------------------------------------------------------------------
library(zoo)
my.ts <-zoo(0:1000,as.Date("2000-01-01")+0:1000)
plot(my.ts, xaxt="n")

years <-index(my.ts)[format(index(my.ts),"%m-%d") %in% "01-01"]
other.quarters <- index(my.ts)[ format(index(my.ts), "%m-%d") %in% c("04-01", "07-01","10-01")]
axis.Date(1, at=years, label=format(years,"%y"))
axis.Date(1, at=other.quarters, label=format(other.quarters, "%b")) grid(nx=NA, ny=NULL)
abline(v=c(years, other.quarters),col = "lightgray", lty = "dotted", lwd = par("lwd"))
-------------------------------------------------------------------------------------------------------
> help(package='ggplot2')
                Information on package ‘ggplot2’    
Description:
Package:            ggplot2
Type:               Package
Title:              An implementation of the Grammar of Graphics
Version:            0.8.9 qplot(reorder(model, hwy), hwy, data=mpg) +
    facet_grid(. ~ manufacturer, scales="free") +
    opts(axis.text.x = theme_text(angle=90))
-------------------------------------------------------------------------------------------------------
axis.ticks require(ggplot2)
df <- data.frame(group=factor(c('sex','sex','race','race')),
                 variable=c('Female','Male','White','African American'), 
                 value=1:4)
p <- ggplot(df,aes(x=variable, y=value)) + geom_line()
p <- p + facet_grid(. ~ group, scale="free") 
p <- p + opts(axis.text.x=theme_text(angle=45), 
              axis.ticks = theme_blank(),axis.title.y=theme_blank())
ggsave(p, file='no_ticks.png', width=6, height=4)
-------------------------------------------------------------------------------------------------------
set_power expand.grid lapply(0:4, function(n) expand.grid( rep( list( 0:4), n)) )
-------------------------------------------------------------------------------------------------------
a <- b <- 1:5
subset( expand.grid(a,b), Var1 < Var2 )
-------------------------------------------------------------------------------------------------------
eg <- expand.grid(a=1:4, b=1:4)

> eg[eg$a < eg$b, ]
   a b
5  1 2
9  1 3
10 2 3
13 1 4
14 2 4
15 3 4 combn > data.frame(t(combn(x=1:4, m=2)))
  X1 X2
1  1  2
2  1  3
3  1  4
4  2  3
5  2  4
6  3  4
-------------------------------------------------------------------------------------------------------
a <- c(1,2,3,"X","Y","M")
eg <- expand.grid(a,a)
eg2 <- eg[as.character(eg$Var1) < as.character(eg$Var2), ]
-------------------------------------------------------------------------------------------------------
merge melt d_pply # Sample data
n <- length(LETTERS)
d1 <- cbind( expand.grid( LETTERS, LETTERS ), rnorm( n*n ) )
names(d1) <- c("id1", "id2", "distance")
d1 <- d1[ as.character(d1$id1) < as.character(d1$id2), ]
d2 <- as.data.frame( matrix( rnorm(n*6), nr=n ) )
d2 <- data.frame( id=LETTERS, d2 )
names( d2 )[-1] <- paste( "sample", 1:6, sep="")

# If the distance data.frame only contains half the pairs,
# i.e., if it only contains one of (a,b) and (b,a), 
# add the missing ones.    
d1a <- d1
d1b <- d1[,c(2,1,3)]
names(d1b) <- names(d1a)
d1 <- rbind( d1a, d1b )
d1 <- d1[ ! duplicated( d1[,1:2]), ]

# Merge the two data.frames    
d <- merge( d1, d2, by.x="id1", by.y="id" )

# Convert to tall format
library(reshape2)
d <- melt(d, id.vars=c("id1", "id2", "distance"))

# Apply a function to each chunk
d_ply( d, "variable", function (u) { 
  cat( "Would save ", nrow(u), " rows to ", as.character(u$variable[1]), "\n" ) 
} )
-------------------------------------------------------------------------------------------------------
is.OHLC plot plot.xts2 <- function (x, y = NULL, type = "l", auto.grid = TRUE, major.ticks = "auto", 
    minor.ticks = TRUE, major.format = TRUE, bar.col = "grey", 
    candle.col = "white", ann = TRUE, axes = TRUE, col = "black", ...) 
{
    series.title <- deparse(substitute(x))
    ep <- axTicksByTime(x, major.ticks, format = major.format)
    otype <- type
    if (xts:::is.OHLC(x) && type %in% c("candles", "bars")) {
        x <- x[, xts:::has.OHLC(x, TRUE)]
        xycoords <- list(x = .index(x), y = seq(min(x), max(x), 
                length.out = NROW(x)))
        type <- "n"
    }
    else {
        if (NCOL(x) > 1) 
            warning("only the univariate series will be plotted")
        if (is.null(y)) 
            xycoords <- xy.coords(.index(x), x[, 1])
    }
    plot(xycoords$x, xycoords$y, type = type, axes = FALSE, ann = FALSE, 
        col = col, ...)
    if (auto.grid) {
        abline(v = xycoords$x[ep], col = "grey", lty = 4)
        grid(NA, NULL)
    }
    if (xts:::is.OHLC(x) && otype == "candles") 
        plot.ohlc.candles(x, bar.col = bar.col, candle.col = candle.col, 
            ...)
    dots <- list(...)
    if (axes) {
        if (minor.ticks) 
            axis(1, at = xycoords$x, labels = FALSE, col = "#BBBBBB", 
                ...)
        axis(1, at = xycoords$x[ep], labels = names(ep), las = 1, 
            lwd = 1, mgp = c(3, 2, 0), ...)
        axis(2, ...)
    }
    box()
    if (!"main" %in% names(dots)) 
        title(main = series.title)
    do.call("title", list(...))
    assign(".plot.xts", recordPlot(), .GlobalEnv)
}

plot.xts2(as.xts(sample_matrix[,1]), col = "blue")
-------------------------------------------------------------------------------------------------------
facet_grid library(ggplot2)
 ggplot(mtcars, aes(factor(cyl), mpg)) + 
   geom_boxplot() + 
   facet_grid(cyl ~., scales = "free")
-------------------------------------------------------------------------------------------------------
group_names <- apply(
    expand.grid("X", c("X", "O", "Y"), c("A", "B", "C"), "_", 0:9, 0:9),
    1,
    paste,
    collapse = ""
)
n_groups <- 50
n_points_per_group <- 10
df1 <- as.data.frame(matrix(
    runif(n_points_per_group * n_groups),
    ncol = n_groups
))
colnames(df1) <- sample(group_names, n_groups) reshape stats::reshape melted_df1 <- melt(df1) melted_df1$group <- with(melted_df1, paste(
    substring(variable, 2, 2),    
    substring(variable, 5, 6),
    sep = ""
)) tapply plyr::ddply with(melted_df1, tapply(value, group, mean))
-------------------------------------------------------------------------------------------------------
DSET <- data.frame(A=c(rep("V1",3),rep("V2",3),"V3"),
                   B=c(rep(c("X1","X2","X3"),2),"X1"),
                   C=c(1,-2,1,3,-1,2,-3))

DSET2 <- data.frame(A=rep(c("V1","V2","V3"), each=3),
                    B=rep(c("X1","X2","X3"), times=3),
                    C=c(1,-2,1,3,-1,2,-3,0,0)) Grph <- ggplot(DSET, aes(x=A, y=C, fill=B)) +
  geom_bar(position=position_dodge(width=0.9))
Grph Grph %+% DSET2 ggplot(DSET, aes(x=B, y=C, fill=B)) +
  geom_bar(position=position_dodge(width=0.9)) +
  facet_grid(.~A, scale="free_x", space="free")
-------------------------------------------------------------------------------------------------------
abline x=strptime(20010101:20010110,format="%Y%m%d")
y=1:10

plot(x,y)
grid(nx=NA, ny=NULL)
abline(v=axis.POSIXct(1, x=pretty(x)),col = "lightgray", lty = "dotted", lwd = par("lwd")) my.grid <-function(){
grid(nx=NA, ny=NULL)
abline(v=axis.POSIXct(1, x=pretty(x)),col = "lightgray", lty = "dotted", lwd =
par("lwd"))
}

plot(x,y)
my.grid()
-------------------------------------------------------------------------------------------------------
position="fill" geom_bar() my.df <- data.frame(replicate(10, sample(1:5, 100, rep=TRUE)), 
                    F1=gl(4, 5, 100, labels=letters[1:4]), 
                    F2=gl(2, 50, labels=c("+","-")))
my.df[,1:10] <- apply(my.df[,1:10], 2, function(x) ifelse(x>4, 1, 0))
library(reshape2)
my.df.melt <- melt(my.df)
library(plyr)
res <- ddply(my.df.melt, c("F1","F2","variable"), summarize, sum=sum(value))
library(ggplot2)
ggplot(res, aes(y=sum, x=variable, fill=F1)) +
   geom_bar(stat="identity", position="fill") + 
   coord_flip() +
   facet_grid(. ~ F2) + 
   ylab("Percent") + xlab("Item") > xtabs(~ F1 + F2, data=my.df)
   F2
F1   +  -
  a 15 10
  b 15 10
  c 10 15
  d 10 15 ddply ddply with(my.df.melt, aggregate(value, list(F1=F1, F2=F2, variable=variable), sum))
-------------------------------------------------------------------------------------------------------
res1 = ddply(data,c(F1,variable),summarize,Rating = value)
res2 = ddply(data,c(F1,variable),summarize,Mean = mean(value))

ggplot(res1,aes(y=Rating,x=variable,fill=factor(Rating))+geom_bar(position="fill",stat="identity")+geom_point(res2,aes(y=Mean,x=variable)+coord_flip()+facet_grid(.~F1)
-------------------------------------------------------------------------------------------------------
rm(list = ls())
install.packages("ggplot2")
library(ggplot2)
install.packages("maps")
library(maps)
install.packages("mapproj")
library(mapproj)
install.packages("spatstat")
library(spatstat)

theme_set(theme_bw(base_size = 8))
options(scipen = 20)

MyPalette <- colorRampPalette(c(hsv(0, 1, 1), hsv(7/12, 1, 1)))

### Map ###
StateMapData <- map_data("state")
head(StateMapData)

### Some Invented Data ###

IndependentVariable1 <- c("Low Income", "Mid Income", "High Income")
IndependentVariable2 <- c("18-29", "30-44", "45-64", "65+")

# Here is one way to "stack" lots of copies of the shapefile dataframe on top of each other:
# This needs to be done, because (as far as I know) ggplot2 needs to have the state names and polygon coordinates
# for each level of the faceting variables.

TallData <- expand.grid(1:nrow(StateMapData), IndependentVariable1, IndependentVariable2)
TallData <- data.frame(StateMapData[TallData[, 1], ], TallData)
colnames(TallData)[8:9] <- c("IndependentVariable1", "IndependentVariable2")

# Some random dependent variable we want to plot in color:
TallData$State_IV1_IV2 <- paste(TallData$region, TallData$IndependentVariable1, TallData$IndependentVariable2)
RandomVariable <- runif(length(unique(TallData$State_IV1_IV2)))
TallData$DependentVariable <- by(RandomVariable, unique(TallData$State_IV1_IV2), mean)[TallData$State_IV1_IV2]

### Plot ###

MapPlot <- ggplot(TallData,
 aes(x = long, y = lat, group = group, fill = DependentVariable))
MapPlot <- MapPlot + geom_polygon()
MapPlot <- MapPlot + coord_map(project="albers", at0 = 45.5, lat1 = 29.5)  # Changes the projection to something other than Mercator.
  MapPlot <- MapPlot + scale_x_continuous(breaks = NA, expand.grid = c(0, 0)) +
    scale_y_continuous(breaks = NA) +
    opts(
      panel.grid.major = theme_blank(),
      panel.grid.minor = theme_blank(),
      panel.background = theme_blank(),
      panel.border = theme_blank(),
      expand.grid = c(0, 0),
      axis.ticks = theme_blank(),
      legend.position = "none",
      legend.box = "horizontal",
      title = "Here is my title",
  legend.key.size = unit(2/3, "lines"))
MapPlot <- MapPlot + xlab(NULL) + ylab(NULL)
MapPlot <- MapPlot + geom_path(fill = "transparent", colour = "BLACK", alpha = I(2/3), lwd = I(1/10))
MapPlot <- MapPlot + scale_fill_gradientn("Some/nRandom/nVariable", legend = FALSE,
 colours = MyPalette(100))

# This does the "faceting":
MapPlot <- MapPlot + facet_grid(IndependentVariable2 ~ IndependentVariable1)

# print(MapPlot)

ggsave(plot = MapPlot, "YOUR DIRECTORY HERE.png", h = 8.5, w = 11)
-------------------------------------------------------------------------------------------------------
?panel.levelplot contourplot col.regions lpolygon library(gstat)

# create structure
xy <- expand.grid(1:360, 1:180)
names(xy) <- c('x','y')

# define the gstat object (spatial model)
g.dummy <- gstat(formula=z~1, locations=~x+y, dummy=T, beta=1,    
  model=vgm(psill=0.025,model='Exp',range=5), nmax=20)

# make a simulations based on the gstat object
yy <- predict(g.dummy, newdata=xy, nsim=1)
gridded(yy) = ~x+y

# scale to range [-1, 1]
z <- matrix(yy@data[, 1], ncol=180)
z.scalefac <- (max(z) - min(z)) / 2
z <- -1 + (z - min(z)) / z.scalefac library(lattice)
library(maps)

lon_sst <- seq(-179.5, 179.5, 1)
lat_sst <- seq(-89.5, 89.5, 1)

colramp <- colorRampPalette(c('red', 'yellow', 'white', 'green', 'blue'))

contourplot(z, xlim=c(100, 160), ylim=c(-80, -50), 
  at=seq(-1, 1, 0.2), region=TRUE, col.regions=colramp,
  row.values=lon_sst, column.values=lat_sst, labels=FALSE, 
  xlab='longitude', ylab='latitude',
  panel = function(at, region, ...) {
    panel.contourplot(at=at, region=TRUE,  ...)
    panel.contourplot(at=c(-0.2, 0.2), lwd=2, region=FALSE, ...)
    mp <- map("world", "antarctica", plot = FALSE, fill=TRUE)
    lpolygon(mp$x, mp$y, fill=TRUE, col='gray')
})
-------------------------------------------------------------------------------------------------------
dat <- expand.grid(d=1:10, j=1:3, i=1:10)

arms.func <- function(vec) {
  require(HI)
  dji <- vec[1]*vec[2]*vec[3]
  arms.out <- arms(0.3, 
                   function(x,params) (3.5 + 0.00001*params)*log(x) - x,
                   function(x,params) (x>1e-4)*(x<20),
                   n.sample=1,
                   params=dji)

  return(arms.out)
}

dat$arms <- apply(dat,1,arms.func)

library(plyr)
out <- ddply(dat,.(d,j),summarise, arms=sum(arms))

matrix(out$arms,nrow=length(unique(out$d)),ncol=length(unique(out$j)))
-------------------------------------------------------------------------------------------------------
library(sos)
findFn("{bilinear interpolation}")

set.seed(101)
old <- array(runif(10*12), dim=c(12,10))

library(fields)

interp2d <- function(old, newx, newy) {
  interp.surface.grid(list(x=seq(nrow(old)),y=seq(ncol(old)),z=old),
                      list(x=seq(1,nrow(old),length=newx),
                           y=seq(1,ncol(old),length=newy)))$z
}

newmat <- interp2d(old, newx=6, newy=5)
-------------------------------------------------------------------------------------------------------
panel.text(x + rep(c(.25, -.25), 3), y, label = one_cir$Value[order(one_cir$bias)], pos = 3, cex = 1.2) one_cir <- data.frame(bias = c(0.0, 0.3, 0.6, 0.0, 0.3, 0.6), 
    Circuits = rep("NOR2", 6), 
    Model = rep(c("11C", "11B"), each = 3), 
    Temp = rep(25,6), 
    Corner = rep("3-TT", 6), 
    Parameter = rep("delay_DDC", 6), 
    Value = c(3.02e-10, 3.79e-10, 4.92e-10, 2.90e-10, 3.66e-10,4.76e-10)
    )

    library(lattice)
    p <- lattice:::barchart(Value~bias, horiz = FALSE, data = one_cir,
            groups = droplevels(Model),
            xlab = list("RVBS (V)", cex = 1.3 ), ylab = list("Delay (ps)",cex = 1.3 ), 
            main = "SVT Circuit Analysis: Delay vs RVBS",
            panel = function(x,y,...){
                panel.barchart(x, y, ...)
                panel.grid(h = -1, v = 0, col = "gray")
                panel.text(x + rep(c(.25, -.25), 3), y, label = one_cir$Value[order(one_cir$bias)], pos = 3,cex = 1.2)
            },
            scales = list(cex = 1.2),
            auto.key = list(x = .81, y = 1, corner = c(0, 0), half = FALSE, points = FALSE, cex = 1.2, rectangles = TRUE)
    )
    print(p)
-------------------------------------------------------------------------------------------------------
d <- data.frame( 
  value = c(1,2,1,2,1,9,9,8),
  group = c(rep("a",4),rep("b",4))
)
# With counts
ggplot(d) + geom_bar(aes(factor(value))) + facet_grid(group ~ .)
# With percentages
ggplot(d) + 
  geom_bar(aes(factor(value), (..count..)/sum(..count..))) + 
  scale_y_continuous(formatter = 'percent') + 
  facet_grid(group ~ .) scale_y_continuous(labels = percent_format())
-------------------------------------------------------------------------------------------------------
splitTextGrob() text = paste(capture.output(licence()),collapse=" ")
library(RGraphics)
library(gridExtra)

grid.arrange(rectGrob(), splitTextGrob(text), ncol=2)

d <- expand.grid(seq(0.1, 0.9, length=10), seq(0.1, 0.9, length=10))
grid.arrange(pointsGrob(d[, 2], d[, 1], pch=21, 
 gp=gpar(fill=rainbow(100))), splitTextGrob(text), ncol=2) gridBase
-------------------------------------------------------------------------------------------------------
# Dummy data    
x <- data.frame(
  hostname=rep(paste("host",1:3,sep=""),1000),
  date=as.Date(1:1000,origin="2005-01-01"),
  CPUMEM=rnorm(1000)+20,
  CPU=rnorm(1000)+10,
  avg=rnorm(1000)+10,
  io=rnorm(1000)+5,
  mem=rnorm(1000)+27)

x <- melt(x, c("hostname","date"))

ggplot(x, aes(date,value, color=variable)) + geom_line() + facet_grid(~hostname)
-------------------------------------------------------------------------------------------------------
data.frame library(ggplot2)
z <- data.frame(
  x = c(1,2,3,4,1,2,3,4),
  y = c(2,4,5,6,9,4,2,10),
  f = c(rep('a',4),rep('b',4))
)

z1 <- data.frame(
  x = c(2,2.5,3.1,2.8,3.4,3.5),
  y = c(1,1.2,1,2,3,2),
  f = c(rep('a',3),rep('b',3))
) ggplot layer geoms ggplot() +
    geom_line(data=z, aes(x,y)) +
    geom_polygon(data=z1, aes(x,y), color="blue") +
    facet_grid(f ~ .)
-------------------------------------------------------------------------------------------------------
# Sample data
n <- 20
k <- 3
d <- data.frame(
  Unit = rep(LETTERS[1:k], each=n),
  Date = rep(sample(seq.Date(Sys.Date(), length=n, by=1)), k),
  Count = rpois(k*n,10)
)
# Unorderd data    
xyplot(Count ~ Date | Unit, data=d, type="l")
# Ordered data
xyplot(Count ~ Date | Unit, data=d[order(d$Date),], type="l") ggplot2 library(ggplot2)
ggplot(d, aes(Date, Count)) + geom_line() + facet_grid(~Unit)
-------------------------------------------------------------------------------------------------------
diagram::plotweb library(diagram)
#sample data
nodes <- LETTERS[23:26]
dat <- expand.grid(nodes,nodes)
dat$Weight <- rpois(16,5)+1

#put data in format for plotweb
datMat <- xtabs(Weight~Var1+Var2,dat)
#no loops
diag(datMat)<-0

#plot
plotweb(datMat)
-------------------------------------------------------------------------------------------------------
df <- expand.grid(colnames(Corr), rownames(Corr))
df$Corr <- apply(df, 1, function(x) Corr[ x[1], x[2] ])
Ltri <- lower.tri(Corr)
df[ Ltri , ]   # the lower triangular data

# I used the longley dataset and the second example on the `cor` help page to test
# (Corr <- cor(longley)) upper.tri lower.tri df[ row(Corr) > col(Corr) , ]
subset(as.data.frame.table(Corr), row(Corr) > col(Corr))
-------------------------------------------------------------------------------------------------------
tmp = expand.grid(1:2,1:2,1:2,1:2,1:2,1:2,1:2,1:2,1:2,1:2) x <- list(1:2)
tmp = expand.grid(rep(x, 10))
-------------------------------------------------------------------------------------------------------
plot(pos, type = 'n', xlim = range(c(start, end)), ylim = c(13,0))
grid()
segments(start, pos, end, pos) r <- par('usr') 
plot(pos, type = 'n', xlim = range(c(start, end)), ylim = c(13.5,0.5), xlab = '', 
    xaxt = 'n', yaxt = 'n', panel.first = rect(r[1], r[3], r[2], r[4], col = 'goldenrod'))
# abline(h = 1:13, col = 'white')
# abline(v = 1:13, col = 'white')
grid(lty = 1, col = 'white')
axis(1, 1:13, 1:13, cex.axis = 0.8)
axis(2, 1:13, 1:13, las = 1, cex.axis = 0.8)
segments(start, pos + 0.5, end, pos + 0.5, lwd = 2)
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(lme4)
library(multcomp)
dataset <- expand.grid(experiment = factor(seq_len(10)), status = factor(c("N", "D", "R"), levels = c("N", "D", "R")), reps = seq_len(10))
dataset$value <- rnorm(nrow(dataset), sd = 0.23) + with(dataset, rnorm(length(levels(experiment)), sd = 0.256)[experiment] + ifelse(status == "D", 0.205, ifelse(status == "R", 0.887, 0))) + 2.78
model <- lmer(value~status+(1|experiment), data = dataset)
tmp <- as.data.frame(confint(glht(model, mcp(status = "Tukey")))$confint)
tmp$Comparison <- rownames(tmp)
ggplot(tmp, aes(x = Comparison, y = Estimate, ymin = lwr, ymax = upr)) + geom_errorbar() + geom_point()

tmp <- as.data.frame(confint(glht(model))$confint)
tmp$Comparison <- rownames(tmp)
ggplot(tmp, aes(x = Comparison, y = Estimate, ymin = lwr, ymax = upr)) + geom_errorbar() + geom_point()

model <- lmer(value ~ 0 + status + (1|experiment), data = dataset)
tmp <- as.data.frame(confint(glht(model))$confint)
tmp$Comparison <- rownames(tmp)
ggplot(tmp, aes(x = Comparison, y = Estimate, ymin = lwr, ymax = upr)) + geom_errorbar() + geom_point()
-------------------------------------------------------------------------------------------------------
coefplot2 set.seed(101)
dataset <- expand.grid(experiment = factor(seq_len(10)), 
    status = factor(c("N", "D", "R"), levels = c("N", "D", "R")), 
    reps = seq_len(10))
X <- model.matrix(~status,dataset)
dataset <- transform(dataset, 
    value=rnorm(nrow(dataset), sd = 0.23) +   ## residual
    rnorm(length(levels(experiment)), sd = 0.256)[experiment] +  ## block effects
    X %*% c(2.78,0.205,0.887))  ## fixed effects library(lme4)
model <- lmer(value~status+(1|experiment), data = dataset) install.packages("coefplot2",repos="http://r-forge.r-project.org")
library(coefplot2)
coefplot2(model) install.packages("coefplot2",
  repos="http://www.math.mcmaster.ca/bolker/R",
  type="source") coda
-------------------------------------------------------------------------------------------------------
cols <- seq(240, 455, 5)
rows <- seq(300, 600.5, 0.5)
# Create a two-column matrix containing all possible excitation-emission pairs.  
d <- expand.grid(rows, cols, stringsAsFactors=FALSE)

# For each pair, test whether the smaller is a factor of the larger
# Set the number on the right hand side of the comparison (<=) to the 
#  maximum distance (from a true factor) within which numbers will be
#  considered factors.
test <- apply(d, 1, function(x) max(x) %% min(x) <= 10)

# Create a matrix and populate with the (inverse) outcome of the test
res <- matrix(as.numeric(!test), ncol=44, nrow=602,
              dimnames=list(rows, cols))

# Partial output
res[c('300', '300.5', '305', '310', '430', '480'), 
    c('240', '245', '250', '300', '305', '310', '440', '455')]
#      240 245 250 300 305 310 440 455
#300     1   1   1   0   0   0   1   1
#300.5   1   1   1   0   0   0   1   1
#305     1   1   1   0   0   0   1   1
#310     1   1   1   0   0   0   1   1
#430     1   1   1   1   1   1   0   1
#480     0   1   1   1   1   1   1   1
-------------------------------------------------------------------------------------------------------
library(ggplot2)
newdiamonds <- diamonds[diamonds$clarity != "VVS2" & diamonds$cut != 'Ideal', ]
newdiamonds$cut <- newdiamonds$cut[, drop=TRUE]
ggplot(newdiamonds, aes(cut, fill=cut)) + geom_bar() + facet_grid(. ~ clarity) +
  opts(axis.text.x=theme_text(angle=90, hjust=1))
-------------------------------------------------------------------------------------------------------
scales='free' facet_grid ggplot(newdiamonds, aes(cut, fill=cut)) + geom_bar() + facet_grid(. ~ clarity, scales='free')
-------------------------------------------------------------------------------------------------------
- DF <- expand.grid(market = LETTERS[1:5],date = Sys.Date()+(0:5),sitename = letters[1:2])
n <- nrow(DF)
DF$impression <- sample(100, n, replace=TRUE)
DF$clicks <- sample(100, n, replace=TRUE) reshape2 library("reshape2")

dcast(melt(DF, id.vars=c("market","date","sitename")), 
      market+date~sitename+variable) market       date a_impression a_clicks b_impression b_clicks
1       A 2012-02-28           74       97           11       71
2       A 2012-02-29           34       30           88       35
3       A 2012-03-01           40       85           40       49
4       A 2012-03-02           46       12           99       20
5       A 2012-03-03            6       95           85       56
6       A 2012-03-04           61       61           42       64
7       B 2012-02-28            4       53           74        9
8       B 2012-02-29           43       27           92       59
9       B 2012-03-01           34       26           86       43
10      B 2012-03-02           81       47           84       35
11      B 2012-03-03            3        5           91       48
12      B 2012-03-04           19       26           99       21
13      C 2012-02-28           22       31          100       53
14      C 2012-02-29           40       83           95       27
15      C 2012-03-01           78       89           81       29
16      C 2012-03-02           57       55           79       87
17      C 2012-03-03           37       61            3       97
18      C 2012-03-04           83       61           41       77
19      D 2012-02-28           81       18           47        3
20      D 2012-02-29           90      100           17       83
21      D 2012-03-01           12       40           35       93
22      D 2012-03-02           85       14           63       67
23      D 2012-03-03           63       53           29       58
24      D 2012-03-04           40       79           56       70
25      E 2012-02-28           97       62           68       31
26      E 2012-02-29           24       84           17       63
27      E 2012-03-01           94       93           32        2
28      E 2012-03-02            6       26           86       26
29      E 2012-03-03          100       34           37       80
30      E 2012-03-04           89       87           72       11 _ - -
-------------------------------------------------------------------------------------------------------
dcast() cast() cast() reshape reshape2 dcast() acast() fun.aggregate cast() dcast() acast() cast() y ?cast ?dcast fun.aggregate dcast() mean() library(reshape2)

## A toy dataset, with one row for each combination of variables
d <- expand.grid(Hostname = letters[1:2],Date = Sys.Date() + 0:1,MetricType = LETTERS[3:4])
d$Value <- rnorm(seq_len(nrow(d)))

## A second dataset, in which one combination of variables is repeated
d2 <- rbind(d, d[1,])

## Runs without complaint
dcast(d, Hostname + Date ~ MetricType)

## Throws error asking for an aggregation function
dcast(d2, Hostname + Date ~ MetricType)

## Happy again, with a supplied aggregation function
dcast(d2, Hostname + Date ~ MetricType, fun.aggregate=mean)
-------------------------------------------------------------------------------------------------------
library("grid")
p + opts(panel.margin=unit(0,"pt")) facet_grid scales="free" p <- ggplot(simsympt, aes(x=date,y=id))    
p=   p + geom_tile(aes(fill=level)) +   
     facet_grid(tx~.,drop=T,space="free",scales="free")+
     scale_y_discrete(expand=c(0,0),drop=T)
-------------------------------------------------------------------------------------------------------
set.seed(1234)

tran <- expand.grid(x1  = c(1, 2, 3), y1  = c(1, 2, 3),
                    x2  = c(1, 2, 3), y2  = c(1, 2, 3))

lin.prob <- -1.75 - 1.18 * ((tran[,1] - tran[,3])^2 + 
                            (tran[,2] - tran[,4])^2) ^ 0.5

e <- exp(1)

prob <- e^lin.prob / (1+e^lin.prob)

tran <- cbind(tran, prob)
colnames(tran) = c("x1","y1","x2","y2", "transition.prob")



nsites <- 25

x1sites <- ceiling(runif(nsites, 0, 3))
y1sites <- ceiling(runif(nsites, 0, 3))
x2sites <- ceiling(runif(nsites, 0, 3))
y2sites <- ceiling(runif(nsites, 0, 3))
site    <- seq(1:nsites)

sites <- cbind(site, x1sites, y1sites, x2sites, y2sites)
colnames(sites) = c("site", "x1","y1","x2","y2")


my.data <- merge(sites, tran, 

by.x = c("x1", "y1", "x2", "y2"),    
by.y = c("x1", "y1", "x2", "y2"), 

all = F, sort=F )

my.data=my.data[order(my.data$site),]
my.data
-------------------------------------------------------------------------------------------------------
#Some simple data grid points
d <- expand.grid(1:3,1:3,1:3,1:3)
#Trivial function
f <- function(x,y,X,Y){x*y*X*Y}
#Wrap mapply in matrix; fills by column by default
matrix(mapply(f,d$Var1,d$Var2,d$Var3,d$Var4),nrow = 9)
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]
 [1,]    1    2    3    2    4    6    3    6    9
 [2,]    2    4    6    4    8   12    6   12   18
 [3,]    3    6    9    6   12   18    9   18   27
 [4,]    2    4    6    4    8   12    6   12   18
 [5,]    4    8   12    8   16   24   12   24   36
 [6,]    6   12   18   12   24   36   18   36   54
 [7,]    3    6    9    6   12   18    9   18   27
 [8,]    6   12   18   12   24   36   18   36   54
 [9,]    9   18   27   18   36   54   27   54   81
-------------------------------------------------------------------------------------------------------
require(CTT); require(foreign)

dat22 <-read.csv(url("http://dl.dropbox.com/u/61803503/dat.csv"), header=TRUE, 
           strip.white = TRUE, sep=",", as.is=FALSE, na.strings= c("999", "NA", " "))

#group items by method(dim) and construct(r)
dim1r1 <- dat2[, c(3, 5, 9, 10)]
dim2r1 <- dat2[, c(4, 13:15)]
dim3r1 <- dat2[, c(1, 6, 7, 11, 12)]
dim4r1 <- dat2[, c(2, 8, 16, 17)]

dim1r2 <- dat2[, c(3, 5, 9, 10)+17]
dim2r2 <- dat2[, c(4, 13:15)+17]
dim3r2 <- dat2[, c(1, 6, 7, 11, 12)+17]
dim4r2 <- dat2[, c(2, 8, 16, 17)+17]

dim1r3 <- dat2[, c(3, 5, 9, 10)+17*2]
dim2r3 <- dat2[, c(4, 13:15)+17*2]
dim3r3 <- dat2[, c(1, 6, 7, 11, 12)+17*2]
dim4r3 <- dat2[, c(2, 8, 16, 17)+17*2]

dim1r4 <- dat2[, c(3, 5, 9, 10)+17*3]
dim2r4 <- dat2[, c(4, 13:15)+17*3]
dim3r4 <- dat2[, c(1, 6, 7, 11, 12)+17*3]
dim4r4 <- dat2[, c(2, 8, 16, 17)+17*3]

#make a list from the above items 
#dim1r1 means methid 1 (dim1) and construct 1(r1)
LIST2 <- list(dim1r1, dim1r2, dim1r3, dim1r4, dim2r1, dim2r2, dim2r3, dim2r4, 
             dim3r1, dim3r2, dim3r3, dim3r4, dim4r1, dim4r2, dim4r3, dim4r4)

#get the sums of the items by method and construct 
#and generate correlation amtrix (all in 1 step)
mtmm <- round(cor(sapply(LIST2, function(x) rowSums(x))), digits=3)
#generate and order row and column names
VN <- expand.grid(paste('dim', 1:4, sep=""), paste('r', 1:4, sep="")) 
VN <- VN[order(VN$Var1, VN$Var2), ]
varNames <- paste(VN[, 1], VN[, 2], sep="")
rownames(mtmm) <- colnames(mtmm) <-varNames

#blank out the upper triangle
mtmm[upper.tri(mtmm)] <- " "
#add cronbach's alpha intot he diagonal
diag(mtmm) <- sapply(LIST2, function(x) round(reliability(x)$alpha, digits=3))
noquote(mtmm) dim1r1 dim1r2 dim1r3 dim1r4 dim2r1 dim2r2 dim2r3 dim2r4 dim3r1 dim3r2 dim3r3 dim3r4 dim4r1 dim4r2 dim4r3 dim4r4
dim1r1 0.737                                                                                                          
dim1r2 0.82   0.78                                                                                                    
dim1r3 0.825  0.755  0.735                                                                                            
dim1r4 0.828  0.783  0.812  0.791                                                                                     
dim2r1 0.415  0.496  0.484  0.495  0.801                                                                              
dim2r2 0.432  0.615  0.493  0.479  0.818  0.886                                                                       
dim2r3 0.425  0.473  0.505  0.459  0.89   0.831  0.843                                                                
dim2r4 0.355  0.468  0.413  0.482  0.806  0.826  0.837  0.802                                                         
dim3r1 0.544  0.518  0.413  0.494  0.281  0.226  0.184  0.233  0.778                                                  
dim3r2 0.517  0.585  0.399  0.461  0.306  0.324  0.26   0.293  0.88   0.782                                           
dim3r3 0.491  0.489  0.392  0.421  0.258  0.229  0.232  0.221  0.875  0.912  0.804                                    
dim3r4 0.487  0.492  0.366  0.475  0.269  0.268  0.209  0.274  0.887  0.89   0.859  0.77                              
dim4r1 0.341  0.399  0.38   0.357  0.387  0.398  0.355  0.375  0.397  0.417  0.387  0.43   0.489                      
dim4r2 0.274  0.433  0.326  0.323  0.462  0.535  0.416  0.46   0.343  0.422  0.349  0.432  0.863  0.517               
dim4r3 0.268  0.368  0.364  0.306  0.329  0.417  0.333  0.341  0.293  0.376  0.34   0.353  0.863  0.856  0.545        
dim4r4 0.301  0.403  0.347  0.395  0.377  0.443  0.371  0.483  0.372  0.441  0.345  0.441  0.86   0.84   0.83   0.52
-------------------------------------------------------------------------------------------------------
qplot(mpg, wt, data=mtcars) + facet_grid(cyl ~ vs, margins="vs") FALSE TRUE
-------------------------------------------------------------------------------------------------------
xyplot(yval ~ xval | p*cr, data=B, group=gval, type=c("l","g"), lwd=5, 
       main="Scatterplots by Cylinders and Gears",
       ylab="Miles per Gallon", xlab="Car Weight") data= type=c("l","g") panel=function(...) {
  panel.xyplot(...)
  panel.grid()
} panel.xyplot() panel.grid()
-------------------------------------------------------------------------------------------------------
d <- expand.grid(id = 1:35000, stratum = letters[1:10])

p = 0.1

dsample <- data.frame()

system.time(
for(i in levels(d$stratum)) {
  dsub <- subset(d, d$stratum == i)
  B = ceiling(nrow(dsub) * p)
  dsub <- dsub[sample(1:nrow(dsub), B), ]
  dsample <- rbind(dsample, dsub) 
  }
)

# size per stratum in resulting df is 10 % of original size:
table(dsample$stratum)
-------------------------------------------------------------------------------------------------------
direct.labels library(ggplot2); library(directlabels)
x <- ggplot(CO2, aes(x=uptake, group=Plant))
y <- x + geom_density(aes(colour=Plant)) + 
    facet_grid(Type~Treatment)+ theme_bw()
y 


my.method1 <- list('top.points',dl.move("Qn1",  hjust=0,vjust=-5) 
)


direct.label(y, my.method1)
-------------------------------------------------------------------------------------------------------
DF <-
structure(list(Date = structure(c(15311, 15311, 15311, 15311, 
15311, 15312, 15312, 15312, 15312, 15312), class = "Date"), fileSystem = structure(c(5L, 
2L, 4L, 1L, 3L, 5L, 2L, 4L, 1L, 3L), .Label = c("/data", "/opt", 
"/ora", "/tmp", "/var"), class = "factor"), FreeSpace = c(99.785, 
30.494, 55.643, 37.846, 0.578, 99.785, 30.494, 55.643, 37.846, 
0.578)), .Names = c("Date", "fileSystem", "FreeSpace"), row.names = c(NA, 
-10L), class = "data.frame") ggplot2 library("ggplot2")
library("scales") ggplot(DF, aes(x=Date, y=FreeSpace)) +
  geom_point() +
  geom_line() +
  scale_x_date(breaks=date_breaks("1 day")) +
  facet_grid(fileSystem~.) library("reshape2")

DF.wide <- dcast(DF, Date~fileSystem, value.var="FreeSpace") > DF.wide
        Date  /data   /opt  /ora   /tmp   /var
1 2011-12-03 37.846 30.494 0.578 55.643 99.785
2 2011-12-04 37.846 30.494 0.578 55.643 99.785
-------------------------------------------------------------------------------------------------------
group geom_line ggplot(data, aes(x = SIZE)) + 
      geom_bar(aes(y = (..count..)/sum(..count..))) +
      facet_grid(~ZONE) + 
      stat_summary(aes(y = BG,group = 1), fun.y=mean, colour="red", geom="line", size = 3) + 
      scale_y_continuous('Percent', labels = percent_format())
-------------------------------------------------------------------------------------------------------
plotmatrix dat <- data.frame(id= gl(4,1,labels,paste("id",1:4,sep="")), variable=gl(4,4,labels=LETTERS[1:4]),value=rnorm(16))

require(reshape2)
dat <- dcast(dat,id~variable)

plotmatrix <- function (data, mapping = aes(), colour = "black") 
{
    grid <- expand.grid(x = 1:ncol(data), y = 1:ncol(data))
    grid <- subset(grid, x != y)
    all <- do.call("rbind", lapply(1:nrow(grid), function(i) {
        xcol <- grid[i, "x"]
        ycol <- grid[i, "y"]
        data.frame(xvar = names(data)[ycol], yvar = names(data)[xcol], 
            x = data[, xcol], y = data[, ycol], data)
    }))
    all$xvar <- factor(all$xvar, levels = names(data))
    all$yvar <- factor(all$yvar, levels = names(data))
    densities <- do.call("rbind", lapply(1:ncol(data), function(i) {
        data.frame(xvar = names(data)[i], yvar = names(data)[i], 
            x = data[, i])
    }))
    densities$xvar <- factor(densities$xvar, levels = names(data))
    densities$yvar <- factor(densities$yvar, levels = names(data))
    mapping <- defaults(mapping, aes_string(x = "x", y = "y"))
    class(mapping) <- "uneval"
    ggplot(all, mapping) + 
        facet_grid(xvar ~ yvar, scales = "free") + 
        geom_point(colour = colour, na.rm = TRUE) + 
        stat_density(aes(x = x,y = ..scaled.. * diff(range(x)) + min(x)), 
            data = densities,position = "identity", colour = "grey20", geom = "line") + 
        geom_smooth(se = FALSE,method = "lm",colour = "blue")
}

plotmatrix(dat[,-1])
-------------------------------------------------------------------------------------------------------
ggplot2 facet_grid() CO3$dummy <- 1:nrow(CO3)

ggplot(CO3, aes(x=outcome)) + 
  geom_bar(aes(x=outcome)) + 
  facet_grid(Treatment~., margins=TRUE)
-------------------------------------------------------------------------------------------------------
# Save the original definition of the guide_grid
guide_grid_orig <- ggplot2:::guide_grid

# Create the replacement function
guide_grid_no_vline <- function(theme, x.minor, x.major, y.minor, y.major) {  
  x.minor <- setdiff(x.minor, x.major)
  y.minor <- setdiff(y.minor, y.major)

  ggname("grill", grobTree(
    theme_render(theme, "panel.background"),
    if(length(y.minor) > 0) theme_render(
      theme, "panel.grid.minor", name = "y",
      x = rep(0:1, length(y.minor)), y = rep(y.minor, each=2), 
      id.lengths = rep(2, length(y.minor))
      ),
    if(length(y.major) > 0) theme_render(
      theme, "panel.grid.major", name = "y",
      x = rep(0:1, length(y.major)), y = rep(y.major, each=2), 
      id.lengths = rep(2, length(y.major))
      )
    ))
}
# Set the environment to be the same as original
environment(guide_grid_no_vline) <- environment(ggplot2:::guide_grid)

# Assign the function inside ggplot2
assignInNamespace("guide_grid", guide_grid_no_vline, ns="ggplot2")

# Draw the plot with the redefined guide_grid
ggplot(CO3, aes(x=outcome)) + 
  geom_bar(aes(x=outcome))+ 
  facet_grid(Treatment~Type, margins='Treatment', scales='free')  +
  theme_bw() + 
  opts(axis.text.x=theme_text(angle= 45, vjust=1, hjust= 1))

# Restore the original guide_grid function so that it will draw all gridlines again
assignInNamespace("guide_grid", guide_grid_orig, ns="ggplot2")
-------------------------------------------------------------------------------------------------------
nadat <- expand.grid(i=71:80, j=63:78)
 nadat$d <- NA
 pl <- levelplot(d ~ j * i, data = rbind(dat,nadat) )
 print(pl)
-------------------------------------------------------------------------------------------------------
levelplot() library(lattice)

makeFullGrid <- function(dat) {
    ## Create a list with coordinates for a full grid and all
    ## values set to 0
    fullgrid <-
        with(dat, expand.grid(i = seq(max(i), min(i)),
                              j = seq(min(j), max(j)),
                              D = 0))
    ## Merge it with your current data, then add the two data
    ## columns together
    dat <- merge(fullgrid, dat, by = c("j", "i"), all.x=TRUE)
    dat$d <- dat$d + dat$D
    dat$D <- NULL         ## Clean up
    return(dat)
}    

## Fix up your data
myDat <- my.data.frame
myFullDat <- makeFullGrid(myDat)

## Create the levelplot
pl <- levelplot(d ~ j * i, data = myFullDat)
print(pl)
-------------------------------------------------------------------------------------------------------
melt walkaday <- read.csv("http://dl.dropbox.com/u/7046039/walkaday.csv")
walkaday.long <- melt(walkaday,id.vars=c(1,2,7))
qplot(factor(value,c("3","2","1")),data=walkaday.long,geom="bar")+facet_grid(.~variable) variable value
-------------------------------------------------------------------------------------------------------
merge() newdf df <- data.frame(matrix(1:9, ncol = 3))
colnames(df) <- c("circle","square","sphere")
rownames(df) <- c("red","blue","green")

newdf <- cbind.data.frame(ID = unlist(df), 
                          expand.grid(colour = rownames(df), 
                                      shape = colnames(df))) > newdf
        ID colour  shape
circle1  1    red circle
circle2  2   blue circle
circle3  3  green circle
square1  4    red square
square2  5   blue square
square3  6  green square
sphere1  7    red sphere
sphere2  8   blue sphere
sphere3  9  green sphere df2 df2 <- data.frame(colour = c("red","blue","blue","green"),
                  shape = c("circle","square","circle","sphere")) merge() > merge(newdf, df2, sort = FALSE)
  colour  shape ID
1    red circle  1
2   blue circle  2
3   blue square  5
4  green sphere  9 > res <- merge(newdf, df2, sort = FALSE)
> res <- res[,c(3,1,2)]
> res
  ID colour  shape
1  1    red circle
2  2   blue circle
3  5   blue square
4  9  green sphere
-------------------------------------------------------------------------------------------------------
ggplot(mtcars2, aes(x=cyl)) + 
  geom_bar() + 
  facet_grid(gear~am) + 
  stat_bin(geom="text", aes(label=..count.., vjust=-1)) count ..count..
-------------------------------------------------------------------------------------------------------
library(plyr)
library(ggplot2)

rm(dat)
dat <- read.table("data.txt", header = TRUE, sep = ",")
dat <- transform(dat, date = as.POSIXct(strptime(date, "%Y-%m-%dT%H:%M:%OS")))

rm(dat.m)
dat.m <- melt(dat, id = c('ccy','date','var1'))

lm_eqn = function(df){
  m = lm(var1 ~ value, df);
  eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
                   list(a = format(coef(m)[1], digits = 2), 
                        b = format(coef(m)[2], digits = 2), 
                        r2 = format(summary(m)$r.squared, digits = 3)))
  as.character(as.expression(eq));                 
}

mymax = function(df){
  max(df$value)
}

rm(regs)
regs <- ddply(dat.m, .(ccy,variable), lm_eqn)
regs.xpos <- ddply(dat.m, .(variable), function(df) (min(df$value)+max(df$value))/2)
regs.ypos <- ddply(dat.m, .(ccy,variable), function(df) min(df$var1) + 0.05*(max(df$var1)-min(df$var1)))

regs$y <- regs.ypos$V1
regs$x <- regs.xpos$V1

rm(gp)
gp <- ggplot(data=dat.m, aes(value, var1)) + geom_point(size = 1, alpha=0.75) + geom_smooth() + geom_smooth(method="lm", se=FALSE, color="red") + geom_text(data=regs, size=3, color="red", aes(x=x, y=y, label=V1), parse=TRUE) + facet_grid(ccy~variable, scales="free")
ggsave("data.png", gp, scale=1.5, width=11, height=8)
-------------------------------------------------------------------------------------------------------
#Create a data frame with the faceting variables
# and some dummy data (that will be overwritten)
tp <- unique(tips[,c('sex','day')])
tp$total_bill <- tp$tip <- 1

#Just Fri
ggplot(tips,aes(x=total_bill, y = tip/total_bill)) + 
        geom_rect(data = subset(tp,day == 'Fri'),aes(fill = day),xmin = -Inf,xmax = Inf,
            ymin = -Inf,ymax = Inf,alpha = 0.3) +
        geom_point(shape=1) + 
        facet_grid(sex ~ day) #Each panel
ggplot(tips,aes(x=total_bill, y = tip/total_bill)) + 
        geom_rect(data = tp,aes(fill = day),xmin = -Inf,xmax = Inf,
            ymin = -Inf,ymax = Inf,alpha = 0.3) +
        geom_point(shape=1) + 
        facet_grid(sex ~ day)
-------------------------------------------------------------------------------------------------------
expand.grid merge vals <- expand.grid(YearWeek = unique(test$YearWeek),
                    ProductID = unique(test$ProductID),
                    CustomerID = unique(test$CustomerID))
> merge(vals,test,all = TRUE)
  YearWeek ProductID CustomerID Quantity
1  2012-01         1          a        5
2  2012-01         1          b        7
3  2012-01         2          a        6
4  2012-01         2          b        8
5  2012-02         1          a        9
6  2012-02         1          b       11
7  2012-02         2          a       10
8  2012-02         2          b       NA NA is.na
-------------------------------------------------------------------------------------------------------
n=70
m1 = matrix(rnorm(n), ncol=7)
m2 = matrix(rnorm(n, 0,4), ncol=7)
d = data.frame(rbind(m1,m2), cl=rep(c(1,2), each=5))

d <- cbind(paste("d", 1:NROW(d), sep = ""), d)
names(d)[1] <- "id.var"

library(reshape)
longDF <- melt(d, id=c("cl", "id.var"))
library(ggplot2)

p <- ggplot(data = longDF, aes(x = variable, y = value, group = id.var))
p + geom_line() + stat_smooth(aes(group = 1), method = "lm", 
se = FALSE, colour="red") + facet_grid(cl ~ .)
-------------------------------------------------------------------------------------------------------
?xyf xyf(data, Y=annotation, grid=somgrid(3,2))
-------------------------------------------------------------------------------------------------------
xdf <- data.frame(x=rep(1:10,each=4)
              ,y=rep(1:10,each=4)*rep(1:4,10)  +rnorm(40,0,1)
              ,g=rep(c("R","S"),20)
              ,z=rep(c("A","A","B","B"),10)
              )
head(xdf)
# plot
xp <- ggplot(xdf,aes(x=x,y=y, group=g)) +
geom_line() +
facet_grid(. ~ z)
xp
# location of the arrow: x=4, y=y+1 on the top of the first facet (A)
(f1x4 <- subset(xdf,x==4 & g=="R" & z=="A")$y)
arrdf <- data.frame(x = 4, y = f1x4, z = "A", g = "R")   # create new data.frame for    annotations
# add arrow and label
xp + geom_segment(data=arrdf,aes(x=x,xend=x,y=y+3,yend=y,z=z,g=g)  # <-- see the z='A'
              , arrow=arrow(length=unit(0.4,"cm")
                )
             ) +
geom_text(data=arrdf,aes(x=x,y=y+4, label="a",z=z, g=g))
-------------------------------------------------------------------------------------------------------
g + facet_grid(Type1 ~ Type2, scales="free") ggplot(data, aes(x=Category, y=Percent)) + 
  geom_bar(width=0.8, stat="identity", position=position_dodge()) + 
  facet_wrap(Type1 ~ Type2,scales="free") + 
  theme_bw() +
  scale_y_continuous(c(0,100)) + 
  coord_flip() + 
  opts()
-------------------------------------------------------------------------------------------------------
facet_grid(scales="free") coord_flip() library(ggplot2)

# Removed quotes from Percent values, so that Percent will be numeric.
dat <- structure(list(Type1 = c("DB", "DB", "DB", "DB", "DB", "DB", 
"DB", "DB", "DB", "DB", "DB", "DB", "DB", "Manual", "Manual", 
"Manual", "Manual", "Manual", "Manual", "Manual", "Manual", "Manual", 
"Manual", "Manual", "Manual", "Manual", "Manual", "Manual"), 
    Type2 = c(1L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L, 3L, 3L, 3L, 
    3L, 1L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L, 2L, 3L, 3L, 3L, 3L, 
    3L), Category = c("A", "B", "C", "D", "E", "A", "B", "F", 
    "G", "A", "B", "C", "H", "I", "J", "K", "L", "M", "O", "J", 
    "P", "K", "Q", "M", "K", "P", "J", "P"), Percent = c(83.5106383, 
    9.574468085, 5.85106383, 0.531914894, 1/188*100, 
    85.24590164, 11.47540984, 1/61*100, 1.639344262, 
    90, 3.333333333, 3.333333333, 3.333333333, 20.10582011, 
    10.05291005, 6.349206349, 5.82010582, 4.761904762, 
    31.14754098, 16.39344262, 6.557377049, 6.557377049, 
    4.918032787, 30, 23.33333333, 16.66666667, 10, 
    6.666666667)), .Names = c("Type1", "Type2", "Category", 
"Percent"), row.names = c(NA, -28L), class = "data.frame")

figure_1 = ggplot(dat, aes(x=Category, y=Percent)) + 
           geom_bar(width=0.8, stat="identity") + 
           facet_grid(Type2 ~ Type1, scales="free_x") + 
           theme_bw() + 
           scale_y_continuous(limits=c(0, 100)) +
           opts(title="Figure 1. Success!\n(But Rotated 90 Degrees)")

figure_2 = ggplot(dat, aes(x=Percent, y=Category)) + 
           geom_point(size=3) + 
           facet_grid(Type1 ~ Type2, scales="free_y") + 
           theme_bw() + 
           scale_x_continuous(limits=c(0, 100)) +
           opts(title="Figure 2. Success!\n(But Dotplot Instead Of Barplot)")

# Unexpected interaction between scales="free" and coord_flip()?
figure_3 = ggplot(dat, aes(x=Category, y=Percent)) + 
           geom_bar(width=0.8, stat="identity") + 
           facet_grid(Type1 ~ Type2, scales="free") + 
           theme_bw() + 
           scale_y_continuous(limits=c(0, 100)) +
           coord_flip() +
           opts(title="Figure 3. Strange Y-axis Behavior.")
-------------------------------------------------------------------------------------------------------
scale_gradientn library(ggplot2)

x = seq(-0.1, 0.1, len=100)
y = 0:10
dat = expand.grid(x=x, y=y)

ggplot(data=dat, aes(x=x, y=y, fill=x)) +
  geom_raster() +
  scale_fill_gradientn(colours=c('red', 'yellow', 'cyan', 'blue'),
    values   = c(-0.05,-1e-32,1e-32,0.05),
    breaks   = c(-0.05,-0.005,0.005,0.05),
    rescaler = function(x,...) x,
    oob      = identity)
-------------------------------------------------------------------------------------------------------
facet_grid space = "free" geom_point() geom_errorbarh() coord.flip() theme test library(ggplot2)

p <- ggplot(test, aes(y = characteristic, x = es, xmin = ci_low, xmax = ci_upp)) +
   geom_point() +
   geom_errorbarh(height = 0) +
   facet_grid(set ~ ., scales = "free", space = "free") +
   theme_bw() +
   theme(strip.text.y = element_text(angle = 0))

p
-------------------------------------------------------------------------------------------------------
geom_text xlim library(gridExtra)
library(ggplot2)

p <- ggplot(test, aes(y = characteristic, x = es, xmin = ci_low, xmax = ci_upp)) + 
  geom_point() +   
  geom_errorbarh(height = 0) +
  geom_text(aes(label = label, x = 2, y = characteristic)) + 
  scale_x_continuous(limits = c(1, 2.2), breaks = c(1, 1.2, 1.4, 1.6, 1.8),
    labels=c("1.0", "1.2", "1.4", "1.6", "1.8")) +
  facet_grid(set ~ ., scales = "free", space = "free") +
  theme_bw() + 
  theme(strip.text.y = element_text(angle = 0),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank())
p

grid.text(expression(paste("ES " %+-% " ci")), x = 0.78,   y = .92,
   gp = gpar(fontsize = 18))
-------------------------------------------------------------------------------------------------------
df <- data.frame(expand.grid(1:5,1:5))
df$z <- runif(nrow(df))
df$grp <- rep(letters[1:2],length.out = nrow(df))

ggplot(df,aes(x = Var1,y = Var2,fill = factor(grp),alpha = z)) + 
    geom_tile() + 
    scale_fill_manual(values = c('red','blue'))
-------------------------------------------------------------------------------------------------------
ggplot() group group centroids geom_text groups=NULL geom_text ggplot(map.data2, aes(long, lat, group=group)) +  
   geom_polygon(aes(fill=level), colour=alpha('white', 1/2), size=0.2) +
   geom_polygon(data=ny, colour='black', fill=NA) + 
   scale_fill_brewer(palette='RdYlBu', guide = guide_legend(title = 
         "Percent Passing"))+
   facet_grid(.~Subject)+
   geom_text(data=centroids, aes(x=long, y=lat, 
     label=subregion, angle=angle, group=NULL), size=3) +   # THIS HAS CHANGED!
   opts(title = " 
     New York State Counties Passing Rate \non Elementary ELA Assessments") +
   opts(axis.text.x = theme_blank(), axis.text.y = theme_blank(), 
       axis.ticks = theme_blank())+
   opts(legend.background = theme_rect()) +
   scale_x_continuous('') + scale_y_continuous('') + 
   labs(title = "legend title") + theme_bw()+
    opts(axis.line=theme_blank(),axis.text.x=theme_blank(),
      axis.text.y=theme_blank(),axis.ticks=theme_blank(),
      axis.title.x=theme_blank(), legend.position="bottom",
      axis.title.y=theme_blank(),
      panel.background=theme_blank(),panel.grid.major=theme_blank(),
      panel.grid.minor=theme_blank(),plot.background=theme_blank())
-------------------------------------------------------------------------------------------------------
R python numpy pandas matplotlib import numpy as np
import pandas as pd
import matplotlib.pyplot as plt 

df = pd.DataFrame({'original_length': [1875, 1143, 960, 1302, 2016],
                   'row_retained': [False, False, False, False, True],
                   'percentage_retained': [11.0, 23.0, 44.0, 66.0, 87.0]})
fig, ax = plt.subplots()
ax.scatter(df.original_length, df.percentage_retained,
           c=np.where(df.row_retained, 'green', 'red'),
           s=np.random.randint(50, 500, 5)
           )   
true_value = df[df.row_retained]
ax.annotate('This one is True',
            xy=(true_value.original_length, true_value.percentage_retained),
            xytext=(0.1, 0.001), textcoords='figure fraction',
            arrowprops=dict(arrowstyle="->"))
ax.grid()
ax.set_xlabel('Original Length')
ax.set_ylabel('Precentage Retained')
ax.margins(0.04)
plt.tight_layout()
plt.savefig('alternative.png') pandas
-------------------------------------------------------------------------------------------------------
decision value = 0 rgl contour3d() misc3d library(e1071)
library(rgl)
library(misc3d)

n    = 100
nnew = 50

# Simulate some data
set.seed(12345)
group = sample(2, n, replace=T)
dat   = data.frame(group=factor(group), matrix(rnorm(n*3, rep(group, each=3)), ncol=3, byrow=T))

# Fit SVM
fit = svm(group ~ ., data=dat)

# Plot original data
plot3d(dat[,-1], col=dat$group)

# Get decision values for a new data grid
newdat.list = lapply(dat[,-1], function(x) seq(min(x), max(x), len=nnew))
newdat      = expand.grid(newdat.list)
newdat.pred = predict(fit, newdata=newdat, decision.values=T)
newdat.dv   = attr(newdat.pred, 'decision.values')
newdat.dv   = array(newdat.dv, dim=rep(nnew, 3))

# Fit/plot an isosurface to the decision boundary
contour3d(newdat.dv, level=0, x=newdat.list$X1, y=newdat.list$X2, z=newdat.list$X3, add=T)
-------------------------------------------------------------------------------------------------------
scales=list(log="e") scales=list(log="e",x=list(cex=.3),y=list(cex=.3)) x <- seq(pi/4, 5 * pi, length.out = 100)
y <- seq(pi/4, 5 * pi, length.out = 100)
r <- as.vector(sqrt(outer(x^2, y^2, "+")))
grid <- expand.grid(x=x, y=y)
grid$z <- cos(r^2) * exp(-r/(pi^3))
levelplot(z~x*y, grid, cuts = 50, 
      scales=list(log="e",x=list(cex=.3),y=list(cex=.3)), xlab=list(cex=.05),
      ylab=list(cex=.25), main=list(label="Weird Function", cex=5), sub="with log scales",
      colorkey = FALSE, region = TRUE)
-------------------------------------------------------------------------------------------------------
z <- expand.grid(0:3,0:3)
z[rowSums(z)==2, ]
  Var1 Var2
3    2    0
5    1    1
7    0    2 z <- expand.grid( rep( list(C), A) ) rep(0:3, 3) > z <- expand.grid(rep(list(0:3), 3))
> z[rowSums(z)==2, ]
   Var1 Var2 Var3
3     2    0    0
6     1    1    0
9     0    2    0
18    1    0    1
21    0    1    1
33    0    0    2
-------------------------------------------------------------------------------------------------------
library(Sleuth2) data $ mlr<-lm(Buchanan2000~Perot96*Gore2000,data=ex1222) expand.grid() predict() perot <- seq(1000,40000,by=1000)
gore <-  seq(1000,400000,by=2000) perot <- sort(unique(ex1222$Perot96)); gore <- sort(unique(ex1222$Gore2000)) pframe <- with(ex1222,expand.grid(Perot96=perot,Gore2000=gore))
mlrpred <- predict(mlr,newdata=pframe) nrz <- length(perot)
ncz <- length(gore)
z <- matrix(mlrpred,nrow=nrz) #ffcccc #cc0000 jet.colors <- colorRampPalette( c("#ffcccc", "#cc0000") ) grep("red",colors(),value=TRUE) # Generate the desired number of colors from this palette
nbcol <- 100
color <- jet.colors(nbcol)

# Compute the z-value at the facet centres
zfacet <- z[-1, -1] + z[-1, -ncz] + z[-nrz, -1] + z[-nrz, -ncz]
# Recode facet z-values into color indices
facetcol <- cut(zfacet, nbcol)

persp(perot, gore, z,
      col=color[facetcol],theta=-30, lwd=.3,
      xlab="Perot 96", ylab="Gore 2000", zlab="Predicted Votes for Buchanan") ?persp rgl library(rgl)
## see ?persp3d for discussion of colour handling
vertcol <- cut(z, nbcol)
persp3d(perot, gore, z,
      col=color[vertcol],smooth=FALSE,lit=FALSE,
      xlab="Perot 96", ylab="Gore 2000", zlab="Predicted Votes for Buchanan") scatter3d car library(car)
scatter3d(Buchanan2000~Perot96*Gore2000,data=ex1222)
-------------------------------------------------------------------------------------------------------
scale_*_manual ggplot(mdf, aes(x=d, y=value, shape=meth, linetype=meth)) + geom_line() +
    geom_point() + facet_grid(fam. ~ tau., scales="free_y", labeller=label_parsed) +
    ## scale_linetype_manual(values=1:4, breaks=meth, labels=meth.labs) + # problem: adds another legend
    scale_x_continuous(trans="log10", breaks=d, labels=d) +
    scale_y_continuous(trans="log10") + 
    scale_linetype_manual(breaks = c('m1','m2','m3','m4'),values = 1:4,labels = meth.labs) +
    scale_shape_manual(breaks = c('m1','m2','m3','m4'),values = 1:4,labels = meth.labs)
-------------------------------------------------------------------------------------------------------
library(microbenchmark)
n <- nrow(dat)
m <- ncol(dat)
f1 <- function()   expand.grid(1:n, 1:m)
f2 <- function()   
  data.frame( 
    Var1 = as.vector(outer( 1:n, rep(1,m) )),
    Var2 = as.vector(outer( rep(1,n), 1:m ))
  )
microbenchmark( f1, f2, times=1e6 )
# Unit: nanoseconds
#   expr min  lq median  uq    max
# 1   f1  70 489    490 559 168458
# 2   f2  70 489    490 559 168597
-------------------------------------------------------------------------------------------------------
expand.grid.alt2 <- function(seq1,seq2) {
  cbind(Var1=rep.int(seq1, length(seq2)), Var2=rep(seq2, each=length(seq1)))
}

s1=seq_len(2000); s2=seq_len(2000)
system.time( for(i in 1:10) expand.grid.alt2(s1, s2) ) # 1.58
system.time( for(i in 1:10) expand.grid.alt(s1, s2) )  # 1.75
system.time( for(i in 1:10) expand.grid(s1, s2) )      # 2.46
-------------------------------------------------------------------------------------------------------
# Some toy data
df <- expand.grid(x = factor(seq(1:5)), y = factor(seq(1:5)), KEEP.OUT.ATTRS = FALSE)
df$Count = seq(1:25)

# A plot
library(ggplot2)
p = ggplot(data = df, aes( x = x, y = y, label = Count, size = Count)) + 
   geom_point(colour = NA) +
   geom_text(show_guide = FALSE) +  
   guides(size = guide_legend(override.aes = list(colour = "black", shape = utf8ToInt("N")))) +
   scale_size(range = c(2, 10))

p # Some toy data
df <- expand.grid(x = factor(seq(1:5)), y = factor(seq(1:5)), KEEP.OUT.ATTRS = FALSE)
df$Count = seq(1:25)

# A plot
library(ggplot2)
p = ggplot(data = df, aes( x = x, y = y, label = Count, size = Count)) + 
    geom_text() +
    scale_size(range = c(2, 10))
p

library(grid)
grid.gedit("^key-[-0-9]+$", label = "N")
-------------------------------------------------------------------------------------------------------
grid.layout grid.arrange install.packages("gridExtra")
 require(gridExtra) # also loads grid
 require(lattice)
 x <- seq(pi/4, 5 * pi, length.out = 100)> y <- seq(pi/4, 5 * pi, length.out = 100)
 r <- as.vector(sqrt(outer(x^2, y^2, "+")))

 grid <- expand.grid(x=x, y=y)
 grid$z <- cos(r^2) * exp(-r/(pi^3))
 plot1 <- levelplot(z~x*y, grid, cuts = 50, scales=list(log="e"), xlab="",
           ylab="", main="Weird Function", sub="with log scales",
           colorkey = FALSE, region = TRUE)

 plot2 <- levelplot(z~x*y, grid, cuts = 50, scales=list(log="e"), xlab="",
           ylab="", main="Weird Function", sub="with log scales",
           colorkey = FALSE, region = TRUE)
 grid.arrange(plot1,plot2, ncol=2)
-------------------------------------------------------------------------------------------------------
lattice ggplot2 ggplot2 p <- ggplot(diamonds, aes(carat, ..density..)) + 
  geom_histogram(binwidth = 0.2) + facet_grid(clarity ~ cut)
-------------------------------------------------------------------------------------------------------
data.table merge library(data.table)

set.seed(1)

mydf3<-data.frame(Id=sample(1:100,10000,replace=TRUE),
  Value=rnorm(10000))
mydf3<-mydf3[order(mydf3$Id),]

mydf3$Time<-unlist(by(mydf3,mydf3$Id,
  function(x)sample(1:(nrow(x)+3),nrow(x)),simplify=TRUE))

mydf3$Id2<-sample(1:2,nrow(mydf3),replace=TRUE) padFun<-function(data,idvars,timevar){
# Coerce ID variables to character
  data[,idvars]<-lapply(data[,idvars,drop=FALSE],as.character)
# Create global ID variable of all individual ID vars pasted together
  globalID<-Reduce(function(...)paste(...,sep="SOMETHINGWACKY"),
    data[,idvars,drop=FALSE])
# Create data.frame of all possible combinations of globalIDs and times
  allTimes<-expand.grid(globalID=unique(globalID),
    allTime=min(data[,timevar]):max(data[,timevar]),
    stringsAsFactors=FALSE)
# Get the original ID variables back
  allTimes2<-data.frame(allTimes$allTime,do.call(rbind,
    strsplit(allTimes$globalID,"SOMETHINGWACKY")),stringsAsFactors=FALSE)
# Convert combinations data.frame to data.table with idvars and timevar as key
  allTimesDT<-data.table(allTimes2)
  setnames(allTimesDT,1:ncol(allTimesDT),c(timevar,idvars))
  setkeyv(allTimesDT,c(idvars,timevar))
# Convert data to data.table with same variables as key
  dataDT<-data.table(data,key=c(idvars,timevar))
# Join the two data.tables to create padding
  res<-dataDT[allTimesDT]
  return(res)
} (padded2<-padFun(data=mydf3,idvars=c("Id"),timevar="Time"))

#       Id Time        Value Id2
#  [1,]  1    1 -0.262482283   2
#  [2,]  1    2 -1.423935165   2
#  [3,]  1    3  0.500523295   1
#  [4,]  1    4 -1.912687398   1
#  [5,]  1    5 -1.459766444   2
#  [6,]  1    6 -0.691736451   1
#  [7,]  1    7           NA  NA
#  [8,]  1    8  0.001041489   2
#  [9,]  1    9  0.495820559   2
# [10,]  1   10 -0.673167744   1
# First 10 rows of 12800 printed.

(padded<-padFun(data=mydf3,idvars=c("Id","Id2"),timevar="Time"))

#      Id Id2 Time      Value
#  [1,]  1   1    1         NA
#  [2,]  1   1    2         NA
#  [3,]  1   1    3  0.5005233
#  [4,]  1   1    4 -1.9126874
#  [5,]  1   1    5         NA
#  [6,]  1   1    6 -0.6917365
#  [7,]  1   1    7         NA
#  [8,]  1   1    8         NA
#  [9,]  1   1    9         NA
# [10,]  1   1   10 -0.6731677
# First 10 rows of 25600 printed.
-------------------------------------------------------------------------------------------------------
ggplot2 # Load required packages
library(ggplot2)

# Your data
dat <- data.frame(
  pos = c(1, 3, 5, 8, 10, 12),
  start = c(1,3, 6, 7, 10, 11),
  end = c(5, 6, 9, 9, 13, 12) )

# Get the  plot
p <- ggplot(dat) + 
   geom_segment(aes(x=start, y=pos, xend=end, yend=pos), 
         color="blue", size=2, lineend = "round") + 
   ylab("Fragments") +  xlab("Position") + 
   theme_bw() +
   geom_text(aes(label = pos, x = start, y = pos), hjust = 1.7) +
   scale_x_continuous(breaks = seq(0,14,2), labels = seq(0,14,2), expand = c(0,0)) +
   scale_y_continuous(limits = c(-1, 14), expand = c(0,0))  +
   geom_hline(yintercept = -1) +
   geom_segment(aes(x = 0, y = -1, xend = 0, yend = -0.9)) +
   geom_segment(aes(x = 14, y = -1, xend = 14, yend = -0.9)) +
   theme(panel.grid.major=element_blank(),
       panel.grid.minor=element_blank(),
       panel.border=element_blank(),
       axis.ticks.y = element_blank(), 
       axis.title.y = element_blank(),
       axis.text.y = element_blank())
p ggplot2 grid() # Load required packages
library(ggplot2)
library(grid)

# Your data
dat <- data.frame(
  pos = c(1, 3, 5, 8, 10, 12),
  start = c(1,3, 6, 7, 10, 11),
  end = c(5, 6, 9, 9, 13, 12) )

# Get the base plot
p <- ggplot(dat) + 
   geom_segment(aes(x=start, y=pos, xend=end, yend=pos), 
   color="blue", size=2) + ylab("Fragments") +  xlab("Position") + theme_bw() +
   geom_text(aes(label = pos, x = start, y = pos), hjust = 1.7) +
   scale_x_continuous(breaks = seq(0,14,2), labels = seq(0,14,2), expand = c(0,0)) +
   scale_y_continuous(limits = c(-1, 14), expand = c(0,0))  +
   geom_hline(yintercept = -1) +
   geom_segment(aes(x = 0, y = -1, xend = 0, yend = -0.9)) +
   geom_segment(aes(x = 14, y = -1, xend = 14, yend = -0.9)) +
   opts(panel.grid.major=theme_blank(),
       panel.grid.minor=theme_blank(),
       panel.border=theme_blank(),
       axis.title.y = theme_blank(),
       axis.text.y = theme_blank())
p

# Remove the y-axis tick marks
g <- ggplotGrob(p)# Save plot as a grob
#grid.ls(g) 
grid.remove(grid.get("axis.ticks", grep=T, global = TRUE)[[1]]$name) proto geom_segment2 # To create the new `geom_segment2`
library(proto)
GeomSegment2 <- proto(ggplot2:::GeomSegment, {
 objname <- "geom_segment2"
 draw <- function(., data, scales, coordinates, arrow=NULL, ...) {
   if (is.linear(coordinates)) {
     return(with(coord_transform(coordinates, data, scales),
       segmentsGrob(x, y, xend, yend, default.units="native",
       gp = gpar(col=alpha(colour, alpha), lwd=size * .pt,
         lty=linetype, lineend = "round"),
       arrow = arrow)
     ))
   }

}})

geom_segment2 <- function(mapping = NULL, data = NULL, stat =
"identity", position = "identity", arrow = NULL, ...)  {
  GeomSegment2$new(mapping = mapping, data = data, stat = stat,
        position = position, arrow = arrow, ...)
} 

    # The base plot
p <- ggplot(dat) + 
       geom_segment2(aes(x=start, y=pos, xend=end, yend=pos), 
       color="blue", size=2, lineend = "round") + ylab("Fragments") +  xlab("Position") + theme_bw() +
       geom_text(aes(label = pos, x = start, y = pos), hjust = 1.7) +
       scale_x_continuous(breaks = seq(0,14,2), labels = seq(0,14,2), expand = c(0,0)) +
       scale_y_continuous(limits = c(-1, 14), expand = c(0,0))  +
       geom_hline(yintercept = -1) +
       geom_segment(aes(x = 0, y = -1, xend = 0, yend = -0.9)) +
       geom_segment(aes(x = 14, y = -1, xend = 14, yend = -0.9)) +
       opts(panel.grid.major=theme_blank(),
           panel.grid.minor=theme_blank(),
           panel.border=theme_blank(),
           axis.title.y = theme_blank(),
           axis.text.y = theme_blank())
p

## Remove the y-axis tick marks
g <- ggplotGrob(p)
#grid.ls(g) 
grid.remove(grid.get("axis.ticks", grep=T, global = TRUE)[[1]]$name)
-------------------------------------------------------------------------------------------------------
library(lme4)
fit <- glmer(resp.var ~ cont.var:cat.var + (1|rand.eff) ,
           data = sample.data , poisson) cont.var==0 cont.var*cat.var library(ggplot2)
theme_update(theme_bw())  ## set white rather than gray background ggplot(sample.data,aes(cont.var,resp.var,linetype=cat.var))+
    geom_smooth(method="lm",se=FALSE) ggplot(sample.data,aes(cont.var,resp.var,colour=cat.var))+
    stat_sum(aes(size=..n..),alpha=0.5)+
    geom_smooth(method="glm",family="poisson") lme4 predict predframe <- with(sample.data,
                  expand.grid(cat.var=levels(cat.var),
                              cont.var=seq(min(cont.var),
                              max(cont.var),length=51))) REform=NA predframe$pred.logit <- predict(fit,newdata=predframe,REform=NA)

minmaxvals <- range(sample.data$cont.var)

ggplot(predframe,aes(cont.var,pred.logit,linetype=cat.var))+geom_line()+
    geom_point(data=subset(predframe,cont.var %in% minmaxvals),
               aes(shape=cat.var)) predframe$pred <- predict(fit,newdata=predframe,REform=NA,type="response")
ggplot(predframe,aes(cont.var,pred,linetype=cat.var))+geom_line()+
    geom_point(data=subset(predframe,cont.var %in% minmaxvals),
               aes(shape=cat.var))
-------------------------------------------------------------------------------------------------------
data.table library(data.table)

## Create a list of three 500000 row data.frames
df <- expand.grid(site=1:2, run=1:2, id=1:2)
df <- data.frame(df, payload=1:1000, dir=rep(1, 5e5))
dfList <- list(df, df, df)
dfNames <- c("firstCSV", "secondCSV", "thirdCSV")

## Manipulate the data with data.table, and time the calculations
system.time({
outputList <-
    lapply(1:3, FUN = function(ii) {
        label <- dfNames[ii]
        df <- dfList[[ii]]
        dt <- data.table(df, key=c("site", "run", "id"))
        groups <- unique(dt[,key(dt), with=FALSE])
        groups[, stream := seq_len(nrow(groups))]
        dt <- dt[groups]
        # Note: The following line only keeps the first 3 (rather than 20) rows
        dt <- dt[, head(cbind(.SD, i=seq_len(.N)), 3), by=stream]
        dt <- cbind(label,
                    dt[,c("stream", "dir", "i", "payload"), with=FALSE])
        df <- as.data.frame(dt)
        return(df)
    })
output <- do.call(rbind, outputList)
})
##    user  system elapsed 
##    1.25    0.18    1.44 

## Have a look at the output
rbind(head(output,4), tail(output,4)) dt <- dt[, head(cbind(.SD, i=seq_len(.N)), 3), by=stream] dt <- cbind(dt, i = dt[, list(i=seq_len(.N)), by=stream][[2]])
dt <- dt[i<=3,]  # Note: This only keeps the 1st 3 (rather than 20) rows
-------------------------------------------------------------------------------------------------------
p = ggplot(mdfn, aes(Visit, Patient)) + 
  geom_tile(aes(fill = Year2), colour = "gray") +
  scale_fill_gradient(low = "white", high = "steelblue") + 
  theme_grey(base_size = base_size) + 
  labs(x = "", y = "") +
  scale_x_discrete(expand = c(0, 0)) + 
  scale_y_discrete(expand = c(0, 0)) + 
  opts(legend.position = "none", axis.ticks = theme_blank(), 
       axis.text.x = theme_text(size = base_size * 0.8, angle = 330,
         hjust = 0, colour = "grey50")) + 
  facet_grid(~ FWrap, scales = "free", space="free") 

s = subset(mdfn, Visit %in% c("Referral","VISIT01"))
p + geom_text(aes(label=format(Year, "%b. %d, %Y")), data = s, 
              size=3, colour = 'white')
-------------------------------------------------------------------------------------------------------
file.paths <- paste0('dir', 1:10, '/', 'f1.csv')
lapply(file.paths, read.csv) expand.grid combos <- expand.grid(1:10, 1:10)
file.paths <- paste0('dir', combos[,1], '/f', combos[,2], '.csv')
-------------------------------------------------------------------------------------------------------
grid() annotation_custom() grid annotation_custom library (ggplot2)
library(grid)

test= data.frame(
  group=c(rep(1,6), rep(2,6)),
  subgroup=c( 1,1,1,2,2,2,1,1,1,2,2,2),
  category=c( rep(1:3, 4)),
  count=c( 10,80,10,5,90,5,  10,80,10,5,90,5   )
  )

p <- qplot(subgroup, count, 
  data=test, geom="bar",  stat="identity",
  fill =category,  
  facets =  .~ group,  width=0.9)+
  opts(legend.position="none",  plot.margin = unit(c(0,9,2,0), "lines"))



# Create the text Grobs
Text1 = textGrob("Text 1")
Text2 = textGrob("Text 2")
Text4 = textGrob("Text 4")

# Draw the plot
# Text 1
p1 = p + annotation_custom(grob = Text1,  xmin = 3., xmax = 3., ymin = 85, ymax = 100) +
    annotation_custom(grob = linesGrob(), xmin = 2.6, xmax = 2.75, ymin = 100, ymax = 100) +
    annotation_custom(grob = linesGrob(), xmin = 2.6, xmax = 2.75, ymin = 85, ymax = 85) +
    annotation_custom(grob = linesGrob(), xmin = 2.75, xmax = 2.75, ymin = 85, ymax = 100)

# Text 2
p1 = p1 + annotation_custom(grob = Text2,  xmin = 3, xmax = 3, ymin = 20, ymax = 80) +
    annotation_custom(grob = linesGrob(), xmin = 2.6, xmax = 2.75, ymin = 80, ymax = 80) +
    annotation_custom(grob = linesGrob(), xmin = 2.6, xmax = 2.75, ymin = 20, ymax = 20) +
    annotation_custom(grob = linesGrob(), xmin = 2.75, xmax = 2.75, ymin = 20, ymax = 80)

# Text 4
p1 = p1 + annotation_custom(grob = Text4,  xmin = 3, xmax = 3, ymin = 0, ymax = 15) +
    annotation_custom(grob = linesGrob(), xmin = 2.6, xmax = 2.75, ymin = 15, ymax = 15) +
    annotation_custom(grob = linesGrob(), xmin = 2.6, xmax = 2.75, ymin = 0, ymax = 0) +
    annotation_custom(grob = linesGrob(), xmin = 2.75, xmax = 2.75, ymin = 0, ymax = 15)

p1

# Code to override clipping
gt <- ggplot_gtable(ggplot_build(p1))
gt$layout$clip[gt$layout$name=="panel"] <- "off"
grid.draw(gt)
-------------------------------------------------------------------------------------------------------
x <- expand.grid(1:length(a), 1:length(b))
x <- x[order(x$Var1), ]    #gives the order you asked for
FUN <- function(i)  diag(outer(a[[x[i, 1]]], b[[x[i, 2]]], "*"))
sapply(1:nrow(x), FUN)     #I like this out put
lapply(1:nrow(x), FUN)     #This one matches what you asked for expand.grid2 expand.grid2 <-function(seq1,seq2) {
    cbind(Var1 = rep.int(seq1, length(seq2)), 
    Var2 = rep.int(seq2, rep.int(length(seq1),length(seq2))))
}

x <- expand.grid2(1:length(a), 1:length(b))
x <- x[order(x[,'Var1']), ]    #gives the order you asked for
FUN <- function(i)  diag(outer(a[[x[i, 1]]], b[[x[i, 2]]], "*"))
lapply(1:nrow(x), FUN) expand.grid2 Unit: microseconds
            expr      min       lq   median       uq      max
1   DiggsL(a, b) 5102.296 5307.816 5471.578 5887.516 70965.58
2   DiggsM(a, b)  384.912  428.769  443.466  461.428 36213.89
3    Joris(a, b)   91.446  105.210  123.172  130.171 16833.47
4 TylerEG2(a, b)  392.377  425.503  438.100  453.263 32208.94
5   TylerL(a, b) 1752.398 1808.852 1847.577 1975.880 49214.10
6   TylerM(a, b) 1827.515 1888.867 1925.959 2090.421 75766.01
7 Wojciech(a, b) 1719.740 1771.760 1807.686 1924.325 81666.12
-------------------------------------------------------------------------------------------------------
# Your data
a <- list(c(1,2), c(2,3), c(4,5))
b <- list(c(1,3), c(3,4), c(6,2))

# Matrix with indicies for elements to multiply
G <- expand.grid(1:3,1:3)

# Coversion of G to list
L <- lapply(1:nrow(G),function(x,d=G) d[x,])

lapply(L,function(i,x=a,y=b) x[[i[[2]]]]*y[[i[[1]]]])
-------------------------------------------------------------------------------------------------------
do.call(mapply, c(FUN=`*`, as.list(expand.grid(b, a)))) [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]
[1,]    1    3    6    2    6   12    4   12   24
[2,]    6    8    4    9   12    6   15   20   10 plyr library("plyr")
as.list(unname(alply(do.call(mapply, c(FUN=`*`, as.list(expand.grid(b, a)))), 2))) [[1]]
[1] 1 6

[[2]]
[1] 3 8

[[3]]
[1] 6 4

[[4]]
[1] 2 9

[[5]]
[1]  6 12

[[6]]
[1] 12  6

[[7]]
[1]  4 15

[[8]]
[1] 12 20

[[9]]
[1] 24 10 Joris <- function(a, b) {
    mapply(`*`,a,rep(b,each=length(a)))
}

TylerM <- function(a, b) {
    x <- expand.grid(1:length(a), 1:length(b))
    x <- x[order(x$Var1), ]    #gives the order you asked for
    FUN <- function(i)  diag(outer(a[[x[i, 1]]], b[[x[i, 2]]], "*"))
    sapply(1:nrow(x), FUN)
}

TylerL <- function(a, b) {
    x <- expand.grid(1:length(a), 1:length(b))
    x <- x[order(x$Var1), ]    #gives the order you asked for
    FUN <- function(i)  diag(outer(a[[x[i, 1]]], b[[x[i, 2]]], "*"))
    lapply(1:nrow(x), FUN)
}

Wojciech <- function(a, b) {
    # Matrix with indicies for elements to multiply
    G <- expand.grid(1:3,1:3)

    # Coversion of G to list
    L <- lapply(1:nrow(G),function(x,d=G) d[x,])

    lapply(L,function(i,x=a,y=b) x[[i[[2]]]]*y[[i[[1]]]])
}

DiggsM <- function(a, b) {
    do.call(mapply, c(FUN=`*`, as.list(expand.grid(b, a))))
}

DiggsL <- function(a, b) {
    as.list(unname(alply(t(do.call(mapply, c(FUN=`*`, as.list(expand.grid(b, a))))), 1)))
} > library("rbenchmark")
> benchmark(Joris(b,a),
+           TylerM(a,b),
+           TylerL(a,b),
+           Wojciech(a,b),
+           DiggsM(a,b),
+           DiggsL(a,b),
+           order = "relative", 
+           replications = 1000,
+           columns = c("test", "elapsed", "relative"))
            test elapsed relative
1    Joris(b, a)    0.08    1.000
5   DiggsM(a, b)    0.26    3.250
4 Wojciech(a, b)    1.34   16.750
3   TylerL(a, b)    1.36   17.000
2   TylerM(a, b)    1.40   17.500
6   DiggsL(a, b)    3.49   43.625 > identical(Joris(b,a), TylerM(a,b))
[1] TRUE
> identical(Joris(b,a), DiggsM(a,b))
[1] TRUE
> identical(TylerL(a,b), Wojciech(a,b))
[1] TRUE
> identical(TylerL(a,b), DiggsL(a,b))
[1] TRUE
-------------------------------------------------------------------------------------------------------
breaks ggplot(mtcars, aes(wt, mpg)) + 
geom_point() + 
facet_grid(am+cyl~., scales="free_y") scales::pretty_breaks library("scales")
integer_breaks <- function(n = 5, ...) {
  breaker <- pretty_breaks(n, ...)
  function(x) {
     breaks <- breaker(x)
     breaks[breaks == floor(breaks)]
  }
} breaks ggplot(mtcars, aes(wt, mpg)) + 
geom_point() + 
facet_grid(am+cyl~., scales="free_y") +
scale_y_continuous(breaks = integer_breaks())
-------------------------------------------------------------------------------------------------------
library(ggplot2)
ggplot(mtcars, aes(wt, mpg)) + 
   geom_point() + 
   facet_grid(am+cyl~., scales="free_y", space = "free_y") +
   scale_y_continuous(breaks = seq(0, 40, 2), expand = c(0, 1))
-------------------------------------------------------------------------------------------------------
K[] <- dfm <- expand.grid(x1=1:2,x2=1:2,y1=1:2,y2=1:2) 
K[] <- with(dfm, x1*y2 - sin(x2*y1 ) ) mtx<- data.matrix( expand.grid(x1=1:2,x2=1:2,y1=1:2,y2=1:2) )
K[mtx] <- apply(mtx, 1, function(x) x["x1"]*x["y2"] - sin(x['x2']*x['y1']) )
#----------------
> K
, , 1, 1

        [,1]       [,2]
[1,] 0.158529 0.09070257
[2,] 1.158529 1.09070257

, , 2, 1

          [,1]     [,2]
[1,] 0.09070257 1.756802
[2,] 1.09070257 2.756802

, , 1, 2

        [,1]     [,2]
[1,] 1.158529 1.090703
[2,] 3.158529 3.090703

, , 2, 2

        [,1]     [,2]
[1,] 1.090703 2.756802
[2,] 3.090703 4.756802
-------------------------------------------------------------------------------------------------------
data.frame cross.join <- function(a, b) {
    idx <- expand.grid(seq(length=nrow(a)), seq(length=nrow(b)))
    cbind(a[idx[,1],], b[idx[,2],])
} > tmp <- cross.join(mtcars, iris)
> dim(mtcars)
[1] 32 11
> dim(iris)
[1] 150   5
> dim(tmp)
[1] 4800   16
> str(tmp)
'data.frame':   4800 obs. of  16 variables:
 $ mpg         : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
 $ cyl         : num  6 6 4 6 8 6 8 4 4 6 ...
 $ disp        : num  160 160 108 258 360 ...
 $ hp          : num  110 110 93 110 175 105 245 62 95 123 ...
 $ drat        : num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
 $ wt          : num  2.62 2.88 2.32 3.21 3.44 ...
 $ qsec        : num  16.5 17 18.6 19.4 17 ...
 $ vs          : num  0 0 1 1 0 1 0 1 1 1 ...
 $ am          : num  1 1 1 0 0 0 0 0 0 0 ...
 $ gear        : num  4 4 4 3 3 3 3 4 4 4 ...
 $ carb        : num  4 4 1 1 2 1 4 2 2 4 ...
 $ Sepal.Length: num  5.1 5.1 5.1 5.1 5.1 5.1 5.1 5.1 5.1 5.1 ...
 $ Sepal.Width : num  3.5 3.5 3.5 3.5 3.5 3.5 3.5 3.5 3.5 3.5 ...
 $ Petal.Length: num  1.4 1.4 1.4 1.4 1.4 1.4 1.4 1.4 1.4 1.4 ...
 $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.2 0.2 0.2 0.2 0.2 ...
 $ Species     : Factor w/ 3 levels "setosa","versicolor",..: 1 1 1 1 1 1 1 1 1 1 ...
-------------------------------------------------------------------------------------------------------
a <- ggplot(subset(df, x != 2), aes(x = z, y = y, fill = z))
b <- a + geom_bar(stat = "identity", position = "dodge")
c <- b + facet_grid(. ~ x, scale = "free_y")
c
-------------------------------------------------------------------------------------------------------
subset ggplot plot_1 = ggplot(subset(df, x %in% c(1, 2)), aes(x=z, y=y, fill=z)) +
         geom_bar(stat = "identity", position = "dodge") +
         facet_grid(. ~ x, scale = "free_y")
-------------------------------------------------------------------------------------------------------
nested.fun <- function(l) {
  out <- ldply(l, data.frame)
  names(out)[1] <- 'inner.id'
  return(out)
}

one.df <- ldply(a, nested.fun)

ggplot(one.df, aes(x,y))+geom_point()+facet_grid(.id~inner.id)
-------------------------------------------------------------------------------------------------------
len data createGrid caret nprune degree createMARSGrid <- function(len, data) {
      g = createGrid("earth", len, data)
      g = expand.grid(.nprune=g$.nprune, .degree=seq(1,5))
      return(g)
  } train(formula, data=data, method='earth', tuneGrid = createMARSGrid)
-------------------------------------------------------------------------------------------------------
lubridate >dmy
function (..., quiet = FALSE, tz = "UTC") 
{
    dates <- unlist(list(...))
    parse_date(num_to_date(dates), make_format("dmy"), quiet = quiet, 
        tz = tz)
}
<environment: namespace:lubridate> parse_date num_to_date make_format > parse_date
function (x, formats, quiet = FALSE, seps = find_separator(x), 
    tz = "UTC") 
{
    fmt <- guess_format(head(x, 100), formats, seps, quiet)
    parsed <- as.POSIXct(strptime(x, fmt, tz = tz))
    if (length(x) > 2 & !quiet) 
        message("Using date format ", fmt, ".")
    failed <- sum(is.na(parsed)) - sum(is.na(x))
    if (failed > 0) {
        message(failed, " failed to parse.")
    }
    parsed
}
<environment: namespace:lubridate> > getAnywhere(num_to_date)
A single object matching ‘num_to_date’ was found
It was found in the following places
  namespace:lubridate
with value

function (x) 
{
    if (is.numeric(x)) {
        x <- as.character(x)
        x <- paste(ifelse(nchar(x)%%2 == 1, "0", ""), x, sep = "")
    }
    x
}
<environment: namespace:lubridate> > getAnywhere(make_format)
A single object matching ‘make_format’ was found
It was found in the following places
  namespace:lubridate
with value

function (order) 
{
    order <- strsplit(order, "")[[1]]
    formats <- list(d = "%d", m = c("%m", "%b"), y = c("%y", 
        "%Y"))[order]
    grid <- expand.grid(formats, KEEP.OUT.ATTRS = FALSE, stringsAsFactors = FALSE)
    lapply(1:nrow(grid), function(i) unname(unlist(grid[i, ])))
}
<environment: namespace:lubridate> strsplit-ting expand-ing.grid-s paste-ing ifelse-ing unname-ing as.POSIXct getAnywhere(as.POSIXct)  #tells us to use methods to see the business
methods('as.POSIXct')    #tells us all the business
as.POSIXct.date          #what I believe your code is using (I don't use dates though) as.POSICct
-------------------------------------------------------------------------------------------------------
panel d3 d3$panel = "a"

p <- ggplot(data = d, mapping = aes(x = x, y = y))
p <- p + facet_grid(panel ~ ., scale = "free")
p <- p + layer(data = d1,  geom = c( "line"), stat = "identity")
p <- p + layer(data = d3,  geom = c( "point"))
p <- p + layer(data = d2,  geom = "line", stat = "identity")
p facet_grid panel
-------------------------------------------------------------------------------------------------------
set.seed(1)
x <- matrix(rnorm(20), nrow=5, ncol=4)
y <- matrix(rnorm(15), nrow=5, ncol=3)
COR <- cor(x,y)
COR
image(x=seq(dim(x)[2]), y=seq(dim(y)[2]), z=COR, xlab="x column", ylab="y column")
text(expand.grid(x=seq(dim(x)[2]), y=seq(dim(y)[2])), labels=round(c(COR),2))
-------------------------------------------------------------------------------------------------------
facet_grid facet_grid opts(strip.text.y = theme_text()) \n .Label # load data
plotdat <- structure(list(level = c("Lost (N =328)", "Won (N =75)", "Lost (N =10)", 
                        "Won (N =65)", "Challenger (N =318)", "Incumbent (N =85)", "Arab (N =7)", 
                        "Black (N =222)", "East Asian (N =40)", "Latino (N =107)", "Other (N =10)", 
                        "South Asian (N =17)", "Not (N =252)", "Statewide (N =151)"), 
                mean = c(0.59834264517378, 0.645308353066667, 0.6382179387, 
                        0.646399186046154, 0.595756747751572, 0.649457274258823, 
                        0.682776774142857, 0.557334915725225, 0.6654738063, 0.68260777364486, 
                        0.6061308922, 0.613378378411765, 0.616298597519841, 0.591703758423841
                ), se = c(0.00597842210656315, 0.0113080614816089, 0.044927778673023, 
                        0.011274258338002, 0.00622316181664198, 0.00900474213888581, 
                        0.0247451786416615, 0.00690804451732034, 0.0116899960061005, 
                        0.00777478853477299, 0.0183766282892234, 0.0166464474073244, 
                        0.00669527297092827, 0.00887170639612841), N = c(328L, 75L, 
                        10L, 65L, 318L, 85L, 7L, 222L, 40L, 107L, 10L, 17L, 252L, 
                        151L), var = structure(c(1L, 1L, 2L, 2L, 3L, 3L, 4L, 4L, 
                                4L, 4L, 4L, 4L, 5L, 5L), .Label = c("Primary\nElection", "General\nElection", 
                                "Incumbency", "Race", "Statewide\nDistrict"), class = "factor")), .Names = c("level", 
                "mean", "se", "N", "var"), row.names = c(NA, 14L), class = "data.frame")
library('ggplot2')


# with facet_grid:
ggplot(plotdat, aes(x = mean, xmin = mean-se, xmax = mean+se, y = level)) + 
    geom_point() + geom_segment( aes(x = mean-se, xend = mean+se, 
                    y = level, yend=level)) +
    facet_grid(var~., scales = "free_y", space = "free_y") +
    theme_bw() + opts(axis.title.x = theme_text(size = 12, vjust = .25))+ 
    xlab("Mean V (Brightness) for Candidate's Face") + ylab("") +
    opts(title = expression("Skin Complexion for 2010 Minority Candidates"),
    strip.text.y = theme_text()) opts(panel.margin = unit(2, "line") grid library(grid)
    ggplot(plotdat, aes(x = mean, xmin = mean-se, xmax = mean+se, y = level)) + 
    geom_point() + geom_segment( aes(x = mean-se, xend = mean+se, 
                    y = level, yend=level)) +
    facet_grid(var~., scales = "free_y", space = "free_y") +
    theme_bw() + opts(axis.title.x = theme_text(size = 12, vjust = .25))+ 
    xlab("Mean V (Brightness) for Candidate's Face") + ylab("") +
    opts(title = expression("Skin Complexion for 2010 Minority Candidates"),
    strip.text.y = theme_text(),
    panel.margin = unit(2, "lines"))
-------------------------------------------------------------------------------------------------------
# convert to a data frame
dept_data <- as.data.frame(dept.table) # add proportions
library(plyr)
dept_data_prop <- ddply(dept_data, .(Var1), mutate, prop = Freq /sum(Freq))


library(ggplot2)
ggplot(dept_data_prop, aes(x= Var1, y = prop, colour = Var2, fill = Var2)) + 
  geom_bar() + 
  coord_flip() + 
  facet_wrap(~Var1, scales = 'free', ncol = 1) + 
  opts(strip.background =theme_blank(), strip.text.x = theme_blank(), 
       strip.text.y = theme_text(), axis.ticks = theme_blank(), 
       axis.title.x = theme_blank(), axis.text.x = theme_blank()) + xlab('') + 
  scale_fill_brewer('Student',  type = 'div', palette = 5) + 
  scale_colour_brewer('Student', type = 'div', palette = 5) + 
  scale_x_discrete(expand = c(0,0)) + 
  scale_y_continuous(expand=c(0,0)) ?opts dept_data <- as.data.frame(dept.table)
names(dept_data) <- c('department', 'student', 'count')



dept_prop <- ddply(dept_data, .(department), mutate, 
               prop_department = count / sum(count),
               max_department = cumsum(prop_department),
               min_department = max_department - prop_department,
               total_department = sum(count))


dept_prop <- mutate(dept_prop, prop_total = total_department / sum(count))

dept_prop <- ddply(dept_prop, .(student), mutate, 
   max_total = cumsum(prop_total), 
   min_total = max_total - prop_total)



ggplot(dept_prop, aes(xmin = min_department, xmax = max_department, 
                      ymin = min_total, ymax = max_total)) +
 geom_rect(aes(colour = student, fill =student)) + 
 facet_grid(department~., scales = 'free', space = 'free') +
 opts(strip.background =theme_blank(), 
   strip.text.y = theme_text(hjust = 0.05), axis.ticks = theme_blank(), 
   axis.title.x = theme_blank(), axis.text.x = theme_blank(), 
   axis.title.y = theme_blank(), axis.text.y = theme_blank(), 
   legend.position = 'bottom', legend.justification = 'left',
   panel.border = theme_blank(), panel.background = theme_blank(), 
   panel.grid.major = theme_blank(), panel.grid.minor = theme_blank()) +
   xlab('') + 
 scale_fill_brewer('Student',  palette = 'Set1') + 
 scale_colour_brewer('Student', palette = 'Set1') + 
 scale_x_continuous(expand = c(0, 0)) + 
 scale_y_continuous(expand = c(0, 0))
-------------------------------------------------------------------------------------------------------
library(reshape)
df = expand.grid(names(dt),names(dt))
df$val=apply(df,1,function(x) mean(dt[x[1]]==dt[x[2]]))
cast(df,Var2~Var1)
-------------------------------------------------------------------------------------------------------
gp<-ggplot(g,aes(x=Date,y=value,group=variable)) +
    opts(
        panel.background = theme_rect(size = 1, colour = "lightgray"),
        panel.grid.minor = theme_blank(),
        strip.background = theme_blank(),
        axis.title.x = theme_blank(),
        axis.title.y = theme_blank()
        ,strip.text.y = theme_text(size = 12,angle = 0)
    )
gp<- gp + geom_line(size=1)
gp <-gp + facet_grid(variable ~ var2, scales="free")
gp<-gp+geom_smooth(data=g[g$var2=="History",],
                   method=loess,size=1,span=.35,alpha=.005)
gp
-------------------------------------------------------------------------------------------------------
library("lubridate")
library("ggplot2")
library("reshape2")

dates <- c("2011-01-01","2011-01-04","2011-01-05",
           "2011-01-06","2011-01-07","2011-01-08",
           "2011-01-11","2011-01-12")
dates <- ymd(dates)

Actual<- c(    1132,    1184,    1177,     950,    1066,    1098,    1116,    1211,
               1132,    1184,    1177,     950,    1066,    1098,    1116,    1211,
               1132,    1184,    1177,     950,    1066,    1098,    1116,    1211)
z     <- c(       1,       1,       1,       1,       1,       1,       1,       1,
                  2,       2,       2,       2,       2,       2,       2,       2,
                  3,       3,       3,       3,       3,       3,       3,       3)
Tops <- c(    1156,    1250,    1156,    1187,    1187,    1187,    1156,    1156,
              1125,    1125,    1125,    1125,    1125,    1250,    1062,    1250,
              1250,    1250,    1250,    1250,    1250,    1250,    1250,    1250)
Mids <- c(    1125,    1187,    1125,    1156,    1156,    1156,    1140,    1140,
              1062,    1062,    1062,    1062,    1062,    1125,    1000,    1125,
              1187,    1187,    1187,    1187,    1187,    1187,    1187,    1187)
Lows <- c(    1093,    1125,    1093,    1125,    1125,    1125,    1125,    1125,
              1000,    1000,    1000,    1000,    1000,    1000,     937,    1000,
              1125,    1125,    1000,    1125,    1125,    1093,    1093,    1000)

df <- data.frame( cbind(z, dates, Actual, Tops, Mids, Lows))

dfm <- melt(df, id.vars=c("z", "dates", "Actual")) p <- ggplot(data = dfm,
            aes(x = dates,
                y = value,
                group = variable,
                colour = variable)
            ) + geom_line(size = 3) +
                facet_grid(variable ~ z) +
                geom_point(aes(x = dates,
                               y = Actual),
                           colour = "steelblue",
                           size = 3) +
                               geom_line(aes(x = dates,
                                             y = Actual),
                                         colour = "steelblue",
                                         size = 1) +
                                             theme_bw()
p p <- ggplot(data = dfm,
            aes(x = Actual,
                y = value,
                group = variable,
                colour = variable)
            ) + geom_point(size = 3) +
                geom_smooth() +
                facet_grid(variable ~ z) +
                theme_bw()
p
-------------------------------------------------------------------------------------------------------
require(ggplot2)

# scales goes with ggplot and adds the needed scale* functions
require(scales)

# need the month() function for the extra plot
require(lubridate)

# original data
#df<-read.csv("http://pastebin.com/download.php?i=sDzXKFxJ", header=TRUE)

# simulated data
years=sample(seq(2008,2012),681,replace=TRUE,prob=c(0.0176211453744493,0.302496328928047,0.323054331864905,0.237885462555066,0.118942731277533))
months=sample(seq(1,12),681,replace=TRUE)
my.dates=as.Date(paste(years,months,01,sep="-"))
df=data.frame(YM=strftime(my.dates, format="%Y-%b"),Date=my.dates,Year=years,Month=months)
# end simulated data creation

# sort the list just to make it pretty. It makes no difference in the final results
df=df[do.call(order, df[c("Date")]), ]

# add a dummy column for clarity in processing
df$Count=1

# compute the frequencies ourselves
freqs=aggregate(Count ~ Year + Month, data=df, FUN=length)

# rebuild the Date column so that ggplot works
freqs$Date=as.Date(paste(freqs$Year,freqs$Month,"01",sep="-"))

# I set the breaks for 2 months to reduce clutter
g<-ggplot(data=freqs,aes(x=Date,y=Count))+ geom_bar(stat="identity") + scale_x_date(labels=date_format("%Y-%b"),breaks="2 months") + theme_bw() + opts(axis.text.x = theme_text(angle=90))
print(g)

# don't overwrite the previous graph
dev.new()

# just for grins, here is a faceted view by year
# Add the Month.name factor to have things work. month() keeps the factor levels in order
freqs$Month.name=month(freqs$Date,label=TRUE, abbr=TRUE)
g2<-ggplot(data=freqs,aes(x=Month.name,y=Count))+ geom_bar(stat="identity") + facet_grid(Year~.) + theme_bw()
print(g2)
-------------------------------------------------------------------------------------------------------
library(akima) 
library(ggplot2) 

x = rnorm(20)
y = rnorm(20)
z = rnorm(20)

t. = interp(x,y,z)
t.df <- data.frame(t.)

gt <- data.frame( expand.grid(X1=t.$x, X2=t.$y), 
                  z=c(t.$z), 
                  value=cut(c(t.$z), 
                            breaks=seq(-1,1,0.25)))

p <- ggplot(gt) + 
    geom_tile(aes(X1,X2,fill=value)) + 
    geom_contour(aes(x=X1,y=X2,z=z), colour="black") + 
    coord_polar()
p <- p + scale_fill_brewer()
p ggplot2
-------------------------------------------------------------------------------------------------------
scale() fields library(akima) 
library(fields) 

x <- rnorm(20, 4, 3)
y <- rnorm(20, 5e-5, 1e-5)
x <- scale(x) # comment out these two lines 
y <- scale(y) # to reproduce your error
z <- rnorm(20)

s <- interp(x,y,z)
image.plot(s) ggplot2 library(akima) 
library(ggplot2) 

x <- rnorm(20, 4, 3)
y <- rnorm(20, 5e-5, 1e-5)
x <- scale(x) # comment out these two lines 
y <- scale(y) # to reproduce your error
z <- rnorm(20)

t. <- interp(x,y,z)
t.df <- data.frame(t.)

gt <- data.frame( expand.grid(X1=t.$x, X2=t.$y), 
                  z=c(t.$z), 
                  value=cut(c(t.$z), 
                            breaks=seq(min(z),max(z),0.25)))

p <- ggplot(gt) + 
    geom_tile(aes(X1,X2,fill=value)) + 
    geom_contour(aes(x=X1,y=X2,z=z), colour="black") 
p ggplot
-------------------------------------------------------------------------------------------------------
library("akima")
library("ggplot2")

x.orig <- rnorm(20, 4, 3)
y.orig <- rnorm(20, 5e-5, 1e-5)
x <- scale(x.orig)  
y <- scale(y.orig) 
z <- rnorm(20)

t. <- interp(x,y,z)
t.df <- data.frame(t.)

gt <- data.frame( expand.grid(x=t.$x, y=t.$y), 
                  z=c(t.$z), 
                  value=cut(c(t.$z), 
                            breaks=seq(min(z),max(z),0.25)))

p <- ggplot(gt) + geom_tile(aes(x,y,fill=value)) + 
    geom_contour(aes(x=x,y=y,z=z), colour="black") 

get.labels <- function(break.points, orig.data, scaled.data, digits) { 
    labels <- as.character(lapply(break.points,      
            function(i) round(i * min(orig.data) 
                              / min(scaled.data),
                              digits)
                                  )
                           )
    labels
}

x.break.points <- seq(min(x), max(x), 0.5)
x.labels <- get.labels(x.break.points, x.orig, x, digits=2)
p <- p + scale_x_continuous(breaks=x.break.points, 
                            labels=x.labels)

y.break.points <- seq(min(y), max(y), 0.5)
y.labels <- get.labels(y.break.points, y.orig, y, digits=8)
p <- p + scale_y_continuous(breaks=y.break.points, 
                            labels=y.labels)

p
-------------------------------------------------------------------------------------------------------
expand.grid v1 <- 1:2
v2 <- 3:4
expand.grid(v1, v2)
#  Var1 Var2
#1    1    3
#2    2    3
#3    1    4
#4    2    4 df1 <- data.frame(a = 1:2, b=3:4)
df2 <- data.frame(cat = 5:6, dog = c("a","b"))

expand.grid(df1, df2) # doesn't work so let's try something else
id <- expand.grid(seq(nrow(df1)), seq(nrow(df2)))
out <-cbind(df1[id[,1],], df2[id[,2],])
out
#    a b cat dog
#1   1 3   5   a
#2   2 4   5   a
#1.1 1 3   6   b
#2.1 2 4   6   b merge df1 <- data.frame(a = 1:2, b=3:4)
df2 <- data.frame(cat = 5:6, dog = c("a","b"))
merge(df1, df2)
#  a b cat dog
#1 1 3   5   a
#2 2 4   5   a
#3 1 3   6   b
#4 2 4   6   b

-------------------------------------------------------------------------------------------------------
b$grp <- with(b,(f == "a") & (c == 1)) size linetype library(scales)
ggplot(b,aes(x=x,y=y)) + 
    geom_line(aes(color=c,group=c,size = grp,linetype = grp)) + 
    facet_grid(f ~ .) + 
    scale_size_manual(values = c(0.5,1.2),guide = "none") + 
    scale_linetype_manual(values = c('solid','dashed'),guide = "none")
-------------------------------------------------------------------------------------------------------
fill = NA na.value NA .data <- cbind( 
           expand.grid(x = 1:10, y = 1:10), z = runif(100))[sample(1:100,75), ]



ggplot(.data, aes(x = x, y = y)) + theme_bw() + 
   geom_tile(fill = NA, color = 'black', na.value = NA)
-------------------------------------------------------------------------------------------------------
outer() expand.grid(x,y)[outer(x,y, FUN=function(x,y) abs(x-y) < 0.01), ]
#   Var1 Var2
#2     2    2
#16    6    6
-------------------------------------------------------------------------------------------------------
dat <- data.frame(f1 = factor(c(1,2,2)), f2 = factor(c("A","A","B")),
                  v1 = c(23,45,27)) expand.grid() dat2 <- with(dat, expand.
grid(f1 = levels(f1), f2 = levels(f2))) merge() all.y = TRUE newdat <- merge(dat, dat2, all.y = TRUE) > newdat
  f1 f2 v1
1  1  A 23
2  1  B NA
3  2  A 45
4  2  B 27 NA NA 0 > newdat$v1[is.na(newdat$v1)] <- 0
> newdat
  f1 f2 v1
1  1  A 23
2  1  B  0
3  2  A 45
4  2  B 27
-------------------------------------------------------------------------------------------------------
bcd  <- rev(expand.grid(list(d=d,c=c,b=b)))
abcd <- data.frame(a = a[match(bcd$b, b)], bcd) length(b)*length(c)*length(d) abcd <- rbind(abcd, abcd)
-------------------------------------------------------------------------------------------------------
a <- c("a","b","c")
b <- c("A","B","C")
c <- c(1,2,3)
d <- c(11,22)
nrow_cd <- length(c)*length(d)

ab <- sapply(list(a,b), rep, each=nrow_cd)
cd <- expand.grid(c,d)
out <- cbind(ab, cd[rep(rownames(cd),length=nrow(ab)),])
rownames(out) <- 1:nrow(out)
names(out ) <- letters[1:4]
out
-------------------------------------------------------------------------------------------------------
arr <- array(seq_len(3*3*3), dim = rep(3,3,3)) dims <- dim(arr)
ind <- expand.grid(lapply(dims, seq_len))
arr[] <- rowSums(ind) > arr
, , 1

     [,1] [,2] [,3]
[1,]    3    4    5
[2,]    4    5    6
[3,]    5    6    7

, , 2

     [,1] [,2] [,3]
[1,]    4    5    6
[2,]    5    6    7
[3,]    6    7    8

, , 3

     [,1] [,2] [,3]
[1,]    5    6    7
[2,]    6    7    8
[3,]    7    8    9

> arr[1,1,1]
[1] 3
> arr[1,2,3]
[1] 6
> arr[3,3,3]
[1] 9 arr <- array(seq_len(3*3*3), dim = rep(3,3,3)) arr i + j + k k > 2 j*k-i dims <- dim(arr)
ind <- expand.grid(lapply(dims, seq_len))
## which k > 2
want <- ind[,3] > 2
arr[!want] <- rowSums(ind[!want, ])
arr[want] <- ind[want, 2] * ind[want, 3] - ind[want, 1] > x <- array(rep(1, 365*5*4), dim=c(365, 5, 4))
> system.time({
+ for (i in seq_len(dim(x)[1])) {
+     for (j in seq_len(dim(x)[2])) {
+         for (k in seq_len(dim(x)[3])) {
+             val = i+j+k
+             if (k > 2) {
+                 val = j*k-i
+             }
+             x[i,j,k] = val
+         }
+     }
+ }
+ })
   user  system elapsed 
  0.043   0.000   0.044 
> arr <- array(rep(1, 365*5*4), dim=c(365, 5, 4))
> system.time({
+ dims <- dim(arr)
+ ind <- expand.grid(lapply(dims, seq_len))
+ ## which k > 2
+ want <- ind[,3] > 2
+ arr[!want] <- rowSums(ind[!want, ])
+ arr[want] <- ind[want, 2] * ind[want, 3] - ind[want, 1]
+ })
   user  system elapsed 
  0.005   0.000   0.006 > x <- array(rep(1, 200*200*200), dim=c(200, 200, 200))
> system.time({
+ for (i in seq_len(dim(x)[1])) {
+     for (j in seq_len(dim(x)[2])) {
+         for (k in seq_len(dim(x)[3])) {
+             val = i+j+k
+             if (k > 2) {
+                 val = j*k-i
+             }
+             x[i,j,k] = val
+         }
+     }
+ }
+ })
   user  system elapsed 
 51.759   0.129  53.090
> arr <- array(rep(1, 200*200*200), dim=c(200, 200, 200))
> system.time({
+     dims <- dim(arr)
+     ind <- expand.grid(lapply(dims, seq_len))
+     ## which k > 2
+     want <- ind[,3] > 2
+     arr[!want] <- rowSums(ind[!want, ])
+     arr[want] <- ind[want, 2] * ind[want, 3] - ind[want, 1]
+ })
   user  system elapsed 
  2.282   1.036   3.397
-------------------------------------------------------------------------------------------------------
for x[i,j,k] i+j+k k>2 j*k-i if val x[i,j,k] x[i,j,k] val x = array(rep(1, 365*5*4), dim=c(365, 5, 4))

for (i in seq_len(dim(x)[1])) {
    for (j in seq_len(dim(x)[2])) {
        for (k in seq_len(dim(x)[3])) {
            val = i+j+k
            if (k > 2) {
                val = j*k-i
            }
            x[i,j,k] = val
        }
    }
} comb = expand.grid(seq_len(365), seq_len(5), seq_len(4))
i = comb$Var1; j = comb$Var2; k = comb$Var3
val = i+j+k
subs = which(k>2); val[subs] = (j*k-i)[subs]
x = array(val, dim = c(365, 5, 4)) i j k val i+j+k k>2 val j*k-i val x x[i,j,k] val
-------------------------------------------------------------------------------------------------------
ggplot(plotobj, aes(as.factor(gm) , peaks, fill=rvalue)) +
    geom_bar(stat="identity") + facet_grid(rvalue ~ .,scales="free") + 
    opts(legend.position = "none") + scale_y_log10()
ggplot(plotobj, aes(as.factor(gm) , peaks, fill=rvalue)) +
    geom_bar(stat="identity") + facet_grid(rvalue ~ .,scales="free") + 
    opts(legend.position = "none") + scale_y_sqrt()
ggplot(plotobj, aes(as.factor(gm) , peaks, fill=rvalue)) +
    geom_bar(stat="identity") + facet_grid(rvalue ~ .,scales="free") + 
    opts(legend.position = "none") + coord_trans(y = "log10")
ggplot(plotobj, aes(as.factor(gm) , peaks, fill=rvalue)) +
    geom_bar(stat="identity") + facet_grid(rvalue ~ .,scales="free") + 
    opts(legend.position = "none") + coord_trans(y = "sqrt")
-------------------------------------------------------------------------------------------------------
data.frame mtcars$cyl_factor <- factor(mtcars$cyl, labels=c('Four', 'Six', 'Eight'))

ggplot(mtcars, aes(mpg, wt, colour = cyl_factor)) + 
  geom_point() +
  facet_grid(. ~ cyl, scales = "free")
-------------------------------------------------------------------------------------------------------
NA dat <- data.frame(a=rep(LETTERS[1:3],3),
                  b=rep(letters[1:3],each=3),
                  v=1:9)[-2,]

ggplot(dat, aes(x=a, y=v, colour=b)) +
  geom_bar(aes(fill=b), stat="identity", position="dodge") dat a b dat.all <- rbind(dat, cbind(expand.grid(a=levels(dat$a), b=levels(dat$b)), v=NA))

ggplot(dat.all, aes(x=a, y=v, colour=b)) +
  geom_bar(aes(fill=b), stat="identity", position="dodge")
-------------------------------------------------------------------------------------------------------
dum.match<-rbind(expand.grid(c(mydf[1,2:3]),c(mydf[2,2:3])),expand.grid(c(mydf[2,2:3]),c(mydf[1,2:3])))
newmydf<-cbind(mydf,paste(mydf$A,mydf$B)%in%paste(dum.match$Var1,dum.match$Var2))

> newmydf
  name A B paste(mydf$A, mydf$B) %in% paste(dum.match$Var1, dum.match$Var2)
1   P1 1 2                                                            FALSE
2   P2 3 4                                                            FALSE
3 IndA 1 3                                                             TRUE
4 IndB 2 4                                                             TRUE
5 IndC 2 2                                                            FALSE
6 IndD 5 2                                                            FALSE
7 IndE 5 6                                                            FALSE
8 IndF 1 2                                                            FALSE
9 IndG 4 2                                                             TRUE

dum.match2<-rbind(expand.grid(c(mydf2[1,2:3]),c(mydf2[2,2:3])),expand.grid(c(mydf2[2,2:3]),c(mydf2[1,2:3])))
newmydf2<-cbind(mydf2,paste(mydf2$A,mydf2$B)%in%paste(dum.match2$Var1,dum.match2$Var2))

> newmydf2
  name A B paste(mydf2$A, mydf2$B) %in% paste(dum.match2$Var1, dum.match2$Var2)
1   P1 1 1                                                                FALSE
2   P2 3 4                                                                FALSE
3 IndH 3 3                                                                FALSE
4 IndI 1 1                                                                FALSE
5 IndJ 4 1                                                                 TRUE
6 IndK 3 5                                                                FALSE
>
-------------------------------------------------------------------------------------------------------
plyr **ply ddply mydf$B x$B err.chk <- function (x) {
  dum.match <- rbind(expand.grid(c(x[1, 2:3]), c(x[2, 2:3])),
                     expand.grid(c(x[2, 2:3]), c(x[1, 2:3])))
  newmydf <- cbind(x, correct = paste(x$A, x$B) %in% paste(dum.match$Var1, dum.match$Var2))

  return (newmydf)
} ddply > ddply(mydf, .(family), err.chk)
   family name A B correct
1       1   P1 1 2   FALSE
2       1   P2 3 4   FALSE
3       1 IndA 1 3    TRUE
4       1 IndB 2 4    TRUE
5       1 IndC 2 2   FALSE
6       1 IndD 5 2   FALSE
7       1 IndE 5 6   FALSE
8       1 IndF 1 2   FALSE
9       1 IndG 4 2    TRUE
10      2   P1 1 1   FALSE
11      2   P2 3 4   FALSE
12      2 IndH 3 3   FALSE
13      2 IndI 1 1   FALSE
14      2 IndJ 4 1    TRUE
15      2 IndK 3 5   FALSE
16      3   P1 1 2    TRUE
17      3   P2 1 2    TRUE
18      3 IndL 3 1   FALSE
19      3 IndM 2 2    TRUE
20      3 IndN 1 1    TRUE
-------------------------------------------------------------------------------------------------------
data.table library(data.table)

dt <- data.table(df, key=c("x", "y"))
dt[, .N, by=key(dt)]
#                       x y  N
#  1: 2012-06-14 18:10:22 1  8
#  2: 2012-06-14 18:10:22 2 10
#  3: 2012-06-14 18:10:22 3  8
#  4: 2012-06-14 18:10:22 4  8
#  5: 2012-06-14 19:10:22 1  6
#  6: 2012-06-14 19:10:22 2  8
#  7: 2012-06-14 19:10:22 3  6
#  8: 2012-06-14 19:10:22 4  6
#  9: 2012-06-14 20:10:22 1 15
# 10: 2012-06-14 20:10:22 2  5
# 11: 2012-06-14 20:10:22 3 12
# 12: 2012-06-14 20:10:22 4  8

str(dt[, .N, by=key(dt)])
# Classes ‘data.table’ and 'data.frame':  12 obs. of  3 variables:
#  $ x: POSIXct, format: "2012-06-14 18:10:22" "2012-06-14 18:10:22" ...
#  $ y: int  1 2 3 4 1 2 3 4 1 2 ...
#  $ N: int  8 10 8 8 6 8 6 6 15 5 ... dt<-dt[1:30,]  # Make subset of dt in which some factor combinations don't appear

ii <- do.call("CJ", lapply(dt, unique))  # CJ() is similar to expand.grid()
dt[ii, .N]
#                      x y N
# 1: 2012-06-14 22:53:05 1 8
# 2: 2012-06-14 22:53:05 2 7
# 3: 2012-06-14 22:53:05 3 9
# 4: 2012-06-14 22:53:05 4 5
# 5: 2012-06-14 23:53:05 1 1
# 6: 2012-06-14 23:53:05 2 0
# 7: 2012-06-14 23:53:05 3 0
# 8: 2012-06-14 23:53:05 4 0
-------------------------------------------------------------------------------------------------------
expand.grid X <- matrix(sample(1:5, 50, replace=TRUE), nrow=10)

row.ind <- expand.grid(1:dim(X)[1], 1:dim(X)[2]) apply myfun <- function(n) {
  sum((X[row.ind[n, 1],] - X[row.ind[n, 2],])^2)
}

Y <- matrix(unlist(lapply(1:nrow(row.ind), myfun)), byrow=TRUE, nrow=nrow(X))


> Y
      [,1] [,2] [,3] [,4] [,5]
 [1,]    0   28   15   31   41
 [2,]   31   28   33   30   33
 [3,]   28    0   15    7   19
 [4,]   33   30   19   34   11
 [5,]   15   15    0   12   22
 [6,]   10   19   10   21   20
 [7,]   31    7   12    0    4
 [8,]   16   17   16   13    2
 [9,]   41   19   22    4    0
[10,]   14   11   28    9    2
>
-------------------------------------------------------------------------------------------------------
f Y = pdist(X).^2; [N, M] = size(X);
f = @(u, v) sum((u-v).^2);
helpf = @(i, j) f(X(i, :), X(j, :))
Y = arrayfun(helpf, meshgrid(1:N, 1:N), meshgrid(1:N, 1:N)'); sum(...) f f
-------------------------------------------------------------------------------------------------------
trees <- function(l) {
    if (length(l) <= 1)
        return(l)
    if (length(l) <= 2)
        return(list(l))

    unlist(lapply(2:(length(l)), function(i) {
        left.trees <- trees(l[1:(i-1)])
        right.trees <- trees(l[i:length(l)])
        apply(expand.grid(1:length(left.trees), 1:length(right.trees)), 1, function(idx) {
            list(left.trees[[idx[1]]], right.trees[[idx[2]]])
        })
    }), recursive=FALSE)
} > dput(trees(as.list(1:4)))
list(list(1L, list(2L, list(3L, 4L))), list(1L, list(list(2L, 
    3L), 4L)), list(list(1L, 2L), list(3L, 4L)), list(list(1L, 
    list(2L, 3L)), 4L), list(list(list(1L, 2L), 3L), 4L))
-------------------------------------------------------------------------------------------------------
plot(...)
lines(...)
grid(...)
legend(...) # legend has to be the last command!
-------------------------------------------------------------------------------------------------------
myfun <- function(i, j) {
  exp(-sqrt((i-64)^2 + (j-64)^2) / 20)
} i, j n <- 128
combos <- expand.grid(i=1:n, j=1:n) matrix(myfun(combos$i, combos$j), nrow=n) > n <- 5
> combos <- expand.grid(i=1:n, j=1:n)
> matrix(myfun(combos$i, combos$j), nrow=n)
           [,1]       [,2]       [,3]       [,4]       [,5]
[1,] 0.01162296 0.01203954 0.01246747 0.01290681 0.01335761
[2,] 0.01203954 0.01247458 0.01292166 0.01338085 0.01385221
[3,] 0.01246747 0.01292166 0.01338860 0.01386840 0.01436113
[4,] 0.01290681 0.01338085 0.01386840 0.01436960 0.01488451
[5,] 0.01335761 0.01385221 0.01436113 0.01488451 0.01542247
>
-------------------------------------------------------------------------------------------------------
facet_grid g4 library(ggplot2)

dat = data.frame(Var=c("a","a","a","a","b","b","b","b"),
                Val=c(0.5,0.4,0.1,0.0,-0.1,-0.3,-0.0,0.1),
                g1=c(1,2,3,4,5,6,7,8),
                g2=c(1,2,3,4,1,2,3,4),
                g3=c(1,2,1,2,1,2,1,2))

dat$g4 = c(1, 1, 2, 2, 1, 1, 2, 2) # New grouping factor

fill_values   = c("#00000090","#00000090","#00000050","#00000050")
colour_values = c("#000000","#00000070","#000000","#00000070")

#---------------------------------------------------------------------------
fig1 = ggplot(dat, aes(x=Var, y=Val, ymin=Val - 0.15, ymax=Val + 0.15, 
              colour=factor(g2), fill=factor(g2), linetype=factor(g3))) +
    geom_crossbar(width=0.5, fatten=2, size=0.5,
                  position=position_dodge(width=0.51)) +
    coord_flip() + 
    theme_bw() +
    scale_fill_manual(values=fill_values) +
    scale_colour_manual(values=colour_values) +
    opts(title="Figure 1: Original Version")

png("fig1.png", height=600, width=600)
print(fig1)
dev.off()

#---------------------------------------------------------------------------
fig2 = ggplot(dat, aes(x=factor(g4), y=Val, ymin=Val - 0.15,ymax=Val + 0.15, 
              colour=factor(g2), fill=factor(g2), linetype=factor(g3))) +
    geom_crossbar(width=0.7, fatten=2, size=0.5,
                  position=position_dodge()) +
    coord_flip() + 
    theme_bw() +
    scale_fill_manual(values=fill_values) +
    scale_colour_manual(values=colour_values) +
    facet_grid(Var ~ .) +
    opts(title="Figure 2: Proposed Solution")

png("fig2.png", height=600, width=600)
print(fig2)
dev.off()
-------------------------------------------------------------------------------------------------------
ftable y <- ftable(x)
y
#
#                    Measure1 Measure2 Measure3
# Subject Cond Item                            
# s1      A    1       -0.930   -0.360   -0.005
#              2       -0.010   -0.190   -0.050
#         B    1       -0.690    0.070    0.170
#              2       -0.070   -0.150    0.060
# s2      A    1        0.390    1.043    1.090
#              2        0.790   -1.390    0.110
#         B    1        1.020    0.670    0.680
#              2       -0.630   -0.080    0.270
# s3      A    1        0.880    0.330    0.360
#              2        0.320    0.980    0.990
#         B    1        0.290    0.480    0.510
#              2        0.260    0.740    0.740
# s4      A    1        0.630   -0.120    0.040
#              2        0.140    0.430    0.620
#         B    1        0.940    0.002    0.090
#              2        0.070    0.960    0.960
# s5      A    1        0.860   -0.055    0.090
#              2        0.130   -0.020    0.130
#         B    1        0.930    0.008    0.120
#              2        0.870    0.440    0.450 data.frame as.data.frame.matrix ftable row.vars col.vars attributes(y)$row.vars
# $Subject
# [1] "s1" "s2" "s3" "s4" "s5"
# 
# $Cond
# [1] "A" "B"
# 
# $Item
# [1] "1" "2"

attributes(y)$col.vars
# [[1]]
# [1] "Measure1" "Measure2" "Measure3" ftable data.frame ftable2df <- function(mydata) {
  ifelse(class(mydata) == "ftable", 
         mydata <- mydata, mydata <- ftable(mydata))
  dfrows <- rev(expand.grid(rev(attr(mydata, "row.vars"))))
  dfcols <- as.data.frame.matrix(mydata)
  names(dfcols) <- do.call(
    paste, c(rev(expand.grid(rev(attr(mydata, "col.vars")))), sep = "_"))
  cbind(dfrows, dfcols)
} ftable2df(x)
#    Subject Cond Item Measure1 Measure2 Measure3
# 1       s1    A    1    -0.93   -0.360   -0.005
# 2       s1    A    2    -0.01   -0.190   -0.050
# 3       s1    B    1    -0.69    0.070    0.170
# 4       s1    B    2    -0.07   -0.150    0.060
# 5       s2    A    1     0.39    1.043    1.090
# 6       s2    A    2     0.79   -1.390    0.110
# 7       s2    B    1     1.02    0.670    0.680
# 8       s2    B    2    -0.63   -0.080    0.270
# 9       s3    A    1     0.88    0.330    0.360
# 10      s3    A    2     0.32    0.980    0.990
# 11      s3    B    1     0.29    0.480    0.510
# 12      s3    B    2     0.26    0.740    0.740
# 13      s4    A    1     0.63   -0.120    0.040
# 14      s4    A    2     0.14    0.430    0.620
# 15      s4    B    1     0.94    0.002    0.090
# 16      s4    B    2     0.07    0.960    0.960
# 17      s5    A    1     0.86   -0.055    0.090
# 18      s5    A    2     0.13   -0.020    0.130
# 19      s5    B    1     0.93    0.008    0.120
# 20      s5    B    2     0.87    0.440    0.450
-------------------------------------------------------------------------------------------------------
prepanel.default.xyplot() prepanel.null() limits.and.aspect() limitsFromLimitList() ## Create a supplementary data frame with one data point for each factor level
dummy <- with(df2, expand.grid(cat1=levels(cat1), cat2=levels(cat2)))
dummy <- data.frame(x=1, y=1e6, dummy)

## Append it to your data frame
df2 <- rbind(df2, dummy)

## Now try plotting it
myFun(df2)
-------------------------------------------------------------------------------------------------------
glmmADMB mcmc MCMCglmm glmmADMB MCMCglmm nschool <- 20
nrep <- 20
dt1 <- expand.grid(school=LETTERS[1:nschool],rep=seq(nrep))
set.seed(101)
u.school <- rnorm(nrep)
dt1$eta <- u.school[dt1$school]
dt1$bull <- rbinom(nrow(dt1),size=1,prob=plogis(dt1$eta))

library(MCMCglmm)
fit.mc1 <-MCMCglmm(bull~1,random=~school,data=dt1,family="categorical",
                   prior=list(R=list(V=1, fix=1), G=list(G1=list(V=1, nu=0))),
                   slice=TRUE)

library(lme4)
fit.glmer <- glmer(bull~(1|school),data=dt1,family=binomial)

library(glmmADMB)
fit.mc12 <- glmmadmb(bull~1+(1|school), data=dt1, family="binomial", 
                     mcmc=TRUE, mcmc.opts=mcmcControl(mcmc=50000))
-------------------------------------------------------------------------------------------------------
test <- matrix(1:9,nrow=3)
rownames(test) <- letters[1:3]
colnames(test) <- letters[4:6]

> test
  d e f
a 1 4 7
b 2 5 8
c 3 6 9 data.frame data.frame(
           rownames=as.vector(row(test,as.factor=TRUE)),
           colnames=as.vector(col(test,as.factor=TRUE)),
           values=as.vector(test)
          ) expand.grid data.frame(
        expand.grid(rownames=rownames(test),colnames=colnames(test)),
        values=as.vector(test)
          ) as.data.frame.table setNames setNames(as.data.frame.table(test),c("rownames","colnames","values")) rownames colnames values
1        a        d      1
2        b        d      2
3        c        d      3
4        a        e      4
5        b        e      5
6        c        e      6
7        a        f      7
8        b        f      8
9        c        f      9
-------------------------------------------------------------------------------------------------------
makecheck2 paste makecheck2 paste match N <- 5
I <- rep(10,N)
S <- as.matrix(expand.grid( lapply(1:N, function(i) { 0:I[i]}) ) )
system.time(f1 <- makecheck1(S))
#   user  system elapsed 
#  1.547   0.000   1.552 
system.time(f2 <- makecheck2(S))
#   user  system elapsed 
#  0.063   0.000   0.065 paste > set.seed(5)
> k <- lapply(0:4, function(idx) sample(1:nrow(S), 10^idx))
> s <- lapply(k, function(idx) S[idx,])
> t1 <- sapply(s, function(x) unname(system.time(for(i in 1:100) f1(x))[1]))
> t2 <- sapply(s, function(x) unname(system.time(for(i in 1:100) f2(x))[1]))
> data.frame(n=10^(0:4), time1=t1, time2=t2)
      n time1 time2
1     1 0.761 1.512
2    10 0.772 1.523
3   100 0.857 1.552
4  1000 1.592 1.547
5 10000 9.651 1.848 makecheck2 <- function(m) {
  codes <- vector("list", length=ncol(m))
  top <- vector("integer", length=ncol(m)+1)
  top[1L] <- 1L
  for(idx in 1:ncol(m)) {
    codes[[idx]] <- unique(m[,idx])
    top[idx+1L] <- top[idx]*length(codes[[idx]])
  }
  getcode <- function(x) {
    out <- 0L
    for(idx in 1:length(codes)) {
      out <- out + top[idx]*match(x[,idx], codes[[idx]])
    }
    out
  }
  key <- getcode(m)
  f <- function(x) {
    if(!is.matrix(x)) {
      x <- matrix(x, ncol=length(codes))
    }
    match(getcode(x), key)
  }
  rm(m) # perhaps there's a better way to remove these from the closure???
  rm(idx)
  f
}

makecheck1 <- function(m) {
  n <- ncol(m)
  statecodes <- apply(m,1,function(x) paste(x,collapse=" ") )
  rm(m)
  function(x) {
    if(!is.matrix(x)) {
      x <- matrix(x, ncol=n)
    }
    x <- apply(x, 1, paste, collapse=" ")
    match(x, statecodes)
  }
}
-------------------------------------------------------------------------------------------------------
facet_grid() library(ggplot2)
data(mtcars)

p <- ggplot(mtcars, aes(factor(cyl), mpg)) + geom_point(aes(colour=factor(carb)))
p + facet_grid(. ~ gear)
-------------------------------------------------------------------------------------------------------
require(ggplot2)
mtcars$cyl2<- ifelse(mtcars$cyl > 4, c('A'), c('B')) 
p <- ggplot(mtcars, aes(factor(cyl), mpg))
p + geom_boxplot() + facet_grid(. ~ cyl2, scales = "free", space = "free")
-------------------------------------------------------------------------------------------------------
scale_fill_manual(values=c("POS"="black", "sim v"="gray50",
                           "C"="gray80", "sim t"="white")) facet_grid() facet_grid(factor(MY_CATEGORY) ~ ., drop=TRUE)
-------------------------------------------------------------------------------------------------------
dataset <- expand.grid(Loc = unique(Final$Loc), 
    Doy = pretty(Final$Doy), Tod = pretty(Final$Tod))
dataset$Temp <- predict(mod1, newdata = dataset)
library(ggplot2)
ggplot(dataset, aes(x = Doy, y = Temp, linetype = Loc)) + geom_line() + 
    facet_wrap(~Tod)
-------------------------------------------------------------------------------------------------------
stat_sum size = ..n.. weight = cost library(ggplot2)
set.seed = 321
# Generate somme data
df <- expand.grid(x = seq(1:5), y = seq(1:5), KEEP.OUT.ATTRS = FALSE)
df$Count = sample(1:25, 25, replace = F)
library(plyr)
new <- dlply(df, .(Count), function(data) matrix(rep(matrix(c(data$x, data$y), ncol = 2), data$Count), byrow = TRUE, ncol = 2))
df2 <- data.frame(do.call(rbind, new))
df2$cost <- 1:325 group=1 ggplot(df2, aes(factor(X1), factor(X2))) + 
  stat_sum(aes(group = 1)) ggplot(df2, aes(factor(X1), factor(X2))) + 
  stat_sum(aes(size = ..n..)) weight ggplot(df2, aes(x=factor(X1), y=factor(X2))) + 
     stat_sum(aes(group = 1, weight = cost, size = ..n..)) ggplot(df2, aes(x=factor(X1), y=factor(X2))) + 
     stat_sum(aes(group = 1, weight = cost)) ggplot(df2, aes(x=factor(X1), y=factor(X2))) + 
     stat_sum(aes(group = X1, weight = cost))
-------------------------------------------------------------------------------------------------------
type library(plyr)
 data <- ddply(data, .( items, name), mutate, is_max = type == type[which.max(value)])

## the plot
ggplot(data, aes(x = type, y = value, fill = is_max, group = items)) + 
  facet_grid(name ~ items, scale = 'free', space = 'free') + 
  geom_bar(stat = 'identity') +  
  scale_fill_manual(values = c('black', 'red'), labels = c('other', 'maximum')) +
  opts(legend.position = "top", legend.text = theme_text(size = 15),  
       legend.title = theme_text(size = 0,colour = "white"), 
       legend.key = theme_rect(colour = NA)) ggplot(data, aes(x=type, y= value, group = items, fill = type)) +  
  facet_grid(name~items, scale = 'free', space = 'free') + 
  geom_bar(stat= 'identity')  +
  geom_bar(data = data[data$is_max,],stat = 'identity', fill = 'red' ) +
  scale_fill_manual(values = rep("grey60",4), 
                    labels = c("type-A", "type-B", "type-C", "type-D")) + 
  opts(strip.text.y = theme_text(size=14, face="bold")) + 
  opts(legend.position="top", legend.text=theme_text(size=15), 
       legend.title=theme_text(size=0,colour="white"), 
       legend.key = theme_rect(colour = NA))
-------------------------------------------------------------------------------------------------------
set.seed(12345)
dataset <- expand.grid(Temp = rnorm(30), Age = runif(10))
dataset$Truth <- with(dataset, plogis(2 * Temp - 3 * Age))
dataset$Sample <- rbinom(nrow(dataset), size = 1, prob = dataset$Truth)
model <- glm(Sample ~ Temp + Age, data = dataset, family = binomial)
newdata <- expand.grid(
  Temp = pretty(dataset$Temp, 20), 
  Age = pretty(dataset$Age, 5))
newdata$Sample <- predict(model, newdata = newdata, type = "response")
library(ggplot2)
ggplot(newdata, aes(x = Temp, y = Sample)) + geom_line() + facet_wrap(~Age) ggplot(newdata, aes(x = Temp, y = Sample, colour = Age, group = Age)) + 
  geom_line()
-------------------------------------------------------------------------------------------------------
x y plot(20:39,data2,type='l',xlim=c(0,50),xlab='Days') all_data <- data.frame(
  day = c(1:50, 20:39),
  y   = c(runif(50), rnorm(20)),
  grp = factor(rep(1:2, times = c(50, 20)))  
)

#ggplot2 style
library(ggplot2)
ggplot(all_data, aes(day, y)) +
  geom_line() +
  facet_grid(grp ~ .)

#lattice style
library(lattice)
xyplot(y ~ day | grp, all_data, type = "l", layout = c(1, 2))
-------------------------------------------------------------------------------------------------------
install.packages("scales")
library(scales) 
ggplot(dd,aes(x=variable,y=value.y,fill=Date)) +
geom_bar(aes(width=rescale(value.x,c(0.5,1))),stat="identity",position="stack")' +
coord_flip() ggplot(dd,aes(x=variable,y=value.y,fill=Date)) +
geom_bar(aes(width=rescale(value.x,c(0.2,1))),stat="identity") +
coord_flip() + facet_grid(~Date) + opts(legend.position="none")
-------------------------------------------------------------------------------------------------------
glmer sess:pc sess:Stim.cond sess effects maintainer("effects") d7nowl <- expand.grid(pc=factor(LETTERS[1:2]),
                      Stim.cond=factor(letters[1:2]),
                      sess=factor(1:2),
                      item.no=factor(1:10),id=factor(1:10))
d7nowl$correct_response <- rbinom(nrow(d7nowl),size=1,prob=0.5) g1 <- glmer(correct_response ~ pc * Stim.cond + sess:pc + sess:Stim.cond +
            (1|item.no) + (1|id), data=d7nowl, family=binomial)

## reproduce error
try(allEffects(g1)) 
## Error in eval(expr, envir, enclos) : object 'sess' not found g2 <- glm(correct_response ~ pc * Stim.cond + sess:pc + sess:Stim.cond,
            data=d7nowl, family=binomial)    
try(allEffects(g2)) ## same error allEffects sess sess g3 <- update(g2,.~.+sess)
try(allEffects(g3)) ## OK

g4 <- update(g2,.~.-sess:pc-sess:Stim.cond)
try(allEffects(g4)) ## OK allEffects g5 <- glm(correct_response ~ pc + sess:pc, data=d7nowl, family=binomial)
try(allEffects(g5))
## Error in mod.matrix[, components] : subscript out of bounds effects:::analyze.model
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library("reshape")

df <- data.frame(T,V1,V2,V3,V4)
m1 <- melt(df, id = "T") 

m1$sepfac <- (m1$variable=="V1")

chart1<-qplot(T, value, data = m1, geom = "line", group = variable) +
stat_smooth() +
facet_grid(sepfac~., scale = "free_y")
-------------------------------------------------------------------------------------------------------
require(coefplot)
coefplot(log) preds <- with(mtcars, expand.grid(mpg, am))
names(preds) <- c("mpg", "am")
preds$Score <- predict(object=logMod, newdata=preds, type="response")
ggplot(preds, aes(x=mpg, y=Score, group=am, colour=factor(am))) + geom_line(linetype=2) + scale_color_discrete("am")
-------------------------------------------------------------------------------------------------------
library(car)
mtcars
#Change your model name because log is also a function
logodds <- glm(vs ~ mpg + am, data=mtcars, family=binomial)
summary(logodds)

library(ggplot2)
new.data = with(mtcars, expand.grid(am = unique(am),
                                    mpg = seq(min(mpg), max(mpg))))

new.data$vs <- predict.glm(logodds, newdata = new.data, type = "response")

ggplot(new.data, aes(mpg, vs, colour = am)) + geom_line(aes(group = am))
-------------------------------------------------------------------------------------------------------
> expand.grid(a,b)
   Var1       Var2
1   ABC 2012-05-01
2   DEF 2012-05-01
3   GHI 2012-05-01
4   ABC 2012-05-02
5   DEF 2012-05-02
6   GHI 2012-05-02
7   ABC 2012-05-03
8   DEF 2012-05-03
9   GHI 2012-05-03
10  ABC 2012-05-04
11  DEF 2012-05-04
12  GHI 2012-05-04
13  ABC 2012-05-05
14  DEF 2012-05-05
15  GHI 2012-05-05 library(plyr)
arrange(expand.grid(a=a,b=b),a)
-------------------------------------------------------------------------------------------------------
dat <- data.frame(V1=c("a", "b"),
                  V2=c("c", "d"),
                  V3=c("e", "f"), 
                  V4=c("g", "h"))

factor_pairs <- expand.grid(c("V1", "V2"), 
                            c("V3", "V4"),
                            stringsAsFactors=FALSE)

for (i in 1:nrow(factor_pairs)) {
    factor_1 <- factor_pairs[i, 1]
    factor_2 <- factor_pairs[i, 2]
    new_col_name <- paste(factor_1, factor_2, sep=":")
    dat[[new_col_name]] <- paste(dat[[factor_1]], dat[[factor_2]], sep=":")
}

dat
#   V1 V2 V3 V4 V1:V3 V2:V3 V1:V4 V2:V4
# 1  a  c  e  g   a:e   c:e   a:g   c:g
# 2  b  d  f  h   b:f   d:f   b:h   d:h
-------------------------------------------------------------------------------------------------------
dput(totalex.df) unit unit & agency.type unit facet_wrap( ~ unit, ncol=6) facet_grid(agency.type ~ unit, ncol=6)
-------------------------------------------------------------------------------------------------------
MySample$date <- as.Date(MySample$x, "%m-%d-%y")
MySample$year <- year(MySample$date)

ggplot(MySample, aes(date, y, fill = year)) + 
  geom_bar(y=y,stat="identity") + 
  facet_grid(. ~ year, scales = "free") +
  scale_x_date(labels = date_format("%b/%y")) +
  scale_fill_gradient(breaks=unique(MySample$year))
-------------------------------------------------------------------------------------------------------
library(plyr)
ms <- ddply(mydf, .(group), colwise(mean))
mydf2ms <- merge(mydf, ms, by = "group")
gm <- ddply(mydf, NULL, colwise(mean))
ms2gm <- data.frame(ms, gm)

ci <- expand.grid(1:3*2, seq(0, 2*pi, length = 180))
ci <- transform(ci, x = cos(Var2) * Var1 + gm$x, y = sin(Var2) * Var1 + gm$y)

library(ggplot2)
ggplot(mydf, aes(x, y)) +
  geom_point(aes(colour= factor (group), size=z)) +
  geom_segment(data = mydf2ms, mapping = aes(x = x.x, y = y.x, xend = x.y, yend = y.y, colour = factor(group))) +
  geom_segment(data = ms2gm, mapping = aes(x = x, y = y, xend = x.1, yend = y.1)) +
  geom_point(data = ms, colour = "black", size = 10, shape = 4) +
  geom_point(data = gm, colour = "red", size = 10, shape = 4) +
  geom_path(data = ci, mapping = aes(group = Var1), colour = "pink")
-------------------------------------------------------------------------------------------------------
ylim ylim library(maps)
library(mapproj)

ylim = c(-90,-45)
orientation=c(-90, 0, 0)

x11()
par(mar=c(1,1,1,1))
m <- map("world", plot=FALSE)
map("world",project="stereographic", orientation=orientation, ylim=ylim, col = "transparent")
map("world",project="stereographic", orientation=orientation, ylim=ylim + c(-5, 5), add = TRUE)
map.grid(m, nx=18,ny=18, col=8)
box()
-------------------------------------------------------------------------------------------------------
orientation=c(-90, 0, 0)

ylim <- c(mapproject(x=-180,y=-45, project="stereographic", orientation=orientation)$y, mapproject(x=0,y=-45, project="stereographic", orientation=orientation)$y)
xlim <- c(mapproject(x=-90,y=-45, project="stereographic", orientation=orientation)$x, mapproject(x=90,y=-45, project="stereographic", orientation=orientation)$x)

x11(width=6,height=6)
par(mar=c(1,1,1,1))
plot(0,0, t="n", ylim=ylim, xlim=xlim, xaxs="i", yaxs="i", xlab="", ylab="", xaxt="n", yaxt="n")
map("world",project="stereographic", orientation=orientation, add=TRUE)
map.grid(nx=18,ny=18, col=8)
box()
-------------------------------------------------------------------------------------------------------
ggplot2 lattice lattice ggplot2 gridBase grid.pdf viewports.pdf rotated.pdf file.path(.Library, "grid", "doc") vignette("gridBase", package="gridBase") ## Load required packages
library(lattice); library(grid); library(gridBase)

## Construct example dataset
set.seed (123)
myd <- data.frame ( matrix(sample (c(1, 0, -1), 500, replace = "T"), 50))
mmat <-  cor(myd)
diag(mmat) <- NA
mmat[upper.tri (mmat)] <- NA

## Reformat data for input to `lattice::levelplot()`
grid <- data.frame(expand.grid(x = rownames(mmat), y = colnames(mmat)), 
                   z = as.vector(mmat))

## Open a plotting device    
plot.new()     

## Push viewport that will contain the levelplot; plot it; up viewport.
pushViewport(viewport(y = 0.6, height = 0.8, width = 0.8, angle=135))
    lp <- levelplot(z~y*x, grid, colorkey=FALSE, 
                    col.regions=heat.colors(100), aspect=1,
                    scales = list(draw=FALSE), xlab="", ylab="", 
                    par.settings=list(axis.line=list(col="white")))
    plot(lp, newpage=FALSE)
upViewport()

## Push viewport that will contain the green bar; plot it; up viewport.
pushViewport(viewport(y = 0.7, height=0.2))
    # Use the gridBase::gridOMI to determine the location within the plot.
    # occupied by the current viewport, then set that location via par() call
    par(omi = gridOMI(), new=TRUE, mar = c(0,0,0,0))
    plot(0:1, 0:1,type = "n", axes = FALSE, xlab = "", ylab = "", yaxt = "n")
    polygon(x=c(0,0,1,1,0), y = c(.4,.6,.6,.4,.4), col = "green4")
upViewport()
-------------------------------------------------------------------------------------------------------
plotmatrix2 plotmatrix2 <- function (data, mapping = aes())
{
    grid <- expand.grid(x = 1:ncol(data), y = 1:ncol(data))
    grid <- subset(grid, x != y)
    all <- do.call("rbind", lapply(1:nrow(grid), function(i) {
        xcol <- grid[i, "x"]
        ycol <- grid[i, "y"]
        data.frame(xvar = names(data)[ycol], yvar = names(data)[xcol], 
            x = data[, xcol], y = data[, ycol], data)
    }))
    all$xvar <- factor(all$xvar, levels = names(data))
    all$yvar <- factor(all$yvar, levels = names(data))
    densities <- do.call("rbind", lapply(1:ncol(data), function(i) {
        data.frame(xvar = names(data)[i], yvar = names(data)[i], 
            x = data[, i])
    }))
    densities$xvar <- factor(densities$xvar, levels = names(data))
    densities$yvar <- factor(densities$yvar, levels = names(data))
    mapping <- defaults(mapping, aes_string(x = "x", y = "y"))
    class(mapping) <- "uneval"
    ggplot(all) + facet_grid(xvar ~ yvar, scales = "free") + 
        geom_point(mapping, na.rm = TRUE) + stat_density(aes(x = x, 
        y = ..scaled.. * diff(range(x)) + min(x)), data = densities, 
        position = "identity", colour = "grey20", geom = "line")
}


plotmatrix2(mtcars[,1:3],aes(colour = factor(cyl))) densities aes()
-------------------------------------------------------------------------------------------------------
standing id library(ggplot2)

# Create new data frame for determining initial standing.
standing_data = data.frame(id=unique(df1$id), initial_standing=NA, cohort=NA)

for (i in 1:nrow(standing_data)) {
    id = standing_data$id[i]
    subdat = df1[df1$id == id, ]
    subdat = subdat[complete.cases(subdat), ]
    initial_standing = subdat$standing[which.min(subdat$term)]
    standing_data[i, "initial_standing"] = as.character(initial_standing)
    standing_data[i, "cohort"] = as.character(subdat$cohort[1])
}

standing_data$cohort = factor(standing_data$cohort, levels=levels(df1$cohort))
standing_data$initial_standing = factor(standing_data$initial_standing,
                                        levels=levels(df1$standing))

# Add the new column (initial_standing) to df1.
df1 = merge(df1, standing_data[, c("id", "initial_standing")], by="id")

# Remove rows where standing is missing. Make some plots tidier.
df1 = df1[!is.na(df1$standing), ]

# Create id factor, controlling the sort order of the levels.     
id_order = order(standing_data$initial_standing, standing_data$cohort)
df1$id = factor(df1$id, levels=as.character(standing_data$id)[id_order])


p1 = ggplot(df1, aes(x=term, fill=standing)) +
     geom_bar(position="fill", colour="grey20", size=0.5, width=1.0) +
     facet_grid(cohort ~ .) +
     scale_fill_brewer(palette="Set1")

p2 = ggplot(df1, aes(x=term, y=termGPA, group=id)) + 
     geom_line(colour="grey70") + 
     geom_point(aes(colour=standing), size=4) + 
     facet_grid(cohort ~ .) +
     scale_colour_brewer(palette="Set1")

p3 = ggplot(df1, aes(x=term, y=termGPA, group=id)) +
     geom_line(colour="grey70") + 
     geom_point(aes(colour=standing), size=4) + 
     geom_text(aes(label=id), hjust=-0.30, size=3) +
     facet_grid(initial_standing ~ cohort) +
     scale_colour_brewer(palette="Set1")


p4 = ggplot(df1, aes(x=term, y=id, fill=standing)) + 
     geom_tile(colour="grey20") +
     facet_grid(initial_standing ~ ., space="free_y", scales="free_y") +
     scale_fill_brewer(palette="Set1") +
     opts(panel.grid.major=theme_blank()) +
     opts(panel.grid.minor=theme_blank())

ggsave("plot_1.png", p1, width=10, height=6.25, dpi=80)
ggsave("plot_2.png", p2, width=10, height=6.25, dpi=80)
ggsave("plot_3.png", p3, width=10, height=6.25, dpi=80)
ggsave("plot_4.png", p4, width=10, height=6.25, dpi=80)
-------------------------------------------------------------------------------------------------------
x <- data.frame(Date=rep(c("1/1/2012", "1/2/2012"), 3), 
  Price=c(98, 100, 36, 34, 78, 75),
  "Stock Ticker"=rep(c("ABC.US", "XYZ.US", "MNO.LN"), each=2), 
  Country=rep(c("US", "US", "UK"), each=2)) all.opts <- expand.grid(Date=levels(x$Date), 
  Stock.Ticker=levels(x$Stock.Ticker), 
  Country=levels(x$Country)) library(plyr)
x2 <- join(all.opts, x) x.arr2 <- array(x2$Price, dim=c(2, 3, 2), 
  dimnames=list(levels(x2$Date), levels(x2$Stock.Ticker), levels(x2$Country))) x.arr2

#, , UK
#
#         ABC.US MNO.LN XYZ.US
#1/1/2012     NA     78     NA
#1/2/2012     NA     75     NA
#
#, , US
#
#         ABC.US MNO.LN XYZ.US
#1/1/2012     98     NA     36
#1/2/2012    100     NA     34
-------------------------------------------------------------------------------------------------------
short_brks long_brks grid unit require(ggplot2)
require(grid)

avtimes3$id <- factor(avtimes3$id)
## create and store plot
p <- ggplot(avtimes3, aes(x=trial, y=ttime, colour=id)) + 
  facet_grid(. ~ brk, scales = "free") + 
  geom_point(shape=21, fill="white") +
  ## remove space between panels    
  opts(panel.margin = unit(0, "lines")) + 
  ylab("Time taken (ms)") + 
  xlab("Trial No.")


## as you had
p + stat_smooth(method="loess") ## only one line per facet
p + stat_smooth(method="loess", aes(colour=NULL)) ## setup plot
p <- ggplot(avtimes3, aes(x=trial, y=ttime, colour=id)) +  
  geom_point(shape=21, fill="white") + 
  ylab("Time taken (ms)") +  
  xlab("Trial No.")

p + stat_smooth(aes(group = brk), method="loess") stat_smooth R p + stat_smooth(method = "loess", mapping = aes(group = brk)) brk p + stat_smooth(method = "loess", mapping = aes(group = interaction(brk, id)))
-------------------------------------------------------------------------------------------------------
par(mfrow=) grid.arrange library(ggplot2)
library(gridExtra)

# Completely fake plotting function.
makePlot = function(a, b) {
    dat = data.frame(x=rnorm(a), y=rnorm(a))
    p = ggplot(dat, aes(x=x, y=y)) + 
        geom_point(size=b, alpha=1/b) +
        opts(title=paste("a = ", a, ", b = ", b, sep="")) +
        opts(plot.title=theme_text(size=12))
    return(p)
}

plot_list = list() # Create an empty list to hold plots.

for (b in c(1, 3, 6)) {                   # I switched a and b loops
    for (a in seq(100, 900, by=100)) {    # to make the final layout neater.
        p = makePlot(a, b)
        plot_list = c(plot_list, list(p)) # Add new plot to list.
    }
}

pdf("mytry1.pdf", width = 14, height = 6)
do.call(grid.arrange, c(plot_list, list(nrow=3, ncol=9, main="Grid of Plots")))
dev.off() plot_list mlply ggsave arrangeGrob library(plyr)
plot_list = mlply(expand.grid(a=seq(100, 900, by=100), b=c(1, 3, 6)), makePlot)

ggsave(filename="grid_1.pdf", height=6, width=14, 
       plot=do.call(arrangeGrob, c(plot_list, nrow=3, main="Grid of Plots")))
-------------------------------------------------------------------------------------------------------
res <- rbind(first,second)
res <- tapply(res, expand.grid(dimnames(res)), sum) data.frame data.frame rowsum(rbind(first, second), c(rownames(first), rownames(second))) tapply rowsum(rbind(first, second)[,-1], c(first[,1], second[,1])) rowsum rowSums data.frame Var1 Var2 names(dimnames(res)) <- NULL rownames(first) <- first[,1]
first <- first[,-1]
-------------------------------------------------------------------------------------------------------
scale = "free" facet_grid space = "free" data <- data.frame(ID=factor(c(rep(1,9), rep(2,6), rep(3,6), rep(4,3), rep(5,3))),
                   TYPE=factor(rep(1:3,3)),
                   TIME=factor(c(1,1,1,2,2,2,3,3,3,1,1,1,2,2,2,1,1,1,2,2,2,1,1,1,1,1,1)),
                   VAL=runif(27))

library(ggplot2)
library(plyr)

# Get the cumulative sums
data = ddply(data, .(ID, TIME), mutate, CUMSUMVAL = cumsum(VAL))

ggplot(data, aes(x=VAL, y = as.numeric(ID), fill=TYPE)) +
   geom_rect(data = subset(data, TYPE == 3), aes(xmin = 0, xmax = CUMSUMVAL, ymin = as.numeric(ID)-.2, ymax = as.numeric(ID)+.2)) +
   geom_rect(data = subset(data, TYPE == 2), aes(xmin = 0, xmax = CUMSUMVAL, ymin = as.numeric(ID)-.2, ymax = as.numeric(ID)+.2)) +
   geom_rect(data = subset(data, TYPE == 1), aes(xmin = 0, xmax = CUMSUMVAL, ymin = as.numeric(ID)-.2, ymax = as.numeric(ID)+.2)) +
   facet_grid(TIME~., space = "free", scale="free") +
   scale_y_continuous(breaks = c(1:5), expand = c(0, 0.2)) ggplot(data, aes(x=VAL, y = ID, colour=TYPE)) +
       geom_segment(data = subset(data, TYPE == 3), aes(x = 0, xend = CUMSUMVAL, y = ID, yend = ID), size = 10) +
       geom_segment(data = subset(data, TYPE == 2), aes(x = 0, xend = CUMSUMVAL, y = ID, yend = ID), size = 10) +
       geom_segment(data = subset(data, TYPE == 1), aes(x = 0, xend = CUMSUMVAL, y = ID, yend = ID), size = 10) +
       facet_grid(TIME~., space = "free", scale="free") df <- structure(list(ID = structure(c(1L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 
2L, 2L, 2L, 3L, 3L, 3L, 3L, 3L, 3L, 4L, 4L, 4L, 4L, 4L, 4L, 5L, 
5L, 5L, 5L, 5L, 5L, 6L, 6L, 6L, 6L, 6L, 6L, 7L, 7L, 7L), .Label = c("a", 
"b", "c", "d", "e", "f", "g"), class = "factor"), TYPE = structure(c(1L, 
2L, 3L, 4L, 5L, 1L, 2L, 3L, 4L, 5L, 6L, 1L, 2L, 3L, 4L, 5L, 6L, 
1L, 2L, 3L, 4L, 5L, 6L, 1L, 2L, 3L, 4L, 5L, 6L, 1L, 2L, 3L, 4L, 
5L, 6L, 1L, 2L, 3L), .Label = c("1", "2", "3", "4", "5", "6", 
"7", "8"), class = "factor"), TIME = structure(c(2L, 2L, 2L, 
2L, 2L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 2L, 2L, 
2L, 2L, 2L, 2L, 1L, 1L, 1L, 1L, 1L, 1L, 3L, 3L, 3L, 3L, 3L, 3L, 
1L, 1L, 1L), .Label = c("One", "Five", "Fifteen"), class = "factor"), VAL = c(0.937377670081332, 
0.522220720537007, 0.278690102742985, 0.967633064137772, 0.116124767344445, 
0.0544306698720902, 0.470229141646996, 0.62017166428268, 0.195459847105667, 
0.732876230962574, 0.996336271753535, 0.983087373664603, 0.666449476964772, 
0.291554537601769, 0.167933790013194, 0.860138458199799, 0.172361251665279, 
0.833266809117049, 0.620465772924945, 0.786503327777609, 0.761877260869369, 
0.425386636285111, 0.612077651312575, 0.178726130630821, 0.528709076810628, 
0.492527724476531, 0.472576208412647, 0.0702785139437765, 0.696220921119675, 
0.230852259788662, 0.359884874196723, 0.518227979075164, 0.259466265095398, 
0.149970305617899, 0.00682218233123422, 0.463400925742462, 0.924704828299582, 
0.229068386601284)), .Names = c("ID", "TYPE", "TIME", "VAL"), row.names = c(NA, 
-38L), class = "data.frame")

library(ggplot2)
library(plyr)

data = ddply(df, .(ID, TIME), mutate, CUMSUMVAL = cumsum(VAL))

ggplot(data, aes(x=VAL, y = ID, colour=TYPE)) +
           geom_segment(data = subset(data, TYPE == 6), aes(x = 0, xend = CUMSUMVAL, y = ID, yend = ID), size = 10) +
           geom_segment(data = subset(data, TYPE == 5), aes(x = 0, xend = CUMSUMVAL, y = ID, yend = ID), size = 10) +
           geom_segment(data = subset(data, TYPE == 4), aes(x = 0, xend = CUMSUMVAL, y = ID, yend = ID), size = 10) +
           geom_segment(data = subset(data, TYPE == 3), aes(x = 0, xend = CUMSUMVAL, y = ID, yend = ID), size = 10) +
           geom_segment(data = subset(data, TYPE == 2), aes(x = 0, xend = CUMSUMVAL, y = ID, yend = ID), size = 10) +
           geom_segment(data = subset(data, TYPE == 1), aes(x = 0, xend = CUMSUMVAL, y = ID, yend = ID), size = 10) +
           facet_grid(TIME~., space = "free", scale="free") +
           opts(strip.text.y = theme_text(angle = 0))
-------------------------------------------------------------------------------------------------------
df$ref_name <- reorder(df$ref_name,-log(df$count_neg,10))    

ggplot(data=df) + 
    geom_point(aes(y=log(count_neg,10), x= ref_name, colour=replicate)) +             
    facet_grid(condition ~ sub_groups)
-------------------------------------------------------------------------------------------------------
library(plyr)

corr_dat<-ddply(dat, .(product), summarise, value=value)
corr.df<-unstack(corr_dat, value~product)

corr_plot <- data.frame(date=max(dat$date),
                        label=paste0("rho==",round(cor(corr.df)[,1], 2)), 
                        ddply(dat, .(product), summarise, 
                          value=(min(value)+max(value))/2))

ggplot(dat, aes(x=date, y=value, color=location, group=location)) + 
  geom_line()+
  facet_grid(product ~ ., scale = "free_y")+
  geom_text(data=corr_plot, aes(x=date, y=value, label=label), 
            colour="black", inherit.aes=FALSE, parse=TRUE)
-------------------------------------------------------------------------------------------------------
ggplot(df, aes(x=ID, y=VAL, fill=TYPE)) +
  facet_grid(.~TIME, scale="free_x", space = "free_x") +
  geom_bar(position="stack") ggplot(df, aes(x=ID, y=VAL, fill=TYPE)) +
  facet_grid(.~TIME, scale="free_x", space = "free_x") +
  geom_bar(position="stack") +
  opts(legend.text = theme_text(angle=90),
       legend.title = theme_text(angle=90),
       strip.text.x = theme_text(angle=90),
       axis.text.x = theme_text(angle=90),
       axis.text.y = theme_text(angle=90),
       axis.title.x = theme_text(angle=90)
       )
-------------------------------------------------------------------------------------------------------
ggplot(mtcars, aes(mpg, wt)) + 
    geom_smooth(method = "loess", colour = "red", fill = "red") + 
    geom_smooth(method = "lm", colour = "blue", fill = "blue") + 
    geom_point() + facet_grid(vs ~ am, margins=TRUE) ggplot(mtcars, aes(mpg, wt)) + geom_smooth(method = "lm") + geom_point() + 
    facet_grid(vs ~ am, margins=TRUE)
-------------------------------------------------------------------------------------------------------
p <- ggplot(mtcars, aes(mpg, wt)) + geom_point()

# Calculate correlation for each group
cors <- ddply(mtcars, c("vs", "am"), summarise, cor = round(cor(mpg, wt), 2))

p + facet_grid(vs ~ am) +
geom_text(data=cors, aes(label=paste("r=", cor, sep="")), x=30, y=4)
-------------------------------------------------------------------------------------------------------
require(ggplot2)
require(gridExtra)
set.seed(10)
dat <- data.frame(var1=rpois(1000, 20), 
                  var2=as.factor(sample(LETTERS[1:4], 1000, replace=T)),
                  var3=as.factor(sample(month.abb[1:5], 1000, replace=T)))
dat$var4 <- "All"

windows(width=8, height=8)

p1 <- ggplot(dat, aes(var1)) + 
  geom_histogram() + 
  facet_grid(var2~var3) +


p2 <- ggplot(dat, aes(var1)) + 
  geom_histogram() + 
  facet_grid(~var3)


grid.arrange(p1, p2, nrow=2, heights=c(4,1.5)) scale_x_continuous('', breaks = NA)
-------------------------------------------------------------------------------------------------------
vals <- expand.grid(n=1:3, z=c("A", "B"), 
                      KEEP.OUT.ATTRS=FALSE, stringsAsFactors=FALSE)

library(plyr)
alply(vals, 1, as.list)

$`1`
$`1`$n
[1] 1

$`1`$z
[1] "A"


$`2`
$`2`$n
[1] 2

$`2`$z
[1] "A"


$`3`
$`3`$n
[1] 3

$`3`$z
[1] "A"


$`4`
$`4`$n
[1] 1

$`4`$z
[1] "B"


$`5`
$`5`$n
[1] 2

$`5`$z
[1] "B"


$`6`
$`6`$n
[1] 3

$`6`$z
[1] "B"


attr(,"split_type")
[1] "array"
attr(,"split_labels")
  n z
1 1 A
2 2 A
3 3 A
4 1 B
5 2 B
6 3 B
-------------------------------------------------------------------------------------------------------
library(reshape)
M2<-data.frame(colsplit(M$date, "-", c("ID", "year", "month", "day")), 
               value=M$value) library(reshape)
M2<-data.frame(colsplit(M$date, "-", c("ID", "year", "month", "day")), 
               value=M$value)

set.seed(1234)
M2<-expand.grid(ID=182, year=2002:2004, month=1:2, day=1:3, KEEP.OUT.ATTRS=FALSE)
M2 <- M2[with(M2, order(year, month, day, ID)),] #sort the data
M2$value <- sample(c(NA, rnorm(100)), nrow(M2), 
                   prob=c(0.5, rep(0.5/100, 100)), replace=TRUE)
M2

    ID year month day      value
1  182 2002     1   1 -0.5012581
7  182 2002     1   2  1.1022975
13 182 2002     1   3         NA
4  182 2002     2   1 -0.1623095
10 182 2002     2   2  1.1022975
16 182 2002     2   3 -1.2519859
2  182 2003     1   1         NA
8  182 2003     1   2         NA
14 182 2003     1   3         NA
5  182 2003     2   1  0.9729168
11 182 2003     2   2  0.9594941
17 182 2003     2   3         NA
3  182 2004     1   1         NA
9  182 2004     1   2 -1.1088896
15 182 2004     1   3  0.9594941
6  182 2004     2   1 -0.4027320
12 182 2004     2   2 -0.0151383
18 182 2004     2   3 -1.0686427 NA_run <- function(x, maxlen){
  runs <- rle(is.na(x$value))
  if(any(runs$lengths[runs$values] >= maxlen)) NULL else x
  }

library(plyr)
rem <- ddply(M2, .(ID, year, month), NA_run, 2)
rem

    ID year month day      value
1  182 2002     1   1 -0.5012581
2  182 2002     1   2  1.1022975
3  182 2002     1   3         NA
4  182 2002     2   1 -0.1623095
5  182 2002     2   2  1.1022975
6  182 2002     2   3 -1.2519859
7  182 2003     2   1  0.9729168
8  182 2003     2   2  0.9594941
9  182 2003     2   3         NA
10 182 2004     1   1         NA
11 182 2004     1   2 -1.1088896
12 182 2004     1   3  0.9594941
13 182 2004     2   1 -0.4027320
14 182 2004     2   2 -0.0151383
15 182 2004     2   3 -1.0686427 na.rm=FALSE library(zoo)
rem$value <- na.locf(rem$value, na.rm=FALSE)
rem

    ID year month day      value
1  182 2002     1   1 -0.5012581
2  182 2002     1   2  1.1022975
3  182 2002     1   3  1.1022975
4  182 2002     2   1 -0.1623095
5  182 2002     2   2  1.1022975
6  182 2002     2   3 -1.2519859
7  182 2003     2   1  0.9729168
8  182 2003     2   2  0.9594941
9  182 2003     2   3  0.9594941
10 182 2004     1   1  0.9594941
11 182 2004     1   2 -1.1088896
12 182 2004     1   3  0.9594941
13 182 2004     2   1 -0.4027320
14 182 2004     2   2 -0.0151383
15 182 2004     2   3 -1.0686427 maxlen NA_run library(zoo)
rem$value <- ddply(rem, .(ID, year, month), summarise, 
                   value=na.locf(value, na.rm=FALSE))$value
rem

    ID year month day      value
1  182 2002     1   1 -0.5012581
2  182 2002     1   2  1.1022975
3  182 2002     1   3  1.1022975
4  182 2002     2   1 -0.1623095
5  182 2002     2   2  1.1022975
6  182 2002     2   3 -1.2519859
7  182 2003     2   1  0.9729168
8  182 2003     2   2  0.9594941
9  182 2003     2   3  0.9594941
10 182 2004     1   1         NA
11 182 2004     1   2 -1.1088896
12 182 2004     1   3  0.9594941
13 182 2004     2   1 -0.4027320
14 182 2004     2   2 -0.0151383
15 182 2004     2   3 -1.0686427
-------------------------------------------------------------------------------------------------------
reshape library(reshape2)
df <- melt(D) ggplot(df, aes(x = factor(Education), y = value, fill = factor(variable))) +
geom_bar() + facet_grid(.~Group) +
ylab('') + xlab('') + opts(title = '') + scale_fill_discrete('') +
theme_bw() +
opts(axis.text.x=theme_text(angle = 45, hjust = 1, vjust = 1)) bar facet b&w
-------------------------------------------------------------------------------------------------------
scale_..._manual value setNames ## some dummy data 
simulations<- expand.grid(year = 2012:2020, geography = paste0('a',1:35))
library(plyr)
library(RColorBrewer)
simulation_long_index <- ddply(simulations, .(geography), mutate, 
  value = (year-2012) * runif(1,-2, 2) + rnorm(9, mean = 0, sd = runif(1, 1, 3)))
## create a manyColors function 
manyColors <- colorRampPalette(brewer.pal(name = 'Set3',n=11)) geography lty <- setNames(sample(1:12,35,T), levels(simulation_long_index$geography)) lty
## a1  a2  a3  a4  a5  a6  a7  a8  a9 a10 a11 a12 a13 a14 a15 a16 
## 7   5   8  11   2  10   3   2   5   4   6   6  11   8   2   2 
## a17 a18 a19 a20 a21 a22 a23 a24 a25 a26 a27 a28 a29 a30 a31 a32 
## 12   7   6   8  11   5   1   1   8  12   8   1  12   2   3   5 
## a33 a34 a35 
#7   1   3 line_type = geography scale_linetype_manual(values = lty) ggplot(data=simulation_long_index,
        aes(
          x=as.factor(year), 
          y=value, 
          colour=geography,
          group=geography,
          linetype = geography))+
            geom_line(size=.65) + 
            scale_colour_manual(values=manyColors(35)) +
            geom_point(size=2.5) +
            opts(title="growth")+
            xlab("Year") + 
            ylab(paste("Indexed Value (Rel. to 2012")) + 
            opts(axis.text.x=theme_text(angle=90, hjust=0)) +
            scale_linetype_manual(values = lty)
-------------------------------------------------------------------------------------------------------
qdap paste2 R CMD INSTALL devtools library(devtools)
install_github("qdap", "trinker")

ind <- unique(t(apply(expand.grid(1:3, 1:3), 1, sort)))
ind <- ind[ind[, 1] != ind[, 2], ]
sapply(1:nrow(ind), function(i) paste2(df[, unlist(ind[i, ])], sep="")) ind <- t(combn(seq_len(ncol(df)), 2))
sapply(1:nrow(ind), function(i) paste2(df[, unlist(ind[i, ])], sep=""))
-------------------------------------------------------------------------------------------------------
#required function from www.menugget.blogspot.com
matrix.poly <- function(x, y, z=mat, n=NULL){
 if(missing(z)) stop("Must define matrix 'z'")
 if(missing(n)) stop("Must define at least 1 grid location 'n'")
 if(missing(x)) x <- seq(0,1,,dim(z)[1])
 if(missing(y)) y <- seq(0,1,,dim(z)[2])
 poly <- vector(mode="list", length(n))
 for(i in seq(n)){
  ROW <- ((n[i]-1) %% dim(z)[1]) +1
  COL <- ((n[i]-1) %/% dim(z)[1]) +1

  dist.left <- (x[ROW]-x[ROW-1])/2
  dist.right <- (x[ROW+1]-x[ROW])/2
  if(ROW==1) dist.left <- dist.right
  if(ROW==dim(z)[1]) dist.right <- dist.left

  dist.down <- (y[COL]-y[COL-1])/2
  dist.up <- (y[COL+1]-y[COL])/2
  if(COL==1) dist.down <- dist.up
  if(COL==dim(z)[2]) dist.up <- dist.down

  xs <- c(x[ROW]-dist.left, x[ROW]-dist.left, x[ROW]+dist.right, x[ROW]+dist.right)
  ys <- c(y[COL]-dist.down, y[COL]+dist.up, y[COL]+dist.up, y[COL]-dist.down)
  poly[[i]] <- data.frame(x=xs, y=ys)
 }
 return(poly)
}

#make vector of grids for hatching
incl <- which(over==1)

#make polygons for each grid for hatching
polys <- matrix.poly(1:12, 1:6, z=over, n=incl)

    #plot
png("hatched_image.png")
image(1:12, 1:6, data)
for(i in seq(polys)){
    polygon(polys[[i]], density=10, angle=45, border=NA)
    polygon(polys[[i]], density=10, angle=-45, border=NA)
}
box()
dev.off() png("hatched_image2.png")
image(1:12, 1:6, data)
for(i in seq(polys)){
    xran <- range(polys[[i]]$x)
    yran <- range(polys[[i]]$y)
    xs <- seq(xran[1], xran[2],,5)
    ys <- seq(yran[1], yran[2],,5)
    grd <- expand.grid(xs,ys)
    points(grd, pch=19, cex=0.5)
}
box()
dev.off()
-------------------------------------------------------------------------------------------------------
+ ggplot2 data.frame melt reshape geom_tile pp <- function (n,r=4) { 
 x <- seq(-r*pi, r*pi, len=n) 
 df <- expand.grid(x=x, y=x) 
 df$r <- sqrt(df$x^2 + df$y^2) 
 df$z <- cos(df$r^2)*exp(-df$r/6) 
 df 
} 

require(ggplot2)
dat = pp(200)
over = dat[,c("x","y")]
over$value = with(dat, ifelse(z > 0.5, 1, 0))
ggplot(aes(x = x, y = y), data = dat) + 
   geom_raster(aes(fill = z)) + 
   scale_fill_gradient2() +
   geom_point(data = subset(over, value == 1), shape = "+", size = 1)
-------------------------------------------------------------------------------------------------------
ggplot2 library(ggplot2)

df = read.table(text='latency1,latency2,testtype
1.3233831,1.0406423,A
1.6799337,1.1520619,A
1.6301824,1.1536479,B
2.3465363,1.2346457,C
1.2452355,1.9987547,C', 
                header=TRUE, sep=',')

p = ggplot(data = df, 
           aes(x = latency1, y = latency2, colour = testtype)) +
    geom_point() +
    facet_grid( . ~ testtype )

p
-------------------------------------------------------------------------------------------------------
library(plyr)
df
  id channel
1  1       a
2  1       b
3  1       c
4  2       a
5  2       c
6  3       a
tb <- table(ddply(df, .(id), function(x) {x$id <- x$channel; expand.grid(x)}))
tb
   channel
id  a b c
  a 3 1 2
  b 1 1 1
  c 2 1 2
names(dimnames(tb)) <- NULL
tb
  a b c
a 3 1 2
b 1 1 1
c 2 1 2 table() ?table a <- letters[1:3]
(b <- sample(a))
[1] "b" "c" "a"
table(a, b)
   b
a   a b c
  a 0 1 0
  b 0 0 1
  c 1 0 0 id channel
  1       a
  1       b
  1       c
  2       a
  ... id id channel tbl <- expand.grid(data.frame(x = c("a","b","c"), y = c("a", "b", "c")))
tbl
  x y
1 a a
2 b a
3 c a
4 a b
5 b b
6 c b
7 a c
8 b c
9 c c
table(tbl$x, tbl$y)

    a b c
  a 1 1 1
  b 1 1 1
  c 1 1 1
-------------------------------------------------------------------------------------------------------
?image data(volcano)
m <- volcano
dimx <- nrow(m)
dimy <- ncol(m)

d1 <- list(x = seq(0, 1, length = dimx), y = seq(0, 1, length = dimy), z = m) image() d2 <- d1
d2$z <- d2$z > 155 pts <- expand.grid(x = d2$x, y = d2$y)
pts$over <- as.vector(d2$z) op <- par(mfcol = c(2, 1))
image(d1)

image(d1)
points(pts$x[pts$over], pts$y[pts$over], cex = 0.7)

par(op) pch = "."
-------------------------------------------------------------------------------------------------------
table() plyr data.table aggregate all_data <- expand.grid(country = paste('Country', LETTERS[1:3]), 
  date = seq(as.Date('2012/01/01'), as.Date('2012/12/31'), by = 1) )

all_data[['ed_visits']] <- rpois(nrow(all_data), lambda = 5)



# using plyr

library(plyr)

by_date_plyr <- ddply(all_data, .(date), summarize, visits = sum(ed_visits))


# using data.table
library(data.table)
all_DT <- data.table(all_data)
by_date_dt <- all_DT[, list(visits = sum(ed_visits)), by = 'date' ]

# using aggregate
by_date_base <- aggregate(ed_visits ~ date, data = all_data, sum)
-------------------------------------------------------------------------------------------------------
ggplot ggplot ggplot expand.grid dat rgb() dat$mix dat <- expand.grid(blue=seq(0, 100, by=10), red=seq(0, 100, by=10))
dat <- within(dat, mix <- rgb(green=0, red=red, blue=blue, maxColorValue=100))

library(ggplot2)
ggplot(dat, aes(x=red, y=blue)) + 
  geom_tile(aes(fill=mix), color="white") + 
  scale_fill_identity()
-------------------------------------------------------------------------------------------------------
axis plot(c(-2,2), c(-2,2), axes = FALSE, bty = 'n', panel.first = grid())
axis(1, c(-2, -1, 1, 2), pos = 0, cex.axis = 0.8)
axis(2, c(-2, -1, 1, 2), pos = 0, cex.axis = 0.8, las = 2)
-------------------------------------------------------------------------------------------------------
day density palette scale_fill_brewer(palette="GnBu") foo <- read.table(header=TRUE,
                 text="species  density day percent  
                    1  species1    high   1    0.40  
                    2  species1     low   1    0.20  
                    3  species1  medium   1    0.40  
                    4  species2    high   1    0.35  
                    5  species2     low   1    0.10  
                    6  species2  medium   1    0.55  
                    7  species3    high   1    0.35  
                    8  species3     low   1    0.20  
                    9  species3  medium   1    0.45  
                    10 species4    high   1    0.30  
                    11 species4     low   1    0.20  
                    12 species4  medium   1    0.50  
                    13 species1    high 100    0.50  
                    14 species1     low 100    0.40  
                    15 species1  medium 100    0.10  
                    16 species2    high 100    0.40  
                    17 species2     low 100    0.05  
                    18 species2  medium 100    0.55  
                    19 species3    high 100    0.65  
                    20 species3     low 100    0.05  
                    21 species3  medium 100    0.30  
                    22 species4    high 100    0.40  
                    23 species4     low 100    0.20  
                    24 species4  medium 100    0.40")

foo$density <- factor(foo$density, levels=c("low", "medium", "high"))
foo$day <- factor(paste("Day", foo$day, sep="_"))

library(ggplot2)

d2 <- ggplot(foo, aes(x=day, y=percent, fill=density)) +
      theme_bw() +
      geom_bar(width=0.95, stat="identity") +
      scale_fill_brewer(type="seq", palette=15) +
      xlab("Species") +
      opts(axis.text.x=theme_text(size=6)) +
      facet_grid(. ~ species)

ggsave("barplot_1.png", d2, width=6, height=4) density
-------------------------------------------------------------------------------------------------------
library(plyr)
daply(expand.grid(x=seq(1,0,-.1), y=seq(0,1,.1)),
      .(y, x), with,
      if (x+y >= 1) x+y-1 else NA) x
y      0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9   1
  0   NA  NA  NA  NA  NA  NA  NA  NA  NA  NA 0.0
  0.1 NA  NA  NA  NA  NA  NA  NA  NA  NA 0.0 0.1
  0.2 NA  NA  NA  NA  NA  NA  NA  NA 0.0 0.1 0.2
  0.3 NA  NA  NA  NA  NA  NA  NA 0.0 0.1 0.2 0.3
  0.4 NA  NA  NA  NA  NA  NA 0.0 0.1 0.2 0.3 0.4
  0.5 NA  NA  NA  NA  NA 0.0 0.1 0.2 0.3 0.4 0.5
  0.6 NA  NA  NA  NA 0.0 0.1 0.2 0.3 0.4 0.5 0.6
  0.7 NA  NA  NA 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7
  0.8 NA  NA 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8
  0.9 NA 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9
  1    0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 expand.grid merge daply ddply daply(expand.grid(x=seq(0,1,.1), y=seq(0,1,.1)),
      .(y, x), with,
      if (y-x >= 0) y-x else NA)[,11:1] x
y      1 0.9 0.8 0.7 0.6 0.5 0.4 0.3 0.2 0.1   0
  0   NA  NA  NA  NA  NA  NA  NA  NA  NA  NA 0.0
  0.1 NA  NA  NA  NA  NA  NA  NA  NA  NA 0.0 0.1
  0.2 NA  NA  NA  NA  NA  NA  NA  NA 0.0 0.1 0.2
  0.3 NA  NA  NA  NA  NA  NA  NA 0.0 0.1 0.2 0.3
  0.4 NA  NA  NA  NA  NA  NA 0.0 0.1 0.2 0.3 0.4
  0.5 NA  NA  NA  NA  NA 0.0 0.1 0.2 0.3 0.4 0.5
  0.6 NA  NA  NA  NA 0.0 0.1 0.2 0.3 0.4 0.5 0.6
  0.7 NA  NA  NA 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7
  0.8 NA  NA 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8
  0.9 NA 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9
  1    0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
-------------------------------------------------------------------------------------------------------
temp <-pairwise.wilcox.test(df$vars, df$obs)$p.value
df <- data.frame(expand.grid(dimnames(temp)),array(temp))
na.omit(df)
-------------------------------------------------------------------------------------------------------
Smooth.Vert.Speed DEPTH X Y Z library(ggplot2)
library(reshape2)

# Add time variable as per @BenBolker's suggestion
dt$time <- seq(nrow(dt))

# Use melt to reshape data so values and variables are in separate columns
dt.df <- melt(dt, measure.vars = c("DEPTH", "X", "Y", "Z"))

ggplot(dt.df, aes(x = time, y = value)) +
  geom_line(aes(color = variable)) +
  facet_grid(variable ~ ., scales = "free_y") +
  # Suppress the legend since color isn't actually providing any information
  opts(legend.position = "none")
-------------------------------------------------------------------------------------------------------
sharpness tricol # Coordinates of the triangle
tri <- rbind(sin(0:2*2/3*pi), cos(0:2*2/3*pi))

# Function for calculating the color of a set of points `pt`
# in relation to the triangle
tricol <- function(pt, sharpness=2){
    require(splancs)
    RGB <- sapply(1:3, function(i){
        a <- sweep(pt, 2, tri[,i])
        b <- apply(tri[,-i], 1, mean) - tri[,i]
        sharpness*((a %*% b) / sum(b^2))-sharpness+1
    })
    RGB[-inpip(pt,t(tri)),] <- 1    # Color points outside the triangle white
    do.call(rgb, unname(as.data.frame(pmin(pmax(RGB, 0), 1))))
}

# Plot
res <- 1000                         # Resolution
xi <- seq(-1, 1, length=res)        # Axis points
yi <- seq(-.8, 1.2, length=res)
x <- xi[1] + cumsum(diff(xi))       # Midpoints between axis points
y <- yi[1] + cumsum(diff(yi))
xy <- matrix(1:(length(x)*length(y)), length(x))
image(xi, yi, xy, col=tricol(as.matrix(expand.grid(x,y))), useRaster=TRUE)
lines(tri[1,c(1:3,1)], tri[2,c(1:3,1)], type="l") tricol() i a pt b a b sharpness
-------------------------------------------------------------------------------------------------------
library(ggplot2)
dummy1 <- expand.grid(X = factor(c("A", "B")), Y = rnorm(10))
dummy1$D <- rnorm(nrow(dummy1))
dummy2 <- data.frame(X = c("A", "B"), Z = c(1, 0))
ggplot(dummy1, aes(x = D, y = Y)) + geom_point() + facet_grid(~X) + 
    geom_hline(data = dummy2, aes(yintercept = Z)) dummy2$X <- factor(dummy2$X)
ggplot(dummy1, aes(x = D, y = Y)) + geom_point() + facet_grid(~X) + 
    geom_hline(data = dummy2, aes(yintercept = Z))
-------------------------------------------------------------------------------------------------------
quakes ggplot2 plyr quakes ddply ggplot geom_text library(plyr)
library(ggplot2)

quakes$level <- cut(quakes$depth, 5, 
  labels=c("Very Shallow", "Shallow", "Medium", "Deep", "Very Deep"))

quakes.summary <- ddply(quakes, .(level), summarise, mag=round(mean(mag), 1))

ggplot(quakes, aes(x=long, y=lat)) + 
  geom_point(aes(colour=mag)) + 
  geom_text(aes(label=mag), data=quakes.summary, x=185, y=-35) +
  facet_grid(~level) + 
  coord_map()
-------------------------------------------------------------------------------------------------------
tags <- c("tag1","tag2","tag3")
times <- c("2012-08-01 13:00:00","2012-08-07 21:00:00")
timesteps <- c("2m", "10m","60m", "90m")

# Use expand.grid to create an object with all the combinations
dat <- expand.grid(tags, times, timesteps)

# Rewrite query to take in a row of dat
query <- function(row) {
    # extract the pieces of interest
    tag <- row[1]
    time <- row[2]
    timestep <- row[3]

    sql <- paste("select tag, time, timestep, value from mydb where tag = '",tag,"' and time = '",time,"' and timestep = '",timestep,"'", sep="")

    # pretend the line below is actually querying a database and returning a DF with one row
    data.frame(tag = tag, time = time, timestep = timestep, value = rnorm(1))

}

# function works correctly on a single row  
query(dat[1,])

# apply the function to each row
j <- apply(dat, 1, query)
# bind all the output together
do.call(rbind, j)
-------------------------------------------------------------------------------------------------------
mdply mapply tags <- c("tag1","tag2","tag3")
times <- c("2012-08-01 13:00:00","2012-08-07 21:00:00")
timesteps <- c("2m", "10m","60m", "90m")


query <- function(tags, times, timesteps) {

  sql <- paste("select tag, time, timestep, value from mydb where 
            tag = '",tags,"' and time = '",times,"' and timestep = '",timesteps,"'", sep="")
  # pretend the line below is actually querying a database and returning a DF with one row
  data.frame(tag = tags, time = times, timestep = timesteps, value = rnorm(1))

}

dat <- expand.grid(tags, times, timesteps)
colnames(dat) <- c('tags','times','timesteps')

mdply(dat,query)
-------------------------------------------------------------------------------------------------------
myfun mydialog <- function(){

       xvar <- tclVar("1")
       yvar <- tclVar("2")
       zvar <- tclVar("3")

       tt <- tktoplevel()
       tkwm.title(tt,"MYTEST")
       x.entry <- tkentry(tt, textvariable=xvar)
       y.entry <- tkentry(tt, textvariable=yvar)
       z.entry <- tkentry(tt, textvariable=zvar)

       reset <- function()
        {
         tclvalue(xvar)<-""
         tclvalue(yvar)<-""
         tclvalue(zvar)<-""
        }

       reset.but <- tkbutton(tt, text="Reset", command=reset)

       submit <- function() {
         x <- as.numeric(tclvalue(xvar))
         y <- as.numeric(tclvalue(yvar))
         z <- as.numeric(tclvalue(zvar))
         print(x+y+z)
         tkmessageBox(message="Done!")
         #tkdestroy(tt)
       }
       submit.but <- tkbutton(tt, text="submit", command=submit)

       tkgrid(tklabel(tt,text="MYTEST"),columnspan=2)
       tkgrid(tklabel(tt,text="x variable"), x.entry)
       tkgrid(tklabel(tt,text="y variable"), y.entry)
       tkgrid(tklabel(tt,text="z variable"), z.entry)
       tkgrid(submit.but, reset.but)

    }

mydialog()
-------------------------------------------------------------------------------------------------------
offset <- with(mydata, 24*(gender == "Female") + 12*(age >= 12))
idxs <- expand.grid(row = 1:nrow(mydata), col = 1:12)
idxs$off <- idxs$col + offset
idxs$val <- as.numeric(mydata[as.matrix(idxs[c("row", "col")])]) + 1
idxs$norm <- normdf[as.matrix(idxs[c("val", "off")])]
converted <- mydata
converted[,1:12] <- as.matrix(idxs$norm, ncol=12) idxs normdf normdf normdf
-------------------------------------------------------------------------------------------------------
library(reshape2)
library(ggplot2)

mpwr <- melt(pwr, id.vars=1:3)

ggplot(mpwr, aes(x=tm, group=1)) + 
  geom_line(aes(y=value, colour=factor(batt_A!=0))) +
  geom_line(aes(y=value, colour=factor(batt_B!=0))) +
  facet_grid(~variable) +
  scale_colour_discrete("Charging")
-------------------------------------------------------------------------------------------------------
df df <- data.frame( 
      date = apply(expand.grid(2001:2012,1:12),1,paste,collapse="/"),
      x = rnorm(12^2,1000,1000),
      stringsAsFactors=FALSE) date tapply with(df, tapply(x, gsub("\\d{4}/","",date), mean))
-------------------------------------------------------------------------------------------------------
library("grid")
library("gridBase")
library("lattice")

# example from levelplot help page
x <- seq(pi/4, 5 * pi, length.out = 100)
y <- seq(pi/4, 5 * pi, length.out = 100)
r <- as.vector(sqrt(outer(x^2, y^2, "+")))
g <- expand.grid(x=x, y=y)
g$z <- cos(r^2) * exp(-r/(pi^3))
p <- levelplot(z~x*y, g, cuts = 50, scales=list(log="e"), xlab="",
               ylab="", main="lattice levelplot",
               colorkey=FALSE, region=TRUE)

grid.newpage()
pushViewport(viewport(layout=grid.layout(2, 1,
                                         heights=unit(c(2, 1), "null"))))
vp <- pushViewport(viewport(layout.pos.row=1, layout.pos.col=1))
par(omi=gridOMI())
# base graphics
plot(1:10, main="base graphics plot")
popViewport()
# lattice plot
vp <- pushViewport(viewport(layout.pos.row=2, layout.pos.col=1))
print(p, vp=vp, newpage=FALSE)
popViewport()
popViewport()
-------------------------------------------------------------------------------------------------------
library(lattice)

A<-matrix(ncol=2, nrow=64)

for(i in 0:63) {  A[i+1,1]<-sin(i/10)  
A[i+1,2]<-cos(i/10) }

Sigma<-matrix(c(0.5,0.1,0.1,0.25),byrow=TRUE,nrow=2) 
G<-eigen(Sigma)

E1<-t(G$vector%*%t(A)) 
E2<-t(diag(sqrt(G$values))%*%t(E1)) 
mu<-c(0.1,0.2) 
E3<-sweep(E2,2,-mu)

a<-sqrt(max(rowSums(sweep(E3,2,mu)**2))) 
b<-sqrt(min(rowSums(sweep(E3,2,mu)**2)))

astar<-as.numeric(a+abs(mu[1])) 
bstar<-as.numeric(b+abs(mu[2]))

xstar<-seq(-astar,astar,len=50) 
ystar<-seq(-bstar,bstar,len=50)

g<-expand.grid(x=xstar,y=ystar)

p1<-2*g$x*mu[1]/a**2+2*g$y*mu[2]/b**2 
p2<-(g$x**2/a**2+g$y**2/b**2) 
p3<-mu[1]**2/a**2+mu[2]**2/b**2-1

q<-(p1+sqrt(p1**2-4*p2*p3))/(2*p2) 
z<-sqrt(1-(q*g$x)**2-(q*g$y)**2) 
zstar<-(z/q) 
ind0<-!(q<1) 
g$z<-zstar 
sc<-matrix(c(rep(c(-1,-1,-1),sum(ind0))),nrow=sum(ind0),byrow=TRUE) 
gstar<-rbind(g[ind0,],sc*g[ind0,])

group<-c(rep(1,nrow(gstar)/2),rep(2,nrow(gstar)/2)) 
gstar$group<-group
gstar <- g 
gstar$z[!ind0] <- NA 
gstar$z2 <- -gstar$z 
wireframe(z + z2 ~ x * y, gstar, colorkey=TRUE,drape=TRUE, scales=list(arrows=FALSE))
-------------------------------------------------------------------------------------------------------
library(ggplot2)
London.melt$medal.type<-factor(London.melt$medal.type, levels = c("gold","silver","bronze"))
# Make every country unique
London.melt$country_l <- with(London.melt, paste(country, medal.type, sep = "_"))
#Reorder the unique countrys
q <- qplot(x = count, y = reorder(country_l, count), data = London.melt, geom = "point") +   facet_grid(medal.type ~., scales = "free_y")
# Rename the countries using the original names
q + scale_y_discrete("Country", breaks = London.melt$country_l, label = London.melt$country)
-------------------------------------------------------------------------------------------------------
toTest <- expand.grid(
    alpha = seq(0.1, 1, by = 0.1), 
    eta = seq(0.1, 1, by = 0.1), 
    gamma = seq(0.1, 1, by = 0.1))
ml <- apply(toTest, 1, function(x){
  exp(sum(x))
})
toTest[which.max(ml), ]
-------------------------------------------------------------------------------------------------------
image(x, col=c("red","blue")[1+(x>50)] ) grid(nx=100, ny=100, lty=1)
-------------------------------------------------------------------------------------------------------
group control, test1, test2 hospital_names <- list(
  'Hospital#1'="Some Hospital",
  'Hospital#2'="Another Hospital",
  'Hospital#3'="Hospital Number 3",
  'Hospital#4'="The Other Hospital"
) hospital_labeller <- function(variable,value){
  return(hospital_names[value])
}

ggplot(survey,aes(x=age)) + stat_bin(aes(n=nrow(h3),y=..count../n), binwidth=10)
 + facet_grid(hospital ~ ., labeller=hospital_labeller)
 ... plot_labeller <- function(variable,value){
  if (variable=='facet1') {
    return(facet1_names[value])
  } else {
    return(facet2_names[value])
  }
} facet1_names facet2_names
-------------------------------------------------------------------------------------------------------
import itertools
def expandgrid(*itrs):
   product = list(itertools.product(*itrs))
   return {'Var{}'.format(i+1):[x[i] for x in product] for i in range(len(itrs))}

>>> a = [1,2,3]
>>> b = [5,7,9]
>>> expandgrid(a, b)
{'Var1': [1, 1, 1, 2, 2, 2, 3, 3, 3], 'Var2': [5, 7, 9, 5, 7, 9, 5, 7, 9]} itertools.product product
-------------------------------------------------------------------------------------------------------
ggplot(df, aes(x = x, y = y),colour=val) +
  geom_tile(aes(fill = factor(val))) +
  facet_grid(. ~ facet_grid, scales = "free")+
  scale_fill_manual(labels=letters[1:4], values=c("red","blue","green","brown"))
-------------------------------------------------------------------------------------------------------
dat <- read.table(text="Species Trait.p  Trait.y   Trait.z
   a      20.1    7.2        14.1
   b      20.4    8.3        15.2
   b      19.2    6.8        13.9
   c      14.2    3.8        11.9", header=T)

li <- lapply(split(dat, dat$Species), function(x) apply(x[, -1], 2, max))

com <- expand.grid(names(li), names(li))
inds <- com[com[, 1] != com[, 2], ]
inds <- t(apply(inds, 1, sort))
inds <- inds[!duplicated(inds), ]

ans <- lapply(1:nrow(inds), function(i) {
    abs(li[[inds[i, 1]]]-li[[inds[i, 2]]])
})
cbind(Combination = paste(inds[, 1], inds[, 2], sep="/"), 
    as.data.frame(do.call(rbind, ans))) Combination Trait.p Trait.y Trait.z
1         a/b     0.3     1.1     1.1
2         a/c     5.9     3.4     2.2
3         b/c     6.2     4.5     3.3
-------------------------------------------------------------------------------------------------------
expand.grid integrate $value t av <- seq(from=50,to=60,by=0.01)
bv <- seq(from=130,to=140,by=0.01)
sv <- seq(from=0.0001,to=0.01,by=0.0001)
tv <- c(seq(from=0,to=60,by=20),seq(from=120,to=360,by=120))
con <- 55

##method 1: using built-in functions (warning: can be slower and memory-intensive)
cmb <- expand.grid(list(av=av,bv=bv,sv=sv,tv=tv))
cmb <- within(cmb,{
    u <- ifelse(tv - av < 0 ,0, tv - av)
    l <- ifelse(tv - (av+bv) < 0,0, tv - (av+bv))
    value <- sv * mapply(function(...){integrate(...)$value},
        lower=l,upper=u,
        MoreArgs=list(f=Vectorize(function(x,constant){constant}),constant=con))
})

##method 2: using package data.table (for speed and efficient memory use)
dt.av <- data.table(av,k=1,key="k")
dt.bv <- data.table(bv,k=1,key="k")
dt.sv <- data.table(sv,k=1,key="k")
dt.tv <- data.table(tv,k=1,key="k")
cmb <- dt.av[dt.bv[dt.sv[dt.tv]]] #joins together
cmb[,u := ifelse(tv - av < 0 ,0, tv - av)]
cmb[,l := ifelse(tv - (av+bv) < 0,0, tv - (av+bv))]
cmb[,value:=mapply(function(...){integrate(...)$value},
    lower=l,upper=u,
    MoreArgs=list(f=Vectorize(function(x,constant){constant}),constant=con)
)]
-------------------------------------------------------------------------------------------------------
check.dup <- expand.grid(names(dat),names(dat)) #find all variable pairs
check.dup[check.dup$Var1 != check.dup$Var2,] #take out self-reference
check.dup$id <- mapply(function(x,y) {
        x <- as.character(x); y <- as.character(y)
            #if number of levels is different, discard; keep the number for later
        if ((n <- length(unique(dat[,x]))) != length(unique(dat[,y])))  {
            return(FALSE)
            }
            #subset just the variables in question to get pairs
        d <- dat[,c(x,y)]
            #find unique pairs
        d <- unique(d)
            #if number of unique pairs is the number of levels from before,
            #then the pairings are one-to-one
        if( nrow(d) == n ) {
            return(TRUE)
        } else return(FALSE)
    },
    check.dup$Var1,
    check.dup$Var2
)
-------------------------------------------------------------------------------------------------------
expand.grid merge grid <- with(mydata, expand.grid(ForSortSNP=unique(ForSortSNP), SortOrder=unique(SortOrder)))
complete <- merge(mydata, grid, all=TRUE, sort=FALSE)
complete[is.na(complete)] <- 0 # replace NAs with 0's
complete <- complete[order(complete$ForSortSNP, complete$SortOrder), ] # re-sort
-------------------------------------------------------------------------------------------------------
density.ppp NA library(maptools)
library(sp)
library(spatstat)

xx <- readShapePoly(system.file("shapes/sids.shp", package="maptools")[1],
      IDvar="FIPSNO", proj4string=CRS("+proj=longlat +ellps=clrk66"))

x <- rnorm(25, -80, 2)
y <- rnorm(25, 35, 1 )

tmp <- density( ppp(x,y, xrange=range(x), yrange=range(y)) )
plot(tmp)
plot(xx, add=TRUE)
points(x,y)

tmp2 <- SpatialPoints( expand.grid( tmp$yrow, tmp$xcol )[,2:1],
    proj4string=CRS(proj4string(xx)) )

tmp3 <- over( tmp2, xx )

tmp$v[ is.na( tmp3[[1]] ) ] <- NA

plot(tmp)
plot(xx, add=TRUE)
-------------------------------------------------------------------------------------------------------
apply "your function" # example data
xs <- rnorm(10)
ys <- rnorm(10)    

apply(expand.grid(xs, ys), 1, FUN = function(x) {"your function"}) apply(expand.grid(xs, ys), 1, FUN = function(x) {x[1] + x[2]}) xs ys x[1] x[2] myfun <- function(xs, ys) xs + ys
arguments <- expand.grid(xs = rnorm(10), ys = rnorm(10))
apply(arguments, 1, function(x)do.call(myfun, as.list(x)))
-------------------------------------------------------------------------------------------------------
outer dfrm <- expand.grid(grain$months,  colnames(cost) ) costcros <- function(x) { sum(grain[ grain[, 'months'] == x[1], c(1,2,4)]*c(0.1,0.3,0.6) ) + 
                           sum( cost[, x[2]]) } dfrm$crosscost <- apply(expand.grid(grain$months,  colnames(cost) ), 1,  costcros)
-------------------------------------------------------------------------------------------------------
hyp NA facet_wrap facet_grid ldt <-complete(impute,"long", include=TRUE)

ggplot(ldt[!is.na(ldt$hyp),], aes(x= factor(hyp))) + 
  geom_bar() + 
  facet_wrap(~.imp, nrow = 1) +
  xlab('Observed') +
  scale_y_continuous(expand = c(0,0)) facet_grid scales = 'free_y' all_long <- melt(ldt, c(".imp",".id","hyp"))
ggplot(all_long[!is.na(all_long$hyp),], aes(x= factor(hyp))) + 
  geom_bar() + 
  facet_grid(variable ~.imp, scales = 'free_y') +
  xlab('Observed') +
  scale_y_continuous(expand = c(0,0))
-------------------------------------------------------------------------------------------------------
# make a data.frame with all possible combinations of kwd1 and kwd2.
# the ones that aren't in df are NA for sim.
k <- merge(expand.grid(kwd1=df$kwd1, kwd2=df$kwd2), df, all=TRUE)
# order the result to put the NA rows at the end, so that rows that are in df 
# have priority in the following step.
k <- k[order(k$sim), ]
# remove all rows where the kwd1-kwd2 combo appears earlier in the data.frame
k <- k[! duplicated(apply(k[1:2], MARGIN=1, sort), MARGIN=2), ]
# assuming you don't want the rows where kwd1 and kwd2 are the same, remove them.
k <- subset(k, kwd1 != kwd2)
# set the NA values to 0
k[is.na(k)] <- 0

   kwd1 kwd2 sim
5     a    b 0.1
7     a    c 0.2
12    b    c 0.0
-------------------------------------------------------------------------------------------------------
library(plyr)
res <- merge(expand.grid(kwd1 = unique(c(df$kwd1, df$kwd2)), 
kwd2 = unique(c(df$kwd1, 
    df$kwd2))), df, all.x = T)

res <- ddply(res, .(kwd1, kwd2), function(x) {
    if (which(letters == x$kwd1) != which(letters == x$kwd2)) {
        if (which(letters == x$kwd1) > which(letters == x$kwd2)) {
            return(data.frame(kwd1 = x$kwd2, kwd2 = x$kwd1, sim = x$sim))
        } else {
            return(x)
        }
    }
})
res1 <- res[!duplicated(res), ] 

> res1
  kwd1 kwd2 sim
1    a    b 0.1
2    a    c 0.2
4    b    c  NA convert_df <- function(df) {
    res <- merge(expand.grid(kwd1 = unique(c(df$kwd1, df$kwd2)), 
kwd2 = unique(c(df$kwd1, 
    df$kwd2))), df, all.x = T)
res <- ddply(res, .(kwd1, kwd2), function(x) {
    if (which(letters == x$kwd1) != which(letters == x$kwd2)) {
        if (which(letters == x$kwd1) > which(letters == x$kwd2)) {
            return(data.frame(kwd1 = x$kwd2, kwd2 = x$kwd1, sim = x$sim))
        } else {
            return(x)
        }
    }
})
 return(res[!duplicated(res), ])
}
# Then simply run this to convert your actual data.frame
convert_df(df)
-------------------------------------------------------------------------------------------------------
ggplot2 facet_wrap library(ggplot2)
mydata = data.frame(x=as.factor(rep(1:2, 5, each=5)), y=rnorm(50),
        division=rep(letters[1:5], each=10))

print(ggplot(mydata, aes(x, y)) + geom_boxplot() + facet_wrap(~division)) facet_grid print(ggplot(data, aes(repetition, energy.level)) + geom_boxplot() + facet_grid(route ~ packet))
-------------------------------------------------------------------------------------------------------
mat <- matrix(c("A","B","A",
                "A","A","B",
                "B","A","A"), ncol = 3, byrow = TRUE) expand.grid() mat mat > ind <- expand.grid(r1 = 1:3, r2 = 1:3)
> ind
  r1 r2
1  1  1
2  2  1
3  3  1
4  1  2
5  2  2
6  3  2
7  1  3
8  2  3
9  3  3 r2 r1 mat ind ind paste0() > matrix(paste0(mat[ind[,2], ], mat[ind[,1], ]), ncol = 3)
      [,1] [,2] [,3]
 [1,] "AA" "BB" "AA"
 [2,] "AA" "BA" "AB"
 [3,] "AB" "BA" "AA"
 [4,] "AA" "AB" "BA"
 [5,] "AA" "AA" "BB"
 [6,] "AB" "AA" "BA"
 [7,] "BA" "AB" "AA"
 [8,] "BA" "AA" "AB"
 [9,] "BB" "AA" "AA" paste0() > paste0(mat[ind[,2], ], mat[ind[,1], ])
 [1] "AA" "AA" "AB" "AA" "AA" "AB" "BA" "BA" "BB" "BB" "BA" "BA" "AB" "AA" "AA"
[16] "AB" "AA" "AA" "AA" "AB" "AA" "BA" "BB" "BA" "AA" "AB" "AA" paste0() ind paste0() > mat[ind[,2], ]
      [,1] [,2] [,3]
 [1,] "A"  "B"  "A" 
 [2,] "A"  "B"  "A" 
 [3,] "A"  "B"  "A" 
 [4,] "A"  "A"  "B" 
 [5,] "A"  "A"  "B" 
 [6,] "A"  "A"  "B" 
 [7,] "B"  "A"  "A" 
 [8,] "B"  "A"  "A" 
 [9,] "B"  "A"  "A" 
> mat[ind[,1], ]
      [,1] [,2] [,3]
 [1,] "A"  "B"  "A" 
 [2,] "A"  "A"  "B" 
 [3,] "B"  "A"  "A" 
 [4,] "A"  "B"  "A" 
 [5,] "A"  "A"  "B" 
 [6,] "B"  "A"  "A" 
 [7,] "A"  "B"  "A" 
 [8,] "A"  "A"  "B" 
 [9,] "B"  "A"  "A"
-------------------------------------------------------------------------------------------------------
M <- matrix(c("A","B","A","A","A","B","B","A","A"), ncol = 3, byrow = TRUE)
rownames(M) <- c("Line1","Line2","Line3")
colnames(M) <- c("M1","M2","M3") expand.grid() d <- expand.grid(rownames(M), rownames(M)) Var1  Var2
1 Line1 Line1
2 Line2 Line1
3 Line3 Line1
4 Line1 Line2
5 Line2 Line2
6 Line3 Line2
7 Line1 Line3
8 Line2 Line3
9 Line3 Line3 apply() apply(d, 1, function(x) { paste(M[x[1],], paste(M[x[2],]), sep="")} ) [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]
[1,] "AA" "AA" "BA" "AA" "AA" "BA" "AB" "AB" "BB"
[2,] "BB" "AB" "AB" "BA" "AA" "AA" "BA" "AA" "AA"
[3,] "AA" "BA" "AA" "AB" "BB" "AB" "AA" "BA" "AA" df <- data.frame( d, t(apply(d, 1, function(x) { paste(M[x[1],], paste(M[x[2],]), sep="")} ))
colnames(df) <- c("X","Y","M1","M2", "M3") get.it <- function(M){ 
    d <- expand.grid(rownames(M), rownames(M))
    e <- t(apply(d, 1, function(x) { paste(M[x[1],], paste(M[x[2],]), sep="")} ))
    output<- data.frame( d, e)
    colnames(output) <- c("X","Y","M1","M2","M3")
return(output)
} get.it(M)
-------------------------------------------------------------------------------------------------------
data.table i by library(data.table)
DT <- data.table(my.data)
DT[year==2001, .SD[which.max(births)]] DT[year==2001][which.max(births)] my.data <- expand.grid(
  Country = c('Swaziland', 'Australia', 'Tuvalu', 'Turkmenistan'),
  year = 1990:2012 )
my.data$births <- rpois(nrow(my.data), lambda = 500)
DT <- data.table(my.data)
DT[year==2001, .SD[which.max(births)]]

##      Country year births
## 1: Swaziland 2001    501 births_2001 <- subset(my.data, year == 2001)
births_2001[which.max(births_2001$births),]

##      Country year births
## 45 Swaziland 2001    501
-------------------------------------------------------------------------------------------------------
dta = data.frame(expand.grid(x1=1:5,x2=2:6,x3=5:10))
dta$y = with(dta,x1+2*x2 + 3*x3^2)
head(dta)
  x1 x2 x3  y
1  1  2  5 80
2  2  2  5 81
3  3  2  5 82
4  4  2  5 83
5  5  2  5 84
6  1  3  5 82 bw <- npcdensbw(formula = y ~ x1+x2+x3,data=dta) head(gradients(npcdens(bws=bw,gradients=TRUE)))

              [,1]          [,2]           [,3]
[1,] -2.024422e-15 -2.048994e-50 -1.227563e-294
[2,] -1.444541e-15 -1.994174e-50 -1.604693e-294
[3,] -1.017979e-31 -1.201719e-50 -1.743784e-294
[4,]  1.444541e-15 -6.753912e-64 -1.604693e-294
[5,]  2.024422e-15  1.201719e-50 -1.227563e-294
[6,] -2.024422e-15 -3.250713e-50 -1.227563e-294 bw <- npcdensbw(formula = log(y) ~ x1 + x2 + x3,data=dta) help(npcdensbw)
-------------------------------------------------------------------------------------------------------
qplot(prevRT, RT, group=ss, color = prim, 
 geom = c("smooth"), 
 method="lm", data =ss) + 
 facet_grid(~ Groupe) + 
 geom_rect(data=ss, 
      aes(xmin=ave(ss$RT, ss$Groupe, FUN = function(x)quantile(x,c(0.05))),      
      xmax=ave(ss$RT, ss$Groupe, FUN = function(x)quantile(x,c(0.95))),
      ymin=-Inf,ymax=Inf), color="green", alpha=1/280, inherit.aes = FALSE)
-------------------------------------------------------------------------------------------------------
library(gridExtra)
p1 <- ggplot(subset(dd, var=="C"), aes(x,y))+
  geom_raster(aes(fill=z)) + facet_grid(type ~ var) + 
  theme(legend.position="bottom", plot.margin = unit(c(1,-1,1,0.2), "line"))
p2 <- ggplot(subset(dd, var=="D"), aes(x,y))+
  geom_raster(aes(fill=z)) + facet_grid(type ~ var) + 
  theme(legend.position="bottom", plot.margin = unit(c(1,1,1,-0.8), "line"),
        axis.text.y = element_blank(), axis.ticks.y = element_blank()) + ylab("")
grid.arrange(arrangeGrob(p1, p2, nrow = 1)) plot.margin
-------------------------------------------------------------------------------------------------------
stat_smooth(method="lm") library(ggplot2)
x <- rnorm(100)
y <-  + .7*x + rnorm(100)
f1 <- as.factor(c(rep("A",50),rep("B",50)))
f2 <- as.factor(rep(c(rep("C",25),rep("D",25)),2))
df <- data.frame(cbind(x,y))
df$f1 <- f1
df$f2 <- f2

ggplot(df,aes(x=x,y=y))+geom_point()+facet_grid(f1~f2)+stat_smooth(method="lm",se=FALSE) geom_abline() ggplot(df,aes(x=x,y=y))+geom_point()+facet_grid(f1~f2)+geom_abline(intercept = 0, slope = 1 )
-------------------------------------------------------------------------------------------------------
scales geom_area geom_line geom_line theme_bw p <- ggplot(mymelt, aes(x = mydate, y = value)) +
  geom_line(lwd=0.3) +
  facet_grid(. ~ variable) +
  theme_bw() +
  theme(axis.text.x = element_text(size = 5, angle = 90),
        axis.text.y = element_text(size = 8),
        axis.title.x = element_text(vjust = 0),
        axis.ticks = element_blank(), 
        panel.grid.minor = element_blank())
print(p)
ggsave(plot=p, filename="plot.png", width = 8, height = 4)
-------------------------------------------------------------------------------------------------------
barplot = ggplot(data=df1, aes(x=Background, y=Count, fill=Background)) +   
  geom_bar(position='dodge') + 
  facet_grid(.~Condition)
-------------------------------------------------------------------------------------------------------
expand.grid > eg <- expand.grid(colnames(x[, -1]), x[, 1])
> setNames(as.numeric(t(x[, -1])), paste(eg[[2]], eg[[1]], sep="."))
               journal.count                 journal.rank 
                    13972.00                     13759.00 
                 journal.pct                    all.count 
                       98.48                    754555.00 
                    all.rank                      all.pct 
                   754043.00                        99.93 
        similar_age_1m.count          similar_age_1m.rank 
                    22408.00                     22339.00 
          similar_age_1m.pct         similar_age_3m.count 
                       99.69                     56213.00 
         similar_age_3m.rank           similar_age_3m.pct 
                    56074.00                        99.75 
similar_age_journal_1m.count  similar_age_journal_1m.rank 
                      508.00                       459.00 
  similar_age_journal_1m.pct similar_age_journal_3m.count 
                       90.35                      1035.00 
 similar_age_journal_3m.rank   similar_age_journal_3m.pct 
                      947.00                        91.50
-------------------------------------------------------------------------------------------------------
df <- expand.grid(A=A, B=B)
df$val <- with(df, A*B))
# then pass that triple column set of i,j, and values to the sparse matrix constructors.
-------------------------------------------------------------------------------------------------------
interaction h<-histogram(~star|interaction(stat, var,  sep="\n") + n, data=testData  , 
              as.table=T ,layout=c(4,3), type="density", breaks=20 ,  
panel=function(x,params,...){ panel.grid() 
panel.histogram(x,...,col=1) 
panel.curve(dnorm(x,0,1), type="l",col=2) } ) 
plot(h) 
useOuterStrips(h,strip.left = strip.custom(horizontal = FALSE), 
                  strip.lines=2, strip.left.lines=1) useOuterStrips
-------------------------------------------------------------------------------------------------------
mapply # Get the inputs we want
years <- 2000:2010
months <- sprintf("%02d", 5:9)
dat <- expand.grid(months = months, years = years)

# Construct a function that gets the query given the month and year
getVal <- function(month, year){
    query <- paste0("SELECT sdci_", 
                    year, "_", month, "_mean as '", 
                    year, "/", month, 
                    "/01' from gr_sea_outlets_tier2 order by",
                    " area_km2 desc limit 1;")
    #dbGetQuery(db, query)
    query
}

# Actually apply the function to each month/year combo of interest
out <- mapply(getVal, dat$months, dat$years) dbGetQuery dbGetQuery for mapply dat <- list()
for(month in months){
    for(year in years){
        id <- paste(year, month, 1, sep = "/")
        dat[[id]] <- getVal(month, year)
    }
}
-------------------------------------------------------------------------------------------------------
facet_grid facet_wrap labeller facet_wrap labeller x x <-
structure(list(Date = structure(c(-719143, -718778), class = "Date"), 
    Duration = c(10L, 3L), Test = c("This is the first that took place on1/1/2012", 
    "This test peformed the best result")), .Names = c("Date", 
"Duration", "Test"), row.names = c(NA, -2L), class = "data.frame") library("plyr")
label_wrap_gen <- function(width = 25) {
    function(variable, value) {
      laply(strwrap(as.character(value), width=width, simplify=FALSE), 
            paste, collapse="\n")
    }
} ggplot(x, aes(Date, Duration, group=Test, colour=Test)) + 
  geom_point() +
  facet_grid(~Test, scale="free", labeller=label_wrap_gen(width=10)) + 
  opts(strip.text.x = theme_text(size=8, colour="navyblue")) facet_grid Test facet_wrap x$Test <- laply(strwrap(as.character(x$Test), width=10, simplify=FALSE), 
                paste, collapse="\n")
ggplot(x, aes(Date, Duration, group=Test, colour=Test)) + 
  geom_point() +
  facet_wrap(~Test, scale="free") + 
  opts(strip.text.x = theme_text(size=8, colour="navyblue"))
-------------------------------------------------------------------------------------------------------
dat <- data.frame(facetvar=letters[1:5], yvar=rep(1:10, each=5), xvar=rep(letters[6:10], each=5))
ggplot(dat, aes(x=xvar, y=yvar, group=facetvar)) + 
    geom_bar(stat='identity') + 
    facet_grid(facetvar~.) ggplot(dat[sample(1:50, 40),], aes(x=xvar, y=yvar, group=facetvar)) + 
    geom_bar(stat='identity') + 
    facet_grid(facetvar~.) scales.y='free' facet_grid()
-------------------------------------------------------------------------------------------------------
set.seed(1234)
data <-
expand.grid(month = month.abb,building = c("Building A", "Building B", "Building C"),hc = c("Heating", "Cooling"))
data$value <- rnorm(nrow(data), 60, 10) hc building ggplot(data, aes(building,value,group=month)) + 
  geom_bar(stat = 'identity',
           position = 'dodge',
           aes(fill = interaction(building, hc))) RColorBrewer colours <- c("#FC9272", "#FB6A4A", "#EF3B2C", "#9ECAE1", "#6BAED6", "#4292C6")
# library("RColorBrewer")
# colours <- c(brewer.pal(9,"Reds")[4:6], brewer.pal(9,"Blues")[4:6]) scale_fill_manual ggplot(data, aes(building,value,group=month)) + 
  geom_bar(stat = 'identity',
           position = 'dodge',
           aes(fill = interaction(building, hc))) +
  scale_fill_manual(values=colours) ggplot(data, aes(building,value,group=month)) + 
  geom_bar(stat = 'identity',
           position = 'dodge',
           aes(fill = interaction(building, hc))) +
  scale_fill_manual("Heating/cooling",
                    values=colours,
                    breaks=c("Building B.Heating", "Building B.Cooling"),
                    labels=c("Heating", "Cooling"))
-------------------------------------------------------------------------------------------------------
ggplot plyr multiplot require(plyr)
require(ggplot2)

indep.dep.cor <- function(xts.obj, title=""){

        # First column always assumed to be independent
        df <- data.frame(coredata(xts.obj))
        assign('df',df,envir=.GlobalEnv)

        df.l <- melt(df, id.vars=colnames(df)[1], measure.vars=colnames(df)[2:ncol(df)])
        assign('df.l',df.l, envir=.GlobalEnv)

        cor.vals <- ddply(df.l, c("variable"), summarise, round(cor(df[,1],value),3))
        stars <- ddply(df.l, c("variable"), summarise, symnum(cor.test(df[,1],value)$p.value, corr = FALSE, na = FALSE, cutpoints = c(0, 0.001, 0.01, 0.05, 0.1, 1), symbols = c("***", "**", "*", ".", " ")))
        cor.vals$stars <- stars[,2]
        assign('cor.vals',cor.vals,envir=.GlobalEnv)

        bin.w <- min((ddply(df.l,c("variable"),summarise,diff(range(value))/30))[,2])

        m1 <- ggplot(df.l,aes_string(x="value"))+
            facet_grid(.~variable)+
            stat_density(aes(y=..density..),fill=NA, colour="red", size=1.2)+
            geom_histogram(aes(y=..density..),fill="white", colour="black", binwidth=bin.w)+
            opts(title=title)

        m2 <- ggplot(df.l,aes_string(x=colnames(df.l)[1], y="value"))+
            facet_grid(.~variable)+geom_point(aes(alpha=0.2))+
            opts(legend.position="none")+
            geom_text(data=cor.vals,aes(label=paste(cor.vals[,2],cor.vals[,3]),size=abs(cor.vals[,2])*2,colour=cor.vals[,2]),x=Inf,y=Inf,vjust=1,hjust=1,show_guide=FALSE)+
                scale_colour_gradient(low = "red", high="blue")+
                geom_smooth(method="loess")

        multiplot(m1,m2,cols=1)
}

indep.dep.cor(d)
-------------------------------------------------------------------------------------------------------
ggplot2 as.data.frame() quoted_df labs X <-data.frame(
  PonOAC = rep(c('a','b','c','d'),2),
  AgeGroup = rep(c("over 80",'under 80'),each=4),
  NumberofPractices = rpois(8,70)
  ) ggplot(X, aes(x=PonOAC,y=NumberofPractices, fill=AgeGroup)) +
  geom_bar() +
  facet_grid(AgeGroup~ .) + 
  labs(x="% on OAC", y="Number of Practices",fill = "Age Group")
-------------------------------------------------------------------------------------------------------
dodge <- position_dodge(width = 0.9)

g <- ggplot(df, aes(x=treatment, y=mean, group=replicate, fill=replicate))
g <- g + geom_bar(position=dodge, stat="identity")
g <- g + geom_errorbar(aes(ymax=mean+sd, ymin=mean-sd), position = dodge,width = 0.25)
g <- g +  facet_grid(. ~ sample)
g
-------------------------------------------------------------------------------------------------------
d <- data.frame(x=c(1,1.1),
                y=c(1,1),
                z=c(2,3))

library(lattice)
wireframe(z~y*x,data=d) d2 <- data.frame(expand.grid(x=c(1,1.1),
                             y=c(1,1.1)),
                 z=1:4)
wireframe(z~y*x,data=d2) y debug() lattice R lattice:::panel.3dwire wireframePanelCalculations nh = (nx-1) * (ny-1) * ng; /* number of quadrilaterals */
sHeights = PROTECT(allocVector(REALSXP, nh)); nx
-------------------------------------------------------------------------------------------------------
mclapply df <- expand.grid(i = 1:10, j = 1:2 , k = seq(100, 500, 100))
params <- mapply(list, n = df[, 3], mu = df[, 1], stdev = df[,2], SIMPLIFY = F)

ff <- function(tlist) {
    n <- tlist$n 
    mu <- tlist$mu 
    stdev <- tlist$stdev
     x1 <- c(1:n)
     y1 <- rnorm(n,mu,stdev)
     z1 <- data.frame(cbind(x1,y1))
     ggplot(z1, aes(x=x1,y=y1))+
       geom_point()+
       labs(title=paste("n=",n,"mu=",mu, "stdev=",stdev))
}

results <- llply(params, ff, .progress='text') mclapply results <- mclapply(params, ff, mc.cores = 4, mc.preschedule = TRUE)
-------------------------------------------------------------------------------------------------------
ggsave() ff() ff <- function(n, mu, stdev){
  x1 <- c(1:n)
  y1 <- rnorm(n,mu,stdev)
  z1 <- data.frame(cbind(x1,y1))
  ggplot(z1, aes(x=x1,y=y1))+
    geom_point()+
    labs(title=paste("n=",n,"mu=",mu, "stdev=",stdev))
  ggsave(paste0(n,"_", mu, "_", stdev, ".jpeg"))
} expand.grid() x <- expand.grid(i = 1:10, j = 1:2, k = seq(100,500,100)) lapply() mclapply() lapply(seq(nrow(x)), function(i) ff(x[i,2], x[i,1], x[i,3]))
-------------------------------------------------------------------------------------------------------
diamonds_sample <- diamonds[sample(nrow(diamonds), 100), ]

melted_diamonds <- melt(diamonds_sample, measure.vars=c('x','y','z'),
  variable_name='letter')
# rename the melt results to avoid confusion with next melt
# (bug in melt means you can't rename the value during melt)
names(melted_diamonds)[9] <- 'letter.value'

melted_diamonds <- melt(melted_diamonds, 
  measure.vars=c('depth', 'price', 'carat'), variable_name='variables')

ggplot(melted_diamonds, aes(x=letter.value, y=value, colour=cut)) +
  geom_point() + facet_grid(variables~letter, scale='free')
-------------------------------------------------------------------------------------------------------
n <- 5
    k <- dim(X)[1]
    F <- matrix(0,n,n^3)
    colnames(F) <- simplify2array(apply(expand.grid(1:n,1:n,1:n ), 1, paste, collapse =" ", sep = ""))
    for(i in 1:k)
    {
for(j in 1:4){
per <- simplify2array(permn(X[i,-j]))
pert_charac <- apply(per,2,paste,sep="",collapse=" ")
num <- sapply(pert_charac,f <- function(x) which(colnames(F)==x))
F[X[i,j],num] <- F[X[i,j],num]+1
    }
 }
-------------------------------------------------------------------------------------------------------
ggplot(data=df.dose, aes(x=sample.size, y=as.factor(z), colour=type)) +
    geom_point() + facet_grid(true.dose~effect.size) ggplot(data=df.dose, aes(x=sample.size, y=as.factor(z), colour=type)) +
    geom_point() + facet_grid(true.dose~effect.size, scales="free")
-------------------------------------------------------------------------------------------------------
?stat_boxplot

data<-data.frame(cat=c('A','A','A','A','B','B','A','A','A','A','B','B'), 
             values=c(3,2,1,4,NA,NA,4,5,6,7,8,9), 
             ind=c('x','x','x','x','x','x','y','y','y','y','y','y'))

p <- ggplot(data = data, aes(factor(cat), values))                     
p + stat_boxplot(geom="boxplot", position = "dodge", width = 0.60, na.rm = TRUE) +  facet_grid(.~ind) p <- ggplot(data, aes(factor(cat), values, fill = ind))                     
p + stat_boxplot(geom="boxplot", position = "dodge", width = 0.60, na.rm = TRUE) + facet_grid(.~ind)
-------------------------------------------------------------------------------------------------------
eeyore <- function(fun, ...){
    if(!is.character(fun)) fun <- as.character(substitute(fun))

f <- match.fun(fun)
args <- as.list(substitute(list(...)))[-1]
foo <- expand.grid(llply(args, eval))
foo$F <- apply(foo, 1, function(x) { f(x[[1]], x[[2]])})
foo
}

d <- eeyore(m, 1:30, c(40,60,80,100))
-------------------------------------------------------------------------------------------------------
Year ggplot Year ggplot scale_x_continuous breaks ggplot(df, aes(x=as.numeric(as.character(Year)), y=sd, colour=Ratio)) +
geom_point() +
facet_grid(Ratio~.) +
theme(axis.text.x  = element_text(angle=-90, hjust=0.5, size=11,colour="black")) +
scale_x_continuous(breaks = as.numeric(levels(df$Year))[c(TRUE, rep(FALSE, 19))])
-------------------------------------------------------------------------------------------------------
library(png)

#Replace the directory and file information with your info
ima <- readPNG("C:\\Documents and Settings\\Bill\\Data\\R\\Data\\Images\\sun.png")

#Set up the plot area
plot(1:2, type='n', main="Plotting Over an Image", xlab="x", ylab="y")

#Get the plot information so the image will fill the plot box, and draw it
lim <- par()
rasterImage(ima, lim$usr[1], lim$usr[3], lim$usr[2], lim$usr[4])
grid()
lines(c(1, 1.2, 1.4, 1.6, 1.8, 2.0), c(1, 1.3, 1.7, 1.6, 1.7, 1.0), type="b", lwd=5, col="white")
-------------------------------------------------------------------------------------------------------
d <- transform(expand.grid(x=seq(-2,2,length=51),
            y=seq(-2,2,length=51)),z=x^2+3*x*y+4*x+2*y+2*y^2) geom_contour g1 <- qplot(x,y,z=z,data=d,colour=factor(..level..),geom="contour") stat_contour stat_contour() levels contour() contourLines() g1 + scale_colour_discrete(breaks="0",limits=c("0","0"),na.value=NA,
                          guide="none")
-------------------------------------------------------------------------------------------------------
sum(do.call("*", expand.grid(x, y)))
sum(outer(x, y)) ## or equivalently: sum(x %o% y)
sum(sapply(split(x, x), function(z) z * y))
-------------------------------------------------------------------------------------------------------
geom_tile ggplot2 require(ggplot2); theme_set(theme_bw())
require(plyr)
dat = data.frame(expand.grid(x = 1:10, y = 1:10),
                 z = sample(LETTERS[1:3], size = 100, replace = TRUE)) x x dat y y z p = ggplot(dat, aes(x = x, y = y, fill = z)) + geom_tile() 
print(p) ggplot2 p + coord_polar() dat
-------------------------------------------------------------------------------------------------------
> DT <- CJ(1:100,1:100)
> key(DT)
[1] "V1" "V2" > system.time(CJ(1:1000,1:10000))
   user  system elapsed 
   3.40    0.25    3.73 
> system.time(data.table(expand.grid(1:1000,1:10000),key=c("Var1","Var2")))
   user  system elapsed 
   4.14    0.68    4.90
-------------------------------------------------------------------------------------------------------
..x.. geom_bar ggplot numeric scale_fill_brewer ggplot(test, aes(x= test2, group = test1)) + 
   geom_bar(aes(y = ..density.., fill = factor(..x..))) + 
   facet_grid(~test1) + 
   scale_fill_brewer(name = 'test2', breaks = 1:6, 
                     labels = levels(test$test2), palette = 'Set3') ..x.. ggplot(test, aes(x= test2, group = test1)) + 
  geom_bar(aes(y = ..density.., fill = ..x..)) +
   facet_grid(~test1)
-------------------------------------------------------------------------------------------------------
opts theme_text theme element_text qplot(hwy, cty, data = mpg) + 
      facet_grid(. ~ manufacturer) + 
      theme(strip.text.x = element_text(size = 8, colour = "red", angle = 90))
-------------------------------------------------------------------------------------------------------
# Sample data
DT <- data.table(Month = sample(c(1,3:12), 100, replace = TRUE),
  Day = sample(1:30, 100, replace = TRUE), key = "Month,Day")

# Dates that you want to exclude
excl <- as.data.table(rbind(expand.grid(6, 15:30), expand.grid(7, 1:15)))

DT[-na.omit(DT[excl, which = TRUE])] na.omit
-------------------------------------------------------------------------------------------------------
expand.grid(list.1, list.b) data.frame apply lapply result.df <- expand.grid(list.a, list.b)
result.list <- lapply(apply(result.df, 1, identity), unlist) result.list <- result.list[order(sapply(result.list, head, 1))]
-------------------------------------------------------------------------------------------------------
expand.list <- function(...){
   lapply(as.data.frame(t((expand.grid(...)))),c, recursive = TRUE, use.names = FALSE)}

 expand.list(list.a, list.b)
-------------------------------------------------------------------------------------------------------
#some example data
set.seed(42)
df <- data.frame(x = rep(1:10,each=5), y = rnorm(50))

#calculate mean, min and max for each x-value
library(plyr)
df2 <- ddply(df,.(x),function(df) c(mean=mean(df$y),min=min(df$y),max=max(df$y)))

#plot error bars
library(Hmisc)
with(df2,errbar(x,mean,max,min))
grid(nx=NA,ny=NULL)
-------------------------------------------------------------------------------------------------------
data.table list i [.data.table .period <- seq(from = as.Date("2010/1/1", "%Y/%m/%d"), to = as.Date("2012/1/1", 
    "%Y/%m/%d"), by = "3 months")
.size <- c("XS", "S", "M", "L", "XL")
.number <- as.character(1:100)
DF <- expand.grid(Period = .period, Size = .size, Number = .number, stringsAsFactors = F)

DF$other <- rnorm(nrow(DF))

library(data.table)

DT <- as.data.table(DF)

DT[, `:=`(Period, as.IDate(.period))]


##           Period Size Number    other
##    1: 2010-01-01   XS      1  0.17947
##    2: 2010-04-01   XS      1  1.43252
##    3: 2010-07-01   XS      1 -0.97142
##    4: 2010-10-01   XS      1 -0.98021
##    5: 2011-01-01   XS      1 -0.62964
##   ---                                
## 4496: 2011-01-01   XL    100  0.65831
## 4497: 2011-04-01   XL    100 -0.45277
## 4498: 2011-07-01   XL    100 -0.14236
## 4499: 2011-10-01   XL    100 -0.02376
## 4500: 2012-01-01   XL    100 -0.11525

all_filters <- list(Period = as.IDate(as.Date("2010/1/1", format = "%Y/%m/%d")), 
    Size = "L", Number = c("11", "21", "35", "42", "45", "47", "49", "52", "57"))


setkeyv(DT, names(all_filters))

DT[all_filters]

##        Period Size Number   other
## 1: 2010-01-01    L     11  1.4122
## 2: 2010-01-01    L     21 -0.4923
## 3: 2010-01-01    L     35  1.1262
## 4: 2010-01-01    L     42  1.3527
## 5: 2010-01-01    L     45 -0.3758
## 6: 2010-01-01    L     47 -0.1847
## 7: 2010-01-01    L     49 -0.8503
## 8: 2010-01-01    L     52 -1.0645
## 9: 2010-01-01    L     57 -0.6092 character factor CJ all_filters <- list(Period = as.IDate(as.Date("2010/1/1", format = "%Y/%m/%d")), 
  Size = c("L",'XL'), Number = c("11", "21", "35", "42", "45", "47", "49", "52", "57"))




cj_filter <- do.call(CJ, all_filters)

# note you could avoid this `do.call` line by
# cj_filter <- CJ(Period = as.IDate(as.Date("2010/1/1", format = "%Y/%m/%d")), 
  Size = c("L",'XL'), Number = c("11", "21", "35", "42", "45", "47", "49", "52", "57"))

setkeyv(DT, names(cj_filter))

DT[cj_filter]
       Period Size Number       other
 1: 2010-01-01    L     11  0.36289104
 2: 2010-01-01    L     21  1.26356767
 3: 2010-01-01    L     35 -0.18629723
 4: 2010-01-01    L     42  0.92267902
 5: 2010-01-01    L     45  1.68796072
 6: 2010-01-01    L     47  1.75107447
 7: 2010-01-01    L     49  0.24048407
 8: 2010-01-01    L     52  0.06675221
 9: 2010-01-01    L     57  0.49665392
10: 2010-01-01   XL     11  0.33682495
11: 2010-01-01   XL     21  0.67642271
12: 2010-01-01   XL     35 -0.16412768
13: 2010-01-01   XL     42  0.72863394
14: 2010-01-01   XL     45 -0.55527588
15: 2010-01-01   XL     47  1.30850591
16: 2010-01-01   XL     49  1.08688166
17: 2010-01-01   XL     52 -0.31157250
18: 2010-01-01   XL     57  0.43626422 setkeyv(DT, names(all_filters))

 DT[do.call(CJ,all_filters)]
-------------------------------------------------------------------------------------------------------
require(ggplot2)
 ggplot(go, aes(x=class, y=number_of_Unigene))+facet_grid(~Ontology)+geom_bar()+ theme(axis.text=element_text(angle=45, hjust=1))+ scale_y_continuous("No of Unigenes")
-------------------------------------------------------------------------------------------------------
W X Y Z expand.grid(W = W, X = X, Y = Y, Z = Z) 

    W X Y Z
1   0 0 0 0
2   1 0 0 0
3   2 0 0 0
4   3 0 0 0
5   4 0 0 0
6   5 0 0 0
7   6 0 0 0
8   7 0 0 0
9   8 0 0 0
10  9 0 0 0
11 10 0 0 0
12  0 1 0 0
13  1 1 0 0
14  2 1 0 0
15  3 1 0 0
...
-------------------------------------------------------------------------------------------------------
library(ggplot2)

d <- expand.grid(x=1:2,y=1:2, f=letters[1:2])
p <- qplot(x,y,data=d) + facet_wrap(~f)

g <- ggplot_gtable(ggplot_build(p))

library(gtable)
library(RCurl)
library(png)
shark <- readPNG(getURLContent("http://i.imgur.com/EOc2V.png"))
tiger <- readPNG(getURLContent("http://i.imgur.com/zjIh5.png"))

strips <- grep("strip", g$layout$name)
new_grobs <- list(rasterGrob(shark, width=1, height=1),
                  rasterGrob(tiger, width=1, height=1))
g <- with(g$layout[strips,],
          gtable_add_grob(g, new_grobs,
                          t=t, l=l, b=b, r=r, name="strip_predator") )        
grid.draw(g) strips <- grep("strip", names(g$grobs))
new_grobs <- list(rectGrob(gp=gpar(fill="red", alpha=0.2)),
                  rectGrob(gp=gpar(fill="blue", alpha=0.2)))
g$grobs[strips] <- new_grobs
grid.draw(g)
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(reshape2)

mydata <- data.frame(a=1:10,b=c('yes','no'),c=seq(2,20,2))
df <- melt(mydata, id.vars="b")
df[which(df$variable=="a"),]$value <- df[which(df$variable=="a"),]$value * 100
ggplot(df, aes(factor(b), value))  + 
  stat_summary(fun.y="mean", geom="bar", colour="black") + facet_grid(.~variable)


# If you need free scales, then:

ggplot(df, aes(factor(b), value))  + 
  stat_summary(fun.y="mean", geom="bar", colour="black") + 
  facet_wrap( ~variable, scales = "free_y")
-------------------------------------------------------------------------------------------------------
f <- function(i,j) i*j
m <- 4
n <- 2
out <- apply(expand.grid(1:m, 1:n), 1, function(x) f(x[1],x[2]))
dim(out) <- c(m,n)
-------------------------------------------------------------------------------------------------------
facet_grid() df <- data.frame( x = rnorm(40), y = rnorm(40) )
df <- cbind( df, expand.grid( c('A', 'B'), c('C', 'D' ) )  )
head( df )

            x          y Var1 Var2
1 -1.27990165  1.1697183    A    C
2 -0.65083905  0.4743215    B    C
3  0.23181562  0.5092162    A    D
4 -0.01370950 -0.1704988    B    D
5 -1.20182791 -0.3525845    A    C
6  0.04877524  0.8801793    B    C

library( "ggplot2" )
g <- ggplot( df ) +
  geom_point( aes(x = x, y = y) ) +
  facet_grid( Var1 ~ Var2 )
ggsave( "plot.png", g )
-------------------------------------------------------------------------------------------------------
geom_raster crime = read.csv("http://datasets.flowingdata.com/crimeRatesByState2005.tsv", 
              header=TRUE, sep="\t")
 ##Fit the regression model
 m = lm(crime$burglary ~ crime$murder) ##Create a grid for the background colour
x = seq(1, 10, length.out=100)
y = seq(400, 1200, length.out=100)
z = expand.grid(x,y) z$grad = (z[,2] - (398.3 +  62.2*z[,1]))^2 require(ggplot2)    
ggplot(z) + geom_raster(aes(Var1, Var2, fill=grad)) + 
    geom_point(data=crime[1:15,], aes(murder, burglary, size=population),pch=1 ) + 
    geom_text(data=crime[1:15,], 
              aes(murder, burglary, label=state), 
              hjust=-0.2, size=4) + 
    scale_size_continuous(range=c(1,10)) + 
    scale_fill_continuous(high="red", low="white", trans="sqrt") +
    xlab("Murder") + ylab("Burglary")  + 
    guides(size=FALSE, fill=FALSE) +
    scale_y_continuous(expand=c(0, 0)) + 
    scale_x_continuous(expand=c(0, 0))
-------------------------------------------------------------------------------------------------------
library(data.table)

(dat <- data.table(expand.grid(sub=1:4, score=1:4), key="sub"))
#     sub score
#  1:   1     1
#  2:   1     2
#  3:   1     3
#  4:   1     4
#  5:   2     1
#  6:   2     2
#  7:   2     3
#  8:   2     4
#  9:   3     1
# 10:   3     2
# 11:   3     3
# 12:   3     4
# 13:   4     1
# 14:   4     2
# 15:   4     3
# 16:   4     4

dat[,list(stat=c("mean","sd"), value=c(mean(score),sd(score))),by=sub]
#    sub stat    value
# 1:   1 mean 2.500000
# 2:   1   sd 1.290994
# 3:   2 mean 2.500000
# 4:   2   sd 1.290994
# 5:   3 mean 2.500000
# 6:   3   sd 1.290994
# 7:   4 mean 2.500000
# 8:   4   sd 1.290994
-------------------------------------------------------------------------------------------------------
require(ggplot2)
require(plyr)
mms <- data.frame(deliciousness = rnorm(100),
                  type=sample(as.factor(c("peanut", "regular")), 100, replace=TRUE),
                  color=sample(as.factor(c("red", "green", "yellow", "brown")), 100, replace=TRUE))


mms.cor <- ddply(.data=mms, .(type, color), summarize, n=paste("n =", length(deliciousness)))

plot <- ggplot(data=mms, aes(x=deliciousness)) + geom_density() + facet_grid(type ~ color) + geom_text(data=mms.cor, aes(x=1.8, y=5, label=n), colour="black", inherit.aes=FALSE, parse=FALSE)

plot
-------------------------------------------------------------------------------------------------------
ggplot plot rgeos library(rgeos)
library(RColorBrewer)

# Get centroids of countries
theCents <- coordinates(world.map)

# extract the polygons objects
pl <- slot(world.map, "polygons")

# Create square polygons that cover the east (left) half of each country's bbox
lpolys <- lapply(seq_along(pl), function(x) {
  lbox <- bbox(pl[[x]])
  lbox[1, 2] <- theCents[x, 1]
  Polygon(expand.grid(lbox[1,], lbox[2,])[c(1,3,4,2,1),])
})

# Slightly different data handling
wmRN <- row.names(world.map)

n <- nrow(world.map@data)
world.map@data[, c("growth", "category")] <- list(growth = 4*runif(n),
                 category = factor(sample(1:5, n, replace=TRUE)))

# Determine the intersection of each country with the respective "left polygon"
lPolys <- lapply(seq_along(lpolys), function(x) {
  curLPol <- SpatialPolygons(list(Polygons(lpolys[x], wmRN[x])),
    proj4string=CRS(proj4string(world.map)))
  curPl <- SpatialPolygons(pl[x], proj4string=CRS(proj4string(world.map)))
  theInt <- gIntersection(curLPol, curPl, id = wmRN[x])
  theInt
})

# Create a SpatialPolygonDataFrame of the intersections
lSPDF <- SpatialPolygonsDataFrame(SpatialPolygons(unlist(lapply(lPolys,
  slot, "polygons")), proj4string = CRS(proj4string(world.map))),
  world.map@data)

##########
## EDIT ##
##########
# Create a slightly less harsh color set
s_growth <- scale(world.map@data$growth,
  center = min(world.map@data$growth), scale = max(world.map@data$growth))
growthRGB <- colorRamp(c("red", "blue"))(s_growth)
growthCols <- apply(growthRGB, 1, function(x) rgb(x[1], x[2], x[3],
  maxColorValue = 255))
catCols <- brewer.pal(nlevels(lSPDF@data$category), "Pastel2")

# and plot
plot(world.map, col = growthCols, bg = "grey90")

plot(lSPDF, col = catCols[lSPDF@data$category], add = TRUE) ggplot2 ggplot2 coordinates(lSPDF) rSPDF # Create square polygons that cover west (right) half of each country's bbox
rpolys <- lapply(seq_along(pl), function(x) {
  rbox <- bbox(pl[[x]])
  rbox[1, 1] <- theCents[x, 1]
  Polygon(expand.grid(rbox[1,], rbox[2,])[c(1,3,4,2,1),])
})

# Determine the intersection of each country with the respective "right polygon"
rPolys <- lapply(seq_along(rpolys), function(x) {
  curRPol <- SpatialPolygons(list(Polygons(rpolys[x], wmRN[x])),
    proj4string=CRS(proj4string(world.map)))
  curPl <- SpatialPolygons(pl[x], proj4string=CRS(proj4string(world.map)))
  theInt <- gIntersection(curRPol, curPl, id = wmRN[x])
  theInt
})

# Create a SpatialPolygonDataFrame of the western (right) intersections
rSPDF <- SpatialPolygonsDataFrame(SpatialPolygons(unlist(lapply(rPolys,
  slot, "polygons")), proj4string = CRS(proj4string(world.map))),
  world.map@data) lSPDF rSPDF points(coordinates(rSPDF), col = factor(rSPDF@data$REGION))
# or
text(coordinates(lSPDF), labels = lSPDF@data$FIPS, cex = .7)
-------------------------------------------------------------------------------------------------------
expand.grid x<-1:7
somevector <- rnorm(10, 5)
df<-(expand.grid(x,somevector))
df[,1]-df[,2]
-------------------------------------------------------------------------------------------------------
expand.grid x <- c(0.0001560653, 0.0001685597, 0.0002793819, 0.0006336307, 0.0455676525,
0.3184740837, 0.3195122279, 0.3195122606)
y <- expand.grid(x,x)
as.matrix(y[abs(y[[2]] - y[[1]]) <= 0.01,])

           Var1         Var2
1  0.0001560653 0.0001560653
2  0.0001685597 0.0001560653
3  0.0002793819 0.0001560653
4  0.0006336307 0.0001560653
9  0.0001560653 0.0001685597
10 0.0001685597 0.0001685597
11 0.0002793819 0.0001685597
...
-------------------------------------------------------------------------------------------------------
?facet_grid() ggplot2 axis.line = theme_blank()
-------------------------------------------------------------------------------------------------------
plot.new()
par(mfcol=c(1,2))
plot(1:5,ann=FALSE,bty="n",type="l",ylim=c(0,25))
grid(ny=NA)
par(mar=c(5.1, 0, 4.1, 2.1))
plot(c(10,20,30,40,50),c(8,5,15,20,20),yaxt="n",ann=FALSE,bty="n",type="l",ylim=c(0,25))
grid(ny=NA)
par(new=TRUE)
par(mfcol=c(1,1))
par(bty="l")
par(mar=c(5.1, 4.1, 4.1, 2.1))
plot(NA,ylim=c(0,25),type="n",xaxt="n",yaxt="n",ann=FALSE)
box()
grid(nx=NA,ny=NULL)
-------------------------------------------------------------------------------------------------------
ggplot2 library(ggplot2)

x = c(1,2,3,4,5, 10,20,30,40,50)
y = c(1,2,2,3,4, 2,1,3,5,5)
# You should introduce cond - condition to separate axises - by yourself
df = data.frame(x=x,y=y,cond=ifelse(x>5,"x2","x1"))

ggplot(df, aes(x,y,group=cond)) + geom_line() + geom_point(aes(shape=cond), size=4) + facet_grid(.~cond, scales="free_x")
-------------------------------------------------------------------------------------------------------
expand.grid(row = seq(nrow(dat)), col = seq(ncol(dat)))
#   row col
#1    1   1
#2    2   1
#3    3   1
#4    4   1
#5    5   1
#6    1   2
#7    2   2
#8    3   2
#9    4   2
#10   5   2
#11   1   3
#12   2   3
#13   3   3
#14   4   3
#15   5   3
#16   1   4
#17   2   4
#18   3   4
#19   4   4
#20   5   4
-------------------------------------------------------------------------------------------------------
expand.grid(sapply(dim(dat), seq_len))
-------------------------------------------------------------------------------------------------------
expand.grid() matrix(c(row(dat), col(dat)), ncol = 2)
-------------------------------------------------------------------------------------------------------
Counts # Create a map of all combinations of indices in the first two dimensions
i <- expand.grid(prey=1:2, predator=1:5)

# Add the indices of the third dimension
i <- as.matrix( cbind(i, as.vector(aresult)) )

# Extract and increment
Counts[i] <- Counts[i] + 1
-------------------------------------------------------------------------------------------------------
datf datf <- datf[order(datf$pollut, datf$lag), ] datfPlusNA <- lapply(split(datf, datf$pollut), function(x) rbind(NA, x, NA))
datf <- do.call(rbind, datfPlusNA) nr <- nrow(datf)  # find out how many rows all together
with(datf, {# this allows entering your commands more succinctly
    # first you could set up the plot so you can select the order of drawing
    plot(1:nr, or, ylim = c(0.8, 1.3), type = 'n', xaxt = 'n', xlab = '', ylab = 'Odds Ratio and 95% CI', frame.plot = TRUE, panel.first = grid(nx = NA, ny = NULL))
    # arrows(1:nr, lcl, 1:nr, ucl, length = 0.02, angle = 90, code = 3, col = factor(lag)) 
    # you could use arrows above but you don't want ends so segments is easier
    segments(1:nr, lcl, 1:nr, ucl, col = factor(lag))
    # add your points
    points(1:nr, or, pch = 19, cex = 0.6)
    xLabels <- na.omit(unique(pollut))
    axis(1, seq(4, 34, by = 6) - 0.5, xLabels)
})
abline(h = 1.0)
-------------------------------------------------------------------------------------------------------
layout(matrix(1:2,nrow=1),widths=c(0.8,0.2))
colfunc <- colorRampPalette(c("white","black"))

par(mar=c(5.1,4.1,4.1,2.1))
plot(1:10,ann=FALSE,type="n")
grid()
points(1:10,col=colfunc(10),pch=19,cex=1.5)

xl <- 1
yb <- 1
xr <- 1.5
yt <- 2

par(mar=c(5.1,0.5,4.1,0.5))
plot(NA,type="n",ann=FALSE,xlim=c(1,2),ylim=c(1,2),xaxt="n",yaxt="n",bty="n")
rect(
     xl,
     head(seq(yb,yt,(yt-yb)/10),-1),
     xr,
     tail(seq(yb,yt,(yt-yb)/10),-1),
     col=colfunc(10)
    )

mtext(1:10,side=2,at=tail(seq(yb,yt,(yt-yb)/10),-1)-0.05,las=2,cex=0.7)
-------------------------------------------------------------------------------------------------------
# plot the results
boxplot(base, xlim=c(1,4), col="gray", xaxt="n", ylab="Base values", outline=FALSE)
axis(side=1,1,labels=('base'))
par(new=TRUE)
boxplot(exps, col="red", ylim=c(-200,200), outline=FALSE, axes=FALSE)
axis(4)
axis(side=1,1:3,labels=c("% exp1","% exp2","% exp3"))
grid() boxplot base exps axis(side=1,1:3,labels=c("% exp1","% exp2","% exp3")) #divide your plottin area into 2 columns with one row.
par(mfrow = c(1, 2))
# plot the results
boxplot(base, col="gray", xaxt="n", ylab="Base values", outline=FALSE,axes=FALSE)
axis(2)
axis(side=1,1,labels=('base'))
segments(0,0,1,0)
boxplot(exps,col="red", xaxt="n", ylim=c(-200,200), outline=FALSE, axes=FALSE)
axis(4)
axis(side=1,at=(1:3),labels=c("% exp1","% exp2","% exp3"))
-------------------------------------------------------------------------------------------------------
twolabs  <- c("120<alpha+150","150<alpha+250")
df<- data.frame(x=rnorm(mean=4,40),
   y=rnorm(mean=4,40),
   labs=sample(twolabs,40,replace=T)) ggplot(df,aes(x=x,y=y))+geom_point()+facet_grid(.~labs,labeller=label_parsed) twolabs  <- c("120<alpha<150","150<alpha<250")
df2<- data.frame(x=rnorm(mean=4,40),
   y=rnorm(mean=4,40),
   labs=sample(twolabs,40,replace=T))

> ggplot(df2,aes(x=x,y=y))+geom_point()+facet_grid(.~labs,labeller=label_parsed)
Error in parse(text = x) : <text>:1:10: unexpected '<'
1: 120<alpha<
-------------------------------------------------------------------------------------------------------
expression(120 <= alpha~phantom() <= 150)
expression(180 <= alpha~phantom() <= 250) parse(text="120 <= alpha~phantom() <= 150")
parse(text="180 <= alpha~phantom() <= 250") label_parsed mtcars dat <- mtcars   
dat$regime <- factor(dat$am)
levels(dat$regime) <- list("120 <= alpha~phantom() <= 150" = "0",
                           "180 <= alpha~phantom() <= 250" = "1")

ggplot(aes(x=wt, y=mpg), data=dat) +
  geom_point() +
  facet_grid(cyl ~ regime, labeller=label_parsed) dat <- mtcars   
dat$regime <- factor(dat$am, levels=c(0,1), labels=c("Lesser", "Greater")) mf_labeller <- function(var, value){
  value <- as.character(value)
  if (var=="regime") {
    value[value=="Lesser"] <- "120 <= alpha~phantom() <= 150"
    value[value=="Greater"]  <- "180 <= alpha~phantom() <= 250"
    value <- lapply(value, function(x) parse(text=x))
  }
  return(value) 
}

ggplot(aes(x=wt, y=mpg), data=dat) +
  geom_point() +
  facet_grid(cyl ~ regime, labeller=mf_labeller)
-------------------------------------------------------------------------------------------------------
num_train <- 1000
num_test <- 10000
train <- data.table(k = rep(1,num_train), ID_train = 1:num_train, b_train =     rnorm(num_train), c_train = rnorm(num_train), cat = sample(c("A", "B", "C", "D"), num_train,     replace = TRUE))
test <- data.table(k = rep(1,num_test), ID_test = 1:num_test, b_test = rnorm(num_test),     c_test = rnorm(num_test))


train <- data.frame(unclass(train), stringsAsFactors=TRUE)
test <- data.frame(unclass(test), stringsAsFactors=TRUE)
require(ffbase)
train$id <- seq_len(nrow(train))
test$id <- seq_len(nrow(test))
train <- as.ffdf(data.frame(train, stringsAsFactors=TRUE))
test <- as.ffdf(data.frame(test, stringsAsFactors=TRUE))
x <- expand.ffgrid(train$id, test$id)
dim(x)
names(x) <- c("train.id", "test.id")
x <- merge(x, train, by.x="train.id", by.y="id", all.x=TRUE, all.y=FALSE)
x <- merge(x, test, by.x="test.id", by.y="id", all.x=TRUE, all.y=FALSE)
dim(x)
x[1:5, ]
-------------------------------------------------------------------------------------------------------
b <- 4    
expand.grid(rep(list(seq(0,1,by=1/3)), b))
-------------------------------------------------------------------------------------------------------
require(ffbase)
x <- expand.ffgrid(ff(1:1000), ff(1:1000), ff(1:100))
dim(x)
x[1:5, ]
-------------------------------------------------------------------------------------------------------
cat facet_grid year ggplot() +
  geom_bar(data=test, aes(y = value, x = cat, fill = cond), stat="identity",
           position='stack') +
  theme_bw() + 
  facet_grid( ~ year)
-------------------------------------------------------------------------------------------------------
library(reshape2)
library(plyr)  
m <- 100;n <- 100;K <- 100;L <- 100
A <- matrix(sample(1:n),nrow=n,ncol=K)
B <- matrix(sample(1:L),nrow=L,ncol=m)
C <- matrix(sample(1:L),nrow=L,ncol=K)

h <- ddply(expand.grid(1:m,1:n),.(Var1,Var2),
           f <- function(i) {sum(B[,i$Var1,drop=FALSE]%*%A[i$Var2,,drop=FALSE]*C)})
D <- acast(h, Var2 ~ Var1)
-------------------------------------------------------------------------------------------------------
## transform data
 require(reshape2)
 h <- do.call(cbind, phat)
 h.melt <- melt(h)

 ## rename variables so they look nicer on plots
 names(h.melt) <- c("test","N","value")     

 ## stripchart (not shown)
 qplot(data = h.melt, x = value,y = Var2,color=Var2)+geom_point()

 ## histogram (not shown)    
 ggplot(h.melt,aes(x=value,fill=N))+geom_histogram()+facet_grid(N~.)

 ## dotplot with rug (not shown)
 ggplot(h.melt,aes(x=value,fill=N))+geom_dotplot()+facet_grid(N~.)+geom_rug()  

 ##density plot with rug (shown below)
 ggplot(h.melt,aes(x=value,fill=N))+geom_density()+facet_grid(N~.)+geom_rug()
-------------------------------------------------------------------------------------------------------
scatterplot3d rgl newdat <- expand.grid(Education=seq(0,50,by=5),
            Agriculture=seq(0,100,by=10))
newdat$pp <- predict(swiss2.lm,newdata=newdat) library(rgl)
with(swiss,plot3d(Agriculture,Education,Fertility))
with(newdat,surface3d(unique(Agriculture),unique(Education),pp,
                      alpha=0.3,front="line"))
rgl.snapshot("swiss.png") rgl plotmath scatter3d car rgl scatterplot3d xyz.convert segments
-------------------------------------------------------------------------------------------------------
mycomb <- expand.grid(Cluster_ID = unique(mydat$Cluster_ID),
          year = 1990:2010) merge(mydat,mycomb,all=TRUE) ?expand.grid ?merge zz <- textConnection('LAT        LONG    Cluster_ID year
13.5330 -15.4180   1            1990
13.5330 -15.4180   1            1992
13.5330 -15.4180   1            1995
13.5330 -15.4180   1            2010
13.5330 -15.4170   2            1995
13.5330 -15.4170   2            1997
13.5330 -15.4170   2             2005
13.5340 -14.9350   3             2005
13.5340 -14.9350   3             2006
13.5340 -15.9170   4             2010
13.3670 -14.6190   5             2006')

mydat <- read.table(zz,header=TRUE)
-------------------------------------------------------------------------------------------------------
expand.grid merge df <- data.frame(a = 1:3, b = 5:7)
c <- 9:10
combined <- expand.grid(a=df$a, c=c)
combined <- merge(combined, df)
> combined[order(combined$c), ]
  a  c b
1 1  9 5
3 2  9 6
5 3  9 7
2 1 10 5
4 2 10 6
6 3 10 7
-------------------------------------------------------------------------------------------------------
x <- do.call("paste",c(expand.grid(1:14,1:14),sep="."))
grep("^[1][.]",x,value=T)
 [1] "1.1"  "1.2"  "1.3"  "1.4"  "1.5"  "1.6"  "1.7"  "1.8"  "1.9"  "1.10"
[11] "1.11" "1.12" "1.13" "1.14" ^
-------------------------------------------------------------------------------------------------------
#name each of your plots
p2 <- ggplot(subset(dfr_melt, variable=="a"),aes(x=d,y=value)) + facet_grid(variable~.,scales="free")+
  geom_line(subset=.(variable=="a")) + geom_line(subset=.(variable=="b"))

#Upper plot should look like this
p1 <- ggplot(dfr,aes(x=d,y=a)) + geom_line() + geom_line(aes(y=c,color="c"))+
  geom_hline(aes(yintercept=1),linetype="dashed")+
  geom_hline(aes(yintercept=-2),linetype="dashed")

#From Wickham ggplot2, p154
vplayout <- function(x,y) {
  viewport(layout.pos.row=x, layout.pos.col=y)
}

require(grid)
png("myplot.png", width = 600, height = 300) #or use a different device, e.g. quartz for onscreen display on a mac
grid.newpage()
pushViewport(viewport(layout=grid.layout(2, 1)))
print(p1, vp=vplayout(1, 1))
print(p2, vp=vplayout(2, 1))
dev.off()
-------------------------------------------------------------------------------------------------------
variable dfr dfr$variable = "a"
ggplot(subset(dfr_melt, variable=="a"),aes(x=d,y=value)) +  
  facet_grid(variable~.,scales="free")+
  geom_line(data=subset(dfr_melt,variable=="a"))  + 
  geom_line(data=subset(dfr_melt, variable=="b")) + 
  geom_line(data=dfr, aes(y=c, colour=factor(c))) + 
  geom_hline(aes(yintercept=1),linetype="dashed")+
  geom_hline(aes(yintercept=-2),linetype="dashed") #This is almost certainly not what you want
  geom_line(data=dfr, aes(y=c, colour="c")) #I made c a factor since it only takes the values 0 or 1
  geom_line(data=dfr, aes(y=c, colour=factor(c)))
  ##Alternatively, you could have
  geom_line(data=dfr, aes(y=c), colour="red") #or
  geom_line(data=dfr, aes(y=c, colour=c)) #or
-------------------------------------------------------------------------------------------------------
mtcars <- within(mtcars, Group <- factor(cyl, levels = rev(sort(unique(cyl)))))


ggplot(mtcars) + geom_point() + facet_grid(~Group)
-------------------------------------------------------------------------------------------------------
expand.grid df <- expand.grid(year = 1990:2001, month = 1:12)
-------------------------------------------------------------------------------------------------------
xtabs data.frame temp <- xtabs(~ LOCATION  + COLOR + STATE, dat)
data.frame(expand.grid(rev(attr(ftable(temp), "row.vars"))),
           setNames(as.data.frame.matrix(ftable(temp)), 
                    rev(attr(ftable(temp), "col.vars")$STATE)))
#   COLOR LOCATION rotten fresh
# 1 green        A      1     0
# 2   red        A      0     1
# 3 green        B      2     0
# 4   red        B      0     0
# 5 green        C      0     1
# 6   red        C      1     0
-------------------------------------------------------------------------------------------------------
require(grid)

dothegrid <- function(){
  grid.newpage()
  grid.lines(x=c(0.5, 0.5), y=c(0.25, 0.75), gp=gpar(col=rgb(1, 0, 0, 0.2)))
  grid.lines(x=c(0.4, 0.4), y=c(0.25, 0.75), gp=gpar(col=rgb(1, 0, 0, 0.6)))
}

# Window 7
# Make sure to restart RStudio/R before running this
dothegrid() # Rstudio: ok, nothing in RGui
# run again
dothegrid() # makes the lines disappear

pdf("a.pdf")
dothegrid()
dothegrid() # lines stay
dev.off()

png("a.png")
dothegrid() #lines stay
dev.off()
-------------------------------------------------------------------------------------------------------
model=lm(VP ~ (G+P+Z)^3, data=xyz)   # see ?formula pred123 <- predict(model, newdata=data.frame(G=1, P=2, Z=3) ) pred.all <- predict(modlel, newdat=expand.grid(G;1:3, P=2:5, Z=6:8) )
-------------------------------------------------------------------------------------------------------
ggplot(Combined,aes(Month,Density,color=factor(Year),shape=factor(Year))) +
scale_shape_discrete("Year") +
facet_grid(Creek~. ,scales = "free_y") +
geom_jitter(position = position_jitter(width = .3)) +
scale_color_grey("Year",end=.6) +
theme_bw() +
scale_y_continuous(expression("Number of prey captured " (m^2) ^-1))+
scale_x_discrete("Month",breaks=c(2,5,8,11),labels=c("February","May","August","November"), expand= c(0,-2)) +
theme(
panel.grid.major=element_blank(),
panel.grid.minor=element_blank()
)
-------------------------------------------------------------------------------------------------------
for() ... expand.grid() nC <- 3 # Num of cols
nR <- 4 # Num of cols
indices <- expand.grid(nC, nC)
# Now you can use apply cleanly
apply(indices, 1,
   function(x) {
      c1 <- x[1]; c2 <- x[2]
      yourResult[c1,c2] <- doYourThing(bigData[,c1], bigData[,c2])
   }
)
-------------------------------------------------------------------------------------------------------
A <- 1:13
B <- 1:26
C <- 1:26
D <- c(1:13, 27:40)

mymat <- expand.grid(A, B, C, D)
names(mymat) <- c("A", "B", "C", "D")
mymat <- as.matrix(mymat)
mymeans <- rowSums(mymat)/4 B <- 1:266
C <- 1:266
D <- c(1:133, 267:400)

for(A in 1:133) {
    mymat <- expand.grid(A, B, C, D)
    names(mymat) <- c("A", "B", "C", "D")
    mymat <- as.matrix(mymat)
    mymeans <- rowSums(mymat)/4
    write.table(mymat, file = paste("matrix", A, "txt", sep = "."))
    write.table(mymeans, file = paste("means", A, "txt", sep = "."))
    rm(mymat, mymeans)
} D n <- 1e7
A <- sample(133, size = n, replace= TRUE)
B <- sample(266, size = n, replace= TRUE)
C <- sample(266, size = n, replace= TRUE)
D <- sample(x = c(1:133, 267:400), size = n, replace= TRUE)
mymeans <- (A+B+C+D)/4 hist(mymeans)
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(tkrplot)
TkPlotLocations <- function(FUN) {
    require(tkrplot)

    cl <- substitute(FUN)
    replot <- function() eval(cl)

    tt <- tktoplevel()
    img <- tkrplot(tt, replot, vscale=1.5, hscale=1.5)
    tkpack(img)

    tkpack(xfr <- tkframe(tt), side='left')
    tkpack(yfr <- tkframe(tt), side='left')

    xndc <- tclVar()
    yndc <- tclVar()
    xin <- tclVar()
    yin <- tclVar()

    tkgrid(tklabel(xfr, text='x ndc'), tklabel(xfr, textvariable=xndc))
    tkgrid(tklabel(yfr, text='y ndc'), tklabel(yfr, textvariable=yndc))
    tkgrid(tklabel(xfr, text='x inch'), tklabel(xfr, textvariable=xin))
    tkgrid(tklabel(yfr, text='y inch'), tklabel(yfr, textvariable=yin))

    iw <- as.numeric(tcl("image","width", tkcget(img, "-image")))
    ih <- as.numeric(tcl("image","height",tkcget(img, "-image")))

    cc <- function(x,y) {
        x <- (as.real(x)-1)/iw
        y <- 1-(as.real(y)-1)/ih
        c(x,y)
    }

    mm <- function(x, y) {
        xy <- cc(x,y)
        tclvalue(xndc) <- xy[1]
        tclvalue(yndc) <- xy[2]
        tclvalue(xin) <- grconvertX(xy[1], from='ndc', to='inches')
        tclvalue(yin) <- grconvertY(xy[2], from='ndc', to='inches')
    }

    tkbind( img, "<Motion>", mm)

    invisible()
}


x <- runif(25)
y <- rnorm(25, x, 0.25)
plot(x,y)
par()$pin
par()$plt
TkPlotLocations(plot(x,y))
qplot(x,y)
par()$pin
par()$plt
TkPlotLocations(print(qplot(x,y)))
qplot(x,y) + xlab('Multi\nline\nx\nlabel')
par()$pin
par()$plt
TkPlotLocations(print(qplot(x,y) + xlab('Multi\nline\nx\nlabel'))) par()$pin par()$plt
-------------------------------------------------------------------------------------------------------
x y z library("lattice")

## Example data
x <- seq(pi/4, 5*pi, length.out=10)
y <- seq(pi/4, 5*pi, length.out=10)
grid <- expand.grid(X=x, Y=y)
grid$Z <- runif(100, -1, 1)

## Write a panel function (after examining 'args(panel.levelplot) to see what
## will be being passed on to the panel function by levelplot())
myPanel <- function(x, y, z, ...) {
    panel.levelplot(x,y,z,...)
    panel.text(x, y, round(z,1))
}

## Try it out
levelplot(Z ~ X*Y, grid, panel = myPanel)
-------------------------------------------------------------------------------------------------------
mat <- read.csv("J_H2S1T6_PassTraffic.csv", header=F)

y        <- as.numeric(mat[1,-1])
mat      <- mat[-1,-1]
n        <- dim(mat)[1] x <- seq(min(y), max(y), length.out=n)
grid     <- expand.grid(x=x, y=x)
mat      <- as.matrix(mat)
dim(mat) <- c(n*n,1)
grid$z   <- mat mat <- as.matrix(mat)
dim(mat) <- c(n*n,1)
grid$z <- mat

p <- levelplot(z~x*y, grid, 
           panel=function(...) {
             arg <- list(...)
             panel.levelplot(...)
             panel.text(arg$x, arg$y,arg$z)},
           scales = list(y = list(at=y,labels=y),
                         x = list(at=y,labels=y)))

print(p)
-------------------------------------------------------------------------------------------------------
m1 <- lm(y~f1*f2,data=d)
predict(m1,newdata=with(d,expand.grid(f1=levels(f1),f2=levels(f2)))
-------------------------------------------------------------------------------------------------------
Reduce reducedData <- Reduce(function(x,y) merge(x,y,by="video_id"),summaryList) names names(reducedData)[-1] <- do.call(function(...) paste(...,sep="."),expand.grid(letters[24:25],names(summaryList))) video_id  x.1 y.1  x.2 y.2  x.3 y.3  x.4 y.4  x.5 y.5  x.6 y.6  x.7 y.7  x.8
1         0   39 108  899 132   61 357  149 298 1105 415  148 208  442 200  210
2         1 1125  70  128 165 1151 390  171 587  623 623   80 643  866 310  994
-------------------------------------------------------------------------------------------------------
ggplot2 ggplot ggplot(platelay, aes(y = factor(rown, rev(levels(rown))),x = factor(coln))) + 
     geom_point(aes(colour = colorvar), size =18)  +theme_bw() +
     labs(x=NULL, y = NULL) # plot with grey colour dictated by rank, no axes or labels
with(platelay, plot( x=as.numeric(coln), y= rev(as.numeric(rown)), pch= 19, cex = 2, 
 col = grey(rank(platelay[['colorvar']] ) / nrow(platelay)), axes = F, xlab= '', ylab = ''))
# add circular outline
with(platelay, points( x=as.numeric(coln), y= rev(as.numeric(rown)), pch= 21, cex = 2))
# add the axes
axis(3, at =1:12, labels = 1:12)
axis(2, at = 1:8, labels = LETTERS[8:1])
# the background grid
grid()
# and a box around the outside
box()
-------------------------------------------------------------------------------------------------------
stat='identity' stat='sum' opt theme theme_text element_text ggplot2 ggplot(data=funded.agvc, aes(moved_date,deal_count)) + 
   geom_bar(colour='black', fill="#33CC00", alpha=.5, 
      size=0, width=.7,stat='sum') + xlab("Deal Funded Date") + 
   ylab("Funded Deal Count") + 
   opts(title="Deals funded since January 2011") + 
   facet_grid(grouptype~fundingstage, scales='free_y') + 
   opts(axis.text.x =theme_text(angle=45, size=5))
-------------------------------------------------------------------------------------------------------
hour item poss summary result <- merge(poss, summary, by=c('hour','item'),all=T)
names(result)[3] <- 'count'
result$count[is.na(result$count)] <- 0

> head(result)
  hour item count
1    0   12     2
2    0   13     0
3    0   14     1
4    0   15     0
5    0   16     0
6    1   12     1 expand.grid poss <- expand.grid(list(hour=0:23, item=12:16))
-------------------------------------------------------------------------------------------------------
require(plyr)
purchases <- data.frame(id = 101:105, hour = c(0,0,0,1,1), item = c(12,14,12,12,15))
results.table <- merge(expand.grid(list(hour = 0:23, item = 12:16)), purchases, by = c('hour', 'item'), all = TRUE)
summary.table <- ddply(results.table, c("hour", "item"), summarise, count = length(na.omit(id)))
-------------------------------------------------------------------------------------------------------
scale_fill_gradientn library(scales)
  heat.dat <- heat[0:10,0:10]
  dat <- expand.grid(var1=1:10, var2=1:10)
  dat$value <- melt(heat.dat)$value
  ggplot(dat, aes(x=var1,y=var2))+ 
        geom_tile(aes(fill = value),colour='white')+
        scale_fill_gradientn(colours=c("red","white","green"),
         values  = rescale(c(min(dat$value), 1000, max(dat$value))) with(dat,
levelplot(round(value,0)~y*x, 
          dat, 
          panel=function(...) {
                 arg <- list(...)
                 panel.levelplot(...)
                 panel.text(arg$x, arg$y,arg$z)},
          scales = list(y = list(at=y,labels=y),
                        x = list(at=y,labels=y)),
          col.regions = colorRampPalette(c("red", "white", "green"),interpolate ='spline'))
)
-------------------------------------------------------------------------------------------------------
mapply # create a table of the i-k index combinations using `expand.grid`
ixk <- expand.grid(i=1:51, k=1:6)

    # Take a look at what expand.grid does
    head(ixk, 60)


# create two vectors for multiplying against our dataframe subset
multpVec <- c(rep(c(0, 1), times=c(4, ncol(mydf)-4-1)), 0)
invVec   <- !multpVec

    # example of how we will use the vectors
    (multpVec * filingstat0711[1, 2, 1] + invVec)


# Instead of for loops, we can use mapply. 
newdf <- 
  mapply(function(i, k) 

    # The function that you are `mapply`ing is:
    # rbingd'ing a list of dataframes, which were subsetted by matching var1 & var2
    # and then multiplying by a value in filingstat
    do.call(rbind, 
        # iterating over m
        lapply(1:4, function(m)

          # the cbind is for adding the newvar=m, at the end of the subtable
          cbind(

            # we transpose twice: first the subset to multiply our vector. 
            # Then the result, to get back our orignal form
            t( t(subset(mydf, var1==i & mydf$var2==k)) * 
              (multpVec * filingstat0711[i,k,m] + invVec)), 

          # this is an argument to cbind
          "newvar"=m) 
    )), 

    # the two lists you are passing as arguments are the columns of the expanded grid
    ixk$i, ixk$k, SIMPLIFY=FALSE
  )

# flatten the data frame
newdf <- do.call(rbind, newdf) data table df sub mydf data apply(ixk, 1, fu..) mapply
-------------------------------------------------------------------------------------------------------
stat_smooth geom_rect # generating data: Usage of set.seed for reproducibility 
# also I changed the multiplication constant to 0.1 to have 
# at least one negative slope.

require(ggplot2)
set.seed(12)
x <- rnorm(100)
y <-  + .1*x + rnorm(100)
f1 <- as.factor(c(rep("A",50),rep("B",50)))
f2 <- as.factor(rep(c(rep("C",25),rep("D",25)),2))
df <- data.frame(cbind(x,y))
df$f1 <- f1
df$f2 <- f2

# first generate your plot in this manner and run it
# from James' post, the part outfit=fit<<-..y.. will store 
# the output of fitted values in "fit"

g <- ggplot(df,aes(x=x,y=y)) + geom_point()+facet_grid(f1~f2) 
g <- g + stat_smooth(aes(outfit=fit<<-..y..), method="lm",se=FALSE)
# now run g to generate "fit"
g

# now extract the slope for each facet and 
# construct the data.frame for geom_rect (as per Joran's post)
# Edit: Just to add more info about "fit". By default it contains
# 80 values per facet. Hence the 80*4 = 320

slopes <- fit[seq(2, 320, by = 80)] - fit[seq(1, 320, by = 80)]
tp <- unique(df[, c('f1', 'f2')])
tp <- transform(tp, slopes=slopes, x=1, y=1)
tp$pos_neg <- ifelse(slopes > 0, 1, 0)
tp$pos_neg <- factor(tp$pos_neg)

# now plot again (but with geom_rect)
g <- ggplot(df,aes(x=x,y=y)) 
g <- g + geom_rect(data = tp, aes(fill = pos_neg), xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf, alpha = 0.5) 
g <- g + geom_point() + facet_grid(f1~f2) + stat_smooth(method = "lm",se = FALSE)
g stat_smooth
-------------------------------------------------------------------------------------------------------
pvalue.matrix <- function(x,...){
  ncx <- ncol(x)
  r <- matrix(0, nrow = ncx, ncol = ncx)
  for (i in seq_len(ncx)) {
    for (j in seq_len(i)) {
      x2 <- x[, i]
      y2 <- x[, j]
      r[i, j] <-  cor.test(x2,y2,...)$p.value
    }
  }
  r <- r + t(r) - diag(diag(r))
  rownames(r) <- colnames(x)
  colnames(r) <- colnames(x)
  r
} df.cor.sig <- (df.cor > 0.01 | df.cor < -0.01) & pvalue.matrix(df) < 0.5 library(reshape2) ## melt
library(plyr)     ## round_any
 library(ggplot2) 
dat <- expand.grid(var1=1:4, var2=1:4)
dat$value <- melt(df.cor.sig)$value
dat$labels <- paste(round_any(df.cor,0.01) ,'(', round_any(pvalue.matrix(df),0.01),')',sep='')
ggplot(dat, aes(x=var1,y=var2,label=labels))+ 
  geom_tile(aes(fill = value),colour='white')+
 geom_text() plots <- apply(dat,1,function(x){
    plot.grob <- nullGrob()
    if(length(grep(pattern='TRUE',x[3])) >0 ){
      gg <- paste('var',c(x[1],x[2]),sep='')
      p <- ggplot(subset(df.melt,variable %in% gg ), 
            aes(x=rownames, y=value, group=variable, colour=variable)) +
            geom_line()
      plot.grob <- ggplotGrob(p)
    }
    plot.grob

})


library(gridExtra)
do.call(grid.arrange,  plots)
-------------------------------------------------------------------------------------------------------
\documentclass[letterpaper]{article}
\usepackage{lscape}
\usepackage{float}
\begin{document}
<<load, echo=FALSE, results='hide', warning=FALSE, message=FALSE>>=
require(ggplot2)
@ 

Two on the first page.
<<first, echo=FALSE, fig.height=3, fig.cap="This is first", fig.pos='h'>>=
ggplot(mtcars, aes(mpg, wt))+geom_point()+facet_grid(vs ~ am, margins=TRUE)
@

Blah, blah, blah.
<<second, echo=FALSE, fig.height=3, fig.cap="This is second", fig.pos='h'>>=
ggplot(mtcars, aes(mpg, wt))+geom_point()+facet_grid(vs ~ am, margins=TRUE)
@

\newpage
Second page.

Side by side images:

\begin{figure}[H]
<<third, echo = FALSE, out.width="0.48\\linewidth",fig.width = 3.5,fig.height=2>>=
ggplot(mtcars, aes(mpg, wt))+geom_point()+facet_grid(vs ~ am, margins=TRUE)
ggplot(mtcars, aes(mpg, wt))+geom_point()+facet_grid(vs ~ am, margins=TRUE)
@
\caption{Side by side}
\end{figure}

\newpage
\begin{landscape}
This page is rotated.
<<fourth, echo = FALSE, fig.width = 4,fig.height = 3,out.width = "0.9\\linewidth">>=
ggplot(mtcars, aes(mpg, wt))+geom_point()+facet_grid(vs ~ am, margins=TRUE)
@
\end{landscape}
\end{document} fig.width fig.height out.width \caption{}
-------------------------------------------------------------------------------------------------------
fig.show='hold' out.width='.45\\linewidth' <<third, echo = FALSE, out.width="2in", fig.cap='Side by side',out.width='.45\\linewidth',fig.show='hold'>>=
ggplot(mtcars, aes(mpg, wt))+geom_point()+facet_grid(vs ~ am, margins=TRUE)
ggplot(mtcars, aes(mpg, wt))+geom_point()+facet_grid(vs ~ am, margins=TRUE)
@
-------------------------------------------------------------------------------------------------------
# Example matrix:
xx <- rnorm(3000)
# Generate some NAs
vv <- sample(3000, 200)
xx[vv] <- NA
# reshape to a matrix
dd <- matrix(xx, ncol = 3)
# find the number of NAs per column
apply(dd, 2, function(x) sum(is.na(x)))
# tack on some column names
colnames(dd) <- paste0("x", seq(3))

# Function to find the number of pairwise complete observations 
# among all pairs of columns in a matrix. It returns a data frame
# whose first two columns comprise all column pairs

pairwiseN <- function(mat)
{
    u <- if(is.null(colnames(mat))) paste0("x", seq_len(ncol(mat))) else colnames(mat)
    h <- expand.grid(x = u, y = u)

    f <- function(x, y)
           sum(apply(mat[, c(x, y)], 1, function(z) !any(is.na(z))))
    h$n <- mapply(f, h[, 1], h[, 2])
    h
}

# Call it
pairwiseN(dd) h <- expand.grid(x = u[-1], y = u[-length(u)])
-------------------------------------------------------------------------------------------------------
library(lattice)
library(grid)


imgs.names <- c('WNinq','7dqJM','9E3Wj','tStmx')
library(png)
images <- lapply(imgs.names, function(x) 
     readPNG(paste(mypath,x,'.png',sep=''),native=TRUE))
## I generate some data because we don't give a reproducible example
x <- c(rep(0,4),rep(10,9),rep(20,3),rep(5,8),rep(4,8),rep(15,4),rep(13,8))
barchart(1:4~x, origin=0, col="yellow",xlim=c(0,30),
             xlab ='values',ylab='categories',title = 'Pictorial',
             scales = list(
               y = list(cex=2,col='blue', at = 1:4,labels = c('Trains','Cars','Ships','Planes')),
               x = list(cex=2,col='blue',at=seq(0,30,by=10))
               ),
             panel=function(x, y, ...) {
                panel.fill(col = rgb(1,1,205/255))    ## I had to pick up the same yellow color!!
                panel.grid()
                lapply(1:4,function(id){
                grid.raster(images[[id]], x=x[which(y==id)],  y=y[which(y==id)],
                           default.units="native",
                           just="left",
                           width =unit(2, "native"),
                           height=unit(0.7, "native"))
                }
            )
          }
         )
-------------------------------------------------------------------------------------------------------
u <- list(0:1)
g <- expand.grid(rep(u,3))
g <- g[order(rowSums(g)), ]
-------------------------------------------------------------------------------------------------------
R -boot- boot.ci n_cluster = 3 x y # fake sample 
  dat <- expand.grid(cat=factor(1:3), lab=factor(1:6))
  dat <- cbind(dat, x=runif(18), y=runif(18, 2, 5))

  # empty matrix for storing coefficients estimates and standard errors of x
  B <- 50 # number of bootstrap samples
  b.sample <- matrix(nrow=B, ncol=3, dimnames=list(c(), c("sim", "b_x", "se_x")))
  b.sample[,1] <- rep(1:B) B ####################################
  #   loop through "b.sample" rows   #
  ####################################

  for (i in seq(1:B)) {

  ###   sampling with replacement from the clustering variable   

    # sampling with replacement from "cluster" 
    cls <- sample(unique(dat$lab), replace=TRUE)
    cls.col <- data.frame(lab=cls)

    # reconstructing the overall simulated sample
    cls.resample <- merge(cls.col, dat, by="lab")


  ###   fitting linear model to simulated data    

    # model fit
    mod.fit <- function(data) glm(data$y ~ data$x)

    # estimated coefficients and standard errors
    b_x <- summary(mod.fit(data=cls.resample))$coefficients[2,1]
    se_x <- summary(mod.fit(data=cls.resample))$coefficients[2,2]

    b.sample[i,2] <- b_x
    b.sample[i,3] <- se_x

  } boot_se_x <- sum(b.sample[,3])/(B-1) 
 boot_se_x -boot-
-------------------------------------------------------------------------------------------------------
Group <- c(0, cumsum(diff(Time) > 1)) facet_grid scales = "free_x" library(ggplot2)
g <- ggplot(data.frame(Time, Value, Group)) + 
  geom_line (aes(x=Time, y=Value)) +
  facet_grid(~ Group, scales = "free_x")
-------------------------------------------------------------------------------------------------------
Edit: expand.grid filter the meaningless set.seed(12345)
m <- matrix(sample(1:50, 800, replace=T), ncol=8)
head(m)
get_grid <- function(in_mat, vec_num) {
    v.idx <- sapply(vec_num, function(idx) {
        which(apply(in_mat, 1, function(x) any(x == idx)))
    })
    out <- as.matrix(expand.grid(v.idx))
    colnames(out) <- NULL
    out
}

out <- get_grid(m, c(37, 10, 29, 42))
out.s <- t(apply(out, 1, sort))

idx <- rowSums(out == out.s)
out.f <- out[idx==4, ]

> dim(out.f)
[1] 2946    4

> head(out.f)
     [,1] [,2] [,3] [,4]
[1,]    1   22   28   36
[2,]    4   22   28   36
[3,]    6   22   28   36
[4,]    9   22   28   36
[5,]   11   22   28   36
[6,]   13   22   28   36 cont.idx <- apply(out.f, 1, function(x) x[1] == x[2]-1 & x[2] == x[4]-1)
> out.f[cont.idx,]
[1] 57 58 58 59
-------------------------------------------------------------------------------------------------------
facet_grid mydata = data.frame(x=rnorm(4), y=runif(4), tau=c(0,0,1,1))
ggplot(mydata) + geom_point(aes(x=x, y=y)) +
         facet_grid(~ tau,labeller = label_bquote(tau ^ .(x))) facet_grid(~ tau,labeller = label_bquote(tau == .(x))) my.label_bquote <- function (expr1 = (tau == .(x)),expr2 = (sigma == .(x))) 
{
   quoted1<- substitute(expr1)
   quoted2 <- substitute(expr2)
   function(variable, value) {
      value <- as.character(value)
      browser()
      if(variable == 'tau')
         lapply(value, function(x) eval(substitute(bquote(expr1, list(x = x)),list(expr1 = quoted1))))
      else
         lapply(value, function(x) eval(substitute(bquote(expr2, list(x = x)),list(expr2 = quoted2))))
   }
}

mydata = data.frame(x=rnorm(4), y=runif(4), tau=c(0,0,1,1),sigma=c(2,2,3,3))
ggplot(mydata) + geom_point(aes(x=x, y=y)) +
  facet_grid(sigma ~ tau,labeller = my.label_bquote())
-------------------------------------------------------------------------------------------------------
<<myplot,echo=FALSE,fig=TRUE>>=
library(car)
x <- rnorm(n=20,mean=30,sd=20)
y <- rnorm(n=20,mean=180,sd=10)
Dataset <- data.frame(x=x,y=y)
LMmodel <- y ~ x
fit <- lm(LMmodel, data = Dataset)
xLim = range(x)
yLim = range(y)
plot(x, y, type = "p", xlim = xLim, ylim = yLim,
    main = "plotTitle", xlab = "x [m]", ylab = "y [dB]",
    pch = 20, cex = .9)
regLine(fit, col=palette()[2], lwd=2, lty=1)
grid(lwd = 1.5)
plot(density(residuals(fit)), main = "Density Plot of the Residuals")
@ <<mysummary>>=
    print(summary(fit))
    @
-------------------------------------------------------------------------------------------------------
ggplot(temp) + 
  geom_bar(aes(x=1, y=Score), stat="identity") + 
  facet_grid(Exercise~Name) + 
  coord_polar(theta = "y") +
  scale_y_continuous(breaks = NULL) +
  scale_x_continuous(name = element_blank(), breaks = NULL)
-------------------------------------------------------------------------------------------------------
score score group temp <- data.frame(Exercise=c(1, 1, 1, 2, 2, 2), 
                   Name=c(1, 2, 3, 1, 2, 3), Score=c(0.2, 0.5, 0.3, 0.9, 1.0, 0.6))
temp<-rbind(temp,temp)
temp$Score[7:12]<-1-temp$Score[1:6]
temp$group<-rep(c("poz","neg"),each=6) coord_polar() facet_grid() theme() ggplot(temp,aes(x = factor(1),y=Score,fill=group)) + 
  geom_bar(width = 1, stat = "identity") + facet_grid(Exercise~Name)+
  coord_polar(theta = "y") +
  scale_fill_manual(values = c("black", "grey")) +
  theme_bw() + scale_x_discrete("",breaks=NULL) + scale_y_continuous("",breaks=NULL)+
  theme(panel.border=element_blank(),
        strip.text=element_blank(),
        strip.background=element_blank(),
        legend.position="none",
        panel.grid=element_blank())
-------------------------------------------------------------------------------------------------------
lapply out patches set.seed(1234)
nr <- 1040
nc <- 1392
data <- matrix(rnorm(nr*nc), nrow = nr)
patch.size <- 16
idx <- expand.grid(1:(ncol(data)-patch.size+1), 1:(nrow(data)-patch.size+1))
idx[,3] <- idx[,1]+patch.size-1
idx[,4] <- idx[,2]+patch.size-1
idx <- as.matrix(idx)

# using rbenchmark
require(rbenchmark)
myFun <- function() {
    out <- do.call(rbind, lapply(1:nrow(idx), 
        function(tx) c(data[idx[tx,2]:idx[tx,4], idx[tx,1]:idx[tx,3]])))
}
benchmark(myFun(), replications = 2)

# Result:
     test replications elapsed relative user.self sys.self user.child sys.child
1 myFun()            2 152.146        1   147.957    4.184          0         0

# using system.time
system.time(out <- do.call(rbind, lapply(1:nrow(idx), 
        function(tx) c(data[idx[tx,2]:idx[tx,4], idx[tx,1]:idx[tx,3]]))))        

# Result
  user  system elapsed 
58.852   1.784  60.638
-------------------------------------------------------------------------------------------------------
expand=c(0, 0) ?continuous_scale library(ggplot2)

pp <- function (n,r=4) {
  x <- seq(-r*pi, r*pi, len=n)
  df <- expand.grid(x=x, y=x)
  df$r <- sqrt(df$x^2 + df$y^2)
  df$z <- cos(df$r^2)*exp(-df$r/6)
  df
}
ggplot(pp(20), aes(x=x,y=y)) + 
  geom_tile(aes(fill=z)) + 
  scale_fill_gradient(low="green", high="red") +
  scale_x_continuous(expand=c(0, 0)) + 
  scale_y_continuous(expand=c(0, 0))
-------------------------------------------------------------------------------------------------------
panel.first plot plot(xlim=c(0,100), ylim=c(0,1), main=NULL, xaxs="i", yaxs="i",
  ecdf(PrecentageVector), col="red", do.p = FALSE, pch=19, lwd=3,
  panel.first = grid())
-------------------------------------------------------------------------------------------------------
a <- c(0,1)
b <- c(1,2,3)
combinations <- expand.grid(a,b)

k <- 2
combinations[sample(nrow(combinations),k),] Var1 Var2
2    1    1
5    0    3
-------------------------------------------------------------------------------------------------------
temp$size_f = factor(temp$size, levels=c('50%','100%','150%','200%')) facet_grid(.~size) facet_grid(.~size_f)
-------------------------------------------------------------------------------------------------------
forecast predict library(forecast)
value <- c(1.2,1.7,1.6, 1.2, 1.6, 1.3, 1.5, 1.9, 5.4, 4.2, 5.5, 6.0, 5.6, 6.2, 6.8, 7.1, 7.1, 5.8, 0.0, 5.2, 4.6, 3.6, 3.0, 3.8, 3.1, 3.4, 2.0, 3.1, 3.2, 1.6, 0.6, 3.3, 4.9, 6.5, 5.3, 3.5, 5.3, 7.2, 7.4, 7.3, 7.2, 4.0, 6.1, 4.3, 4.0, 2.4, 0.4, 2.4, 1.2,1.7,1.6, 1.2, 1.6, 1.3, 1.5, 1.9, 5.4, 4.2, 5.5, 6.0, 5.6, 6.2, 6.8, 7.1, 7.1, 5.8, 0.0, 5.2, 4.6, 3.6, 3.0, 3.8, 3.1, 3.4, 2.0, 3.1, 3.2, 1.6, 0.6, 3.3, 4.9, 6.5, 5.3, 3.5, 5.3, 7.2, 7.4, 7.3, 7.2, 4.0, 6.1, 4.3, 4.0, 2.4, 0.4, 2.4)
sensor <- ts(value,frequency=24) # consider adding a start so you get nicer labelling on your chart. 
fit <- auto.arima(sensor)
fcast <- forecast(fit)
plot(fcast)
grid()
fcast
         Point Forecast     Lo 80    Hi 80      Lo 95    Hi 95
3.000000       2.867879 0.8348814 4.900877 -0.2413226 5.977081
3.041667       3.179447 0.7369338 5.621961 -0.5560547 6.914950
3.083333       3.386926 0.7833486 5.990503 -0.5949021 7.368754
3.125000       3.525089 0.8531946 6.196984 -0.5612211 7.611400
3.166667       3.617095 0.9154577 6.318732 -0.5147025 7.748892
-------------------------------------------------------------------------------------------------------
d <- read.table(text="Loss_Yr Dev_Lag Claim_Amnt
1   2007    1   300
2   2007    2   10
3   2007    3   250
4   2007    5   5
5   2008    1   450
6   2008    2   80
7   2008    4   3
8   2009    1   175
9   2009    3   20
10  2010    1   95
11  2010    2   40
12  2011    1   130", header=TRUE, row.names=1)

filled <- merge(d, 
                with(d, expand.grid(Loss_Yr=unique(Loss_Yr), Dev_Lag=unique(Dev_Lag))), 
                all=TRUE)
-------------------------------------------------------------------------------------------------------
?legend plot PrecentageVector1 <- c(10,20,30)
plot(xlim=c(0,100), ylim=c(0,1), main=NULL, xaxs="i", yaxs="i", 
     ecdf(PrecentageVector1),  col="red", do.p = FALSE, pch=19, 
     lwd=3, panel.first = grid()) 
legend("bottomleft",c("A","B","C"))
-------------------------------------------------------------------------------------------------------
image() #using image() function
x<-c(0, 5, 30, 80, 1000)
y<-c(150, 2000, 2010, 3000)
grd <- expand.grid(x=x, y=y)
z<-matrix(grd$x*2-grd$y*3, nrow=length(x), ncol=length(y), byrow=TRUE)
image(x=x, y=y, z=z, col=rainbow(20))

#another option with z-scale
source("image.scale.r") #http://menugget.blogspot.de/2011/08/adding-scale-to-image-plot.html
x11(width=5, height=4)
layout(matrix(1:2, nrow=1, ncol=2), widths=c(4,1), heights=4, respect=TRUE)
layout.show(2)
par(mar=c(4,4,1,1))
image(x=x, y=y, z=z, col=rainbow(20))
par(mar=c(4,0,1,4))
image.scale(z, col=rainbow(20), horiz=FALSE, xlab="", ylab="", xaxt="n", yaxt="n")
axis(4)
box()
-------------------------------------------------------------------------------------------------------
mypanel <- function(x,y,...) {
   panel.xyplot(x, y, ...)
   panel.grid(x=-1, y=-1)
   panel.lmline(x,y,col="red",lwd=1,lty=1)
   } 
data <- mtcars[,2:11]
charts <- lapply(names(data), function(x) { xyplot (mtcars[,1] ~ mtcars[,x], 
                                               panel=mypanel,ylab="MPG", xlab=x)})
-------------------------------------------------------------------------------------------------------
auto.arima() predict forecast forecast() fit <- auto.arima(sensor,D=1)
LH.pred <- forecast(fit,h=30)
plot(LH.pred)
grid()
-------------------------------------------------------------------------------------------------------
matplotlibrc xtick.direction : out ytick.direction : out import numpy as np
import matplotlib
import matplotlib.pyplot as plt
# Data to be represented
X = np.random.randn(256)

# Actual plotting
fig = plt.figure(figsize=(8,6), dpi=72, facecolor="white")
axes = plt.subplot(111)
heights, positions, patches = axes.hist(X, color='white')

axes.spines['right'].set_color('none')
axes.spines['top'].set_color('none')
axes.xaxis.set_ticks_position('bottom')

# was: axes.spines['bottom'].set_position(('data',1.1*X.min()))
axes.spines['bottom'].set_position(('axes', -0.05))
axes.yaxis.set_ticks_position('left')
axes.spines['left'].set_position(('axes', -0.05))

axes.set_xlim([np.floor(positions.min()), np.ceil(positions.max())])
axes.set_ylim([0,70])
axes.xaxis.grid(False)
axes.yaxis.grid(False)
fig.tight_layout()
plt.show() axes.spines['bottom'].set_position?
-------------------------------------------------------------------------------------------------------
dim nei size^dim library(igraph)
g <- graph.lattice(5)
plot(g, layout=layout.grid(g,width=5)) plot(graph.lattice(c(5,5))) nei g <- graph.lattice(10, nei=2)
plot(g, layout=layout.circle) p=0 g <- watts.strogatz.game(dim=1,size=10,nei=2, p=0)
plot(g)
-------------------------------------------------------------------------------------------------------
library(ggplot2)

ggplot(new.reg, aes(x=aum, y=Pos.Percent)) + 
  geom_point() +   
  geom_smooth(method="lm") + 
  facet_grid(long.short~Op.Der)
-------------------------------------------------------------------------------------------------------
> a <- c(2,4,9)
> b <- c(3,6,9)
> sort(rowSums(expand.grid(a,b)))
[1]  5  7  8 10 11 12 13 15 18
-------------------------------------------------------------------------------------------------------
outer x <- rnorm(1000)
y <- rnorm(1000)
REP <- function() { z1 <- rep(x, length(x)) + rep(y, each=length(y)) }
GRID <- function() { z2 <- rowSums(expand.grid(x,y)) }
OUTER <- function() { z3 <- c(outer(x,y,"+")) }
require(rbenchmark)
benchmark(REP(), GRID(), OUTER(), replications = 10, order = "elapsed")

     test replications elapsed relative user.self sys.self user.child sys.child
3 OUTER()           10    0.24    1.000      0.19     0.05         NA        NA
1   REP()           10    0.31    1.292      0.21     0.10         NA        NA
2  GRID()           10    2.10    8.750      1.57     0.44         NA        NA
-------------------------------------------------------------------------------------------------------
time.data$Date2 Date2 data geom_text color aes aes label.color label.data scale_colour_manual scale_colour_identity plot <- ggplot()+
  geom_line(data=time.data, aes(as.numeric(Date2), value, 
                                group=Attribute, color=Color), 
            size=1)+
  geom_text(data=label.data, aes(x=Inf, y=value, 
                                 label=paste("  ",Attribute),
                                 color=label.color),
            size=4,vjust=0, hjust=0)+
  facet_grid(Attribute.Category~.,space="free") +
  scale_x_continuous(breaks=as.numeric(unique(time.data$Date2)),
                     labels=format(unique(time.data$Date2),format = "%b %Y")) +
  scale_colour_identity() +
  theme_bw()+
  theme(strip.background=element_blank(),
        strip.text.y=element_blank(),
        legend.text=element_blank(),
        legend.title=element_blank(),
        plot.margin=unit(c(1,5,1,1),"cm"),
        legend.position="none")
gt3 <- ggplot_gtable(ggplot_build(plot))
gt3$layout$clip[gt3$layout$name == "panel"] <- "off"
grid.draw(gt3) time.data <- 
structure(list(Attribute = structure(c(1L, 1L, 2L, 2L, 3L, 3L, 
4L, 4L), .Label = c("Taste 1", "Taste 2", "Use 1", "Use 2"), class = "factor"), 
    Attribute.Category = structure(c(2L, 2L, 2L, 2L, 1L, 1L, 
    1L, 1L), .Label = c("Nutritional/Usage", "Taste/Quality"), class = "factor"), 
    Color = c("#084594", "#084594", "#2171B5", "#2171B5", "#6A51A3", 
    "#6A51A3", "#807DBA", "#807DBA"), value = c(75L, 78L, 90L, 
    95L, 43L, 40L, 25L, 31L), Date2 = structure(c(15584, 15706, 
    15584, 15706, 15584, 15706, 15584, 15706), class = "Date")), .Names = c("Attribute", 
"Attribute.Category", "Color", "value", "Date2"), row.names = c(NA, 
-8L), class = "data.frame")

label.data <- 
structure(list(value = c(78L, 95L, 40L, 31L), Attribute = structure(1:4, .Label = c("Taste 1", 
"Taste 2", "Use 1", "Use 2"), class = "factor"), label.color = c("black", 
"forestgreen", "red", "forestgreen"), Attribute.Category = structure(c(2L, 
2L, 1L, 1L), .Label = c("Nutritional/Usage", "Taste/Quality"), class = "factor"), 
    Date2 = structure(c(15706, 15706, 15706, 15706), class = "Date")), .Names = c("value", 
"Attribute", "label.color", "Attribute.Category", "Date2"), row.names = c(NA, 
-4L), class = "data.frame")

ggplot() +
  geom_line(data = time.data, 
            aes(x=Date2, y=value, group=Attribute, colour=Color)) +
  geom_text(data = label.data,
            aes(x=Date2, y=value, label=Attribute, colour=label.color),
            hjust = 1) +
  facet_grid(Attribute.Category~.) +
  scale_colour_identity() Inf
-------------------------------------------------------------------------------------------------------
setdiff length(setdiff(5, 1:5)) == 0 all(x %in% y) dt <- expand.grid(list1,list2)
dt$subset <- apply(dt,1, function(.v) all(.v[[1]] %in% .v[[2]]) )


  Var1    Var2 subset
1    1 1, 2, 3   TRUE
2    2 1, 2, 3   TRUE
3    3 1, 2, 3   TRUE
4    1    2, 3  FALSE
5    2    2, 3   TRUE
6    3    2, 3   TRUE
7    1    2, 3  FALSE
8    2    2, 3   TRUE
9    3    2, 3   TRUE expand.grid
-------------------------------------------------------------------------------------------------------
expand.grid expand.grid(A)
#   Var1 Var2 Var3 Var4
# 1    1    2    3    1
# 2    4    2    3    1
# 3    1    2    3    4
# 4    4    2    3    4 rev(expand.grid(rev(A)))
#   Var4 Var3 Var2 Var1
# 1    1    2    3    1
# 2    1    2    3    4
# 3    4    2    3    1
# 4    4    2    3    4
-------------------------------------------------------------------------------------------------------
# create all possible combinations
comb <- expand.grid(yoda)

# find unique values for each combination
uni <- lapply(seq(nrow(comb)), function(x) unique(unlist(comb[x, ])))

# count the unique values
len <- lapply(uni, length)

# extract longest combination  
uni[which.max(len)]

[[1]]
[1] "A" "B" "C" "D" "E" "F"
-------------------------------------------------------------------------------------------------------
# data
temp <- structure(list(type = structure(c(1L, 2L, 3L, 2L, 3L, 3L), .Label = c("A", 
"B", "C"), class = "factor"), items = c(16L, 16L, 16L, 32L, 32L, 
64L), value = c(6.3, 8.3, 7.9, 7.7, 8.3, 7.9)), .Names = c("type", 
"items", "value"), class = "data.frame", row.names = c(NA, -6L
))

# plot
library(ggplot2)
ggplot(temp, aes(type, value, fill=type, group=items, facets=items)) + 
    geom_bar(stat="identity") + 
    facet_grid(.~ items, scales = "free_x", space="free") + 
    labs(y="value") + 
    scale_fill_manual(values = rep("steelblue",3), 
                      labels = c("A: Item A", "B: Item B", "C: Item C")) + 
    guides(fill = guide_legend(override.aes = list(fill = "white"))) + 
    theme_bw() + 
    opts(axis.title.y=theme_text(size=16,angle=90),
         axis.title.x=theme_text(size=16,angle=0)) + 
    opts(axis.text.x=theme_text(size=12)) + 
    opts(axis.text.y=theme_text(size=14)) + 
    opts(strip.background = theme_rect(colour = 'steelblue', fill = 'white',size = 1)) + 
    opts(legend.position="top", legend.text=theme_text(size=15), 
         legend.title=theme_text(size=0,colour="white")) +  
    opts(legend.key = theme_rect(colour = NA))
-------------------------------------------------------------------------------------------------------
good.cover <- function(top.list) {
    selection <- vector("list", length(top.list))
    num.new.unique <- function(x, y) length(setdiff(y, x))
    for (i in seq_along(top.list)) {
        score <- sapply(top.list[[i]], num.new.unique, x = unlist(selection))
        selection[[i]] <- top.list[[i]][which.max(score)]
    }
    selection
} items.universe <- apply(expand.grid(list(LETTERS, 0:9)), 1, paste, collapse = "")
random.length  <- function()sample(3:6, 1)
random.sample  <- function(i)sample(items.universe, random.length())
random.list    <- function(i)lapply(letters[1:12], random.sample)
initial.list   <- lapply(1:11, random.list) system.time(final.list <- good.cover(initial.list))
#    user  system elapsed 
#   0.004   0.000   0.004
-------------------------------------------------------------------------------------------------------
set.seed(100)

rand <- matrix(runif(100*3), ncol=3, nrow=100)
rand <- rand / apply(rand, 1, sum) # Make sure the numbers sum to one in each row
d <- data.frame(a = rand[,1],
                b = rand[,2],
                c = rand[,3],
                expand.grid(x=1:10, y=1:10)) ggplot(d, aes(x=x, y=y))+
  theme_bw() + #For a clearer background
  geom_tile(alpha=d$a, fill="red")+
  geom_tile(alpha=d$b, fill="blue")+
  geom_tile(alpha=d$c, fill="green")+
  theme(panel.grid.major=element_blank()) d2 <- data.frame(col=rgb(rand), expand.grid(x=1:10, y=1:10))

ggplot(d2, aes(x=x, y=y)) +
  theme_bw()+
  geom_tile(aes(fill=col))+
  scale_fill_identity()
-------------------------------------------------------------------------------------------------------
expand.grid apply matrix 1 idx <- expand.grid(1:3, 1:3)
out <- apply(idx, 1, function(ix) {
    if (all(ix==ix[1])) {
        return(NA)
    } else {
        summary(lm(x[1:11, ix[1]] ~ x[1:11, ix[2]]))$coefficients[2,1]
    }
})

> out.m <- matrix(out, ncol=3)
> out.m

#           [,1]      [,2]      [,3]
# [1,]        NA 0.3015123 0.6071429
# [2,] 0.8122685        NA 0.7978208
# [3,] 0.6384838 0.3114367        NA
-------------------------------------------------------------------------------------------------------
aes(colour="red") position="dodge" df <- data.frame(a=rep(rep(c("A","B"),each=2),2), 
b=rep(1:2,4), 
c=rep(c("X","Y"),each=4), 
d=c(1.2,1.1,1.15,1.1, -1.1,-1.05,-1.2,-1.08)) p <- ggplot(NULL, aes(x=b, y=d)) +      
facet_grid(. ~ c + a) +
geom_bar(data = df, stat="identity", position="dodge") +
theme(axis.ticks = element_blank(), axis.text.x = element_blank(), axis.title.x = element_blank())

print(p)
-------------------------------------------------------------------------------------------------------
df$c <- factor(df$c, levels=levels(df$c)[order(df$d)]) grid.newpage()
pushViewport(viewport(layout = grid.layout(1, 2))) a_df <- df[df$a=="A",]
a_df$c <- factor(a_df$c, levels=levels(a_df$c)[order(a_df$d)])

a_p <- ggplot(a_df, aes(x=1:10, y=d, fill=b)) +
facet_grid(. ~ a) +
geom_bar(stat="identity", position="dodge")

print(a_p, vp = viewport(layout.pos.row=1, layout.pos.col=1)) b_df <- df[df$a=="B",]
b_df$c <- factor(b_df$c, levels=levels(b_df$c)[order(b_df$d)])

b_p <- ggplot(b_df, aes(x=1:10, y=d, fill=b)) +
facet_grid(. ~ a) +
geom_bar(stat="identity", position="dodge")

print(b_p, vp = viewport(layout.pos.row=1, layout.pos.col=2))
-------------------------------------------------------------------------------------------------------
geom_bar ggplot(temp,aes(type, value)) + 
    geom_bar(stat="identity", aes(group=var, fill=type, facets=var),color = "blue1", position="identity",legend = "none") +
    geom_bar(stat="identity", aes(group=var, fill=type, facets=var), position="identity") +
    facet_grid(.~var) + 
    theme_bw()
-------------------------------------------------------------------------------------------------------
tf <- function(formula = NULL, data = NULL) {
  res <- as.character(formula[[2]])
  fac2 <- as.character(formula[[3]][3])
  fac1 <- as.character(formula[[3]][2])

  # Aesthetic & Data 1
  p <- ggplot(aes_string(x = fac1, y = res, color = fac1), data = data) +
    facet_grid(paste(".~", fac2)) + geom_point() # OK if we only go this far

  facCounts <- count(data, vars = c(fac2, fac1))
  facCounts$label <- paste("n = ", facCounts$freq , sep = "")
  facCounts$y <- min(data$res) - 0.1*diff(range(data$res))
  facCounts <- facCounts[,-3]
  names(facCounts) <- c("cat2", "f1", "lab", "y") # data frame looks correct

  # Aesthetic & Data 2
  p <- p + geom_text(aes(x = f1, y = y, label = lab),
                     color = "black", size = 4.0, data = facCounts)
  p
} facet_grid f2
-------------------------------------------------------------------------------------------------------
hist freq=FALSE breaks set.seed(1)
f1 <- rnorm(100, mean=0, sd=1)
f2 <- rnorm(100, mean=3, sd=3)
f3 <- rnorm(100, mean=4, sd=1)
f4 <- rnorm(100, mean=7, sd=3)

breaks <- pretty(c(f1, f2, f3, f4), n=20)
x11(width=4, height=8)
op <- par(mfcol=c(4,1))
hist(f1, freq=FALSE, breaks=breaks)
hist(f2, freq=FALSE, breaks=breaks)
hist(f3, freq=FALSE, breaks=breaks)
hist(f4, freq=FALSE, breaks=breaks)
par(op) t set.seed(1)

N <- 100
M <- 7
MEAN <- c(1:M)
SD <- MEAN*0.2+1
RES <- list()

for(i in seq(M)){
    RES[[i]] <- rnorm(N, mean=MEAN[[i]], sd=SD[[i]])
}


breaks <- pretty(unlist(RES), n=20)
x11(width=4, height=10)
op <- par(mfcol=c(M,1), mar=c(1,3,0,0), oma=c(3,2,1,1))
for(i in seq(M)){
    h1 <- hist(RES[[i]], breaks=breaks, plot=FALSE)
    plot(h1$mids, h1$densit, t="n", xlab="", ylab="", xaxt="n")
    grid()
    lines(h1$mids, h1$densit, t="S")
    text(par()$usr[1], par()$usr[3]+(par()$usr[4]-par()$usr[3])*0.9, labels=paste("t", i), pos=4)
    if(i == M){
        axis(1)
    } else {
        axis(1, labels=FALSE)
    }
}
mtext("Density", outer=TRUE, side=2, line=0)
par(op)
-------------------------------------------------------------------------------------------------------
rgdal sp maptools library(ncdf)
library(rgdal)
library(sp)
library(maptools)
nc <- open.ncdf("20130128-ABOM-L4HRfnd-AUS-v01-fv01_0-RAMSSA_09km.nc")

# Grab the longitude, latitude and data
lon <- nc$dim$lon$vals
lat <- nc$dim$lat$vals
sst <- get.var.ncdf(nc,"analysed_sst")

# Create a SpatialPointsDataFrame object
lonlat <- expand.grid(lon,lat)
sst <- as.data.frame(matrix(sst,ncol=1))
dat <- SpatialPointsDataFrame(lonlat, data=sst,
                              proj4string=CRS("+proj=longlat +datum=WGS84 "))

# And then reproject
dat2 <- spTransform(dat,CRS("+proj=lcc"))  
# Of course you have to write the proj4 string that corresponds exactly to the desired projection.
-------------------------------------------------------------------------------------------------------
widths = c(0.5, 0.5, 1/3,1/4,1/5, 3.5, 0.5)
heights = c(25, 10, 5,4.5,4,2,0.5) barplot ##Also specify colours
barplot(heights, widths, space=0, 
        col = colours()[1:6]) axis(1, 0:6) grid ##Look at ?grid to for more control over the grid lines
grid() arrows(1, 10, 1.2, 12, code=1)
text(1.2, 13, "A country") polygon polygon(c(4,4,5,5), c(20, 25, 25, 20), col="antiquewhite1")
text(4.3, 22.5, "Hi there", cex=0.6) par(mar=c(3,3,2,1), 
    mgp=c(2,0.4,0), tck=-.01,
    cex.axis=0.9, las=1)
-------------------------------------------------------------------------------------------------------
df <- data.frame(cyl = mtcars[,2])
(df2 <- t(table(df$cyl)))
# Assume you know the group labels
df2 <- data.frame(val=df2[1, ], label=c("Control", "Treat1", "Treat2"))
df2$cyl2 <- c("Control", "Treatment", "Treatment")

ggplot(df2, aes(label, val)) +
geom_bar(fill="white", colour="darkgreen", alpha=0.5, stat="identity") +
  facet_grid(. ~ cyl2, scales = "free", space = "free") +
  theme(axis.title.x  = element_blank(), axis.title.y  = element_blank(),
        axis.ticks.x = element_blank(), legend.position = "none") +
  scale_y_continuous(breaks=c(4, 6, 8), labels=c("Minimal","Mild", "Moderate")) +
  scale_x_discrete(breaks=c(6,8,4), labels=c("Treat 1", "Treat 2", "Control"))
-------------------------------------------------------------------------------------------------------
msleep.noNA.red <- within(msleep.noNA.red,
                         name <- ordered(name, levels = rev(sort(unique(name))))) pg <- ggplot(msleep.noNA.red, aes(value, name, colour = variable)) +
  geom_point() +
  facet_grid(vore ~ ., scale="free_y", space = "free_y")
-------------------------------------------------------------------------------------------------------
as.integer(as.Date(apply(expand.grid(1:12,c(1994,2001)), 1, 
                         function(x)paste(x[2], x[1], 28,sep="-"))))

 [1]  8793  8824  8852  8883  8913  8944  8974  9005  9036  9066  9097  9127 11350 11381 11409 11440 11470 11501
[19] 11531 11562 11593 11623 11654 11684 expand.grid(1:12, c(1994,2001))
 Var1 Var2
1     1 1994
2     2 1994
3     3 1994
4     4 1994
5     5 1994
6     6 1994
7     7 1994
8     8 1994
9     9 1994
10   10 1994
11   11 1994
12   12 1994
13    1 2001
14    2 2001
15    3 2001
16    4 2001
17    5 2001
18    6 2001
19    7 2001
20    8 2001
21    9 2001
22   10 2001
23   11 2001
24   12 2001 apply paste()
-------------------------------------------------------------------------------------------------------
list.of.matrices <- apply(expand.grid(rep(list(c(FALSE, TRUE)), ncol(myarray))),
                          1, function(j)myarray[, j, drop = FALSE])

length(list.of.matrices)
# [1] 1024 result <- sapply(list.of.matrices, function_of_your_choice) det
-------------------------------------------------------------------------------------------------------
apply cov.mat <- cov(myarray)
# is a 5-by-5 matrix

dets <- apply(expand.grid(rep(list(c(FALSE, TRUE)), ncol(cov.mat))),
              1, function(j) det(cov.mat[j, j, drop = FALSE]))
# is a vector of length 32 list.of.cov.mat <- apply(expand.grid(rep(list(c(FALSE, TRUE)), ncol(cov.mat))),
                         1, function(j) cov.mat[j, j, drop = FALSE])
# is a list of 32 covariance matrices
dets <- sapply(list.of.cov.mat, det)
# is a vector of length 32 list.of.mat <- apply(expand.grid(rep(list(c(FALSE, TRUE)), ncol(cov.mat))),
                         1, function(j) myarray[, j, drop = FALSE])
# is a list of 32 matrices
list.of.cov.mat <- lapply(list.of.mat, cov)
# is a list of 32 covariance matrices
dets <- sapply(list.of.cov.mat, det)
# is a vector of length 32
-------------------------------------------------------------------------------------------------------
geom_point geom_jitter geom_point p <- ggplot(test_subset, aes(x = var1, y = value))
p <- p + facet_grid(~variable) + coord_flip()
p <- p + geom_jitter(position = position_jitter(width=0.2, height = 0.2))
p
-------------------------------------------------------------------------------------------------------
expand.grid(unique(x),unique(y)) require(data.table)
dt <- data.table(expand.grid(x,y))
setkey(dt, "Var1", "Var2")
dt[, .N, by="Var1,Var2"]

#     Var1 Var2 N
#  1:    1    1 4
#  2:    1    2 2
#  3:    1    4 2
#  4:    1    8 4
#  5:    2    1 2
#  6:    2    2 1
#  7:    2    4 1
#  8:    2    8 2
#  9:    5    1 2
# 10:    5    2 1
# 11:    5    4 1
# 12:    5    8 2
# 13:    7    1 2
# 14:    7    2 1
# 15:    7    4 1
# 16:    7    8 2
# 17:    8    1 2
# 18:    8    2 1
# 19:    8    4 1
# 20:    8    8 2
-------------------------------------------------------------------------------------------------------
p1 <- ggplot(dat, aes(Date, count)) + 
  geom_bar(aes(fill=Industry), stat="identity", position="stack") + 
  geom_smooth(method="lm", se=T, size=0.5, colour="yellow") +
  facet_grid(Industry~Country, scales="free_y", margins=T) + 
  scale_x_date(breaks = "3 month", minor_breaks = "1 week", 
             labels=date_format("%b-%y")) mytheme <-  theme(legend.position = 'bottom', legend.direction = 'horizontal',
        legend.title = element_blank(), 
        legend.text = element_text(size=10, face = 'bold')) +
  theme(axis.title.x = element_text(face="bold", colour="white", size=12), 
        axis.text.x  = element_text(angle=90, face="bold", size=10),
        axis.title.y = element_text(face="bold", 
                                    colour="white", 
                                    angle=90, 
                                    size=10),
        axis.text.y=element_text(size=10, face="bold"),
        legend.text = element_text(size=10, face = 'bold'), 
        legend.title = element_blank()) +
  theme(strip.text.x = element_text(size=10, 
                                    face="bold", colour="navyblue"), 
        strip.background = element_rect(colour="blue", fill="white"))+ 
  theme(plot.title=element_text(size=13, colour="white", face="bold"))


  p1 + mytheme
-------------------------------------------------------------------------------------------------------
data.table require(utils)
require(data.table)

## Data generation
N <- 2e6
set.seed(1)
states <- c("a","b")
cost <- data.frame(a=c("aa","ab"),b=c("ba","bb"))
transitions <- data.frame(from=sample(states, N, replace=T), 
                            to=sample(states, N, replace=T))

## Expanded cost matrix construction
f <- expand.grid(states, states)
f <- f[order(f$Var1, f$Var2),]
f$cost <- unlist(cost)

## Prepare data.table
dt <- data.table(transitions)
setkey(dt, from, to)

## Routine itself  
dt[,cost:=as.character("")] # You don't need this line if cost is numeric
apply(f, 1, function(x) dt[J(x[1],x[2]),cost:=x[3]]) transitions
-------------------------------------------------------------------------------------------------------
require(gregmisc)
x <- c(a=10, b=29, c=10, d=10, e=-15)
y <- sort(x, decreasing=T)

if (any(duplicated(y))) {
    o <- sapply(unique(y), function(val) {
        m <- names(y[y==val])
        # just to make things quicker using length(m)
        if (length(m) <= 1) {
            return(m)
        }
        do.call(paste0, as.data.frame(permutations(length(m), length(m), m)))
    })
    out <- do.call(paste0, expand.grid(o))
} else {
    out <- paste(names(y), collapse="")
}

# [1] "bacde" "badce" "bcade" "bcdae" "bdace" "bdcae" x <- c(a=10, b=29, c=10, d=-10, e=35, f=-10, g=10)
y <- sort(x, decreasing = TRUE) # [1] "ebacgdf" "ebagcdf" "ebcagdf" "ebcgadf" "ebgacdf" "ebgcadf" "ebacgfd" "ebagcfd"
# [9] "ebcagfd" "ebcgafd" "ebgacfd" "ebgcafd"
-------------------------------------------------------------------------------------------------------
matrix # sort the 'liked' values (this is not neccessary for the example data)
vec <- with(ratingDB, liked[order(user, movie)])

# create a matrix
matrix(vec, nrow = length(unique(ratingDB$user)), byrow = TRUE)

     [,1] [,2] [,3]
[1,]    1   NA    0
[2,]    1    1    0
[3,]   NA   NA    1 ratingDB$liked byrow = TRUE NA NA subDB <- ratingDB[complete.cases(ratingDB), ]

  user movie liked
1    1     1     1
3    1     3     0
4    2     1     1
5    2     2     1
6    2     3     0
9    3     3     1 expand.grid user movie full <- setNames(with(subDB, expand.grid(sort(unique(user)), sort(unique(movie)))),
                 c("user", "movie"))

  movie user
1     1    1
2     2    1
3     3    1
4     1    2
5     2    2
6     3    2
7     1    3
8     2    3
9     3    3 subDB full merge ratingDB_2 <- merge(full, subDB, all = TRUE)

  user movie liked
1    1     1     1
2    1     2    NA
3    1     3     0
4    2     1     1
5    2     2     1
6    2     3     0
7    3     1    NA
8    3     2    NA
9    3     3     1 liked matrix(ratingDB_2$liked, nrow = length(unique(ratingDB_2$user)), byrow = TRUE)

     [,1] [,2] [,3]
[1,]    1   NA    0
[2,]    1    1    0
[3,]   NA   NA    1
-------------------------------------------------------------------------------------------------------
d <- read.table(textConnection("income  expend  id
9142.7  1576.2  1
23648.75 2595   2
9014.25 156 1
4670.4  604.4   3
6691.4  3654.4  3
14425.2 66  2
8563.45 1976.2  2
2392    6   1
7915.95 619.2   3
4424.2  504.2   2"), header=TRUE)

library(reshape2)
d2 <- melt(d, id.var="id")
ggplot(data=d2, aes(x=id,y=value)) + stat_summary(fun.y="mean", geom="bar") + facet_grid(.~variable)
-------------------------------------------------------------------------------------------------------
by ##dat$split <- cut(dat$a,seq(0, 1, 0.05),include.lowest=T)

dat$split <- c(0,cumsum(diff(dat$a) > 0.05)) by(dat,dat$split,FUN =function(x){
  P <- x$b
  if( is.null(P)||length(P) ==1) return(0)
  nn <- length(P)
  ind <- expand.grid(1:nn,1:nn)     ## I generate indexes here
  ret <- abs(P[ind[,1]]/P[ind[,2]]-1)   ## perfom P_l/P_m-1  (vectorized)
  list(P=P,
       ret.max = max(ret),
        ret.ind = ind[which.max(ret),])
}) dat$split: 0
$P
[1] 0.0130 0.0014 0.0014 0.0020

$ret.max
[1] 8.6236

$ret.ind
  Var1 Var2
5    1    2

--------------------------------------------------------------------------------------------------------------- 
dat$split: 1
$P
[1] 0.0014 0.0000

$ret.max
[1] 1

$ret.ind
  Var1 Var2
2    2    1
-------------------------------------------------------------------------------------------------------
plot(x = 1:10, y = rnorm(10, 5, 2), xlim=c(1, 10), ylim=c(1, 10), panel.first=grid()) plot(x = 1:10, y = rnorm(10, 5, 2), xaxp=c(1, 10, 10), yaxp=c(1, 10, 10), axes=FALSE)
axis(1, 1:10)
axis(2, 1:10)
abline(h=1:10, v=1:10, col="gray", lty=3)
-------------------------------------------------------------------------------------------------------
# starting data
x <- c(0,1,2,3)
y <- c(4,5,6)
z <- c(7,8)

# find every combo
w <- expand.grid( x , y , z )

# convert to a matrix
v <- as.matrix( w )

# view your result
v
-------------------------------------------------------------------------------------------------------
as.formula paste p <- p + facet_grid(as.formula(paste(". ~", fac2)))
-------------------------------------------------------------------------------------------------------
formula.tools wt ~ am*vs wt~am | vs latticeParseFormula facet facet_grid environment = parent.frame() library(formula.tools)

tf <- function(formula, faceting = NULL, data, print = TRUE) {
   y <- rhs(formula)
   x <- lhs(formula)

  p <- ggplot(environment = parent.frame()) 

  p <- p + geom_point(aes_string(x = x, y = y), data = data) 
   if (! is.null(faceting)){
     rhsfacet <- all.vars(rhs(faceting))
     lhsfacet <- all.vars(lhs(faceting))
     if(length(lhsfacet)==1 & any(lhsfacet %in% '.')) {lhsfacet <- NULL}
     if(length(rhsfacet)==1 & any(rhsfacet %in% '.')) {rhsfacet <- NULL}
     p <- p+ facet_grid(facet = list( lhsfacet, rhsfacet))}
  if(print) {print(p)}
  p 

}
tf(wt~mpg, faceting = ~am, data = mtcars, print = TRUE)
-------------------------------------------------------------------------------------------------------
expand.grid > a <- structure(list(Date = structure(c(1L, 1L, 1L, 1L, 1L, 1L, 3L,
+ 3L, 2L), .Label = c("1/1/2012", "1/12/2012", "1/2/2012"), class = "factor"),
+ Company = structure(c(3L, 3L, 3L, 2L, 2L, 1L, 3L, 2L, 4L), .Label = c("   Gateway",
+ "   HP", "   IBM", "  Gateway"), class = "factor"), Region = structure(c(3L,
+ 5L, 6L, 1L, 2L, 7L, 4L, 2L, 7L), .Label = c("         America",
+ "         Europe", "        America", "        Americas",
+ "        Europe", "        Pacific", "    Americas"), class = "factor"),
+ Units = c(10L, 4L, 2L, 10L, 2L, 2L, 10L, 2L, 10L)), .Names = c("Date",
+ "Company", "Region", "Units"), class = "data.frame", row.names = c(NA,
+ -9L))
> 
> b <- expand.grid(Date=unique(a$Date), Company=unique(a$Company), Region=unique(a$Region))
> 
> 
> 
> z <- merge(x=b,y=a, all.x=T)
> 
> z[is.na(z)] <- 0
> z
        Date    Company           Region Units
1   1/1/2012    Gateway          America     0
2   1/1/2012    Gateway           Europe     0
3   1/1/2012    Gateway          America     0
4   1/1/2012    Gateway         Americas     0
5   1/1/2012    Gateway           Europe     0
6   1/1/2012    Gateway          Pacific     0
7   1/1/2012    Gateway         Americas     2
8   1/1/2012         HP          America    10
9   1/1/2012         HP           Europe     2
10  1/1/2012         HP          America     0
11  1/1/2012         HP         Americas     0
12  1/1/2012         HP           Europe     0
13  1/1/2012         HP          Pacific     0
14  1/1/2012         HP         Americas     0
15  1/1/2012        IBM          America     0
16  1/1/2012        IBM           Europe     0
17  1/1/2012        IBM          America    10
18  1/1/2012        IBM         Americas     0
19  1/1/2012        IBM           Europe     4
20  1/1/2012        IBM          Pacific     2
21  1/1/2012        IBM         Americas     0
22  1/1/2012    Gateway          America     0
23  1/1/2012    Gateway           Europe     0
24  1/1/2012    Gateway          America     0
25  1/1/2012    Gateway         Americas     0
26  1/1/2012    Gateway           Europe     0
27  1/1/2012    Gateway          Pacific     0
28  1/1/2012    Gateway         Americas     0
29 1/12/2012    Gateway          America     0
30 1/12/2012    Gateway           Europe     0
31 1/12/2012    Gateway          America     0
32 1/12/2012    Gateway         Americas     0
33 1/12/2012    Gateway           Europe     0
34 1/12/2012    Gateway          Pacific     0
35 1/12/2012    Gateway         Americas     0
36 1/12/2012         HP          America     0
37 1/12/2012         HP           Europe     0
38 1/12/2012         HP          America     0
39 1/12/2012         HP         Americas     0
40 1/12/2012         HP           Europe     0
41 1/12/2012         HP          Pacific     0
42 1/12/2012         HP         Americas     0
43 1/12/2012        IBM          America     0
44 1/12/2012        IBM           Europe     0
45 1/12/2012        IBM          America     0
46 1/12/2012        IBM         Americas     0
47 1/12/2012        IBM           Europe     0
48 1/12/2012        IBM          Pacific     0
49 1/12/2012        IBM         Americas     0
50 1/12/2012    Gateway          America     0
51 1/12/2012    Gateway           Europe     0
52 1/12/2012    Gateway          America     0
53 1/12/2012    Gateway         Americas     0
54 1/12/2012    Gateway           Europe     0
55 1/12/2012    Gateway          Pacific     0
56 1/12/2012    Gateway         Americas    10
57  1/2/2012    Gateway          America     0
58  1/2/2012    Gateway           Europe     0
59  1/2/2012    Gateway          America     0
60  1/2/2012    Gateway         Americas     0
61  1/2/2012    Gateway           Europe     0
62  1/2/2012    Gateway          Pacific     0
63  1/2/2012    Gateway         Americas     0
64  1/2/2012         HP          America     0
65  1/2/2012         HP           Europe     2
66  1/2/2012         HP          America     0
67  1/2/2012         HP         Americas     0
68  1/2/2012         HP           Europe     0
69  1/2/2012         HP          Pacific     0
70  1/2/2012         HP         Americas     0
71  1/2/2012        IBM          America     0
72  1/2/2012        IBM           Europe     0
73  1/2/2012        IBM          America     0
74  1/2/2012        IBM         Americas    10
75  1/2/2012        IBM           Europe     0
76  1/2/2012        IBM          Pacific     0
77  1/2/2012        IBM         Americas     0
78  1/2/2012    Gateway          America     0
79  1/2/2012    Gateway           Europe     0
80  1/2/2012    Gateway          America     0
81  1/2/2012    Gateway         Americas     0
82  1/2/2012    Gateway           Europe     0
83  1/2/2012    Gateway          Pacific     0
84  1/2/2012    Gateway         Americas     0 America Gateway expand.grid
-------------------------------------------------------------------------------------------------------
log(N2012$Rate) `log(N2012$Rate)` Gas fill ggplot(Data, aes(Location, `log(N2012$Rate)`, fill=Gas)) +
  geom_boxplot(width = 0.7) + 
  geom_point() +
  facet_grid(Gas ~ Month) +
  scale_fill_manual(values=colvec) +
  xlab("Location") + 
  ylab("log(N2O ug N2O-N/m2/h)") + 
  theme(axis.title.x = element_text(face="bold", colour="Black", size=15),
        axis.text.x  = element_text(angle=50, vjust=0.5, size=12, colour="Black"), 
        axis.title.y = element_text(face="bold", size=13), 
        axis.text.y = element_text(size=12, colour="black"))
-------------------------------------------------------------------------------------------------------
rainbow col <- rainbow(30)
col.index <- ifelse(seq(col) %% 2, 
                    seq(col), 
                    (seq(ceiling(length(col)/2), length.out=length(col)) %% length(col)) + 1)
mixed <- col[col.index]

p <- ggplot(icc, aes(x=state, y=count, fill=entity)) +
  geom_bar(stat="identity", position="stack") +
  facet_grid( type ~ . ) + 
  scale_fill_manual(values=rep(mixed, length.out=nrow(icc)))

custom_theme <- theme_update(legend.position='none')
p
-------------------------------------------------------------------------------------------------------
year data.frame df require(ggplot2)
require(reshape2)
df1 <- read.csv("~/Downloads/testseries.csv")
df <- melt(df1,id=c("date"))
df$date <- as.Date(df$date)

# get `year` first
# df$year <- as.POSIXlt(df$date)$year + 1900 (old code)
# df$year <- format(df$date,'%Y') # following @agstudy's comment.
p <- ggplot(data = df, aes(x=date, y=value))
# group/colour by year
p <- p + geom_line(aes(colour=factor(year))) 
p <- p + scale_colour_brewer(palette="Set3") 
p <- p + facet_wrap(~ variable, scales="free", ncol=3)
p <- p + xlab("Date") + ylab("Discharge(cms)")
p facet_grid df$year <- factor(as.POSIXlt(df$date)$year + 1900)
p <- ggplot(data = df, aes(x=date, y=value))
p <- p + geom_line() 
p <- p + facet_grid(variable ~ year)
p <- p + xlab("Date") + ylab("Discharge(cms)")
p
-------------------------------------------------------------------------------------------------------
require(gregmisc)
perm <- permutations(5, 2, paste0("X", 1:5), repeats.allowed=TRUE)
# instead of gregmisc + permutations, you can use expand.grid from base as:
# perm <- expand.grid(paste0("X", 1:5), paste0("X", 1:5))
o <- apply(perm, 1, function(idx) {
    t <- tmp1[idx]
    names(t) <- c("A", "B")
    t$id1 <- idx[1]
    t$id2 <- idx[2]
    t
})
require(ggplot2)
require(reshape2)    
o <- do.call(rbind, o)
o.m <- melt(o, c("id1", "id2"))
o.m$id1 <- factor(o.m$id1)
o.m$id2 <- factor(o.m$id2)
p <- ggplot(o.m, aes(x = value))
p <- p + geom_density(alpha = 0.2, position = "identity", aes(fill = variable)) 
p <- p + theme(legend.position = "none")
p <- p + facet_grid(id1 ~ id2)
p
-------------------------------------------------------------------------------------------------------
reshape2 library(reshape2)
dat.m <- melt(dat, id.vars='Treatment')
library(ggplot2)
ggplot(data = dat.m, 
        aes(x=Treatment, y=value,shape = Treatment,color=Treatment)) + 
                  geom_point()+facet_grid(~variable) dotplot dotplot(value~Treatment|variable,
        groups = Treatment, data=dat.m,
        pch=c(25,19),
        par.strip.text=list(cex=3),
        cex=2)
-------------------------------------------------------------------------------------------------------
aes() aes(size = 2) `2` aes reg_labeller Figure29 + geom_line(aes(group=factor(tradlib)),size=1) + facet_grid(regionsFull~., scales="free_y") + scale_colour_brewer(type = "div") +
     theme(axis.text.x = element_text(colour = 'black', angle = 90, size = 13, hjust = 0.5, vjust = 0.5),axis.title.x=element_blank()) + 
     ylab("FSI (%Change)") + theme(axis.text.y = element_text(colour = 'black', size = 12), axis.title.y = element_text(size = 12, hjust = 0.5, vjust = 0.2)) + 
     theme(strip.text.y = element_text(size = 11, hjust = 0.5, vjust = 0.5, face = 'bold')) Figure29 + geom_line(aes(group=factor(tradlib)),size=2) + facet_grid(regionsFull~., scales="free_y") + scale_colour_brewer(type = "div") +
         theme(axis.text.x = element_text(colour = 'black', angle = 90, size = 13, hjust = 0.5, vjust = 0.5),axis.title.x=element_blank()) + 
         ylab("FSI (%Change)") + theme(axis.text.y = element_text(colour = 'black', size = 12), axis.title.y = element_text(size = 12, hjust = 0.5, vjust = 0.2)) + 
         theme(strip.text.y = element_text(size = 11, hjust = 0.5, vjust = 0.5, face = 'bold'))
-------------------------------------------------------------------------------------------------------
quantiles heatmaps quantiles quantile(x$Units, seq(0, 1, length.out = 25)

#      0% 4.166667% 8.333333%     12.5% 16.66667% 20.83333%       25% 29.16667% 33.33333% 
# 0.00000   0.00000   0.00000   0.00000   0.00000   0.00000   0.00000   0.00000   0.00000 
#   37.5% 41.66667% 45.83333%       50% 54.16667% 58.33333%     62.5% 66.66667% 70.83333% 
# 1.00000   1.00000   2.00000   2.00000   3.00000   3.00000   4.00000   4.00000   5.00000 
#     75% 79.16667% 83.33333%     87.5% 91.66667% 95.83333%      100% 
# 6.00000   7.00000   8.00000   9.62500  10.16667  25.41667  56.00000 0% Units=0 33% 33.33% 38% 60% 75% 90% 100% zoo require(zoo) # for rollapply
# the quantiles we just decided to categorise the data into classes.
qtiles    <- quantile(x$Units, probs = c(0, 38, 60, 75, 90, 100)/100)
# a color palette
c_pal     <- colorRampPalette(c("#3794bf", "#FFFFFF", 
                         "#df8640"))(length(qtiles)-1)
# since we are using quantile classes for fill levels, 
# we'll have to generate the appropriate labels
labels    <- rollapply(round(qtiles, 2), width = 2, by = 1, 
                      FUN = function(i) paste(i, collapse = " : "))
# added the quantile interval in which the data falls, 
# which will be used for fill
x$q.units <- findInterval(x$Units, qtiles, all.inside = TRUE)

# Now plot
library(ggplot2)
p <- ggplot(data = x, aes(x = Date, y = Company, fill = factor(q.units)))
p <- p + geom_tile(color = "black")
p <- p + scale_fill_manual(values = c_pal, name = "", labels = labels)
p <- p + facet_grid( ~ Region)
p <- p + theme(axis.text.x = element_text(angle = 90, hjust = 1))
p # try out these colors:
c_pal     <- c("#EDF8FB", "#B3CDE3", "#8C96C6", "#8856A7", "#810F7C")
c_pal     <- c("#FFFFB2", "#FECC5C", "#FD8D3C", "#F03B20", "#BD0026") alpha geom_tile(color = "black", alpha = 0.5")
-------------------------------------------------------------------------------------------------------
fac toy=data.frame(type=c("f", "f","f", "f", "i", "i", "i", "i"),fac=c(letters[1:4],1,5,7,40)) geom_bar() subset= fac facet_grid() scale_x_discrete() breaks= library(ggplot2)
library(plyr)    
ggplot(data=toy)+
  geom_bar(subset=.(type=="f"),aes(x=fac),width=0.2)+
  geom_bar(subset=.(type=="i"),aes(x=as.numeric(as.character(fac))))+
  facet_grid(.~type,scales="free") + 
  scale_x_discrete(breaks=c("a","b","c","d",1,5,7,40))
-------------------------------------------------------------------------------------------------------
myfunc <- function(n) {

  # create a data frame of all combinations
  grid <- expand.grid(rep(list(seq_len(n - 1)), 4))

  # remove invalid combinations (keep valid ones)
  grid <- grid[grid[3] <= grid[1] &         # number of hits <= number of signals
               grid[4] <= grid[2] &         # false alarms <= noise
               (grid[1] + grid[2]) == n , ] # signal and noise sum to total n

  # remove signal and noise > 20
  grid <- grid[!rowSums(grid[1:2] > 20), ]

  # sort rows
  grid <- grid[order(grid[1], grid[3], grid[4]), ]

  # add total number of trials
  res <- cbind(n, grid)

  # remove row names, add column names and return the object
  return(setNames("rownames<-"(res, NULL),
                  c("N_total", "Signal", "Noise", "N_Hit", "N_FA"))) 


} > myfunc(4)
   N_total Signal Noise N_Hit N_FA
1        4      1     3     1    1
2        4      1     3     1    2
3        4      1     3     1    3
4        4      2     2     1    1
5        4      2     2     1    2
6        4      2     2     2    1
7        4      2     2     2    2
8        4      3     1     1    1
9        4      3     1     2    1
10       4      3     1     3    1 lapply(3:40, myfunc)
-------------------------------------------------------------------------------------------------------
tile.list secr::pointsInPolygon # Sample data
x <- matrix( rnorm(20), nc = 2 )
y <- matrix( rnorm(1000), nc=2 )

# Tessellation
library(deldir)
d <- deldir(x[,1], x[,2])
plot(d, wlines="tess")

# Pick a cell at random 
cell <- sample( tile.list(d), 1 )[[1]]
points( cell$pt[1], cell$pt[2], pch=16 )
polygon( cell$x, cell$y, lwd=3 )

# Select the points inside that cell
library(secr)
i <- pointsInPolygon(
  y, 
  cbind( 
    c(cell$x,cell$x[1]), 
    c(cell$y,cell$y[1])
  )
)
points(y[!i,], pch=".")
points(y[i,], pch="+")

# Compute a tessellation of those points
dd <- deldir(y[i,1], y[i,2])
plot(dd, wlines="tess", add=TRUE) distance_to_segment <- function(M, A, B) {
  norm <- function(u) sqrt(sum(u^2))
  lambda <- sum( (B-A) * (M-A) ) / norm(B-A)^2
  if( lambda <= 0 ) {
    norm(M-A)
  } else if( lambda >= 1 ) {
    norm(M-B)
  } else {
    N <- A + lambda * (B-A)
    norm(M-N)
  }
}
A <- c(-.5,0)
B <- c(.5,.5)
x <- seq(-1,1,length=100)
y <- seq(-1,1,length=100)
z <- apply(
  expand.grid(x,y), 
  1, 
  function(u) distance_to_segment( u, A, B )
)
par(las=1)
image(x, y, matrix(z,nr=length(x)))
box()
segments(A[1],A[2],B[1],B[2],lwd=3)

library(secr)
distance_to_polygon <- function(x, poly) {
  closed_polygon <- rbind(poly, poly[1,])
  if( pointsInPolygon( t(x), closed_polygon ) )
    return(0)
  d <- rep(Inf, nrow(poly))
  for(i in 1:nrow(poly)) {
    A <- closed_polygon[i,]
    B <- closed_polygon[i+1,]
    d[i] <- distance_to_segment(x,A,B)
  }
  min(d)
}
x <- matrix(rnorm(20),nc=2)
poly <- x[chull(x),]
x <- seq(-5,5,length=100)
y <- seq(-5,5,length=100)
z <- apply(
  expand.grid(x,y), 
  1, 
  function(u) distance_to_polygon( u, poly )
)
par(las=1)
image(x, y, matrix(z,nr=length(x)))
box()
polygon(poly, lwd=3) x --> lambda * x + a
y --> lambda * y + b # Sample data 
x <- matrix(rnorm(20),nc=2)
x <- x[chull(x),]
y <- matrix( c(1,2) + 5*rnorm(20), nc=2 )
plot(y, axes=FALSE, xlab="", ylab="")
polygon(x)

# Function to minimize:
# either the sum of the squares of the distances to the polygon, 
# if at least one point is outside, 
# or minus the square of the scaling factor.
# It is not continuous, but (surprisingly) that does not seem to be a problem.
f <- function( p ) {
  lambda <- log( 1 + exp(p[1]) )
  a <- p[2:3]
  y0 <- colMeans(y)
  transformed_points <- t( lambda * (t(y)-y0) + a )
  distances <- apply(
    transformed_points, 
    1, 
    function(u) distance_to_polygon(u, x)
  )
  if( all(distances == 0) ) - lambda^2
  else                      sum( distances^2 )
}
# Minimize this function
p <- optim(c(1,0,0), f)$par
# Compute the optimal parameters
lambda <- log( 1 + exp(p[1]) )
a <- p[2:3]
y0 <- colMeans(y)
# Compute the new coordinates
transformed_points <- t( lambda * (t(y)-y0) + a )
# Plot them
segments( y[,1], y[,2], transformed_points[,1], transformed_points[,2], lty=3 )
points( transformed_points, pch=3 )
library(deldir)
plot( 
  deldir( transformed_points[,1], transformed_points[,2] ), 
  wlines="tess", add=TRUE 
)
-------------------------------------------------------------------------------------------------------
import itertools as it
import pandas as pd

def expand_grid(*args, **kwargs):
    columns = []
    lst = []
    if args:
        columns += xrange(len(args))
        lst += args
    if kwargs:
        columns += kwargs.iterkeys()
        lst += kwargs.itervalues()
    return pd.DataFrame(list(it.product(*lst)), columns=columns)

print expand_grid([0,1], [1,2,3])
print expand_grid(a=[0,1], b=[1,2,3])
print expand_grid([0,1], b=[1,2,3])
-------------------------------------------------------------------------------------------------------
require(ggplot2)
require(lattice)

# make some data
s = 100
i = 0.5
x0 <- 27
y0 <- 34
df <- expand.grid(x=seq(0,s,i), y=seq(0,s,i))
df <- transform(df, f = cos( 10*pi * sqrt((x - x0)^2 + (y-y0)^2)))

# try as points
ggplot(df,aes(x,y,color=f)) + geom_point()

# or as tile
ggplot(df,aes(x,y,fill=f)) + geom_tile()

# or even easier with lattice
levelplot(f ~ x * y, df)
-------------------------------------------------------------------------------------------------------
grd <- expand.grid(x1=unique(x1), x2=unique(x2) )
grd$pred <-predict(mod2, newdata=grd)
persp3d(x=unique(grd[[1]]), y=unique(grd[[2]]), 
              z=matrix(grd[[3]],5,5), add=TRUE)
-------------------------------------------------------------------------------------------------------
ggplot2 p <- ggplot(data = df, aes(x = Form, y = Percentage, fill = Position))
p <- p + geom_bar(stat = "identity", colour = "black")
p <- p + geom_text(position = "stack", aes(x = Form, y = Percentage, ymax = Percentage, label = Percentage, hjust = 0.5))
p <- p + facet_grid(Sample_name ~ Sample_type, scales="free", space="free")
p <- p + theme(plot.title = element_text("Input_profile"), 
         axis.text.x = element_text(angle = 90, hjust = 1, size = 8, colour = "grey50"), 
         plot.title = element_text(face="bold", size=11), 
         axis.title.x = element_text(face="bold", size=9), 
         axis.title.y = element_text(face="bold", size=9, angle=90),
         panel.grid.major = element_blank(), 
         panel.grid.minor = element_blank())
p <- p + scale_fill_hue(c=45, l=80)
p size df <- ddply(df, .(Form, Sample_type, Sample_name), transform, 
      cum.perc = Reduce('+', list(Percentage/2,cumsum(c(0,head(Percentage,-1))))))

p <- ggplot(data = df, aes(x = Form, y = Percentage, fill = Position))
p <- p + geom_bar(stat = "identity", colour = "black")
p <- p + geom_text(aes(x = Form, y = cum.perc, ymax = cum.perc, label = Percentage, hjust = 0.5), size=2.7)
p <- p + facet_grid(Sample_name ~ Sample_type, scales="free", space="free")
p <- p + theme(plot.title = element_text("Input_profile"), 
         axis.text.x = element_text(angle = 90, hjust = 1, size = 8, colour = "grey50"), 
         plot.title = element_text(face="bold", size=11), 
         axis.title.x = element_text(face="bold", size=9), 
         axis.title.y = element_text(face="bold", size=9, angle=90),
         panel.grid.major = element_blank(), 
         panel.grid.minor = element_blank())
p <- p + scale_fill_hue(c=45, l=80)
p
-------------------------------------------------------------------------------------------------------
dat <- data.frame(name=letters[1:4],photo=1:4)
 dat.ex <- expand.grid(dat)
 paste(dat.ex[,1],dat.ex[,2],sep='/')
 [1] "a/1" "b/1" "c/1" "d/1" "a/2" "b/2" "c/2" "d/2" "a/3" "b/3" "c/3" "d/3" "a/4" "b/4" "c/4" "d/4"
-------------------------------------------------------------------------------------------------------
Ellipses <- read.table(file.choose())
names(Ellipses) <- c('x','y','dfluxx','dfluxy','kxx','Temps','gradTx','gradTy')
require(splancs)
require(akima) #First the background layer (the 'kxx' layer):
# Here the regular grid on which we're gonna do the interpolation
E.grid <- with(Ellipses, 
               expand.grid(seq(min(x),max(x),length=200),
                           seq(min(y),max(y),length=200)))
names(E.grid) <- c("x","y") # Without this step, function inout throws an error
E.grid$Value <- rep(0,nrow(E.grid))
#Split the dataset according to unique values of kxx
E.k <- split(Ellipses,Ellipses$kxx)
# Find the convex hull delimiting each of those values domain
E.k.ch <- lapply(E.k,function(X){X[chull(X$x,X$y),]}) 
for(i in unique(Ellipses$kxx)){ # Pick the value for each coordinate in our regular grid
    E.grid$Value[inout(E.grid[,1:2],E.k.ch[names(E.k.ch)==i][[1]],bound=TRUE)]<-i
}

# Then the regular grid for the second layer (Temp)
T.grid <- with(Ellipses,
               interp(x,y,Temps, xo=seq(min(x),max(x),length=200),        
                      yo=seq(min(y),max(y),length=200), 
                      duplicate="mean", linear=FALSE))
# The regular grids for the arrow layer (gradT)
dx <- with(Ellipses,
           interp(x,y,gradTx,xo=seq(min(x),max(x),length=15),
                  yo=seq(min(y),max(y),length=10),
                  duplicate="mean", linear=FALSE))
dy <- with(Ellipses,
           interp(x,y,gradTy,xo=seq(min(x),max(x),length=15),
                  yo=seq(min(y),max(y),length=10),
                  duplicate="mean", linear=FALSE))
T.grid2 <- with(Ellipses,
               interp(x,y,Temps, xo=seq(min(x),max(x),length=15),        
                      yo=seq(min(y),max(y),length=10), 
                      duplicate="mean", linear=FALSE))
gradTgrid<-expand.grid(dx$x,dx$y) palette(grey(seq(0.5,0.9,length=5)))
par(mar=rep(0,4))
plot(E.grid$x, E.grid$y, col=E.grid$Value, 
     axes=F, xaxs="i", yaxs="i", pch=19)
contour(T.grid, add=TRUE, col=colorRampPalette(c("blue","red"))(15), drawlabels=FALSE)
arrows(gradTgrid[,1], gradTgrid[,2],  # Here I multiply the values so you can see them
       gradTgrid[,1]-dx$z*40*T.grid2$z, gradTgrid[,2]-dy$z*40*T.grid2$z, 
       col="yellow", length=0.05) ?inout ?chull ?interp ?expand.grid ?contour
-------------------------------------------------------------------------------------------------------
iris ggplot2 library(ggplot2)

plot_1 = ggplot(iris, aes(x=Petal.Length, colour=Species)) +
         geom_density() +
         labs(title="Density plots")

plot_2 = ggplot(iris, aes(x=Petal.Length, fill=Species)) +
         geom_histogram(colour="grey30", binwidth=0.15) +
         facet_grid(Species ~ .) +
         labs(title="Histograms")

plot_3 = ggplot(iris, aes(y=Petal.Length, x=Species)) +
         geom_point(aes(colour=Species),
                    position=position_jitter(width=0.05, height=0.05)) +
         geom_boxplot(fill=NA, outlier.colour=NA) +
         labs(title="Boxplots")

plot_4 = ggplot(iris, aes(y=Petal.Length, x=Species, fill=Species)) +
         geom_dotplot(binaxis="y", stackdir="center", binwidth=0.15) +
         labs(title="Dot plots")

library(gridExtra)
part_1 = arrangeGrob(plot_1, plot_2, heights=c(0.4, 0.6))
part_2 = arrangeGrob(plot_3, plot_4, nrow=2)
parts_12 = arrangeGrob(part_1, part_2, ncol=2, widths=c(0.6, 0.4))
ggsave(file="plots.png", parts_12, height=6, width=10, units="in")
-------------------------------------------------------------------------------------------------------
persp(z)

x = seq(1,10,0.1); y = seq(1,10,0.1)
z= outer(x,y,"*")
data =data.frame(x=rep(x, times=91), y=rep(y, each=91), z=c(z) )
data.loess = loess(z~x*y,data =data)
data.fit = expand.grid(list(x = seq(min(x),max(x),0.1), y = seq(min(y),max(y),0.1)))
z = predict(data.loess, newdata =data.fit)
persp(z)
-------------------------------------------------------------------------------------------------------
panel.level.plot latticeExtra calendarHeat date.seq value dotw woty   yr month seq
1 2012-01-01    NA    0    2 2012     1   1
2 2012-01-02    NA    1    2 2012     1   2
3 2012-01-03    NA    2    2 2012     1   3
4 2012-01-04    NA    3    2 2012     1   4
5 2012-01-05    NA    4    2 2012     1   5
6 2012-01-06    NA    5    2 2012     1   6 dat <- transformdata(stock.data$Date, stock.data$by) levelplot sacles theme panel' function library(latticeExtra)
levelplot(value~woty*dotw | yr, data=dat, border = "black",
          layout = c(1, nyr%%7),
          col.regions = (calendar.pal(ncolors)),
          aspect='iso',
          between = list(x=0, y=c(1,1)),
          strip=TRUE,
          panel = function(...) {
            panel.levelplot(...)
            calendar.division(...)  
            panel.levelplot.points(...,na.rm=T,
                                   col='blue',alpha=0.5,
                                   ## you can play with cex and pch here to get the pattern you      
                                   ## like
                                   cex =dat$value/max(dat$value,na.rm=T)*3
                                   pch=ifelse(is.na(dat$value),NA,20),
                                   type = c("p"))

          },
          scales= scales,
          xlim =extendrange(dat$woty,f=0.01),
          ylim=extendrange(dat$dotw,f=0.1),
          cuts= ncolors - 1,
          colorkey= list(col = calendar.pal(ncolors), width = 0.6, height = 0.5),
          subscripts=TRUE,
          par.settings = calendar.theme) scales = list(
   x = list( at= c(seq(2.9, 52, by=4.42)),
             labels = month.abb,
             alternating = c(1, rep(0, (nyr-1))),
             tck=0,
             cex =1),
   y=list(
     at = c(0, 1, 2, 3, 4, 5, 6),
     labels = c("Sunday", "Monday", "Tuesday", "Wednesday", "Thursday",
                "Friday", "Saturday"),
     alternating = 1,
     cex =1,
     tck=0)) calendar.theme <- list(
   xlab=NULL,ylab=NULL,
   strip.background = list(col = "transparent"),
   strip.border = list(col = "transparent"),
   axis.line = list(col="transparent"),
   par.strip.text=list(cex=2)) grid
-------------------------------------------------------------------------------------------------------
cr.setup Y >= 0; Y>=1, ... Y>=K-1 y <- c(NA, 10, 21, 32, 32)
> cr.setup(y)
$y
[1] NA  1  0  1  0  0  0  0

$cohort
[1] <NA>  all   all   y>=21 all   y>=21 all   y>=21
Levels: all y>=21

$subs
[1] 1 2 3 3 4 4 5 5

$reps
[1] 1 1 2 2 2 subs reps combinations <- expand.grid(cohort=levels(cohort), sex=levels(sex))
combinations
-------------------------------------------------------------------------------------------------------
combn FUN Reduce(paste0, expand.grid(lapply(words, function(x) {
  combn(x, m=2, FUN=paste0, collapse="")
}))) m combn for(i in seq_along(words)) {
  attr(words[[i]], "n") <- i
}

Reduce(paste0, expand.grid(lapply(words, function(x) {
  combn(x, m=attr(x, "n"), FUN=paste0, collapse="")})))
-------------------------------------------------------------------------------------------------------
> words
[1] "blue" "red"  "pink"
> wordsplit <- strsplit(words, split="")
> wordsplit
[[1]]
[1] "b" "l" "u" "e"

[[2]]
[1] "r" "e" "d"

[[3]]
[1] "p" "i" "n" "k"

> lengths <- c(2, 1, 3)
> combos <- expand.grid(mapply(function(word, n) combn(word,m=n, FUN=paste0, collapse=""), wordsplit, lengths))
> head(combos)
  Var1 Var2 Var3
1   bl    r  pin
2   bu    r  pin
3   be    r  pin
4   lu    r  pin
5   le    r  pin
6   ue    r  pin

> do.call('paste0', combos)
 [1] "blrpin" "burpin" "berpin" "lurpin" "lerpin" "uerpin" "blepin" "buepin" "beepin" "luepin" "leepin" "ueepin" "bldpin" "budpin" "bedpin" "ludpin"
[17] "ledpin" "uedpin" "blrpik" "burpik" "berpik" "lurpik" "lerpik" "uerpik" "blepik" "buepik" "beepik" "luepik" "leepik" "ueepik" "bldpik" "budpik"
[33] "bedpik" "ludpik" "ledpik" "uedpik" "blrpnk" "burpnk" "berpnk" "lurpnk" "lerpnk" "uerpnk" "blepnk" "buepnk" "beepnk" "luepnk" "leepnk" "ueepnk"
[49] "bldpnk" "budpnk" "bedpnk" "ludpnk" "ledpnk" "uedpnk" "blrink" "burink" "berink" "lurink" "lerink" "uerink" "bleink" "bueink" "beeink" "lueink"
[65] "leeink" "ueeink" "bldink" "budink" "bedink" "ludink" "ledink" "uedink"
-------------------------------------------------------------------------------------------------------
dat <- expand.grid(var1=1:4, var2=1:4) # Find redunant pairs
dat <- data.frame(t(apply(dat, 1, function(x){
  if(x[1]-x[2] <= 0) {    # If > zero than pair has come before.
    -x                    # If = zero than pair is same 
  } else x
})))

# Remove redundant pairs
dat <- dat[dat$var1>0,]
-------------------------------------------------------------------------------------------------------
qplot x Length ggplot Length 1 Length 2 stat_summary x library(plyr)
data.means <- ddply(data, .(Group, Pos, Length), summarize, ReadT = mean(ReadT)) ggplot qplot x geom_line ggplot(data.means, aes(x= Length, y= ReadT, colour = Pos)) + 
 geom_point() +
 geom_line(aes(x=as.numeric(Length))) +
 facet_grid(~Group) stat_xxxx stat_smooth x ggplot(data, aes(x = Length, y= ReadT, colour = Pos)) + 
 stat_summary(fun.y = 'mean', geom = 'point')+
 stat_smooth(method = 'lm', aes(x=as.numeric(Length)), se = FALSE) +
 facet_grid(~Group)
-------------------------------------------------------------------------------------------------------
test <- read.table(text="STM_cold STM_normal STM_hot PIC_cold PIC_normal PIC_hot
6.0 6.6 6.3 0.9 1.9 3.2
6.0 6.6 6.5 1.0 2.0 3.2
5.9 6.7 6.5 0.3 1.8 3.2
6.1 6.8 6.6 0.2 1.8 3.8
5.5 6.7 6.2 0.5 1.9 3.3
5.6 6.5 6.5 0.2 1.9 3.5
5.4 6.8 6.5 0.2 1.8 3.7
5.3 6.5 6.2 0.2 2.0 3.5
5.3 6.7 6.5 0.1 1.7 3.6
5.7 6.7 6.5 0.3 1.7 3.6
NA  NA  NA  0.1 1.8 3.8
NA  NA  NA  0.2 2.1 4.1
NA  NA  NA  0.2 1.8 3.3
NA  NA  NA  0.8 1.7 3.5
NA  NA  NA  1.7 1.6 4.0
NA  NA  NA  0.1 1.7 3.7",header=TRUE) plot(
     NA,
     ylim=c(0,max(test,na.rm=TRUE)+0.3),
     xlim=c(1-0.1,ncol(test)+0.1),
     xaxt="n",
     ann=FALSE,
     panel.first=grid()
     )

axis(1,at=seq_along(test),labels=names(test),lwd=0,lwd.ticks=1) jitter invisible(
  mapply(
        points,
        jitter(rep(seq_along(test),each=nrow(test))),
        unlist(test),
        col=rep(seq_along(test),each=nrow(test)),
        pch=19
        )
) jitter invisible(
  mapply(
        points,
        rep(seq_along(test),each=nrow(test)),
        unlist(test),
        col=rgb(0,0,0,0.1),
        pch=15,
        cex=3
        )
)
-------------------------------------------------------------------------------------------------------
ggplot(transform(iris,
      Species=factor(Species,levels=c("virginica","setosa","versicolor")))) + 
    geom_histogram(aes(Petal.Width))+ facet_grid(Species~.) ggplot factor(...,levels=...) ggplot order() arrange() neworder <- c("virginica","setosa","versicolor")
library("plyr")
iris2 <- arrange(transform(iris,
             Species=factor(Species,levels=neworder)),Species) ggplot2::facet_grid
-------------------------------------------------------------------------------------------------------
target==TRUE "(Intercept)"       -> target==TRUE, cond==0 (even if model matrix contains all conds)
"cond1"             -> target==TRUE, cond==1 on top of cond==0
"cond2"             -> target==TRUE, cond==2 on top of cond==0
"targetFALSE"       -> target==FALSE, cond==0 (even if model matrix contains all conds)
"cond1:targetFALSE" -> target==FALSE, cond==1 on top of cond==0
"cond2:targetFALSE" -> target==FALSE, cond==2 on top of cond==0 "(Intercept)" "cond1" "cond2" getME(stu3,'X') target==TRUE target==TRUE target==TRUE cond fit1 fit2 set.seed(0)
struct <- expand.grid(target = c(FALSE,TRUE), cond = as.factor(0:2), patient = LETTERS[1:20])
attach(struct)
ranpatient <- rep(rnorm(20), each=6)
rerror <- rnorm(120)
# Just random noise
response0 <- ranpatient + rerror
# When target==TRUE we increment the response by 1 and add errors
response1 <- 1*target + ranpatient + rerror
# When target==TRUE we increment the response by  1,
# to which we also add an interaction effect condition {0,1,2} * target {0,1}
# notice that numeric transformation of cond {0,1,2} transforms to ranks {1,2,3}
response2 <- 1*target + target*(as.numeric(cond)-1) + ranpatient + rerror

dat <- data.frame(cond, target, patient, response0, response1, response2)   
detach(struct)

require(lme4)
fit0 <- lmer(response0 ~ cond*target + (1|patient), data=dat)
fit1 <- lmer(response1 ~ cond*target + (1|patient), data=dat)
fit2 <- lmer(response2 ~ cond*target + (1|patient), data=dat)

head(dat)
round(coef(summary(fit0)),2) # Notice low t values
round(coef(summary(fit1)),2) # High t value for targetTRUE
round(coef(summary(fit2)),2) # High t value for interaction cond0/1/2 with targetTRUE
# Notice how cond==1 adds 1, and cond==2 adds 2 in comparison to cond==0 when targetTRUE
# Notice also that coefficient "cond2:targetTRUE" is incremental to term "targetTRUE", not "cond1:targetTRUE"
head(getME(fit2,'X')) # Columns correspond to the fixed effect terms > head(dat)
  cond target patient response0 response1 response2
1    0  FALSE       A  1.038686  1.038686  1.038686
2    0   TRUE       A  1.640350  2.640350  2.640350
3    1  FALSE       A  1.396291  1.396291  1.396291
4    1   TRUE       A  2.067144  3.067144  4.067144
5    2  FALSE       A  1.205848  1.205848  1.205848
6    2   TRUE       A  1.766562  2.766562  4.766562
> round(coef(summary(fit0)),2) # Notice low t values
                 Estimate Std. Error t value
(Intercept)         -0.13       0.31   -0.40
cond1                0.18       0.29    0.62
cond2                0.00       0.29    0.00
targetTRUE           0.00       0.29   -0.01
cond1:targetTRUE     0.13       0.41    0.32
cond2:targetTRUE     0.08       0.41    0.19
> round(coef(summary(fit1)),2) # High t value for targetTRUE
                 Estimate Std. Error t value
(Intercept)         -0.13       0.31   -0.40
cond1                0.18       0.29    0.62
cond2                0.00       0.29    0.00
targetTRUE           1.00       0.29    3.42
cond1:targetTRUE     0.13       0.41    0.32
cond2:targetTRUE     0.08       0.41    0.19
> round(coef(summary(fit2)),2) # High t value for interaction cond0/1/2 with targetTRUE
                 Estimate Std. Error t value
(Intercept)         -0.13       0.31   -0.40
cond1                0.18       0.29    0.62
cond2                0.00       0.29    0.00
targetTRUE           1.00       0.29    3.42
cond1:targetTRUE     1.13       0.41    2.75
cond2:targetTRUE     2.08       0.41    5.04
> # Notice how cond==1 adds 1, and cond==2 adds 2 in comparison to cond==0 when targetTRUE
> # Notice also that coefficient "cond2:targetTRUE" is incremental to term "targetTRUE", not "cond1:targetTRUE"
> head(getME(fit2,'X')) # Columns correspond to the fixed effect terms
     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    0    0    0    0    0
[2,]    1    0    0    1    0    0
[3,]    1    1    0    0    0    0
[4,]    1    1    0    1    1    0
[5,]    1    0    1    0    0    0
[6,]    1    0    1    1    0    1
-------------------------------------------------------------------------------------------------------
expand.grid merge > fullFrame <- expand.grid(allweeks, allprobes)
> names(fullFrame) <- c("week", "probe")
> merge(fullFrame, logs, all = TRUE)
   week probe obs
1     1     A   2
2     1     B  NA
3     1     C  NA
4     1     D  NA
5     2     A  NA
6     2     B   3
7     2     C   4
8     2     D  NA
9     3     A  NA
10    3     B  NA
11    3     C  NA
12    3     D  NA
13    4     A  NA
14    4     B  NA
15    4     C   1
16    4     D  NA expand.grid data.frame data.frame data.frame merge all = TRUE merge NA NA fullFrame <- expand.grid(allweeks, allprobes)
names(fullFrame) <- c("week", "probe")
finalLogs <- merge(fullFrame, logs, all = TRUE)
finalLogs[is.na(finalLogs)] <- 0 xtabs xtabs data.frame logs$week <- factor(logs$week, levels=c(1, 2, 3, 4))
logs$probe <- factor(logs$probe, levels=c("A", "B", "C", "D"))
data.frame(xtabs(obs ~ week + probe, logs))
#    week probe Freq
# 1     1     A    2
# 2     2     A    0
# 3     3     A    0
# 4     4     A    0
# 5     1     B    0
# 6     2     B    3
# 7     3     B    0
# 8     4     B    0
# 9     1     C    0
# 10    2     C    4
# 11    3     C    0
# 12    4     C    1
# 13    1     D    0
# 14    2     D    0
# 15    3     D    0
# 16    4     D    0
-------------------------------------------------------------------------------------------------------
z 0 names(z) NULL append(liste,test, after=k) liste[k] = test append expand.grid fn <- function(x, y) {
    rowSums(expand.grid(x, y))
}
-------------------------------------------------------------------------------------------------------
print \ print("\150") a <- sapply(97:122,function(x) rawToChar(as.raw(x)))

b <- expand.grid(a,a)

c <- t(apply(b,1,function(x) paste(x[1],x[2])))
-------------------------------------------------------------------------------------------------------
res <- do.call(paste, expand.grid(letters, letters)) val <- 65:96 # whatever values you want the equivalent characters for
mode(val) <- "raw" # set mode to raw
# alternatively, val <- as.raw(65:96)
a   <- sapply(val, rawToChar)
res <- do.call(paste, expand.grid(a, a))
-------------------------------------------------------------------------------------------------------
unable to evaluate at initial parameters sqrt dat <- dat[dat>0] dat <- dat[dat > 1] log(ptp1)-log(ptp) ppt1 c(1,ppt1) linear wireframe dat <- seq(1,100)
ptp <- head(dat,-1)
ptp1 <- c(tail(dat,-2),1)

g <- expand.grid( k = seq(0.1,2,length.out=100),     ## k between [0.1,2]
                  sigma = seq(0.1,1,length.out=100), ## sigma [0.1,1]
                  r= c(0.1,0.5,0.8,1))               ## some r points forgrouping

z <- rep(0,nrow(g))
for(i in seq_along(z))
  z[i] <- sum(dnorm(log(ptp1)-log(ptp)*exp(g[i,'r']-(ptp/g[i,'k'])),
                 mean=0,
                 sd=g[i,'sigma'],
                 log=T))
g$z <- z
any(is.infinite(g$z))     ## you can test if you have infinite value       
FALSE

wireframe(z ~ k * sigma, data = g, groups = r,
          scales = list(arrows = FALSE),
          drape = TRUE, colorkey = TRUE)
-------------------------------------------------------------------------------------------------------
plyr data.table data.table plyr #-------------------#
#   M E T H O D S   #
#-------------------#

  # additional methods below, in the updates

  # Method 1  -- suggested by @agstudy
  plyrMethod <- quote({
                  dfw<-dcast(df,
                         formula = Par1+Par2~Type,
                         value.var="Val",
                         fun.aggregate=mean)
                  dat <- ddply(df,.(Par1,Par2),function(x){
                    data.frame(ParD=paste(paste(x$ParD),collapse='_'),
                               Num.pre =length(x$Type[x$Type =='pre']),
                               Num.post = length(x$Type[x$Type =='post']))
                  })
                  merge(dfw,dat)
                })

  # Method 2 -- suggested by @Arun
  dtMethod <- quote(
                dt[, list(pre=mean(Val[Type == "pre"]), 
                          post=mean(Val[Type == "post"]), 
                          Num.pre=length(Val[Type == "pre"]), 
                          Num.post=length(Val[Type == "post"]), 
                          ParD = paste(ParD, collapse="_")), 
                by=list(Par1, Par2)]
              ) 

 # Method 3 -- suggested by @regetz
 reduceMethod <- quote(
                  Reduce(merge, list(
                      dcast(df, formula = Par1+Par2~Type, value.var="Val",
                          fun.aggregate=mean),
                      setNames(dcast(df, formula = Par1+Par2~Type, value.var="Val",
                          fun.aggregate=length), c("Par1", "Par2", "Num.post",
                          "Num.pre")),
                      aggregate(df["ParD"], df[c("Par1", "Par2")], paste, collapse="_")
                      ))
                  )

 # Method 4 -- suggested by @Ramnath
 castddplyMethod <- quote(
                      reshape::cast(Par1 + Par2 + ParD ~ Type, 
                           data = ddply(df, .(Par1, Par2), transform, 
                           ParD = paste(ParD, collapse = "_")), 
                           fun  = c(mean, length)
                          )
                      )



# SAMPLE DATA #
#-------------#

library(data.table)
library(plyr)
library(reshape2)
library(rbenchmark)


  # for Par1, ParD
  LLL <- apply(expand.grid(LETTERS, LETTERS, LETTERS, stringsAsFactors=FALSE), 1, paste0, collapse="")
  lll <- apply(expand.grid(letters, letters, letters, stringsAsFactors=FALSE), 1, paste0, collapse="")

  # max size is 17568 with current sample data setup, ie: floor(length(LLL) / 18) * 18
  size <- 17568
  size <- 10800
  size <- 900  

  set.seed(1)
  df<-data.frame(Par1=rep(LLL[1:(size/2)], times=rep(c(2,2,3), size)[1:(size/2)])[1:(size)]
                 , Par2=rep(lll[1:(size/2)], times=rep(c(2,2,3), size)[1:(size/2)])[1:(size)]
                 , ParD=sample(unlist(lapply(c("f", "b"), paste0, lll)), size, FALSE)
                 , Type=rep(c("pre","post"), size/2)
                 , Val =sample(seq(10,100,10), size, TRUE)
                 )

  dt <- data.table(df, key=c("Par1", "Par2"))


# Confirming Same Results # 
#-------------------------#
  # Evaluate
  DF1 <- eval(plyrMethod)
  DF2 <- eval(dtMethod)

  # Convert to DF and sort columns and sort ParD levels, for use in identical
  colOrder <- sort(names(DF1))
  DF1 <- DF1[, colOrder]
  DF2 <- as.data.frame(DF2)[, colOrder]
  DF2$ParD <- factor(DF2$ParD, levels=levels(DF1$ParD))
  identical((DF1), (DF2))
  # [1] TRUE
#-------------------------# #--------------------#
#     BENCHMARK      #
#--------------------#
benchmark(plyr=eval(plyrMethod), dt=eval(dtMethod), reduce=eval(reduceMethod), castddply=eval(castddplyMethod),
          replications=5, columns=c("relative", "test", "elapsed", "user.self", "sys.self", "replications"), 
          order="relative")


# SAMPLE SIZE = 900
  relative      test elapsed user.self sys.self replications
     1.000    reduce   0.392     0.375    0.018            5
     1.003        dt   0.393     0.377    0.016            5
     7.064      plyr   2.769     2.721    0.047            5
     8.003 castddply   3.137     3.030    0.106            5

# SAMPLE SIZE = 2,700
  relative   test elapsed user.self sys.self replications
     1.000     dt   1.371     1.327    0.090            5
     2.205 reduce   3.023     2.927    0.102            5
     7.291   plyr   9.996     9.644    0.377            5

# SAMPLE SIZE = 10,800
  relative      test elapsed user.self sys.self replications
     1.000        dt   8.678     7.168    1.507            5
     2.769    reduce  24.029    23.231    0.786            5
     6.946      plyr  60.277    52.298    7.947            5
    13.796 castddply 119.719   113.333   10.816            5

# SAMPLE SIZE = 17,568
  relative   test elapsed user.self sys.self replications
     1.000     dt  27.421    13.042   14.470            5
     4.030 reduce 110.498    75.853   34.922            5
     5.414   plyr 148.452   105.776   43.156            5 # Used only sample size of 90, as it was taking long
relative  test elapsed user.self sys.self replications
   1.000    dt   0.044     0.043    0.001            5
   7.773  plyr   0.342     0.339    0.003            5
  65.614 base1   2.887     2.866    0.028            5

Where
   baseMethod1 <- quote({
                  step1 <- with(df, split(df, list(Par1, Par2)))
                  step2 <- step1[sapply(step1, nrow) > 0]
                  step3 <- lapply(step2, function(x) {
                      piece1 <- tapply(x$Val, x$Type, mean)
                      piece2 <- tapply(x$Type, x$Type, length)
                      names(piece2) <- paste0("Num.", names(piece2))
                      out <- x[1, 1:2]
                      out[, 3:6] <- c(piece1, piece2)
                      names(out)[3:6] <-  names(c(piece1, piece2))
                      out$ParD <- paste(unique(x$ParD), collapse="_")
                      out
                  })
                  data.frame(do.call(rbind, step3), row.names=NULL)
                }) dtMethod.withkey <- quote({
                       dt <- data.table(df, key=c("Par1", "Par2"))       
                       dt[, list(pre=mean(Val[Type == "pre"]), 
                                 post=mean(Val[Type == "post"]), 
                                 Num.pre=length(Val[Type == "pre"]), 
                                 Num.post=length(Val[Type == "post"]), 
                                 ParD = paste(ParD, collapse="_")), 
                       by=list(Par1, Par2)]
                     }) 

# SAMPLE SIZE = 10,800
  relative       test elapsed user.self sys.self replications
     1.000         dt   9.155     7.055    2.137            5
     1.043 dt.withkey   9.553     7.245    2.353            5
     3.567     reduce  32.659    31.196    1.586            5
     6.703       plyr  61.364    54.080    7.600            5 dtMethod.MD1 <- quote(
                  dt[, list(pre=mean(Val[.pre <- Type=="pre"]),     # save .pre
                            post=mean(Val[.post <- Type=="post"]),  # save .post
                            pre.num=sum(.pre),                      # reuse .pre
                            post.num=sum(.post),                    # reuse .post
                            ParD = paste(ParD, collapse="_")), 
                     by=list(Par1, Par2)]
                  )

dtMethod.MD2 <- quote(
                  dt[, { .pre <- Type=="pre"                  # or save .pre and .post up front 
                         .post <- Type=="post"
                         list(pre=mean(Val[.pre]), 
                              post=mean(Val[.post]),
                              pre.num=sum(.pre),
                              post.num=sum(.post), 
                              ParD = paste(ParD, collapse="_")) }
                  , by=list(Par1, Par2)]
                  )

dtMethod.MD3 <- quote(
                dt[, { .pre <- Type=="pre"
                       .post <- Type=="post"
                       list(pre=mean(Val[.pre]), 
                            post=mean(Val[.post]),
                            pre.num=sum(.pre),
                            post.num=sum(.post), 
                            ParD = list(ParD)) }     # list() faster than paste()
                , by=list(Par1, Par2)]
                )

benchmark(dt.M1=eval(dtMethod.MD1), dt.M2=eval(dtMethod.MD2), dt.M3=eval(dtMethod.MD3), dt=eval(dtMethod),
      replications=5, columns=c("relative", "test", "elapsed", "user.self", "sys.self", "replications"), 
      order="relative")

#--------------------#

Comparing the different data.table methods amongst themselves


# SAMPLE SIZE = 900
  relative  test elapsed user.self sys.self replications
     1.000 dt.M3   0.198     0.197    0.001            5  <~~~ "list()" Method
     1.242 dt.M1   0.246     0.243    0.004            5
     1.253 dt.M2   0.248     0.242    0.007            5
     1.884    dt   0.373     0.367    0.007            5

# SAMPLE SIZE = 17,568
  relative  test elapsed user.self sys.self replications
     1.000 dt.M3  33.492    24.487    9.122            5   <~~~ "list()" Method
     1.086 dt.M1  36.388    11.442   25.086            5
     1.086 dt.M2  36.388    10.845   25.660            5
     1.126    dt  37.701    13.256   24.535            5

Comparing MD3 ("list" method) with MD1 (best of DT non-list methods)
Using a clean session  (ie, removing string cache)
_Note: Ran the following twice, fresh session each time, with practically identical results
       Then re-ran in the *same* session, with reps=5. Results very different._


benchmark(dt.M1=eval(dtMethod.MD1), dt.M3=eval(dtMethod.MD3), replications=1, columns=c("relative", "test", "elapsed", "user.self", "sys.self", "replications"), order="relative")
# SAMPLE SIZE=17,568;  CLEAN SESSION
  relative  test elapsed user.self sys.self replications
     1.000 dt.M1   8.885     4.260    4.617            1
     1.633 dt.M3  14.506    12.821    1.677            1

# SAMPLE SIZE=17,568;  *SAME* SESSION
  relative  test elapsed user.self sys.self replications
     1.000 dt.M1  33.443    10.200   23.226            5
     1.048 dt.M3  35.060    26.127    8.915            5

#--------------------#

New benchmarks against previous methods
_Note: Not using the "list method" as results are not the same as other methods_

# SAMPLE SIZE = 900
  relative   test elapsed user.self sys.self replications
     1.000  dt.M1   0.254     0.247    0.008            5
     1.705 reduce   0.433     0.425    0.010            5
    11.280   plyr   2.865     2.842    0.031            5

# SAMPLE SIZE = 17,568
  relative   test elapsed user.self sys.self replications
     1.000  dt.M1  24.826    10.427   14.458            5
     4.348 reduce 107.935    70.107   38.314            5
     5.942   plyr 147.508   106.958   41.083            5
-------------------------------------------------------------------------------------------------------
Stack data.table stack dtt <- data.table(data)

# non value columns, ie, the columns to keep post reshape
nvc <- c("Name","Code", "CURRENCY")

# name of columns being transformed 
dateCols <- setdiff(names(data), nvc)

# use rbind list to combine subsets
dtt2 <- rbindlist(lapply(dateCols, function(d) {
    dtt[, Date := d]
    cols <- c(nvc, "Date", d)
    setnames(dtt[, cols, with=FALSE], cols, c(nvc, "Date", "value"))
}))

## Results: 

dtt2
#       Name Code CURRENCY         Date value
# 1: Abengoa 4256      USD X_01_01_1980  1.53
# 2:  Adidas 6783      USD X_01_01_1980  0.23
# 3: Abengoa 4256      USD X_02_01_1980  1.54
# 4:  Adidas 6783      USD X_02_01_1980  0.54
# 5: ... <cropped> Resh <- quote(reshape::melt(data,id=c("Name","Code", "CURRENCY"),variable_name="Date"))
 Resh2 <- quote(reshape2::melt(data,id=c("Name","Code", "CURRENCY"),variable_name="Date"))
 DT <- quote({    nvc <- c("Name","Code", "CURRENCY"); dateCols <- setdiff(names(data), nvc); rbindlist(lapply(dateCols, function(d) { dtt[, Date := d]; cols <- c(nvc, "Date", d); setnames(dtt[, cols, with=FALSE], cols, c(nvc, "Date", "value"))}))})
 Stack <- quote(data.frame(data[1:3], stack(data[-c(1, 2, 3)])))


 # SAMPLE SIZE: ROWS = 900; COLS = 380 + 3; 
 dtt <- data.table(data);  
 benchmark(Resh=eval(Resh),Resh2=eval(Resh2),DT=eval(DT), Stack=eval(Stack), replications=5, columns=c("relative", "test", "elapsed", "user.self", "sys.self", "replications"), order="relative")
 # relative  test elapsed user.self sys.self replications
 #    1.000 Stack   0.813     0.623    0.192            5
 #    2.530    DT   2.057     2.035    0.026            5
 #   40.470  Resh  32.902    18.410   14.602            5
 #   40.578 Resh2  32.990    18.419   14.728            5

 # SAMPLE SIZE: ROWS = 3,500; COLS = 380 + 3; 
 dtt <- data.table(data);  
 benchmark(DT=eval(DT), Stack=eval(Stack), replications=5, columns=c("relative", "test", "elapsed", "user.self", "sys.self", "replications"), order="relative")
 #  relative  test elapsed user.self sys.self replications
 #      1.00    DT   2.407     2.336    0.076            5
 #      1.08 Stack   2.600     1.626    0.983            5

 # SAMPLE SIZE: ROWS = 27,000; COLS = 380 + 3; 
 dtt <- data.table(data);  
 benchmark(DT=eval(DT), Stack=eval(Stack), replications=5, columns=c("relative", "test", "elapsed", "user.self", "sys.self", "replications"), order="relative")
 # relative  test elapsed user.self sys.self replications
 #    1.000    DT  10.450     7.418    3.058            5
 #    2.232 Stack  23.329    14.180    9.266            5 # rm(list=ls(all=TRUE))
  set.seed(1)
  LLLL <- apply(expand.grid(LETTERS, LETTERS[10:15], LETTERS[1:20], LETTERS[1:5], stringsAsFactors=FALSE), 1, paste0, collapse="")

  size <- 900
  dateSamples <- 380
  startDate <- as.Date("1980-01-01")

  Name <- apply(matrix(LLLL[1:(2*size)], ncol=2), 1, paste0, collapse="")
  Code <- sample(1e3:max(1e4-1, size+1e3), length(Name))
  CURRENCY <- sample(c("USD", "EUR", "YEN"), length(Name), TRUE)

  Dates <- seq(startDate, length.out=dateSamples, by="mon")
  Values <- sample(c(1:1e2, 1:5e2), size=size*dateSamples, TRUE) / 1e2

  # Calling the sample dataframe `data` to keep consistency, but I dont like this practice
  data <- data.frame(Name, Code, CURRENCY,       
                     matrix(Values, ncol=length(Dates), dimnames=list(c(), as.character(Dates)))
                    ) 

  data[1:6, 1:8]
  #        Name Code CURRENCY X1980.01.01 X1980.02.01 X1980.03.01 X1980.04.01 X1980.05.01
  # 1  AJAAQNFA 3389      YEN        0.37        0.33        3.58        4.33        1.06
  # 2  BJAARNFA 4348      YEN        1.14        2.69        2.57        0.27        3.02
  # 3  CJAASNFA 6154      USD        2.47        3.72        3.32        0.36        4.85
  # 4  DJAATNFA 9171      USD        2.22        2.48        0.71        0.79        2.85
  # 5  EJAAUNFA 2814      USD        2.63        2.17        1.66        0.55        3.12
  # 6  FJAAVNFA 9081      USD        1.92        1.47        3.51        3.23        3.68
-------------------------------------------------------------------------------------------------------
ptinpoly pip3d library(ptinpoly)
X <- seq(-1/sqrt(2),1/sqrt(2),length.out=10)  #I used a smaller dataset here
Y <- seq(-sqrt(2)/(2*sqrt(3)),sqrt(2)/sqrt(3),length.out=10)
Z <- seq(-1/(2*sqrt(3)),sqrt(3)/2,length.out=10)
# The query points has to be inputted as a matrix.
grid <- as.matrix(expand.grid(X=X,Y=Y,Z=Z))

w <- c(0,0,sqrt(3)/2)
x <- c(0,sqrt(2)/sqrt(3),-1/(2*sqrt(3)))
y <- c(-1/sqrt(2),-sqrt(2)/(2*sqrt(3)),-1/(2*sqrt(3)))
z <- c(1/sqrt(2),-sqrt(2)/(2*sqrt(3)),-1/(2*sqrt(3)))
# The matrix of vertices
tetra_vert <- matrix(c(w,x,y,z),byrow=TRUE,nrow=4)
# The matrix of faces (each row correspond to a vector of vertices linked by a face.
tetra_faces <- matrix(c(1,2,3,
                        1,2,4,
                        1,3,4,
                        2,3,4),byrow=TRUE,nrow=4)
inout <- pip3d(tetra_vert, tetra_faces, grid) 0 1 -1 grid[inout%in%c(0,1),]
-------------------------------------------------------------------------------------------------------
levelplot.points latticeExtra mm <- rbind(
  c(NA,0,1,1),
  c(0,NA,4,2),
  c(1,4,NA,3),
  c(1,2,3,NA))
dat <- expand.grid(x=1:ncol(mm),y=1:nrow(mm))
dat$z <- as.vector(mm)

library(latticeExtra)
levelplot(z~x*y,data=dat,
       panel=function(...)
       {
         panel.levelplot.points(...,cex=10,pch=22)
         panel.grid()
       },par.settings=ggplot2like())
-------------------------------------------------------------------------------------------------------
grid.raster xyplot grid.raster readPNG png ll <- list.files(path='c:/temp',patt='compo[0-9].*',full.names=T)
library(png)
imgs <- lapply(ll,function(x){
       as.raster(readPNG(x))  ## no need to convert to a matrix here!
   }) x = 1:4   ## here 4 because I use  16 plots
y = 1:4
dat <- expand.grid(x,y) xyplot library(lattice)
library(grid)
xyplot(Var2~Var1|rownames(dat),data=dat,layout=c(4,4),
      panel=function(x,y,...){
        lims <- current.panel.limits()
        grid.raster(image =imgs[[panel.number()]],sum(lims$xlim)/2,sum(lims$ylim)/2,
                                      width =diff(lims$xlim),
                                          height=diff(lims$ylim),def='native' )

       })
-------------------------------------------------------------------------------------------------------
data <- expand.grid(1:3, 1:3, 1:3, 1:3, 1:3, 1:3, 1:3)
len <- apply(data,1,function(x) c(rle(x)$lengths[1:7], nchar(paste(unique(sort(rle(x)$value)), collapse=''))))
data <- data[!(duplicated(t(len))), ] data <- expand.grid(1:3, 1:3, 1:3, 1:3, 1:3, 1:3, 1:3)
len <- apply(data,1,function(x) c(rle(x)$lengths[1:7], length(unique(x))))
data <- data[!(duplicated(t(len))), ]
-------------------------------------------------------------------------------------------------------
mat <- expand.grid(1:3, 1:3, 1:3, 1:3, 1:3, 1:3, 1:3)

mat <- t(apply(mat, 1, 
               function(x){
                 un <- unique(x)
                 map <- setNames(1:length(un), un)
                 map[as.character(x)]
               }))

mat <- mat[!duplicated(mat), ]
nrow(mat)
# [1] 365 c(3,3,1,2,1,2,3) c(1,1,2,3,2,3,1) 3 1 2 duplicated setNames setNames(1:3,3:1)
3 2 1 
1 2 3 
setNames(1:3,3:1)[c("2","1")]
2 1 
2 3
-------------------------------------------------------------------------------------------------------
Dates_List <- c("2007-01-02", "2007-01-03")
ISIN_Table <- data.frame(c(1, 2, 3))
colnames(ISIN_Table) <- "ID"
ID <- rep(1:2, len = 2, each = 1)
Date <- c("2007-01-02", "2007-01-02", "2007-01-03", "2007-01-03")
Bid.Price <- rep(100, 4)
Ask.Price <- rep(100, 4)
data.raw <- data.frame(ID, Date, Bid.Price, Ask.Price)

temp <- expand.grid(Dates_List, ISIN_Table$ID)
names(temp) <- c("Date", "ID")

data.raw <- merge(temp, data.raw, all.x = TRUE)
data.raw[is.na(data.raw)] <- 0
data.raw
##         Date ID Bid.Price Ask.Price
## 1 2007-01-02  1       100       100
## 2 2007-01-02  2       100       100
## 3 2007-01-02  3         0         0
## 4 2007-01-03  1       100       100
## 5 2007-01-03  2       100       100
## 6 2007-01-03  3         0         0


splitdata <- split(data.raw, data.raw$Date)

splitdata
## $`2007-01-02`
##         Date ID Bid.Price Ask.Price
## 1 2007-01-02  1       100       100
## 2 2007-01-02  2       100       100
## 3 2007-01-02  3         0         0
## 
## $`2007-01-03`
##         Date ID Bid.Price Ask.Price
## 4 2007-01-03  1       100       100
## 5 2007-01-03  2       100       100
## 6 2007-01-03  3         0         0 split mapply merge Dates_List <- c("2007-01-02", "2007-01-03")
ISIN_Table <- data.frame(c(1, 2, 3))
colnames(ISIN_Table) <- "ID"
ID <- rep(1:2, len = 2, each = 1)
Date <- c("2007-01-02", "2007-01-02", "2007-01-03", "2007-01-03")
Bid.Price <- rep(100, 4)
Ask.Price <- rep(100, 4)
data.raw <- data.frame(ID, Date, Bid.Price, Ask.Price)

splitdata <- split(data.raw, data.raw$Date)

mapply(FUN = function(x, date) merge(x, 
                          data.frame(ID = ISIN_Table$ID, 
                                     Date = rep(date, length(ISIN_Table$ID))), 
                                 all.y = TRUE), 
       splitdata, t(names(splitdata)), SIMPLIFY = FALSE)

## $`2007-01-02`
##   ID       Date Bid.Price Ask.Price
## 1  1 2007-01-02       100       100
## 2  2 2007-01-02       100       100
## 3  3 2007-01-02        NA        NA
## 
## $`2007-01-03`
##   ID       Date Bid.Price Ask.Price
## 1  1 2007-01-03       100       100
## 2  2 2007-01-03       100       100
## 3  3 2007-01-03        NA        NA
-------------------------------------------------------------------------------------------------------
fasterWay <- function(df.data) {
  a1 <- aggregate(df.data[,3:4], list(x=floor(df.data$x/3), y=floor(df.data$y/3)), sum)
  a2 <- aggregate(list(count=rep(NA,nrow(df.data))), list(x=floor(df.data$x/3), y=floor(df.data$y/3)), length)
  result <- merge(expand.grid(y=0:3,x=0:3), merge(a1,a2), by=c("x","y"), all=TRUE)
  result[is.na(result)] <- 0
  result <- result[order(result$y, result$x),]
  rownames(result) <- NULL
  result
} x y vx vy count
1  0 0  0  0     1
2  0 1  0  0     0
3  0 2 -1 -1     1
4  0 3  0  0     0
5  1 0 -1 -1     1
6  1 1  0  0     0
7  1 2  0  0     0
8  1 3 -1  0     2
9  2 0 -1 -1     1
10 2 1  0  0     0
11 2 2 -1  1     2
12 2 3  0  0     1
13 3 0  0  0     0
14 3 1  0  0     0
15 3 2 -1  0     1
16 3 3  0  0     0
-------------------------------------------------------------------------------------------------------
expand.grid rowSums n = counts[, counts > 0]
answer = matrix(rowSums(expand.grid(n, n)), nrow=length(n), dimnames=list(names(n), names(n)))
diag(answer) = n n V2 V4 V5 
 2  5  6 expand.grid(n, n) Var1 Var2
1    2    2
2    5    2
3    6    2
4    2    5
5    5    5
6    6    5
7    2    6
8    5    6
9    6    6 diag 2+2 5+5 6+6
-------------------------------------------------------------------------------------------------------
#find optimum:
fit<-optim(par=c(r=1,k=1,sigma=1),fn=loglike,dat=dat,scale='log',
           method='Nelder-Mead',control=list(fnscale=-1))

fit$par
        r           k       sigma 
0.3911590 254.4989317   0.5159761 

# make grid around optimum with few selected sigma values:

rs<-seq(0.01,1,length=30)
ks<-seq(230,280,length=30)
sigmas<-c(0.25,0.5159761,0.75)

# this will contains all parameter combinations 
# and the corresponding likelihood values

mlegrid<-cbind(as.matrix(expand.grid(rs,ks,sigmas)),0)  #Matrix
colnames(mlegrid)<-c('r','k','sigma','likelihood')

for(i in 1:nrow(mlegrid)){ #go through all combinations
  mlegrid[i,4]<- loglike(par=mlegrid[i,1:3],dat=dat,scale='log') 
}
mlegrid[which.max(mlegrid[,4]),] 
      r           k       sigma  likelihood 
0.3855172 257.5862069   0.5159761 -74.9940496 
# almost the same as from optim 
# (differences due to sparse grid, more dense gives more accurate results)

#for interactive plots, static versions with `persp` function
library(rgl)
persp3d(x=rs,y=ks,
        z=matrix(mlegrid[mlegrid[,3]==sigmas[1],4],nrow=length(rs)),col=2)
#with sigma from optim
persp3d(x=rs,y=ks,
        z=matrix(mlegrid[mlegrid[,3]==sigmas[2],4],nrow=length(rs)),col=2) 
persp3d(x=rs,y=ks,
        z=matrix(mlegrid[mlegrid[,3]==sigmas[3],4],nrow=length(rs)),col=2)
-------------------------------------------------------------------------------------------------------
ddply list.runs df.summary <- ldply(list.runs,function(x,...) do.call(data.frame,x))

library(ggplot2)
ggplot(df.summary, aes(factor(lengths),values)) + 
  geom_bar(stat = "identity", aes(fill=factor(ID))) + 
  facet_grid( ~ ID, ncol=2)
-------------------------------------------------------------------------------------------------------
ymin lower middle upper ymax stat = "identity" library(reshape2)
library(plyr)
library(ggplot2)

dataf <- ddply(iris, .(Species), summarize, quantilesy= quantile(Petal.Width, c(0,0.2, 0.5,0.85,1 )))
dataf$Labels <- rep(c("0%", "20%","50%","85%", "100%"),length(unique(dataf$Species)))

dataf2 <- reshape(dataf , idvar = c("Species"),timevar = "Labels", direction = "wide")
datafmeanx <- ddply(iris, .(Species), summarize, meanx= mean(Petal.Length))
dataf3 <- merge(dataf2,datafmeanx)

b <- ggplot(dataf3 , aes(x=meanx,ymin = `quantilesy.0%`, lower = `quantilesy.20%`, middle = `quantilesy.50%`, upper = `quantilesy.85%`, ymax = `quantilesy.100%`))
b + geom_boxplot(stat = "identity")+ facet_grid(Species~.) + xlab("Mean PetalLength") + ylab("PetalWidth") dataf$Labels <- rep(c("0", "20","50","85", "100"),length(unique(dataf$Species)))

dataf2 <- reshape(dataf , idvar = c("Species"),timevar = "Labels", direction = "wide")
datafmeanx <- ddply(iris, .(Species), summarize, meanx= mean(Petal.Length))
dataf3 <- merge(dataf2,datafmeanx)

b <- ggplot(dataf3 , aes(x=meanx ,ymin = quantilesy.0, lower = quantilesy.20, middle = quantilesy.50, upper = quantilesy.85, ymax = quantilesy.100))
b + geom_boxplot(stat = "identity")+ facet_grid(Species~.) + xlab("Mean PetalLength") + ylab("PetalWidth")
-------------------------------------------------------------------------------------------------------
variofit library(geoR)
vario100 <- variog(s100, max.dist=1)
ini.vals <- expand.grid(seq(0,1,l=5), seq(0,1,l=5))
ols <- variofit(vario100, ini=ini.vals, fix.nug=TRUE, wei="equal")
## variofit: model parameters estimated by OLS (ordinary least squares):
## covariance model is: matern with fixed kappa = 0.5 (exponential)
## fixed value for tausq =  0 
## parameter estimates:
## sigmasq     phi 
##  1.1070  0.4006 
## Practical Range with cor=0.05 for asymptotic range: 1.200177
## 
## variofit: minimised sum of squares = 0.1025 loglik.GRF # you can pass an existing model
loglik.GRF(s100, obj.model = ols)
## [1] -87.32958 loglik.GRF(s100, cov.pars = c(1.5,0.6), nugget = 0.01) fit.variogram gstat gstat geoR gstat gstat library(gstat)
 # convert geodata to  data.frame object
 s100df <- as.data.frame(s100)
 # remove geodata.frame class that causes problems
 class(s100df) <- 'data.frame'

 # create gstat version of variogram
 s100v <- variogram(data~1, ~X1+X2, s100df)

 # convert a variomodel to vgm object

 foo <- as.vgm.variomodel(list(cov.model = 'exponential', kappa = 0.5,
                          cov.pars = c(1.5,0.6), nugget = 0.2))

 # get the weighted least squares value
 # calling fit.variogram without fitting any thing
 fittedfoo <- fit.variogram(s100v, foo, fit.sills = FALSE, fit.ranges = FALSE)
 # the weighted sum of squares is
 attr(fittedfoo, 'SSErr')
 ## [1] 0.6911813
-------------------------------------------------------------------------------------------------------
list colorkey = list(space = 'left') ?levelplot x <- seq(pi/4, 5 * pi, length.out = 100)
y <- seq(pi/4, 5 * pi, length.out = 100)
r <- as.vector(sqrt(outer(x^2, y^2, "+")))
grid <- expand.grid(x=x, y=y)
grid$z <- cos(r^2) * exp(-r/(pi^3))
levelplot(z~x*y, grid, cuts = 50, scales=list(log="e"), xlab="",
          ylab="", main="Weird Function", sub="with log scales",
          colorkey = list(space = 'left')
-------------------------------------------------------------------------------------------------------
library(reshape2)
library(ggplot2)
x8.New <-c(70, 20, 7, 2, 2, 54, 33, 8, 0, 4, 37, 29, 23, 11, 
                   0, 46, 29, 18, 4, 2, 16, 29, 26, 20, 10, 37, 20, 9, 13, 22, 66, 
                   18, 14, 2, 0, 65, 20, 12, 3, 0, 47, 29, 18, 4, 3, 48, 32, 16, 
                   3, 1, 24, 25, 19, 22, 10, 41, 14, 18, 9, 18, 66, 25, 6, 3, 0, 
                   62, 23, 14, 1, 0, 47, 30, 14, 8, 1, 46, 31, 16, 6, 1, 19, 27, 
                   25, 22, 7, 34, 15, 17, 13, 21, 68, 22, 7, 2, 1, 62, 21, 16, 1, 
                   0, 45, 30, 18, 5, 1, 43, 28, 22, 5, 2, 20, 23, 25, 23, 10, 36, 
                   20, 12, 14, 19, 60, 25, 13, 2, 0, 62, 23, 10, 6, 0, 41, 24, 26, 
                   9, 0, 47, 31, 16, 5, 1, 13, 29, 22, 24, 13, 28, 16, 20, 18, 18)

length(x8.New)

# names and structures your values
Exit.Survey <- array(x8.New, c(5, 6, 5), dimnames = list(
  Rating = c("Highly Satisfied", "Moderately Satisfied", "Satisfied", "Moderately Dis-Satisfied", "Extremely Dis-Satistfied"), 
  Churn.Reason = c("work change", "diff phone", "Best Mates/ Favourites", "better offer", "poor coverage", "Other"), 
  YearQuarter = c("2011-09-01", "2011-12-01", "2012-03-01", "2012-06-01", "2012-09-01") 
  ))

#please note - 3d array- just like a cube of data - 3 matrices (including 0's!)
dim(Exit.Survey)
Exit.Survey[,,1]

#melts the 3d array into a 2d structure by adding a YearQuarter variable
df1<- melt(Exit.Survey, id=names(Exit.Survey), measured="YearQuarter")
df1$Rating<- factor(c("Highly Satisfied", "Moderately Satisfied", "Satisfied", "Moderately Dis-Satisfied", "Extremely Dis-Satistfied"))
ggplot(data=df1, aes(x=factor(Rating), y=value, fill=Churn.Reason)) +
  geom_bar(colour="black", stat="identity") +
  facet_grid(. ~ YearQuarter) + ylab(c("# of Churned Customers")) + 
  xlab(c("Satisfaction Level")) + scale_fill_brewer(palette="Set1") + 
  theme(axis.text.x  = element_text(angle=90, vjust=0.5)) + 
  scale_x_discrete(limits= c("Highly Satisfied", "Moderately Satisfied", "Satisfied", 
                     "Moderately Dis-Satisfied", "Extremely Dis-Satistfied"))
-------------------------------------------------------------------------------------------------------
library(ggplot2)
xval <- rep(0:20,10)
lambda <- rep(1:10,21)
yvtal <- exp(- lambda)*lambda**xval/gamma(xval+1)
the_new_data_frame <- data.frame(cbind(xval,lambda,yval))

plot1 <- ggplot(the_new_data_frame, aes(xval, yval)) + geom_line(aes(colour=factor(lambda)))
plot1
plot1 + facet_grid(~lambda)
-------------------------------------------------------------------------------------------------------
polyroot(c(1,alpha1,alpha2)) alpha ## I choose alpha1 in interavl [-1,1]
alpha1 <- seq(-1, 1, length=200)
## I choose alpha2 in interavl [-2,2]
alpha2 <- seq(-2, 2, length=200)
dat <- expand.grid(data.frame(alpha1,alpha2))
## for each combination of (alpha1,alpha2)
## i compute the module of the roots 
## I replace |roots|> 1 by NA
ll <- apply(dat,1,function(x) {
  rr =Mod(polyroot(c(1,x['alpha1'],x['alpha2'])))
  res <- ifelse(rr>1,NA,rr)
  if (length(res)==1) res <- rep(res,2)
  if (length(res)==0) res <- rep(NA,2)
  else res
  })
dat <- na.omit(cbind(dat,t(ll)))
## finally i plot the result
library(lattice)
xyplot(alpha2~alpha1,data=dat)
-------------------------------------------------------------------------------------------------------
library(data.table)
myDT <- data.table(DataFrame)

myDT[ , "TVI" :=  100 * (1 - 10^-(Data - Data[Do==0])) / (1 - 10^-(Data[Do==100] - Data[Do==0])) 
      , by=list(Cl, In, Sa)]

# this is your Tonval Value Increase
myDT$TVI ids expand.grid myIDs <- expand.grid(unique(Do), unique(Cl), unique(In), unique(Sa))

# You can then use something like 
apply(myIDs, 1, paste, sep=".")
# to get the same results.  Or whatever other function suits dG data.table ids by data.table library(data.table)
myDT <- data.table(DataFrame)

myDT

dG_DT <- 
    100 * 
    1 - 10^(   myDT[ ,     Data, by=list(Do, Cl, In, Sa)][, Data] 
             - myDT[Do==0, Data, by=list(Do, Cl, In, Sa)][, Data]
            ) / 

    1 - 10^(   myDT[Do==100, Data, by=list(Do, Cl, In, Sa)][, Data]
             - myDT[Do==0,   Data, by=list(Do, Cl, In, Sa)][, Data]
            ) - 
    myDT[, Do]

dG_DT
-------------------------------------------------------------------------------------------------------
df<-data.frame(nam=rep(c("A","B","C","D","E"),times=3),
  val=runif(15,0,1),type=rep(c("TypA","TypB","TypC"),each=5))
df<-rbind(df,df,df)
df$num.lev<-rep(c(10,20,30),each=15) panel.grid.major panel.grid.minor theme() panel.margin= library(ggplot2)
library(grid)
ggplot(df,aes(val,nam))+geom_point(size=3,colour="blue")+facet_grid(num.lev~type)+
  scale_x_continuous(breaks=c(0,0.2,0.4,0.6,0.8))+
  theme(panel.margin=unit(0,"cm"),
        panel.border=element_rect(colour="black",fill=NA,size=1.2),
        strip.background=element_rect(colour="black",size=1.2),
        panel.grid.major.x=element_blank(),
        panel.grid.minor.x=element_blank(),
        panel.grid.major.y=element_line(size=1.5,colour="grey88"),
        panel.background=element_rect(fill="white"))
-------------------------------------------------------------------------------------------------------
colvec2 colvec2 <-c("white", "gray80", "gray60", "gray37",  "black")  
colvec <-c("white", "white","gray80", "gray80", "gray60", "gray60", "gray37", "gray37","black", "black") p<-ggplot(water, aes(Date, Temp, group=Wetland, shape=Hydrology)) +
  geom_point(aes(color=Wetland),size=3) +
  scale_colour_manual(values=colvec) +
  facet_grid(Layer ~ Hydrology) +
  theme(legend.position="none") Pulsed shape=16 geom_point() scale_colour_manual() p1<-ggplot(subset(water,Hydrology=="Pulsed"), 
     aes(Date, Temp, group=Wetland, shape=Hydrology)) +
  geom_point(aes(color=Wetland),size=3,shape=16) +
  scale_colour_manual("Pulsed Wetlands",values=colvec2) +
  facet_grid(Layer ~ Hydrology) p1 Static p2<-ggplot(subset(water,Hydrology=="Static"), 
      aes(Date, Temp, group=Wetland, shape=Hydrology)) +
  geom_point(aes(color=Wetland),size=3,shape=17) +
  scale_colour_manual("Static Wetlands",values=colvec2) +
  facet_grid(Layer ~ Hydrology) p1 p2 ggplot_build() ggplot_gtable() pt1<-ggplot_gtable(ggplot_build(p1))
pt2<-ggplot_gtable(ggplot_build(p2)) guide-box leg1<-pt1$grobs[[12]]
leg2<-pt2$grobs[[12]] grid.arrange() arrangeGrob() library(gridExtra)
grid.arrange(arrangeGrob(p,arrangeGrob(leg1,leg2), ncol = 2,widths=c(3/4,1/4)))
-------------------------------------------------------------------------------------------------------
lattice lattice compact library(lattice)
dat <- transform(dat,k2=c(0,cumsum(diff(kanzler)!=0)))
s <- split(dat,dat$k2)
xyplot(ger.90.10.ratio~year,data=dat,type=c('p'),groups=kanzler,
       main = 'THE PARTISAL POLITICAL ECONOMY',
       auto.key=list(columns=2,cex=2,text=c('Democrats','Republicans')),
       panel=function(x,y,...) {
         panel.xyplot(x,y,...)
         lapply(s,function(x) 
          with(x,panel.lines(year,ger.90.10.ratio,col=kanzler)))
         panel.grid()
       })
-------------------------------------------------------------------------------------------------------
p <- ggplot(all, aes(val1, val2))+ geom_smooth(method = "lm")  + geom_point() +
  facet_grid(~type) 
# Calculate correlation for each group
cors <- ddply(all, .(type), summarise, cor = round(cor(val1, val2), 2))
p + geom_text(data=cors, aes(label=paste("r=", cor, sep="")), x=1, y=-0.25) # I consider the type in your previous data to be xx and yy
dat <- data.frame(val1 = c(rep(all$val1[all$type == "x"], 2), 
                           rep(all$val1[all$type == "y"], 2)), 
                  val2 = rep(all$val2, 2), 
                  grp1 = rep(c("x", "x", "y", "y"), each=10), 
                  grp2 = rep(c("x", "y", "x", "y"), each=10))

p <- ggplot(dat, aes(val1, val2)) + geom_point() + geom_smooth(method = "lm") + 
     facet_grid(grp1 ~ grp2)
cors <- ddply(dat, .(grp1, grp2), summarise, cor = round(cor(val1, val2), 2))
p + geom_text(data=cors, aes(label=paste("r=", cor, sep="")), x=1, y=-0.25)
-------------------------------------------------------------------------------------------------------
library(reshape2)
allM <- melt(all[-1], id.vars = "type") type val1 val2 allList <- split(allM$value, interaction(allM$type, allM$variable)) allComb <- unlist(lapply(c(1, 3), 
                  function(x)
                    lapply(c(2 ,4), 
                           function(y) 
                             do.call(cbind, allList[c(x, y)]))), 
           recursive = FALSE) allNew <- do.call(rbind, 
                  lapply(allComb, function(x) {
                                    tmp <- as.data.frame(x)
                                    tmp <- (within(tmp, {xval <- names(tmp)[1]; 
                                                         yval <- names(tmp)[2]}))
                                    names(tmp)[1:2] <- c("x", "y")
                                    tmp})) library(ggplot2)
p <- ggplot(allNew, aes(x = x, y = y)) + 
       geom_smooth(method = "lm")  + 
       geom_point() +
       facet_grid(yval ~ xval) 
# Calculate correlation for each group
library(plyr)
cors <- ddply(allNew, .(yval, xval), summarise, cor = round(cor(x, y), 2))
p + geom_text(data=cors, aes(label=paste("r=", cor, sep="")), x=0.5, y=0.5)
-------------------------------------------------------------------------------------------------------
expand.grid d <- expand.grid(x,y)
 transform(d,difference = d$Var1 -d$Var2)
  Var1 Var2 difference
1    2    1          1
2   -5    1         -6
3    2    2          0
4   -5    2         -7
5    2    3         -1
6   -5    3         -8
-------------------------------------------------------------------------------------------------------
> x
[1]  2 -5
> y
[1] 1 2 3
> rowSums(expand.grid(-y,x))
[1]  1  0 -1 -6 -7 -8
-------------------------------------------------------------------------------------------------------
factor() expand.grid() all.possible <- expand.grid(c('a','b','c'), c('a','b','c'))
all.possible <- all.possible[all.possible[, 1] != all.possible[, 2], ]
all.possible <- unique(apply(all.possible, 1, function(x) paste(sort(x), collapse='-')))

df <- data.frame('x' = c('a', 'b', 'c', 'c', 'c'), 
                 'y' = c('c', 'c', 'a', 'a', 'b'))
table(factor(apply(df , 1, function(x) paste(sort(x), collapse='-')), levels=all.possible))
-------------------------------------------------------------------------------------------------------
base data.table a <- matrix(seq(1, 100, by = 1), 10, 10)
b <- c(2, 4, 5, 6, 7, 8)
c <- c(5, 3, 1, 4, 6, 2)

res <- t(sapply(X = mapply(FUN = function(b, c) expand.grid(b, seq(from = c, to = 8)), b, c, SIMPLIFY = FALSE), FUN = function(x) {
    c(a[as.matrix(x)], rep(0, 8 - nrow(x)))
}))

res
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
## [1,]   42   52   62   72    0    0    0    0
## [2,]   24   34   44   54   64   74    0    0
## [3,]    5   15   25   35   45   55   65   75
## [4,]   36   46   56   66   76    0    0    0
## [5,]   57   67   77    0    0    0    0    0
## [6,]   18   28   38   48   58   68   78    0



# Let's break it down in multiple steps.

coordinates <- mapply(FUN = function(b, c) expand.grid(b, seq(from = c, to = 8)), b, c, SIMPLIFY = FALSE)

# below sapply subsets c using each element in coordinates and pads result with additional 0s such that total 8 elements are returned.

res <- sapply(X = coordinates, FUN = function(x) {
    c(a[as.matrix(x)], rep(0, 8 - nrow(x)))
})
res
##      [,1] [,2] [,3] [,4] [,5] [,6]
## [1,]   42   24    5   36   57   18
## [2,]   52   34   15   46   67   28
## [3,]   62   44   25   56   77   38
## [4,]   72   54   35   66    0   48
## [5,]    0   64   45   76    0   58
## [6,]    0   74   55    0    0   68
## [7,]    0    0   65    0    0   78
## [8,]    0    0   75    0    0    0


# you probably need result as traspose
res <- t(res)

res
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
## [1,]   42   52   62   72    0    0    0    0
## [2,]   24   34   44   54   64   74    0    0
## [3,]    5   15   25   35   45   55   65   75
## [4,]   36   46   56   66   76    0    0    0
## [5,]   57   67   77    0    0    0    0    0
## [6,]   18   28   38   48   58   68   78    0
-------------------------------------------------------------------------------------------------------
expand.grid apply matrix A1/B1  A1/B2  A1/B3  ...
A2/B1  A2/B2  A2/B3  ...
...    ...    ...    ...
...    ...    ...    ... txt <- "A    B     C     D    E     F\n187  174   183   115  101   104\n451  166   177   842  101   133\n727  171   187 12803   98   134\n1532  181   196   730   98   108\n4139  188   214 20358  105   159\n689  185   211  1633  110   162\n1625  184   195  2283  109   114\n771  181   190   904  105   110\n950  177   190  1033  106   112\n703  180   191   463  106   110\n2052  178   188  2585  100   105\n1161  178   187  2874   99   110\n214  175   184   173   98   110\n473  184   191   971  104   111\n756  185   193 14743  107   114"

data <- as.matrix(read.table(textConnection(txt), header = TRUE))

# expand.grid : creates every combination of one element each from column A and
# B with elements of B repeated first 

# apply : calls function(x) { x[1]/x[2]) } for every combination outputted by 
# expand.grid 

# matrix : converts the result of apply into matrix. dimnames arguments sets 
# rownames and colnames for easy  verification for us

result <- matrix(apply(expand.grid(data[, "A"], data[, "B"]), 1, function(x) x[1]/x[2]), 
    nrow = nrow(data), dimnames = list(data[, "A"], data[, "B"]))

# note that we have set rownames for result to be values of A and colnames for
# result to be value of B
result
##            174       166       171       181        188       185       184
## 187   1.074713  1.126506  1.093567  1.033149  0.9946809  1.010811  1.016304
## 451   2.591954  2.716867  2.637427  2.491713  2.3989362  2.437838  2.451087
## 727   4.178161  4.379518  4.251462  4.016575  3.8670213  3.929730  3.951087
## 1532  8.804598  9.228916  8.959064  8.464088  8.1489362  8.281081  8.326087
## 4139 23.787356 24.933735 24.204678 22.867403 22.0159574 22.372973 22.494565
## 689   3.959770  4.150602  4.029240  3.806630  3.6648936  3.724324  3.744565
## 1625  9.339080  9.789157  9.502924  8.977901  8.6436170  8.783784  8.831522
## 771   4.431034  4.644578  4.508772  4.259669  4.1010638  4.167568  4.190217
## 950   5.459770  5.722892  5.555556  5.248619  5.0531915  5.135135  5.163043
## 703   4.040230  4.234940  4.111111  3.883978  3.7393617  3.800000  3.820652
## 2052 11.793103 12.361446 12.000000 11.337017 10.9148936 11.091892 11.152174
## 1161  6.672414  6.993976  6.789474  6.414365  6.1755319  6.275676  6.309783
## 214   1.229885  1.289157  1.251462  1.182320  1.1382979  1.156757  1.163043
## 473   2.718391  2.849398  2.766082  2.613260  2.5159574  2.556757  2.570652
## 756   4.344828  4.554217  4.421053  4.176796  4.0212766  4.086486  4.108696
##            181       177       180       178       178       175       184
## 187   1.033149  1.056497  1.038889  1.050562  1.050562  1.068571  1.016304
## 451   2.491713  2.548023  2.505556  2.533708  2.533708  2.577143  2.451087
## 727   4.016575  4.107345  4.038889  4.084270  4.084270  4.154286  3.951087
## 1532  8.464088  8.655367  8.511111  8.606742  8.606742  8.754286  8.326087
## 4139 22.867403 23.384181 22.994444 23.252809 23.252809 23.651429 22.494565
## 689   3.806630  3.892655  3.827778  3.870787  3.870787  3.937143  3.744565
## 1625  8.977901  9.180791  9.027778  9.129213  9.129213  9.285714  8.831522
## 771   4.259669  4.355932  4.283333  4.331461  4.331461  4.405714  4.190217
## 950   5.248619  5.367232  5.277778  5.337079  5.337079  5.428571  5.163043
## 703   3.883978  3.971751  3.905556  3.949438  3.949438  4.017143  3.820652
## 2052 11.337017 11.593220 11.400000 11.528090 11.528090 11.725714 11.152174
## 1161  6.414365  6.559322  6.450000  6.522472  6.522472  6.634286  6.309783
## 214   1.182320  1.209040  1.188889  1.202247  1.202247  1.222857  1.163043
## 473   2.613260  2.672316  2.627778  2.657303  2.657303  2.702857  2.570652
## 756   4.176796  4.271186  4.200000  4.247191  4.247191  4.320000  4.108696
##            185
## 187   1.010811
## 451   2.437838
## 727   3.929730
## 1532  8.281081
## 4139 22.372973
## 689   3.724324
## 1625  8.783784
## 771   4.167568
## 950   5.135135
## 703   3.800000
## 2052 11.091892
## 1161  6.275676
## 214   1.156757
## 473   2.556757
## 756   4.086486
-------------------------------------------------------------------------------------------------------
?expand.grid > expand.grid(1:3, 1:2, 1)
  Var1 Var2 Var3
1    1    1    1
2    2    1    1
3    3    1    1
4    1    2    1
5    2    2    1
6    3    2    1 do.call do.call(expand.grid, list(1:3, 1:2, 1))
-------------------------------------------------------------------------------------------------------
grid.arrange() gridExtra SitutationA library(grid)
library(gridExtra)
p1<-ggplot(subset(data,sep=="SitutationA"), aes(x=tech, y=error)) +
  geom_bar(aes(fill=error), stat="identity", position="dodge") + 
  facet_grid(sep ~ ., scales="free_y") + 
  scale_fill_continuous(guide=FALSE)+
  scale_y_continuous(breaks=c(0,0.25,0.50))+
  theme(axis.text.x=element_blank(),
        axis.title.x=element_blank(),
        axis.ticks.x=element_blank(),
        plot.margin=unit(c(1,1,-0.4,1),"lines")) SitutationB scale_fill_continuous() p2<-ggplot(subset(data,sep=="SitutationB"), aes(x=tech, y=error)) +
  geom_bar(aes(fill=error), stat="identity", position="dodge") + 
  facet_grid(sep ~ ., scales="free_y") + 
  scale_fill_continuous(guide=FALSE,low="red",high="purple") +
  theme(plot.margin=unit(c(-0.4,1,1,1),"lines")) grid.arrange(p1,p2)
-------------------------------------------------------------------------------------------------------
aggregate geom_point data.frame nutm <- aggregate( Nitrate ~ Date + Hydrology , data = nut , FUN = mean )

p <-ggplot(nut, aes(Date, Nitrate, shape = Hydrology)) +
  geom_point( data = nut , aes( fill = Wetland , group=Wetland ), colour="black", size=4)+
  scale_fill_manual(values=colvec) +
  scale_shape_manual(values=c(21,22))+
  facet_grid(. ~ Hydrology) +
  ylab ("Nitrate (mg/L) ") +
  geom_point( data = nutm , aes( x = Date , y = Nitrate) , color = "red" , fill = "red" , size = 4 ) +
  theme(legend.position="none",
        panel.background = element_rect(fill='white', colour='white'), 
        panel.grid = element_line(color = NA),
        panel.grid.minor = element_line(color = NA),
        panel.border = element_rect(fill = NA, color = "black"),
        axis.text.x  = element_text(size=10, colour="black"),  
        axis.title.x = element_text(vjust=0.1),
        axis.text.y = element_text(size=12, colour="black"),
        axis.title.y = element_text(vjust=0.3))

p
-------------------------------------------------------------------------------------------------------
## Example matrices
m1 <- matrix(1:4, nrow=2)
m2 <- matrix(1:6, nrow=2)
m3 <- matrix(1:2, nrow=2)

## A function that should do what you're after
f <- function(...) {
    mm <- list(...)
    ii <- expand.grid(lapply(mm, function(X) seq_len(ncol(X))))
    lapply(seq_len(nrow(ii)), function(Z) {
        mapply(FUN=function(X, Y) X[,Y], mm, ii[Z,])
    })
}

## Try it out
f(m1)
f(m1,m2)
f(m1,m2,m3)
-------------------------------------------------------------------------------------------------------
data.table library(data.table)
set.seed(1234)
DT <- data.table(x=rep(c(1,2,3),each=1e6), 
                  y=c("A","B"), 
                  v=sample(1:100,12))

out <- DT[,list(SUM=sum(v)),by=list(x,y)]
# edit (mnel) to avoid setNames which creates a copy
# when calling `names<-` inside the function
out[, as.list(setattr(SUM, 'names', y)), by=list(x)]
})
   x        A        B
1: 1 26499966 28166677
2: 2 26499978 28166673
3: 3 26500056 28166650 tapply(DT$v,list(DT$x, DT$y), FUN=sum)
         A        B
1 26499966 28166677
2 26499978 28166673
3 26500056 28166650 system.time({ 
   out <- DT[,list(SUM=sum(v)),by=list(x,y)]
   out[, as.list(setattr(SUM, 'names', y)), by=list(x)]})
##  user  system elapsed 
## 0.64    0.05    0.70 
system.time(tapply(DT$v,list(DT$x, DT$y), FUN=sum))
## user  system elapsed 
## 7.23    0.16    7.39 library(data.table)
set.seed(1234)
DT <- data.table(x=c(rep(c(1,2,3),each=4),3,4), y=c("A","B"), v=sample(1:100,14))

out <- DT[,list(SUM=sum(v)),by=list(x,y)]
setkey(out, x, y)

intDT <- expand.grid(unique(out[,x]), unique(out[,y]))
setnames(intDT, c("x", "y"))
out <- out[intDT]

out[, as.list(setattr(SUM, 'names', y)), by=list(x)] DT[, sum(v), keyby = list(x,y)][CJ(unique(x), unique(y)), allow.cartesian = T][,
   setNames(as.list(V1), paste(y)), by = x] DT[, list(sum(v), mean(v)), keyby = list(x,y)][CJ(unique(x), unique(y)), allow.cartesian = T][,
   setNames(as.list(c(V1, V2)), c(paste0(y,".sum"), paste0(y,".mean"))), by = x]
#   x A.sum B.sum   A.mean B.mean
#1: 1    72   123 36.00000   61.5
#2: 2    84   119 42.00000   59.5
#3: 3   187    96 62.33333   48.0
#4: 4    NA    81       NA   81.0
-------------------------------------------------------------------------------------------------------
ow <- expand.grid(c(1.5,2.5),c(1.5,2.5))
row.names(ow)<-letters[1:4]
pw <- expand.grid(1:3,1:3)
row.names(pw)<-LETTERS[1:9]
B <- rbind(expand.grid("a",row.names(pw)[c(1,2,4,5)]),
           expand.grid("b",row.names(pw)[c(2,3,5,6)]),
           expand.grid("c",row.names(pw)[c(4,5,7,8)]),
           expand.grid("d",row.names(pw)[c(5,6,8,9)]))
B <- cbind(B,abs(rnorm(16))) # The location of your oil wells:
ow
   Var1 Var2
a  1.5  1.5
b  2.5  1.5
c  1.5  2.5
d  2.5  2.5
# Of your production wells:
pw
  Var1 Var2
A    1    1
B    2    1
C    3    1
D    1    2
E    2    2
F    3    2
G    1    3
H    2    3
I    3    3
#And a b value for each pairs of neighbouring oil/production wells:
   Var1 Var2 abs(rnorm(16))
1     a    A     1.78527757
2     a    B     1.61794028
3     a    D     1.80234599
4     a    E     0.04202002
5     b    B     0.90265280
6     b    C     1.05214769
7     b    E     0.67932237
8     b    F     0.11497430
9     c    D     0.26288589
10    c    E     0.50745137
11    c    G     0.74102529
12    c    H     1.43919338
13    d    E     1.04111278
14    d    F     0.49372216
15    d    H     0.21500663
16    d    I     0.20156929 weirdplot <- function(ow_loc, pw_loc, B, 
                     pch_ow=19, pch_pw=17, 
                     col_ow="green", col_pw="blue", col_b="red", breaks){
    # with ow_loc and pw_loc the locations of your wells
    # B the correspondance table
    # pch_ow and pch_pw the point type for the wells
    # col_b, col_ow and col_pw the colors for the arrows and the wells
    # and breaks a vector of size categories for b values
    plot(pw_loc,type="n")
    b<-cut(B[,3], breaks=breaks)
    for(i in 1:nrow(B)){
        start=ow_loc[row.names(ow)==B[i,1],]
        end=pw_loc[row.names(pw)==B[i,2],]
        arrows(x0=start[,1],y0=start[,2], 
               x1=end[,1], y1=end[,2], lwd=b[i], col=col_b)
        }
    points(pw_loc, pch=pch_pw, col=col_pw)
    points(ow_loc, pch=pch_ow, col=col_ow)
    } weirdplot(ow, pw, B, breaks=c(0,0.5,1,1.5,2))
-------------------------------------------------------------------------------------------------------
transform(expand.grid(x=as.numeric(rownames(df)), 
                      y=as.numeric(colnames(df))), 
                      z=unlist(df)) set.seed(42)
m <- matrix(rnorm(25),ncol=5)
df <- as.data.frame(m)
rownames(df) <- colnames(df) <- 0:4

#    x y           z
# 01 0 0  1.37095845
# 02 1 0 -0.56469817
# 03 2 0  0.36312841
# 04 3 0  0.63286260
# 05 4 0  0.40426832
# 11 0 1 -0.10612452
# 12 1 1  1.51152200
# 13 2 1 -0.09465904
# 14 3 1  2.01842371
# 15 4 1 -0.06271410
# 21 0 2  1.30486965
# 22 1 2  2.28664539
# 23 2 2 -1.38886070
# 24 3 2 -0.27878877
# 25 4 2 -0.13332134
# 31 0 3  0.63595040
# 32 1 3 -0.28425292
# 33 2 3 -2.65645542
# 34 3 3 -2.44046693
# 35 4 3  1.32011335
# 41 0 4 -0.30663859
# 42 1 4 -1.78130843
# 43 2 4 -0.17191736
# 44 3 4  1.21467470
# 45 4 4  1.89519346
-------------------------------------------------------------------------------------------------------
lattice y x xyplot(foodexp~income , data =engel, 
       type = c("g"),
       auto.key=list(x=.8,y=.35,cex=.8,cex.title=.8, title="", points=TRUE), 
       scales=list(tck=-1),ylab=list("Food Expenditure",font=3),
       xlab=list("Household Income",font=3),
       panel=function(x,y,...){
         panel.xyplot(x,y)
         panel.grid()
         panel.abline(rq(y ~ x, tau = 0.5))
         panel.points(x, y, cex = 0.5, col = "blue")
         panel.abline(rq(y ~ x, tau = 0.5), col = "blue")
         panel.abline(lm(y ~ x), lty = 2, col = "red")
         taus <- c(0.05, 0.1, 0.25, 0.75, 0.9, 0.95)
         for (i in 1:length(taus)) {
           panel.abline(rq(y ~ x, tau = taus[i]),
                  col = "gray")
         }

       }
)
-------------------------------------------------------------------------------------------------------
Answers = list()
For(i in 1:30) {
  For(j in 1:??) {
    For(k in 1:??) {
      For(l in 1:??){
        For(m in 1:??){
          mod <- lm(Y ~ LHt[i] + LCv[j] + LKu[k] + LSk[l] + L??[m])
          Answers[[length(Answers)+1]] = list(i,j,k,l,m,summary(mod)$adj.r.squared)
        }
      }
    }
  }
} LHt[i] + LCv[j] + LKu[k] + LSk[l] + L??[m] expand.grid LHT_names = lapply(1:30,function(i) paste("LHt[",i,"]",sep="")) #a list of names of LHT type variables for use in formula
LCv_names = lapply(1:?,function(i) paste("LCv[",i,"]",sep="")) #similar for LCv
LKu_names = ...
LSk_names = ...
L??_names = ...

temp = expand.grid(c(LHt_names, LCv_names, LKu_names, LSk_names, L??_names)) list_of_formulas = lapply(seq_along(nrow(temp)), function(i) paste("Y~",paste(temp[i,],collapse="+"),sep = "")) list_of_models = lapply(list_of_formulas, function(x)  lm(x) )
-------------------------------------------------------------------------------------------------------
lattice require(ggplot2)
require(grid)

# user-level interface to the element grob
my_axis = function(text,rot=0) {
  structure(
    list(text=text,rot=rot),
    class = c("element_custom","element_blank", "element") # inheritance test workaround
  )
}
# returns a gTree with two children: the text label, and a rasterGrob below
element_grob.element_custom <- function(element,...)  {
  g2 <- rectGrob(gp=gpar(fill='red',alpha=0.5))
  g1 <- textGrob(element$text, x=0.5,vjust=0.5,rot  =element$rot)
  gTree(children=gList(g2,g1), cl = "custom_axis")
}
# gTrees don't know their size and ggplot would squash it, so give it room
 grobHeight.custom_axis = heightDetails.custom_axis = function(x, ...)
   unit(1, "lines")


ggplot(mtcars,aes(mpg,disp))+geom_point()+facet_grid(.~vs)+
  theme_bw() +
  theme(axis.title.x = my_axis('my custom x title'),
        axis.title.y = my_axis('my custom y title',rot=90))
-------------------------------------------------------------------------------------------------------
mapply expand.grid # some dummy data
xx <- data.frame(replicate(5, runif(50)))
yy <- setNames(data.frame(replicate(3, runif(50))), paste0('Y',1:3))
# all combinations
cs <- expand.grid(list(pred = names(xx), resp = names(yy)), stringsAsFactors= FALSE)

# a function to do the fitting
fitting <- function(pred, resp, dd){
  # fit linear model
  ff <- reformulate(pred, resp)
  lmf <- lm(ff, data =dd)
  # create a formula for poly(,2)
  ff.poly2 <- update(ff, .~poly(.,2, raw=TRUE))
  # and poly(,3)
  ff.poly3 <- update(ff, .~poly(.,3, raw=TRUE))
  # fit these models
  lmp2 <- lm(ff.poly2, data = dd)
  lmp3 <- lm(ff.poly3, data = dd)
  # return a list with these three models
  list(linear = lmf, poly2 = lmp2, poly3 = lmp3)
}

biglist <- mapply('fitting', pred = as.list(cs[['pred']]), 
        resp = as.list(cs[['resp']]),
       MoreArgs = list(dd = cbind(xx,yy)), SIMPLIFY = FALSE)

# give this list meaningful names

names(biglist) <- do.call(paste, c(cs, sep = ':')) lapply lapply(lapply(biglist, `[[`,'linear'), summary) lapply(lapply(biglist, `[[`,'poly2'), summary) print(summary(lm)) capture.output(lapply(biglist, function(x) lapply(x, summary)), file = 'results.txt') results.txt
-------------------------------------------------------------------------------------------------------
ggplot2 df country2 country1 langLevel scales="free_y" facet_grid() library(ggplot2)
ggplot(df,aes(country2,frequency,fill=langLevel))+geom_bar(stat="identity")+
  facet_grid(country1~.,scales="free_y")
-------------------------------------------------------------------------------------------------------
##initialize matrix
nof.rows <- 100
mat <- cbind(matrix(ncol=40, nrow=nof.rows, sample(40*nof.rows)),
         matrix(ncol=6, nrow=nof.rows, c(1,2,-1,3, -2, -3),
                dimnames=list(seq_len(nof.rows),c("a", "b", "c", "d", "e", "f"))))
col="a"

pos.row.idx <- which(mat[,col]>0)
neg.row.idx <- which(mat[,col]<0)
newmat <- unique(t(apply(expand.grid(pos.row.idx, neg.row.idx), 1, function(x){
  abs(mat[x[2],col]) * mat[x[1],] + abs(mat[x[1],col]) * mat[x[2],]
})))
-------------------------------------------------------------------------------------------------------
require(xts)

X.stock.rtns <- xts(rnorm(1000,0.00001,0.0003), Sys.Date()-(1000:1))
Y.stock.rtns <- xts(rnorm(1000,0.00003,0.0004), Sys.Date()-(1000:1))
Z.stock.rtns <- xts(rnorm(1000,0.00005,0.0005), Sys.Date()-(1000:1))
rtn.obj <- merge(X.stock.rtns , Y.stock.rtns, Z.stock.rtns)
colnames(rtn.obj) <- c("x","y","z")

# advanced charts.PerforanceSummary based on ggplot
gg.charts.PerformanceSummary <- function(rtn.obj, geometric = TRUE, main = "", plot = TRUE)
  {

    # load libraries
    suppressPackageStartupMessages(require(ggplot2))
    suppressPackageStartupMessages(require(scales))
    suppressPackageStartupMessages(require(reshape))
    suppressPackageStartupMessages(require(PerformanceAnalytics))

    # create function to clean returns if having NAs in data
    clean.rtn.xts <- function(univ.rtn.xts.obj,na.replace=0){
    univ.rtn.xts.obj[is.na(univ.rtn.xts.obj)]<- na.replace
    univ.rtn.xts.obj  
  }

    # Create cumulative return function
    cum.rtn <- function(clean.xts.obj, g = TRUE)
    {
      x <- clean.xts.obj
      if(g == TRUE){y <- cumprod(x+1)-1} else {y <- cumsum(x)}
      y
    }

    # Create function to calculate drawdowns
    dd.xts <- function(clean.xts.obj, g = TRUE)
    {
      x <- clean.xts.obj
      if(g == TRUE){y <- Drawdowns(x)} else {y <- Drawdowns(x,geometric = FALSE)}
      y
    }

    # create a function to create a dataframe to be usable in ggplot to replicate charts.PerformanceSummary
    cps.df <- function(xts.obj,geometric)
    {
      x <- clean.rtn.xts(xts.obj)
      series.name <- colnames(xts.obj)[1]
      tmp <- cum.rtn(x,geometric)
      tmp$rtn <- x
      tmp$dd <- dd.xts(x,geometric)
      colnames(tmp) <- c("Index","Return","Drawdown") # names with space
      tmp.df <- as.data.frame(coredata(tmp))
      tmp.df$Date <- as.POSIXct(index(tmp))
      tmp.df.long <- melt(tmp.df,id.var="Date")
      tmp.df.long$asset <- rep(series.name,nrow(tmp.df.long))
      tmp.df.long
    }

    # A conditional statement altering the plot according to the number of assets
    if(ncol(rtn.obj)==1)
    {
      # using the cps.df function
      df <- cps.df(rtn.obj,geometric)
      # adding in a title string if need be
      if(main == ""){
        title.string <- paste("Asset Performance")
      } else {
        title.string <- main
      }

    gg.xts <- ggplot(df, aes_string( x = "Date", y = "value", group = "variable" )) +
      facet_grid(variable ~ ., scales = "free_y", space = "fixed") +
      geom_line(data = subset(df, variable == "Index")) +
      geom_bar(data = subset(df, variable == "Return"), stat = "identity") +
      geom_line(data = subset(df, variable == "Drawdown")) +
      geom_hline(yintercept = 0, size = 0.5, colour = "black") +
      ggtitle(title.string) +
      theme(axis.text.x = element_text(angle = 0, hjust = 1)) +
      scale_x_datetime(breaks = date_breaks("6 months"), labels = date_format("%m/%Y")) +
      ylab("") +
      xlab("")

  } 
 else 
  {
    # a few extra bits to deal with the added rtn columns
    no.of.assets <- ncol(rtn.obj)
    asset.names <- colnames(rtn.obj)
    df <- do.call(rbind,lapply(1:no.of.assets, function(x){cps.df(rtn.obj[,x],geometric)}))
    df$asset <- ordered(df$asset, levels=asset.names)
    if(main == ""){
      title.string <- paste("Asset",asset.names[1],asset.names[2],asset.names[3],"Performance")
    } else {
      title.string <- main
    }

    if(no.of.assets>5){legend.rows <- 5} else {legend.rows <- no.of.assets}

      gg.xts <- ggplot(df, aes_string(x = "Date", y = "value" )) +

      # panel layout
      facet_grid(variable~., scales = "free_y", space = "fixed", shrink = TRUE, drop = TRUE, margin = 
                 , labeller = label_value) + # label_value is default

      # display points for Index and Drawdown, but not for Return
      geom_point(data = subset(df, variable == c("Index","Drawdown"))
                 , aes(colour = factor(asset), shape = factor(asset)), size = 1.2, show_guide = TRUE) + 

      # manually select shape of geom_point
      scale_shape_manual(values = c(1,2,3)) + 

      # line colours for the Index
      geom_line(data = subset(df, variable == "Index"), aes(colour = factor(asset)), show_guide = FALSE) +

      # bar colours for the Return
      geom_bar(data = subset(df,variable == "Return"), stat = "identity"
           , aes(fill = factor(asset), colour = factor(asset)), position = "dodge", show_guide = FALSE) +

      # line colours for the Drawdown
      geom_line(data = subset(df, variable == "Drawdown"), aes(colour = factor(asset)), show_guide = FALSE) +

      # horizontal line to indicate zero values
      geom_hline(yintercept = 0, size = 0.5, colour = "black") +

      # horizontal ticks
      scale_x_datetime(breaks = date_breaks("6 months"), labels = date_format("%m/%Y")) +

      # main y-axis title
      ylab("") +

      # main x-axis title
      xlab("") +

      # main chart title
      ggtitle(title.string)

      # legend 

      gglegend <- guide_legend(override.aes = list(size = 3))

      gg.xts <- gg.xts + guides(colour = gglegend, size = "none") +

      # gglegend <- guide_legend(override.aes = list(size = 3), direction = "horizontal") # direction overwritten by legend.box?
      # gg.xts <- gg.xts + guides(colour = gglegend, size = "none", shape = gglegend) + # Warning: "Duplicated override.aes is ignored"

      theme( legend.title = element_blank()
             , legend.position = c(0,1)
             , legend.justification = c(0,1)
             , legend.background = element_rect()
             , legend.box = "horizontal" # not working?
             , axis.text.x = element_text(angle = 0, hjust = 1)
            )

}

assign("gg.xts", gg.xts,envir=.GlobalEnv)
if(plot == TRUE){
    plot(gg.xts)
} else {}

}

# display chart
gg.charts.PerformanceSummary(rtn.obj, geometric = TRUE) # create a function to store fancy axis labels 

    my_labeller <- function(var, value){ # from the R Cookbook
        value <- as.character(value)
        if (var=="variable") 
        {
              value[value=="Index"] <- "Cumulative Returns"
              value[value=="Return"] <- "Daily Returns"
              value[value=="Drawdown"] <- "Drawdown"
        }
        return(value)
    } theme( legend.title = element_blank()
         , legend.position = c(0,1)
         , legend.justification = c(0,1)
         , legend.background = element_rect()
         #, legend.key = element_rect(fill="white",colour="white")# added as afterthought
         , legend.box = "horizontal" # not working?
         , axis.text.x = element_text(angle = 0, hjust = 1)
         #, axis.title.y = element_text(size=2,colour="black")
         , strip.background = element_rect(fill = 'white')
         , panel.background = element_rect(fill = 'white', colour = 'white')
         , panel.grid.major = element_line(colour = "grey", size = 0.5) 
         , panel.grid.minor = element_line(colour = NA, size = 0.0)
        )
-------------------------------------------------------------------------------------------------------
reshape unlist setNames df.t <- as.data.frame(t(df))
vec <- unlist(df.t, use.names=FALSE) # gives a vector not matrix/data.frame
vec.names <- do.call(paste, c(expand.grid(rownames(df.t), colnames(df.t)), sep="."))
vec <- setNames(vec, vec.names)

# X1.a X2.a X3.a X1.b X2.b X3.b X1.c X2.c X3.c X1.d X2.d X3.d 
#    1    5    9    2    6   10    3    7   11    4    8   12
-------------------------------------------------------------------------------------------------------
wrap <- function(x) paste0("(",x,")")

rowcol <- function(row,col) paste(wrap(row),wrap(col),sep="*",collapse="+") > rowcol(c("A","B","C"),c("D","E","F"))
[1] "(A)*(D)+(B)*(E)+(C)*(F)" > rowcol(c("A","B"),c("0","X+Y"))
[1] "(A)*(0)+(B)*(X+Y)" symprod <- function(A,B) sapply(1:ncol(B), function(j)sapply(1:nrow(A), function(i)rowcol(A[i,],B[,j])))

sympow <- function(A,n) { B <- A; for( i in seq_len(n-1) ) B <- symprod(B,A); B } > A <- matrix(LETTERS[1:4],2,2)
> diag(A) <- 0
> sympow(A,3)
     [,1]                                          [,2]                                         
[1,] "((0)*(0)+(C)*(B))*(0)+((0)*(C)+(C)*(0))*(B)" "((0)*(0)+(C)*(B))*(C)+((0)*(C)+(C)*(0))*(0)"
[2,] "((B)*(0)+(0)*(B))*(0)+((B)*(C)+(0)*(0))*(B)" "((B)*(0)+(0)*(B))*(C)+((B)*(C)+(0)*(0))*(0)" simplify <- function(e)
{
    if( mode(e) %in% c("name","numeric") ) return(e)

    if( as.character(e[[1]])=="+" )
    {
        x <- simplify(e[[2]])

        y <- simplify(e[[3]])

        if( identical(x,0) ) return(y)

        if( identical(y,0) ) return(x)

        return(call("+", x, y))
    }

    if( as.character(e[[1]])=="*" )
    {
        x <- simplify(e[[2]])

        if( identical(x,0) ) return(0)

        y <- simplify(e[[3]])

        if( identical(y,0) ) return(0)

        return(call("*", x, y))
    }

    if( as.character(e[[1]])=="(" )
    {
        x <- simplify(e[[2]])

        if( mode(x) %in% c("name","numeric") ) return(x)

        return(call("(", x))
    }
} call simplify_text <- function(s) deparse(simplify(parse(text=s)[[1]])) > simplify_text("(x)+(0*(a+b))+(z)")
[1] "x + z" rowcol rowcol <- function(row,col) simplify_text(paste(wrap(row),wrap(col),sep="*",collapse="+")) > sympow(A,3)
     [,1]          [,2]         
[1,] "0"           "(C * B) * C"
[2,] "(B * C) * B" "0" rowcol cellprod <- function(r, s)
{
    z <- expand.grid(r,s, stringsAsFactors=FALSE)

    filter <- (z$Var1 != 0) & (z$Var2 != 0)

    paste(z$Var1[filter], z$Var2[filter], sep="*", collapse="+")
}

rowcol <- function(row,col)
{
    x <- strsplit(row, "\\+")

    y <- strsplit(col, "\\+")

    L <- vapply(seq_along(x), function(i) cellprod(x[[i]],y[[i]]), character(1))

    filter <- nzchar(L)

    if( ! any(filter) ) return("0")

    paste(L[filter], collapse="+")
} x*y*z+a*b+f > sympow(A,3)
     [,1]    [,2]   
[1,] "0"     "C*B*C"
[2,] "B*C*B" "0" > A <- matrix(LETTERS[1:9],3,3)
> B <- matrix(LETTERS[10:18],3,3)
> A[2,3] <- 0
> A[3,2] <- 0
> B[1,3] <- 0
> B[3,1] <- 0
> A
     [,1] [,2] [,3]
[1,] "A"  "D"  "G" 
[2,] "B"  "E"  "0" 
[3,] "C"  "0"  "I" 
> B
     [,1] [,2] [,3]
[1,] "J"  "M"  "0" 
[2,] "K"  "N"  "Q" 
[3,] "0"  "O"  "R"
> symprod(A,B)
     [,1]      [,2]          [,3]     
[1,] "A*J+D*K" "A*M+D*N+G*O" "D*Q+G*R"
[2,] "B*J+E*K" "B*M+E*N"     "E*Q"    
[3,] "C*J"     "C*M+I*O"     "I*R"
-------------------------------------------------------------------------------------------------------
mm <- expand.grid(rownames(mat),colnames(mat))[as.vector(mat==1),]

 Var1 Var2
1    X1   X1
4    X4   X1
6    X2   X2
7    X3   X2
9    X1   X3
11   X3   X3 mm[order(mm$Var1),]
   Var1 Var2
1    X1   X1
9    X1   X3
6    X2   X2
7    X3   X2
11   X3   X3
4    X4   X1 mat <- data.frame(X1=c(1,0,0,1),X2=c(0,1,1,0),X3=c(1,0,1,0))
rownames(mat)= paste0('X',1:4)

   X1 X2 X3
X1  1  0  1
X2  0  1  0
X3  0  1  1
X4  1  0  0
-------------------------------------------------------------------------------------------------------
require(reshape2)
require(ggplot2)
Data.m <- melt(Data,id=Y)
rbPal <- colorRampPalette(c('red','blue'))
Data.m$Col <- rbPal(10)[as.numeric(cut(Data.m$value,breaks = 10))]
ggplot(Data.m, aes(value, Y,col=Col)) + 
  geom_point() +
  facet_grid(variable~.)
-------------------------------------------------------------------------------------------------------
DF <- expand.grid(x=1:100, y=1:100)
DF$z <- abs(sin(DF$x/34) * cos(DF$y/22)) x y z plot(DF$x, DF$y, col=rgb((colorRamp(c("blue", "red"))(DF$z))/255), pch=19) library("ggplot2")
ggplot(DF, aes(x, y, colour=z)) +
  geom_point(shape=19) +
  scale_colour_gradient(low="blue", high="red")
-------------------------------------------------------------------------------------------------------
color=ifelse(y<0, 'red', 'black') aes() scale_color_identity() ggplot(df) + geom_point(aes(x, y, color=ifelse(y<0, 'red', 'black'))) + 
   facet_grid(case ~. ,)+scale_color_identity()
-------------------------------------------------------------------------------------------------------
ggplot(data, aes(y=y, x=x)) + 
  geom_point(shape = 1) +
  geom_smooth(method="lm", fullrange=T) +
  facet_grid(~a) + 
  theme(aspect.ratio = 1)
-------------------------------------------------------------------------------------------------------
diamonds2 price geom_density() diamonds diamonds2 diamonds2 clarity diamonds2<-diamonds["price"]
ggplot(diamonds, aes(price)) + geom_density()+facet_grid(.~clarity) + 
     geom_density(data=diamonds2,aes(price),colour="blue") geom_density() ggplot(diamonds, aes(price)) + geom_density()+facet_grid(.~clarity) +
     geom_density(data=transform(diamonds, clarity=NULL),aes(price),colour="blue") geom_density() aes(color=clarity) clarity geom_density() ggplot(diamonds,aes(price))+geom_density(aes(color=clarity))+geom_density()
-------------------------------------------------------------------------------------------------------
Date data$Date<-as.Date(paste(data$Date,"-01",sep=""),format="%Y-%m-%d") angle= hjust=1 theme_bw() ggplot(data=na.omit(data), aes(x=Date, y=Ptot, group=Station))+
  geom_line()+
  facet_grid(Station~.)+
  scale_x_date(breaks = "month", labels=date_format("%Y-%m"))+
  xlab("Year")+
  ylab("Prec (mm)")+theme_bw()+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
-------------------------------------------------------------------------------------------------------
ggplot2 #  generate some fake data
x <- c("A","B","C","D")
y <- c("a","b","c","d")
dat <- expand.grid(x=x,y=y)
dat$r <- as.numeric(dat$y)**4

library(ggplot2)
# create ggplot object
g<-ggplot(dat, aes(x=x,y=y,size=r))
# add some 'geom' layers
g+geom_point(shape=21)+
  geom_text(size=4,aes(label=r))+
  # scale the size of the point by area
  scale_size_area(max_size=30,guide="none")+
  theme_bw()
-------------------------------------------------------------------------------------------------------
(S0,E0,B0,tau,Fe,tb,Be) nls data with with predict newdata modelS <- function(S0,E0,B0,tau,Fe, tb, Be) {
  x <- Fe*(S0/E0)*(1-exp(-B0*E0*tau))
  b <- Fe*(S0/E0)*(1-exp(-B0*E0*tb))
  x*exp(-x)+Be*(1-exp(-x)-(x*exp(-x)))*exp(-b)}

## Define starting values

start <- list(Fe = 0.2, tb = 0.1, Be = 0.1)

## Fit the model using nls

modelS.fitted <- nls(formula = fert ~ modelS(S0,E0,B0,tau,Fe, tb, Be), data = data.nls, start = start, 
                     control=nls.control(warnOnly=TRUE,minFactor=1e-5),trace = T, lower = c(0,0,0), 
                     upper = c(1, Inf, 1), algorithm = "port")

## Combine model parameters

model.data <- data.frame(
  S0=seq(min(data.nls$S0),max(data.nls$S0),length.out=1e5),
  E0=seq(min(data.nls$E0),max(data.nls$E0),length.out=1e5),
  B0=seq(min(data.nls$B0),max(data.nls$B0),length.out=1e5),
  tau=seq(min(data.nls$tau),max(data.nls$tau),length.out=1e5))
model.data$pred <- predict(modelS.fitted,newdata=model.data)


## Plot

ggplot(data.nls) +
  geom_point(aes(x = S0, y = fert), size = 2) +
  geom_line(data=model.data,aes(x = S0, y = pred), lwd = 1.3) +
  scale_x_log10() new.data S0 <- seq(min(data.nls$S0),max(data.nls$S0),length.out=1e4)
  E0 <- seq(1,20,length.out=20)
  B0 <- unique(data.nls$B0)
  tau <- unique(data.nls$tau)

model.data <- expand.grid(S0,E0,B0,tau)
names(model.data) <- c("S0","E0","B0","tau")

model.data$pred <- predict(modelS.fitted,newdata=model.data)



## Plot

ggplot(model.data) +
  geom_line(data=,aes(x = S0, y = pred, color=interaction(E0,B0,tau)), lwd = 1.3) +
  geom_point(data=data.nls,aes(x = S0, y = fert), size = 2) +
  scale_x_log10()
-------------------------------------------------------------------------------------------------------
library(ggplot2) 
x <-runif(9, 0, 125) 
data <- as.data.frame(x) 
data$y <--runif(9, 0, 125) 
data$yy <- factor(c("a","b","c")) 

ggplot(data, aes(x, y)) + geom_point(shape = 2) + facet_grid(~yy) + 
    geom_text(aes(x, y, label=lab),
        data=data.frame(x=60,y=Inf,lab=c("this","is","the way"),
            yy=letters[1:3]), vjust=1)
-------------------------------------------------------------------------------------------------------
g <- h <- i <- c(1:3)
j<-expand.grid(g,h,i)

tmp<-c(0,0,0)
t(sapply(t(j),function(x,tmp){ tmp[x]<-1;tmp }, tmp))
-------------------------------------------------------------------------------------------------------
paste( start = "My name is",
        apply( expand.grid(name.first = c("John","Jane"),
                           name.last  = c("Doe","Smith"), 
                           stringsAsFactors=FALSE),
               1, paste, collapse=" "),
        end  = "and I am a person.")

[1] "My name is John Doe and I am a person."   "My name is Jane Doe and I am a person."  
[3] "My name is John Smith and I am a person." "My name is Jane Smith and I am a person."
-------------------------------------------------------------------------------------------------------
mpg facet_grid dataset$variable c("median_something", "aggregated_average_x","error","something_else") reformat <– function(x,lab="\n"){ sapply(x, function(c){ paste(unlist(strsplit(as.character(c) , split="_")),collapse=lab) }) } reformat dataset$variable <- factor(dataset$variable, labels=reformat(dataset$variable, lab='\n') ggplot(data=dataset, aes(x,y)) + geom_point() + facet_grid(. ~ variable)
-------------------------------------------------------------------------------------------------------
cut f1 f2 factor paste factor split factor dat$f1.group<-cut(dat$f1,c(0,1,15,30,60,80,90,95,100))
dat$f2.group<-cut(dat$f1,c(0,5,10,15,20))
gr<-expand.grid(levels(dat$f1.group),levels(dat$f2.group))
names(gr)<-c('f1.group','f2.group')
gr$combined = paste(gr$f1.group,gr$f2.group)
dat<-merge(gr,dat)[c('id','f1','f2','combined')]
split(dat,dat$combined) list data.frame gr
-------------------------------------------------------------------------------------------------------
subset() ggplot() ggplot(data=subset(mydata2,variable %in% c("DENSITY","SPL")), aes(TIMESTAMP, value)) + 
  geom_point() + facet_grid(variable~., scale  = "free_y")
-------------------------------------------------------------------------------------------------------
obs proc library(ggplot2)
library(reshape2)

ss.data = data.frame(
    pop=c("E1", "E2", "E3", "E4", "E5", "E6", "E7", "C1", "C2", "C3", "C4"),
    obs=c(0.0027, 0.0018, 0.0464, 0.0095, 0.0034, 0.0117, 0.017, 0.1178,
          0.0449, 0.039, 0.0903),
    proc=c(0.0319, 0.0196, 0.0511, 0.0143, 0.0048, 0.0078, 0.0396, 0.1662,
           0.074, 0.1681, 0.1358), stringsAsFactors=FALSE)

# Add new column 'species' by removing the trailing digits from 'pop'.
ss.data$species = gsub("\\d", "", ss.data$pop)

# Convert data to long-form with 'melt' from the reshape2 package.
mdat = melt(ss.data, id.vars=c("pop", "species"),
            measure.vars=c("obs", "proc"))

plot_1 = ggplot(mdat, aes(x=pop, y=value, fill=variable)) +
         theme_bw() +
         geom_bar(position="stack", stat="identity") +
         scale_fill_manual(values=c("grey50", "grey80")) +
         facet_grid(. ~ species, space="free_x", scales="free_x",
             labeller=label_both)

ggsave("plot_1.png", plot=plot_1, width=6.5, height=4)
-------------------------------------------------------------------------------------------------------
subm value mcsm value scale_y...() mcsm value value2 scale_color_discrete() breaks= mcsm$value2<-as.numeric(mcsm$value)
ggplot(subm, aes(date, value, col=variable, group=1)) + geom_line()+
 facet_grid(variable~., scale='free_y') + geom_step(data=mcsm, aes(date, value2)) +
  scale_color_discrete(breaks=c('psavert','uempmed','unemploy','q')) gridExtra p ggplot_build() ggplot_gtable() gp gp.leg library(gridExtra)
p<-ggplot(subm, aes(date, value, col=variable, group=1)) + geom_line()+
  facet_grid(variable~., scale='free_y') + geom_step(data=mcsm, aes(date, value2)) +
  scale_color_discrete(breaks=c('psavert','uempmed','unemploy','q'))
gp<-ggplot_gtable(ggplot_build(p))
gp.leg<-gp$grobs[[17]] p1 p2 subm mcsm scale_color_manual() p plot.margin= faced_grid() p1 <- ggplot(subm, aes(date, value, col=variable, group=1)) + geom_line()+
   facet_grid(variable~., scale='free_y')+
  theme(plot.margin = unit(c(0.5,0.5,-0.25,0.5), "lines"),
        axis.text.x=element_blank(),
        axis.title.x=element_blank(),
        axis.ticks.x=element_blank())+
  scale_color_manual(values=c("#F8766D","#00BFC4","#C77CFF"),guide="none")

p2 <- ggplot(data=mcsm, aes(date, value,group=1,col=variable)) + geom_step() +
  facet_grid(variable~., scale='free_y')+
  theme(plot.margin = unit(c(-0.25,0.5,0.5,0.5), "lines"))+ylab("")+
  scale_color_manual(values="#7CAE00",guide="none") p1 p2 gp1 <- ggplot_gtable(ggplot_build(p1))
gp2 <- ggplot_gtable(ggplot_build(p2))
maxWidth = grid::unit.pmax(gp1$widths[2:3],gp2$widths[2:3])
gp1$widths[2:3] <- as.list(maxWidth)
gp2$widths[2:3] <- as.list(maxWidth) grid.arrange() arrangeGrob() grid.arrange(arrangeGrob(arrangeGrob(gp1,gp2,heights=c(3/4,1/4),ncol=1),
       gp.leg,widths=c(7/8,1/8),ncol=2))
-------------------------------------------------------------------------------------------------------
position_dodge alpha library(reshape2)
ldat <- melt(dat)


 # slight overlap
 ggplot(ldat, aes(x=value, colour = variable, fill = variable)) + 
    geom_histogram(position = position_dodge(width = 0.5), binwidth = 1, alpha =0.5) # or the default value
ggplot(ldat, aes(x=value, colour = variable, fill = variable)) + 
  geom_histogram(position = 'dodge', binwidth = 1) ggplot(ldat, aes(x=value)) + 
  geom_histogram(binwidth=1,fill = 'grey', colour = 'black') +
  facet_grid(~variable)
-------------------------------------------------------------------------------------------------------
geom_errorbar() width=0 df x=foresttype ggplot() ggplot(df,aes(x = foresttype))+
  geom_bar(aes(y = average, fill = type),stat="identity",position='stack')+
  geom_errorbar(aes(ymin = ystart,ymax = yend),width=0)+facet_grid( ~ Month)
-------------------------------------------------------------------------------------------------------
set.seed(1)
n = 10
x <- runif(n, min=0, max=2)
y <- runif(n, min=8, max=24)
z <- runif(n, min=0, max=100)

#z to cex function
a <- 1
b <- 0.02
z.cex <- a + b*z

example.cex <- seq(1,3,0.5)
example.z <- (example.cex - a)/b
example.z 


plot(x, y, pch=21, bg="orange", col="red", cex=z.cex, lwd=2, bty="n", xaxt="n", yaxt="n", xlab="", ylab="")
grid()
axis(1, at=seq(0,2,0.5), pos=16, col="green4", lwd=3)
axis(2, at=seq(8,24,4), pos=1, col="green4", lwd=3)
legend("topright", legend=c(example.z), pch=21, pt.bg="orange", col="red", pt.cex=example.cex, title="sales vol.", bg="white")
-------------------------------------------------------------------------------------------------------
numpy.random.multivariate_normal import numpy as np
import matplotlib.pyplot as plt


num_samples = 400

# The desired mean values of the sample.
mu = np.array([5.0, 0.0, 10.0])

# The desired covariance matrix.
r = np.array([
        [  3.40, -2.75, -2.00],
        [ -2.75,  5.50,  1.50],
        [ -2.00,  1.50,  1.25]
    ])

# Generate the random samples.
y = np.random.multivariate_normal(mu, r, size=num_samples)


# Plot various projections of the samples.
plt.subplot(2,2,1)
plt.plot(y[:,0], y[:,1], 'b.')
plt.plot(mu[0], mu[1], 'ro')
plt.ylabel('y[1]')
plt.axis('equal')
plt.grid(True)

plt.subplot(2,2,3)
plt.plot(y[:,0], y[:,2], 'b.')
plt.plot(mu[0], mu[2], 'ro')
plt.xlabel('y[0]')
plt.ylabel('y[2]')
plt.axis('equal')
plt.grid(True)

plt.subplot(2,2,4)
plt.plot(y[:,1], y[:,2], 'b.')
plt.plot(mu[1], mu[2], 'ro')
plt.xlabel('y[1]')
plt.axis('equal')
plt.grid(True)

plt.show()
-------------------------------------------------------------------------------------------------------
facet_grid() facet_wrap() species year qplot(x, y, data = d)+
  facet_grid(species~year, scales = "free_y", drop = FALSE)
-------------------------------------------------------------------------------------------------------
expand.grid() rowSums() expand.grid() rowSums() r = c(0,1,2)
s = c(0,5,10)
rowSums(expand.grid(r,s))
[1]  0  1  2  5  6  7 10 11 12 sort() r = c(0,1,2)
s = c(0,5,10)
k=c(3,4,6)
rowSums(expand.grid(r,s,k))
 [1]  3  4  5  8  9 10 13 14 15  4  5  6  9 10 11 14 15 16  6  7  8 11 12 13 16 17 18
sort(rowSums(expand.grid(r,s,k)))
 [1]  3  4  4  5  5  6  6  7  8  8  9  9 10 10 11 11 12 13 13 14 14 15 15 16 16 17 18
-------------------------------------------------------------------------------------------------------
outer Reduce as.vector(Reduce(function(x, y) outer(x, y, '+'), list(r, s, k)))
#  [1]  3  4  5  8  9 10 13 14 15  4  5  6  9 10 11 14 15 16  6  7  8 11 12 13 16 17 18 sort w <- sample(50)
x <- sample(50)
y <- sample(50)
z <- sample(30)

# arun's 
system.time(t1 <- as.vector(Reduce(function(x, y) outer(x, y, '+'), list(w, x, y, z))))
#    user  system elapsed 
#   0.051   0.044   0.100 

# Didzis'
system.time(t2 <- rowSums(expand.grid(w, x, y, z)))
#    user  system elapsed 
#   1.167   0.308   1.579 

identical(as.numeric(t1), t2)
[1] TRUE
-------------------------------------------------------------------------------------------------------
expand.grid R> expand.grid(var1, var2)
   Var1 Var2
1     1    1
2     2    1
3     3    1
4     4    1
5     5    1
6     6    1
7     7    1
8     8    1
9     9    1
10   10    1
11    1    6
12    2    6
13    3    6
14    4    6
15    5    6
16    6    6
17    7    6
18    8    6
19    9    6
20   10    6
-------------------------------------------------------------------------------------------------------
myfun ares <- expand.grid(1:nrow(A), 1:nrow(B))
ares$res <- myfun(A[ares[,1], ), B[res[,2] ) 
# but may need mapply("myfun", A[ares[,1], ), B[res[,2] ) on which Vectorize is based
# or do.call(my.fun, ....)
a <- matrix(ares$res, nrow(A), nrow(B) )
-------------------------------------------------------------------------------------------------------
## First I generate combinations of the supplied
dd <- expand.grid(seq_along(ptareas),seq_along(isect_polys))
## Using mapply to test intersection (1-1,2-2,...
mapply(function(x,y)intersect(ptareas[[x]],isect_polys[[y]]),
       dd$Var1,dd$Var2) gpclib rgeos
-------------------------------------------------------------------------------------------------------
merge aggregate set.seed(1)
df <- cbind(expand.grid(x = 1:3, y = 1:5), time = round(runif(15) * 30))
to.merge <- data.frame(x = c(2, 2, 2, 3, 2), y = c(1, 1, 1, 5, 4), time = c(17, 12, 11.6, 22.5, 2), val = letters[1:5], stringsAsFactors = F)

#Find rows that match by x and y
res <- merge(to.merge, df, by = c("x", "y"), all.x = TRUE)
res$dif <- abs(res$time.x - res$time.y)
res
##   x y time.x val time.y dif
## 1 2 1   17.0   a     11 6.0
## 2 2 1   12.0   b     11 1.0
## 3 2 1   11.6   c     11 0.6
## 4 2 4    2.0   e      6 4.0
## 5 3 5   22.5   d     23 0.5

#Find rows that need to be merged
res1 <- merge(aggregate(dif ~ x + y, data = res, FUN = min), res)
res1
##   x y dif time.x val time.y
## 1 2 1 0.6   11.6   c     11
## 2 2 4 4.0    2.0   e      6
## 3 3 5 0.5   22.5   d     23

#Finally merge the result back into df
final <- merge(df, res1[res1$dif <= 1, c("x", "y", "val")], all.x = TRUE)
final
##    x y time  val
## 1  1 1    8 <NA>
## 2  1 2   27 <NA>
## 3  1 3   28 <NA>
## 4  1 4    2 <NA>
## 5  1 5   21 <NA>
## 6  2 1   11    c
## 7  2 2    6 <NA>
## 8  2 3   20 <NA>
## 9  2 4    6 <NA>
## 10 2 5   12 <NA>
## 11 3 1   17 <NA>
## 12 3 2   27 <NA>
## 13 3 3   19 <NA>
## 14 3 4    5 <NA>
## 15 3 5   23    d
-------------------------------------------------------------------------------------------------------
for ## For reproducibility
set.seed( 35471 )

## Example data - bigger than the original to get and idea of difference in speed
x<-matrix(rnorm(60),20,3)
y<-matrix(rnorm(300),100,3)

# My function which uses grid.expand to get all combinations of row indices, then rowSums to operate on them
rs <- function( x , y ){
rows <- expand.grid( 1:nrow(x) , 1:nrow(y) )
results <- matrix( rowSums( x[ rows[,1] , ] * y[ rows[,2] , ] ) , nrow(x) , nrow(y) )
return(results)
}

# Your orignal function
flp <- function(x ,y){
results<-matrix(NA,nrow(x),nrow(y))
for (i in 1:nrow(x)){
  for (j in 1:nrow(y)){
    r1<-x[i,]
    r2<-y[j,]
    results[i,j]<-sum(r1*r2)  ## Example function
  }
}
return(results)
}


## Benchmark timings:
library(microbenchmark)
microbenchmark( rs( x, y ) , flp( x ,y ) , times = 100L )
#Unit: microseconds
#     expr      min       lq     median        uq      max neval
#  rs(x, y)  487.500  527.396   558.5425   620.486   679.98   100
# flp(x, y) 9253.385 9656.193 10008.0820 10430.663 11511.70   100

## And a subset of the results returned from each function to confirm they return the same thing!
flp(x,y)[1:3,1:3]
#          [,1]       [,2]       [,3]
#[1,] -0.5528311  0.1095852  0.4461507
#[2,] -1.9495687  1.7814502 -0.3769874
#[3,]  1.8753978 -3.0908057  2.2341414

rs(x,y)[1:3,1:3]
#          [,1]       [,2]       [,3]
#[1,] -0.5528311  0.1095852  0.4461507
#[2,] -1.9495687  1.7814502 -0.3769874
#[3,]  1.8753978 -3.0908057  2.2341414 rowSums
-------------------------------------------------------------------------------------------------------
matrix data <- matrix(c(dog, cat, pig), nrow=3, ncol=4, dimnames=list(c("dog", "cat", "pig"), c("A", "C", "T", "G")))
data

>   dog cat pig
> A 100 99  100
> C 30  31  12 
> T 140 150 90 
> G 102 123 144 barplot(data) x <- data.frame(
     animals=c(rep("dog",4),rep("cat",4),rep("pig",4)),
     gen=c(rep(c("A","C","T","G"),3)),
     value=c(100,30,140,102,99,31,150,123,100,12,90,144))

>    animals gen value
> 1      dog   A   100
> 2      dog   C    30
> 3      dog   T   140
> 4      dog   G   102
> 5      cat   A    99
> 6      cat   C    31
> 7      cat   T   150
> 8      cat   G   123
> 9      pig   A   100
> 10     pig   C    12
> 11     pig   T    90
> 12     pig   G   144 library(ggplot2)
library(reshape2)

ggplot(mx, aes(x=animals,y=value)) + 
     geom_bar(stat="identity") + 
     facet_grid(~gen)
-------------------------------------------------------------------------------------------------------
order= aes() geom_bar() Response desc() factor() ggplot(dat, aes(Banner, Proportion/100, fill=Response,
                label=ifelse(Proportion > 5, percent(Proportion/100), ""))) + 
  geom_bar(position="fill", stat="identity",aes(order=desc(Response))) + 
  geom_text(aes(Banner, Pos/100)) + 
  facet_grid(~Phase) + 
  scale_y_continuous(labels=percent) +
  labs(x="\nCompany", y="\nProportion") dat <- ddply(dat, .(Banner, Phase), function(x) {
  x$Pos <- (100-cumsum(x$Proportion) + 0.5*x$Proportion)
  x
})
-------------------------------------------------------------------------------------------------------
R> apply(expand.grid(vars, vis), 1, paste, collapse=".")
[1] "SR.1" "PL.1" "SR.2" "PL.2" "SR.3" "PL.3" expand.grid data.frame apply apply matrix outer matrix outer as.vector(outer(vars, vis, paste, sep="."))
# [1] "SR.1" "PL.1" "SR.2" "PL.2" "SR.3" "PL.3"
-------------------------------------------------------------------------------------------------------
stat_summary() geom="pointrange" stat_summary() y ymin ymax my.fun stat_summary() my.fun<-function(x){data.frame(ymin=min(x),ymax=max(x),y=mean(x))}

graph <- ggplot(slantclean, aes(x = View,value, fill = Texture))

graph + stat_summary(fun.y = mean, geom = "bar", position = "dodge") + 
  stat_summary(fun.data = my.fun, geom = "pointrange", position = position_dodge(width = 0.90)) + 
  labs(x = "View", y = "Vertical height of ellipse (cm)", fill = "Texture") + 
  facet_grid( Shape ~ TNOGroup)
-------------------------------------------------------------------------------------------------------
graphics.off() dev.copy dev.off() graphics.off() dev.off() ggsave print last_plot ggplot p ggsave('filname.png') for (i in 1:2){
  if (1){
    hist(rnorm(100))
    dev.copy(file="MyHist.png",device=png, bg="white",  width=640, height=352) 
    graphics.off()

    p <- ggplot(bin.ts.avg, aes(x, tt)) + geom_point() +geom_line() + facet_grid(.~depday)
    p <- p + ggtitle("10 minute averages")+ xlab("Hour") + ylab("Values")    
    p <- p + scale_x_continuous(breaks=c(min(bin.ts.avg$x), max(bin.ts.avg$x)), labels=c("7", "10"))
   # no need to print p
   ggsave(filename="MyGGPlot.png")
   # note specifying p is redundant but explicit.
   # ggsave(filename = 'MyGGplot.png', plot = p)
  }
}
-------------------------------------------------------------------------------------------------------
expand.grid exg <- expand.grid(x, x)
exg[apply(exg, 1, diff) == VALUE.TO.FIND, ]  # notice the ', ' (comma-and-space)

  Var1 Var2
52 -0.2  0.8 VALUE.TO.FIND dist <- apply(exg, 1, diff)
exg[dist == max(dist),  ]
-------------------------------------------------------------------------------------------------------
set.seed(1234)
DT <- data.table(x=rep(c(1,2,3),each=4), y=c("A","B"), v=sample(1:100,12))
DT[, id := seq_len(nrow(DT))]

setkey(DT, y)

uniqY <- unique(DT$y)

for(jj in uniqY){
  nc <- do.call(paste, c(expand.grid('Sum', c('x','v'),jj), sep ='.'))
  DT[.(jj), (nc) := list(cumsum(x), cumsum(v))]

}

setkey(DT, id)

DT[, 5:8 := lapply(.SD, function(x) { 
  xn <- is.na(x)
  x[xn] <- -Inf
  xx <- cummax(x)
  # deal with leading NA values
    if(xn[1]){
    xn1 <- which(xn)[1]
  xx[seq_len(xn1)] <- NA}   

  xx }), .SDcols = 5:8]
-------------------------------------------------------------------------------------------------------
ys <- unique(DT$y)
sdcols <- c("x", "v")
cols <- paste0("SUM.", sdcols)
DT[, c(cols) := lapply(.SD, cumsum), by = y, .SDcols = sdcols]
for( i in seq_along(ys)) {
    cols <- paste0("SUM.", sdcols, ".", ys[i])
    DT[, c("v1", "v2") := list(SUM.x, SUM.v[i]), by = SUM.x]
    DT[, c("v1", "v2") := list(c(rep(NA_integer_, (i-1)), v1)[seq_len(.N)], 
    c(rep(NA_integer_, (i-1)), v2)[seq_len(.N)])]
    setnames(DT, c("v1", "v2"), cols)
} arun <- function(DT) {

    ys <- unique(DT$y)
    sdcols <- c("x", "v")
    cols <- paste0("SUM.", sdcols)
    DT[, c(cols) := lapply(.SD, cumsum), by = y, .SDcols = sdcols]
    for( i in seq_along(ys)) {
        cols <- paste0("SUM.", sdcols, ".", ys[i])
        DT[, c("v1", "v2") := list(SUM.x, SUM.v[i]), by = SUM.x]
        DT[, c("v1", "v2") := list(c(rep(NA_integer_, (i-1)), v1)[seq_len(.N)], 
        c(rep(NA_integer_, (i-1)), v2)[seq_len(.N)])]
        setnames(DT, c("v1", "v2"), cols)
    }
    DT
} mnel <- function(DT) {
    set.seed(1234)
    DT <- data.table(x=rep(c(1,2,3),each=4), y=c("A","B"), v=sample(1:100,12))
    DT[, id := seq_len(nrow(DT))]
    setkey(DT, y)
    uniqY <- unique(DT$y)
    for(jj in uniqY){
      nc <- do.call(paste, c(expand.grid('Sum', c('x','v'),jj), sep ='.'))
      DT[.(jj), (nc) := list(cumsum(x), cumsum(v))]

    }
    setkey(DT, id)
    DT[, 5:8 := lapply(.SD, function(x) { 
      xn <- is.na(x)
      x[xn] <- -Inf
      xx <- cummax(x)
      # deal with leading NA values
        if(xn[1]){
        xn1 <- which(xn)[1]
      xx[seq_len(xn1)] <- NA}   
      xx }), .SDcols = 5:8]
} statquant <- function(DT){
    #first step is to create cumsum columns
    colNames <- c("x","v"); newColNames <- paste0("SUM.",colNames)
    DT[, newColNames:=lapply(.SD,cumsum) ,by=y, .SDcols=colNames, with=F];
    #now we need to reshape each SUM.* to SUM.*.{yvalue}
    DT[,N:=.I]; setattr(DT,"sorted","N")

    g <- function(DT,SD){
      cols <- c('N',grep('SUM',colnames(SD), value=T));
      Yval <- unique(SD[,y]);
      merge(DT, SD[,cols, with=F], suffixe=c('',paste0('.',Yval)), all.x=T);    
    }

    DT <- Reduce(f=g,init=DT,x=split(DT,DT$y));

    locf = function(x) {
      ind = which(!is.na(x))    
      if(is.na(x[1])) ind = c(1,ind)
      rep(x[ind], times = diff( c(ind, length(x) + 1) )) 
    }

    newColNames <- grep('SUM',colnames(DT),value=T);
    DT <- DT[, (newColNames):=lapply(.SD, locf), .SDcols=newColNames]
    DT
} grothendieck <- function(DT) {
    cumsum0 <- function(x) { x <- cumsum(x); ifelse(x == 0, NA, x) }
    DT2 <- DT[, {SUM.<-y; lapply(data.table(model.matrix(~ SUM.:x + SUM.:v + 0)), cumsum0)}]
    setnames(DT2, sub("(.):(.)", "\\2.\\1", names(DT2)))
    DT2
} library(data.table)
library(zoo)
set.seed(1234)
DT <- data.table(x=rep(c(1,2,3),each=4), y=c("A","B"), v=sample(1:100,12))

library(microbenchmark)
microbenchmark( s <- statquant(copy(DT)), g <- grothendieck(copy(DT)), 
                m <- mnel(copy(DT)), a <- arun(copy(DT)), times = 1e3)

# Unit: milliseconds
#                         expr       min        lq    median        uq       max neval
#     s <- statquant(copy(DT)) 13.041125 13.674083 14.493870 17.273151 144.74186  1000
#  g <- grothendieck(copy(DT))  3.634120  3.859143  4.006085  4.443388  80.01984  1000
#          m <- mnel(copy(DT))  7.819286  8.234178  8.596090 10.423668  87.07668  1000
#          a <- arun(copy(DT))  6.925419  7.369286  7.703003  9.262719  53.39823  1000 #     x y  v SUM.x SUM.v SUM.x.A SUM.v.A SUM.x.B SUM.v.B
#  1: 1 A 12     1    12       1      12      NA      NA
#  2: 1 B 62     1    62       1      12       1      62
#  3: 1 A 60     2    72       2      72       1      62
#  4: 1 B 61     2   123       2      72       2     123
#  5: 2 A 83     4   155       4     155       2     123
#  6: 2 B 97     4   220       4     155       4     220
#  7: 2 A  1     6   156       6     156       4     220
#  8: 2 B 22     6   242       6     156       6     242
#  9: 3 A 99     9   255       9     255       6     242
# 10: 3 B 47     9   289       9     255       9     289
# 11: 3 A 63    12   318      12     318       9     289
# 12: 3 B 49    12   338      12     318      12     338 #    x y  v id Sum.x.A Sum.v.A Sum.x.B Sum.v.B
#  1: 1 A 12  1       1      12      NA      NA
#  2: 1 B 62  2       1      12       1      62
#  3: 1 A 60  3       2      72       1      62
#  4: 1 B 61  4       2      72       2     123
#  5: 2 A 83  5       4     155       2     123
#  6: 2 B 97  6       4     155       4     220
#  7: 2 A  1  7       6     156       4     220
#  8: 2 B 22  8       6     156       6     242
#  9: 3 A 99  9       9     255       6     242
# 10: 3 B 47 10       9     255       9     289
# 11: 3 A 63 11      12     318       9     289
# 12: 3 B 49 12      12     318      12     338 #      N x y  v SUM.x SUM.v SUM.x.A SUM.v.A SUM.x.B SUM.v.B
#  1:  1 1 A 12     1    12       1      12      NA      NA
#  2:  2 1 B 62     1    62       1      12       1      62
#  3:  3 1 A 60     2    72       2      72       1      62
#  4:  4 1 B 61     2   123       2      72       2     123
#  5:  5 2 A 83     4   155       4     155       2     123
#  6:  6 2 B 97     4   220       4     155       4     220
#  7:  7 2 A  1     6   156       6     156       4     220
#  8:  8 2 B 22     6   242       6     156       6     242
#  9:  9 3 A 99     9   255       9     255       6     242
# 10: 10 3 B 47     9   289       9     255       9     289
# 11: 11 3 A 63    12   318      12     318       9     289
# 12: 12 3 B 49    12   338      12     318      12     338 #    SUM.x.A SUM.x.B SUM.v.A SUM.v.B
#  1:       1      NA      12      NA
#  2:       1       1      12      62
#  3:       2       1      72      62
#  4:       2       2      72     123
#  5:       4       2     155     123
#  6:       4       4     155     220
#  7:       6       4     156     220
#  8:       6       6     156     242
#  9:       9       6     255     242
# 10:       9       9     255     289
# 11:      12       9     318     289
# 12:      12      12     318     338
-------------------------------------------------------------------------------------------------------
warning ggplot(mtcars) + geom_rect(data = subset(mtcars, cyl == 4), aes(fill = cyl),xmin = -inf,xmax = Inf, ymin = -Inf,ymax = Inf, alpha = 0.05) +
  geom_point(aes(mpg, wt)) +  facet_grid(. ~ cyl)
-------------------------------------------------------------------------------------------------------
text_KIOSK = dat$Cnt
text_AGENT = dat$Cnt
text_KIOSK[dat$Channel=='AGENT'] = 0
text_AGENT[dat$Channel=='KIOSK'] = 0
text_KIOSK = text_KIOSK/1.7 + c(0,cumsum(text_KIOSK)[-length(dat$Cnt)])
text_AGENT = text_AGENT/1.7 + c(0,cumsum(text_AGENT)[-length(dat$Cnt)])
text_KIOSK[dat$Channel=='AGENT'] = 0
text_AGENT[dat$Channel=='KIOSK'] = 0
pie_text = text_KIOSK + text_AGENT


vis = ggplot(data=dat, aes(x=factor(1), y=Cnt, fill=Volume)) +
  geom_bar(stat="identity", position=position_fill(width=1)) +
  coord_polar(theta="y") +
  facet_grid(Channel~.) +
  geom_text(aes(y=pie_text, label=format(Cnt,format="d",big.mark=','), ymax=Inf), position=position_fill(width=1))
-------------------------------------------------------------------------------------------------------
# Simulate some data and put in data frame DF
n <- 100
x <- rnorm(n)
y <- 3 + 2* x * rexp(n) + rnorm(n)
# add some outliers
y[sample(1:n,20)] <- rnorm(20,20,20)
DF <- data.frame(x,y)

# Calculate 2d density over a grid
library(MASS)
dens <- kde2d(x,y)

# create a new data frame of that 2d density grid
# (needs checking that I haven't stuffed up the order here of z?)
gr <- data.frame(with(dens, expand.grid(x,y)), as.vector(dens$z))
names(gr) <- c("xgr", "ygr", "zgr")

# Fit a model
mod <- loess(zgr~xgr*ygr, data=gr)

# Apply the model to the original data to estimate density at that point
DF$pointdens <- predict(mod, newdata=data.frame(xgr=x, ygr=y))

# Draw plot
ggplot(DF, aes(x=x,y=y, color=pointdens)) + geom_point()
-------------------------------------------------------------------------------------------------------
expand.grid g <- as.matrix(expand.grid( seq(3), seq(3) ))
print(g)
      Var1 Var2
 [1,]    1    1
 [2,]    2    1
 [3,]    3    1    
 [4,]    1    2
 [5,]    2    2
 [6,]    3    2
 [7,]    1    3
 [8,]    2    3
 [9,]    3    3 g m <- t(apply(g, 1, 
             function(z) {
               x <- rep(0, 6)
               x[2 * z[1] - 1] <- 1
               x[2 * z[2]] <- 1
               x
             }))
print(m)
      [,1] [,2] [,3] [,4] [,5] [,6]
 [1,]    1    1    0    0    0    0
 [2,]    0    1    1    0    0    0
 [3,]    0    1    0    0    1    0
 [4,]    1    0    0    1    0    0
 [5,]    0    0    1    1    0    0
 [6,]    0    0    0    1    1    0
 [7,]    1    0    0    0    0    1
 [8,]    0    0    1    0    0    1
 [9,]    0    0    0    0    1    1 seq(3) expand.grid apply seq(3) seq(number.of.periods)
-------------------------------------------------------------------------------------------------------
# Solution:
numperiods <- 4
numevents <- 2
numseqs <- numperiods^numevents

gridparam <- rep(list(seq(numperiods)),numevents)
g <- as.matrix(expand.grid(gridparam))
print(g)

m <- t(apply(g, 1, 
         function(z) {
            x <- rep(0, numperiods*numevents) 
            for (i in 1:numseqs) 
            {
              x[numevents * z[i] - (numevents-i)] <- 1
            }
            x
         }))
print(m)

result <- array(m,c(numseqs,numevents,numperiods))
colnames(result) <- outer("Event",1:numevents, paste)
rownames(result) <- outer("Seq", 1:numseqs, paste)
# Time period is third dim
print(result)
-------------------------------------------------------------------------------------------------------
expand.grid() apply() d t apply() paste() collapse=" " apply(expand.grid(d,t),1,paste,collapse=" ")

 [1] "2013-01-17 11:25:30" "2013-01-24 11:25:30" "2013-02-09 11:25:30"
 [4] "2013-02-11 11:25:30" "2013-01-17 12:00:00" "2013-01-24 12:00:00"
 [7] "2013-02-09 12:00:00" "2013-02-11 12:00:00" "2013-01-17 15:31:25"
[10] "2013-01-24 15:31:25" "2013-02-09 15:31:25" "2013-02-11 15:31:25"
[13] "2013-01-17 19:15:48" "2013-01-24 19:15:48" "2013-02-09 19:15:48"
[16] "2013-02-11 19:15:48" "2013-01-17 23:51:06" "2013-01-24 23:51:06"
[19] "2013-02-09 23:51:06" "2013-02-11 23:51:06"
-------------------------------------------------------------------------------------------------------
expand.grid paste t <- c("11:25:30", "12:00:00", "15:31:25", "19:15:48", "23:51:06")
d <- c("2013-01-17", "2013-01-24", "2013-02-09", "2013-02-11") 
do.call("paste", expand.grid(d,t))
 [1] "2013-01-17 11:25:30" "2013-01-24 11:25:30" "2013-02-09 11:25:30"
 [4] "2013-02-11 11:25:30" "2013-01-17 12:00:00" "2013-01-24 12:00:00"
 [7] "2013-02-09 12:00:00" "2013-02-11 12:00:00" "2013-01-17 15:31:25"
[10] "2013-01-24 15:31:25" "2013-02-09 15:31:25" "2013-02-11 15:31:25"
[13] "2013-01-17 19:15:48" "2013-01-24 19:15:48" "2013-02-09 19:15:48"
[16] "2013-02-11 19:15:48" "2013-01-17 23:51:06" "2013-01-24 23:51:06"
[19] "2013-02-09 23:51:06" "2013-02-11 23:51:06" sep paste
-------------------------------------------------------------------------------------------------------
ylim xlim space=free facet_grid facet_wrap space=free gg_state + facet_grid(~region, scales = "free_x", space="free") map_state <- subset(fortify(map_data('state')),
                 region %in% c("california", "nevada"))
gg_state <- qplot(long, lat, data=map_state, geom="polygon", group=group)
gg_state + facet_wrap(~region, scales="free_x")
-------------------------------------------------------------------------------------------------------
plotmatrix() expand.grid() combs <- expand.grid(names(dataframe), names(dataframe))

out <- do.call(rbind, apply(combs, 1, function(x) {
  tt <- dataframe[, x]; names(tt) <- c("V1", "V2")
  tt <- cbind(tt, id1 = x[1], id2 = x[2])
})) library(plyr)
df.text=ddply(out[out$id1==out$id2,],.(id1,id2),summarise,
                       pos=max(V1)-(max(V1)-min(V1))/2) out[out$id1==out$id2,c("V1","V2")]<-NA geom_text() ggplot(data = out, aes(x = V2, y = V1)) + geom_point() +
  facet_grid(id1 ~ id2,scales="free")+
  geom_text(data=df.text,aes(pos,pos,label=id1))
-------------------------------------------------------------------------------------------------------
ggplot(datat, aes(x=Carga, y=Cat.A.88, fill=Vagas)) + 
  geom_bar(stat='identity', position='dodge') + ylab('Vagas') + 
  xlab('Carga horária') + facet_grid(. ~ Categoria) + coord_flip() + 
  guides(fill = guide_legend(reverse=T))
-------------------------------------------------------------------------------------------------------
combs <- as.matrix(expand.grid(-5:5,-5:5,-5:5))    
combs[combs %*% c(-2,-3,1) == -5,]
#      Var1 Var2 Var3
# [1,]    3   -2   -5
# [2,]    0    0   -5
# [3,]   -3    2   -5
# [4,]    5   -3   -4
# [5,]    2   -1   -4
# ...
-------------------------------------------------------------------------------------------------------
expand.grid idx = expand.grid((1:ncol(mat1)),(1:ncol(mat2)))

rbind(mat1[,idx[,1]], mat2[,idx[,2]]) mat.list <- list(mat1, mat2)
idx <- expand.grid(lapply(lapply(mat.list, ncol), seq_len))
do.call(rbind, mapply(function(x, j)x[, j], mat.list, idx))
-------------------------------------------------------------------------------------------------------
expand = c(0,0) scale_x_date geom_linerange ymin ymax geom_linerange filler_value ymin a7.data$filler_value2 <- 1 ymax geom_linerange expand a7.data$filler_value2 <- 1
bb <- ggplot(a7.data, aes(x = doy)) + 
geom_linerange( aes(ymin = filler_value , ymax = filler_value2 , color=status, group=1), size=15, alpha=0.9) + 
scale_x_date(label=date_format("%b"), breaks = "month" , expand = c(0,0)) + 
xlab("") + ylab("") + facet_grid(year~., scales="free") + 
theme_bw() + theme(axis.text.y=element_blank()) + 
theme(axis.ticks.y=element_blank()) + 
scale_color_manual(values=ccolors, name="Article VII Restrictions?")

# Display plot.
bb
-------------------------------------------------------------------------------------------------------
NA geom_text geom_text(data = out[!is.na(out$V1),], label = "test") rownames plotAll<-function(data){
  combs <- expand.grid(names(data), names(data))
  out <- do.call(rbind, apply(combs, 1, function(x) {
    tt <- data[, x]; names(tt) <- c("V1", "V2")
    tt <- cbind(tt, id1 = x[1], id2 = x[2])
  }))

  library(plyr)
  df.text=ddply(out[out$id1==out$id2,],.(id1,id2),summarise,
                pos=max(V1)-(max(V1)-min(V1))/2)
  out[out$id1==out$id2,c("V1","V2")]<-NA
  out$labels <- rownames(out)
  ggplot(data = out, aes(x = V2, y = V1)) + geom_text(data = out[!is.na(out$V1),], aes(label = labels)) +
    facet_grid(id1 ~ id2,scales="fixed")+
    geom_text(data=df.text,aes(pos,pos,label=id1)) + geom_abline( slope=1 ) + 
    ggtitle("Corralation between measured & calculated affinities") +
    ylab("") + xlab("") + theme(panel.grid.minor.x=element_blank(), panel.grid.major.x=element_blank())
}
plotAll(data)
-------------------------------------------------------------------------------------------------------
Day tmp$Day <- as.integer(as.character(tmp$Day))

ggplot(tmp, aes(x=Day, y=Mean, group=Group))+
  facet_grid(Mig~Measure)+
  geom_line()+
  scale_x_continuous(breaks=seq(-14,14,2))
-------------------------------------------------------------------------------------------------------
mtcars$ref <- as.factor(mtcars$gear)

p <- ggplot(mtcars, aes(mpg, wt)) + geom_point(aes(col=as.factor(gear)))
p + facet_grid(.~ref, margins = TRUE) library(ggplot2)

mtcars$ref <- (mtcars$gear)

# create the duplicate
dat <- do.call("rbind", replicate(2, mtcars, simplify = FALSE)) 

# give the duplicates a false value for "gear" so they can be plotted together 
#This value can then be used for faceting, grouping everything with "all".

dat$ref[1:32] <- "all" 


# where not in the "all" facet, change "gear" to one (so they are plotted with the same colour)
dat$gear[dat$ref != "all"] <- 1

# then plot using ref as the facet and gear to colour points.

p <- ggplot(dat, aes(mpg, wt)) + geom_point(aes(col=as.factor(gear)))
p + facet_grid(.~ref, margins = F)
-------------------------------------------------------------------------------------------------------
gridExtra library(ggplot2)
library(gridExtra)
mtcars$ALL <- "all"
p <- ggplot(mtcars, aes(mpg, wt))
p1 <- p + geom_point() + facet_grid(.~gear)
p2 <- p + geom_point(aes(color=factor(gear))) + facet_grid(.~ALL)
grid.arrange(p1, p2, ncol=2)
-------------------------------------------------------------------------------------------------------
library(ggplot2) #data
    df=data.frame(rna=factor(sample(-3:3,100,replace=T)),er=factor(rbinom(100,1,0.3)),type=factor(sample(1:5,100,replace=T)))
    ggplot(df , aes(x=rna , fill=er)) + geom_bar() + facet_grid(~type) #data
df=data.frame(rna=rnorm(100),er=factor(rbinom(100,1,0.3)),type=factor(sample(1:5,100,replace=T)))
 ggplot(df , aes(y=rna , x=er)) + geom_boxplot() + facet_grid(~type) library(plyr)
# Calculate the mean rna for each level of er and type
out <- ddply(df, c("er","type"), summarise, my.mn = mean(rna))
ggplot(out, aes(x = factor(type), y = my.mn, fill=factor(er))) + geom_bar(stat = "identity",position="dodge")
-------------------------------------------------------------------------------------------------------
done tkwait.variable OnOK done ## New object 'done'
done <- tclVar(0)

OnOK <- function()
{
    rbVal <- tclvalue(rbValue)
    tkdestroy(tt)
    testVal <<- rbVal
  ## When OK button is pressed, value of 'done' is changed
    tclvalue(done) <- 1
    print(rbVal)
    #return(rbVal)
}
OK.but <- tkbutton(tt,text="OK",command=OnOK)
tkgrid(OK.but)
tkfocus(tt)

## Tell R to wait for change in value of 'done'
tkwait.variable(done)

cat(testVal)
-------------------------------------------------------------------------------------------------------
X <-
  matrix(
    data=
    c(
        5, 9, 20
      , 6, 11, 2
      , 4, 5, 20
      , 6, 9, 46
      , 5, 7, 1
      , 3, 1, 12
      )
      , nrow = 6
      , ncol = 3
      , byrow=TRUE
      )

comb <- expand.grid(x1=1:nrow(X), x2=1:nrow(X))
XSub <- X[comb$x1,] - X[comb$x2,]
rownames(XSub) <- paste(comb$x1, comb$x2, sep="-") > XSub
    [,1] [,2] [,3]
1-1    0    0    0
2-1    1    2  -18
3-1   -1   -4    0
4-1    1    0   26
5-1    0   -2  -19
6-1   -2   -8   -8
1-2   -1   -2   18
2-2    0    0    0
3-2   -2   -6   18
4-2    0   -2   44
5-2   -1   -4   -1
6-2   -3  -10   10
1-3    1    4    0
2-3    2    6  -18
3-3    0    0    0
4-3    2    4   26
5-3    1    2  -19
6-3   -1   -4   -8
1-4   -1    0  -26
2-4    0    2  -44
3-4   -2   -4  -26
4-4    0    0    0
5-4   -1   -2  -45
6-4   -3   -8  -34
1-5    0    2   19
2-5    1    4    1
3-5   -1   -2   19
4-5    1    2   45
5-5    0    0    0
6-5   -2   -6   11
1-6    2    8    8
2-6    3   10  -10
3-6    1    4    8
4-6    3    8   34
5-6    2    6  -11
6-6    0    0    0
-------------------------------------------------------------------------------------------------------
mapply mapply(compare.Files, file_list1, file_list2) expand.grid file_list1 = c("d1/a.txt", "d1/b.txt")
file_list2 = c("d2/a.txt", "d2/b.txt")
file.comb <- expand.grid(file_list1, file_list2) compare.Files result <- mapply(compare.Files, as.vector(file.comb[,1]), as.vector(file.comb[,2]))
-------------------------------------------------------------------------------------------------------
reshape2 time id id.vars= library(reshape2)
df.long <- melt(df ,  id.vars = c("time","id"))
head(df.long)
  time id variable      value
1    1  a        d -0.3813535
2    2  a        d -0.5192448
3    3  b        d  0.3292604
4    4  b        d  0.5438868
5    5  a        d -0.6883436
6    6  b        d  0.7651908 variable id ggplot(df.long,aes(time,value,color=variable))+geom_line()+
         facet_grid(id~.) variable id ggplot(df.long,aes(time,value))+geom_line()+
      facet_grid(variable~id) facet_grid(id~.) group=id ggplot(df,aes(time,d,group=id))+geom_line()+facet_grid(id~.)
-------------------------------------------------------------------------------------------------------
plotmath plotmath atop levels(length_subject$CONSTRUCTION) <- 
  c("atop(textstyle('THAT'),textstyle('Extraposed'))", 
    "atop(textstyle('THAT'),textstyle('Post-predicate'))",
    "atop(atop(textstyle('TO'),textstyle('Extraposed')),italic('for')*textstyle('-subject'))",
    "atop(atop(textstyle('TO'),textstyle('Post-predicate')),italic('for')*textstyle('-subject'))",
    "atop(atop(textstyle('THAT'),textstyle('Extraposed')),italic('that')*textstyle('-omission'))",
    "atop(atop(textstyle('THAT'),textstyle('Post-predicate')),italic('that')*textstyle('-omission'))") labeller=label_parsed facet_grid ggplot( length_subject, aes( x = SUBJECT ) ) +
  geom_histogram(binwidth=.6, colour="black", fill="grey") +
  ylab("Frequency") +  
  xlab("Subject length") +  
  scale_x_discrete(breaks=c(2,4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30)) + #
  facet_grid( SUBJECT_TYPE~CONSTRUCTION, scales="free_x", space="free", 
              labeller=label_parsed) +
  theme(strip.text.x = element_text(size = 8))
-------------------------------------------------------------------------------------------------------
element require(ggplot2)
require(gridExtra) # tableGrob

element_grob.element_custom <- function(element, label="", ...)  {

  disect <- strsplit(label, "\\n")[[1]]
  g1 <- tableGrob(as.matrix(disect), parse=TRUE,
                  theme=theme.list(gpar.corefill = gpar(fill = NA, col = NA),
                                   core.just = "center"))
  gTree(children=gList(g1), height=grobHeight(g1), cl = "custom_strip")
}

# gTrees don't know their size and ggplot would squash it, so give it room
grobHeight.custom_strip = heightDetails.custom_axis = function(x, ...)
  x$height
# silly wrapper to fool ggplot2's slightly paranoid checks...
facet_custom <- function(...){
  structure(
    list(...), # this ... information is not used, btw
    class = c("element_custom","element_blank", "element") # inheritance test workaround
  ) 

}


title <- c("First*line \n italic('see that second')", 
           "this~is~boring",
           "integral(f(x)*dx, a, b)")

iris2 <- iris
iris2$Species <- factor(iris$Species, labels=title)
ggplot(iris2, aes(Sepal.Length, Sepal.Width)) +
  geom_line() + facet_grid(.~Species) +
  theme(strip.text.x = facet_custom())
-------------------------------------------------------------------------------------------------------
# Assuming Thresh is your threshold
thresh <- 10

# create some sample data
set.seed(123)
DT <- data.table(X=sample(-10:10, 5, TRUE), Y=sample(-10:10, 5, TRUE))

# create the disance matrix
distTable <- matrix(apply(createTable(DT), 1, distance), nrow=nrow(DT))

# remove the lower.triangle since we have symmetry (we don't want duplicates)
distTable[lower.tri(distTable)] <- NA

# Show which rows are above the threshold
pairedRows <- which(distTable >= thresh, arr.ind=TRUE)
colnames(pairedRows) <- c("RowA", "RowB")  # clean up the names > DT
    X   Y
1: -4 -10
2:  6   1
3: -2   8
4:  8   1
5:  9  -1 > pairedRows
     RowA RowB
[1,]    1    2
[2,]    1    3
[3,]    2    3
[4,]    1    4
[5,]    3    4
[6,]    1    5
[7,]    3    5 # pair-up all of the rows
createTable <- function(DT)   
  expand.grid(apply(DT, 1, list), apply(DT, 1, list))

# simple cartesian/pythagorean distance 
distance <- function(CoordPair)
  sqrt(sum((CoordPair[[2]][[1]] - CoordPair[[1]][[1]])^2, na.rm=FALSE))
-------------------------------------------------------------------------------------------------------
qqmath.ranef.mer() dotplot.ranef.mer() qqmath() dotplot() qqmath() require(lme4)                            ## for lmer(), sleepstudy
fit <- lmer(Reaction ~ Days + (Days|Subject), sleepstudy)
ggCaterpillar(ranef(fit, postVar=TRUE))  ## using ggplot2
qqmath(ranef(fit, postVar=TRUE))         ## for comparison dotplot() ggCaterpillar(ranef(fit, postVar=TRUE), QQ=FALSE)
dotplot(ranef(fit, postVar=TRUE)) dotplot() ggCaterpillar(ranef(fit, postVar=TRUE), QQ=FALSE, likeDotplot=FALSE) ## re = object of class ranef.mer
ggCaterpillar <- function(re, QQ=TRUE, likeDotplot=TRUE) {
    require(ggplot2)
    f <- function(x) {
        pv   <- attr(x, "postVar")
        cols <- 1:(dim(pv)[1])
        se   <- unlist(lapply(cols, function(i) sqrt(pv[i, i, ])))
        ord  <- unlist(lapply(x, order)) + rep((0:(ncol(x) - 1)) * nrow(x), each=nrow(x))
        pDf  <- data.frame(y=unlist(x)[ord],
                           ci=1.96*se[ord],
                           nQQ=rep(qnorm(ppoints(nrow(x))), ncol(x)),
                           ID=factor(rep(rownames(x), ncol(x))[ord], levels=rownames(x)[ord]),
                           ind=gl(ncol(x), nrow(x), labels=names(x)))

        if(QQ) {  ## normal QQ-plot
            p <- ggplot(pDf, aes(nQQ, y))
            p <- p + facet_wrap(~ ind, scales="free")
            p <- p + xlab("Standard normal quantiles") + ylab("Random effect quantiles")
        } else {  ## caterpillar dotplot
            p <- ggplot(pDf, aes(ID, y)) + coord_flip()
            if(likeDotplot) {  ## imitate dotplot() -> same scales for random effects
                p <- p + facet_wrap(~ ind)
            } else {           ## different scales for random effects
                p <- p + facet_grid(ind ~ ., scales="free_y")
            }
            p <- p + xlab("Levels") + ylab("Random effects")
        }

        p <- p + theme(legend.position="none")
        p <- p + geom_hline(yintercept=0)
        p <- p + geom_errorbar(aes(ymin=y-ci, ymax=y+ci), width=0, colour="black")
        p <- p + geom_point(aes(size=1.2), colour="blue") 
        return(p)
    }

    lapply(re, f)
}
-------------------------------------------------------------------------------------------------------
d$profile data ggplot d$ faceting facet_grid facet_wrap aes p = ggplot(d, aes(x=value, fill=category)) + geom_density(alpha=.3)
p + facet_grid(profile ~ .)
-------------------------------------------------------------------------------------------------------
expand.grid allow.cartesian = TRUE setkey(dt, "id", "wday")
vals <- c("mon", "tue", "wed", "thu", "fri", "sat", "sun")
idx <- expand.grid(vals, unique(dt$id))[, 2:1]
dt[J(idx), allow.cartesian=TRUE]

#     id wday val
#  1:  1  mon   2
#  2:  1  tue   3
#  3:  1  wed   5
#  4:  1  thu   8
#  5:  1  fri   6
#  6:  1  sat   2
#  7:  1  sun  NA
#  8:  2  mon   3
#  9:  2  tue   4
# 10:  2  wed  NA
# 11:  2  thu   2
# 12:  2  fri   6
# 13:  2  sat  NA
# 14:  2  sun  NA idx CJ dt[CJ(unique(dt$id),vals), allow.cartesian=TRUE]
-------------------------------------------------------------------------------------------------------
ggplot(df.2, aes(x=TAD, y=value, colour = variable)) + geom_line() + facet_grid(XID ~ FID, labeller=label_both) + labs(x = "TAD", y = "Response")
-------------------------------------------------------------------------------------------------------
expand.grid df.2 <- expand.grid(Date = unique(dates),Group = unique(groups))
df <- merge(df.1,df.2,all=TRUE)

aggregate(Cost ~ Group + Date, FUN=sum,  data=df, na.action=na.pass) aggregate Group       Date     Cost
1      X 2010-01-01 312.8357
2      Y 2010-01-01 295.7956
3      X 2010-01-08 283.1533
4      Y 2010-01-08       NA
5      X 2010-01-15 340.6775
6      Y 2010-01-15 309.2443
7      X 2010-01-22 263.6070
8      Y 2010-01-22 373.6912
9      X 2010-01-29 349.3823
10     Y 2010-01-29 240.6646
-------------------------------------------------------------------------------------------------------
cut() # I created an example i, j, and y rather than using your code for simplicity
df <- expand.grid(i=seq(0, 0.8, 0.1), j=seq(0, 1, 0.1))
y <- runif(dim(df)[1])

# define the colors you want
mycol <- c("green", "yellow", "red")

# define a color index based on y using the breaks you want
yindex <- cut(y, c(0, 0.25, 0.5, 1), labels=FALSE)

# scatterplot using the specified colors
plot(df$i, df$j, col=mycol[yindex])
-------------------------------------------------------------------------------------------------------
library(reshape2)
dat.long<-melt(dat,id.vars="time")
head(dat.long)
  time variable     value
1    0     surv 1.0000000
2    5     surv 0.9956140
3   11     surv 0.9824561
4   12     surv 0.9780702
5   13     surv 0.9692982
6   15     surv 0.9649123 subset() surv geom_step() nr geom_area() facet_grid() variable scales="free_y" ggplot()+geom_step(data=subset(dat.long,variable=="surv"),aes(time,value))+
  geom_area(data=subset(dat.long,variable=="nr"),aes(time,value))+
  facet_grid(variable~.,scales="free_y")
-------------------------------------------------------------------------------------------------------
try tryCatch for (p in ..)
    for (q in...)
  ...

  mod <- arima(x, c(p,d,q)) mod <- try(arima(x, c(p,d,q)), silent=TRUE)
 # the silent is optional pdq <- expand.grid(p, d, q)
 apply(pdq, 1, function(o) try(arima(x, o), silent=TRUE))
-------------------------------------------------------------------------------------------------------
subset stack gsub df <- expand.grid(
  "country" = c("A", "B"),
  "statistic" =  c("c", "d", "e", "f"),
  stringsAsFactors = FALSE)

df$year1980 <- rnorm(8)
df$year1990 <- rnorm(8)
df$year2000 <- rnorm(8)


getYears <- function(input, cntry, stat) {
  x <- subset(input, country == cntry & stat == statistic,
    select = -c(country, statistic))
  x <- stack(x)[,c("ind", "values")]
  x$ind <- gsub("\\D", "", x$ind)
  x
}


getYears(df, "A", "c")

   ind     values
1 1980  1.1421309
2 1990  1.0777974
3 2000 -0.2010913
-------------------------------------------------------------------------------------------------------
plot.default() panel.first ## Your example
plot(x=1, y=2, 
     panel.first={points(0, 0, pch=16, cex=1e6, col="grey90")
                  grid(col="white", lty=1)})

## Or, for repeated use, make it a function:
ggbg <- function() {
    points(0, 0, pch=16, cex=1e6, col="grey90")
    grid(col="white", lty=1)
}
plot(x=1, y=2, panel.first=ggbg()) ## Also works for plots running out to 1e300 in each direction
plot(x=-1e300, y=1e300, panel.first=ggbg())
-------------------------------------------------------------------------------------------------------
panel plot.zoo ax.date <-as.POSIXlt("2013-01-06")+(0:167)*3600 #Dummy date for POSIXlt method

my.panel <- function(x, y, ..., pf = parent.frame()) {
 grid(NA,NULL)
 abline(v=seq(1,168,24),col = "lightgray", lty = "dotted", lwd = par("lwd"))
 lines(x, y, ...)

 #if bottom panel
 if (with(pf, length(panel.number) == 0 ||
        panel.number %% nr == 0 || panel.number == nser)) {
      # create ticks at x values and then label every 24th tick
      axis(side = 1, at = x, labels = FALSE, tcl=-0.3) #hour ticks
      axis(side = 1, at = seq(1,168,6), labels = FALSE) #6hour ticks ticks
      axis(1,at=seq(1,168,24), labels=format(ax.date[seq(1,168,24)],"%a")) #day of the week
      axis(1,at=seq(13,168,24),labels=format(ax.date[seq(13,168,24)],"%H"), cex.axis=0.7) #noon ticks
   }
 }
 plot(z[,3:5], panel = my.panel,yax.flip=TRUE,col=1:3,xaxt="n")
-------------------------------------------------------------------------------------------------------
ggplot2 geom_pointrange library(ggplot2)
ggplot(data=a, aes(x     = factor(UID),
                   y     = NUMBER,
                   ymin  = Lower,
                   ymax  = Upper  )) +
  geom_pointrange() +
  facet_grid(PERIOD~.)
-------------------------------------------------------------------------------------------------------
> data(iris)
> tc <- trainControl("cv",10)
> rpart.grid <- expand.grid(.cp=0.2)
> 
> (train.rpart <- train(Species ~., data=iris, method="rpart",trControl=tc,tuneGrid=rpart.grid))
150 samples
  4 predictors
  3 classes: 'setosa', 'versicolor', 'virginica' 

No pre-processing
Resampling: Cross-Validation (10 fold) 

Summary of sample sizes: 135, 135, 135, 135, 135, 135, ... 

Resampling results

  Accuracy  Kappa  Accuracy SD  Kappa SD
  0.94      0.91   0.0798       0.12    

Tuning parameter 'cp' was held constant at a value of 0.2
-------------------------------------------------------------------------------------------------------
unique(do.call(c, apply(expand.grid(a,b,d), 1, combn, m=2, simplify=FALSE))) > L <- unique(do.call(c, apply(expand.grid(a,b,d), 1, combn, m=2, simplify=FALSE)))[1:5]
> length(L) ## 21
> L
## [[1]]
## Var1 Var2 
##  "a"  "d" 
## 
## [[2]]
## Var1 Var3 
##  "a"  "g" 
## 
## [[3]]
## Var2 Var3 
##  "d"  "g" 
## 
## [[4]]
## Var1 Var2 
##  "b"  "d" 
## 
## [[5]]
## Var1 Var3 
##  "b"  "g"
-------------------------------------------------------------------------------------------------------
facet_wrap facet_wrap(~ cut + color + clarity) clarity for(clarity in levels(diamonds$clarity))
{
  p <- qplot(carat, price, data = diamonds[diamonds$clarity == clarity, ]) + 
    facet_grid(cut ~ color)
  print(p)
} for l_ply(
  levels(diamonds$clarity),
  function(clarity)
  {
    qplot(carat, price, data = diamonds[diamonds$clarity == clarity, ]) + 
      facet_grid(cut ~ color)
  }
) ggsave
-------------------------------------------------------------------------------------------------------
facet_grid() melt
-------------------------------------------------------------------------------------------------------
base = qplot(carat, price, data = diamonds) + facet_grid(cut ~ color)
lp = dlply(diamonds, "clarity", `%+%`, e1 = base)

library(gridExtra)
do.call(grid.arrange, lp) # all in one page

# or multiple pages (with layout passed to grid.arrange)
all = do.call(marrangeGrob, c(lp, ncol=2, nrow=1))
ggsave("multipage.pdf", all, width=12)
-------------------------------------------------------------------------------------------------------
strwrap_strip_text = function(p, pad=0.05) { 
  # get facet font attributes
  th = theme_get()
  if (length(p$theme) > 0L)
    th = th + p$theme

  require("grid")
  grobs <- ggplotGrob(p)

  # wrap strip x text
  if ((class(p$facet)[1] == "grid" && !is.null(names(p$facet$cols))) ||
        class(p$facet)[1] == "wrap")
  {
    ps = calc_element("strip.text.x", th)[["size"]]
    family = calc_element("strip.text.x", th)[["family"]]
    face = calc_element("strip.text.x", th)[["face"]]

    if (class(p$facet)[1] == "wrap") {
      nm = names(p$facet$facets)
    } else {
      nm = names(p$facet$cols)
    }

    # get number of facet columns
    levs = levels(factor(p$data[[nm]]))
    npanels = length(levs)
    if (class(p$facet)[1] == "wrap") {
      cols = n2mfrow(npanels)[1]
    } else {
      cols = npanels
    }

    # get plot width
    sum = sum(sapply(grobs$width, function(x) convertWidth(x, "in")))
    panels_width = par("din")[1] - sum  # inches
    # determine strwrap width
    panel_width = panels_width / cols
    mx_ind = which.max(nchar(levs))
    char_width = strwidth(levs[mx_ind], units="inches", cex=ps / par("ps"), 
                          family=family, font=gpar(fontface=face)$font) / 
      nchar(levs[mx_ind])
    width = floor((panel_width - pad)/ char_width)  # characters

    # wrap facet text
    p$data[[nm]] = unlist(lapply(strwrap(p$data[[nm]], width=width, 
                                         simplify=FALSE), paste, collapse="\n"))
  }

  if (class(p$facet)[1] == "grid" && !is.null(names(p$facet$rows))) {  
    ps = calc_element("strip.text.y", th)[["size"]]
    family = calc_element("strip.text.y", th)[["family"]]
    face = calc_element("strip.text.y", th)[["face"]]

    nm = names(p$facet$rows)

    # get number of facet columns
    levs = levels(factor(p$data[[nm]]))
    rows = length(levs)

    # get plot height
    sum = sum(sapply(grobs$height, function(x) convertWidth(x, "in")))
    panels_height = par("din")[2] - sum  # inches
    # determine strwrap width
    panels_height = panels_height / rows
    mx_ind = which.max(nchar(levs))
    char_height = strwidth(levs[mx_ind], units="inches", cex=ps / par("ps"), 
                           family=family, font=gpar(fontface=face)$font) / 
      nchar(levs[mx_ind])
    width = floor((panels_height - pad)/ char_height)  # characters

    # wrap facet text
    p$data[[nm]] = unlist(lapply(strwrap(p$data[[nm]], width=width, 
                                         simplify=FALSE), paste, collapse="\n"))
  }

  invisible(p)
} print library(ggplot2)
df = expand.grid(group=paste(c("Very Very Very Long Group Name "), 1:4),
                 group1=paste(c("Very Very Very Long Group Name "), 5:8),
                 x=rnorm(5), y=rnorm(5), stringsAsFactors=FALSE)

p = ggplot(df) +
  geom_point(aes(x=x, y=y)) +
  facet_grid(group1~group)
strwrap_strip_text(p)
-------------------------------------------------------------------------------------------------------
facet_grid() subset facet_grid(. ~ subset) facet_grid()
-------------------------------------------------------------------------------------------------------
lattice library(lattice)
xyplot(V1+V2~time,groups=type,data=DT,type='l') ggplot2 library(reshape2)
dt.m <- melt(DT,measure.vars=c('V1','V2'))

ggplot(dt.m) +
 geom_line(aes(x=time,y=value,group=type,color=type)) +
  facet_grid(~variable)
-------------------------------------------------------------------------------------------------------
atan a = atan(y0/x0) * 215 / (pi/2) # Load the image
library(png)
library(RCurl)
d <- readPNG( getBinaryURL( "http://i.stack.imgur.com/rMR3C.png" ) )
image(d, col=gray(0:255/255))

# Origin for the polar coordinates
x0 <- ncol(d)/2
y0 <- nrow(d)/2

# The value of pixel (i,j) in the final image 
# comes from the pixel, in the original image, 
# with polar coordinates (r[i],theta[i]).
# We need a grid for the values of r and theta.
r <- 1:ceiling(sqrt( max(x0,nrow(d))^2 + max(y0,ncol(d))^2))
theta <- -pi/2 + seq(0,2*pi, length = 200)
r_theta <- expand.grid(r=r, theta=theta)

# Convert those polar coordinates to cartesian coordinates:
x <- with( r_theta, x0 + r * cos(theta) )
y <- with( r_theta, y0 + r * sin(theta) )
# Truncate them
x <- pmin( pmax( x, 1 ), ncol(d) )
y <- pmin( pmax( y, 1 ), nrow(d) )

# Build an empty matrix with the desired size and populate it
r <- matrix(NA, nrow=length(r), ncol=length(theta))
r[] <- d[cbind(x,y)]
image(r, col=gray(0:255/255))
-------------------------------------------------------------------------------------------------------
xVariables<-names(data[,1:3])
yVariables<-names(data[,4:6]) expand.grid() gg<-expand.grid(xVariables,yVariables)
gg<-data.frame(lapply(gg, as.character), stringsAsFactors=FALSE) apply() aes_string() apply(gg,1,function(x) ggplot(data,aes_string(x=x[1],y=x[2]))+geom_boxplot())
-------------------------------------------------------------------------------------------------------
aes_string() ggplot() x.variable y.variable print() ggplot() makeScatterplots <- function(dataframe,x.variable, y.variable, my.factor){
  print(ggplot(dataframe, aes_string(x=x.variable,y= y.variable, 
                     group=my.factor, colour=my.factor)) + geom_point())  
}

makeScatterplots(data,"length","width","age") makeScatterplots <- function(dataframe,x.variable, y.variable, my.factor){
  gg<-expand.grid(x.variable,y.variable,my.factor)
  gg<-data.frame(lapply(gg, as.character), stringsAsFactors=FALSE)
  apply(gg,1,function(x) ggplot(data,aes_string(x=x[1],y=x[2],color=x[3]))+geom_point())
}
-------------------------------------------------------------------------------------------------------
ans <- with(dat, tapply(obs, list(catA, catB, catC), mean))
ans <- data.frame(expand.grid(dimnames(ans)), results=c(ans))
names(ans)[1:3] <- names(dat)[1:3]

str(ans)
# 'data.frame':  36 obs. of  4 variables:
#  $ catA   : Factor w/ 3 levels "a","b","c": 1 2 3 1 2 3 1 2 3 1 ...
#  $ catB   : Factor w/ 4 levels "1","2","3","4": 1 1 1 2 2 2 3 3 3 4 ...
#  $ catC   : Factor w/ 3 levels "d","e","f": 1 1 1 1 1 1 1 1 1 1 ...
#  $ results: num  69.7 NA NA 55.3 NA ...
-------------------------------------------------------------------------------------------------------
data(litter)
mod <- ancova(weight ~ gesttime + dose, data=litter)
pred <- predict(mod) ggplot(data = cbind(litter, pred),
    aes(gesttime, weight, color=dose)) + geom_point() +
    facet_grid(. ~ dose) + geom_line(aes(y=pred))
-------------------------------------------------------------------------------------------------------
daisy() distff <- function(training.data, nblocks=5, verbose=TRUE)
{
require(ff)
require(cluster)
ffmat <- ff(vmode="single", dim=c(7000,7000), filename="if so desired")
nro <- nrow(training.data)
###This could be changed to handle rowcounts that have modulus(nro/nblocks) != 0
splt <- split(1:nro, rep(1:nblocks, each = nro/nblocks))
COMBS <- expand.grid(1:length(splt), 1:length(splt)) 
COMBS <- t(apply(COMBS, 1, sort)) 
COMBS <- unique(COMBS) 
for (i in 1:nrow(COMBS)) {
COMB <- COMBS[i,]
###Since g1 and g2 get appended below, it wouldn't make sense to append the same group to itself
if (COMB[1] != COMB[2]) {
g1 <- splt[[COMB[1]]]
    g2 <- splt[[COMB[2]]]
    slj <- as.matrix(daisy(training.data[c(g1,g2),], metric="gower", stand=FALSE))
    ffmat[c(g1,g2), c(g1,g2)] <- slj
    rm(slj)
    gc()
    }
}
-------------------------------------------------------------------------------------------------------
inputs <- function(){

   xvar <- tclVar("")
   yvar <- tclVar("")

   tt <- tktoplevel()
   tkwm.title(tt,"Input Numbers")
   x.entry <- tkentry(tt, textvariable=xvar)
   y.entry <- tkentry(tt, textvariable=yvar)

   reset <- function()
    {
     tclvalue(xvar)<-""
     tclvalue(yvar)<-""
    }

   reset.but <- tkbutton(tt, text="Reset", command=reset)

   submit <- function() {
     x <- as.numeric(tclvalue(xvar))
     y <- as.numeric(tclvalue(yvar))
     e <- parent.env(environment())
     e$x <- x
     e$y <- y
     tkdestroy(tt)
   }
   submit.but <- tkbutton(tt, text="submit", command=submit)

   tkgrid(tklabel(tt,text="Enter Two Inputs"),columnspan=2)
   tkgrid(tklabel(tt,text="Input1"), x.entry, pady = 10, padx =10)
   tkgrid(tklabel(tt,text="Input2"), y.entry, pady = 10, padx =10)
   tkgrid(submit.but, reset.but)

  tkwait.window(tt)
  return(c(x,y))
} myvals <- inputs() myvals
-------------------------------------------------------------------------------------------------------
setkey(dt, time, sid, s.c)
dt[J(expand.grid(unique(time),unique(sid),unique(s.c)))][order(time, sid, s.c)]
#                   time     sid   s.c  count
# 1: 2013-05-25 10:00:00 missing CLICK 104192
# 2: 2013-05-25 10:00:00 missing SHARE   7694
# 3: 2013-05-25 10:00:00 present CLICK  99573
# 4: 2013-05-25 10:00:00 present SHARE  89302
# 5: 2013-05-25 11:00:00 missing CLICK     28
# 6: 2013-05-25 11:00:00 missing SHARE     NA
# 7: 2013-05-25 11:00:00 present CLICK     25
# 8: 2013-05-25 11:00:00 present SHARE     15
# 9: 2013-05-25 12:00:00 missing CLICK 104544
#10: 2013-05-25 12:00:00 missing SHARE   7253
#11: 2013-05-25 12:00:00 present CLICK 105891
#12: 2013-05-25 12:00:00 present SHARE  88709
-------------------------------------------------------------------------------------------------------
facet_grid(Y~X) facet_wrap d1$X <- ifelse(d1$x<0.5,'d1.L','d1.R') 
d2$Y <- ifelse(d2$x<0.5,'d2.L','d2.R') r = ggplot() +
  geom_point(data=d1, aes(x=x, y=y),col='blue',size=10) +
  geom_point(data=d2, aes(x=x, y=y))+
  facet_grid(Y~X,scales="free")+
  theme(strip.text = element_text(size=20))
-------------------------------------------------------------------------------------------------------
p <- ggplot(mdf[as.numeric(mdf$milieu) < 6,], aes(x = variable, y = value)) +
  geom_line(data = transform(mdf, milieu = NULL), aes(group = y), 
            colour = 'grey80') +
  geom_line(data = meandf[as.numeric(meandf$milieu) < 6,], 
            aes(x = variable, y = value, group = milieu),
            colour = 'grey50') +
  geom_line(aes(group = milieu, colour=mycols), size=1) +
  scale_colour_identity() +
  facet_grid(milieu~.) +
  theme(axis.text.x = element_text(angle=90, hjust=1)) +
  theme(legend.position = 'none') +
  scale_y_continuous('') +
  xlab('')

print(p)
-------------------------------------------------------------------------------------------------------
Ex<-structure(list(X1 = c(-36.8598, -37.1726, -36.4343, -36.8644, 
-37.0599, -34.8818, -31.9907, -37.8304, -34.3367, -31.2984, -33.5731
), X2 = c(64.26, 63.085, 66.36, 61.08, 61.57, 65.04, 72.69, 63.83, 
67.555, 76.06, 68.61), Y1 = c(493.81544, 493.81544, 494.54173, 
494.61364, 494.61381, 494.38717, 494.64122, 493.73265, 494.04246, 
494.92989, 494.98384), Y2 = c(489.704166, 489.704166, 490.710962, 
490.653212, 490.710612, 489.822928, 488.160904, 489.747776, 490.600579, 
488.946738, 490.398958), Y3 = c(-19L, -19L, -19L, -23L, -30L, 
-43L, -43L, -2L, -58L, -47L, -61L)), .Names = c("X1", "X2", "Y1", 
"Y2", "Y3"), row.names = c(NA, 11L), class = "data.frame")


library(reshape2)
library(ggplot2)
Ex2<-melt(Ex,id=c("X1","X2"))
colnames(Ex2)[3:4]<-c("Y","Yvalue")
Ex3<-melt(Ex2,id=c("Y","Yvalue"))
colnames(Ex3)[3:4]<-c("X","Xvalue")

ggplot(Ex3,aes(Xvalue,Yvalue))+
          geom_smooth(method="lm",alpha=0.2,size=1,color="grey")+
          geom_point(size=2)+
          facet_grid(Y~X,scales='free')


#Use the lmp function

lmp <- function (modelobject) {
  if (class(modelobject) != "lm") stop("Not an object of class 'lm' ")
  f <- summary(modelobject)$fstatistic
    p <- pf(f[1],f[2],f[3],lower.tail=F)
    attributes(p) <- NULL
    return(p)
    }

# create function to extract different informations from lm

lmtable<-function (var1,var2,data,signi=NULL){
  #var1= y data : colnames of data as.character, so "Y1" or c("Y1","Y2") for example
  #var2= x data : colnames of data as.character, so "X1" or c("X1","X2") for example
  #data= data in dataframe, variables in columns
  # if signi TRUE, round p-value with 2 digits and add *** if <0.001, ** if < 0.01, * if < 0.05.

  if (class(data) != "data.frame") stop("Not an object of class 'data.frame' ")
  Tabtemp<-data.frame(matrix(NA,ncol=6,nrow=length(var1)*length(var2)))
  for (i in 1:length(var2))
       {
  Tabtemp[((length(var1)*i)-(length(var1)-1)):(length(var1)*i),1]<-var1
  Tabtemp[((length(var1)*i)-(length(var1)-1)):(length(var1)*i),2]<-var2[i]
  colnames(Tabtemp)<-c("Var.y","Var.x","p-value","a","b","r^2")

  for (n in 1:length(var1))
  {
  Tabtemp[(((length(var1)*i)-(length(var1)-1))+n-1),3]<-lmp(lm(data[,var1[n]]~data[,var2[i]],data))

  Tabtemp[(((length(var1)*i)-(length(var1)-1))+n-1),4]<-coef(lm(data[,var1[n]]~data[,var2[i]],data))[1]

  Tabtemp[(((length(var1)*i)-(length(var1)-1))+n-1),5]<-coef(lm(data[,var1[n]]~data[,var2[i]],data))[2]

  Tabtemp[(((length(var1)*i)-(length(var1)-1))+n-1),6]<-summary(lm(data[,var1[n]]~data[,var2[i]],data))$r.squared
  }
  }

  signi2<-data.frame(matrix(NA,ncol=3,nrow=nrow(Tabtemp)))
  signi2[,1]<-ifelse(Tabtemp[,3]<0.001,paste0("***"),ifelse(Tabtemp[,3]<0.01,paste0("**"),ifelse(Tabtemp[,3]<0.05,paste0("*"),paste0(""))))
  signi2[,2]<-round(Tabtemp[,3],2)
  signi2[,3]<-paste0(format(signi2[,2],digits=2),signi2[,1])

  for (l in 1:nrow(Tabtemp))
    {
  Tabtemp$"p-value"[l]<-ifelse(is.null(signi),
         Tabtemp$"p-value"[l],
         ifelse(isTRUE(signi),
                paste0(signi2[,3][l]),
                Tabtemp$"p-value"[l]))
  }

   Tabtemp
}

# ------- EXAMPLES ------

lmtable("Y1","X1",Ex)
lmtable(c("Y1","Y2","Y3"),c("X1","X2"),Ex)
lmtable(c("Y1","Y2","Y3"),c("X1","X2"),Ex,signi=TRUE)
-------------------------------------------------------------------------------------------------------
scales="free_x" facet_grid() space="free_x" ggplot(sample, aes(category, count)) + geom_bar() + 
  facet_grid(. ~ parent_id,scale="free_x",space="free_x")
-------------------------------------------------------------------------------------------------------
geom_rect() facet_grid() geom_text() df.text + geom_rect(data=df.text,aes(xmin=-Inf,xmax=Inf,ymin=-Inf,ymax=Inf),
        fill="white",inherit.aes=FALSE)
-------------------------------------------------------------------------------------------------------
library(ggplot2)

d <- data.frame(x=1:10, y=1:10, f=gl(2,5, labels=c("FOO","BLAH")))

make_label <- function(value)
  bquote(group("|",A['i,j'],"|"):.(value))

plot_labeller <- function(variable,value){
  print(value)
  if(variable=='f')
    do.call(expression, lapply(levels(value)[value], make_label)) else "other"
}

qplot(x,y,data=d) + facet_grid(.~f, labeller=plot_labeller)
-------------------------------------------------------------------------------------------------------
M_xx G_xx S_xx Q_xx M <- NULL

for(M_P in 0:9) for(M_D in 0:(9-M_P)) for(M_A in 0:(9-M_P-M_D)) for(M_CC in 0:(9-M_P-M_D-M_A)) for(M_CD in (9-M_P-M_D-M_A-M_CC))
{
    M[length(M)+1] <- 1.1*M_P+2.1*M_D+3.1*M_A+4.1*M_CC+4*M_CD
}

G <- NULL

for(G_D in 0:9) for(G_A in 0:(9-G_D)) for(G_CC in 0:(9-G_D-G_A)) for(G_CD in (9-G_D-G_A-G_CC))
{
    G[length(G)+1] <- 2*G_D+5*G_A+1.5*G_CC+3*G_CD
}

S <- NULL

for(S_D in 0:9) for(S_A in 0:(9-S_D)) for(S_CC in 0:(9-S_D-S_A)) for(S_CD in (9-S_D-S_A-S_CC))
{
    S[length(S)+1] <- 5*S_D+4*S_A+3*S_CC+6*S_CD
}

Q <- NULL

for(Q_P in 0:3) for(Q_D in 0:(3-Q_P)) for(Q_A in 0:(3-Q_P-Q_D)) for(Q_CC in 0:(3-Q_P-Q_D-Q_A)) for(Q_CD in (3-Q_P-Q_D-Q_A-Q_CC))
{
    Q[length(Q)+1] <- 2*Q_P+3*Q_D+2.2*Q_A+3*Q_CC+4*Q_CD
}

max(apply(expand.grid(unique(M), unique(G), unique(S), unique(Q)), 1, sum))
-------------------------------------------------------------------------------------------------------
Dataset1 <- data.frame(ax=1:2,ay=3:4)
Dataset2 <- data.frame(bx=5:6,by=7:8)

apply(
    expand.grid(seq_along(Dataset1),seq_along(Dataset2)),
    1,
    function(x) cbind(Dataset1[x[1]],Dataset2[x[2]])
     ) [[1]]
  ax bx
1  1  5
2  2  6

[[2]]
  ay bx
1  3  5
2  4  6

[[3]]
  ax by
1  1  7
2  2  8

[[4]]
  ay by
1  3  7
2  4  8
-------------------------------------------------------------------------------------------------------
y = do.call('c', lapply(z, function(x) ifelse(x == d, seq_along(d), 0)))
[1] 1 0 3 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0 0 0 0 expand.grid df = data.frame(expand.grid(d = d, z = z, stringsAsFactors = FALSE), 
                y = rep(seq_along(d), length(z)))
with(df, ifelse(z == d, y, 0))
-------------------------------------------------------------------------------------------------------
as.vector( t( x ) )
# [1]  4  8  2  6  5  4  6  3  9 13 expand.grid #  The data
y <-  as.vector( t( x ) )

#  Combinations of row and column names
nms <- expand.grid( colnames(x) , rownames(x)  )  

# Rename vector with desired names
names(y) <- paste0( nms[,2] , nms[,1] )

#AX AY BX BY CX CY DX DY EX EY 
# 4  8  2  6  5  4  6  3  9 13
-------------------------------------------------------------------------------------------------------
db <- data.frame(
  c(rep("A", 4), rep("B", 2), rep("C", 5), rep("D", 6), rep("E", 9), 
    rep("A", 8), rep("B", 6), rep("C", 4), rep("D", 3), rep("E", 13)),
  c(rep("X", 26), rep("Y", 34)),
  stringsAsFactors = FALSE)

tab <- table(db[,1],db[,2]) array(tab, dimnames = list(do.call("paste0", expand.grid(dimnames(tab)))))
AX BX CX DX EX AY BY CY DY EY 
 4  2  5  6  9  8  6  4  3 13
-------------------------------------------------------------------------------------------------------
expand grid apply(expand.grid(initial_consonants, vowels, final_consonants), 1, function(x)create_CVC_words(x[1], x[2], x[3]))
-------------------------------------------------------------------------------------------------------
do.call(paste0, expand.grid(initial_consonants, vowels, final_consonants))
-------------------------------------------------------------------------------------------------------
library(rugarch)
data(sp500ret)
spec <- ugarchspec(distribution.model = "std")
mod <- ugarchroll(spec, data = sp500ret[1:2000,], n.ahead = 1, 
                 n.start = 1000,  refit.every = 100, refit.window = "moving", 
                 solver = "hybrid", fit.control = list(),
                 calculate.VaR = TRUE, VaR.alpha = c(0.01, 0.025, 0.05),
                 keep.coef = TRUE) plot(mod, which = 5) getMethod("plot", c(x = "uGARCHroll", y = "missing")) .intergarchrollPlot(x, choices = choices, plotFUN = paste(".plot.garchroll", 
            1:5, sep = "."), which = which, VaR.alpha = VaR.alpha, 
            density.support = density.support, ...) choices "Fit Coefficients (with s.e. bands)" rugarch:::.intergarchrollPlot rugarch:::.plot.garchroll.5 library(xts)
x <- mod
vmodel = x@model$spec@model$modeldesc$vmodel
if (!x@model$keep.coef) 
  stop("\n\nplot-->error: keep.coef set to FALSE in estimation\n")
coefs = x@model$coef
m = dim(coefs[[1]]$coef)[1]
N = length(coefs)
Z = matrix(NA, ncol = m, nrow = N)
Zup = matrix(NA, ncol = m, nrow = N)
Zdn = matrix(NA, ncol = m, nrow = N)
for (i in 1:m) {
  Z[, i] = sapply(coefs, FUN = function(y) y$coef[i, 1])
  Zup[, i] = Z[, i] + sapply(coefs, FUN = function(y) y$coef[i, 
                                                             2])
  Zdn[, i] = Z[, i] - sapply(coefs, FUN = function(y) y$coef[i, 
                                                             2])
}
dt = sapply(coefs, FUN = function(y) as.character(y$index))
cnames = rownames(coefs[[1]]$coef)
np = rugarch:::.divisortable(m) # added rugarch::: i plotFun <- function(i){
  plot(xts(Z[, i], as.POSIXct(dt)), type = "l", 
       ylim = c(min(Zdn[, i]), max(Zup[, i])), ylab = "value", xlab = "", main = "", 
       minor.ticks = FALSE, ann = FALSE, auto.grid = FALSE)
  lines(xts(Zdn[, i], as.POSIXct(dt)), col = 2)
  lines(xts(Zup[, i], as.POSIXct(dt)), col = 2)
  title(cnames[i], line = 0.4, cex = 0.9)
  grid()
} plotFun(1)
plotFun(2)
-------------------------------------------------------------------------------------------------------
runForAll <- function(x) {
  emboss <- read.table(x,header=T)
  x <- table(emboss[,2],emboss[,3])/NROW(emboss[,3])
  y <- as.vector(t(x))
  nms <- expand.grid(colnames(x), rownames(x))
  names(y) <- paste( nms[,2],nms[,1],sep="")
  return(t(y))
}

my.files <- list.files(pattern = ".ss")
outputs <- lapply(my.files, FUN = runForAll)   

library(plyr)
one.header.output <- rbind.fill.matrix(outputs)
write.table(one.header.output, file = "nontpsec.csv") R CMD
-------------------------------------------------------------------------------------------------------
library(ggplot2)
d.405 <- data.frame(abs(rnorm(30)),abs(rnorm(30)),abs(rnorm(30)),abs(rnorm(30)),type="405")
d.409 <- data.frame(abs(rnorm(30)),abs(rnorm(30)),abs(rnorm(30)),abs(rnorm(30)),type="409")
all <- rbind(d.405,d.409)
colnames(all) <- c("401","402","403","404","type")

library("reshape2");
allM <- melt(all, id.vars = "type")


combis <- expand.grid(levels(allM$variable),levels(allM$variable))

plotdat <- lapply(seq_len(nrow(combis)),function(i) cbind(allM[allM$variable==combis[i,1] & allM$type=="405",],
                                               allM[allM$variable==combis[i,2] & allM$type=="409",c("type","variable","value")]))
plotdat <- do.call(rbind,plotdat)
names(plotdat) <- c("type.x","var.x","x","type.y","var.y","y")
plotdat$var.x <- paste("x:",plotdat$var.x)
plotdat$var.y <- paste("y:",plotdat$var.y)

library(plyr)
cors <- ddply(plotdat,.(var.x,var.y),summarize,cor=format(signif(cor(x,y),2),scientific=-2))
cors$x <- 2.2
cors$y <- 2.5

p <- ggplot(plotdat,aes(x=x,y=y)) + 
  geom_point() + 
  geom_smooth(method="lm") +
  geom_text(data=cors,aes(label=paste("r =",cor))) +
  facet_wrap(~var.y*var.x,ncol=4) +
  xlab("405") + ylab("409")


print(p)
-------------------------------------------------------------------------------------------------------
require(ffbase)
x <- ffseq(1, 10000)
y <- ff(factor(LETTERS))
allcombinations <- expand.ffgrid(x, y)
addme <- data.frame(Var1 = c(1, 2), Var2 = c("A","B"), measure = rnorm(2))
addme <- as.ffdf(addme)
myffdf <- merge(allcombinations, addme, by.x=c("Var1","Var2"), by.y=c("Var1","Var2"),  all.x=TRUE)
myffdf[1:10,]
-------------------------------------------------------------------------------------------------------
facet_grid() Description scales="free_y" space="free_y" Description ggplot(GO_sum.m, aes(variable, Gene)) + 
   geom_tile(aes(fill = value), colour = "white") + 
   scale_fill_gradient2(low = "darkred", high = "darkblue", guide="colorbar")+
   facet_grid(Description~.,scales="free_y",space="free_y")
-------------------------------------------------------------------------------------------------------
expand.grid sort(apply(X = expand.grid(x, y), MARGIN = 1, FUN = function(x) paste(x[1], x[2], sep = " ")))
-------------------------------------------------------------------------------------------------------
# Assuming the grid is always a square grid.

grid.size <- 20

# The matrix of row indices.

rindex.grid <- matrix(1:(grid.size * grid.size),
                  nrow=grid.size, ncol=grid.size, byrow=TRUE)

# We can traverse the grid by moving any given square either right or down in any 
# single  move. We choose to go right.

move.square.right <- function (this.square, steps=1) {
  new.square <- this.square + steps
}

# Going right, capture co-ordinates of all squares in this row.

collect.sq.of.edge.length.in.row.number <- function (grid.size, elength,
                                                    rownum=1) {
  first.square.in.row <- (rownum - 1) * grid.size + c(1, elength)
  first.square.in.row <- c(first.square.in.row,
                          first.square.in.row + grid.size * (elength - 1))
  squares.in.row <- t(sapply(X=seq_len(grid.size - (elength - 1)) - 1,
                            FUN=move.square.right,
                            this.square=first.square.in.row))
  squares.in.row
}

# Now we start going down the columns and using the function above to collect
# squares in each row. The we will rbind the list of squares in each row into a
# dataframe. So what we get is a (grid.size - (elength - 1) ^ 2) x 4 matrix where
# each row is the co-ordinates of a square of edge length elength.

collect.sq.of.edge.length.in.grid <- function (grid.size, elength) {
  all.squares=lapply(X=seq_len(grid.size - (elength - 1)),
          FUN=collect.sq.of.edge.length.in.row.number,
          grid.size=grid.size, elength=elength)
  all.squares <- do.call(rbind, all.squares)
  all.squares
} tmp <- sapply(1:20, collect.sq.of.edge.length.in.grid, grid.size=grid.size)
sapply(tt, nrow)

[1] 400 361 324 289 256 225 196 169 144 121 100  81  64  49  36  25  16   9   4   1 collect.sq.of.edge.length.in.grid(grid.size=3, elength=2)

     [,1] [,2] [,3] [,4]
[1,]    1    2    4    5
[2,]    2    3    5    6
[3,]    4    5    7    8
[4,]    5    6    8    9
-------------------------------------------------------------------------------------------------------
library(ggplot2)
 labeli <- function(variable, value){
  names_li <- list("versicolor"="versi", "virginica"="virg")
  return(names_li[value])
 }

 dat <- subset(iris,Species!="setosa")
 ggplot(dat, aes(Petal.Length)) + stat_bin() + facet_grid(Species ~ ., labeller=labeli) labeli2 <- function(variable, value){
  value <- droplevels(value)
  names_li <- list("versicolor"="versi", "virginica"="virg")
  return(names_li[value])
}

dat <- subset(iris,Species!="setosa")
ggplot(dat, aes(Petal.Length)) + stat_bin() + facet_grid(Species ~ ., labeller=labeli2)
-------------------------------------------------------------------------------------------------------
Bush$grp <- rep(c('a','b'),times = c(16,3)) facet_grid(.~ grp, scales="free_x") mean_df <- data.frame(grp = c('a','b'),
                      yint = with(Bush,c(mean(DIS[1:16]),mean(DIS[17:19])))) geom_hline yintercept yint geom_hline(data = mean_df,aes(yintercept = yint),colour = "blue")
-------------------------------------------------------------------------------------------------------
expand scale_y_continuous ggplot(test, aes(x=YEAR, y=(value), fill=variable)) +
   labs(title="Test", x=NULL, y="Total", fill=NULL) + 
   geom_bar(stat="identity"), position="stack") + 
   facet_grid(variable ~., scales="free") +
   theme(legend.position = "none") + 
   geom_text(aes(x=YEAR, y=(value), label=value), size=3)+
   scale_y_continuous( expand = c( 0.05 , 0.05 ) ) scale_y_discrete( expand = c( 0.05 , 0.05 ) ) mm <- ddply(mtcars, "cyl", summarise, mmpg = mean(mpg))
ggplot(mm, aes(x = factor(cyl), y = mmpg , fill = factor(cyl))) + 
  geom_bar(stat = "identity") +
  geom_text( aes( label=c("RED","GREEN","BLUE" ) ), size = 15 )+
  scale_y_continuous( expand = c(0.5,0.5) )
-------------------------------------------------------------------------------------------------------
require(lattice)

# begin generating my 3D shape
b <- seq(from=0, to=20,by=0.5)
s <- seq(from=0, to=20,by=0.5)
payoff <- expand.grid(b=b,s=s)
payoff$payoff <- payoff$b - payoff$s
payoff$payoff[payoff$payoff < -1] <- -1
# end generating my 3D shape


wireframe(payoff ~ s * b, payoff, shade = TRUE, aspect = c(1, 1),
    light.source = c(10,10,10), main = "Study 1",
    scales = list(z.ticks=5,arrows=FALSE, col="black", font=10, tck=0.5),
    screen = list(z = 40, x = -75, y = 0))
-------------------------------------------------------------------------------------------------------
x <- c("a", "b")
y <- c("c", "d")

do.call(paste0, expand.grid(x, y))
# [1] "ac" "bc" "ad" "bd" outer x y z <- c("e", "f")

do.call(paste0, expand.grid(x, y, z))
# [1] "ace" "bce" "ade" "bde" "acf" "bcf" "adf" "bdf"
-------------------------------------------------------------------------------------------------------
x1 x2 x3 x4 x5 y
 0  0  0  0  0 *
 0  0  0  0  0 *
 ...

 1  0  0  0  0 *
 1  0  0  0  0 *
 ...

 0  1  0  0  0 *
 0  1  0  0  0 *
 ... df <- expand.grid(1:500, x1=0:1, x2=0:1, x3=0:1, x4=0:1, x5=0:1)[, -1]
-------------------------------------------------------------------------------------------------------
expand.grid df1 <- data.frame(topstate=c("CA","TX","NJ","FL","NY"))
df2 <- data.frame(state=c("AB","AE"))
result <- expand.grid(topstate=unique(df1$topstate),state=unique(df2$state))
result

   topstate state
1        CA    AB
2        TX    AB
3        NJ    AB
4        FL    AB
5        NY    AB
6        CA    AE
7        TX    AE
8        NJ    AE
9        FL    AE
10       NY    AE
-------------------------------------------------------------------------------------------------------
tab <- expand.grid(gene=letters[1:2], SNP=LETTERS[1:3])
tab$minus_logpval <- abs(rnorm(6))*-1
tab <- tab[do.call("order", tab),]
tab$SNP <- as.character(tab$SNP)
with(tab, tapply(minus_logpval, gene, function(x) SNP[which.max(x)]))
-------------------------------------------------------------------------------------------------------
NA df1$variable == ?"==" NA NA TRUE FALSE NA df1 <- expand.grid(variable=c(0, 1, NA), var2=c(0, 1, NA))

sel1 <- !(df1$variable==1)
sel1
df1[sel1, ]

sel2 <- df1$variable==0 | is.na(df1$variable)
sel2
df1[sel2, ]
-------------------------------------------------------------------------------------------------------
clu.pairs <- function(k, row)
{
    w <- which(row==k)

    expand.grid(w, w)
}

row.pairs <- function(row)
{
    do.call(rbind, lapply(unique(row), function(k) clu.pairs(k, row)))
}

full.pairs <- function(data)
{
    do.call(rbind, lapply(seq_len(nrow(data)), function(i) row.pairs(data[i,])))
} full.pairs(testData)
-------------------------------------------------------------------------------------------------------
x = c(1,4,5,8,9)
x2 <- as.matrix(expand.grid(x, x))
x2 <- as.data.frame(t(apply(x2, 1, sort)))
x2 <- x2[!duplicated(x2), ]
x2 <- cbind(x2, d =abs(mapply("-", x2[,1], x2[,2])))
x2[order(x2$d), ]
# V1 V2 d
# 1   1  1 0
# 7   4  4 0
# 13  5  5 0
# 19  8  8 0
# 25  9  9 0
# 8   4  5 1
# 20  8  9 1
# 2   1  4 3
# 14  5  8 3
# 3   1  5 4
# 9   4  8 4
# 15  5  9 4
# 10  4  9 5
# 4   1  8 7
# 5   1  9 8
-------------------------------------------------------------------------------------------------------
som.prep.df som.prep.df <- function(som.model, obs.classes, scaled) {
  require(reshape2)
  lev <- factor(wine.classes)
  df <- data.frame(cbind(unit=som.model$unit.classif, class=as.integer(lev)))
  # create table
  df2 <- data.frame(table(df))
  df2 <- dcast(df2, unit ~ class, value.var="Freq")
  df2$unit <- as.integer(df2$unit)
  # calc sum
  df2$sum <- rowSums(df2[,-1])
  # calc fraction borders of classes in each node
  tmp <- data.frame(cbind(X0=rep(0,nrow(df2)), 
                          t(apply(df2[,-1], 1, function(x) {
                            cumsum(x[1:(length(x)-1)]) / x[length(x)]
                          }))))
  df2 <- cbind(df2, tmp)
  df2 <- melt(df2, id.vars=which(!grepl("^\\d$", colnames(df2))))
  df2 <- df2[,-ncol(df2)]
  # define border for each classs in each node
  tmp <- t(apply(df2, 1, function(x) {
    c(x[paste0("X", as.character(as.integer(x["variable"])-1))], 
      x[paste0("X", as.character(x["variable"]))])
  }))
  tmp <- data.frame(tmp, stringsAsFactors=FALSE)
  tmp <- sapply(tmp, as.numeric)
  colnames(tmp) <- c("ymin", "ymax")
  df2 <- cbind(df2, tmp)
  # scale size of pie charts
  if (is.logical(scaled)) {
    if (scaled) {
      df2$xmax <- log2(df2$sum)
    } else {
      df2$xmax <- df2$sum
    }
  }
  df2 <- df2[,c("unit", "variable", "ymin", "ymax", "xmax")]
  colnames(df2) <- c("unit", "class", "ymin", "ymax", "xmax")
  # replace classes with original levels names
  df2$class <- levels(lev)[df2$class]
  return(df2)
}

som.draw <- function(som.model, obs.classes, scaled=FALSE) {
  # scaled - make or not a logarithmic scaling of the size of each node
  require(ggplot2)
  require(grid)
  g <- som.model$grid
  df <- som.prep.df(som.model, obs.classes, scaled)
  df <- cbind(g$pts, df[,-1])
  df$class <- factor(df$class)
  g <- ggplot(df, aes(fill=class, ymax=ymax, ymin=ymin, xmax=xmax, xmin=0)) +
    geom_rect() +
    coord_polar(theta="y") +
    facet_wrap(x~y, ncol=g$xdim, nrow=g$ydim) + 
    theme(axis.ticks = element_blank(), 
          axis.text.y = element_blank(),
          axis.text.x = element_blank(),
          panel.margin = unit(0, "cm"),
          strip.background = element_blank(),
          strip.text = element_blank(),
          plot.margin = unit(c(0,0,0,0), "cm"),
          panel.background = element_blank(),
          panel.grid = element_blank())
  return(g)
} require(kohonen)
data(wines)
som.wines <- som(scale(wines), grid = somgrid(5, 5, "rectangular"))

# Non-scaled map
som.draw(som.wines, wine.classes) # Scaled map
som.draw(som.wines, wine.classes, TRUE)
-------------------------------------------------------------------------------------------------------
Mutation pos2 cumsum() diff() position df2<-df[order(df$Mutation),]
df2$pos2<-cumsum(c(0,diff(df2$position)) != 0)
df2
  position Mutation  difference difference_std pos2
3       99     A99H -0.22949999    0.240179571    0
4       99     A99S -0.45171049    0.001381697    0
7      103    D103Y  0.66920000    0.073128153    1
5      101    G101S  0.53151109    0.084838109    2
6      102    P102S -0.04872141    0.028908203    3
1       97     R97L -0.31748485    0.286747763    4
2       97     R97N  0.53339566    0.352321704    4 pos2 theme() strip.text= strip.background= ggplot(df2,aes(x=Mutation,y=difference) ) +
  geom_bar( width=.75,aes(fill=as.factor(position),
                   stat="identity"),position="dodge") +
  geom_errorbar(aes(y=difference, ymin=difference-difference_std,  
                   ymax=difference+difference_std )) +
  theme(legend.key = element_blank()) +
  ylim(-2.5,2.5) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90,size=9,hjust=1))+
  theme(legend.position="none")+
  theme(strip.text=element_blank(),
        strip.background=element_blank())+
  facet_grid(.~pos2,scales="free_x",space="free_x") scale_x_discrete() limits= ggplot(df2,aes(x=Mutation,y=difference) ) +
  geom_bar( width=.75,aes(fill=as.factor(position),
           stat="identity"),position="dodge") +
  geom_errorbar(aes(y=difference, ymin=difference-difference_std, 
            ymax=difference+difference_std )) +
  theme(legend.key = element_blank()) +
  ylim(-2.5,2.5) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90,size=9,hjust=1))+
  theme(legend.position="none")+
  scale_x_discrete(limits=c("A99H", "A99S","", "D103Y","","G101S",
                             "","P102S","","R97L", "R97N"))
-------------------------------------------------------------------------------------------------------
expand.grid HM ifelse if HM2 <- function(CO,CS,CD,CSD)
{
    den <- 2^CO-2^CSD

    ifelse(CO-CS>1, 2^CS/den,
        ifelse(CO-CD>1, 1-2^CD/den, 0))
} den CO <- c(25.76031685, 25.71126747, 25.90163231)
CS <- c(24.40528297, 24.09929848, 23.51999092)
CD <- c(25.99405861, 25.72906113, 25.61374474)
CSD <- c(35.94195557, 36.07263184, 34.00024414) cmbs <- expand.grid(CO, CS, CD, CSD)
names(cmbs) <- c("CO", "CS", "CD", "CSD") > head(cmbs)
        CO       CS       CD      CSD
1 25.76032 24.40528 25.99406 35.94196
2 25.71127 24.40528 25.99406 35.94196
3 25.90163 24.40528 25.99406 35.94196
4 25.76032 24.09930 25.99406 35.94196
5 25.71127 24.09930 25.99406 35.94196
6 25.90163 24.09930 25.99406 35.94196 within result <- within(cmbs, HM <- HM2(CO, CS, CD, CSD)) > head(result)
        CO       CS       CD      CSD            HM
1 25.76032 24.40528 25.99406 35.94196 -0.0003368911
2 25.71127 24.40528 25.99406 35.94196 -0.0003368814
3 25.90163 24.40528 25.99406 35.94196 -0.0003369210
4 25.76032 24.09930 25.99406 35.94196 -0.0002725079
5 25.71127 24.09930 25.99406 35.94196 -0.0002725000
6 25.90163 24.09930 25.99406 35.94196 -0.0002725321
-------------------------------------------------------------------------------------------------------
dat1 <- read.table(text="
Road    Start     End
1 157398137 166811234
1 216984017 238298694
1 238298694 247249719
2       0   8794530
2   8794530  26703134
2  59852594  73085123
2 206737339 218577503
2 218695178 231142027
3  96301465 115456078
3 116345621 126898764", header=T)

dat2 <- read.table(text="
Road    Start     End
       1 157398137 166811234
1 216984017 238298694
1 238298694 247249719
2     0   8794530
2   8794530  26703134
2  59852594  73085123
2 206737339 218577503
3   3469683  56797911
3  96301465 115456078
3 116345621 126898764", header=T)

dat3 <- read.table(text="
Road    Start     End
1 157398137 166811234
1 216984017 238298694
1 238298694 247249719
2       0   8794530
2   8794530  26703134
2  59852594  73085123
2 206737339 218577503
2 218695178 231142027
2 231142027 241946296
3   3469683  56797911
3  96301465 115456078
3 116345621 126898764", header=T)

lst <- list(dat1, dat2, dat3)

dat <- data.frame(Vehicle = rep(paste0("Vehicle", 1:3), sapply(lst, nrow)),
do.call(rbind, lst))

dat$Road <- factor(dat$Road)

dat library(ggplot2)
ggplot(dat) + 
    geom_segment(aes(x=Start, xend=End, y=Vehicle, yend=Vehicle), size=3) +
    coord_flip() +
    facet_grid(Road~.)
-------------------------------------------------------------------------------------------------------
geom_rect Vehicles <- structure(list(Road = c(1L, 1L, 1L, 2L, 2L, 2L, 2L, 2L, 3L, 3L, 
1L, 1L, 1L, 2L, 2L, 2L, 2L, 3L, 3L, 3L, 1L, 1L, 1L, 2L, 2L, 2L, 
2L, 2L, 2L, 3L, 3L, 3L), Start = c(157398137L, 216984017L, 238298694L, 
0L, 8794530L, 59852594L, 206737339L, 218695178L, 96301465L, 116345621L, 
157398137L, 216984017L, 238298694L, 0L, 8794530L, 59852594L, 
206737339L, 3469683L, 96301465L, 116345621L, 157398137L, 216984017L, 
238298694L, 0L, 8794530L, 59852594L, 206737339L, 218695178L, 
231142027L, 3469683L, 96301465L, 116345621L), End = c(166811234L, 
238298694L, 247249719L, 8794530L, 26703134L, 73085123L, 218577503L, 
231142027L, 115456078L, 126898764L, 166811234L, 238298694L, 247249719L, 
8794530L, 26703134L, 73085123L, 218577503L, 56797911L, 115456078L, 
126898764L, 166811234L, 238298694L, 247249719L, 8794530L, 26703134L, 
73085123L, 218577503L, 231142027L, 241946296L, 56797911L, 115456078L, 
126898764L), Vehicle = c("1", "1", "1", "1", "1", "1", "1", "1", 
"1", "1", "2", "2", "2", "2", "2", "2", "2", "2", "2", "2", "3", 
"3", "3", "3", "3", "3", "3", "3", "3", "3", "3", "3")), .Names = c("Road", 
"Start", "End", "Vehicle"), row.names = c(NA, 32L), class = "data.frame")

set.seed(42)
Vehicles$overspeed <- runif(nrow(Vehicles),0,50)
Vehicles$overspeed <- cut(Vehicles$overspeed,c(0,20,30,Inf))

roads <- read.table(text="Road    Length
1   529290651
2   249139323
3   298024420",header=TRUE)

library(ggplot2)
p <- ggplot(Vehicles,aes(xmin=as.numeric(Vehicle)-0.4,
                         xmax=as.numeric(Vehicle)+0.4,
                         ymin=Start,ymax=End,fill=overspeed)) + 
  geom_rect() +
  facet_grid(Road~.,scales = "free_y") +
  #ugly hack to get correct road lengths:
  geom_rect(data=roads,aes(ymin=0,ymax=Length,xmin=0.4,xmax=1.4,fill=NA),alpha=0) + 
  scale_y_continuous(expand=c(0,1)) +
  xlab("Vehicle") +
  ylab("Distance") +
  theme_bw() +
  scale_fill_manual(values=c("(0,20]"="blue","(20,30]"="yellow","(30,Inf]"="red"))
print(p) p + scale_y_reverse(expand=c(0,1))
-------------------------------------------------------------------------------------------------------
expand.grid predict dgrid <- expand.grid(b=fivenum(data$b)[2:4], c=fivenum(data$c)[2:4]
# A grid with the upper and lower hinges and the medians for `a` and `b`.

predict(my_probit,  newdata=dgrid) predict(my_probit,  newdata=dgrid, type ="response") ?predict ?predict.glm
-------------------------------------------------------------------------------------------------------
df <- data.frame(values=unlist(FHM_CS, use.names=FALSE), tag=rep(names(FHM_CS), times=sapply(FHM_CS, length)) ggplot2 df.CS <- data.frame(values=unlist(FHM_CS, use.names=FALSE), tag=rep(names(FHM_CS), times=sapply(FHM_CS, length)), class='CS', stringsAsFactors=TRUE)
df.CD <- data.frame(values=unlist(FHM_CD, use.names=FALSE), tag=rep(names(FHM_CD), times=sapply(FHM_CD, length)), class='CD', stringsAsFactors=TRUE)
my.data <- rbind(df.CS, df.CD) melt library(reshape2)
df.CD <- data.frame(melt(FHM_CD), class='CD')
df.CS <- data.frame(melt(FHM_CS), class='CS')
## Except now, instead of `tag`, we have `L1`.
my.data <- rbind(df.CD, df.CS)
my.data$tag <- my.data$L1 library(ggplot2)
ggplot(my.data, aes(x=interaction(tag, class), y=values)) + geom_point(position=position_jitter()) ggplot(my.data, aes(x=tag, y=values)) + geom_point(position=position_jitter()) + stat_summary(fun.y='mean', geom='errorbarh', aes(xmin=as.integer(tag)-0.3, xmax=as.integer(tag)+0.3), height=0) + facet_grid(.~class) my.data$it <- with(my.data, interaction(tag, class, sep=' - ', lex.order=TRUE)) ggplot(my.data, aes(x=it, y=values)) + geom_point(position=position_jitter()) + stat_summary(fun.y='mean', geom='errorbarh', aes(xmin=as.integer(it)-0.3, xmax=as.integer(it)+0.3, height=0, colour=class)) position_jitter()
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(reshape2)
df <- data.frame(country=c('USA','Brazil','Ghana','England','Australia'), Stabbing=c(15,10,9,6,7), Accidents=c(20,25,21,28,15), Suicide=c(3,10,7,8,6))
mm <- melt(df, id.vars='country')
ggplot(mm, aes(x=country, y=value)) + geom_bar(stat='identity') + facet_grid(.~variable) + coord_flip() + labs(x='',y='')
-------------------------------------------------------------------------------------------------------
c <-  c("9", "286593", "C", "C/C", "C/A", "A/A")
# Note: In your original data, you had a space in "G/A", which I did remove. 
# If this was no mistake, we would also have to deal with the space.
d <-  c("9", "334337", "A", "A/A", "G/A", "A/A")
e <-   c("9", "390512", "C", "C/C", "C/C", "C/C")
dat <- data.frame(rbind(c,d,e)) values <- c("A", "C", "G", "T")
dat$X3 <- factor(dat$X3, levels=values) # This way we just ensure that it will later on be possible to compare the reference values to our generated data. 

# Generate all possible combinations of two letters
combinations <- expand.grid(f=values, s=values)
combinations <- cbind(combinations, v=with(combinations, paste(f, s, sep='/'))) compare <- function(col, val) {
    m <- match(col, combinations$v)
    2 - (combinations$f[m] == val) - (combinations$s[m] == val)
} dat[,4:6] <- apply(dat[,4:6], 2, compare, val=dat[,3]) test replications elapsed relative user.self sys.self user.child sys.child
1   arun      1000000   2.881    1.116     2.864    0.024          0         0
2  fabio      1000000   2.593    1.005     2.558    0.030          0         0
3 roland      1000000   2.727    1.057     2.687    0.048          0         0
5  thilo      1000000   2.581    1.000     2.540    0.036          0         0
4  tyler      1000000   2.663    1.032     2.626    0.042          0         0
-------------------------------------------------------------------------------------------------------
ggplot2 # Recreate your data.
data<-c(6,6,4,5,8,9,8,6,3,3,4,5,4,2,1,5,3,3,4,2,4,8,3,1,6,5,4,3,9,8,2,6,8,3,4,5,7,6,2,2,10,9,6,8,9,4,6,7)
list<-split(data,rep(1:6,each=8))
names(list)<-paste0('Block',1:6)

library(ggplot2)
library(reshape2)
dat<-melt(list)[2:1]
names(dat)<-c('Block','Value')
dat$brain.section<-rep(1:8,6)

ggplot(dat,aes(x=brain.section,y=Value,group=Block)) + geom_line() + facet_grid(Block~.) ggplot2 ggplot(dat,aes(x=brain.section,fill=Value,y=Block)) + geom_tile()
-------------------------------------------------------------------------------------------------------
ggplot(dat=d, aes(x=x, y=..ncount..)) +
  geom_histogram(data = d[d$par == "a",], binwidth=0.1) +
  geom_histogram(data = d[d$par == "b",], binwidth=0.01) +  
  facet_grid(.~ par, scales="free") # More facets
d <- data.frame(x=c(rnorm(200,10,0.1),rnorm(200,20,0.1)),par=rep(letters[1:4],each=100))

# vector of binwidths same length as number of facets - need a nicer way to calculate these
my.width=c(0.5,0.25,0.1,0.01)

out<-lapply(1:length(my.width),function(.i) data.frame(par=levels(d$par)[.i],ggplot2:::bin(d$x[d$par==levels(d$par)[.i]],binwidth=my.width[.i])))

my.df<-do.call(rbind , out)

ggplot(my.df) + geom_histogram(aes(x, y = density, width = width), stat =  "identity") + facet_wrap(~par,scales="free")
-------------------------------------------------------------------------------------------------------
ind  <- expand.grid(1:nrow(CY), 1:nrow(CY))
CY.1 <- CY[ind[, 1], ]
CY.2 <- CY[ind[, 2], ]
bool <- (CY.1$year == CY.2$year) & (CY.1$country != CY.2$country)
DDY  <- data.frame(country1 = CY.1$country[bool], 
                   country2 = CY.2$country[bool],
                   year     = CY.1$year[bool],
                   x1       = CY.1$x[bool],
                   x2       = CY.2$x[bool])
DDY  <- DDY[order(country1, country2), ]
DDY
-------------------------------------------------------------------------------------------------------
expand.grid expand.grid(c(0,1),c(0,1))
  Var1 Var2
1    0    0
2    1    0
3    0    1
4    1    1 m m <- as.data.frame(matrix(rbinom(5*2, 1, 0.5),ncol=5))
 V1 V2 V3 V4 V5
1  0  1  1  0  0
2  0  1  1  0  0

dim(expand.grid(m))
32 5
-------------------------------------------------------------------------------------------------------
statAncova <- function (dataframe, response, covariate, Factor) {

  library(ggplot2)
  eval(parse(text=paste0("mod <- aov(",response," ~ ",covariate," + ",Factor,", data=dataframe)")))
  pred <- predict(mod)
  eval(parse(text=paste0("plotMod <- ggplot(data = cbind(mod$model, pred), aes(",covariate,", ",response,", color=",Factor,")) + 
  geom_point() +
  facet_grid(. ~ ",Factor,") + 
  geom_line(aes(y=pred))")))

  return(list(mod, plotMod))

}

statAncova(mtcars, "drat", "hp", "cyl") statAncova <- function (response, covariate, Factor) {

  dataframe <- data.frame(response, covariate, Factor)

  library(ggplot2)
  mod <- aov(response ~ covariate + Factor, data=dataframe)
  pred <- predict(mod)
  plotMod <- ggplot(data = cbind(mod$model, pred), aes(covariate, response, color=Factor)) + 
    geom_point() +
    facet_grid(. ~ Factor) + 
    geom_line(aes(y=pred))

  return(list(mod, plotMod))

}

statAncova(mtcars$drat, mtcars$hp, mtcars$cyl)
-------------------------------------------------------------------------------------------------------
ggplot2 lattice dat$DATE <- as.Date(dat$DATE,format='%d/%m/%Y')
library(ggplot2)
ggplot(dat,aes(x=DATE,y=Rev,group=ProdCode,color=ProdCode)) + 
  geom_line() + 
  facet_grid(~ID) +
  geom_smooth(method='lm') dat <- read.table(text='DATE    ID  ProdCode    Rev
08/01/2012   1-100FDK    B51    0.22
09/01/2012   1-100FDK    B51    10.17
10/01/2012   1-100FDK    B51    39.73
11/01/2012   1-100FDK    B51    78.77
12/01/2012   1-100FDK    B51    167.66
08/01/2012   1-100FDK    B53    387.82
09/01/2012   1-100FDK    B53    321.58
10/01/2012   1-100FDK    B53    261.9
11/01/2012   1-100FDK    B53    259.84
12/01/2012   1-100FDK    B53    269.84
08/01/2012   1-200FFK    A54    194.42
09/01/2012   1-200FFK    A54    225.1
10/01/2012   1-200FFK    A54    269.42
11/01/2012   1-200FFK    A54    321.14
12/01/2012   1-200FFK    A54    429.11',
         header=TRUE)
-------------------------------------------------------------------------------------------------------
qplot binwidth = 2 plyr library(plyr)
agg.data <-  ddply(dat.m, .(value,time), summarize, p = unique(perc), n = length(perc))

ggplot(agg.data, aes(x= value)) + 
 geom_bar(aes(y = n),stat='identity') + 
 facet_grid(time~.) + 
 geom_text(aes(y=n, label = sprintf('%.01f',p)),vjust=-1,size=3) geom_histogram stat_bin ..density.. ggplot(dat.m, aes(x= value)) + 
  geom_histogram(binwidth=2) +  
  facet_grid(time~.) + 
  stat_bin(aes(y = ..count.., label = sprintf('%.01f', 100 * ..density..)),
           binwidth=2,geom='text',vjust = -1) 0.0 ifelse ggplot(dat.m, aes(x= value)) + 
   geom_histogram(binwidth=2) +  facet_grid(time~.) + 
   stat_bin(aes(y = ..count.., 
     label = ifelse(test = (xxx <- sprintf('%.01f', 100 * ..density..))=='0.0','',xxx)),
     binwidth=2,geom='text',vjust = -0.7) qplot qplot(value, data=dat.m,facets=time~.,binwidth=2,main="")+
     xlab("Value")+ ylab("Count")+
     theme(legend.position="none")+
     stat_bin(aes(value,label=ifelse(test = (xxx <-  
       sprintf("%.01f",..density..*100))=='0.0','',xxx)),geom="text",binwidth=2,vjust = -0.7)
-------------------------------------------------------------------------------------------------------
setwd('c:/users/mmiller21/simple r programs/')

# define fruits of interest

fruits <- c('apple', 'pumpkin', 'pecan')

# define ingredients of interest

ingredients <- c('all.purpose.flour', 'sugar', 'ground.cinnamon')

# define every combination of fruit and ingredient

fruits.and.ingredients <- expand.grid(fruits, ingredients)

old.fruit <- as.character(rep('apple', nrow(fruits.and.ingredients)))
old.ingredient  <- as.character(rep('all.purpose.flour', nrow(fruits.and.ingredients)))

fruits.and.ingredients2 <- cbind(old.fruit , as.character(fruits.and.ingredients[,1]),
                           old.ingredient, as.character(fruits.and.ingredients[,2]))

colnames(fruits.and.ingredients2) <- c('old.fruit', 'new.fruit', 'old.ingredient', 'new.ingredient')


# begin function

make.pie <- function(old.fruit, new.fruit, old.ingredient, new.ingredient) {

new.ingredient2 <- gsub('\\.',  '', new.ingredient)
old.ingredient2 <- gsub('\\.',  '', old.ingredient)

new.ingredient3 <- gsub('\\.', ' ', new.ingredient)
old.ingredient3 <- gsub('\\.', ' ', old.ingredient)

# file name

old.file <- paste(old.fruit, ".pie.", old.ingredient, ".arsc.Jun26.2013.r", sep="")
new.file <- paste(new.fruit, ".pie.", new.ingredient, ".arsc.Jun26.2013.r", sep="")

# read original fruit and original ingredient

flour   <- readLines(old.file)

# add new file name

flour.a <- gsub(paste("# ", old.file, sep=""), 
                paste("# ", new.file, sep=""), flour)

# read new data file 

old.data.file <- print(paste("my.data = convert.txt(\"../", old.fruit, "pie", old.ingredient2, ".txt\",", sep=""), quote=FALSE)

new.data.file <- print(paste("my.data = convert.txt(\"../", new.fruit, "pie", new.ingredient2, ".txt\",", sep=""), quote=FALSE)

flour.b <- ifelse(flour.a == old.data.file, new.data.file, flour.a)

flour.c <- ifelse(flour.b == paste('ingredient <- c(\'', old.ingredient3, '\')', sep=""), 
                             paste('ingredient <- c(\'', new.ingredient3, '\')', sep=""), flour.b)

cat(flour.c, file = new.file, sep=c("\n"))

}

apply(fruits.and.ingredients2, 1, function(x) make.pie(x[1], x[2], x[3], x[4]))
-------------------------------------------------------------------------------------------------------
melt cast reshape2 df d <- unlist(df[-1]) # put all the distances into a vector
newdf <- cbind(expand.grid(back=seq_len(nrow(df)), pres=seq_len(ncol(df) - 1)), d)
-------------------------------------------------------------------------------------------------------
d$aabbcc # create the source data
d <- data.frame(matrix(rbinom(60, 1, 0.5), ncol=6))
names(d) <- letters[1:6]


# generate matrix of all possible combinations (except the null)
v <- as.matrix(expand.grid(rep(list(c(FALSE, TRUE)), ncol(d))))[-1, ]

# convert the matrix into a list of column indexes
indexes <- lapply(seq_len(nrow(v)), function(x) v[x, ])
names(indexes) <- apply(v, 1, function(x) paste(names(d)[x], collapse="."))

# compute values from the source data
out <- data.frame(lapply(indexes, function(i) as.numeric(apply(d[i], 1, all))))
-------------------------------------------------------------------------------------------------------
df <- read.table(text="Date      Month Year  Value1
30/05/96       May 1996 1835
06/12/96  December 1996 1770
18/03/97     March 1997 1640
27/06/97      June 1997 1379
30/09/97 September 1997 1195
24/11/97  November 1997 1335
13/03/98     March 1998 1790
07/05/98       May 1998  349
14/07/98      July 1998 1179
27/10/98   October 1998  665", header=T, as.is=T)

df$Month <- factor(df$Month, levels=month.name, ordered=T)

library(ggplot2)
ggplot(df) + geom_line(aes(Month, Value1, group=Year)) +
  facet_grid(Year~.)
-------------------------------------------------------------------------------------------------------
expand.grid x <- expand.grid(x1=seq(0.1, 0.9, by=0.01), x2=seq(1.1, 0.3, by=-0.01))
x$yval <- with(x, fn(x1, x2))

fit = lm(yval ~ x1 + x2 + I(x1^2) + I(x2^2),data=x)
coef(fit)
(Intercept)          x1          x2     I(x1^2)     I(x2^2) 
       -0.1        -1.3        -0.4         1.8         1.8
-------------------------------------------------------------------------------------------------------
get.simulation.GBM = function(TIME = 10, N = 250, N_SIMS = 1000, x0 = 100, sigma = c(0.1, 0.3, 0.6), r = c(0.03, 0.05, 0.08))
{
  require(sde)
  params = expand.grid(sigma = sigma, r = r)

  # pre-allocate matrix
  results = matrix(0, ncol = N_SIMS * nrow(params), nrow = N)

  for (i in 1:nrow(params))
  {
    idx.range =  ((i - 1)*N_SIMS + 1):((i - 1)*N_SIMS + N_SIMS)
    temp.res = replicate(N_SIMS, GBM(x0, r = params[i, 'r'], sigma = params[i, 'sigma'], T = TIME, N = N - 1 ))
    results[, idx.range] = temp.res
  }

  return(results)
}

apply.MACD = function(serie, nFast = 12, nSlow = 26, nSig = 9, p0 = 100)
{
  require(TTR)
  roc = ROC(serie)
  sim.MACD = MACD(serie, nFast, nSlow, nSig, maType = "EMA")
  portfolio = rep(0, length = length(serie))
  portfolio[1] = p0

  sim.MACD[is.na(sim.MACD)] = 0
  sim.MACD = as.data.frame(sim.MACD)

  for (i in 2:length(serie))
  {
    buy = portfolio[i - 1] * exp(roc[i])
    sell = portfolio[i - 1]
    hold = buy

    if(sim.MACD$macd[i - 1] < sim.MACD$signal[i - 1] && sim.MACD$macd[i] > sim.MACD$signal[i]){portfolio[i] = buy}
    if(sim.MACD$macd[i - 1] > sim.MACD$signal[i - 1] && sim.MACD$macd[i] < sim.MACD$signal[i]){portfolio[i] = sell}
    if(sim.MACD$macd[i - 1] > sim.MACD$signal[i - 1] && sim.MACD$macd[i] > sim.MACD$signal[i]){portfolio[i] = hold}
    if(sim.MACD$macd[i - 1] < sim.MACD$signal[i - 1] && sim.MACD$macd[i] < sim.MACD$signal[i]){portfolio[i] = sell}
    if(sim.MACD$macd[i] == sim.MACD$signal[i]){portfolio[i] = sell}
    if(sim.MACD$macd[i - 1] == sim.MACD$signal[i - 1] && sim.MACD$macd[i] != sim.MACD$signal[i]){portfolio[i] = buy}

  }
  return(portfolio)
}

apply.RSI = function(serie, p0 = 100, n = 14)
{
  require(TTR)
  roc = ROC(serie)
  sim.RSI = RSI(serie, n = n)
  sim.RSI[is.na(sim.RSI)] = 0
  portfolio = rep(0, length = length(serie))
  portfolio[1] = p0

  for (i in 2:length(serie))
  {
    buy = portfolio[i - 1] * exp(roc[i])
    hold = portfolio[i - 1]

    if(sim.RSI[i - 1] < 50 && sim.RSI[i] > 50){portfolio[i] = buy}
    if(sim.RSI[i - 1] > 50 && sim.RSI[i] < 50){portfolio[i] = hold}
    if(sim.RSI[i - 1] < 50 && sim.RSI[i] < 50){portfolio[i] = hold}
    if(sim.RSI[i - 1] > 50 && sim.RSI[i] > 50){portfolio[i] = buy}
  }
  return(portfolio)
}

# Example (this is SLOW)
simulation.matrix = get.simulation.GBM()
portfolio.RSI = apply(simulation.matrix, 2, apply.RSI)
portfolio.MACD = apply(simulation.matrix, 2, apply.MACD)

# if you need only the last values
portfolio.RSI.last = tail(portfolio.RSI, 1)
portfolio.MACD.last = tail(portfolio.MACD, 1)
-------------------------------------------------------------------------------------------------------
geom_bar() y library(ggplot2)
a <- data.frame(x = factor(c(rep('a',5), rep('a',5), rep('b',5), rep('c',5))),
                y = 1,
                z = c(5:1, c(5,4,4,4,1), 5:1, 5:1)
)

a$bar <- rep(1:4, each=5)

ggplot(a, aes(x = factor(bar), y=y, fill=x, alpha=z)) + 
  geom_bar(stat="identity") +
  facet_grid(~x, space="free", scale="free") a$bar <- rep(1:4, each=5)

ggplot(a, aes(x = factor(bar), y = y, fill=x, alpha=z)) + 
  geom_bar(stat="identity", position="dodge") +
  facet_grid(~x, space="free", scale="free") geom_bar() stat="identity" ggplot(a, aes(x = x, y = y, fill=x, alpha=z)) + 
  geom_bar(stat="identity", position="dodge")
-------------------------------------------------------------------------------------------------------
persp wireframe expand.grid preddf <- expand.grid(x=seq(xmin, xmax, len=51),
                      y=seq(ymin, ymax, len=51))

preddf$z <- predict(model, preddf)

persp(preddf) xmin xmax ymin ymax
-------------------------------------------------------------------------------------------------------
set.seed(1)
dat <- cbind(expand.grid(time = paste("time", 1:3, sep=""), group = paste("task", 1:3, sep=""), subject = paste("S", 1:20, sep="")), response = rnorm(3*3*20))
# Add task1-specific effect (== task1.timeANY)
dat$response <- dat$response + as.numeric(dat$group=="task1")
# Extra effect in the last timepoint of task1 (== task1.time3)
dat$response <- dat$response + as.numeric(dat$group=="task1")*as.numeric(dat$time=="time3")
# Randomness specific for each subject
dat$response <- dat$response + rep(rnorm(20), each=3)
dat$grtim <- interaction(dat$group, dat$time)
# Interaction term specified above
#> head(dat)
#   time group subject    response       grtim
#1 time1 task1      S1 -0.85777723 task1.time1
#2 time2 task1      S1 -0.04768010 task1.time2
#3 time3 task1      S1 -0.06695203 task1.time3
#4 time1 task2      S1  2.57917637 task2.time1
#5 time2 task2      S1  1.31340334 task2.time2
#6 time3 task2      S1  0.16342719 task2.time3

# Reason why TukeyHSD-function fails:
#anova = aov(response~(group*time)+Error(subject/time),dat) 
#summary(anova)
#TukeyHSD(anova)
#Error in UseMethod("TukeyHSD") : 
#  no applicable method for 'TukeyHSD' applied to an object of class "c('aovlist', 'listof')"
#> class(anova)
#[1] "aovlist" "listof"

require(nlme)
# Below call does not work for glht, thus we created the interaction term in the data frame
#model <- lme(response ~ group*time, random = ~ 1 | subject / time, dat)
model <- lme(response ~ grtim, random = ~ 1 | subject / time, dat)
require(multcomp)
summary(glht(model, linfct=mcp(grtim="Tukey")), test = adjusted(type = "bonferroni")) Simultaneous Tests for General Linear Hypotheses

Multiple Comparisons of Means: Tukey Contrasts


Fit: lme.formula(fixed = response ~ grtim, data = dat, random = ~1 | 
    subject/time)

Linear Hypotheses:
                               Estimate Std. Error z value Pr(>|z|)    
task2.time1 - task1.time1 == 0 -0.66574    0.40907  -1.627 1.000000    
task3.time1 - task1.time1 == 0 -0.21758    0.40907  -0.532 1.000000    
task1.time2 - task1.time1 == 0  0.46382    0.40907   1.134 1.000000    
task2.time2 - task1.time1 == 0 -0.63987    0.40907  -1.564 1.000000    
task3.time2 - task1.time1 == 0 -0.86698    0.40907  -2.119 1.000000    
task1.time3 - task1.time1 == 0  1.17238    0.40907   2.866 0.149667    
task2.time3 - task1.time1 == 0 -1.15241    0.40907  -2.817 0.174433    
task3.time3 - task1.time1 == 0 -0.70811    0.40907  -1.731 1.000000    
task3.time1 - task2.time1 == 0  0.44816    0.40907   1.096 1.000000    
task1.time2 - task2.time1 == 0  1.12956    0.40907   2.761 0.207272    
task2.time2 - task2.time1 == 0  0.02587    0.40907   0.063 1.000000    
task3.time2 - task2.time1 == 0 -0.20124    0.40907  -0.492 1.000000    
task1.time3 - task2.time1 == 0  1.83812    0.40907   4.493 0.000252 ***
task2.time3 - task2.time1 == 0 -0.48667    0.40907  -1.190 1.000000    
task3.time3 - task2.time1 == 0 -0.04237    0.40907  -0.104 1.000000    
task1.time2 - task3.time1 == 0  0.68140    0.40907   1.666 1.000000    
task2.time2 - task3.time1 == 0 -0.42229    0.40907  -1.032 1.000000    
task3.time2 - task3.time1 == 0 -0.64940    0.40907  -1.587 1.000000    
task1.time3 - task3.time1 == 0  1.38996    0.40907   3.398 0.024451 *  
task2.time3 - task3.time1 == 0 -0.93483    0.40907  -2.285 0.802723    
task3.time3 - task3.time1 == 0 -0.49053    0.40907  -1.199 1.000000    
task2.time2 - task1.time2 == 0 -1.10369    0.40907  -2.698 0.251098    
task3.time2 - task1.time2 == 0 -1.33080    0.40907  -3.253 0.041077 *  
task1.time3 - task1.time2 == 0  0.70856    0.40907   1.732 1.000000    
task2.time3 - task1.time2 == 0 -1.61623    0.40907  -3.951 0.002802 ** 
task3.time3 - task1.time2 == 0 -1.17193    0.40907  -2.865 0.150188    
task3.time2 - task2.time2 == 0 -0.22711    0.40907  -0.555 1.000000    
task1.time3 - task2.time2 == 0  1.81225    0.40907   4.430 0.000339 ***
task2.time3 - task2.time2 == 0 -0.51254    0.40907  -1.253 1.000000    
task3.time3 - task2.time2 == 0 -0.06824    0.40907  -0.167 1.000000    
task1.time3 - task3.time2 == 0  2.03936    0.40907   4.985 2.23e-05 ***
task2.time3 - task3.time2 == 0 -0.28543    0.40907  -0.698 1.000000    
task3.time3 - task3.time2 == 0  0.15887    0.40907   0.388 1.000000    
task2.time3 - task1.time3 == 0 -2.32479    0.40907  -5.683 4.76e-07 ***
task3.time3 - task1.time3 == 0 -1.88049    0.40907  -4.597 0.000154 ***
task3.time3 - task2.time3 == 0  0.44430    0.40907   1.086 1.000000    
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
(Adjusted p values reported -- bonferroni method)
-------------------------------------------------------------------------------------------------------
reshape2 library(ggplot2)
library(reshape2)
dt <- read.table(text='
M1 N2 O1 P2 Q1 R2     
A  10 11 12 13 14 15
B  15 14 13 12 11 10 
C  20 21 22 23 24 25
D  25 24 23 22 21 20',header=TRUE)
dt.m <- melt(t(dt))
dt.m$Var1 <- gsub('[A-Z]','',dt.m$Var1) library(ggplot2)
library(gridExtra)
p1 <- ggplot(dt.m) +
   geom_boxplot(aes(x=Var2,y=value,fill=Var1))

p2 <- ggplot(dt.m) +
  geom_boxplot(aes(x=Var2,y=value,fill=Var2))+
  facet_grid(~Var1)

grid.arrange(p1,p2)
-------------------------------------------------------------------------------------------------------
id <- seq(2*3*3*4*2*3*3) # a vector of identification values

#create a lookup table
lut <- cbind(id=id, expand.grid(lev1=seq(2), lev2=seq(3), lev3=seq(3), lev4=seq(4), lev5=seq(2), lev6=seq(3), lev7=seq(3)))

list.obj <- vector(mode="list", nrow(lut))

#optional addition of names
names(list.obj) <- paste(lut$lev1, lut$lev2, lut$lev3, lut$lev4, lut$lev5, lut$lev6, lut$lev7, sep=".")
head(list.obj)

#fill in list with data
for(i in seq(list.obj)){
    matching <- i #here you can have some sort of case matching for filling in elements of the list
    list.obj[[matching]] <- runif(10)
}
head(list.obj)
-------------------------------------------------------------------------------------------------------
grid.arrange dat <- rbind(GO.df2,GO.df2)
    dat$grp <- factor(rep(c('p-values','Num of Ocurrences'),each = nrow(GO.df2)),
                      levels = c('p-values','Num of Ocurrences'))
    dat$GO.ID <- factor(dat$GO.ID,levels = unique(dat$GO.ID))

ggplot(dat,aes(x = GO.ID)) + 
    facet_grid(grp~.,scales = "free_y") +
    geom_point(data = subset(dat,grp == 'p-values'),
               aes(y = value,colour = variable)) + 
    geom_line(data = subset(dat,grp == 'p-values'),
              aes(y = value,colour = variable,group = variable)) + 
    geom_bar(data = subset(dat,grp == 'Num of Ocurrences'),
             aes(y = occ),stat = "identity") + 
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
    ylab("") geom_line rbind facet_grid theme
-------------------------------------------------------------------------------------------------------
"Python has a REALLY WAY TOO long label"  # will be handled correctly labeller width label_wrap_gen2 <- function(width = 100) {
  function(variable, value) {
    inter <- lapply(strwrap(as.character(value), width=width, simplify=FALSE), 
           paste, collapse="\n")
    inter <- gsub("(.{5})", "\\1\n",inter)
  }
} label_wrap_gen3 <- function(width = 100) {
  function(variable, value) {
    inter <- lapply(strwrap(as.character(value), width=width, simplify=FALSE), 
           paste, collapse="\n")
    inter <- gsub(paste0("(.{",width,"})"), "\\1\n",inter)
  }
}

# Seems to deliver expected results when called with:
  ... + facet_grid(..., labeller=label_wrap_gen3(width=5) )
-------------------------------------------------------------------------------------------------------
histo <- tkrplot(tt, function()hist(data)
tkgrid(histo)
-------------------------------------------------------------------------------------------------------
split f df$yearmon <- factor(df$yearmon, levels=unique(df$yearmon))
# now split
split(df, df$yearmon)
# $`4_2013`
#   Date.of.Inclusion Securities.Included Securities.Excluded yearmon
# 1        2013-04-01          INDUSINDBK             SIEMENS  4_2013
# 2        2013-04-01                NMDC               WIPRO  4_2013

# $`9_2012`
#   Date.of.Inclusion Securities.Included Securities.Excluded yearmon
# 3        2012-09-28               LUPIN                SAIL  9_2012
# 4        2012-09-28          ULTRACEMCO                STER  9_2012

# $`4_2012`
#   Date.of.Inclusion Securities.Included Securities.Excluded yearmon
# 5        2012-04-27          ASIANPAINT                RCOM  4_2012
# 6        2012-04-27          BANKBARODA              RPOWER  4_2012 split data.table split data.table require(data.table)
dt <- data.table(df)
dt[, grp := .GRP, by = yearmon]
setkey(dt, grp)
o2 <- dt[, list(list(.SD)), by = grp]$V1 set.seed(45)
dates <- seq(as.Date("1900-01-01"), as.Date("2013-12-31"), by = "days")
ym <- do.call(paste, c(expand.grid(1:500, 1900:2013), sep="_"))

df <- data.frame(x1 = sample(dates, 1e4, TRUE), 
                 x2 = sample(letters, 1e4, TRUE), 
                 x3 = sample(10, 1e4, TRUE), 
                 yearmon = sample(ym, 1e4, TRUE), 
      stringsAsFactors=FALSE)

require(data.table)
dt <- data.table(df)

f1 <- function(dt) {
    dt[, grp := .GRP, by = yearmon]
    setkey(dt, grp)

    o1 <- dt[, list(list(.SD)), by=grp]$V1
}

f2 <- function(df) {
    df$yearmon <- factor(df$yearmon, levels=unique(df$yearmon))
    o2 <- split(df, df$yearmon)
}

require(microbenchmark)
microbenchmark(o1 <- f1(dt), o2 <- f2(df), times = 10)

# Unit: milliseconds
         expr        min         lq     median        uq      max neval
#  o1 <- f1(dt)   43.72995   43.85035   45.20087  715.1292 1071.976    10
#  o2 <- f2(df) 4485.34205 4916.13633 5210.88376 5763.1667 6912.741    10 o1 names(o1) <- unique(dt$yearmon)
-------------------------------------------------------------------------------------------------------
library("plyr")
cns.annotate <- ddply(cns, .(Name), summarize, y.int=mean(Days[Type=="Completed"])) geom_hline qplot(Date, data=cns, 
      geom="bar", binwidth = 1, 
      fill=Type, facets = Name ~ .) +
  geom_hline(data=cns.annotate, aes(yintercept=y.int)) ggplot(cns, aes(x=Date)) +
  geom_bar(aes(fill=Type), binwidth=1) +
  geom_hline(data=cns.annotate, aes(yintercept=y.int)) +
  facet_grid(Name ~ .)
-------------------------------------------------------------------------------------------------------
label_wrap_gen <- function(width = 100) {
  function(variable, value) {
    lapply(strwrap(as.character(value), width=width, simplify=FALSE), 
           paste, collapse="\n")
  }
}

Data <- data.frame(Language=c("C++","C++","C++", "Java","Java","Java","Java", "PythonhasaREALLY- WAYTOOlonglabel","PythonhasaREALLY- WAYTOOlonglabel","PythonhasaREALLY- WAYTOOlonglabel"), #note that I add a hyphen here and two placeholders that will have 0 values
                   Files=c(400, 210, 35,55,330,220,213,0,76,0), #note that I add two 0 values here
                   Difficulty=c("a","b","c","d","e","f","g","h","i","j"), 
                   stringsAsFactors=FALSE)

Data
g <- ggplot(Data,aes(x=Difficulty,y=Files,fill=Difficulty))  #replaced fill=feetype,
h <- g + geom_bar(stat="identity",position="dodge") +   facet_grid(.~ Language, scales = "free_x", space="free",labeller=label_wrap_gen(width=.1))
-------------------------------------------------------------------------------------------------------
spplot spplot.grid(obj, zcol = names(obj), ..., names.attr, scales = list(draw = FALSE),
  xlab = NULL, ylab = NULL, aspect = mapasp(obj,xlim,ylim),
  panel = panel.gridplot, sp.layout = NULL, formula, xlim = bbox(obj)[1, ],
  ylim = bbox(obj)[2, ], checkEmptyRC = TRUE)

....................................................................
....................................................................
....................................................................

 obj: object of class extending Spatial-class

zcol: character; attribute name(s) or column number(s) in attribute
      table
....................................................................
....................................................................
.................................................................... zcol meuse.grid require(sp)
data(meuse.grid) 
coordinates(meuse.grid) = c("x", "y") 
gridded(meuse.grid) <- TRUE

class(meuse.grid)
[1] "SpatialPixelsDataFrame"
attr(,"package")
[1] "sp"

names(meuse.grid)
[1] "part.a" "part.b" "dist"   "soil"   "ffreq" 

spplot(meuse.grid, "soil") spplot(meuse.grid["soil"])
-------------------------------------------------------------------------------------------------------
library(shiny)
library(ggplot2)

## Define UI for miles per gallon application

dataset <- diamonds

title <- "Diamonds data Analysis"

## Define UI for application that plots random distributions

shinyUI(pageWithSidebar(

  ## Application title
  headerPanel(title),

  ## Sidebar with a slider input for number of observations

  sidebarPanel (

    sliderInput('sampleSize','Sample Size', min=1, max=nrow(dataset),
                value=min(1000,nrow(dataset)),
                step=500,
                round=0),

    selectInput('x','X',names(dataset)),
    selectInput('y','Y',names(dataset),
                names(dataset)[[2]]),

    selectInput('color','Color',c('None',names(dataset))),

    selectInput('shape','Shape',c('None',names(dataset))),

    checkboxInput('jitter','Jitter'),
    checkboxInput('smooth','Smooth'),

    selectInput('facet_col','Facet Column',
                c(None='.',names(dataset))),

    selectInput('facet_row','Facet Row',
                c(None='.',names(dataset)))

  ),

  ## Show a plot of the generated distribution

  mainPanel(plotOutput('plot',height="700px"))


)

) library(shiny)
library(ggplot2)

## Define server logic required to generate and plot a random distribution
shinyServer(function(input,output) {

  dataset <- reactive(function(){
    diamonds[sample(nrow(diamonds),input$sampleSize),]
  })

output$plot <- renderPlot(function(){

  p <- ggplot(dataset(),aes_string(x=input$x, y=input$y))+geom_point()

  if(input$color != 'None')
    p <- p + aes_string(color=input$color)

  if (input$shape != 'None')
    p <- p + aes_string(shape=input$shape)

  facets <- paste(input$facet_row, '~', input$facet_col)

  if (facets != '. ~ .')
    p <- p + facet_grid(facets)

  if (input$jitter)
    p <- p + geom_jitter()

  if (input$smooth)
    p <- p + geom_smooth()


  print(p)

})


})
-------------------------------------------------------------------------------------------------------
gbmGrid TrainedGBM ntrees gbm.perf ntrees = 2000 gbm.perf ntrees trainedGBM$finalModel$fit predict(trainedGBM$finalModel, type="response", n.trees=ntrees) library(caret)
library(gbm)

set.seed(42)

gbmGrid <- expand.grid(.n.trees = 100, 
                   .interaction.depth = 1:4, 
                   .shrinkage = 0.05)


trainedGBM <- train(Species ~ ., method = "gbm", distribution='multinomial',
                data = iris, tuneGrid = gbmGrid, 
                trControl = trainControl(method = "repeatedcv", number = 10, 
                                         repeats = 3, verboseIter = FALSE, 
                                         returnResamp = "all"))
print(trainedGBM) # Resampling results across tuning parameters:

#  interaction.depth  Accuracy  Kappa  Accuracy SD  Kappa SD
#   1                  0.947     0.92   0.0407       0.061   
#   2                  0.947     0.92   0.0407       0.061   
#   3                  0.944     0.917  0.0432       0.0648  
#   4                  0.944     0.917  0.0395       0.0592  

# Tuning parameter 'n.trees' was held constant at a value of 100
# Tuning parameter 'shrinkage' was held constant at a value of 0.05
# Accuracy was used to select the optimal model using  the largest value.
# The final values used for the model were interaction.depth = 1, n.trees = 100
# and shrinkage = 0.05. ntrees <-  gbm.perf(trainedGBM$finalModel, method="OOB")
# Giving ntrees = 50 gbmGrid2 <- expand.grid(.n.trees = 1:100, 
                   .interaction.depth = 1:4, 
                   .shrinkage = 0.05)

trainedGBM2 <- train(Species ~ ., method = "gbm", 
                data = iris, tuneGrid = gbmGrid2, 
                trControl = trainControl(method = "repeatedcv", number = 10, 
                                         repeats = 3, verboseIter = FALSE, 
                                         returnResamp = "all"))

print(trainedGBM2) 

# Tuning parameter 'shrinkage' was held constant at a value of 0.05
# Accuracy was used to select the optimal model using  the largest value.
# The final values used for the model were interaction.depth = 2, n.trees = 39
# and shrinkage = 0.05. gbm.perf
-------------------------------------------------------------------------------------------------------
## generate one response, two predictors and one factor (random effect)
set.seed(101)
resp <- runif(100,1,100)
pred1<- rnorm(100, 
           mean=rep(resp[1:50],2)+rep(c(-10,20),each=50),
           sd=rep(c(10,5),each=50))
pred2<- rnorm(100, resp-10, 10) gl(2,50) gl(10,10) RF1<-gl(10,10)
d <- data.frame(resp,pred1,pred2,RF1)

#lmer
library(lme4)
mod <- lmer(resp ~ pred1 + pred2 + (1|RF1),data=d) lme4 predict() pred1 pred2 nd <- with(d,
           rbind(data.frame(expand.grid(RF1=levels(RF1),
                      pred1=seq(min(pred1),max(pred1),length=51)),
                      pred2=mean(pred2),focus="pred1"),
                 data.frame(expand.grid(RF1=levels(RF1),
                      pred2=seq(min(pred2),max(pred2),length=51)),
                      pred1=mean(pred1),focus="pred2")))
nd$val <- with(nd,pred1[focus=="pred1"],pred2[focus=="pred2"])
pframe <- data.frame(nd,resp=predict(mod,newdata=nd))
library(ggplot2)
ggplot(pframe,aes(x=val,y=resp,colour=RF1))+geom_line()+
         facet_wrap(~focus,scale="free") pred1 pred2 nd <- with(d,
           data.frame(expand.grid(RF1=levels(RF1),
                      pred1=seq(min(pred1),max(pred1),length=51),
                      pred2=seq(-20,100,by=40))))
pframe <- data.frame(nd,resp=predict(mod,newdata=nd))
ggplot(pframe,aes(x=pred1,y=resp,colour=RF1))+geom_line()+
         facet_wrap(~pred2,nrow=1) scale="free" facet_wrap() facet_grid(~pred2,labeller=label_both) colour group
-------------------------------------------------------------------------------------------------------
S <- data.frame(S1=c(TRUE,FALSE),S2=c(FALSE,TRUE))
P <- data.frame(P1=c(TRUE,FALSE,FALSE),P2=c(FALSE,TRUE,FALSE),P3=c(FALSE,FALSE,TRUE))

ids <- expand.grid(1:length(S),1:length(P))
t(mapply(function(x,y) unlist(c(S[x,],P[y,])) , ids[[1]], ids[[2]]))

        S1    S2    P1    P2    P3
[1,]  TRUE FALSE  TRUE FALSE FALSE
[2,] FALSE  TRUE  TRUE FALSE FALSE
[3,]  TRUE FALSE FALSE  TRUE FALSE
[4,] FALSE  TRUE FALSE  TRUE FALSE
[5,]  TRUE FALSE FALSE FALSE  TRUE
[6,] FALSE  TRUE FALSE FALSE  TRUE
-------------------------------------------------------------------------------------------------------
ni <- seq_along(y[[3]])
nj <- seq_along(y[[c(3, 1, 2)]])
nij <- as.matrix(expand.grid(3, ni=ni, 2, nj=nj)) nij data <- apply(nij, 1, function(ij) y[[ij]])
year <- apply(cbind(nij[,1:2], 1), 1, function(ij) y[[ij]]) > data.frame(year, do.call(rbind, data))
   year code                     name employment
1  2014    1                   London   74909.59
2  2015    5  West Midlands (England)   69132.34
3  2016   12         Northern Ireland   24313.94
4  2017    5  West Midlands (England)    71723.4
5  2018    9     North East (England)   27199.99
6  2019    4     South West (England)   71219.51
-------------------------------------------------------------------------------------------------------
#Subsetting to only the vectors I want to see in the correlation, as ordered
insheet<-subset(insheet1,
    select=c("Cond", "CL", "SO4", "TN", "TP", "OrthoPhos", "DO", ...., "Rural"))

#Defining "high" and "low" colors
library(colorspace)
mycolors<-diverge_hcl(8,  h = c(8, 240), c = 80, l = c(50,100), power = 1)

#Correlating them into a matrix
sheet<-cor(insheet,use="complete.obs")

#Making it!
image(x=seq(dim(sheet)[2]), y=seq(dim(sheet)[2]), z=sheet, ann=FALSE, 
    col=mycolors,  xlab="x column", ylab="y column", xaxt='n', yaxt='n')
text(expand.grid(x=seq(dim(sheet)[2]), y=seq(dim(sheet)[2])),
    labels=round(c(sheet),2), cex=0.5)
axis(1, 1:dim(insheet2)[2], colnames(insheet2), las=2)
axis(2, 1:dim(insheet2)[2], colnames(insheet2), las=2)
par(mar=c(5.5, 5.5, 2, 1)) #Moves margins over to allow for axis labels
-------------------------------------------------------------------------------------------------------
panel.bwplot bwplot(values~ind, prices,
       panel = function(...) {
         panel.grid(h=-1, v = 0)
         panel.bwplot(...)
       }, ylim=c(0,110)) latticeExtra library(latticeExtra)
bwplot(values~ind, prices,axis=axis.grid)
-------------------------------------------------------------------------------------------------------
dat <- rbind(kyphosis,kyphosis)
dat$grp <- factor(rep(c('smooth','dens'),each = nrow(kyphosis)),
                  levels = c('smooth','dens'))
ggplot(dat,aes(x=Age)) +
      facet_grid(grp~.,scales = "free_y") +
      #geom_point(data=subset(dat,grp=='smooth'),aes(y = as.numeric(Kyphosis) - 1)) +
      stat_smooth(data=subset(dat,grp=='smooth'),aes(y = as.numeric(Kyphosis) - 1),
                  method="glm", family="binomial") +
      geom_density(data=subset(dat,grp=='dens'))
-------------------------------------------------------------------------------------------------------
result <- merge(  
  with(df.start, expand.grid(siteID=unique(siteID),group=unique(group))),
  df.start,
  by=c("siteID","group"),
  all.x=TRUE
)
result$value[is.na(result$value)] <- 0

> result
  siteID    group species value
1      a domestic     dog     2
2      a   exotic    <NA>     0
3      a     wild    <NA>     0
4      b domestic    <NA>     0
5      b   exotic  toucan     4
6      b     wild    deer     3
7      c domestic     dog     5
8      c   exotic  toucan     7
9      c     wild    deer     6
-------------------------------------------------------------------------------------------------------
expand.grid outer library(lattice)

x <- seq(-3,3,by=0.05)
y <- seq(-3,3,by=0.05)

grid <- expand.grid(x=x, y=y)

dim(grid)
[1] 14641     2

grid$z = with(grid, pmin(x,y))

wireframe(z ~ x*y, data=grid, shade=TRUE, main="X=Y",
scales=list(arrows=FALSE))

contourplot(z ~ x*y, data=grid, cuts=10, aspect = "iso")
-------------------------------------------------------------------------------------------------------
fun0 <- function(x) -10

qplot(tag,values,colour=factor(class),data=my.data,geom="jitter")+
  stat_summary(fun.y='mean', geom='text', 
               aes(label=signif(..y..,4),x=as.integer(tag)))+ 
  stat_summary(fun.y="fun0",fun.ymin='sd', geom='text', 
               aes(label=paste("sd:",signif(..ymin..,2)),x=as.integer(tag)))+
  facet_grid(.~class)
-------------------------------------------------------------------------------------------------------
abind::asub indmat <- cbind(1:3,as.matrix(expand.grid(1:3,1:4)))
matrix(TestArray[indmat],nrow=4,ncol=3,byrow=TRUE) d <- dim(TestArray)[1]
d2 <- dim(TestArray)[3]
indmat <- cbind(1:d,as.matrix(expand.grid(1:d,1:d2))
matrix(TestArray[indmat],nrow=d2,ncol=d,byrow=TRUE)
-------------------------------------------------------------------------------------------------------
pretty=FALSE library("maps")
library("mapproj")
map("world")
map.axes()
map.grid(c(-180,180,-90,90),col=2,nx=7,ny=5, pretty=FALSE, label=TRUE,lty=2)
-------------------------------------------------------------------------------------------------------
plot.spei plot.spei <- 
function (x, ...) 
{
    ## label <- ifelse(as.character(x$call)[1] == "spei", "SPEI", 
    ##     "SPI")

    ser <- ts(as.matrix(x$fitted[-c(1:x$scale), ]), end = end(x$fitted), 
        frequency = frequency(x$fitted))
    ser[is.nan(ser - ser)] <- 0
    se <- ifelse(ser == 0, ser, NA)
    tit <- dimnames(x$coefficients)[2][[1]]
    if (start(ser)[2] == 1) {
        ns <- c(start(ser)[1] - 1, 12)
    }
    else {
        ns <- c(start(ser)[1], start(ser)[2] - 1)
    }
    if (end(ser)[2] == 12) {
        ne <- c(end(ser)[1] + 1, 1)
    }
    else {
        ne <- c(end(ser)[1], end(ser)[2] + 1)
    }
    n <- ncol(ser)
    if (is.null(n)) 
        n <- 1
    par(mar = c(4, 4, 2, 1) + 0.1)
    if (n > 1 & n < 5) 
        par(mfrow = c(n, 1))
    if (n > 1 & n >= 5) 
        par(mfrow = c({
            n + 1
        }%/%2, 2))
    for (i in 1:n) {
        datt <- ts(c(0, ser[, i], 0), frequency = frequency(ser), 
            start = ns, end = ne)
        datt.pos <- ifelse(datt > 0, datt, 0)
        datt.neg <- ifelse(datt <= 0, datt, 0)
        plot(datt, type = "n", xlab = "", main = tit[i], ...)
        if (!is.null(x$ref.period)) {
            k <- ts(5, start = x$ref.period[1, ], end = x$ref.period[2, 
                ], frequency = 12)
            k[1] <- k[length(k)] <- -5
            polygon(k, col = "light grey", border = NA, density = 20)
            abline(v = x$ref.period[1, 1] + (x$ref.period[1, 
                2] - 1)/12, col = "grey")
            abline(v = x$ref.period[2, 1] + (x$ref.period[2, 
                2] - 1)/12, col = "grey")
        }
        grid(col = "black")
        polygon(datt.pos, col = "blue", border = NA)
        polygon(datt.neg, col = "red", border = NA)
        lines(datt, col = "dark grey")
        abline(h = 0)
        points(se, pch = 21, col = "white", bg = "black")
    }
} ylab plot(spi1, ylab = "SPI") ts par(mfrow = c(3, 4))
listofmonths <- split(fitted(spi1), cycle(fitted(spi1)))
names(listofmonths) <- month.abb

require(plyr)
l_ply(seq_along(listofmonths), function(x) {
       plot(x = seq_along(listofmonths[[x]]), y = listofmonths[[x]],
            type = "l", xlab = "", ylab = "SPI")
       title(names(listofmonths)[x])
   }) monthplot(fitted(spi1), labels = month.abb, cex.axis = 0.8)
boxplot(fitted(spi1) ~ cycle(fitted(spi1)), names = month.abb, cex.axis = 0.8)
-------------------------------------------------------------------------------------------------------
df cut() df$ag<-cut(df$trial,c(1,6,11,16,21),right=FALSE) stat_summary() stat_sum_df() stat_sum_df <- function(fun, geom="crossbar", ...) {
     stat_summary(fun.data=fun, colour="red", geom=geom, width=0.2, ...)
 } stat_sum_df() "mean_cl_normal" geom="errorbar" stat_summary() geom="line" ag scale_x_discrete() ggplot(df, aes(ag,ev,group=seeds))+stat_sum_df("mean_cl_normal",geom="errorbar")+
  stat_summary(fun.y="mean",geom="line",color="red")+
  facet_grid(ngambles~seeds)+
  scale_x_discrete(labels=c("1-5","6-10","11-15","16-20")) ddply() plyr ag library(plyr)
df.new<-ddply(df,.(ag,seeds,ngambles),summarise,ev.m=mean(ev),
      ev.lim=qt(0.975,length(ev)-1)*sd(ev)/sqrt(length(ev)))

ggplot(df.new,aes(ag,group=seeds))+
  geom_errorbar(aes(y=ev.m,ymin=ev.m-ev.lim,ymax=ev.m+ev.lim))+
  geom_line(aes(y=ev.m))+
  facet_grid(ngambles~seeds)+
  scale_x_discrete(labels=c("1-5","6-10","11-15","16-20"))
-------------------------------------------------------------------------------------------------------
ni <- seq_along(aapl_total)
nj <- seq_along(aapl_total[[1]])
nij <- as.matrix(expand.grid( ni=ni,  nj=nj))
data <- apply(nij, 1, function(ij) aapl_total[[ij]]) res <- do.call(rbind,data) labels <- as.vector(outer(c('call','put'),
                         names(aapl_total),paste0))
data <- lapply(seq(nrow(nij)), function(i) {
  data.frame(aapl_total[[nij[i,]]],type=labels[i])
})
res <- do.call(rbind,data)
-------------------------------------------------------------------------------------------------------
ls pattern "sample" list mget combn expand.grid data.frame do.call rbind sample1 <- 1:2
sample2 <- 3:4
sample3 <- 5:6

args <-mget( ls( pattern = "^sample\\d+") , env = .GlobalEnv )

res <- combn( length(args) , 2 , FUN = function(x) expand.grid(args[[x[1]]] , args[[x[2]]]) , simplify = FALSE )

do.call( rbind , res )
   Var1 Var2
1     1    3
2     2    3
3     1    4
4     2    4
5     1    5
6     2    5
7     1    6
8     2    6
9     3    5
10    4    5
11    3    6
12    4    6
-------------------------------------------------------------------------------------------------------
expand.grid my.template  <- expand.grid( unique(paste(df.1$state, df.1$district, df.1$county, sep= ' ')), year = unique(df.1$year))

my.template2 <- data.frame(do.call(rbind, strsplit(as.character(my.template$Var1), ' ')), year = my.template$year)

colnames(my.template2) <- names(df.1)[1:4]

desired.result2 <- merge(df.1, my.template2, all=TRUE)
-------------------------------------------------------------------------------------------------------
tkProgressBar tk2progress tcltk2 root <- tktoplevel()

l1 <- tk2label(root)
pb1 <- tk2progress(root, length = 300)
tkconfigure(pb1, value = 0, maximum = 9)

tkgrid(l1, row = 0)
tkgrid(pb1, row = 1)

for (index in 1:10){

    tkconfigure(l1, text = paste("Index", index))
    tkconfigure(pb1, value = index - 1)
    Sys.sleep(1)
}
-------------------------------------------------------------------------------------------------------
expand.grid() x <- seq(-3,3,0.01)
i <- 1:4
df <- expand.grid(x, i)
df$y <- exp(-abs(df$Var1)^df$Var2)

require(ggplot2)
ggplot(df, aes(x = Var1, y = y, col = factor(Var2))) +
  geom_point()
-------------------------------------------------------------------------------------------------------
# load packages
require(ggplot2)
require(plyr)
# read data 
Y <- read.table("C:/data.csv", sep=",", header=TRUE)
# define the theme
th <- theme_bw() +
  theme(axis.text.x=element_text(),  
        axis.line=element_line(colour="black"), 
        panel.grid.minor = element_blank(),
        panel.grid.major = element_blank(),
        panel.background=element_blank(),
        legend.justification=c(10,10), legend.position=c(10,10), 
        legend.title = element_text(),
        legend.key = element_blank()
        )
# determine park levels
parks <- levels(Y[,"Park_name"])
# apply seperately for each park
p <- lapply(parks, function(park) {
ggplot(Y[Y[, "Park_name"]==park,], aes(x=as.factor(Year), y=Height_mm)) +
  facet_grid(Zone~.) + # show each zone in a seperate facet
  geom_point() + # plot the actual heights (if desired)
  # plot the mean and confidence interval
  stat_summary(fun.data="mean_cl_boot", color="red") 
})       
# finally print your plots
lapply(p, function(x) print(x+th))
-------------------------------------------------------------------------------------------------------
scale="free_x" facet_grid() x ggplot() stat_summary() tdat$int<-with(tdat,interaction(Condition,variable,drop=TRUE,sep='-'))
ggplot(tdat,aes(int,value,fill=Condition))+
  stat_summary(fun.y='mean', geom='bar')+
  geom_point()+
  facet_grid(.~variable,scales="free_x") interaction() facet_grid() ggplot(tdat,aes(Condition,value,fill=Condition))+
  stat_summary(fun.y='mean', geom='bar')+
  geom_point()+
  facet_grid(.~variable)
-------------------------------------------------------------------------------------------------------
interaction geom_bar set.seed(10)
library(reshape2)
test.m <- melt(test,measure.vars=c('x','y'))
ggplot(test.m)+
  geom_bar(aes(x=interaction(yr,mth),y=value,
                 fill=variable),stat='identity',position='dodge')+
  facet_grid(modeltype~siteloc)
-------------------------------------------------------------------------------------------------------
interaction testm = melt(test, id=c('siteloc', 'modeltype', 'mth', 'yr'))

# by color
ggplot(testm, aes(x=siteloc, y=modeltype, size=value, colour=variable)) +
  geom_point(shape=21, position="jitter") +
  facet_grid(mth~yr) +
  scale_size_area(max_size=40) +
  scale_shape(solid=FALSE) +
  theme_bw() #by shape
testm$shape = as.factor(with(testm, ifelse(variable=='x', 21, 25)))

ggplot(testm, aes(x=siteloc, y=modeltype, size=value, shape=shape)) +
  geom_point(position="jitter") +
  facet_grid(mth~yr) +
  scale_size_area(max_size=40) +
  scale_shape(solid=FALSE) +
  theme_bw() # by shape and color
ggplot(testm, aes(x=siteloc, y=modeltype, size=value, colour=variable, shape=shape)) +
  geom_point(position="jitter") +
  facet_grid(mth~yr) +
  scale_size_area(max_size=40) +
  scale_shape(solid=FALSE) +
  theme_bw() melt test$shape = as.factor(with(test, ifelse(x/y>1, 25, 21)))
test$ratio = with(test, ifelse(x/y>1, x/y, y/x))

ggplot(test, aes(x=siteloc, y=modeltype, size=ratio, colour=shape, shape=shape)) +
  geom_point() +
  facet_grid(mth~yr) +
  scale_size_area(max_size=40) +
  scale_shape(solid=FALSE) +
  theme_bw()
-------------------------------------------------------------------------------------------------------
which scales facet_grid plot <- ggplot(df[which(df$prop>0),], aes(X5employff, prop)) +
  geom_bar(aes(fill=X5employff, stat="identity")) +
  facet_grid( ~ X5employf, scales="free_x") +
  theme_bw()
plot
-------------------------------------------------------------------------------------------------------
grid.multipanel() require(grid)
require(mvtnorm)

set.seed(271)
X <- rmvnorm(100, mean=1:4, sigma=diag(4:1)) # goal: draw this in a pairs plot

panelGrob <- function(x=runif(10, -10, 10), y=runif(10, -10, 100), ...,
  xlim = range(x), ylim=range(y),
  axis.x=TRUE, axis.y=TRUE){
  xx <- pretty(x) ; yy <- pretty(y)
  xx <- xx[xx <= xlim[2] & xx >= xlim[1]]
  yy <- yy[yy <= ylim[2] & yy >= ylim[1]]

  r <- rectGrob()
  dvp <- dataViewport(xData=xx, yData=yy)
  p <- pointsGrob(x, y, pch=".", gp=gpar(col="red"), default.units="native",
                  vp = dvp)

  ax <- if(axis.x) xaxisGrob(at=xx, vp=dvp) else nullGrob()
  ay <- if(axis.y) yaxisGrob(at=yy, vp=dvp) else nullGrob()

  grobTree(r, ax, ay, p, ...)
}

grid.panel <- function(...)
  grid.draw(panelGrob(...))

grid.newpage()
grid.panel(vp=viewport(width=0.8, height=0.8))


pairsGrob <- function(X, ..., name=NULL, gp=NULL, vp=NULL){

  N <- NCOL(X)
  layout <- grid.layout(N+1, N+1, 
                        widths=unit(c(2, rep(1, N)), c("lines", rep("null", N))), 
                        heights = unit(c(rep(1, N), 2), c(rep("null", N), "lines")))


  wrap <- function(ii, jj, ...){
    panelGrob(X[,ii], X[,jj], ..., axis.x= ii == N, axis.y = jj == 1,
              vp=viewport(layout.pos.row=ii, layout.pos.col=jj+1))
  }

  rowcol <- expand.grid(ii=seq_len(N), jj=seq_len(N))
  gl <- mapply(wrap, ii=rowcol[,"ii"], jj=rowcol[,"jj"], MoreArgs=list(...),
               SIMPLIFY=FALSE)

  gTree(children=do.call(gList, gl), vp=viewport(layout=layout))
}

grid.pairs <- function(...) grid.draw(pairsGrob(...))

grid.newpage()
grid.pairs(X, xlim=c(-10,10), ylim=c(-10,10)) args(lattice::panel.xyplot)
-------------------------------------------------------------------------------------------------------
expand.grid dat <- expand.grid(aql = c(0.01,0.05),prp = c(0.95),
            def = c(0.06,0.1,0.15), crp = c(0.05,0.08,0.10)) data.table library(data.table)
DT <- as.data.table(dat)
DT[, c('n','Ac') := list(find.plan(PRP=c(aql,prp),CRP=c(def,crp))$n,
                         find.plan(PRP=c(aql,prp),CRP=c(def,crp))$c),
                           by = 1:nrow(DT)]

    aql  prp  def  crp    n  Ac
 1: 0.01 0.95 0.06 0.05  127   3
 2: 0.05 0.95 0.06 0.05 5626 308
 3: 0.01 0.95 0.10 0.05   61   2
 4: 0.05 0.95 0.10 0.05  298  21
 5: 0.01 0.95 0.15 0.05   30   1
 6: 0.05 0.95 0.15 0.05   93   8
 7: 0.01 0.95 0.06 0.08  116   3
 8: 0.05 0.95 0.06 0.08 4826 266
 9: 0.01 0.95 0.10 0.08   55   2
10: 0.05 0.95 0.10 0.08  251  18
11: 0.01 0.95 0.15 0.08   27   1
12: 0.05 0.95 0.15 0.08   79   7
13: 0.01 0.95 0.06 0.10  110   3
14: 0.05 0.95 0.06 0.10 4445 246
15: 0.01 0.95 0.10 0.10   52   2
16: 0.05 0.95 0.10 0.10  233  17
17: 0.01 0.95 0.15 0.10   25   1
18: 0.05 0.95 0.15 0.10   77   7 find.plan mapply cbind(dat,with(dat,t(mapply(function(x,y,z,t)
                 find.plan(c(x,y),c(z,t)),aql,prp,def,crp))))

  aql  prp  def  crp    n   c   r
1  0.01 0.95 0.06 0.05  127   3   4
2  0.05 0.95 0.06 0.05 5626 308 309
3  0.01 0.95 0.10 0.05   61   2   3
4  0.05 0.95 0.10 0.05  298  21  22
5  0.01 0.95 0.15 0.05   30   1   2
6  0.05 0.95 0.15 0.05   93   8   9
7  0.01 0.95 0.06 0.08  116   3   4
8  0.05 0.95 0.06 0.08 4826 266 267
9  0.01 0.95 0.10 0.08   55   2   3
10 0.05 0.95 0.10 0.08  251  18  19
11 0.01 0.95 0.15 0.08   27   1   2
12 0.05 0.95 0.15 0.08   79   7   8
13 0.01 0.95 0.06 0.10  110   3   4
14 0.05 0.95 0.06 0.10 4445 246 247
15 0.01 0.95 0.10 0.10   52   2   3
16 0.05 0.95 0.10 0.10  233  17  18
17 0.01 0.95 0.15 0.10   25   1   2
18 0.05 0.95 0.15 0.10   77   7   8
-------------------------------------------------------------------------------------------------------
install.packages("AcceptanceSampling")
library(AcceptanceSampling)

df <- expand.grid(
  aql = c(0.01,0.05),
  prp = c(0.95),
  def = c(0.06,0.1,0.15),
  crp = c(0.05,0.08,0.10)
)

findpl <- do.call(
  rbind,
  by(df,df,function(x) {
    i <- find.plan(c(x$aql,x$prp),c(x$def,x$crp))
    c(n=i$n,Ac=i$c)
    }
  )
)

result <- data.frame(df,findpl)

head(result)

   aql  prp  def  crp    n  Ac
1 0.01 0.95 0.06 0.05  127   3
2 0.05 0.95 0.06 0.05 5626 308
3 0.01 0.95 0.10 0.05   61   2
4 0.05 0.95 0.10 0.05  298  21
5 0.01 0.95 0.15 0.05   30   1
6 0.05 0.95 0.15 0.05   93   8
-------------------------------------------------------------------------------------------------------
set.seed(1)

getRewardsGaussian <- function(arms, plays) {
## assuming each action has a normal distribution 

  # first generate new means
  QStar <- rnorm(arms, 0, 1)

  # then for each mean, generate `play`-many samples
  sapply(QStar, function(u)
    rnorm(plays, u, 1))
}


CalculateRewardsPerMethod <- function(arms=7, epsi1=0.01, epsi2=0.1
                    , plays=1000, methods=c("greedy", "epsi1", "epsi2")) {

  # names for easy handling
  names(methods) <- methods
  arm.names <- paste0("Arm", ifelse((1:arms)<10, 0, ""), 1:arms)

  # this could be different if not all actions' rewards have a gaussian dist.
  rewards.source <- getRewardsGaussian(arms, plays) 

  # Three dimensional array to track running averages of each method
  running.avgs <- 
    array(0, dim=c(plays, arms, length(methods))
           , dimnames=list(PlayNo.=NULL, Arm=arm.names, Method=methods))

  # Three dimensional array to track the outcome of each play, according to each method 
  rewards.received <- 
    array(NA_real_, dim=c(plays, 2, length(methods))
                  , dimnames=list(PlayNo.=seq(plays), Outcome=c("Arm", "Reward"), Method=methods))


  # define the function internally to not have to pass running.avgs 
  chooseAnArm <- function(p) {
    # Note that in a tie, which.max returns the lowest value, which is what we want
    maxes <- apply(running.avgs[p, ,methods, drop=FALSE], 3, which.max)

    # Note: deliberately drawing two separate random numbers and keeping this as 
    #       two lines of code to accent that the two draws should not be related 
    if(runif(1) < epsi1)
      maxes["epsi1"] <- sample(arms, 1)

    if(runif(1) < epsi2)
      maxes["epsi2"] <- sample(arms, 1)

    return(maxes)
  }

  ## TODO:  Perform each action at least once, then select according to algorithm
  ## Starting points. Everyone starts at machine 3
  choice <- c(3, 3, 3)
  reward <- rewards.source[1, choice]
  ## First run, slightly different
  rewards.received[1,,] <- rbind(choice, reward)
  running.avgs[1, choice, ] <- reward # if different starting points, this needs to change like below

  ## HERE IS WHERE WE START PULLING THE LEVERS ##
  ## ----------------------------------------- ##
  for (p in 2:plays) {
    choice <- chooseAnArm(p)
    reward <- rewards.source[p, choice]

    # Note: When dropping a dim, the methods will be the columns 
    #       and the Outcome info will be the rows. Use `rbind` instead of `cbind`.
    rewards.received[p,,names(choice)] <- rbind(choice, reward)

    ## Update the running averages. 
    ## For each method, the current running averages are the same as the
    ##    previous for all arms, except for the one chosen this round.
    ##    Thus start with last round's averages, then update the one arm.
    running.avgs[p,,] <- running.avgs[p-1,,]

    # The updating is only involved part (due to lots of array-indexing)
    running.avgs[p,,][cbind(choice, 1:3)] <- 
     sapply(names(choice), function(m) 
       # Update the running average for the selected arm (for the current play & method) 
          mean( rewards.received[ 1:p,,,drop=FALSE][ rewards.received[1:p,"Arm",m] == choice[m],"Reward",m])
     )
  } # end for-loop


  ## DIFFERENT RETURN OPTIONS ##
  ## ------------------------ ##


  ## All rewards received, in simplifed matrix (dropping information on arm chosen)
  # return(rewards.received[, "Reward", ])

  ## All rewards received, along with which arm chosen: 
  #   return(rewards.received)

  ## Running averages of the rewards received by method
  return( apply(rewards.received[, "Reward", ], 2, cumsum) / (1:plays) )

}


### EXECUTION (AND SIMULATION)

## PARAMETERS
arms   <- 10
plays  <- 1000
epsi1  <- 0.01
epsi2  <- 0.1
simuls <- 50  # 2000
methods=c("greedy", "epsi1", "epsi2")

## Single Iteration: 
### we can run system time to get an idea for how long one will take
tme <- system.time( CalculateRewardsPerMethod(arms=arms, epsi1=epsi1, epsi2=epsi2, plays=plays) )
cat("Expected run time is approx: ", round((simuls * tme[["elapsed"]]) / 60, 1), " minutes")

## Multiple iterations (simulations)
rewards.received.list <- replicate(simuls, CalculateRewardsPerMethod(arms=arms, epsi1=epsi1, epsi2=epsi2, plays=plays), simplify="array")

## Compute average across simulations
rewards.received <- apply(rewards.received.list, 1:2, mean)

## RESULTS
head(rewards.received, 17)
MeanRewards <- rewards.received

## If using an alternate return method in `Calculate..` use the two lines below to calculate running avg
#   CumulRewards <- apply(rewards.received, 2, cumsum)
#   MeanRewards  <- CumulRewards / (1:plays)

## PLOT
plot.ts(MeanRewards[, "greedy"], col = 'red', lwd = 2, ylim = range(MeanRewards), ylab = 'Average reward', xlab="Plays")
  lines(MeanRewards[, "epsi1"], col = 'orange', lwd = 2)
  lines(MeanRewards[, "epsi2"], col = 'navy', lwd = 2)
  grid(col = 'darkgray')

  legend('bottomright', c('greedy', paste("epsi1 =", epsi1), paste("epsi2 =", epsi2)), col = c('red', 'orange', 'navy'), lwd = 2, cex = 0.8)
-------------------------------------------------------------------------------------------------------
scales='free_y' facet_grid ?facet_grid library(ggplot2)
library(reshape2)

df <- read.data('clipboard', header=TRUE)

tmp <- cbind(df$x, melt(df[, -1]))
names(tmp) <- c("x", "variable", "value")

ggplot(tmp, aes(x=x)) + 
  geom_bar(stat = "identity" ) + 
  facet_grid(variable ~ ., scales='free_y')
-------------------------------------------------------------------------------------------------------
get.testbed = function(arms = 10, plays = 500, u = 0, sdev.arm = 1, sdev.rewards = 1){

  optimal = rnorm(arms, u, sdev.arm)
  rewards = sapply(optimal, function(x)rnorm(plays, x, sdev.rewards))

  list(optimal = optimal, rewards = rewards)
}

play.slots = function(arms = 10, plays = 500, u = 0, sdev.arm = 1, sdev.rewards = 1, eps = 0.1){

  testbed = get.testbed(arms, plays, u, sdev.arm, sdev.rewards)
  optimal = testbed$optimal
  rewards = testbed$rewards

  optim.index = which.max(optimal)
  slot.rewards = rep(0, arms)
  reward.hist = rep(0, plays)
  optimal.hist = rep(0, plays)
  pulls = rep(0, arms)
  probs = runif(plays)

  # vetorizar
  for (i in 1:plays){

      ## dont use ifelse() in this case
      ## idx = ifelse(probs[i] < eps, sample(arms, 1), which.max(slot.rewards))

      idx = if (probs[i] < eps) sample(arms, 1) else which.max(slot.rewards)
      reward.hist[i] = rewards[i, idx]

      if (idx == optim.index)
        optimal.hist[i] = 1

      slot.rewards[idx] = slot.rewards[idx] + (rewards[i, idx] - slot.rewards[idx])/(pulls[idx] + 1)
      pulls[idx] = pulls[idx] + 1
  }

  list(slot.rewards = slot.rewards, reward.hist = reward.hist, optimal.hist = optimal.hist, pulls = pulls)
}

do.simulation = function(N = 100, arms = 10, plays = 500, u = 0, sdev.arm = 1, sdev.rewards = 1, eps = c(0.0, 0.01, 0.1)){

  n.players = length(eps)
  col.names = paste('eps', eps)
  rewards.hist = matrix(0, nrow = plays, ncol = n.players)
  optim.hist = matrix(0, nrow = plays, ncol = n.players)
  colnames(rewards.hist) = col.names
  colnames(optim.hist) = col.names

  for (p in 1:n.players){
    for (i in 1:N){
      play.results = play.slots(arms, plays, u, sdev.arm, sdev.rewards, eps[p])
      rewards.hist[, p] = rewards.hist[, p] + play.results$reward.hist
      optim.hist[, p] = optim.hist[, p] + play.results$optimal.hist
    } 
  }

  rewards.hist = rewards.hist/N
  optim.hist = optim.hist/N
  optim.hist = apply(optim.hist, 2, function(x)cumsum(x)/(1:plays))

  ### Plot helper ###
  plot.result = function(x, n.series, colors, leg.names, ...){
    for (i in 1:n.series){
      if (i == 1)
        plot.ts(x[, i], ylim = 2*range(x), col = colors[i], ...)
      else
        lines(x[, i], col = colors[i], ...)
      grid(col = 'lightgray')
    }
    legend('topleft', leg.names, col = colors, lwd = 2, cex = 0.6, box.lwd = NA)
  }
  ### Plot helper ###

  #### Plots ####
  require(RColorBrewer)
  colors = brewer.pal(n.players + 3, 'Set2')
  op <-par(mfrow = c(2, 1), no.readonly = TRUE)

  plot.result(rewards.hist, n.players, colors, col.names, xlab = 'Plays', ylab = 'Average reward', lwd = 2)
  plot.result(optim.hist, n.players, colors, col.names, xlab = 'Plays', ylab = 'Optimal move %', lwd = 2)
  #### Plots ####

  par(op)
} do.simulation(N = 100, arms = 10, eps = c(0, 0.01, 0.1))
-------------------------------------------------------------------------------------------------------
x<-rnorm(100, 12, 3)
y<-rnorm(100, 34, 45)
plot(x,y)

clip(x1=min(x), x2=max(x), y1=min(y), y2=max(y))
grid(NA, 25, lwd = 2) ny <- 25
U <- par("usr")
at <- seq.int(U[3L], U[4L], length.out = ny + 1)
Y <- at[-c(1, ny + 1)]
-------------------------------------------------------------------------------------------------------
> print(data.frame(n=2:3, x=1:6))
- n x
1 2 1
2 3 2
3 2 3
4 3 4
5 2 5
6 3 6 > print(expand.grid(x=1:5, n=2:3))
-  x n
1  1 2
2  2 2
3  3 2
4  4 2
5  5 2
6  1 3
7  2 3
8  3 3
9  4 3
10 5 3 lapply(2:3, FUN=function(n) (f(n, x=1:5)))
#[[1]]
#[1] 0.0004981910 0.0006066275 0.0007328627 0.0008786344 0.0010456478
#
#[[2]]
#[1] 0.0007464956 0.0009087272 0.0010974595 0.0013152213 0.0015644676 wrapper <- function(i, x, n, fti){
    # As was provided by OP
    g<-function(x) {do.call(paste("d",i,sep=""),c(list(x=x),fti$estimate))}

    G<-function(x) {do.call(paste("p",i,sep=""),c(list(q=x),fti$estimate))}
    # does the i in fti refer to fit of i:th distribution, i.e. should it be a list where i:th location in ft is i:th distribution estimates?

    f<-function(n,x) {n*g(x)*(1-G(x))^(n-1)}
    # was missing a '-' and a '}'

    h<- function(n) {integrate(function(x) {x*f(n,x)},0,Inf)}

    list(gres = g(x), Gres = G(x), fres = f(n,x), hres = h(n))
}

# Example data
require("fitdistrplus")
data(groundbeef)
serving <- groundbeef$serving

# Gumbel distribution
d1 <- function(x, a, b) 1/b*exp((a-x)/b)*exp(-exp((a-x)/b))
p1 <- function(q, a, b) exp(-exp((a-q)/b))
q1 <- function(p, a, b) a-b*log(-log(p))

fti1 <- fitdist(serving, "1", start=list(a=10, b=10))
#> fti1$estimate
#       a        b 
#56.95893 29.07871

# Normal distribution

# dnorm, pnorm and qnorm are available in the default environment
d2 <- dnorm
p2 <- pnorm
q2 <- qnorm

fti2 <- fitdist(serving, "2", start=list(mean=0, sd=1))
#> fti2$estimate
#    mean       sd 
#73.67743 35.92581

# Sequence of x-values
xs <- seq(-100, 100, by=1)

print((resultdist1n2 <- wrapper(i=1, x=xs, n=2, fti=fti1))$hres)
print((resultdist1n3 <- wrapper(i=1, x=xs, n=3, fti=fti1))$hres)
print((resultdist2n2 <- wrapper(i=2, x=xs, n=2, fti=fti2))$hres)
print((resultdist2n3 <- wrapper(i=2, x=xs, n=3, fti=fti2))$hres)

plot(xs, resultdist1n2$fres, col=1, type="l", ylim=c(0,0.025), xlab="x", ylab="f(n, x)")
points(xs, resultdist1n3$fres, col=2, type="l")
points(xs, resultdist2n2$fres, col=3, type="l")
points(xs, resultdist2n3$fres, col=4, type="l")
legend("topleft", legend=c("Gamma (i=1) n=2", "Gamma (i=1) n=3", "Normal (i=2) n=2", "Normal (i=2) n=3"), col=1:4, lty=1) h(n=2) for distribution i=1:
53.59385 with absolute error < 0.00022
h(n=3) for distribution i=1:
45.23146 with absolute error < 4.5e-05
h(n=2) for distribution i=2:
53.93748 with absolute error < 1.1e-05
h(n=3) for distribution i=2:
44.06331 with absolute error < 2e-05 ns <- 0:256
res1 <- lapply(ns, FUN=function(nseq) wrapper(i=1, x=xs, n=nseq, fti=fti1))
par(mfrow=c(1,2))
plot.new()
plot.window(xlim=c(-100,100), ylim=c(0, 0.05))
box(); axis(1); axis(2); title(xlab="x", ylab="f(n,x)", main="f(n,x) for gamma (i=1), n=0:256")
for(i in 1:length(ns)) points(xs, res1[[i]]$fres, col=rainbow(257)[i], type="l")
# perform similarly for the other distributions by calling with i=2, fti=fti2
# h as a function of n for dist i=1
plot(ns, unlist(lapply(res1, FUN=function(x) x$hres$value)), col=rainbow(257), xlab="n", ylab="h(n)", main="h(n) for gamma (i=1), n=0:256")
-------------------------------------------------------------------------------------------------------
#some data
set.seed(42)
x1 <- rnorm(20)
x2 <- runif(20)
x3 <- rpois(20,10)
x4 <- rexp(20)
y <- 10 + 2*x1 + 3*x2^2 + 4*x3 +5*x4 + rnorm(20, sd=0.1)

dat <- data.frame(x1, x2, x3, x4, y)

#fit the model
fit <- lm(y~x1+I(x2^2)+x3+x4, data=dat)
summary(fit)

#ranges and fixed values
fix_x <- c(0.3, 0.4, 15, 1)
min_x <- c(-3, 0, 5, 0)
max_x <- c(3, 1, 20, 7)

#all combinations
combis <- combn(seq_len(ncol(dat)-1),2)
#number of x-values 
#(warning! don't make too large since expand.grid is used)
n <- 100

#create new data and predict for each combination
newdat <- lapply(seq_len(ncol(combis)),
                 function(i) {
                   gr <- expand.grid(seq(from=min_x[combis[1,i]],to=max_x[combis[1,i]],length.out=n),
                                     seq(from=min_x[combis[2,i]],
                                         to=max_x[combis[2,i]],
                                         length.out=n))

                   newdat <- as.data.frame(matrix(nrow=nrow(gr), ncol=ncol(dat)-1))
                   newdat[,combis[,i]] <- gr
                   newdat[,-combis[,i]] <- matrix(rep(fix_x[-combis[,i]],each=nrow(gr)), nrow=nrow(gr))

                   newdat <- as.data.frame(newdat)
                   names(newdat) <- head(names(dat),-1)

                   newdat$y <- predict(fit, newdata=newdat)

                   newdat$comb <- paste(combis[,i],collapse=" vs. ")
                   #rename so rbind works as needed
                   names(newdat)[combis[,i]] <- c("xa","xb")
                   names(newdat)[-combis[,i]] <- c(paste0("fix",letters[seq_len(ncol(dat)-3)]), "y", "comb")
                   newdat
                 })

newdat <- do.call(rbind,newdat)

#plot
library(ggplot2)
ggplot(newdat, aes(x=xa, y=xb, z=y)) + 
  stat_contour() + 
  facet_wrap(~comb, scales="free", ncol=2) +
  xlab("") +
  ylab("")
-------------------------------------------------------------------------------------------------------
grid.arrange require(plyr)
## Ordered data
datOrder <- ddply(dataSummary, c("Condition", "Parameter"), function(x){
  if (nrow(x)<=1) return(x)
  x$MeanWeight <- x$MeanWeight[order(x$MeanWeight)]
  x
})
## Plot
ggplot(datOrder, aes(x=MeanWeight, y=SubjectID)) + 
  scale_x_continuous(limits=c(-3, 3)) + 
  geom_vline(yintercept = 0.0, size = 0.1, colour = "#a9a9a9", linetype = "solid") + 
  geom_segment(aes(yend=SubjectID), xend=0, colour="grey50") + 
  geom_point(size=2) + 
  facet_grid(Parameter~Condition) +
  scale_y_discrete(name="Ordered subjects")
-------------------------------------------------------------------------------------------------------
facet_grid() theme(aspect.ratio=1) # Create a new factor column for faceting.
newfactor = ifelse(all_states$weco, "weco", 
                           ifelse(all_states$west, "west", "east"))

# Manually specify sort order of factor levels.
newfactor = factor(as.character(newfactor), levels=c("weco", "west", "east"))

all_states$region = newfactor

plot_1 = ggplot(all_states, aes(x=long, y=lat, group=group)) + 
         geom_polygon(colour="white", fill="grey") + 
         facet_grid(. ~ region, space="free", scales="free") + 
         theme(aspect.ratio=1)

ggsave("plot_1.png", plot=plot_1, height=4, width=8, dpi=150)
-------------------------------------------------------------------------------------------------------
expand.grid > expand.grid(df[1,1],halfway[[1]])
  Var1  Var2
1   X1   foo
2   X1   bar
3   X1 hello apply threequarterway <- lapply(seq(nrow(df)),function(i) expand.grid(df[i,1],halfway[[i]])) do.call df2 <- do.call(rbind,threequarterway) df2 = df2[!is.na(df2[,2]),] expand.grid
-------------------------------------------------------------------------------------------------------
require(ff)
a=as.ffdf(data.frame(a=1:10,b=11:20))
z=as.ffdf(data.frame(y=2:4))

require(ffbase)
a$a.key <- ikey(a)
z$z.key <- ikey(z)
combined <- expand.ffgrid(a.key = a$a.key, z.key = z$z.key)
combined <- merge(combined, a, by.x="a.key", by.y="a.key", all.x=TRUE, all.y=FALSE)
combined <- merge(combined, z, by.x="z.key", by.y="z.key", all.x=TRUE, all.y=FALSE)
-------------------------------------------------------------------------------------------------------
# a (minimal) data frame with all unique source-county combinations
src_cnt <- data.frame(source = c("Morning Call", "AP", "AP", "AP"), county = c("Lehigh", "Lehigh", "Mercer", "Phila"))

# a data frame with a unique score for each source
src_score <- data.frame(source = c("Morning Call", "AP"), score = c(10, 3))

merge(src_cnt, src_score) # Assuming your current data is named dd
# select the national sources, i.e. the sources where County is missing
src_national <- dd$Source[is.na(dd$County)])

# select unique counties
counties <- unique(dd$County[!is.na(dd$County)])

# create all combinations of national sources and counties
src_cnt <- expand.grid(Source = src_national, County = counties)

# add score from current data to national sources
src_cnt2 <- merge(src_cnt, dd[is.na(dd$County), c("Source", "Score")], by = "Source")

# add national sources to local sources in dd
dd2 <- rbind(dd[!is.na(dd$County), ], src_cnt2)

# order by Sourcy and County
# assuming desired data is named `desired`
library(plyr)
desired2 <- arrange(df = desired, Source, County) 
dd2 <- arrange(df = dd2, Source, County)
all.equal(desired2, dd2) rbind src_cnt County.Name dd2
-------------------------------------------------------------------------------------------------------
require(gtable)
# let's fix this name before it's too late
gtable_add_grobs <- gtable_add_grob

base <- gtable(widths=unit(rep(1, 2), "null"),
               heights=unit(rep(1, 3), "null"))
grid.newpage()
g <- 1
for(i in 1:3) {
    for(j in 1:2) {
        base <- gtable_add_grobs(base,
                                grobs=list(rectGrob(gp=gpar(fill="#FF0000")),
                                           linesGrob(x=1:4, y=4:1, def="native", 
                                                     vp=dataViewport(1:4, 1:4)),
                                           textGrob(label=g)), i, j, name=1:3)
        g <- g+1
    }
}
grid.draw(base) gtable_add_grobs library(gtable)

g <- gtable(widths = unit(c(1,1), "null"),
            heights = unit(c(1,1), "null"))


cell <- function(ii)
  grobTree(rectGrob(), 
           linesGrob(1:4, 1:4, default.units="native"), 
           textGrob(ii),
           vp=dataViewport(c(1,4), c(1,4)))

gl <- lapply(1:4, cell)

xy <- expand.grid(1:2, 1:2)

g <- gtable_add_grobs(g, gl, 
                      l=xy[,1],
                      r=xy[,1],
                      t=xy[,2],
                      b=xy[,2])


grid.newpage()
grid.draw(g)
-------------------------------------------------------------------------------------------------------
# Enumerate the transformations (the dihedral group of order 8)
k <- 5
d1 <- expand.grid( 1:k, 1:k ) 
d2 <- expand.grid( k:1, 1:k ) 
d3 <- expand.grid( 1:k, k:1 ) 
d4 <- expand.grid( k:1, k:1 )
o1 <- order(d1[,1], d1[,2])
o2 <- order(d2[,1], d2[,2])
o3 <- order(d3[,1], d3[,2])
o4 <- order(d4[,1], d4[,2])
o5 <- order(d1[,2], d1[,1])
o6 <- order(d2[,2], d2[,1])
o7 <- order(d3[,2], d3[,1])
o8 <- order(d4[,2], d4[,1])
g1 <- function(p) o1[p]
g2 <- function(p) o2[p]
g3 <- function(p) o3[p]
g4 <- function(p) o4[p]
g5 <- function(p) o5[p]
g6 <- function(p) o6[p]
g7 <- function(p) o7[p]
g8 <- function(p) o8[p]
transformations <- list(g1,g2,g3,g4,g5,g6,g7,g8)

# Check that we have all the transformations
op <- par(mfrow=c(3,3), las=2, mar=c(1,1,1,1))
for( f in transformations ) { 
  plot( d1 )
  lines( d1[f(1:10),] )
}
par(op)

# Function to decide whether to keep a value
library(digest)
keep <- function(p, d) {
  q0 <- digest( d[ sort(p), , drop=FALSE] )
  q <- sapply( transformations, function(f) digest( d[ sort(f(p)), , drop=FALSE ] ) )
  q0 == sort(q)[1]
}

# Apply the function on each column    
i <- apply(combo, 2, keep, d=d1)  # Long...
length(i) / sum(i)   # Around 8 (not exactly, because some of those combinations are symmetric)
result <- combo[,i] apply( equiv, 1, keep, d=d1 )
#    p1    p2    p3    p4    p5    p6    p7    p8 
# FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE
-------------------------------------------------------------------------------------------------------
plot1 <- ggplot(data=df, aes(x=xval, y=yval, group=cond, colour=cond) ) +
         geom_smooth(aes(ymin = yval-se, ymax = yval+se,
                     linetype=cond, colour=cond, fill=cond), stat="identity",
                     size=1.1) +
         scale_colour_hue(l=25) +
         ylim(-0.1,1.3) + scale_linetype_manual(values = c('a' = 1,'b' = 2))

plot1 + facet_grid(~ zval, scales="free_y") + 
theme(strip.text.x = element_blank(),
      strip.background = element_rect(colour="white", fill="white"),
      legend.position=c(.9,.75)
      )
-------------------------------------------------------------------------------------------------------
x <- seq(-124.25,length=115,by=0.5)    
y <- seq(26.25,length=46,by=0.5)
z <- 1:5290
w <- rep(1:5,1058)
longlat <- expand.grid(x = x, y = y)
pts <- data.frame(longlat,z,w) 
names(pts) <- c( "lon","lat","data","class")

require('ggmap')
base.map.in <- get_map(location = c(min(x),
                                    min(y),
                                    max(x),
                                    max(y)),
                       source = "osm")
# create the map object
theme_set(theme_bw(base_size = 8))
my.map <- ggmap(base.map.in) %+% pts + 
  aes(x = lon,
      y = lat) +
  geom_point(aes(color = as.factor(class),
             size = data),
             alpha = 0.5) +
  scale_size(range = c(0.5,2))
print(my.map)


ggsave(filename = "classmap.png",
       plot = my.map,
       scale = 1,
       width = 6, height = 3,
       dpi = 300)
-------------------------------------------------------------------------------------------------------
all <- expand.grid(p1 = letters[1:3], p2 = letters[1:3], p3 = letters[1:3], stringsAsFactors = FALSE) 
perms <- all[apply(all, 1, function(x) {length(unique(x)) == 3}),]
-------------------------------------------------------------------------------------------------------
> df <- data.frame(name=rep(name, each=12), 
                   reading=unlist(sapply(reading, strsplit, split="")))
> df
               name reading
yyyggrggryyy1    t1       y
yyyggrggryyy2    t1       y
yyyggrggryyy3    t1       y
yyyggrggryyy4    t1       g
snipped
grgrgrrryyyy4    t2       r
grgrgrrryyyy5    t2       g
grgrgrrryyyy6    t2       r
grgrgrrryyyy7    t2       r
grgrgrrryyyy8    t2       r
grgrgrrryyyy9    t2       y
grgrgrrryyyy10   t2       y
grgrgrrryyyy11   t2       y
grgrgrrryyyy12   t2       y

 qplot(reading,  data=df, geom="bar")+facet_grid(~name) qplot(x=name,  data=df)+facet_grid(~name)+geom_bar(aes(fill = reading))
-------------------------------------------------------------------------------------------------------
library(ggplot2)
m<-strsplit(as.character(df$reading),"") # split the strings 
data1<-as.data.frame(table(m[[1]])) # create dataframe for first element of reading
data2<-as.data.frame(table(m[[2]])) # create dataframe for second element of reading
t<-rep(c("t1","t2"),c(dim(data1)[1],dim(data2)[1])) 
t<-as.data.frame(t) # create dataframe of t which gives t1 and t2
mydata<-cbind(rbind(data1,data2),t)  #final data for plot
mydata$reading<-mydata$Var1
qplot(reading, data=mydata, geom="bar",weight=Freq)+facet_grid(~t)
-------------------------------------------------------------------------------------------------------
## use white->yellow for the x-axis and white->blue for the y-axis
chooseColors <- function(x, y) {
  x <- 1-x/max(x)
  y <- 1-y/max(y)
  return(rgb(green=y, red=y, blue=x))
}


## example values for the whole range
values <- expand.grid(1:100, 1:100)

## plot it
plot(values, col=chooseColors(values[,1], values[,2]), pch=16) set.seed(1)
n <- 50
values <- cbind(sample(1:15, size=n, replace=TRUE), sample(1:15, size=n, replace=TRUE))

## plot it
plot(values, col=chooseColors(values[,1], values[,2]), pch=16)
-------------------------------------------------------------------------------------------------------
# example data
test <- expand.grid(opt1=0:1,opt2=0:1)
# create a unique identifier to represent the binary variables
test$code <- with(allopts,paste(opt1,opt2,sep=""))
# create an input variable to be used in functions
test$var1 <- 1:4

#  opt1 opt2 code var1
#1    0    0   00    1
#2    1    0   10    2
#3    0    1   01    3
#4    1    1   11    4 var1 + 10    #code 00 - intended result =   11
var1 + 100   #code 10 - intended result =  102
var1 + 1000  #code 01 - intended result = 1003
var1 + var1  #code 11 - intended result =    8 ifelse test$result <- with(test,
  ifelse(code == "00", var1 + 10,
  ifelse(code == "10", var1 + 100,
  ifelse(code == "01", var1 + 1000,
  ifelse(code == "11", var1 + var1,
  NA
))))) opt1 opt2 code var1 result
1    0    0   00    1     11
2    1    0   10    2    102
3    0    1   01    3   1003
4    1    1   11    4      8
-------------------------------------------------------------------------------------------------------
colnames(x) <- LETTERS[6:10] expand.grid rowCol <- expand.grid(rownames(x), colnames(x)) labs <- rowCol[as.vector(upper.tri(x,diag=F)),]
df <- cbind(labs, x[upper.tri(x,diag=F)])
colnames(df) <- c("Row","Col","Val")
df[,c(2,1,3)]
##    Col Row Val
## 6    G   A   6
## 11   H   A  11
## ...
-------------------------------------------------------------------------------------------------------
fit <- lm(x ~ y) expand.grid predict(fit, newdata)
 x y geom_tile height width geom_tile() dput() set.seed(42)
x1 <- rnorm(20)
x2 <- runif(20)
x3 <- rpois(20,10)
x4 <- rexp(20)
y <- 10 + 2*x1 + 3*x2^2 + 4*x3 +5*x4 + rnorm(20, sd=0.1)

dat <- data.frame(x1, x2, x3, x4, y)

# vector of variable names for easy data.frame column naming later
var_names <- c("x1", "x2", "x3", "x4")

# possible combinations of four variables
combis <- combn(1:4, 2)
combis <- rbind(combis, combis[, 6:1])

# steps to generate for the contour using `rep(min, max, length.out = n)`
n <- 100

#fit the model
fit <- lm(y~x1+I(x2^2)+x3+x4, data=dat)

# range values for when variable is featured on an axis
mins_maxs <- data.frame(x1 = c(-3, 3),
                        x2 = c(0, 1),
                        x3 = c(5, 20),
                        x4 = c(0, 7))

# values to hold for plots in which variables are not on an axis
holds <- c(0, 0.5, 10, 5)

sim_data <- list()
sim_data <- lapply(seq_len(ncol(combis)), function (i) {
  sim_data[[i]] <- 
} )

# we create a new data frame for the data set we want to plot
# for each contour of interest, we want the first two columns, as the second two
# were only created for the sake of feeding into our fit lm 
# we'll also create a vector for facetting using paste()
plot_data <- list()
plot_data <- lapply(1:ncol(combis), function(i) {
  plot_data[[i]] <- sim_data[[i]][, 1:2]
  plot_data[[i]]$var1 <- rep(var_names[combis[1, i]],
                             nrow(plot_data[[i]]))
  plot_data[[i]]$var2 <- rep(var_names[combis[2, i]],
                                   nrow(plot_data[[i]]))
  return(plot_data[[i]])
} )

# now we rename the columns of plot_data
plot_data <- lapply(1:length(plot_data), function(i) {
  names(plot_data[[i]]) <- c("x", "y", "var1", "var2")
  return(plot_data[[i]])
} )

# similarly, we need to re-name the sim_data columns so we can rbind them
# and predict new values using our fit lm
sim_data <- lapply(1:length(sim_data), function(i) {
  names(sim_data[[i]]) <- var_names[combis[, i]]
  return(sim_data[[i]])
} )


# collapse the separate lists into one data.frame
plot_data <- do.call(rbind, plot_data)
sim_data <- do.call(rbind, sim_data)

# create a vector of predictions using sim_data
plot_data$resp <- predict(fit, sim_data) plot_data library(ggplot2)
p <- ggplot(plot_data, aes(x = x, y = y, z = resp))
p <- p + geom_tile(aes(fill = resp))
p <- p + facet_wrap(var2 ~ var1, scales = "free", ncol = 3) + theme_bw() plot_data_round <- plot_data
plot_data_round[, c("x", "y")] <- round(plot_data_round[, c("x", "y")], 5)

# same plot call as above
p <- ggplot(plot_data_round, aes(x = x, y = y, z = resp))
p <- p + geom_tile(aes(fill = resp))
p <- p + facet_wrap(var2 ~ var1, scales = "free", ncol = 3) + theme_bw() plot_data_hw <- plot_data
hw <- ddply(plot_data, .(var1, var2), summarize,
            height = (max(y) - min(y))/n, width = (max(x) - min(x))/n)
plot_data_hw <- merge(plot_data_hw, hw, by = c("var1", "var2"), all.x = T)
# verify using same plot call and plot_data_hw height width height width geom_tile() plot_data_hw_round <- merge(plot_data_round, hw, by = c("var1", "var2"), all.x = T)
p <- ggplot(plot_data_hw_round, aes(x = x, y = y, z = resp))
p <- p + geom_tile(aes(fill = resp, height = height, width = width))
p <- p + facet_wrap(var2 ~ var1, scales = "free", ncol = 3) + theme_bw()
-------------------------------------------------------------------------------------------------------
ggplot(data=data, aes(x=Group, y=Value, fill=Group)) +
  geom_bar(position = 'dodge', stat="identity") +
  geom_text(aes(label=paste(Value, "%")), position=position_dodge(width=0.9), vjust=-0.25) + 
  facet_grid(. ~ Category) + 
  theme(legend.position="none")
-------------------------------------------------------------------------------------------------------
#making random numbers reproducible
set.seed(12345)
rawdata <- expand.grid(
  Crop = paste("Crop", LETTERS[1:8]), 
  Country = paste("Country", letters[10:13])
)
#day.of.year of sowing
rawdata$Sowing <- runif(nrow(rawdata), min = 0, max = 365)
#number of days until mid season
rawdata$Midseason <- runif(nrow(rawdata), min = 10, max = 30)
#number of days until harvest
rawdata$Harvest <- runif(nrow(rawdata), min = 20, max = 150)
#number of days until end of harvest
rawdata$Harvest.end <- runif(nrow(rawdata), min = 10, max = 40)

dataset <- data.frame(Crop = character(0), Country = character(0), Period = character(0), Duration = numeric(0))

#sowing around new year
last.day <- rowSums(rawdata[, c("Sowing", "Midseason")])
if(any(last.day >= 365)){
  dataset <- rbind(
    dataset,
    cbind(
      rawdata[last.day >= 365, c("Crop", "Country")],
      Period = "Sowing",
      Duration = last.day[last.day >= 365] - 365
    )
  )
  dataset <- rbind(
    dataset,
    cbind(
      rawdata[last.day >= 365, c("Crop", "Country")],
      Period = "Mid-season",
      Duration = rawdata$Harvest[last.day >= 365]
    )
  )
  dataset <- rbind(
    dataset,
    cbind(
      rawdata[last.day >= 365, c("Crop", "Country")],
      Period = "Harvest",
      Duration = rawdata$Harvest.end[last.day >= 365]
    )
  )
  dataset <- rbind(
    dataset,
    cbind(
      rawdata[last.day >= 365, c("Crop", "Country")],
      Period = NA,
      Duration = 365 - rowSums(rawdata[last.day >= 365, c("Midseason", "Harvest", "Harvest.end")])
    )
  )
  dataset <- rbind(
    dataset,
    cbind(
      rawdata[last.day >= 365, c("Crop", "Country")],
      Period = "Sowing",
      Duration = 365 - rawdata$Sowing[last.day >= 365]
    )
  )
  rawdata <- rawdata[last.day < 365, ]
}

#mid-season around new year
last.day <- rowSums(rawdata[, c("Sowing", "Midseason", "Harvest")])
if(any(last.day >= 365)){
  dataset <- rbind(
    dataset,
    cbind(
      rawdata[last.day >= 365, c("Crop", "Country")],
      Period = "Mid-season",
      Duration = last.day[last.day >= 365] - 365
    )
  )
  dataset <- rbind(
    dataset,
    cbind(
      rawdata[last.day >= 365, c("Crop", "Country")],
      Period = "Harvest",
      Duration = rawdata$Harvest.end[last.day >= 365]
    )
  )
  dataset <- rbind(
    dataset,
    cbind(
      rawdata[last.day >= 365, c("Crop", "Country")],
      Period = NA,
      Duration = 365 - rowSums(rawdata[last.day >= 365, c("Midseason", "Harvest", "Harvest.end")])
    )
  )
  dataset <- rbind(
    dataset,
    cbind(
      rawdata[last.day >= 365, c("Crop", "Country")],
      Period = "Sowing",
      Duration = rawdata$Midseason[last.day >= 365]
    )
  )
  dataset <- rbind(
    dataset,
    cbind(
      rawdata[last.day >= 365, c("Crop", "Country")],
      Period = "Mid-season",
      Duration = 365 - rowSums(rawdata[last.day >= 365, c("Sowing", "Midseason")])
    )
  )
  rawdata <- rawdata[last.day < 365, ]
}


#harvest around new year
last.day <- rowSums(rawdata[, c("Sowing", "Midseason", "Harvest", "Harvest.end")])
if(any(last.day >= 365)){
  dataset <- rbind(
    dataset,
    cbind(
      rawdata[last.day >= 365, c("Crop", "Country")],
      Period = "Harvest",
      Duration = last.day[last.day >= 365] - 365
    )
  )
  dataset <- rbind(
    dataset,
    cbind(
      rawdata[last.day >= 365, c("Crop", "Country")],
      Period = NA,
      Duration = 365 - rowSums(rawdata[last.day >= 365, c("Midseason", "Harvest", "Harvest.end")])
    )
  )
  dataset <- rbind(
    dataset,
    cbind(
      rawdata[last.day >= 365, c("Crop", "Country")],
      Period = "Sowing",
      Duration = rawdata$Midseason[last.day >= 365]
    )
  )
  dataset <- rbind(
    dataset,
    cbind(
      rawdata[last.day >= 365, c("Crop", "Country")],
      Period = "Mid-season",
      Duration = rawdata$Harvest[last.day >= 365]
    )
  )
  dataset <- rbind(
    dataset,
    cbind(
      rawdata[last.day >= 365, c("Crop", "Country")],
      Period = "Harvest",
      Duration = 365 - rowSums(rawdata[last.day >= 365, c("Sowing", "Midseason", "Harvest")])
    )
  )
  rawdata <- rawdata[last.day < 365, ]
}


#no crop around new year
dataset <- rbind(
  dataset,
  cbind(
    rawdata[, c("Crop", "Country")],
    Period = NA,
    Duration = rawdata$Sowing
  )
)
dataset <- rbind(
  dataset,
  cbind(
    rawdata[, c("Crop", "Country")],
    Period = "Sowing",
    Duration = rawdata$Midseason
  )
)
dataset <- rbind(
  dataset,
  cbind(
    rawdata[, c("Crop", "Country")],
    Period = "Mid-season",
    Duration = rawdata$Harvest
  )
)
dataset <- rbind(
  dataset,
  cbind(
    rawdata[, c("Crop", "Country")],
    Period = "Harvest",
    Duration = rawdata$Harvest.end
  )
)
dataset <- rbind(
  dataset,
  cbind(
    rawdata[, c("Crop", "Country")],
    Period = NA,
    Duration = 365 - rowSums(rawdata[, c("Sowing", "Midseason", "Harvest")])
  )
)

Labels <- c("", "Jan.", "Feb.", "Mar.", "Apr.", "May", "Jun.", "Jul.", "Aug.", "Sep.", "Okt.", "Nov.", "Dec.")
Breaks <- cumsum(c(0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31))
ggplot(dataset, aes(x = Crop, y = Duration, colour = Period, fill = Period)) + geom_bar(stat = "identity") + facet_wrap(~Country) + coord_flip() + scale_fill_manual(values = c("Sowing" = "darkgreen", "Mid-season" = "grey", "Harvest" = "yellow")) + scale_colour_manual(values = c("Sowing" = "black", "Mid-season" = "black", "Harvest" = "black"), guide = "none") + scale_y_continuous("", breaks = Breaks, labels = Labels, limits = c(0, 365)) + theme_bw() + theme(axis.text.x = element_text(hjust = 1))
-------------------------------------------------------------------------------------------------------
year ggplot(ga.data,aes(x=as.factor(month),y=visits,fill=as.factor(year)))+
  geom_bar(stat="identity")+facet_grid(~year,scale="free_x",space="free_x")
-------------------------------------------------------------------------------------------------------
ggplot2 lattice # Load required packages
require(ggplot2)
require(plyr)

# Make factors with the same levels as in the original post
#   but 100x longer, and in random order so all combinations are present
a <- sample(factor(rep(c(1,2), times = 600)))
b <- sample(factor(rep(c(1,2,3), times = 400)))
c <- sample(factor(rep(c(1,2,3,4), times = 300)))
d <- sample(factor(rep(c("true", "false"), each = 600)))
e <- sample(factor(rep(c("yes", "no", "may be"), each = 400)))
value <- runif(1200)

# Put them in a data frame
df <- data.frame(a=a, b=b, c=c, d=d, e=e, value=value)

# Calculate the sum of the value columns for each unique combination of a, b, c, d, and e
#   I think this is what you'd like - am not totally sure
ds <- ddply(df, c("a", "b", "c", "d", "e"), summarise, sum.value=sum(value, na.omit=TRUE))

# Make the plot
ggplot(ds, aes(x=d, y=sum.value, fill=e)) + geom_bar(stat="identity") +
  facet_grid(a~b+c) +
  theme(axis.text.x=element_text(angle=-90))
-------------------------------------------------------------------------------------------------------
?panel.grid

myplot <- xyplot(noOfInst ~ instSize, data = inst
            , col = "blue",
             xlab = "Instance Size (Number of Aircraft)",
             ylab = "Number Of Instances",
          panel = function(x, y) {
           panel.grid(h = 16, v = 0)
           panel.xyplot(x, y, type = "h")
                                 },
             scales=list(
               y=list(
                 at=seq(0,150,10),
                 labels=seq(0,150,10) ),
               x=list(
                 at=seq(10,27,1),
                 labels=seq(10,27,1) )
             )
             )
myplot
-------------------------------------------------------------------------------------------------------
?grid abline plot(as.Date(data[["Date"]]), -data[["dbns"]], type="l")
grid(NA,NULL,lwd=3)
v <- as.numeric(as.Date(paste0(c(1970,1980,1990,2000,2010),'-01-01')))
abline(v = v,lty = "dotted",col = "lightgray",lwd = 3)
-------------------------------------------------------------------------------------------------------
Axis.Date Date par('xaxp') grid # assuming your data is called DD
DD$Date <- as.Date(as.character(DD$Date), format = '%d/%m/%Y')
# don't plot the x axis (xaxt = 'n')
plot(-dbns~Date,data = DD[order(DD$Date),], type="l", xaxt = 'n')
# create the axis and  save the tick locations
at <- as.numeric(Axis(side = 1, x = DD$Date))
grid(NA,NULL,lwd=3)
abline(v = at,lty = "dotted",col = "lightgray",lwd = 3)
-------------------------------------------------------------------------------------------------------
my.data.frame <- expand.grid(x = 1:15, y = 1:14)
my.data.frame$z <- with(my.data.frame, x ^2 + x + x * y + y ^ 2 + y)
library(lattice)
contourplot(z ~ x * y, data = my.data.frame)
-------------------------------------------------------------------------------------------------------
f <- function(A,B){
  tmpA <-  lapply( A , function(x) min(x):max(x) )
  tmpB <-  lapply( B , function(x) min(x):max(x) )
  ids <- expand.grid( seq_along( tmpA ) , seq_along( tmpB ) )
  res <- mapply( function(i,j) any( tmpA[[i]] %in% tmpB[[j]] ) , i = ids[,1] , j = ids[ ,2] )
  out <- matrix( res , nrow = length( tmpA ) )
  return( out * 1 )
  }

 f(A,B)
     [,1] [,2]
[1,]    1    1
[2,]    1    1
[3,]    0    1
-------------------------------------------------------------------------------------------------------
stats >dat <- read.table(text="sample_num  category 
+       1         A      
+       2         A      
+       3         A      
+       4         A      
+       5         B      
+       6         B      
+       7         B      
+       8         C      
+       9         C      
+      10         C      
+      11         C      
+      12         C", header=TRUE)
> model.matrix( ~category, data=dat)

   (Intercept) categoryB categoryC
1            1         0         0
2            1         0         0
3            1         0         0
4            1         0         0
5            1         1         0
6            1         1         0
7            1         1         0
8            1         0         1
9            1         0         1
10           1         0         1
11           1         0         1
12           1         0         1
attr(,"assign")
[1] 0 1 1
attr(,"contrasts")
attr(,"contrasts")$category
[1] "contr.treatment" ?model.matrix
?contrasts > model.matrix(~category+0, data=dat, contrasts = list(category = "contr.sum"))
   categoryA categoryB categoryC
1          1         0         0
2          1         0         0
3          1         0         0
4          1         0         0
5          0         1         0
6          0         1         0
7          0         1         0
8          0         0         1
9          0         0         1
10         0         0         1
11         0         0         1
12         0         0         1
attr(,"assign")
[1] 1 1 1
attr(,"contrasts")
attr(,"contrasts")$category
[1] "contr.sum" > dat <- expand.grid(A=letters[1:3], B=letters[4:6], C=letters[7:9])
> str(model.matrix( ~ A*B*C))
Error in str(model.matrix(~A * B * C)) : 
  error in evaluating the argument 'object' in selecting a method for function 'str': Error in model.frame.default(object, data, xlev = xlev) : 
  invalid type (closure) for variable 'C'
> str(model.matrix( ~ A*B*C, data=dat))
 num [1:27, 1:27] 1 1 1 1 1 1 1 1 1 1 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:27] "1" "2" "3" "4" ...
  ..$ : chr [1:27] "(Intercept)" "Ab" "Ac" "Be" ...
 - attr(*, "assign")= int [1:27] 0 1 1 2 2 3 3 4 4 4 ...
 - attr(*, "contrasts")=List of 3
  ..$ A: chr "contr.treatment"
  ..$ B: chr "contr.treatment"
  ..$ C: chr "contr.treatment"

model.matrix( ~ A*B*C, data=dat)

omitted output
-------------------------------------------------------------------------------------------------------
?ikey ikey(x[c("id_1","id_2","month","year")]) require(ffbase)
require(data.table)
x <- expand.ffgrid(id_1 = ffseq(1, 1000), id_2 = ffseq(1, 1000), year = as.ff(c(2012,2013)), month = as.ff(1:12))
x$Amount <- ffrandom(nrow(x), rnorm, mean = 10, sd = 5)
x$key <- ikey(x[c("id_1","id_2","month","year")])
x$key <- as.character(x$key)
summary <- ffdfdply(x, split=x$key, FUN=function(df) {
  df <- data.table(df)
  df <- df[, list(
    id_1 = id_1[1], 
    id_2 = id_2[1],
    month = month[1],
    year = year[1],
    withdraw = sum(Amount*(Amount>0), na.rm=T)
  ), by = key]
  df
}, trace=TRUE)
-------------------------------------------------------------------------------------------------------
times key key tim.seq tim.seq<-seq(as.POSIXlt("2013-07-01 00:00:00",origin = "1960-01-01",tz="GMT"),
             as.POSIXlt("2013-07-16 12:00:00",origin = "1960-01-01",tz="GMT"),by="12 hours") cut() times2 df$times2<-cut(df$times,breaks=tim.seq) ddply() plyr df2<-ddply(df,.(order,times2,key),nrow)
df2$times2<-as.POSIXct(df2$times2) order times2 key df2 V1 df3<-expand.grid(unique(df2$order),unique(df2$times2),unique(df2$key))
colnames(df3)<-c("order","times2","key")
df4<-merge(df2,df3,by=c("times2","order","key"),all=TRUE)
df4$V1[is.na(df4$V1)]<-0 ggplot(df4,aes(x=times2,y=V1,fill=key))+geom_area(stat="identity")+
  facet_wrap( ~ order,scales="free_x")
-------------------------------------------------------------------------------------------------------
value2 date value2 POSIXct date value mdfr$value2<-as.POSIXct(strptime(mdfr$value, "%d/%m/%Y %H:%M:%S"))
mdfr$date<-as.factor(as.Date(strptime(mdfr$value, "%d/%m/%Y %H:%M:%S"))) facet_grid() scales="free_x" space="free_x" ggplot(mdfr, aes(value2, name)) + 
  geom_line(size = 6) +
  xlab("") + ylab("") +
  theme_bw() + facet_grid(~date,scales="free_x",space="free_x")
-------------------------------------------------------------------------------------------------------
d <- expand.grid(rep(list(factor(1:2)), 4))
names(d) <- c("w", "x", "y", "z")

# Remove 5 combinations randomly
d_miss <- d[-sample(nrow(d), 5), ]

# To find which ones are missing, build up a complete list
# (this will be the same as d in this case, but obviously
# you don't normally have d)
vals <- lapply(d_miss, unique)
all_combs <- expand.grid(vals)

# Now collapse each data frame to a single value, then
# figure out which ones are missing. There's lots of ways 
# of doing this, this is the approach plyr uses: 
# (you could also use interaction, or paste the values together)
all <- plyr::id(all_combs)
some <- plyr::id(d_miss)

# Here are the missing 
all_combs[setdiff(all, some), ]
-------------------------------------------------------------------------------------------------------
expand.grid data <- data.frame(R=1:6,B=1:6)
out <- expand.grid(data$R,2*data$B)
apply(out,1,sum)
 [1]  3  4  5  6  7  8  5  6  7  8  9 10  7  8  9 10 11 12  9 10 11 12 13 14 11
[26] 12 13 14 15 16 13 14 15 16 17 18
-------------------------------------------------------------------------------------------------------
ggplot(df,aes(exp))+geom_density()+facet_grid(tissue~ctype) Cell2 tissue S NK-Cell tissue L
-------------------------------------------------------------------------------------------------------
ggplot2 data.table geom_text pvalue require(data.table)
dt <- data.table(df)
pval <- dt[, list(pvalue = paste0("pval = ", sprintf("%.3f", 
        summary(aov(x ~ type))[[1]][["Pr(>F)"]][1]))), 
        by=list(country, month)]

ggplot(data = df, aes(x=type, y=x)) + geom_boxplot() + 
geom_text(data = pval, aes(label=pvalue, x="river", y=2.5)) + 
facet_grid(country ~ month) + theme_bw() + 
theme(panel.margin=grid::unit(0,"lines"), # thanks to @DieterMenne
strip.background = element_rect(fill = NA), 
panel.grid.major = element_line(colour=NA), 
panel.grid.minor = element_line(colour=NA))
-------------------------------------------------------------------------------------------------------
?plotmath
?points # to which plotmath sends you for mapping of 'symbol' characters

# And I do not like the plotmath-paste function, 
# so translated to 'pure' expressions.
# The number arguments to symbol are numbers in octal.

plot(1, 1, pch = "")
text(1, 1.2, 
       expression(low ~italic(P)*"("*italic(p)~
                                   symbol("\332")~ italic(q)* 
                                  "), -1 SD"), 
       cex = 1.2)
text(1, 0.8, 
   expression(low~italic(P)* 
               "("*symbol("\330")*italic(p)~symbol("\331")~ italic(q)*
               "), -1 SD"),
    cex = 1.2 ) > as.octmode(216)
[1] "330"

TestChars <- function(sign = 1, font = 1, ...)
{
   MB <- l10n_info()$MBCS
   r <- if(font == 5) { sign <- 1; c(32:126, 160:254)
       } else if(MB) 32:126 else 32:255
   if (sign == -1) r <- c(32:126, 160:255)
   par(pty = "s")
   plot(c(-1,16), c(-1,16), type = "n", xlab = "", ylab = "",
        xaxs = "i", yaxs = "i",
        main = "Symbol Font, Decimal Indices")
   grid(17, 17, lty = 1) ; mtext(paste("MBCS:", MB))
   for(i in r) try(points(i%%16, i%/%16, pch = sign*i, font = font,...))

   for(i in r) try(text(x=i%%16, y=(i%/%16)-0.4, i, cex=0.5 , font = font,...))
}

TestChars(font = 5)
-------------------------------------------------------------------------------------------------------
dd <- data.frame(vs = c(0,1), ff = factor(0:1))
ggplot() + geom_rect(data=dd, aes(fill=ff), 
    xmin=-Inf, xmax=Inf, ymin=-Inf, ymax=Inf, alpha=0.15) + 
    geom_bar(data = mtcars, aes(factor(cyl))) + facet_grid(. ~ vs) + 
    scale_fill_manual(values=c(NA, "red"), breaks=NULL)
-------------------------------------------------------------------------------------------------------
ggplot2 geom_bar(position="dodge") facet_grid(...) ggplot2 example(geom_bar) position="fill" reshape melt()
-------------------------------------------------------------------------------------------------------
max.n.filt if() x > filter length(x) > 1 if() x x if() > max.n.filt(data.frame(x=c(10,15,400)))
$y.x
[1]  10  15 400

$label
[1] "" ifelse() max.n.filt2 <- function(x){
    filter = 300                  # whatever threshold
    y = ifelse( x > filter, max(x) + 1, x[,1] )
    label = ifelse( x > filter, round(max(x),2), NA )
    return(data.frame(y=y[,1], label=label[,1]))
}

> max.n.filt2(data.frame(x=c(10,15,400)))
    y label
1  10    NA
2  15    NA
3 401   400 geom_text() set.seed(101)
sim_data <- expand.grid(m1=1:1440, variable=factor(c(0,0.25,0.5,0.75,1)))
sim_data$sample_size <- sapply(1:1440, function(.) sample(1:25, 1, replace=T))
sim_data$value = t(sapply(1:1440, function(.) quantile(rgamma(sim_data$sample_size, 0.9, 0.5),c(0,0.25,0.5,0.75,1))))[1:(1440*5)] subset geom_text() ggplot(sim_data, aes(x = m1/60, y = value, color = variable)) +
geom_point(size = 4) + geom_text(aes(label=round(value)), subset = .(variable == 1 & value > 25), angle = 90, size = 4, colour = "red", hjust = -0.5) label paste() ggplot(sim_data, aes(x = m1/60, y = value, color = variable)) +
geom_point(size = 4) + geom_text(aes(label=paste(round(value),", N=",sample_size)), subset = .(variable == 1 & value > 25), angle = 90, size = 4, colour = "red", hjust = -0.25) ddply() ...
c2 <- ddply(C, .(h1), function (x) { cbind(summarise(x, y = quantile(x$gaps, cuts)), n=nrow(x)) } )
c2$cuts <- cuts
c2 <- dcast(c2, h1 + n ~ cuts, value.var = "y")
c2.h1.melt <- melt(c2, id.vars = c("h1","n"))
...
-------------------------------------------------------------------------------------------------------
DirLea ~ Time DirLea ~ Dur model <- glm(DirLea ~ (Time + Dur)*treatment, 
             data=data_animal, family = binomial(link=logit)) predict subset sucrose.line <- 
expand.grid(treatment = "sucrose", Time = seq(100, 1200, length=50)Dur=mean(animal_data$Dur))
sucrose.line$fitted <- predict(model, sucrose.line)
lines(fitted ~ Time, data = sucrose.line,
      xlab ="Time of the presentation of the danger cue",    
      ylab="Proportion of wasps leaving the patch")
-------------------------------------------------------------------------------------------------------
predict() mer lme4 ez::ezPredict library(ez)
library(ggplot2)
to_predict <- expand.grid(TMT1=c("A","B"), TMT2=c("C","D"))
t_means <- rbind(ezPredict(m2011, to_predict=to_predict, boot=F), ezPredict(m2012, to_predict=to_predict, boot=F), ezPredict(m2013, to_predict=to_predict, boot=F) )
t_means$YEAR = rep(2011:2013, each = 4)
ggplot(t_means, aes(x=YEAR, y=value, color=TMT1:TMT2)) + geom_point() + geom_line() mm = unique(model.matrix(m2011))
Y_bar <- c(mm%*%fixef(m2011), mm%*%fixef(m2012), mm%*%fixef(m2013))
ggplot(t_means, aes(x=YEAR, y=Y_bar, color=TMT1:TMT2)) + geom_point() + geom_line() ranef(m2011) m2011@Zt fixef(m2011) model.matrix(m2011) bootMer() lme4 simulate() refit() t_sim <- apply(simulate(model, 999), 2, function(x) combn(unique(model.matrix(model))%*%fixef(refit(model, x)), 2, diff) ) quantile() apply(t_sim, 1, function(.) quantile(., c(0.975, 0.025)))
-------------------------------------------------------------------------------------------------------
facet_wrap() facet_grid() scales="free_y" ggplot(mtcars,aes(as.factor(cyl),mpg))+geom_boxplot()+
          facet_wrap(~gear,scales="free_y")
-------------------------------------------------------------------------------------------------------
n <- nrow(s_i)
dgpos <- rev(expand.grid(row2 = seq_len(n), row1 = seq_len(n)))
dgpos <- subset(dgpos, row1 != row2)
dgpos
#   row1 row2
# 2    1    2
# 3    1    3
# 4    2    1
# 6    2    3
# 7    3    1
# 8    3    2 ifelse dgpos <- transform(dgpos, out = { c1 <- s_i[row1, ]
                                  c2 <- s_i[row2, ]
                                  ifelse(c2[,2] >= c1[,2], 1,
                                  ifelse(c1[,1] >= c2[,3], 0,
                                  (c1[,1]-c2[,3]) / ((c2[,2]-c2[,3]) - (c1[,2]-c1[,1])))) })
dgpos
#   row1 row2 out
# 2    1    2   0
# 3    1    3   0
# 4    2    1   0
# 6    2    3   0
# 7    3    1   0
# 8    3    2   0
-------------------------------------------------------------------------------------------------------
dgpos = rev(expand.grid(row2 = seq_len(nrow(s_i)), row1 = seq_len(nrow(s_i))))
dgpos =  subset(dgpos, row1 != row2)

for (i in 1:nrow(dgpos)) {

  c1 = s_i[dgpos$row1[i], ]
  c2 = s_i[dgpos$row2[i], ]

  dgpos$out[i] = ifelse(c2[2] >= c1[2], 1,
           ifelse(c1[1] >= c2[3], 0,
                  (c1[1]-c2[3]) / ((c2[2]-c2[3]) - (c1[2]-c1[1])))) }

dgpos

   # row1 row2       out
   # 2    1    2 0.5168453
   # 3    1    3         1
   # 4    2    1         1
   # 6    2    3         1
   # 7    3    1         0
   # 8    3    2 0.1235813
-------------------------------------------------------------------------------------------------------
df <- aggregate(rate~., data=test, sum)
> df
      time bucket rate
1 20060200      1 0.15
2 20060400      1 0.03
3 20060200      2 0.09
4 20060300      3 0.01
5 20060400      3 0.15 > levels(factor(bucket))
[1] "1" "2" "3"
> levels(factor(time))
[1] "20060200" "20060300" "20060400"
> B <- levels(factor(bucket))
> t <- levels(factor(time)) > base <- expand.grid(B,t)
> names(base) <-c("bucket","time")
> base
  bucket     time
1      1 20060200
2      2 20060200
3      3 20060200
4      1 20060300
5      2 20060300
6      3 20060300
7      1 20060400
8      2 20060400
9      3 20060400 > m <- merge(base,df,all.x=T)
  bucket     time rate
1      1 20060200 0.15
2      1 20060300   NA
3      1 20060400 0.03
4      2 20060200 0.09
5      2 20060300   NA
6      2 20060400   NA
7      3 20060200   NA
8      3 20060300 0.01
9      3 20060400 0.15 m$rate[is.na(m$rate)] <- 0
> m
  bucket     time rate
1      1 20060200 0.15
2      1 20060300 0.00
3      1 20060400 0.03
4      2 20060200 0.09
5      2 20060300 0.00
6      2 20060400 0.00
7      3 20060200 0.00
8      3 20060300 0.01
9      3 20060400 0.15 > m[with(m,order(time,bucket)),]
  bucket     time rate
1      1 20060200 0.15
4      2 20060200 0.09
7      3 20060200 0.00
2      1 20060300 0.00
5      2 20060300 0.00
8      3 20060300 0.01
3      1 20060400 0.03
6      2 20060400 0.00
9      3 20060400 0.15
-------------------------------------------------------------------------------------------------------
geom_line wday splitter aes ggplot(melt(temp,id.vars = c("wday","splitter")), 
  aes(x = wday, y = value, colour = splitter, group = splitter)) + 
  geom_point() + geom_line() +
  facet_grid(variable ~ ., scale = "free_y")
-------------------------------------------------------------------------------------------------------
palette(c("red","green","yellow","blue","black"))
plot.default(
  as.data.frame.table(t(mat))[1:2],
  col=findInterval(t(mat),c(0,0.2,0.4,0.6,0.9)),
  pch=19,
  axes=FALSE,ann=FALSE,
  panel.first=grid()
)
axis(2,at=1:length(rownames(mat)),labels=rownames(mat),lwd=0,lwd.ticks=1,las=1)
axis(1,at=1:length(colnames(mat)),labels=colnames(mat),lwd=0,lwd.ticks=1)
box()
palette("default")
-------------------------------------------------------------------------------------------------------
N <- c(1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000)
H2 <- c(0.005, 0.01, 0.02)
alpha <- 0.05

threshold <- qchisq(alpha, df = 1, lower.tail = FALSE)

paraComb <- expand.grid(N, H2)
ncp <- with(paraComb, Var1 * Var2)

setNames(cbind(paraComb,
               sapply(ncp, 
                      function(ncp) pchisq(threshold, 
                                           df = 1, lower.tail = FALSE, 
                                           ncp = ncp))
              ),
         c("N", "H2", "power"))

#        N    H2     power
# 1   1000 0.005 0.6087795
# 2   2000 0.005 0.8853791
# 3   3000 0.005 0.9721272
# 4   4000 0.005 0.9940005
# 5   5000 0.005 0.9988173
# <snip>
-------------------------------------------------------------------------------------------------------
predict ggplot # A transformed response
df$resp2 = df$resp^(1/3.79)

m2 = lm(resp2 ~ expl1 * expl2, data=df)

plotexpl = seq(1, 4, by = .1)
# Use expand grid to make dataset for predictions
newdat = expand.grid(expl1 = plotexpl, expl2 = c("1", "2", "3"))
newdat$pred = predict(m2, newdata = newdat)

# Back-transform predictions
newdat$back = newdat$pred^3.79

require(ggplot2)
ggplot(df, aes(x = expl1, y = resp, color = expl2)) +
    geom_point() + geom_line(data = newdat, aes(y = back) )
-------------------------------------------------------------------------------------------------------
position = position_dodge(width=0.9) geom_text ggplot(meltedLikert[meltedLikert$variable != "age",], 
       aes(variable, count, fill=score)) + 
  geom_bar(position="dodge", stat="identity") +
  geom_text(data=data.frame(meltedLikert), 
            aes(variable, count, group=score, label=meltedLikert$score), 
            position = position_dodge(width=0.9),
            size=4) +
  facet_grid(age ~ .) meltedLikert$score aes() data meltedLikert data.frame data.frame() tabulatedLikert <- ldply(likert[-1], function(sc) {
  as.data.frame(table(age = likert$age, score = sc))
})
ggplot(tabulatedLikert, aes(x=.id, y=Freq, fill=score)) +
  geom_bar(position="dodge", stat="identity") +
  geom_text(aes(label=score), position=position_dodge(width=0.9), size=4) +
  facet_grid(age ~ .) likert2 <- mutate(likert,
                  score1 = factor(score1, levels=c("unlikely", "likely", "very likely")),
                  score2 = factor(score2, levels=c("disagree", "neutral", "agree")),
                  score3 = factor(score3, levels=c("no", "maybe", "yes")))
tabulatedLikert2 <- ldply(likert2[-1], function(sc) {
  as.data.frame(table(age = likert2$age, score = sc))
})
ggplot(tabulatedLikert2, aes(x=.id, y=Freq, fill=score)) +
  geom_bar(position="dodge", stat="identity") +
  geom_text(aes(label=score), position=position_dodge(width=0.9), size=4) +
  facet_grid(age ~ .) ggplot(tabulatedLikert2, aes(x=.id, y=Freq, group=score)) +
  geom_bar(position="dodge", stat="identity", fill="gray70") +
  geom_text(aes(label=score), position=position_dodge(width=0.9), size=4) +
  facet_grid(age ~ .)
-------------------------------------------------------------------------------------------------------
system.time(expand.grid(1:1000,1:10000))
# user system elapsed
# 1.420 0.552 1.987

system.time(CJ(1:1000,1:10000))
# user system elapsed
# 0.080 0.092 0.171 CJ() sorted
-------------------------------------------------------------------------------------------------------
comb3 <- function(n){
    result <- expand.grid(i=1:n,j=1:n,k=1:n)
    result[with(result, i!=j & j!=k & i!=k & j>i),]
} i!=j & j!=k & i!=k & j>i sumx <- function(x) {
    sum(with(comb3(length(x)), ((a[cbind(i,j)]*a[cbind(j,k)])-(x[i]/x[j]))^2))
} sumx(1:5)
#[1] 3584.542 a[i,j] a[cbind(i,j)] sumx comb3(length(x)) x y <- within(comb3(nrow(a)), b <- a[cbind(i,j)]*a[cbind(j,k)])

sumx <- function(x) {
    sum(with(y, (b-(x[i]/x[j]))^2))
} optim > optim(rep(1,5), sumx)
$par
[1] 1.9739966 1.5882750 1.5626338 0.1592725 0.1521839

$value
[1] 1436.526

$counts
function gradient 
     502       NA 

$convergence
[1] 1

$message
NULL

> optim(1:5, sumx)
$par
[1] 5.4254668 4.3857303 4.3029354 0.4374246 0.4199909

$value
[1] 1436.503

$counts
function gradient 
     218       NA 

$convergence
[1] 0

$message
NULL
-------------------------------------------------------------------------------------------------------
# Make fake data
x <- c('A','B','C')
dat <- expand.grid(x, x)
dat$Var3 <- rnorm(9) > reshape(dat, idvar = "Var1", timevar = "Var2", direction = "wide")
  Var1     Var3.A      Var3.B     Var3.C
1    A -1.2442937 -0.01132871 -0.5693153
2    B -1.6044295 -1.34907504  1.6778866
3    C  0.5393472 -1.00637345 -0.7694940 dcast > library(reshape2)
> dcast(dat, Var1 ~ Var2, value.var = "Var3")
  Var1          A           B          C
1    A -1.2442937 -0.01132871 -0.5693153
2    B -1.6044295 -1.34907504  1.6778866
3    C  0.5393472 -1.00637345 -0.7694940
-------------------------------------------------------------------------------------------------------
dput as.matrix #create combinations of row indices
ind <- expand.grid(seq_len(nrow(dat[[3]])),  seq_len(nrow(dat[[2]])), seq_len(nrow(dat[[1]])))

#use subsetting and cbind
res <- cbind(dat[[1]][ind[,3],],
              dat[[2]][ind[,2],], 
              dat[[3]][ind[,1],])

head(res)

#     cue op split pred     cue op split pred      cue op split  pred
# 1   edu  <     1 TRUE edu_hus  <     1 TRUE religion ==     0  TRUE
# 1.1 edu  <     1 TRUE edu_hus  <     1 TRUE religion ==     1  TRUE
# 1.2 edu  <     1 TRUE edu_hus  <     1 TRUE religion ==     0 FALSE
# 1.3 edu  <     1 TRUE edu_hus  <     1 TRUE religion ==     1 FALSE
# 1.4 edu  <     1 TRUE edu_hus  >     1 TRUE religion ==     0  TRUE
# 1.5 edu  <     1 TRUE edu_hus  >     1 TRUE religion ==     1  TRUE lapply do.call sl <- lapply(dat, function(df) seq_len(nrow(df)))
sl <- sl[rev(seq_along(sl))]
ind <- do.call(expand.grid, sl)
ind <- ind[,rev(seq_along(dat))]

res <- do.call(cbind, lapply(seq_along(dat), function(i) dat[[i]][ind[,i],]))
-------------------------------------------------------------------------------------------------------
ggplot ..count.. ..PANEL.. ggplot(test, aes(test2)) + 
    geom_bar(aes(y = (..count..)/tapply(..count..,..PANEL..,sum)[..PANEL..])) + 
    facet_grid(~test1)
-------------------------------------------------------------------------------------------------------
paste(period, name) df <- data.frame(name=c('foo','bar','foo','bar'),
  period=c('old','old','recent','recent'),
  val=c(1.23,2.17,4.15,3.65),
  stringsAsFactors=F)
df$n = as.numeric(factor(df$period))
df = ddply(df,.(period,name),transform, x=paste(c(rep(' ',n-1), name), collapse=''))
df$x = factor(df$x, levels=df[order(df$val), 'x'])
p = ggplot(data = df, aes(x = x, y = val))
p = p + geom_bar(stat='identity')
p = p + facet_grid(~period, scale='free_x')
p df <- ddply(mpg, .(year, manufacturer), summarize, mixmpg = mean(cty+hwy))
df$manufacturer = as.character(df$manufacturer)
df$n = as.numeric(factor(df$year))
df = ddply(df, .(year,manufacturer), transform,
     x=paste(c(rep(' ',n-1), manufacturer), collapse=''))
df$x = factor(df$x, levels=df[order(df$mixmpg), 'x'])
p = ggplot(data = df, aes(x = x, y = mixmpg))
p = p + geom_bar(stat='identity')
p = p + facet_grid(~year, scale='free_x')
p = p + theme(axis.text.x=element_text(angle=90,hjust=1,vjust=.5,colour='gray50'))
p
-------------------------------------------------------------------------------------------------------
xaxt = "n" yaxt = "n" box grid month.name seq.int x <- matrix(
  c(
    200, 227, 196, 
    210, 279, 319, 
    220, 126, 111,
    230, 196, 123,
    240, 106, 94,
    250, 154, 233,
    260, 226, 218
  ),
  nrow = 3,
  ncol = 7
)
colnames(x) <- month.name[c(11:12, 1:5)]
rownames(x) <- c("Hornberg", "Strick", "Huetten")


par(mar = c(5, 4, 1.5, 0.5), ps = 12, cex  = 1, cex.main = 2, las = 1)

barplot(
  x, 
  beside      = TRUE, 
  ylim        = c(0,350),
  xlab        = "Month", 
  axes        = TRUE,
  axis.lty    = 1, 
  ylab        = "Monthly Precipitation [mm]",
  col         = c("darkblue", "dodgerblue3", "deepskyblue1"),
  panel.first =  abline(
    h    =  seq.int(50, 300, 50), 
    col  =  "grey", 
    lty  =  2
  )
)
box()
grid()
-------------------------------------------------------------------------------------------------------
library(chron)
x$tt<-hours(times(x$time))*3600+minutes(times(x$time))*60+seconds(times(x$time)) p<-ggplot(x, aes(x = hour, y=tt,fill = occur)) + 
geom_bar(breaks = seq(0,24), width = 2, colour="grey",stat = "identity") +
theme_minimal() + 
scale_fill_brewer()+coord_polar(start=0)+
scale_x_continuous("", limits = c(0, 24), breaks = seq(0, 24), labels = seq(0,24)) p+facet_grid(~occur)+ theme(axis.title.y = theme_blank(),
                       axis.text.y =  theme_blank())
-------------------------------------------------------------------------------------------------------
fig.width fig.height fig.height \documentclass{article}

\begin{document}
<<setup>>=
library(ggplot2)
calc_height = function(f) length(levels(f))
p = ggplot(diamonds, aes(color)) + geom_bar()
@

<<test-a, fig.width=7, fig.height=calc_height(diamonds$cut)>>==
p + facet_grid(cut ~ .)
@

<<test-b, fig.width=7, fig.height=calc_height(diamonds$clarity)>>==
p + facet_grid(clarity ~ .)
@

\end{document}
-------------------------------------------------------------------------------------------------------
expand.grid factor facLevs <- expand.grid(c("yes", "no"), c("yes", "no"), c("yes", "no"))
facLevs
#   Var1 Var2 Var3
# 1  yes  yes  yes
# 2   no  yes  yes
# 3  yes   no  yes
# 4   no   no  yes
# 5  yes  yes   no
# 6   no  yes   no
# 7  yes   no   no
# 8   no   no   no do.call(paste, ...) apply(mydf, ...) as.numeric mydf$pattern <- as.numeric(factor(do.call(paste, mydf[1:3]), 
                                  do.call(paste, facLevs)))
mydf
#   Visit1 Visit2 Visit3 pattern
# 1    yes     no     no       7
# 2    yes     no    yes       3
# 3    yes    yes    yes       1
# 4     no    yes     no       6
# 5    yes     no    yes       3 pattern = 7 facLevs data.frame mydf mydf <- structure(list(Visit1 = c("yes", "yes", "yes", "no", "yes"), 
                       Visit2 = c("no", "no", "yes", "yes", "no"), 
                       Visit3 = c("no", "yes", "yes", "no", "yes")), 
                  .Names = c("Visit1", "Visit2", "Visit3"), 
                  class = "data.frame", row.names = c("1", "2", "3", "4", "5"))
-------------------------------------------------------------------------------------------------------
expand.grid expand.grid(0:1, 0:1, 0:1) n <- 14
l <- rep(list(0:1), n)

expand.grid(l)
-------------------------------------------------------------------------------------------------------
combinations <- function(n)
    expand.grid(rep(list(1:3),n))

> combinations(2)
  Var1 Var2
1    1    1
2    2    1
3    3    1
4    1    2
5    2    2
6    3    2
7    1    3
8    2    3
9    3    3
> combinations(3)
   Var1 Var2 Var3
1     1    1    1
2     2    1    1
3     3    1    1
4     1    2    1
5     2    2    1
6     3    2    1
7     1    3    1
8     2    3    1
9     3    3    1
10    1    1    2
11    2    1    2
12    3    1    2
13    1    2    2
14    2    2    2
15    3    2    2
16    1    3    2
17    2    3    2
18    3    3    2
19    1    1    3
20    2    1    3
21    3    1    3
22    1    2    3
23    2    2    3
24    3    2    3
25    1    3    3
26    2    3    3
27    3    3    3
-------------------------------------------------------------------------------------------------------
c(sapply(strsplit(as.character(vcf_GT[,10]),"/"),function(x) x[1]))... myfun <- function(var1, var2, dat=vcf_GT) {
    sapply(strsplit(as.character(dat[,var1], '/'),
           function(x) x[var2])
} regexpr(c(myfun(10, 1),
          myfun(10, 2)... dad = 'A/G'
mom = 'G/A'
kid = 'G/G'

splt <- function(x) unlist(strsplit(x, '/'))
comp <- function(x, y) c(x[1] %in% y, x[2] %in% y)

comp(splt(kid), splt(dad)) apply ## make some data
possible <- expand.grid(c('C', 'T', 'A', 'G'),
                        c('C', 'T', 'A', 'G'))

gen <- function(n, pos=possible) {
    res=possible[sample(1:nrow(possible), n, replace=TRUE),]
    return (paste(res[,1], res[,2], sep='/'))
}

n <- 10
dat <- data.frame(mom=gen(n), dad=gen(n), kid=gen(n))

# put both functions together
splt_and_comp <- function(x, y) {
    x <- splt(x)
    y <- splt(y)

    comp(x, y)
}

# you could do this with `apply` as well...
mapply(splt_and_comp, dat$kid, dat$mom) regexpr first_arg <- c(sapply(strsplit(as.character(vcf_GT[,10]), "/"),
                      function(x) x[1]))

second_arg <- (sapply(strsplit(as.character(vcf_GT[, 10]), "/"),
                      function(x) x[2]))

third_arg <- (c(c(sapply(strsplit(as.character(vcf_GT[,9]),"/"),
                           function(x) x[1])), 
                  (sapply(strsplit(as.character(vcf_GT[,9]),"/"),
                          function(x) x[2])),
                  c(sapply(strsplit(as.character(vcf_GT[,8]),"/"),
                           function(x) x[1])), 
                  (sapply(strsplit(as.character(vcf_GT[,8]),"/"),
                          function(x) x[2]))))
-------------------------------------------------------------------------------------------------------
alpha2f <- function(p0, t2, n1, n2){
  alls <- expand.grid(x1=12:n1, x2=0:n2, y2=0:n2)
  a <- dbinom(alls$x1, n1, p0)
  b <- dbinom(alls$x2, n2, p0)
  z <- numeric(nrow(alls))
  X <- alls$x1+alls$x2
  N <- n1+n2
  for (i in 1:length(z))
   z[i] <- (ztest(X[i], alls$y2|i], N, n2) > t2)
  d <- dbinom(alls$y2,n2,p0)
  alpha2 <- sum(a*b*d*z)
  return(alpha2)
  }
-------------------------------------------------------------------------------------------------------
expand.grid(A[A<20],B[B<15],...)
-------------------------------------------------------------------------------------------------------
data( iris )
iris$Petal.Class <- cut( iris$Petal.Length , 3 )

p1 <- ggplot( iris ) +
  geom_boxplot( aes( Species , Sepal.Width ) ) +
  facet_grid( Species + Petal.Class ~ . )

p2 <- ggplot( iris ) +
  geom_boxplot( aes( Species , Sepal.Width ) ) +
  facet_grid( Species ~ Petal.Class )

require( gridExtra )
grid.arrange( p1 , p2 , nrow = 1 , ncol = 2 ) facet_grid( species + varY ~ .) +
-------------------------------------------------------------------------------------------------------
data.frame cat library(reshape2) # for melt

melted <- melt(test, "person")

melted$cat <- ''
melted[melted$variable == 'value1',]$cat <- "first"
melted[melted$variable != 'value1',]$cat <- "second" cat value person ggplot(melted, aes(x = cat, y = value, fill = variable)) + 
  geom_bar(stat = 'identity', position = 'stack') + facet_grid(~ person)
-------------------------------------------------------------------------------------------------------
#!/usr/bin/rscript --vanilla
filename='smith_chart.pdf'
pdf(filename, 6, 6)

# applies conformal map (z-1)/(z+1) to complex number z
cmap <- function(z) (z-1)/(z+1)

plot.new()
plot.window(c(-1, 1), c(-1, 1), asp = 1)

dd <- c(seq(-100, 100, 1), seq(-10, 10, 0.1), seq(-2, 2, 0.02))
dd <- round(dd, digits = 2) # fix roundoff errors
dd <- sort(unique(dd)) # remove duplicates

smith_grid <- function (val, step) {
  # applies conformal map to lines having fixed real component
  r_grid <- outer(1i * dd[dd >= -val & dd <= val], seq(0, val, step), '+')
  r_grid <- cmap(r_grid)
  matlines(Re(r_grid), Im(r_grid), lwd = 0.5, col = 1, lty = 1)

  # applies conformal map to lines having fixed imaginary component
  x_grid <- outer(dd[dd >= 0 & dd <= val], 1i * seq(-val, val, step), '+')
  x_grid <- cmap(x_grid)
  matlines(Re(x_grid), Im(x_grid), lwd = 0.5, col = 1, lty = 1)
}

smith_grid(50, 10)
smith_grid(10, 1)
smith_grid(2, 0.2)
smith_grid(0.6, 0.1)

dev.off()
-------------------------------------------------------------------------------------------------------
reshape2 df = read.table(text="Isolate MIC1    MIC2     MIC3
    1   0.008   0.064   0.064
    2   0.016   0.250   0.500
    3   0.064   0.125   32", header=TRUE)

library(reshape2)
df_melted = melt(df, id.vars="Isolate", variable.name="antibiotic", value.name="MIC")
ggplot(df_melted, aes(factor(MIC))) + geom_bar() + facet_grid(antibiotic ~ .)
-------------------------------------------------------------------------------------------------------
sessionInfo() ggplot(dat.m, aes(date,  value)) + 
      scale_x_continuous(name="Time") + 
      expand_limits(y=0) +
      ylab("Variable") + 
      geom_step() + 
      facet_grid(variable~., scales="free_y")+ 
      scale_y_continuous(breaks = c(seq(0, 12, by = 2),seq(0, 150, by = 50)))
-------------------------------------------------------------------------------------------------------
# need indices.  Use Names or numeric index
rr <- if(is.null(rownames(myMatrix))) seq(nrow(myMatrix)) else rownames(myMatrix)
cc <- if(is.null(colnames(myMatrix))) seq(ncol(myMatrix)) else colnames(myMatrix)

inds <- as.matrix( expand.grid(X=rr, Y=cc) )


## as a data.frame
data.frame(inds, Dist=myMatrix[inds])

## as a list
ret <- apply(inds, 1, function(i) list(c(i, Dist=myMatrix[rbind(i)])))
# possibly unlist if needed
unlist(ret, recursive=FALSE) set.seed(1)
myMatrix <- matrix(sample(8, 22, TRUE), ncol=2, dimnames=list(LETTERS[1:11], letters[1:2]))
myMatrix
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(scales)

ggplot( mtcars[ mtcars$vs==1,], aes(factor(vs) )) +
  geom_bar(aes(y= ..count../ sum(..count..) )) +
  facet_grid(.  ~  am,)  + 
  scale_y_continuous(labels = percent_format()) ggplot ggplot data.table ggplot library(ggplot2)
library(scales)
library(plyr)

df1 <- ddply(mtcars, .(am, vs), summarise,
             percentage = length(vs[vs==1])/nrow(mtcars)) # percentages calculated
#respected the whole table. nrow(mtcars) can be changed with a subset of it in case
#of NAs not to be used taken into account for example.

> df1
  am vs percentage
1  0  0    0.00000
2  0  1    0.21875
3  1  0    0.00000
4  1  1    0.21875

ggplot( df1[ df1$vs==1, ], aes(factor(vs), percentage )) +
  geom_bar(sta="identity") +
  facet_grid(.  ~  am,)  + 
  scale_y_continuous(labels = percent_format())


df2 <- ddply(mtcars, .(am, vs), summarise,
             percentage = length(vs)) am df2 <- ddply(mtcars, .(am, vs), summarise,
             percentage = length(vs))

df2$tot <- ave(df2$percentage, df2$am, FUN=sum)
df2$percentage <- df2$percentage / df2$tot
df2$tot <- NULL

> df2
  am vs percentage
1  0  0  0.6315789
2  0  1  0.3684211
3  1  0  0.4615385
4  1  1  0.5384615

ggplot( df2[ df2$vs==1, ], aes(factor(vs), percentage )) +
  geom_bar(sta="identity") +
  facet_grid(.  ~  am,)  + 
  scale_y_continuous(labels = percent_format())
-------------------------------------------------------------------------------------------------------
par(las=1, bty = 'n')
point_colors  <- c("royalblue4", "gray")
subjects <- c("Comp. Sc.\n(17.2%)", "Physics\n(19.6%)", "Maths\n(29.4%)",
              "Pol. Sc.\n(40.4%)", "Psychology\n(69.8%)")
aVals <- c(52.36, 52.00, 55.43, 56.08, 62.89)
bVals <- c(53.57, 52.93, 56.07, 58.86, 63.87)
n <- length(aVals)
plot(1:n, aVals, ylim = c(50, 65), type = 'l', col=point_colors[1], xlab="Disciplines (% of women)", ylab = "Classification accuracy (%)", xaxt = 'n', panel.first = grid(nx = NA, ny = NULL))
lines(1:n, bVals, col = point_colors[2])
axis(1, 1:5, subjects, cex.axis = 0.85, tcl = -0.1)
text(c(3.25, 3.5), c(54, 59), c('aVals', 'bVals')) par(las=1, bty = 'n')
point_colors  <- c("royalblue4", "gray")
subjects <- c("Comp. Sc.\n(17.2%)", "Physics\n(19.6%)", "Maths\n(29.4%)",
              "Pol. Sc.\n(40.4%)", "Psychology\n(69.8%)")
xpos <- c(17.2, 19.6, 29.4, 40.4, 69.8)
aVals <- c(52.36, 52.00, 55.43, 56.08, 62.89)
bVals <- c(53.57, 52.93, 56.07, 58.86, 63.87)
n <- length(aVals)
plot(xpos, aVals, ylim = c(50, 65), type = 'l', col=point_colors[1], xlab="Disciplines (% of women)", ylab = "Classification accuracy (%)", xaxt = 'n', panel.first = grid(nx = NA, ny = NULL))
lines(xpos, bVals, col = point_colors[2])
axis(1, xpos, subjects, cex.axis = 0.85, tcl = -0.1)
text(c(3.25, 3.5), c(54, 59), c('aVals', 'bVals'))
-------------------------------------------------------------------------------------------------------
textGrob gtable_arrange <- function(..., grobs=list(), as.table=TRUE,
                           top = NULL, bottom = NULL, 
                           left = NULL, right = NULL, draw=TRUE){
  require(gtable)
  # alias
  gtable_add_grobs <- gtable_add_grob

  dots <- list(...)
  params <- c("nrow", "ncol", "widths", "heights",
              "respect", "just", "z") # TODO currently ignored

  layout.call <- intersect(names(dots), params)
  params.layout <- dots[layout.call]

  if(is.null(names(dots)))
    not.grobnames <- FALSE else
      not.grobnames <- names(dots) %in% layout.call

  if(!length(grobs))
  grobs <- dots[! not.grobnames ]

  ## figure out the layout
  n <- length(grobs)
  nm <- n2mfrow(n)

  if(is.null(params.layout$nrow) & is.null(params.layout$ncol)) 
  {
    params.layout$nrow = nm[1]
    params.layout$ncol = nm[2]
  }
  if(is.null(params.layout$nrow))
    params.layout$nrow = ceiling(n/params.layout$ncol)
  if(is.null(params.layout$ncol))
    params.layout$ncol = ceiling(n/params.layout$nrow)

  if(is.null(params.layout$widths))
    params.layout$widths <- unit(rep(1, params.layout$ncol), "null")
  if(is.null(params.layout$heights))
    params.layout$heights <- unit(rep(1,params.layout$nrow), "null")

  positions <- expand.grid(row = seq_len(params.layout$nrow), 
                           col = seq_len(params.layout$ncol))
  if(as.table) # fill table by rows
    positions <- positions[order(positions$row),]

  positions <- positions[seq_along(grobs), ] # n might be < ncol*nrow

  ## build the gtable, similar steps to gtable_matrix

  gt <- gtable(name="table")
  gt <- gtable_add_cols(gt, params.layout$widths)
  gt <- gtable_add_rows(gt, params.layout$heights)
  gt <- gtable_add_grobs(gt, grobs, t = positions$row, 
                            l = positions$col)

  ## titles given as strings are converted to text grobs
  if (is.character(top)) 
    top <- textGrob(top)
  if (is.character(bottom)) 
    bottom <- textGrob(bottom)
  if (is.character(right)) 
    right <- textGrob(right, rot = -90)
  if (is.character(left)) 
    left <- textGrob(left, rot = 90)

  if(!is.null(top)){
    gt <- gtable_add_rows(gt, heights=grobHeight(top), 0)
    gt <- gtable_add_grobs(gt, top, t=1, l=1, r=ncol(gt))
  }
  if(!is.null(bottom)){
    gt <- gtable_add_rows(gt, heights=grobHeight(bottom), -1)
    gt <- gtable_add_grobs(gt, bottom, t=nrow(gt), l=1, r=ncol(gt))
  }
  if(!is.null(left)){
    gt <- gtable_add_cols(gt, widths=grobWidth(left), 0)
    gt <- gtable_add_grobs(gt, left, t=1, b=nrow(gt), l=1, r=1)
  }
  if(!is.null(right)){
    gt <- gtable_add_cols(gt, widths=grobWidth(right), -1)
    gt <- gtable_add_grobs(gt, right, t=1, b=nrow(gt), l=ncol(gt), r=ncol(gt))
  }

  if(draw){
   grid.newpage()
   grid.draw(gt)
  }
  gt # load needed libraries
library(ggplot2)

# Set loop counter and create list to store objects
imax=37
plist <- list()
p <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_line() 

for(i in 1:imax){
  plist[[i]] <- p + ggtitle(i)
}

# build list of grobs
grob.list <- lapply(plist, ggplotGrob)

# prepare titles
title.main <- textGrob("Main title")
title.sub <- textGrob("Subtitle")

# then arrange as required
g <- gtable_arrange(ncol=6, grobs=grob.list, 
                    top=title.main, bottom=title.sub, draw=FALSE)
ann <- grobTree(rectGrob(), textGrob("Annotation box here"))
g <- gtable_add_grobs(g, ann, t=nrow(g)-1, l=2, r=ncol(g))

# save it all together
png(file = "out.png",width=1000, height=710, units = "px")
grid.draw(g)
dev.off()
-------------------------------------------------------------------------------------------------------
plot + geom_bar(stat="identity") + facet_wrap(~category, scales="free") facet_grid plot + geom_bar(stat="identity") + facet_grid(~category, scales="free") facet_wrap
-------------------------------------------------------------------------------------------------------
for for(s in 3:ncol(mylist[[1]])) { 
  for(i in 1:length(mylist)){ 
    boxplot(mylist[[i]][s])
  }
} par(mfrow=c(num.rows,num.cols)) ?boxplot ggplot2 # Stick your list together.
one.df<-do.call(rbind,mylist)
# Convert to "long-form".
library(reshape)
melted.df<-melt(one.df,id.vars=c('name','date'))
# Plot with ggplot2
ggplot(melted.df,aes(x=name,y=value)) + 
geom_boxplot() + facet_grid(variable~.,scales='free')
-------------------------------------------------------------------------------------------------------
ggplot(df.melt, aes(x = Claim, y = Ratings, fill = Agreement)) +              
    geom_bar(stat="identity") + coord_flip()+
    theme_classic(base_size = 15, base_family = "") + 
    scale_fill_brewer(palette="Paired") +
    theme(legend.position="top") +
    facet_grid(Categories~.) facet_grid
-------------------------------------------------------------------------------------------------------
require(data.table)
DT <- data.table(x)
DT[x%in%2:3,`:=`(ab=0,cd=1)] ijs <- expand.grid(with(x, which(x==2|x==3)),c(2:3))
ijs <- ijs[order(ijs$Var1),]

x[as.matrix(ijs)] <- c(0,1) x ab cd
1  0  0  0
2  2  0  1
3  2  0  1
4  2  0  1
5  3  0  1
6  2  0  1
7  0  0  0
8  0  0  0
9  2  0  1
10 2  0  1
-------------------------------------------------------------------------------------------------------
months() x mes pcp.mensual$month <- months(pcp.mensual$mes)
pcp.mensual$month <- factor(pcp.mensual$month, levels = unique(pcp.mensual$month))
ggplot(data=pcp.mensual,aes(x=pcp.mensual$month, y=Precip.mensual)) +
  facet_grid(ano ~. ) +
  geom_bar(colour="blue",stat="identity",fill="blue")
-------------------------------------------------------------------------------------------------------
set.seed(1)
df<-data.frame(expand.grid(c("Control","Effect"),c("Self","Other"),c("Type1","Type2")),
     runif(8,0,1))
colnames(df)<-c("Treatment","Group","Type","value")
df
  Treatment Group  Type     value
1   Control  Self Type1 0.2655087
2    Effect  Self Type1 0.3721239
3   Control Other Type1 0.5728534
4    Effect Other Type1 0.9082078
5   Control  Self Type2 0.2016819
6    Effect  Self Type2 0.8983897
7   Control Other Type2 0.9446753
8    Effect Other Type2 0.6607978 ymin ymax Treatment Type library(plyr)
df<-ddply(df,.(Treatment,Type),transform,ymax=max(value)+0.2)
df$ymin<-df$value+0.05
df
  Treatment Group  Type     value      ymax      ymin
1   Control  Self Type1 0.2655087 0.7728534 0.3155087
2   Control  Self Type2 0.2016819 1.1446753 0.2516819
3   Control Other Type1 0.5728534 0.7728534 0.6228534
4   Control Other Type2 0.9446753 1.1446753 0.9946753
5    Effect  Self Type1 0.3721239 1.1082078 0.4221239
6    Effect  Self Type2 0.8983897 1.0983897 0.9483897
7    Effect Other Type1 0.9082078 1.1082078 0.9582078
8    Effect Other Type2 0.6607978 1.0983897 0.7107978 ymax lab df.names<-ddply(df,.(Treatment,Type),summarise,ymax=ymax[1]+0.1)
df.names$lab<-c("p=0.46","**","***","*")
df.names
  Treatment  Type      ymax    lab
1   Control Type1 0.8728534 p=0.46
2   Control Type2 1.2446753     **
3    Effect Type1 1.2082078    ***
4    Effect Type2 1.1983897      * df geom_bar(stat="identity") stat_summary() geom_segment() geom_text() ggplot(df, aes(Group,value,fill=Group)) +    
  geom_bar(stat="identity") + facet_grid(Type~Treatment) + 
  theme(legend.position="none")+
  geom_segment(aes(x=Group,xend=Group,y=ymin,yend=ymax))+
  geom_segment(aes(x="Self",xend="Other",y=ymax,yend=ymax))+
  geom_text(data=df.names,aes(x=1.5,y=ymax,label=lab),inherit.aes=FALSE)
-------------------------------------------------------------------------------------------------------
... + facet_grid(as.formula(sprintf("%s ~ %s", rowfacet, colfacet))
-------------------------------------------------------------------------------------------------------
facet_grid() as.formula() facet_grid(as.formula(paste(rowfacet, "~", colfacet)))
-------------------------------------------------------------------------------------------------------
library(ggplot2)
a <- ggplot(mtcars, aes(mpg, hp)) +
  geom_point() +
  facet_grid(cyl~gear) 

strip.remover <- function(ggp, what="x") {
  require(gridExtra)

  zeroGrob <- function() {
    g0 <- grob(name="NULL")
    class(g0) <- c("zeroGrob",class(g0))
    g0
  }

  g <- ggplotGrob(ggp)

  g$grobs <- lapply(g$grob, function(gr) {
    if (any(grepl(paste0("strip.text.", what),names(gr$children)))) {
      gr$children[[grep("strip.background",names(gr$children))]] <- zeroGrob()
      gr$children[[grep("strip.text",names(gr$children))]] <- zeroGrob()
    }
    return(gr)
  }
  )

  class(g) = c("arrange", "ggplot",class(g)) 
  g
}

strip.remover(a, "y")
-------------------------------------------------------------------------------------------------------
expand.grid outer library(ggplot2)
testPts <- transform(expand.grid(x=1:10,y=1:5),z=sin(x*y))
(ggplot(data=testPts, aes(x=x, y=y, z=z))
 + stat_contour()
 + geom_point(aes(colour=z))
)
-------------------------------------------------------------------------------------------------------
df <- data.frame(lapply(df, as.character), stringsAsFactors=FALSE) expand.grid df y ind.mat = expand.grid(1:length(y), 1:nrow(df)) ind.mat data.frame(t(apply(ind.mat, 1, function(x){c(as.character(df[x[2], ]), y[x[1]])})))
-------------------------------------------------------------------------------------------------------
dl <- unclass(df)
dl$y <- y
merge(df, expand.grid(dl))
#   w x y
# 1 q b 1
# 2 q b 2
# 3 r a 1
# 4 r a 2
-------------------------------------------------------------------------------------------------------
pts.grid <- interp(as.data.frame(pts)$coords.x1, as.data.frame(pts)$coords.x2, as.data.frame(pts)$GWLEVEL_TI)
pts.grid2 <- expand.grid(x=pts.grid$x, y=pts.grid$y)
pts.grid2$z <- as.vector(pts.grid$z) stat_contour() (ggplot(as.data.frame(pts), aes(x=coords.x1, y=coords.x2, z=GWLEVEL_TI))
#+ geom_tile(data=na.omit(pts.grid2), aes(x=x, y=y, z=z, fill=z))
+ stat_contour(data=na.omit(pts.grid2), binwidth=2, colour="red", aes(x=x, y=y, z=z))
+ geom_point()
)
-------------------------------------------------------------------------------------------------------
keys.df <- expand.grid(d = unique(mydf$d),
                       t = unique(mydf$t))
full.df <- merge(keys.df, mydf, all.x = TRUE) ddply(full.df, .(t), function(x) cumprod(ifelse(is.na(x$r), 0, x$r) + 1) - 1)
      t   V1     V2       V3
1   ibm 0.01 0.0504 0.123928
2  appl 0.02 0.0710 0.156680
3 loser 0.03 0.0918 0.091800 ddply(full.df,.(t), transform, cum.r = cumprod(ifelse(is.na(r), 0, r) + 1) - 1)
-------------------------------------------------------------------------------------------------------
expand.grid merge mydf <- structure(list(FIRM = c("FIRM.1", "FIRM.1", "FIRM.2", "FIRM.2"),
    YEAR = c("YEAR.1", "YEAR.3", "YEAR.2", "YEAR.3"), VAR = c("x.1", "x.2",
    "x.3", "x.4")), .Names = c("FIRM", "YEAR", "VAR"),
    class = "data.frame", row.names = c(NA, -4L))
mydf
#     FIRM   YEAR VAR
# 1 FIRM.1 YEAR.1 x.1
# 2 FIRM.1 YEAR.3 x.2
# 3 FIRM.2 YEAR.2 x.3
# 4 FIRM.2 YEAR.3 x.4 expand.grid merge merge(mydf, expand.grid(FIRM = unique(mydf$FIRM), 
                        YEAR = unique(mydf$YEAR)), 
      all.y = TRUE)
#     FIRM   YEAR  VAR
# 1 FIRM.1 YEAR.1  x.1
# 2 FIRM.1 YEAR.2 <NA>
# 3 FIRM.1 YEAR.3  x.2
# 4 FIRM.2 YEAR.1 <NA>
# 5 FIRM.2 YEAR.2  x.3
# 6 FIRM.2 YEAR.3  x.4
-------------------------------------------------------------------------------------------------------
scale_y_continuous() percent_format() scales library(ggplot2)
library(scales)
ggplot(df,aes(x=1,y=Errors/Fields))+geom_bar(stat="identity")+
  facet_grid(~Hospital)+
  coord_polar(theta="y")+
  scale_y_continuous(labels = percent_format(),limits=c(0,1),
              breaks=c(0.25,0.5,0.75,1))+
  theme(axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())
-------------------------------------------------------------------------------------------------------
variable variable a.dfm2 <- transform(a.dfm, 
                    color.use = ifelse(variable=="var2", 
                                       as.character(color1), 
                                       as.character(color2)))

ggplot(a.dfm2, aes(x=value, y=var1, color=color.use)) + 
  geom_point(shape=1) + 
  facet_grid(. ~ variable)
-------------------------------------------------------------------------------------------------------
facet_wrap facet_grid ggplot(data=subset(a.df,group1!='NONE'), aes(x=var1)) + 
    geom_density() +
    facet_wrap( ~ group1, ncol = 2) +
    geom_density(data=subset(a.df,group1=='NONE', var1), aes(var1, color = "NONE")) +
    scale_color_manual(name = "Baseline", values = "blue") facet_grid require(reshape2)
dat2 = melt(a.df, measure.vars = c("group1", "group2"), variable.name = "group")

ggplot(data=subset(dat2, value != "NONE"), aes(x=var1)) +
    geom_density() + facet_grid(group ~ value) +
    geom_density(data=subset(dat2,value=='NONE', c(var1, group)), aes(var1), color = "blue") var1 NONE datnone datnone = cbind(dat2[dat2$value == "NONE", 2:3], 
             value = rep(1:4, each = nrow(dat2[dat2$value == "NONE",])) )

ggplot(data=subset(dat2, value != "NONE"), aes(x=var1)) +
    geom_density() + facet_wrap(group ~ value, ncol = 2) +
    geom_density(data = datnone, aes(var1), color = "blue") linetype color ggplot(data=subset(a.df,group1!='NONE'), aes(x=var1, color = "GROUP", linetype = "GROUP")) + 
    geom_density() +
    facet_wrap( ~ group1, ncol = 2) +
    geom_density(data=subset(a.df,group1=='NONE', var1), 
               aes(var1, color = "NONE", linetype = "NONE")) +
    scale_linetype_manual(values = c("solid", "dotted") ) +
    scale_color_manual(values = c("black", "red") )
-------------------------------------------------------------------------------------------------------
expand.grid #all possible paths of times (either 1.1. or 0.9) each previous value
    aa <- expand.grid(1, c(1.1,0.9), c(1.1,0.9), c(1.1,0.9), c(1.1,0.9)) 

    aa[,1] <- aa[,1] * 100 # start with 100

    for(i in 2:ncol(aa)) # fill by multiplying value of previous column
     {
      aa[,i] <- aa[,i] * aa[,i-1]
     }

    aa
    #Var1 Var2 Var3  Var4   Var5
    #1   100  110  121 133.1 146.41
    #2   100   90   99 108.9 119.79
    #3   100  110   99 108.9 119.79
    #4   100   90   81  89.1  98.01
    #5   100  110  121 108.9 119.79
    #6   100   90   99  89.1  98.01
    #7   100  110   99  89.1  98.01
    #8   100   90   81  72.9  80.19
    #9   100  110  121 133.1 119.79
    #10  100   90   99 108.9  98.01
    #11  100  110   99 108.9  98.01
    #12  100   90   81  89.1  80.19
    #13  100  110  121 108.9  98.01
    #14  100   90   99  89.1  80.19
    #15  100  110   99  89.1  80.19
    #16  100   90   81  72.9  65.61 expand.grid c(1.1,0.9)
-------------------------------------------------------------------------------------------------------
plot.xts add plot.xts plot.xtsMODIFIED<-function (x, y = NULL, type = "l", auto.grid = TRUE, major.ticks = "auto", 
    minor.ticks = TRUE, major.format = TRUE, bar.col = "grey", 
    candle.col = "white", ann = TRUE, axes = TRUE, ...) 
{
    series.title <- deparse(substitute(x))
    ep <- axTicksByTime(x, major.ticks, format.labels = major.format)
    otype <- type
    if (is.OHLC(x) && type %in% c("candles", "bars")) {
        x <- x[, has.OHLC(x, TRUE)]
        xycoords <- list(x = .index(x), y = seq(min(x), max(x), 
            length.out = NROW(x)))
        type <- "n"
    }
    else {
        if (NCOL(x) > 1) 
            warning("only the univariate series will be plotted")
        if (is.null(y)) 
            xycoords <- xy.coords(.index(x), x[, 1])
    }
    ###The next three lines are the only modifications i made to the function####
    plot(xycoords$x, xycoords$y, type = "n", axes = FALSE, ann = FALSE) 
    rect(par("usr")[1], par("usr")[3], par("usr")[2], par("usr")[4], col ="white")
    if(type=="l"){lines(xycoords$x, xycoords$y, ...)}

    if (auto.grid) {
        abline(v = xycoords$x[ep], col = "grey", lty = 4)
        grid(NA, NULL)
    }
    if (is.OHLC(x) && otype == "candles") 
        plot.ohlc.candles(x, bar.col = bar.col, candle.col = candle.col, 
            ...)
    dots <- list(...)
    if (axes) {
        if (minor.ticks) 
            axis(1, at = xycoords$x, labels = FALSE, col = "#BBBBBB", 
                ...)
        axis(1, at = xycoords$x[ep], labels = names(ep), las = 1, 
            lwd = 1, mgp = c(3, 2, 0), ...)
        axis(2, ...)
    }
    box()
    if (!"main" %in% names(dots)) 
        title(main = series.title)
    do.call("title", list(...))
    assign(".plot.xts", recordPlot(), .GlobalEnv)
} library(quantmod)
getSymbols('SPY', from='1998-01-01', to='2011-07-31', adjust=T)

GRAPH_BLUE<-rgb(43/255, 71/255,153/255)
GRAPH_BACKGROUND<-rgb(180/255, 226/255, 244/255)

par(bg=GRAPH_BACKGROUND)

plot.xtsMODIFIED(SPY, col=GRAPH_BLUE) Error in axis(1, at = xycoords$x, labels = FALSE, col = "#BBBBBB", ...) : formal argument "col" matched by multiple actual arguments. plot.xts ... col axis plot lines ...
axis(1, at = xycoords$x, labels = FALSE, col = "#BBBBBB", 
            ...)
... ...
axis(1, at = xycoords$x, labels = FALSE, ...)
... plot.xts plot.xtsMODIFIED<-function (x, y = NULL, type = "l", auto.grid = TRUE, major.ticks = "auto", 
                             minor.ticks = TRUE, major.format = TRUE, bar.col = "grey", 
                             candle.col = "white", ann = TRUE, axes = TRUE, 
                             lcol, ...) 
{
...
if(type=="l"){lines(xycoords$x, xycoords$y, lcol, ...)}
...
} plot.xtsMODIFIED(SPY, lcol=GRAPH_BLUE)
-------------------------------------------------------------------------------------------------------
for dat$Order==x generate.data <- function(n.order, n.date){
  dat <- expand.grid(Order=seq_len(n.order), date=seq_len(n.date))
  dat$Discharge <- rlnorm(n.order * n.date)
  dat[, c("Order", "Discharge", "date")]
}

dat <- generate.data(10, 5)

head(dat)
#   Order Discharge date
# 1     1 2.1925563    1
# 2     2 0.4093022    1
# 3     3 2.5525497    1
# 4     4 1.9274013    1
# 5     5 1.1941986    1
# 6     6 1.2407451    1
tail(dat)
#    Order Discharge date
# 45     5 1.4344575    5
# 46     6 0.5757580    5
# 47     7 0.4986190    5
# 48     8 1.2076292    5
# 49     9 0.3724899    5
# 50    10 0.8288401    5 dat$Order==4 dat[dat$Order==4, ]
#    Order Discharge date
# 4      4 1.9274013    1
# 14     4 3.5319072    2
# 24     4 0.2374532    3
# 34     4 0.4549798    4
# 44     4 0.7654059    5 Discharge dat[dat$Order==4, ]$Discharge
# [1] 1.9274013 3.5319072 0.2374532 0.4549798 0.7654059 x-1 x+1 x dat[dat$Order==4-1, ]$Discharge
# [1] 2.5525497 1.9143963 0.2800546 8.3627810 7.8577635
dat[dat$Order==4+1, ]$Discharge
# [1] 1.1941986 4.6076114 0.3963693 0.4190957 1.4344575 pmean cbind rowMeans rowMeans(cbind(dat[dat$Order==4-1, ]$Discharge, dat[dat$Order==4+1, ]$Discharge))
# [1] 1.8733741 3.2610039 0.3382119 4.3909383 4.6461105 dat[dat$Order==4, ]$Discharge <- rowMeans(cbind(dat[dat$Order==4-1, ]$Discharge,
                                                dat[dat$Order==4+1, ]$Discharge)) %in% x
-------------------------------------------------------------------------------------------------------
library("rgeos")
library("sp")
library("ggplot2")
library("plyr") rworldmap library("rworldmap")
data(countriesLow)
ctry <- countriesLow[countriesLow$ISO3.1 %in% c("TZA", "KEN", "UGA", "RWA", "BDI"),] head #generate a grid of points
xy<-expand.grid(long=seq(25,45,0.5),lat=seq(-15,5,0.5))
xy.sp <- SpatialPoints(xy, proj4string=CRS(proj4string(ctry)))
Overlay<-over(xy.sp,ctry)
xy<-xy[!is.na(Overlay$ISO3.1),] fx.ggplot fx.ggplot<-function(ctry, aesfill="id", scalefill="Country", pathcol="white") {
    ##ctry is a shapefile of countries
    ctry@data$id = rownames(ctry@data)
    ctry.points = fortify(ctry, region="id")
    ctry.df = join(ctry.points, ctry@data, by="id")
    ggplot(ctry.df, aes(long, lat)) +
        geom_polygon(aes_string(group="group", fill=aesfill)) +
        geom_path(colour = pathcol) +
        scale_fill_brewer(scalefill)
} aes long lat geom_polygon group fill aes_string (p <- fx.ggplot(ctry)) p + geom_point(data=xy)
-------------------------------------------------------------------------------------------------------
ifelse() aes() geom_text() Group ggplot(df, aes(x=Year, y=Score,colour=Group)) + geom_line(aes(group=Group),size=1.5) +
  facet_grid(.~ Test) + 
  geom_point(size=4, shape=21) +
  geom_text(aes(y=ifelse(Group=="Group B",Score+5,Score-5),label = Score))+
  scale_y_continuous(limits = c(0,100), breaks=seq(0,100,20))
-------------------------------------------------------------------------------------------------------
substr ggplot2 df.m$groups = substr(df.m$variable, 1, 10) color shape variable ggplot(df.m, aes(x=Years, y=value, colour=groups, shape=groups)) +
    geom_point(size=3) + 
    facet_grid(.~facet) +
    scale_colour_manual(values = c("chartreuse4", "deepskyblue3"))
-------------------------------------------------------------------------------------------------------
df library("ggplot2")
library("reshape2")
library("grid") df.m df.m <- melt(df, id="Years")
df.m$measure <- gsub("(.*) \\(.*", "\\1", df.m$variable)
df.m$facet <- gsub(".*\\((.*)\\)", "\\1", df.m$variable) colour shape variable shape colour ggplot(df.m, aes(group=1, x=Years, y=value, colour=measure, shape=measure)) +
    scale_colour_manual(name='', values=c('chartreuse4', 'deepskyblue3')) +
    scale_shape_manual(name='', values=c(19, 17)) +
    geom_point(size=3) +
    facet_grid(.~facet) +
    coord_cartesian(ylim=(c(0.0,0.45))) +
    scale_x_discrete("", expand=c(0.01, 0.01)) +
    scale_y_continuous(name="") +
    guides(colour=guide_legend(title='', ncol=2, keywidth=unit(2,'lines'))) +
    theme(legend.position="top",
          legend.key=element_blank(),
          legend.background=element_rect(colour='black', fill='transparent'),
          legend.text=element_text(size=12),
          panel.grid.minor = element_blank(),
          panel.margin=unit(1, 'lines'),
          axis.text=element_text(size=12,color="black"),
          axis.title=element_text(size=16),
          strip.text.y = element_text(size = 14)) breaks scale_colour_manual scale_shape_manual g <- g + scale_colour_manual(name='',
                             breaks=c('% of Women (Physics)', 'Divergence (Physics)'),
                             labels=c('% of Women', 'Divergence'),
                             values=c('chartreuse4', 'deepskyblue3','chartreuse4', 
                                      'deepskyblue3', 'chartreuse4', 'deepskyblue3'))
g <- g + scale_shape_manual(name='',
                            breaks=c('% of Women (Physics)', 'Divergence (Physics)'),
                            labels=c('% of Women', 'Divergence'),
                            values=c(19, 17, 19, 17, 19, 17))
-------------------------------------------------------------------------------------------------------
library(ggplot2)
g<- ggplot(myDF, aes(Environment, Time))
g + geom_point() + facet_grid(. ~ phylum) library(ggplot2)

 g<- ggplot(df1, aes(Environment, Time))
 g + geom_point() + facet_grid(phylum ~ .)
-------------------------------------------------------------------------------------------------------
las ?par barplot(bpsamplevalues, col = "#87DEE1", axes = FALSE, las = 2)
axis(side = 2, tick = FALSE, las = 1)
grid(nx = NA, ny = NULL, col = "white", lty = "solid")
-------------------------------------------------------------------------------------------------------
x <- expand.grid(seq(0.1,1,0.05),
                 seq(0.1,1,0.05),
                 seq(0.1,1,0.05)) x <- x[abs(rowSums(x)-1) < .Machine$double.eps ^ 0.5,]

#if order doesn't matter
unique(apply(x,1,sort), MARGIN=2)
#      15   33  51   69  87  105 123  141  393  411  429  447  465  483 771  789 807  825 #843 1149 1167 1185 1527 1545
#[1,] 0.1 0.10 0.1 0.10 0.1 0.10 0.1 0.10 0.15 0.15 0.15 0.15 0.15 0.15 0.2 0.20 0.2 0.20 0.2 0.25 0.25 0.25  0.3 0.30
#[2,] 0.1 0.15 0.2 0.25 0.3 0.35 0.4 0.45 0.15 0.20 0.25 0.30 0.35 0.40 0.2 0.25 0.3 0.35 0.4 0.25 0.30 0.35  0.3 0.35
#[3,] 0.8 0.75 0.7 0.65 0.6 0.55 0.5 0.45 0.70 0.65 0.60 0.55 0.50 0.45 0.6 0.55 0.5 0.45 0.4 0.50 0.45 0.40  0.4 0.35
-------------------------------------------------------------------------------------------------------
labeller facet_grid() facet_labels <- function(variable, value) {
  labels <- as.character(value)
  labels[labels == '(all)'] <- 'FOO'
  return (labels)
}

ggplot(mtcars, aes(mpg, wt)) + geom_point() +
  facet_grid(am ~ cyl, margins = "cyl", labeller = facet_labels)
-------------------------------------------------------------------------------------------------------
Error in eval(expr, envir, enclos) : object 'label' not found color=label shape=label ggplot() df_error_all inherit.aes=FALSE geom_segment() ggplot(df_all, mapping=aes(x=t, y=value, color=label, shape=label)) +  
  geom_point() + ggtitle('Test vs. Predicted') + geom_line() + facet_grid(. ~ group) +
  geom_segment(data=df_error_all, aes(x=x,y=y,xend=xend,yend=yend), 
                                size=0.3,inherit.aes=FALSE)
-------------------------------------------------------------------------------------------------------
expand.grid list replicate expand.grid(replicate(3, v, simplify=FALSE)) new.expand.grid <- function(input, reps) {
  expand.grid(replicate(reps, input, simplify = FALSE))
}

new.expand.grid(c(1, 2), 4)
#    Var1 Var2 Var3 Var4
# 1     1    1    1    1
# 2     2    1    1    1
# 3     1    2    1    1
# 4     2    2    1    1
# 5     1    1    2    1
# 6     2    1    2    1
# 7     1    2    2    1
# 8     2    2    2    1
# 9     1    1    1    2
# 10    2    1    1    2
# 11    1    2    1    2
# 12    2    2    1    2
# 13    1    1    2    2
# 14    2    1    2    2
# 15    1    2    2    2
# 16    2    2    2    2
-------------------------------------------------------------------------------------------------------
do.call new.expand.grid <- function(vec,nrep) do.call(expand.grid,rep(list(vec),nrep)) new.expand.grid(letters[1:2],4) Var1 Var2 Var3 Var4
1     a    a    a    a
2     b    a    a    a
3     a    b    a    a
4     b    b    a    a
5     a    a    b    a
6     b    a    b    a
7     a    b    b    a
8     b    b    b    a
9     a    a    a    b
10    b    a    a    b
11    a    b    a    b
12    b    b    a    b
13    a    a    b    b
14    b    a    b    b
15    a    b    b    b
16    b    b    b    b
-------------------------------------------------------------------------------------------------------
vs am rbind vs frame_labels mtcars2 = mtcars3 = mtcars4 = mtcars
mtcars2$vs = mtcars3$am = mtcars4$am = mtcars4$vs = "all"
mtcarsall = rbind(mtcars, mtcars2, mtcars3, mtcars4)

mtcarsall$vs = factor(mtcarsall$vs, levels = c("all", "0", "1"))

ggplot(mtcarsall, aes(x = wt, y = mpg)) + geom_point() + 
    facet_grid(vs ~ am, as.table = FALSE)+
    geom_text(data = frame_labels, position = NULL, aes(x = x, y = y, label = frame))
-------------------------------------------------------------------------------------------------------
library(ggplot2)

frame_labels <- data.frame(
frame = LETTERS[1:4],
vs = rep(0:1, each = 2),
am = rep(0:1, times = 2),
x = 5, y = 33)

p <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
p <- p + facet_grid(vs ~ am, margin = TRUE, as.table = FALSE)
print(p)
-------------------------------------------------------------------------------------------------------
p <- ggplot(mtcars, aes(factor(gear), mpg, fill=factor(gear)))
p <- p + scale_x_discrete()
p <- p + geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf, fill=(typeColor)))
p <- p + geom_boxplot()
p <- p + facet_grid(. ~ type)
p <- p + scale_fill_manual( values = c("black" = "black","white" = "white","3" = "green","4" = "red","5" = "blue"))
show(p)
-------------------------------------------------------------------------------------------------------
geom_rect ggplot(mtcars, aes(factor(gear), mpg, fill=factor(gear))) + 
        scale_x_discrete() + 
        geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf, fill=(typeColor)),
                  show_guide = FALSE) + 
        geom_boxplot() + 
        facet_grid(. ~ type) + 
        scale_fill_manual(values = c("black" = "black","white" = "white","3" = "green","4" = "red","5" = "blue"), 
                          limits=c("3","4","5"))
-------------------------------------------------------------------------------------------------------
predict rnglat <- range(dat$lat)
 rnglon <- range(dat$lon)
 xvals <- seq(rnglon[1], rnglon[2], len=100)
 yvals <- seq(rnglat[1], rnglat[2], len=100)
 griddf <- expand.grid(xvals, yvals)
 griddf$pred <- predict(fit, x=as.matrix(griddf) ) Tps predict.Krig newdata seq fit0
-------------------------------------------------------------------------------------------------------
ggplot(x, aes(x=QuanMethod, 
      y=ScaledGains,
      fill=BarType, 
      color=BarType, 
      linetype=BarType,
      group=group1)) +
geom_bar(stat="identity") +
facet_grid(ConnectType~System) +
scale_linetype_manual(values=linetypes1) +
scale_fill_manual(values = barcols) +
scale_color_manual(values=bordcols) +
xlab("Quantification Method") +
ylab("Percent Connectivity Gains") +
theme(legend.position = "bottom",
legend.title =element_blank())
-------------------------------------------------------------------------------------------------------
== {} p <- p + facet_grid(. ~ vs, labeller = label_bquote({alpha^a==alpha^b}==.(x)))
-------------------------------------------------------------------------------------------------------
p <- p + facet_grid(. ~ vs, labeller = label_bquote({alpha^a==alpha^b}==.(x)))
-------------------------------------------------------------------------------------------------------
library(data.table)
library(reshape2)

y <- c(10,20,15,5,9)

#getting all combinations    
allwduplicate <- data.table(expand.grid(p1 = 1:5, p2 = 1:5, p3 = 1:5, p4 = 1:5, p5 = 1:5) )
perms <- allwduplicate[(p1+p2+p3+p4+p5 == sum(1:5)) & (p1*p2*p3*p4*p5 == prod(1:5))] 

#melting dataset into easier structure
perms[,permid := 1:prod(1:5)]
perms <- data.table(melt(perms, id.vars = 'permid'))

# assigning treatement values
perms[,yvalue := y[value]]

# assigning whether treated or not
perms[,treated := 1]
perms[variable %in% c('p1','p2'),treated := 0]

# calculating means of treated 3 vs. non treated 2
perms <- merge(
   perms[treated == 1,list(yvmean1 = mean(yvalue)), by = c('permid')],
   perms[treated == 0,list(yvmean0 = mean(yvalue)), by = c('permid')],
   by = 'permid'
   )

# treatementdiff is the value you want, I think
perms[,treatementdiff := ymean1 - ymean0]
-------------------------------------------------------------------------------------------------------
gsub new <- c("up.p33-dw.p33","up.p33-dw.p38", "up.p33-dw.p52")
old <- c("Nr11" ,"Nr12", "Nr131", "Nr132" )

old <- new[as.integer(gsub('^Nr[0-9]([0-9]).*','\\1',old))]

[1] "up.p33-dw.p33" "up.p33-dw.p38" "up.p33-dw.p52" "up.p33-dw.p52" merge letters[1:16] dd <- expand.grid(1:4,1:4)
dat.match <- data.frame(nr = paste0('Nr',mapply(paste0,dd[,1],dd[,2])),
                       gene =letters[seq_len(16)])

   nr gene
1  Nr11    a
2  Nr21    b
3  Nr31    c
4  Nr41    d
5  Nr12    e
6  Nr22    f
7  Nr32    g
8  Nr42    h
9  Nr13    i
10 Nr23    j
11 Nr33    k
12 Nr43    l
13 Nr14    m
14 Nr24    n
15 Nr34    o
16 Nr44    p merge nr.genes <-c("Nr11", "Nr12", "Nr131", "Nr132")
genes <- data.frame(nr=gsub('(^Nr[0-9]{2}).*','\\1',nr.genes))
merge(genes,dat.match)

  nr gene
1 Nr11    a
2 Nr12    e
3 Nr13    i
4 Nr13    i
-------------------------------------------------------------------------------------------------------
x <- expand.grid(rep(list(c('A', 'G', 'T', 'C')), 4))
do.call(paste0, x) chartr x <- c(1111, 1112, 1113, 1114, 1121)
chartr('1234', 'AGCT', x)
# [1] "AAAA" "AAAG" "AAAC" "AAAT" "AAGA"
-------------------------------------------------------------------------------------------------------
lubridate paste date Date require(lubridate)
bktst.plotdata$date2 = as.Date(with(bktst.plotdata, 
                                    paste(year(date), month(date), "01", sep = "-"))) scales require(scales)
ggplot(data=bktst.plotdata, aes(x = date2, y=Percent_error, colour=method)) +
    facet_grid(product~type,scales="free_y") +
    ggtitle("Percent Error - Month-over-Month") +
    xlab("Date") + ylab("Error (%)") +
    geom_line() +
    scale_x_date(labels=date_format(format = "%m-%Y"))
-------------------------------------------------------------------------------------------------------
a <- expand.grid(rep(list(1:4), 4))
b <- numeric(256)

generating_numbers <- function() {
for(i in 1:nrow(a)) {
    z <- paste(a[i,],collapse=" ") 
    b[i] <- z }
}

generating_numbers() for() b <- apply(a,1,paste,collapse=" ") a <- expand.grid(rep(list(1:4), 4))

generating_numbers <- function() {
  b <- NULL
  for(i in 1:nrow(a)) {
    z <- a[i,] 
    b[[i]] <- as.numeric(z) }
  return(b)
}

generating_numbers() b <- as.list(as.data.frame(t(a)))
-------------------------------------------------------------------------------------------------------
vecout<-function(...)as.vector(outer(...))

 f2<-function(a,b,c,A,B,C){
 N<-length(a)
 t<-length(A)

 ab<-vecout(a,b)
 ret<-array(vecout(ab,c),c(N,N,N))*t

 ret<-ret - ab * sum(C)
 ret<-ret - vecout(a,rep(c,each = N)) * sum(B)
 ret<-ret - rep(vecout(b,c) * sum(A),each=N)
 ret<-ret + a * sum(B*C)
 ret<-ret + rep(b * sum(A*C),each=N)
 ret<-ret + rep(c * sum(A*B),each=N^2)
 ret<-ret - sum(A*B*C)
 ret
 } f1<-function(a,b,c,A,B,C){
 N<-length(a)
 ret<-array(0,c(N,N,N))
 for(i in 1:N)
  for(j in 1:N)
   for(k in 1:N)
    ret[i,j,k]<-sum((a[i]-A)*(b[j]-B)*(c[k]-C))
 ret
 } > a<-rnorm(100)
> b<-rnorm(100)
> c<-rnorm(100)
> A<-rnorm(200)
> B<-rnorm(200)
> C<-rnorm(200)
> system.time(r1<-f1(a,b,c,A,B,C))
   user  system elapsed 
  9.006   1.125  10.204 
> system.time(r2<-f2(a,b,c,A,B,C))
   user  system elapsed 
  0.203   0.033   0.242 
> max(abs(r1-r2))
[1] 1.364242e-12 f3<-function(a,A){
  subsets<-as.matrix(expand.grid(rep(list(c(F,T)),ncol(a))))
  ret<-array(0,rep(nrow(a),ncol(a)))

  for(i in 1:nrow(subsets)){
    sub<-as.logical(subsets[i,])
    temp<-Reduce(outer,as.list(data.frame(a[,sub,drop=F])),init=1)
    temp<-temp*sum(apply(A[,!sub,drop=F],1,prod))
    temp<-aperm(array(temp,dim(ret)),order(c(which(sub),which(!sub))))
    ret<-ret+temp*(-1)^(sum(!sub))
  } 
  ret
}

> system.time(r3<-f3(cbind(a,b,c),cbind(A,B,C)))
   user  system elapsed 
  0.258   0.056   0.303 
> max(abs(r3-r1))
[1] 9.094947e-13 A B C A B C a b c f4<-function(a,A){
  ret<-array(0,rep(nrow(a),ncol(a)))
  for(i in 1:nrow(A)){
    temp<- Reduce(outer,as.list(data.frame(a-rep(A[i,],each=nrow(a)))),init=1)
    ret<-ret + as.vector(temp )
  }
  ret
} a b c 100 A B C 200 > system.time(r3<-f3(cbind(a,b,c),cbind(A,B,C)))
   user  system elapsed 
  0.704   0.092   0.256 
> system.time(r4<-f4(cbind(a,b,c),cbind(A,B,C)))
   user  system elapsed 
 65.824  19.060   3.553 
> max(abs(r3-r4))
[1] 2.728484e-12 A B C 1 > A<-rnorm(1)
> B<-rnorm(1)
> C<-rnorm(1)
> system.time(r3<-f3(cbind(a,b,c),cbind(A,B,C)))
   user  system elapsed 
  0.796   0.172   0.222 
> system.time(r4<-f4(cbind(a,b,c),cbind(A,B,C)))
   user  system elapsed 
  0.180   0.012   0.017 
> max(abs(r3-r4))
[1] 7.105427e-15
-------------------------------------------------------------------------------------------------------
library(plyr)

# create some data
set.seed(123)
df1 <- data.frame(vals = rnorm(1000, 10),
                  y = sample(LETTERS[1:3], 1000, replace = TRUE),
                  z = sample(letters[1:3], 1000, replace = TRUE))

# calculate the normal theoretical quantiles per group
df2 <- ddply(.data = df1, .variables = .(y, z), function(dat){
             q <- qqnorm(dat$vals, plot = FALSE)
             dat$xq <- q$x
             dat
}
)

# plot the sample values against the theoretical quantiles
ggplot(data = df2, aes(x = xq, y = vals)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  xlab("Theoretical") +
  ylab("Sample") +
  facet_grid(y ~ z)
-------------------------------------------------------------------------------------------------------
actiontype$lastAction 'reset' actiontype$lastAction 'draw' else temp xval yval NULL input$coords input$coords input$coords NULL #server.R
library(shiny)
N = 30
x = sort(runif(N, 0, 10)); y = x + rnorm(N)
xval=NULL
yval=NULL
checker <- 1 #### CHANGE

shinyServer(function(input, output) {
get.coords <- reactive({
    data.frame(x=input$coords$x, y=input$coords$y)
})

actiontype <- reactiveValues()
actiontype$lastAction <- 'draw'

observe({
    if (input$reset != 0)
        actiontype$lastAction <- 'reset'
})
observe({
    if (input$closepolygon != 0)
        actiontype$lastAction <- 'closepolygon'
})

output$diagPlot = renderPlot({
    plot(x, y, xlim = range(x), ylim = range(y))
    grid()

    if (identical(actiontype$lastAction, 'reset')) {
        xval <<- NULL
        yval <<- NULL
        checker <<- 0 ####CHANGE
        actiontype$lastAction <- 'draw'

    } else if (identical(actiontype$lastAction, 'draw')){
        temp <- get.coords()
        xval <<- c(xval,temp$x)
        yval <<- c(yval,temp$y)

        ########### CHANGE...
        if(identical(checker, 0))
         {
           points(xval, yval, pch = 19, col = rgb(1,0,0,0), cex = 1.5)
           xval <<- NULL
           yval <<- NULL
           checker <<- 1
         }else
         {
          points(xval, yval, pch = 19, col = 'red', cex = 1.5)
         }
        ############# ...CHANGE

        for (i in 1:(length(xval)-1))
             lines(c(xval[i],xval[i+1]),c(yval[i],yval[i+1]),type="l",col="blue")
        if(identical(actiontype$lastAction, 'closepolygon'))
       lines(c(xval[1],xval[length(xval)]),c(yval[1],yval[length(yval)]),
              type="l",col="blue")
    }
}, width = 700, height = 600)
}) input$coords input$coords checker 1 0
-------------------------------------------------------------------------------------------------------
bar ## second try--facet by county

N = 100
industry = ['a','b','c']
city = ['x','y','z']
ind = np.random.choice(industry, N)
cty = np.random.choice(city, N)
jobs = np.random.randint(low=1,high=250,size=N)
df_city =pd.DataFrame({'industry':ind,'city':cty,'jobs':jobs})

## how many panels do we need?
cols =df_city.city.value_counts().shape[0]
fig, axes = plt.subplots(1, cols, figsize=(8, 8))

for x, city in enumerate(df_city.city.value_counts().index.values):
    data = df_city[(df_city['city'] == city)]
    data = data.groupby(['industry']).jobs.sum()
    print (data)
    print type(data.index)
    left=  [k[0] for k in enumerate(data)]
    right=  [k[1] for k in enumerate(data)]

    axes[x].bar(left,right,label="%s" % (city))
    axes[x].set_xticks(left, minor=False)
    axes[x].set_xticklabels(data.index.values)

    axes[x].legend(loc='best')
    axes[x].grid(True)
    fig.suptitle('Employment By Industry By City', fontsize=20)
-------------------------------------------------------------------------------------------------------
#define a function
fun <- function(a,b) (25*a+20*b) == 1600 #alternative function
fun <- function(a,b,tol=.Machine$double.eps ^ 0.5) abs(25*a+20*b-1600) < tol

#create all possible combinations
paras <- expand.grid(a=c(240:600)/10, b=20:50)
paras[fun(paras$a,paras$b),]

         a  b
241   48.0 20
594   47.2 21
947   46.4 22
1300  45.6 23
1653  44.8 24
2006  44.0 25
2359  43.2 26
2712  42.4 27
3065  41.6 28
3418  40.8 29
3771  40.0 30
4124  39.2 31
4477  38.4 32
4830  37.6 33
5183  36.8 34
5536  36.0 35
5889  35.2 36
6242  34.4 37
6595  33.6 38
6948  32.8 39
7301  32.0 40
7654  31.2 41
8007  30.4 42
8360  29.6 43
8713  28.8 44
9066  28.0 45
9419  27.2 46
9772  26.4 47
10125 25.6 48
10478 24.8 49
10831 24.0 50
-------------------------------------------------------------------------------------------------------
data.table ggplot ggplot require(data.table)
dt.m2 <- data.table(df.m2)
dt.m2[, count:=.N, by=list(Indicators, Categories)] # create the count index 
# almost the same as before
p <- ggplot(dt.m2, aes(Indicators, fill=Condition))
p + coord_cartesian(ylim=c(-.3,12.3)) +
  geom_bar(stat="bin", colour="gray", alpha=.7) +
  geom_text(aes(y=count+1, label=paste0("n=", count))) + # add text above bar
  # you may have to change the y position for this to look good
  scale_fill_manual(values = c("green","yellow","red")) +
  theme(axis.text.x = element_text(angle = 90,vjust= .5,hjust=1)) +
  labs(x = "Farmers' Indicators", y = "Number of Rankings by Farmers") +
  facet_grid(Community ~ Categories, scales = "free_x")
-------------------------------------------------------------------------------------------------------
griddg Tps xvals <- seq(-10, 4, len=20)
yvals <- seq(49, 63, len=20)
griddf <- expand.grid(lon=xvals, lat=yvals)
griddg <- predict(fit, x=as.matrix(griddf) )

dat2 <- cbind(griddf, mm=griddg)
head(dat2)
fit <- Tps(cbind(dat2$lon, dat2$lat), dat2$mm, scale.type="unscaled")
surface (fit, nx=100, ny=100)
world(add=TRUE) Tps #option 2
source("matrix.poly.r") #http://menugget.blogspot.de/2012/04/create-polygons-from-matrix.html
source("val2col.R") # http://menugget.blogspot.de/2011/09/converting-values-to-color-levels.html
source("image.scale.R") # http://menugget.blogspot.de/2011/08/adding-scale-to-image-plot.html

#new grid and predition
xvals <- seq(-10, 4, len=100)
yvals <- seq(49, 63, len=100)
griddf <- expand.grid(lon=xvals, lat=yvals)
griddg <- predict(fit, x=as.matrix(griddf) )

#make polygons for new grid, calculate color levels
mat <- matrix(griddg, nrow=length(xvals), ncol=length(yvals))
poly <- matrix.poly(xvals, yvals, z=mat, n=seq(mat))
pal <- colorRampPalette(c("blue", "cyan", "yellow", "red"))
COL <- val2col(mat, col=pal(100))

#required packages
library(maps)
library(mapproj)

#plot
png("tmp.png", width=5, height=4, res=400, units="in")
layout(matrix(1:2, nrow=1, ncol=2), widths=c(4,1), heights=4)
par(mar=c(1,1,1,1))
map("world", proj="stereographic", orient=c(mean(yvals),mean(xvals),0), par=NULL, t="n", xlim=range(xvals), ylim=range(yvals))
for(i in seq(poly)){
 polygon(mapproject(poly[[i]]), col=COL[i], border=COL[i], lwd=0.3)
}
map("world", proj="stereographic", orient=c(mean(yvals),mean(xvals),0), par=NULL, add=T)
map.grid(col=rgb(0,0,0,0.5), labels=F)
box()

par(mar=c(5,0,5,4))
image.scale(mat, col=pal(100), horiz=FALSE, axes=FALSE, xlab="", ylab="")
axis(4)
mtext("mm", side=4, line=2.5)
box()

dev.off()
-------------------------------------------------------------------------------------------------------
mapply fun <- function(row.o, row.d)
{
 lines(c(o[row.o,1], d[row.d,1]), c(o[row.o,2], d[row.d,2]), 
         lwd = 2 * s[row.o,row.d] / mean(s))
}

#all combinatios of rows of `d` and `o` 
args.od <- expand.grid(1:nrow(o), 1:nrow(d))

mapply(fun, row.o = args.od[,1], row.d = args.od[,2])
-------------------------------------------------------------------------------------------------------
import rpy2.robjects as ro

ro.globalenv['dr'] = dr

ro.r("""
library(ggplot2)
names(dr) <- c('letters','bool','n','value')

x <- ggplot() +
  geom_bar(data=dr, aes(y = value, x = letters, fill = bool), 
           stat="identity", position='stack') +
  theme_bw() + 
  facet_grid( ~ n)

print(x)
""") make_plot = ro.r("""
function(dr) {
  names(dr) <- c('letters','bool','n','value')

  x <- ggplot() +
    geom_bar(data=dr, aes(y = value, x = letters, fill = bool), 
             stat="identity", position='stack') +
    theme_bw() + 
    facet_grid( ~ n)

  print(x)
}""")

make_plot(dr) from rpy2.robjects import Formula
from rpy2.robjects.lib.ggplot2 import ggplot, geom_bar, aes_string, theme_bw, facet_grid

## oddity with names in the examples, that can either be corrected in the Python-pandas
## structure or with an explicit conversion into an R object and renaming there
drr = rpy2.robjects.pandas2ri.pandas2ri(dr)
drr.names[2] = 'n'
drr.names[3] = 'value'

p = ggplot(drr) + \
    geom_bar(aes_string(x="letters", y="value", fill="bool"),
             stat="identity", position="stack") + \
    theme_bw() + \
    facet_grid(Formula('~ n'))

p.plot()
-------------------------------------------------------------------------------------------------------
require(ggplot2)
require(plyr)

df <- data.frame(x = c(1:100))
df$y <- 2 + 3 * df$x + rnorm(100, sd = 40)


lm_eqn = function(df){
    m = lm(y ~ x, df);
    eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
         list(a = format(coef(m)[1], digits = 2), 
              b = format(coef(m)[2], digits = 2), 
             r2 = format(summary(m)$r.squared, digits = 3)))
    as.character(as.expression(eq));                 
} df$group <- c(rep(1:2,50)) eq <- ddply(df,.(group),lm_eqn) p <- ggplot(data = df, aes(x = x, y = y)) +
            geom_smooth(method = "lm", se=FALSE, color="black", formula = y ~ x) +
            geom_point()
p1 = p + geom_text(data=eq,aes(x = 25, y = 300,label=V1), parse = TRUE, inherit.aes=FALSE) + facet_grid(group~.)
p1
-------------------------------------------------------------------------------------------------------
city facet_grid() ggplot(forecl, aes(x = month, y = value, color = city, group = city)) +
  geom_line() +
  facet_grid( ~ city)
-------------------------------------------------------------------------------------------------------
coord_fixed library(ggplot2)    
df <- data.frame(x=rep(1,3), y=rep(1,3), z=factor(letters[1:3]))
p <- ggplot(df, aes(x, y)) + geom_point() + facet_grid(z ~ .)
p + coord_fixed(ratio=1)
-------------------------------------------------------------------------------------------------------
NA expand.grid(c(NA,1),c(NA,1)) NA NULL d <- data.frame(x = 1:5)
> d$y <- list("a",1,2,3,"b")
> d
  x y
1 1 a
2 2 1
3 3 2
4 4 3
5 5 b
> str(d)
'data.frame':   5 obs. of  2 variables:
 $ x: int  1 2 3 4 5
 $ y:List of 5
  ..$ : chr "a"
  ..$ : num 1
  ..$ : num 2
  ..$ : num 3
  ..$ : chr "b"
-------------------------------------------------------------------------------------------------------
color=animals fill=animal scale_color_brewer() scale_fill_brewer() qplot(animals, value, data = data, fill=animals)+ 
  geom_boxplot() + facet_grid(~region) + scale_fill_brewer()
-------------------------------------------------------------------------------------------------------
summary() summary(p)
data: mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb [32x11]
mapping:  colour = am, shape = am, x = hp, y = mpg
faceting: facet_grid(gear ~ cyl) 
-----------------------------------
geom_point:  
stat_identity:  
position_identity: (width = NULL, height = NULL)
-------------------------------------------------------------------------------------------------------
reorder() df2 <- df[df$sex==1,]
p1 <- ggplot(df2, aes(y=(reorder(id, id))))
p1 <- p1 + geom_point(aes(x=year))
p1


df3 <- df[df$sex==0,]
p2 <- ggplot(df3, aes(y=(reorder(id, id))))
p2 <- p2 + geom_point(aes(x=year)) require(gridExtra)
grid.arrange(p1, p2, ncol=2) drop=TRUE p <- ggplot(df, aes(y=reorder(id, id)))
p <- p + geom_point(aes(x=year))
p <- p + facet_grid(sex ~.)
p
-------------------------------------------------------------------------------------------------------
annotate geom_text ggplot(testdat,aes(Combo, Start, ymin=Start,ymax=End,color=as.factor(Grant),xticks)) + 
  xlab("Sponsor") + geom_linerange(size=4,alpha=.7) + geom_point(size=4,shape=18) + coord_flip()  + 
  scale_colour_brewer(palette="Spectral") + 
  scale_x_discrete(labels=testdat$Sponsor) + 
  geom_hline(yintercept = as.numeric(YearLine),alpha=0.6,col="indianred1",linetype="dotted")  + 
  geom_text(aes(x=Combo, y=Start, label = testdat$Last), colour="black") +
  facet_grid(Sponsor ~ .,scale="free_x",space="free_x") annotate
-------------------------------------------------------------------------------------------------------
facet_grid() geom_point() library(ggplot2)

plot1 = ggplot(mtcars, aes(x=factor(gear), y=mpg, colour=factor(gear))) +
        geom_boxplot(space=0) + 
        facet_grid(. ~ cyl, labeller="label_both")

plot2 = plot1 + geom_point()

library(gridExtra)
ggsave(filename="plots.png", plot=arrangeGrob(plot1, plot2, ncol=2), 
       width=10, height=4, dpi=120)
-------------------------------------------------------------------------------------------------------
rasterVis::hovmoller RasterLayer RasterLayer zonal RasterStack library('raster')

dirLayer <- init(SISmm, v='y')
z <- zonal(SISmm, dirLayer, FUN='mean', digits=2) data.frame lattice::levelplot ## Time on the x-axis, latitude on the y-axis
dat <- expand.grid(y=z[,1], x=idx)
dat$z <- as.vector(z[,-1], mode='numeric')

levelplot(z ~ x*y, data=dat,
          xlab='Time', ylab='Latitude',
          panel=panel.levelplot.raster,
          interpolate=TRUE,
          par.settings=RdBuTheme())
-------------------------------------------------------------------------------------------------------
melt matrix data.frame melt(as.matrix(dat))
#     Var1 Var2     value
# 1   Cubn  FOO 3.7145516
# 2 Gm9779  FOO 2.5605166
# 3   Apod  FOO 3.5179670
# 4   Cubn  BAR 0.2374546
# 5 Gm9779  BAR 0.2085075
# 6   Apod  BAR 0.1959992 melt reshape2:::melt.matrix labels <- expand.grid(lapply(dn, var.convert), KEEP.OUT.ATTRS = FALSE, 
    stringsAsFactors = FALSE)
-------------------------------------------------------------------------------------------------------
code1<-c("AAA","BBB","DDD","EEE","FFF")
code2<-c("Yyy","Zzzzz")
code3<-seq(1970,2011,1) 
params <- expand.grid(code1, code2, code3)
names(params) <- c('code1', 'code2', 'code3')

myFunc <- function(code1, code2, code3) {
    ##add your function code here.
  ...
  ...
  return(output2$out[,2])
}

    LL <- mapply(FUN=myFunc, code1 = params$code1, code2 = params$code2, code3 = params$code3)
    result <- split(LL, rep(1:ncol(LL), each = nrow(LL)))
    result <- do.call(rbind, result)
    result <- cbind(result, params)         result <- cbind(result, params)
-------------------------------------------------------------------------------------------------------
d <- read.table(
  text='name    date         cat1    cat2    cat3    cat4    cat5
joe     15/09/2013   A       D       C       D       NA
joe     14/09/2013   D       A       C       NA      NA
joe     13/09/2013   A       C       NA      NA      NA
jack    15/09/2013   G       I       K       D       O
jack    14/09/2013   H       G       O       M       K', 
  header=T, stringsAsFactors=FALSE)

library(plyr)
ddply(d, 'name', function(x) {
  combns <- expand.grid(seq_len(nrow(x)), seq_len(nrow(x)))
  combns <- combns[!combns[, 1] == combns[, 2], ]
  mean(sapply(seq_len(nrow(combns)), function(i) {
    n <- sum(!is.na(unique(unlist(x[combns[i, 1], -(1:2)]))))
    sum(!is.na(match(unique(unlist(x[combns[i, 1], -(1:2)])), 
                     unique(unlist(x[combns[i, 2], -(1:2)])), 
                     incomparables=NA))) / n
  }))
})
-------------------------------------------------------------------------------------------------------
$grid$pts kohonen $codes lattice require ("kohonen")
require ("latticeExtra")
require ("deldir")
som.wines <- som (scale (wines), grid = somgrid(5, 5, "hexagonal"))

df <- as.data.frame (cbind (som.wines$grid$pts, som.wines$codes))
levelplot (alcohol ~ x * y, data = df, panel = panel.voronoi, aspect = "iso)
-------------------------------------------------------------------------------------------------------
lin_mods <- vector(mode = "list", length = 100)
quad_mods  <- vector(mode = "list", length = 100)

for(i in 1:100){
    # ....
    lin_mods[[i]]  <- model.1
    quad_mods[[i]] <- model.2
}

randy_linear    <- sample(1:100, 5, replace=F) 
randy_quadradic <- sample(1:100, 5, replace=F)

rand_lin_mods  <- lin_mods[randy_linear]
rand_quad_mods <- quad_mods[randy_quadradic] pred_grid <- expand.grid(y = seq(min(data$y), max(data$y), length = 100)
get_fit <- function(model, newdata){
    newdata$fit <- predict(model, newdata = newdata)
    return(newdata)
}    

library(plyr)
names(randy_lin_mods) <- 1:5
names(randy_quad_mods) <- 1:5

lin_fits  <- ldply(randy_lin_mods,  get_fit, newdata = pred_grid)
quad_fits <- ldply(randy_quad_mods, get_fit, newdata = pred_grid) lin_fits quad_fits
-------------------------------------------------------------------------------------------------------
d1 d2 Total d2 <- d1
d2$x <- "Total" d1 d2 x coord_flip() ggplot()+geom_point(data=d1,aes(x=x,y=v1))+
  geom_boxplot(data=d2,aes(x=x,y=v1))+
  facet_wrap(~group ,
             scales = "free_x") grid.arrange() gridExtra library(gridExtra)

p1<-ggplot()+geom_point(data=subset(d1,group=="g1"),aes(x=x,y=v1))+
  geom_boxplot(data=subset(d2,group=="g1"),aes(x=x,y=v1))+
  coord_flip()+
  facet_grid(group~.)+
  scale_y_continuous(limits=c(-2,2.5))+
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

p2<-ggplot()+geom_point(data=subset(d1,group=="g2"),aes(x=x,y=v1))+
  geom_boxplot(data=subset(d2,group=="g2"),aes(x=x,y=v1))+
  coord_flip()+
  facet_grid(group~.)+
  scale_y_continuous(limits=c(-2,2.5))+
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

p3<-ggplot()+geom_point(data=subset(d1,group=="g3"),aes(x=x,y=v1))+
  geom_boxplot(data=subset(d2,group=="g3"),aes(x=x,y=v1))+
  coord_flip()+
  facet_grid(group~.)+
  scale_y_continuous(limits=c(-2,2.5))

grid.arrange(p1,p2,p3)
-------------------------------------------------------------------------------------------------------
facet_grid data.frame as.double factor numeric ggplot aes [ facet_grid names CP <- as.data.frame(Compare)

CP[[1]] <- as.numeric(as.character(CP[[1]]))
CP[[2]] <- as.numeric(as.character(CP[[2]]))
# your data.frame names are..
names(CP)
# [1] "V1" "V2" "V3" "V4"

ggplot(CP, aes(x = V1, y = V2, colour = V3)) +
 geom_point() + facet_grid(V4 ~ . )
-------------------------------------------------------------------------------------------------------
as.ff_matrix.ffdf ffbase:::as.ff_matrix.ffdf require(ffbase)
x <- expand.ffgrid(a = ff(1:10), b = ffseq(1,1000))
y <- ffbase:::as.ff_matrix.ffdf(x)
class(y)
[1] "ff_matrix" "ff_array"  "ff"
-------------------------------------------------------------------------------------------------------
expand.grid colSums matrix #  Some reproducible 6x6 sample data
set.seed(1)
m <- matrix( sample(10,36,repl=TRUE) , ncol = 6 )
#     [,1] [,2] [,3] [,4] [,5] [,6]
#[1,]    3   10    7    4    3    5
#[2,]    4    7    4    8    4    6
#[3,]    6    7    8   10    1    5
#[4,]   10    1    5    3    4    2
#[5,]    3    3    8    7    9    9
#[6,]    9    2   10    2    4    7


#  Vector source for column combinations
n <- seq_len( ncol(m) )

#  Make combinations
id <- expand.grid( n , n )

#  Get result
out <- matrix( colSums( m[ , id[,1] ] == m[ , id[,2] ] ) , ncol = length(n) )
diag(out) <- 0
#    [,1] [,2] [,3] [,4] [,5] [,6]
#[1,]    0    1    1    0    2    0
#[2,]    1    0    0    1    0    0
#[3,]    1    0    0    0    1    0
#[4,]    0    1    0    0    0    0
#[5,]    2    0    1    0    0    1
#[6,]    0    0    0    0    1    0
-------------------------------------------------------------------------------------------------------
dt <- dt[,avg_score := mean(score),by = subject]

ggplot(dt,aes(x=cohort, y=score)) + 
    facet_grid(subject~.) + 
    stat_summary(fun.data="mean_cl_normal") +
    geom_hline(aes(yintercept = avg_score),color = "blue",linetype = "dashed") + 
    ylim(0,100)
-------------------------------------------------------------------------------------------------------
stat_* aes geom_* ggplot(dt,aes(x=cohort, y=score)) +
       stat_summary(fun.data="mean_cl_normal") + 
       stat_smooth(formula=y~1,aes(group=1),method="lm",se=FALSE) +
       facet_grid(subject~.) + ylim(0,100)
-------------------------------------------------------------------------------------------------------
## LIBRARY (must be installed)
    require(ggplot2)

    ## CREATE THE GENEMAP DATA
    geneMap<-data.frame(1:100,expand.grid(1:10,1:10),rnorm(100,6,2))
    colnames(geneMap)<-c("ID","X","Y","expr")

    ## APPEND THE ROWMEANS TO EACH ITEM
    rowMean<-ddply(geneMap, "X" ,function(df)mean(df$expr))
    geneMap<-merge(geneMap,rowMean,by="X")
    colnames(geneMap)<-c("X","ID","Y","expr","rMean")

    ## CREATE A BASIC TILE WITH FILLED ROWS (FILL BY MEAN, ALPHA BY VALUE)
    hmap<-ggplot(data=geneMap, aes(x=X,y=Y)) +        # Basic Plot
          theme_bw() +                                # Basic Theme
          geom_tile(aes(fill=rMean)) +                # Fill the tile by mean
          scale_x_continuous( breaks = 1:10,1) +      # Force ticks 1-10 on x axis
          scale_y_continuous( breaks = 1:10,1) +      # Force ticks 1-10 ony axis
          scale_fill_gradient(low="yellow", high="orange")   # Color the heatmap

    hmap <- hmap + annotate("text", x = geneMap$X, y = geneMap$Y, 
                            label = round(geneMap$expr,2))  # Label each point with value

    meanSummary<-unique(geneMap[,c("X","rMean")])     # Pull out the means for each row
    origSummary<-geneMap[geneMap$Y==1,]               # Pull out the original "seed" vals for each row

    hmap<- hmap + annotate("text", x = meanSummary$X, 
                           y = max(geneMap$Y)+1, 
                           label = round(meanSummary$rMean,2)) # Add the mean labels at row end
    hmap<- hmap + annotate("text", x = min(geneMap$Y)-1,
                           y = max(geneMap$Y)+1, label = "MEANS") # Label the row

    hmap<- hmap + geom_line(aes(x=origSummary$X, 
                                y=origSummary$expr*(max(origSummary$X)/max(origSummary$expr)),
                                size=3, alpha=0.6))   # Add the line plot

    # Draw the map & flip is so the rows run horizontally (or not!)
    hmap + coord_flip()
-------------------------------------------------------------------------------------------------------
MyFunction apply wrapper grid <- expand.grid(x=x, y=y)
grid$z <- apply(grid, 1, FUN=function(XY)MyFunction(XY[1], XY[2])) MyFunction outer z <- outer(x, y, MyFunction)
grid <- expand.grid(x=x, y=y)
grid$z <- as.vector(z)
-------------------------------------------------------------------------------------------------------
plot_one plot_one <- function(d){
  with(d, plot(Days, Count, t="n", tck=1, main=unique(d$ID), cex.main = 0.8, ylab = "", yaxt = 'n', xlab = "", xaxt="n",  xlim=c(0,1000), ylim=c(0,1200))) # set limits
  grid(lwd = 0.3, lty = 7)
  with(d[d$Treat == 0,], points(Days, Count, col = 1)) 
  with(d[d$Treat == 1,], points(Days, Count, col = 2))
  mod = lm(Count ~ Days, data = d[d$Treat == 0,])
  abline(reg = mod)
  text(x=500, y=800, mod$coefficients[2])
}
-------------------------------------------------------------------------------------------------------
mlpGrid mlpGrid <- expand.grid(.size=c(3,3)) size mlp train caret
-------------------------------------------------------------------------------------------------------
show_guide=FALSE geom_boxplot() override.aes= guide_legend() guides() paste() expression() ggplot()+
  geom_boxplot(data=r2df.realtime,aes(as.factor(yr),r2phvrcn,col='model1'),
                                           outlier.shape=3,show_guide=FALSE)+
  geom_boxplot(data=r2df,aes(x=as.factor(yr),y=r2phv,col='model2'),show_guide=FALSE)+
  geom_point(data=r2df,aes(x=as.factor(yr),y=r2recon,col='model3'),shape=6)+
  geom_point(data=r2df.sameyr,aes(x=as.factor(yr),y=r2phvrcn,col='model4'),shape=6)+
  scale_color_manual(values=c('blue','red','green','black'))+
  facet_grid(~mth)+
  guides(color=guide_legend('Model',override.aes=list(shape=c(1,1,6,6))))+
  labs(title=expression(paste("Real-time Ensemble of Cross-Validated Skill Scores 
                                                                (",r^2,")",sep='')))
-------------------------------------------------------------------------------------------------------
A*B A.*B syms a11 a12 a21 a22 b11 b12 b21 b22
syms a13 a31 a23 a32 a33
syms b13 b31 b23 b32 b33 A1 = [a11;a21] ;
B1 = [b11;b21] ; 1 - prod(1-A1.*B1)
=
1 - (a11*b11 - 1)*(a12*b12 - 1) A3 = [a11 a12 a13;a21 a22 a23; a31 a32 a33];
B2 = [b11 b12 ;b21 b22 ; b31 b32]; [indA indB] = meshgrid(1:3,1:2); a.*b = b.*a indA = triu(indA); indB = triu(indB);
indA = reshape(indA(indA>0),[],1); indB = reshape(indB(indB>0),[],1); result = 1 - prod(1-A3(:,indA).*B2(:,indB)) pretty(result.')

=

  +-                                               -+ 
  |  (a11 b11 - 1) (a21 b21 - 1) (a31 b31 - 1) + 1  | 
  |                                                 | 
  |  (a12 b11 - 1) (a22 b21 - 1) (a32 b31 - 1) + 1  | 
  |                                                 | 
  |  (a12 b12 - 1) (a22 b22 - 1) (a32 b32 - 1) + 1  | 
  |                                                 | 
  |  (a13 b11 - 1) (a23 b21 - 1) (a33 b31 - 1) + 1  | 
  |                                                 | 
  |  (a13 b12 - 1) (a23 b22 - 1) (a33 b32 - 1) + 1  | 
  +-                                               -+
-------------------------------------------------------------------------------------------------------
?igraph.plotting vertex.frame.color vertex.color layout.grid ?layout.grid vertex.label layout.grid g <- graph.lattice( c(5,5) )
lay <- layout.grid(g)
V(g)$x <- lay[,1]
V(g)$y <- lay[,2]
V(g)$color <- V(g)$frame.color <- "darkolivegreen"
V(g)$label.color <- "lightgrey"
V(g)$label <- paste(V(g)$x+1, V(g)$y+1, sep=",") torem <- c(E(g)[ V(g)[x==0] %--% V(g)[x==0] ], 
           E(g)[ V(g)[y==0] %--% V(g)[y==0] ], 
           E(g)[ V(g)[x==4] %--% V(g)[x==4] ], 
           E(g)[ V(g)[y==4] %--% V(g)[y==4] ])
g2 <- delete.edges(g, torem) g3 <- delete.vertices(g2, V(g2)[ x %in% c(0,4) & y %in% c(0,4) ])
plot(g3, layout=cbind(V(g3)$x, V(g3)$y))
-------------------------------------------------------------------------------------------------------
pctable<-data.frame(expand.grid(c("monday","tuesday","wednesday","thursday","friday","saturday","sunday"),1:22))
colnames(pctable)<-c("weekday","day")
pctable$value=rnorm(nrow(pctable),15,8)
plot(pctable$day,pctable$weekday,cex=pctable$value/(max(pctable$value)/5), col=rgb(0,0,1), pch=19, yaxt="n", xaxt="n")
axis(1, at=1:22, labels=c(1:22)) 
axis(2, at=1:7, labels=c("monday","tuesday","wednesday","thursday","friday","saturday","sunday"), cex.axis=0.7)
-------------------------------------------------------------------------------------------------------
maps mapproject expand.grid(long,lat) library("mapproj")
m <- map( "world", "Antarctica", plot=FALSE)
map("world", "Antarctica", proj="conic", param=-90, fill=TRUE, col="gray")
map.grid(m, nx=4, ny=6, col="black")

front.lim <- data.frame(x=seq(-180, 180, length.out=1000),
                        y=rep(-62, 1000))
front.lim <- mapproject(front.lim$x, front.lim$y, projection="conic", parameters=-90)
lines(front.lim$x, front.lim$y, col="red", lwd=2) map(add=TRUE) plot(c(-10, 45), c(30, 60), type="n", xlab="", ylab="") # image(ncdf)
map(add=TRUE, fill=TRUE, col="gray")
abline(v=seq(-10, 45, 7.5), lty=2)
abline(h=seq(-30, 60, 7.5), lty=2)
-------------------------------------------------------------------------------------------------------
symbols() sqrt((pctable$value / max(pctable$value)) / pi) pctable <- data.frame(expand.grid(weekday=c("Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"),
                              day=1:22), value=abs(rnorm(nrow(pctable), 20, 30)))

par(list(las=1, mar=c(6,6,1,1), mgp=c(4.5,1,0)))

bubble.size <- sqrt((pctable$value / max(pctable$value)) / pi)
symbols(pctable$day, pctable$weekday, circles=bubble.size,
    inches=.2, fg="black", bg="blue", yaxt="n", xaxt="n", xlab="Day", ylab="Weekday")
axis(1, at=1:22, labels=c(1:22)) 
axis(2, at=1:7,labels=rev(c("Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday")), cex.axis=0.7)
-------------------------------------------------------------------------------------------------------
aes() library(reshape2)
df1 <- dcast(df,skew+version+color~product,
             fun.aggregate = sum,
             value.var = "price")
ggplot(df1,aes(x = p1,y = p3,colour = factor(skew))) +
  facet_grid(version~color) +
  geom_point(size = 2,shape = 19)
-------------------------------------------------------------------------------------------------------
xx <- reshape(df, idvar=c("skew","version","color"),
              v.names="price", timevar="product", direction="wide") ggp <- ggplot(xx,aes(x=price.p1, y=price.p3, color=factor(skew))) +
       geom_point(shape=19, size=5)
ggp + facet_grid(color~version)
-------------------------------------------------------------------------------------------------------
+ facet_grid(.~Actor)
-------------------------------------------------------------------------------------------------------
a n <- dim(a)
b <- aperm(a, c(3,1,2))
dim(b) <- c(n[3] * n[1], n[2]) b <- cbind(rev(expand.grid(dim3 = 1:n[3], dim1 = 1:n[1])), b)
-------------------------------------------------------------------------------------------------------
require(ggplot2)

molten<-expand.grid(c("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"),1985:2013,0)
colnames(molten)<-c("Var2","Var1","value")
molten$value=(runif(nrow(molten))*60)-30

#create means
means<-aggregate(molten[,c(1,3)], by=list(molten$Var2),FUN=mean, na.rm=TRUE)
colnames(means)<-c("Var2","Var1","value")
means$Var1<-"MEANS"

#create spacer bar
spacer<-means
spacer$Var1<-" "
spacer$value<-NA

#append them to the data
molten<-rbind(molten,spacer,means)


hm <- ggplot(data = molten, aes(x = Var2, y=Var1, fill=value)) + 
geom_raster() +
# replaced your functions for ease of use
scale_fill_gradient2(low="red", mid="yellow", high="green",na.value="grey") +
labs(fill='% Return') +
# don't format the NA vals with %, return blank
geom_text(aes(label=ifelse((is.na(value)),"",paste(sprintf("%.1f %%", value)))), size = 4) +
# make the scale discrete to add labels and enforce order (use a blank space for the spacer)
scale_y_discrete(limits = c("MEANS"," ",1985:2013)) +
xlab(label = NULL) + ylab(label = NULL) +
theme_bw() +
theme(axis.text.x = element_text(size = 10, hjust = 0, vjust = 0.4, angle=90))

hm
-------------------------------------------------------------------------------------------------------
LtoM MtoH hm2 require(reshape2)
require(ggplot2)

# Random data
set.seed(100)
casted = data.frame(Var1 = rep(1985:2013, times=12), Var2 = rep(month.abb, each=29), return = rnorm(12*29, 0, 9))
molten = melt(casted, id.vars = c("Var1", "Var2"))

LtoM <-colorRampPalette(c('red', 'yellow' ))
Mid <- "snow3"
MtoH <-colorRampPalette(c('lightgreen', 'darkgreen'))

# Averages
monthly.avg = cbind(Var1 = rep("Mean", 12), dcast(molten, Var2 ~ ., mean))
colnames(monthly.avg)[3] = "Mean"
molten2 = merge(molten, melt(monthly.avg), all.x = TRUE, all.y = TRUE)

# New plot
hm2 = 
  ggplot(data = molten2, aes(x = factor(Var2, levels = month.abb), y=Var1, fill=value)) +
  geom_raster() +
  scale_fill_gradient2(low=LtoM(100), mid=Mid, high=MtoH(100)) +
  labs(fill='% Return') +
  geom_text(aes(label=paste(sprintf("%.1f %%", value))), size = 4) +
  xlab(label = NULL) + ylab(label = NULL) +
  theme_bw() +
  theme(axis.text.x = element_text(size = 10, hjust = 0, vjust = 0.4, angle=90)) +
  facet_grid(variable ~ ., scales = "free_y", space = "free_y") +    # grid layout
  theme(strip.background = element_rect(colour = 'NA', fill = 'NA'), strip.text.y = element_text(colour = 'white'))    # remove facet labels
-------------------------------------------------------------------------------------------------------
geom_point() ggplot(WetNmaPso) + geom_point(data=WetNmaPso,aes(y=NbWB_m2,x=mean_PercentCover,color=Category,shape=Site,size=7)) + stat_smooth(method="lm",aes(y=NbWB_m2,x=mean_PercentCover,color=Category)) + facet_grid(. ~ Category)
-------------------------------------------------------------------------------------------------------
annotation_logticks data data.frame add_logticks  <- function (base = 10, sides = "bl", scaled = TRUE, 
   short = unit(0.1, "cm"), mid = unit(0.2, "cm"),  long = unit(0.3, "cm"), 
   colour = "black",  size = 0.5, linetype = 1, alpha = 1, color = NULL, 
   data =data.frame(x = NA),... )   {
  if (!is.null(color)) 
    colour <- color
  layer(geom = "logticks", geom_params = list(base = base, 
          sides = sides, raw = raw, scaled = scaled, short = short, 
          mid = mid, long = long, colour = colour, size = size, 
          linetype = linetype, alpha = alpha, ...), 
        stat = "identity", data =data , mapping = NULL, inherit.aes = FALSE, 
        show_guide = FALSE)
}
# The plot without logticks
overall <- ggplot(df, aes(x=station, y=Mean)) + 
  geom_errorbar(aes(ymin=Mean-StErr, ymax=Mean+StErr), colour="black", width=.1) +
  geom_point(size=2)+
  xlab(NULL) +
  ylab(expression(paste('Copepods,'~'#/m'^3))) + 
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  ) + 
  scale_x_continuous(expand=c(.3,0), breaks=c(1:3), labels=c("In", "FL", "Off")) + 
  scale_y_log10(limit=c(100,10000)) +
  theme(axis.text.x=element_text(size=12)) +
  theme(axis.text.y=element_text(size=12)) +
  facet_grid(.~day)

overall + add_logticks(side = 'l', data = data.frame(x= NA, day = '5-Aug'))
-------------------------------------------------------------------------------------------------------
expand.grid > expand.grid(f1, e1)
   Var1 Var2
1     a    e
2     b    e
3     c    e
4     d    e
5     a    f
6     b    f
7     c    f
8     d    f
9     a    g
10    b    g
11    c    g
12    d    g
-------------------------------------------------------------------------------------------------------
ggplot(df, aes(ValueX, ValueY)) + geom_point() +
  facet_grid(Facet2 ~ Facet1) labeller facet_grid()
-------------------------------------------------------------------------------------------------------
x <- mtcars
x$group <- ""
x[x$wt<3,]$group  <- "1.LIGHT"
x[x$wt>=3,]$group <- "2.HEAVY"

library(ggplot2)
library(grid)    #for unit(...)
ggplot(x, aes(x=wt,y=mpg)) + 
  geom_point() + 
  facet_grid(~group,scales="free",space="free") + 
  theme(panel.margin = unit(2, "lines"))
-------------------------------------------------------------------------------------------------------
ggplot(data2, aes(x=x)) +
        geom_point(aes(y=y)) +
        geom_text(aes(label=y, y=mean(range(y)))) +
        facet_grid(z~.) scale_y_continuous(limits = c(10, 15))
-------------------------------------------------------------------------------------------------------
geom_text(...) ggplot data1 <- data.table(x=1:5, y=1:5, z=c(1,2,1,2,1))
data2 <- data.table(x=1:5, y=11:15, z=c(1,2,1,2,1))

myfun <- function(data){
    label.pos <- data[,ypos:=min(y)+0.75*diff(range(y)),by=z] # 75% to the top...

    ggplot(data, aes(x=x, y=y)) +
        geom_point() +
    #   geom_text(aes(label=y), y=3) +
        geom_text(data=label.pos, aes(y=ypos, label=y)) +
        facet_grid(z~., scales="free")     # note scales = "free"
}

myfun(data2)
-------------------------------------------------------------------------------------------------------
kde2d_mod <- function (data, h, n = 200, lims = c(range(data$lat), range(data$lon))) {
#Data is a matrix: lon,lat for each source. (lon,lat to match rdist.earth format.)
print(Sys.time()) #for timing

nx <- dim(data)[1]
if (dim(data)[2] != 2) 
stop("data vectors have only lat-long data")
if (any(!is.finite(data))) 
stop("missing or infinite values in the data are not allowed")
if (any(!is.finite(lims))) 
stop("only finite values are allowed in 'lims'")
#Grid:
g<-grid(n,lims) #Function to create grid.

#The distance matrix gets large... Can we work around it? YES WE CAN!
sets<-ceiling(dim(g)[1]/10000)
#Allocate our output:
z<-rep(as.double(0),dim(g)[1])

for (i in (1:sets)-1) {
   g_subset=g[(i*10000+1):(min((i+1)*10000,dim(g)[1])),]
   a_matrix<-rdist.earth(g_subset,data,miles=FALSE)

   z[(i*10000+1):(min((i+1)*10000,dim(g)[1]))]<- apply( #Here is my kernel...
    a_matrix,1,FUN=function(X)
    {sum(exp(-X^2/(2*(h^2))))/(2*pi*nx)}
   )
rm(a_matrix)
}

print(Sys.time())
#Un-transpose the final data.
z<-t(matrix(z,n,n))
dim(z)<-c(n^2,1)
z<-as.vector(z)
return(z)
} grid<- function(n,lims) {
num <- rep(n, length.out = 2L)
gx <- seq.int(lims[1L], lims[2L], length.out = num[1L])
gy <- seq.int(lims[3L], lims[4L], length.out = num[2L])

v1=rep(gy,length(gx))
v2=rep(gx,length(gy))
v1<-matrix(v1, nrow=length(gy), ncol=length(gx))
v2<-t(matrix(v2, nrow=length(gx), ncol=length(gy)))
grid_out<-c(unlist(v1),unlist(v2))

grid_out<-aperm(array(grid_out,dim=c(n,n,2)),c(3,2,1) ) #reshape
grid_out<-unlist(as.list(grid_out))
dim(grid_out)<-c(2,n^2)
grid_out<-t(grid_out)
return(grid_out)
} kde2d_mod_plot<-function(kde2d_mod_output,n,lims) ){
 num <- rep(n, length.out = 2L)
 gx <- seq.int(lims[1L], lims[2L], length.out = num[1L])
 gy <- seq.int(lims[3L], lims[4L], length.out = num[2L])

 v1=rep(gy,length(gx))
 v2=rep(gx,length(gy))
 v1<-matrix(v1, nrow=length(gy), ncol=length(gx))
 v2<-t(matrix(v2, nrow=length(gx), ncol=length(gy)))

 image.plot(v1,v2,matrix(kde2d_mod_output,n,n))
 map('world', fill = FALSE,add=TRUE)
}
-------------------------------------------------------------------------------------------------------
reshape2 library(reshape2)
df <- melt(df, id = c("day", "station"))
Cop.Plot <- ggplot(data = df, aes(x = station, y = value)) + geom_point()
Cop.Plot + facet_grid(variable ~ day) day day <- factor(day, levels = c('5-Aug', '10-Aug', '17-Aug'))
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(reshape2)
moltendf <- melt(df, id.vars=c("day","station"))
allplots <- ggplot(data=moltendf, aes(x=station, y=value)) +
             geom_point() + facet_grid(variable ~ day) *apply plotfun <- function(x,y) { 
                 a <- ggplot(data=x, aes(x=station, y=value)) +
                 geom_point() + facet_grid(.~ day)
                 pdf(paste0(y,".pdf"))
                 print(a)
                 dev.off()
}

mapply(plotfun, split(moltendf, moltendf$variable), as.list(1:3))
-------------------------------------------------------------------------------------------------------
library(reshape2)
ggdata <- melt(df,id=1:2,variable.name="Measure",value.name="Mean")
ggplot(ggdata,aes(x=station, y=Mean)) +
  geom_point() + 
  facet_grid(Measure~day)
-------------------------------------------------------------------------------------------------------
ggplot ggmap location <- get_map(location = c(lon = 0, lat = 80), zoom = 4, maptype = "hybrid")

#Create a small data frame to pass to ggplot
fourCorners <- expand.grid(
  lon = as.numeric(attr(location, "bb")[, c("ll.lon", "ur.lon")]), 
  lat = as.numeric(attr(location, "bb")[, c("ll.lat", "ur.lat")])
  )
# The inset_raster function needs 4 data coordinates. Pull it out of your "location" that you got via get_map
xmin <- attr(location, "bb")$ll.lon
xmax <- attr(location, "bb")$ur.lon
ymin <- attr(location, "bb")$ll.lat
ymax <- attr(location, "bb")$ur.lat

# Now you are ready to plot it
mp <- ggplot(fourCorners, aes(x = lon, y = lat) ) + 
 inset_raster(location, xmin, xmax, ymin, ymax)            
mp
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(gridExtra)
ggp <- ggplot(dat)
p1  <- ggp + geom_boxplot(aes(x=m1, y=mse))
p2  <- ggp + geom_boxplot(aes(x=m2, y=mse))
p3  <- ggp + geom_boxplot(aes(x=m3, y=mse))

grid.arrange(p1,p2,p3,nrow=1) library(reshape2)
xx=melt(dat, id.vars="mse", measure.vars=c("m1","m2","m3"),
   variable.name="facet", value.name="facet.variable")
ggplot(xx) + 
   geom_boxplot(aes(x=facet.variable,y=mse)) + 
   facet_grid(~facet,scales="free") + 
   labs(x="") rnorm(...)
-------------------------------------------------------------------------------------------------------
ylab plotfun <- function(x,y) {
    a <- ggplot(data=x, aes(x=station, y=Mean)) +
        geom_errorbar(aes(ymin=(Mean-StErr), ymax=(Mean+StErr)), 
                      colour="black", width=0.1)+
        geom_point(size=2) + 
        xlab(NULL) +
        ylab(  bquote(.(y)~"#"/m^3) )+   
        scale_y_log10()+
        theme_bw()  
 pdf(file=paste(y,'pdf',sep="."))
 print(a)
 dev.off()  
     }

mapply(plotfun, x=split(df, df$Bug), y=levels(df$Bug)) plotfun <- function(x,y) {
    a <- ggplot(data=x, aes(x=station, y=Mean)) +
        geom_errorbar(aes(ymin=(Mean-StErr), ymax=(Mean+StErr)), colour="black", width=0.1)+
        geom_point(size=2) + 
        xlab(NULL) +
        ylab(bquote(.(y)*","*~"#"/m^3) )+  
        scale_y_log10() + annotation_logticks(sides = "l") + 
        theme_bw() +
        theme(  panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()  )  +  facet_grid(.~day)
 pdf(file=paste(y,'pdf',sep="."))
 print(a)
 dev.off()  
     }

mapply(plotfun, x=split(df, df$Bug), y=levels(df$Bug)) allplots <- ggplot(data=df, aes(x=station, y=Mean)) + 
    geom_errorbar(aes(ymin=(Mean-StErr), ymax=(Mean+StErr)), colour="black", width=0.1)+
    geom_point(size=2) + 
    facet_grid(Bug ~ day) +
    xlab(NULL) +
    ylab(expression(Copepods *","* ~'#'/m^3)) +scale_x_continuous(expand=c(.3,0), breaks=c(1:3), labels=c("In", "FL", "Off")) +annotation_logticks(sides = "l") + scale_y_log10() +
    theme_bw() +
    theme(   panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()     ) + 
    theme(axis.text.x=element_text(size=12)) +
    theme(axis.text.y=element_text(size=12))
print(allplots)
-------------------------------------------------------------------------------------------------------
adj.poss <- function(x) {
  n <- length(x)
  stopifnot(n > 2L)
  idx <- expand.grid(start = 1L:n, len = 2L:(n-1L))
  idx$end <- idx$start + idx$len - 1L
  idx <- idx[idx$end <= n, ]
  Map(function(start, end) x[start:end], idx$start, idx$end)
} adj.poss(data)
-------------------------------------------------------------------------------------------------------
require(akima) # akima package for easy surface interpolation
a <- seq(-1,1,0.01)
b <- seq(-1,1,0.01)
lambda1 <- function(a,b){eigen(matrix(c(a,b,a-b,a+b,b,a,a,a,b),3,3,byrow=T))$values[[1]]} 
# make it a data frame for all permutations to fix the issue that
# your current code runs for a, b vectors so you get the same result 200x
mytab<-data.frame(expand.grid(a=a,b=b))
# use adply and transform to generate the 1st eigenvalues for each
# takes a while for 200 x 200! you could reduce a & b
mytab<-mytab<-adply(mytab, 1, transform, c = lambda1(a, b))
# use interp from akima to create 40x40 matrix - you can change this
surface<-interp(mytab$a,mytab$b,mytab$c)
# plot the surface
persp(surface$x,surface$y,surface$z,col=ifelse(surface$z>=0,"red","white"))

# you can also create a spinning plot like this:

require(rgl)
plot3d(1,1,3,       # just an easy way to set the plot area
   xlab="a",
   ylab="b",
   zlab="lambda1")

surface3d(surface$x,surface$y,surface$z,
      col=ifelse(surface$z>=0,"red","white"), size=1) a <- seq(-1,1,0.05)
b <- seq(-1,1,0.05)
lambda1 <- function(a,b){eigen(matrix(c(a,b,a-b,a+b,b,a,a,a,b),3,3,byrow=T))$values[[1]]} 
mytab<-data.frame(expand.grid(a=a,b=b))

mytab$c<-apply(mytab, 1, function(x)lambda1(x["a"],x["b"]))

surface<-NULL
surface$x<-unique(mytab$a)
surface$y<-unique(mytab$b)
surface$z<-matrix(mytab$c,nrow=length(surface$x),byrow=TRUE) 

persp(surface$x,surface$y,surface$z,col=ifelse(surface$z>=0,"red","white"))
-------------------------------------------------------------------------------------------------------
expand.grid if else ifelse pD1S80 <- round(rnorm(27),2)
id <- seq_along(pD1S80)
dat <- expand.grid(i=id,j=id,k=id)

valueAF <- with(dat,
     ifelse(i==j & j==k, pD1S80[i]^3,
            ifelse (i==j & k!=i,(pD1S80[i]^2)*pD1S80[k],
                                pD1S80[i]*pD1S80[j]*pD1S80[k] ))) microbenchmark(ag(),op(),times=1)
Unit: milliseconds
 expr        min         lq     median         uq        max neval
 ag()   31.52897   31.52897   31.52897   31.52897   31.52897     1
 op() 2181.76081 2181.76081 2181.76081 2181.76081 2181.76081     1 pD1S80 <- round(rnorm(27),2)
ag <- function(){
  id <- seq_along(pD1S80)
  dat <- expand.grid(i=id,j=id,k=id)
  valueAF <- with(dat,
     ifelse(i==j & j==k, pD1S80[i]^3,
            ifelse (i==j & k!=i,(pD1S80[i]^2)*pD1S80[k],
                                0 )))
  valueAF
}

op <- function(){
  probHAF <- numeric (0)
n <- length(pD1S80)
for (i in 1:n){
  for (j in 1:n){
    for (k in 1:n){
      valueAF = 0
      if ((i==j)&(j==k)) {
        valueAF = pD1S80[i]^3
      } else if ((i==j)&(k!=i)) {
        valueAF = (pD1S80[i]^2)*pD1S80[k]
      } 
      probHAF <-c(probHAF, valueAF)
    }}}
unlist(probHAF)
}
-------------------------------------------------------------------------------------------------------
Facet facet_grid facet_wrap ggplot(mtcars, aes(mpg, wt)) + geom_point() + facet_grid(. ~ cyl) gridExtra::arrangeGrob ncol = 1
-------------------------------------------------------------------------------------------------------
#function to `outer`
fun <- function(x, y) 
{ 
 a1 <- get(paste0("a", x))
 a2 <- get(paste0("a", y))
 res <- apply(expand.grid(a1, a2), 1, paste, collapse = "")
 res2 <- paste(res, collapse = ";")

 return(res2)
}

#`outer` a vectorized `fun`
m2 <- outer(primes, primes, Vectorize(fun))
#select `upper.tri`
unq2 <- m2[upper.tri(m2)]

#combine to a list
myls <- lapply(as.list(unq2), function(x) as.numeric(unlist(strsplit(x, ";"))))
names(myls) <- unq

myls
#$`6`
#[1] 11 11 12 12

#$`10`
#[1] 12 12 12 12

#$`15`
#[1] 12 22 12 22

#$`14`
#[1] 11 11 13 13
#...
-------------------------------------------------------------------------------------------------------
f=data.frame(name=c("A","B","C"),
         year.start=c(1993,1994,1993),year.end=c(1994,1995,1993), stringsAsFactors=F)
x <- expand.grid(unique(f$name),min(f1$year):max(f1$year)) 
names(x) <- c("name", "year")
x$indicator <- sapply(1:nrow(x), function(i) sum(x$name[i]==f$name & x$year[i] >=    f$year.start & x$year[i] <= f$year.end))
x[order(x$name),]
-------------------------------------------------------------------------------------------------------
### Create data frame with mean and std dev
x <- data.frame(mean=tapply(mtcars$mpg, list(mtcars$cyl), mean), sd=tapply(mtcars$mpg, list(mtcars$cyl), sd) )

###  Add lower and upper levels of confidence intervals
x$LL <- x$mean-2*x$sd
x$UL <- x$mean+2*x$sd

### plot dotchart with confidence intervals

title <- "MPG by Num. of Cylinders with 95% Confidence Intervals"

dotchart(x$mean, col="blue", xlim=c(floor(min(x$LL)/10)*10, ceiling(max(x$UL)/10)*10), main=title )

for (i in 1:nrow(x)){
    lines(x=c(x$LL[i],x$UL[i]), y=c(i,i))
}
grid()
-------------------------------------------------------------------------------------------------------
## Not tested...
library(XLConnect)
myData <- "lace for R.xlsx"             # NOTE: need path also...
wb     <- loadWorkbook(myData)
lace   <- readWorksheet(wb, sheet="lace")
lace$Admission.Day <- as.Date(lace$Admission.Day) format(...) library(lubridate)   # for year(...) and wday(...)
library(ggplot2)
# random dates around Jun 1, across 5 years...
set.seed(123)
lace <- data.frame(date=as.Date(rnorm(1000,sd=50)+365*(0:4),origin="2008/6/1"))
lace$year <- factor(year(lace$date))
lace$dow  <- wday(lace$date, label=T)
# This creates the histograms...
ggplot(lace) +
  geom_histogram(aes(x=dow, fill=year)) +      # fill color by year
  facet_grid(~year) +                          # facet by year
  theme(axis.text.x=element_text(angle=90))    # to rotate weekday names...
-------------------------------------------------------------------------------------------------------
expand.grid monCode yearRange do.call(sprintf,...) f <- expand.grid(monCode,yearRange)
outList <- do.call(sprintf, c(f, fmt = 'IB%s%s comdty'))
-------------------------------------------------------------------------------------------------------
R x=seq(-107,-106,.1)
y=seq(33,34,.1)
coords=expand.grid(x,y)
data1=data.frame(coords,depth=runif(nrow(coords),0,2))
names(data1)=c('x','y','value')

# get max and min values 
xmn=min(data1[,1]); xmx=max(data1[,1])
ymn=min(data1[,2]); ymx=max(data1[,2]) # compute interpolated raster. Note that this is not the 'spatial-temporal K function' requested in the question, as pointed out in a comment below, but a linear interpolation
library(akima)
akima.li <- interp(data1[,1], data1[,2], data1[,3], duplicate = "median",
                   xo=seq(xmn,xmx, length=100),
                   yo=seq(ymn,ymx, length=100)) # plot interpolated raster 
image(akima.li, col = rainbow(100, alpha = 1)) # plot interpolated contour 
contour(akima.li, nlevels = 3) # put the raster and contours together
image(akima.li, col = rainbow(100, alpha = 1))
contour(akima.li, nlevels = 3, add = TRUE) image(akima.li, col = gray.colors(10, start = 0, end = 0.9, gamma = 2.2, alpha = 1))
contour(akima.li, nlevels = 3, add = TRUE) image(akima.li, col = gray.colors(10, start = 0, end = 1, gamma = 1, alpha = 1))
contour(akima.li, nlevels = 3, add = TRUE, lty = 0)
-------------------------------------------------------------------------------------------------------
ggplot2 grid blankRows ## MOCK up confidence interval data in the form:
## ID (level from groupData), low (2.5%) high (97.5%), target
CI_Data<-ddply(hazardData[!is.na(hazardData$HR),],.(ID),summarize,low=min(HR),high=max(HR),target=mean(HR)) geom_boxplot(fill=boxColor,size=0.5, alpha=0.8, notch=F) geom_point(data=CI_Data,aes(x = factor(ID), y = target),shape=22,size=5,fill=boxColor,vjust=0) + 
  geom_errorbar(data=CI_Data,aes(x=factor(ID),y=target,ymin =low, ymax=high),width=0.5)+ ## REQUIRED PACKAGES
require(grid)
require(ggplot2)
require(plyr)

############################################
### CUSTOMIZE APPEARANCE WITH THESE     ####
############################################
blankRows<-2    # blank rows under boxplot
titleSize<-4
dataSize<-4
boxColor<-"pink"
############################################
############################################

## BASIC THEMES (SO TO PLOT BLANK GRID)
theme_grid <- theme(
  axis.line = element_blank(), 
  axis.text.x = element_blank(), 
  axis.text.y = element_blank(),
  axis.ticks = element_blank(), 
  axis.title.x = element_blank(), 
  axis.title.y = element_blank(), 
  axis.ticks.length = unit(0.0001, "mm"),
  axis.ticks.margin = unit(c(0,0,0,0), "lines"), 
  legend.position = "none", 
  panel.background = element_rect(fill = "transparent"), 
  panel.border = element_blank(), 
  panel.grid.major = element_line(colour="grey"), 
  panel.grid.minor = element_line(colour="grey"), 
  panel.margin = unit(c(-0.1,-0.1,-0.1,-0.1), "mm"), 
  plot.margin = unit(c(5,0,5,0.01), "mm")
)

theme_bare <- theme_grid +
  theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank()
  )

## LOAD GROUP DATA AND P values from csv file
groupData<-read.csv(file="groupdata.csv",header=T)

## SYNTHESIZE SOME PLOT DATA - you can load csv instead
## EXPECTS 2 columns - integer for 'ID' matching groupdatacsv
## AND 'HR' Hazard Rate
hazardData<-expand.grid(ID=1:nrow(groupData),HR=1:6)
hazardData$HR<-1.3-runif(nrow(hazardData))*0.7
hazardData<-rbind(hazardData,ddply(groupData,.(Group),summarize,ID=max(ID)+0.1,HR=NA)[,2:3])
hazardData<-rbind(hazardData,data.frame(ID=c(0,-1:(-2-blankRows),max(groupData$ID)+1,max(groupData$ID)+2),HR=NA))

## Make the min/max mean labels
hrlabels<-ddply(hazardData[!is.na(hazardData$HR),],.(ID),summarize,lab=paste(round(mean(HR),2)," (",round(min(HR),2),"-",round(max(HR),2),")",sep=""))

## Points to plot on the log scale
scaledata<-data.frame(ID=0,HR=c(0.2,0.6,0.8,1.2,1.8))

## Pull out the Groups & P values
group_p<-ddply(groupData,.(Group),summarize,P=mean(P_G),y=max(ID)+0.1)

## identify the rows to be highlighted, and 
## build a function to add the layers
hl_rows<-data.frame(ID=(1:floor(length(unique(hazardData$ID[which(hazardData$ID>0)]))/2))*2,col="lightgrey")
hl_rows$ID<-hl_rows$ID+blankRows+1
hl_rect<-function(col="white",alpha=0.5){
  rectGrob(   x = 0, y = 0, width = 1, height = 1, just = c("left","bottom"), gp=gpar(alpha=alpha, fill=col))
}

## DATA FOR TEXT LABELS
RtLabels<-data.frame(x=c(rep(length(unique(hazardData$ID))-0.2,times=3)),
                      y=c(0.6,6,10),
                      lab=c("Hazard Ratio\n(95% CI)","P Value","P Value for\nInteraction"))

LfLabels<-data.frame(x=c(rep(length(unique(hazardData$ID))-0.2,times=2)),
                     y=c(0.5,4),
                     lab=c("Subgroup","No. of\nPatients"))

LegendLabels<-data.frame(x=c(rep(1,times=2)),
                     y=c(0.5,1.8),
                     lab=c("Off-Pump CABG Better","On-Pump CABG Better"))

## BASIC PLOT
haz<-ggplot(hazardData,aes(factor(ID),HR))+ labs(x=NULL, y=NULL)

## RIGHT PANEL WITH LOG SCALE
rightPanel<-haz + 
  apply(hl_rows,1,function(x)annotation_custom(hl_rect(x["col"],alpha=0.4),as.numeric(x["ID"])-0.5,as.numeric(x["ID"])+0.5,-20,20)) +
  geom_segment(aes(x = 2, y = 1, xend = 1.5, yend = 1)) + 
  geom_hline(aes(yintercept=1),linetype=2, size=0.5)+
  geom_boxplot(fill=boxColor,size=0.5, alpha=0.8)+ 
  scale_y_log10() + coord_flip() +
  geom_text(data=scaledata,aes(3,HR,label=HR), vjust=0.5, size=dataSize) +
  geom_text(data=RtLabels,aes(x,y,label=lab, fontface="bold"), vjust=0.5, size=titleSize) +
  geom_text(data=hrlabels,aes(factor(ID),4,label=lab),vjust=0.5, hjust=1, size=dataSize) +
  geom_text(data=group_p,aes(factor(y),11,label=P, fontface="bold"),vjust=0.5, hjust=1, size=dataSize) +
  geom_text(data=groupData,aes(factor(ID),6.5,label=P_S),vjust=0.5, hjust=1, size=dataSize) +
  geom_text(data=LegendLabels,aes(x,y,label=lab, fontface="bold"),hjust=0.5, vjust=1, size=titleSize) +
  geom_point(data=scaledata,aes(2.5,HR),shape=3,size=3) + 
  geom_point(aes(2,12),shape=3,alpha=0,vjust=0) + 
  geom_segment(aes(x = 2.5, y = 0, xend = 2.5, yend = 13)) + 
  geom_segment(aes(x = 2, y = 1, xend = 2, yend = 1.8),arrow=arrow(),linetype=1,size=1) + 
  geom_segment(aes(x = 2, y = 1, xend = 2, yend = 0.2),arrow=arrow(),linetype=1,size=1) + 
  theme_bare

## LEFT PANEL WITH NORMAL SCALE
leftPanel<-haz + 
  apply(hl_rows,1,function(x)annotation_custom(hl_rect(x["col"],alpha=0.4),as.numeric(x["ID"])-0.5,as.numeric(x["ID"])+0.5,-20,20)) +
  coord_flip(ylim=c(0,5.5)) +
  geom_point(aes(x=factor(ID),y=1),shape=3,alpha=0,vjust=0) + 
  geom_text(data=group_p,aes(factor(y),0.5,label=Group, fontface="bold"),vjust=0.5, hjust=0, size=dataSize) +
  geom_text(data=groupData,aes(factor(ID),1,label=Subgroup),vjust=0.5, hjust=0, size=dataSize) +
  geom_text(data=groupData,aes(factor(ID),5,label=NoP),vjust=0.5, hjust=1, size=dataSize) +
  geom_text(data=LfLabels,aes(x,y,label=lab, fontface="bold"), vjust=0.5, hjust=0, size=4, size=titleSize) +
  geom_segment(aes(x = 2.5, y = 0, xend = 2.5, yend = 5.5)) + 
  theme_bare

## PLOT THEM BOTH IN A GRID SO THEY MATCH UP
grid.arrange(leftPanel,rightPanel, widths=c(1,3), ncol=2, nrow=1)
-------------------------------------------------------------------------------------------------------
ggplot2 geom_raster() require(ggplot2)
require(plyr)

## CREATE REASONABLE SIZE GRID 30x30
dfe<-expand.grid(ENT_LATITU=seq(415000,418000,100),
            ENT_LONGIT=seq(630000,633000,100),
            CSK=0)
## FILL WITH RANDOM DATA
dfe$CSK=round(rnorm(nrow(dfe),200,50),0)

#######################################################
#####  VALUES TO CHANGE IN THIS BLOCK             #####
#######################################################
## TRIM ORIGINAL DATASET
lat.max<-Inf       # change items to trim data
lat.min<-0       
long.max<-Inf    
long.min<-631000      
dfe.trim<-dfe[findInterval(dfe$ENT_LATITU,c(lat.min,lat.max))*findInterval(dfe$ENT_LONGIT,c(long.min,long.max))==1,]
## SUMMARIZE TO NEW X/Y GRID
xblocks<-6
yblocks<-8

## GRAPH COLOR AND TEXT CONTROLS
showText<-TRUE
txtSize<-3
heatmap.low<-"lightgreen"
heatmap.high<-"orangered"
#######################################################
#####                                             #####
#######################################################

## BASIC PLOT (ALL DATA POINTS)
ggplot(dfe) +
  geom_raster(aes(ENT_LATITU,ENT_LONGIT,fill=CSK)) + theme_bw() +
  scale_fill_gradient(low=heatmap.low, high=heatmap.high) +
  geom_text(aes(ENT_LATITU,ENT_LONGIT,label=CSK,fontface="bold"),
            color="black",
            size=2.5) ## CALL ddply to roll-up the data and calculate summary means, SDs,ec
dfe.plot<-ddply(dfe.trim,
      .(lat=cut(dfe.trim$ENT_LATITU,xblocks),
        long=cut(dfe.trim$ENT_LONGIT,yblocks)),
      summarize,
      mean=mean(CSK),
      sd=sd(CSK),
      sum=sum(CSK),
      range=paste(min(CSK),max(CSK),sep="-"))

## BUILD THE SUMMARY CHART
g<-ggplot(dfe.plot) +
  geom_raster(aes(lat,long,fill=sum),alpha=0.75) +
  scale_fill_gradient(low=heatmap.low, high=heatmap.high) +
  theme_bw() + theme(axis.text.x=element_text(angle=-90)) +
  ggtitle(paste(xblocks,
                " X ",
                yblocks,
                " grid of Catch Data\nbetween ( ",
                min(dfe.trim$ENT_LATITU),
                " : ",
                min(dfe.trim$ENT_LONGIT),
                " ) and ( ",
                max(dfe.trim$ENT_LATITU),
                " : ",
                max(dfe.trim$ENT_LONGIT),
                " )\n\n",
                sep=""))

## ADD THE LABELS IF NEEDED
if(showText)g<-g+geom_text(aes(lat,long,label=paste("SUM=",round(sum,0),
                                            "\nMEAN=",round(mean,1),
                                            "\nSD=",round(sd,1),
                                            "\nRNG=",range,sep=""),
                                  fontface=c("italic")),
                                  color="black",size=txtSize)

## FUDGE THE LABELS TO MAKE MORE READABLE
## REPLACE "," with newline and "]" with ")"
g$data[,1:2]<-gsub("[,]",replacement=" to\n",x=as.matrix(g$data[,1:2]))
g$data[,1:2]<-gsub("]",replacement=")",x=as.matrix(g$data[,1:2]))

## PLOT THE CHART
g + labs(x="\nLatitude", y="Longitude\n", fill="Sum\nBlock\n")

## SHOW HEADER OF data.plot
head(dfe.plot)
-------------------------------------------------------------------------------------------------------
lapply library(quantmod)
 library(mgcv)
 library(dlnm) 
 df <- chicagoNMMAPS
 outcome<- c("death", "cvd", "resp ")
 pollut1<-c("pm10" , "o3" ) 

library("doParallel")
library("foreach")
registerDoParallel(cores=8)

combinations<-expand.grid(outcome,pollut1)
mod1<- foreach(o=combinations, .combine='list') %dopar% {
    f <- as.formula(paste0("~ s(time,bs='cr',k=14*50)+ s(temp,k=6, bs='cr') + as.factor(dow) + ",o["Var1"], o["Var2"]) )
    gam(f,family=quasipoisson,na.action=na.omit,data=df) 
}
-------------------------------------------------------------------------------------------------------
ggplot(data)+ 
    geom_histogram(aes(x=pr,fill=factor(loc))) +
    facet_grid(method~exc)
-------------------------------------------------------------------------------------------------------
df <- subset(df, year <= 2013 & year >= 1997)
df$totalnationals <- as.integer(df$totalnationals)
df$internationalskilled <- as.integer(df$internationalskilled)
df2 <- aggregate(data = df,cbind(totalnationals,internationalskilled)~year+country, sum) df3 <- expand.grid(unique(df$year),unique(df$country))
df3 <- merge(df3,df2, all.x = TRUE, by = 1:2)
df3[is.na(df3)] <- 0
-------------------------------------------------------------------------------------------------------
df melt(...) gg <- reshape(df,idvar="COMPANY",
              varying=list(c(2,4),c(3,5)), v.names=c("Individual","Average"),
              timevar="Metric", times=c("Performance","Learning"),
              direction="long")

ggplot(gg)+
  geom_point(aes(x=COMPANY,y=Individual))+
  geom_hline(aes(yintercept=Average))+
  geom_linerange(aes(x=COMPANY,ymin=Average,ymax=Individual,
                     color=factor(sign(Individual-Average))))+
  facet_grid(~Metric) +
  labs(x="",y="Scores") +
  theme(legend.position="none",
        axis.text.x=element_text(angle=90, vjust=0.4, hjust=1, size=15, face="bold"))
-------------------------------------------------------------------------------------------------------
#  Unique names for longish vector
nms <- apply( expand.grid( letters , letters , letters , letters ) , 1 , paste , collapse = "" )
length(nms)
#[1] 456976
length(unique(nms))
#[1] 456976

#  Start of names
head(nms)
#[1] "aaaa" "baaa" "caaa" "daaa" "eaaa" "faaa"

#  End of names
tail(nms)
#[1] "uzzz" "vzzz" "wzzz" "xzzz" "yzzz" "zzzz"

#  Large named vector
x <- setNames( runif( 456976 ) , nms )

#  Small named vector
y <- setNames( runif(26) , letters )

#  Timing information
require( microbenchmark )
bm <- microbenchmark( x['daaa'] , x[4] , x['vzzz'] , x[456972] , y['d'] , y[4] )
print( bm , order = 'median' , unit = 'relative' , digits = 3 )
#Unit: relative
#      expr min       lq   median       uq      max neval
# x[456972] NaN 1.00e+00     1.00     1.00    1.000   100
#      x[4] Inf 1.00e+00     1.33     1.07    0.957   100
#      y[4] NaN 5.01e-01     1.33     1.14    0.191   100
#    y["d"] Inf 1.00e+00     2.00     1.25    0.265   100
# x["vzzz"] Inf 6.57e+04 44412.24  9969.64 3439.154   100
# x["daaa"] Inf 6.59e+04 44582.73 10049.63 1207.337   100
-------------------------------------------------------------------------------------------------------
akima require(akima)
require(reshape2)

temp.df<-expand.grid(x=2:4,y=2:4,z=0)
temp.df$z<-rnorm(9,10,3)

surface<-melt(interp(temp.df$x,temp.df$y,temp.df$z)) # melt() stretches out the surface to x,y,z as you've put into the original example
flat<-surface[!is.na(surface$X1)&!is.na(surface$X2),] # drop the NAs

#CONVERT SCALES BACK (INTERP GIVES YOU A 40x40 grid over the existing range)

points<-data.frame(x=min(temp.df$x)+(flat$X1-1)/(40/diff(range(temp.df$x))),
                   y=min(temp.df$y)+(flat$X2-1)/(40/diff(range(temp.df$x))),
                   z=flat$value)

wireframe((points$z ~ points$x + points$y),
          scales=list(arrows=F), 
          screen = list(z = 40,x= -60) 
)
-------------------------------------------------------------------------------------------------------
diamonds geom_bar() data= diamonds[(diamonds$clarity=="SI2"),] d <- ggplot(diamonds) +  geom_bar(aes(clarity, fill=color))    # first plot
d + geom_bar(data=diamonds[(diamonds$clarity=="SI2"),],        # filter
aes(clarity), alpha=0, size=1, color="black") +                # plot outline only
  facet_wrap(~ cut) data=yourdata[(yourdata$visualcondition=="LeftCust" & yourdata$report=="Left" |
                 yourdata$visualcondition=="SIMCust" & yourdata$report=="SIM" |
                yourdata$visualcondition=="RightCust" & yourdata$report=="Right"),] ######### ADD THIS LINE TO CREATE THE HIGHLIGHT SUBSET
HighlightData<-AggBar2[AggBar2$Report==gsub("Cust","",AggBar2$Visual),]
#####################################################

prob.bar = ggplot(AggBar2, aes(x = Report, y = Prob, fill = Report)) + theme_bw() + facet_grid(Audio~Visual)
prob.bar + geom_bar(position=position_dodge(.9), stat="identity", colour="black") + theme(legend.position = "none") + labs(x="Report", y="Probability of Report") + scale_fill_grey() +

######### ADD THIS LINE TO CREATE THE HIGHLIGHT SUBSET
  geom_bar(data=HighlightData, position=position_dodge(.9), stat="identity", colour="pink",size=1) +
######################################################

  labs(title = expression("Visual Condition")) +
  theme(plot.title = element_text(size = rel(1)))+
  geom_errorbar(aes(ymin=Prob-ci, ymax=Prob+ci),
                width=.2, # Width of the error bars
                position=position_dodge(.9))+
  theme(plot.title = element_text(size = rel(1.5)))+
  scale_y_continuous(limits = c(0, 100), breaks = (seq(0,100,by = 10)))
-------------------------------------------------------------------------------------------------------
scales facet_grid(facets, margins = FALSE, scales = "fixed",
    space = "fixed", shrink = TRUE,
    labeller = "label_value", as.table = TRUE, drop = TRUE)
-------------------------------------------------------------------------------------------------------
library(plyr)
df.text<-ddply(df,.(type,subtype),summarise,mean.value=mean(value))

df.text
  type subtype   mean.value
1    1       a -0.003138127
2    1       b  0.023252169
3    2       a  0.030831337
4    2       b -0.059001888 geom_text() vjust= ggplot(df, aes(x=value, fill=subtype)) + 
  geom_histogram(position="identity", alpha=0.4)+
  facet_grid(. ~ type)+
  geom_text(data=df.text,aes(label=paste("mean=",mean.value),
                 colour=subtype,x=-Inf,y=Inf), size = 4, hjust=-0.1, vjust=c(2,4))
-------------------------------------------------------------------------------------------------------
tnet igraph igraph igraph tnet igraph > # Load packages
> library(tnet)
>   
> # Create random network (you could also use the rg_w-function)
> m <- expand.grid(from = 1:4, to = 1:4)
> m <- m[m$from != m$to, ]
> m$weight <- sample(1:7, 12, replace = T)
>   
> # Make tnet object and calculate closeness
> closeness_w(m)

     node closeness n.closeness
[1,]    1 0.2193116  0.07310387
[2,]    2 0.3809524  0.12698413
[3,]    3 0.2825746  0.09419152
[4,]    4 0.3339518  0.11131725

>   
> # igraph
> # Invert weights (transform into costs from strengths)
> # Multiply weights by mean (just scaling, not really)
> m$weight <- mean(m$weight)/m$weight
> # Transform into igraph object
> igraph_g <- graph.data.frame(m)
> # Compute closeness
> closeness(igraph_g, mode = "out")

        2         3         4         1 
0.3809524 0.2825746 0.3339518 0.2193116
-------------------------------------------------------------------------------------------------------
p <- ggplot(growth, aes(x = class, y = value, group = treatment, color = treatment))
p + geom_point(size = 4) + facet_grid(. ~ variable) + geom_errorbar(aes(ymin=value-se,ymax=value+se),width=.1,colour="black") + geom_line() growth$treatment_variable <- paste(growth$treatment, growth$variable)
p <- ggplot(growth, aes(x = class, y = value, group = treatment_variable, colour = treatment_variable))
pd<-position_dodge(.2)
p + geom_point(size = 4, position=pd) + geom_errorbar(aes(ymin=value-se, ymax=value+se), width=.1, position=pd, colour="black") + geom_line(position=pd)
-------------------------------------------------------------------------------------------------------
variable treatment p <- ggplot(growth,aes(class,value,colour=treatment,group=treatment))
pd<-position_dodge(.9)
p + 
  geom_errorbar(aes(ymin=value-se,ymax=value+se),width=.1,position=pd,colour="black") +
  geom_point(position=pd,size=4) + geom_line(position=pd) + 
  theme_bw() + theme(legend.position=c(1,1),legend.justification=c(1,1)) +
  facet_grid(variable~treatment)
-------------------------------------------------------------------------------------------------------
reshape2::melt DF <- read.table(text="    Names     hr1    hr2    hr3    hr4      workhr_bin
      41     80     76     70     60               7
      42     80     74     75     NA               8
      43     85     NA     60     65               6
      44     NA     NA     NA     60               3
      45     80     70     NA     NA               8
      46     NA     NA     NA     60               3", header=TRUE)

library(reshape2)
DF_melt <- melt(DF, id.vars=c("Names", "workhr_bin"))
#make time numeric
DF_melt$variable <- as.numeric(gsub("hr", "", DF_melt$variable))

library(ggplot2)
p <- ggplot(DF_melt, aes(x=variable, y=value, color=factor(Names))) +
  geom_line() +
  geom_point() +
  facet_grid(workhr_bin ~ .)

print(p)
-------------------------------------------------------------------------------------------------------
FacetingFunction <- function(df) {df$dat > 3}
ArbitraryFacetingPlot <- function(df, FacetingFunction) {
  df$facet <- FacetingFunction(df)
  p <- ggplot(df, aes(x=1:5, y=dat, colour=factor(dat > 3))) + 
    geom_point() + 
    facet_grid(facet ~ .)
  df$facet <- NULL
  p
}

ArbitraryFacetingPlot(df, FacetingFunction)
ArbitraryFacetingPlot(df, function(df) {df$dat==5})
-------------------------------------------------------------------------------------------------------
# for reproducibility (data generation only) 
set.seed(123)
# sample size
Nsims <- 1e3
# generate data
df <- data.frame(x1=rnorm(Nsims, 0, 2), 
                 x2=runif(Nsims, -2, 2), 
                 x3=rnorm(Nsims))
# generate response
df[, "y"] <- rbinom(Nsims, 1, with(df, exp(x1+3*x2+2*x3+x2*x3+0.5*x3^2)/(1+exp(x1+3*x2+2*x3+x2*x3+0.5*x3^2))))

# glm (your version)
glm(y ~ x1*x1 + x1*x2 + x1*x3 + x2*x2 + x2*x3 + x3*x3, 
    data =df, family=binomial) 
# equivalent but simpliried version
glm(y ~  x1*x2 + x1*x3 + x2*x3, 
    data = df, family=binomial) 
# another equivalent version 
# I think this is what you mean by your input vector
vars <- names(df)[names(df) != "y"] 
# write down the formula
form <- paste("y ~", do.call(paste, c(as.list(do.call(paste, c(expand.grid(vars, vars), sep="*"))), sep=" + ")))
# use this formula
glm(form, data = df, family=binomial) 

# different version that includes x1^2, x2^2 and x3^2 
# you had these terms in the original version, but they weren't used 
# because you didn't put them in the I(...) notation
glm(y ~ x1*x2 + x1*x3 + x2*x3 + I(x1*x1) + I(x2*x2)  + I(x3*x3), 
    data = df, family=binomial) 
# and here's the same thing using the poly function (as @Ben Bolker suggested)
# this used the option raw=TRUE for the output to be comparable with the above, 
# however usually you should use ortogonal polynomials instead. 
glm(y ~ poly(x1, x2, x3, degree=2, raw=TRUE), data=df, family=binomial)

# yet another version without the non-squared terms (as @ Aaron suggested)
glm(y ~ x1:x2 + x1:x3 + x2:x3 + I(x1*x1) + I(x2*x2)  + I(x3*x3), 
    data = df, family=binomial) 
# you can also use define a formula similar to the one I suggested in the first version.
-------------------------------------------------------------------------------------------------------
library(parallel)
library(BLR)

data(wheat)

mc = mclapply(2:6, function(x,centers)kmeans(x, centers), x=X) > summary(mc)
     Length Class  Mode
[1,] 9      kmeans list
[2,] 9      kmeans list
[3,] 9      kmeans list
[4,] 9      kmeans list
[5,] 9      kmeans list nstart centers (pars = expand.grid(i=1:3, cent=2:4))

  i cent
1 1    2
2 2    2
3 3    2
4 1    3
5 2    3
6 3    3
7 1    4
8 2    4
9 3    4

L=list()
# zikes horrible
pars2=apply(pars,1,append, L)
mc = mclapply(pars2, function(x,pars)kmeans(x, centers=pars$cent,nstart=pars$i ), x=X)

> summary(mc)
      Length Class  Mode
 [1,] 9      kmeans list
 [2,] 9      kmeans list
 [3,] 9      kmeans list
 [4,] 9      kmeans list
 [5,] 9      kmeans list
 [6,] 9      kmeans list
 [7,] 9      kmeans list
 [8,] 9      kmeans list
 [9,] 9      means list
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(reshape2)
set.seed(1)
N <- 24

dates = seq(as.Date("2014-01-01"), as.Date("2015-12-01"), by = "1 month")
dummy_data <- data.frame(dates = dates, x = rnorm(N,0,1), group = sample(c("A", "B", "C"), size = N, replace = TRUE))
dummy_data_m  <- melt(dummy_data, id.vars = c("dates", "group"))

plot = ggplot(data = dummy_data_m, aes(x = dates, y = value, colour = variable)) + geom_point() + facet_grid(group ~., scales="free_y")

print(plot) # Want to modify y-axis on this plot for each panel


# to expand plot axes, build the y ranges in a data.frame and add a new layer to the plot using geom_blank

# pick an x.value in the range of your x-values in dummy_data
x.value = as.Date("2014-01-01")
x.value = as.Date("2014-01-01")

# Say you want to expand the y-axis ranges for the different subpanels to be (-5, 5), (-4, 4), (-2, 2).  
# If you simply plot at this point the y limits are roughly ~(-1.5, 1.5) for each plot
lower_y = data.frame(dates = x.value, group = c("A", "B", "C"),  value = c(5, 4, 2))

y_ranges = rbind(lower_y, upper_y)
y_ranges_m = melt(y_ranges, id.vars = c("dates", "group"))
plot = plot + geom_blank(data = y_ranges_m, aes(x = dates, y = value, colour = variable))

print(plot) # do not want to plot any values where y < 0 for group A

dummy_data2 = dummy_data

x_adjusted = dummy_data2$x

x_adjusted[x_adjusted < 0 & dummy_data2$group == "A"] = NA

dummy_data2$x = x_adjusted

dummy_data_m2  <- melt(dummy_data2, id.vars = c("dates", "group"))

plot = ggplot(data = dummy_data_m2, aes(x = dates, y = value, colour = variable)) + geom_point() + facet_grid(group ~., scales="free_y")
print(plot) # this will show a plot where the panel for A has a y-axis lower limit above 0
-------------------------------------------------------------------------------------------------------
ldata facet_grid splitter ldata facet_grid xpos <- c(10,10,10) 
ypos <- c(Inf,Inf,Inf)
lab <- c(378,2,50)
splitter <- c(1:3)
ldata <- data.frame(xpos, ypos, lab, splitter)


ggplot(mtcars) + geom_bar(aes(x=cyl)) + facet_grid(~splitter) + 
  geom_text(data=ldata, aes(x=xpos, y=ypos, 
                            label=lab, size=1), 
            vjust=2, parse=FALSE)
-------------------------------------------------------------------------------------------------------
sTout <- split(Tout, Tout$Index)
crosscount <- function(idx1, idx2) { 
      sum(sTout[[idx1]][['Price']][sTout[[idx2]][['ProductID']] %in% sTout[[idx1]][['ProductID']] ] ) }
 combs <- expand.grid(1:4, 1:4)

 full <- t( matrix( mapply(crosscount, idx1=combs[,1], idx2=combs[,2]), 4,4) )

 full[upper.tri(full)] <- NA
 full
     [,1] [,2] [,3] [,4]
[1,]   45   NA   NA   NA
[2,]   45   66   NA   NA
[3,]   45   66   88   NA
[4,]   45   66   88  112 sTout <- split(Tout, Tout$Index)
crosscount <- function(idx1, idx2) { 
      sum(sTout[[idx1]][['Price']][sTout[[idx1]][['ProductID']] %in% sTout[[idx2]][['ProductID']] ] ) }
 combs <- expand.grid(1:5, 1:5)

  full <- t( matrix( mapply(crosscount, idx1=combs[,1], idx2=combs[,2]), 5,5) )

  full[upper.tri(full)] <- NA
  full
#-------------------
         [,1]     [,2]     [,3]     [,4]     [,5]
[1,] 38327684       NA       NA       NA       NA
[2,] 37933389 37855767       NA       NA       NA
[3,] 37617296 37576066 37860673       NA       NA
[4,] 37097790 37098335 37431261 37449372       NA
[5,] 36541878 36584403 36955598 37044139 37471920
# Just a check to make sure these large numbers made sense. > sum(sTout[[1]][["Price"]])
[1] 38327684
-------------------------------------------------------------------------------------------------------
facet_wrap(...) ggplots facet_grid(...) p + facet_grid(cyl~class) qplot(displ, hwy, data=mpg,color=factor(year)) + facet_grid(cyl~class)
-------------------------------------------------------------------------------------------------------
data(diamonds)
diamonds$cut <- paste("Super",as.character(diamonds$cut))
q <- qplot(cut,carat,data=diamonds,geom="boxplot") +
     facet_grid(~color)
library(gridExtra)

grid.arrange(q,
q + theme(axis.text.x = element_text(angle = 90, hjust = 1))) facet_wrap qplot(cut,carat,data=diamonds,geom="boxplot") +
    facet_wrap(~color,ncol=1)
-------------------------------------------------------------------------------------------------------
facet_grid facet_wrap nfacetcols <- function(p) {
  if (is.null(p$facet$cols) & is.null(p$facet$facets)) return(1)
  # facet_grid - version
  if (! is.null(p$facet$cols)) {
    if (length(p$facet$cols)==0) return(1)
    dat <- p$data[,as.character(p$facet$cols)]
    if (is.factor(dat)) return(nlevels(dat)) 
    if (is.data.frame(dat)) return(nrow(unique(dat)))
    if (is.numeric(dat)) return(length(unique(dat)))
  }
  # facet_wrap - version
  if (! is.null(p$facet$facets)){
    if (!is.null(p$facet$ncol)) return(p$facet$ncol)
    dat <- p$data[,as.character(p$facet$facets)]
    tot <- ifelse(is.factor(dat), nlevels(dat), nrow(unique(dat)))
    if (!is.null(p$facet$nrow)) return(ceiling(tot/p$facet$nrow))
    return(ceiling(sqrt(tot)))
  }
} x xlvls <- nlevels(p$data[,p$labels$x]) ggsave # create data set
set.seed(123)
N <- 20
df <- data.frame(a = sample(LETTERS[1:10], N, replace=TRUE), 
                 b = sample(letters[1:5], N, replace=TRUE), 
                 yax = rnorm(N), 
                 xax = factor(sample(letters[16:20], N, replace=TRUE)))
# plot
p <- ggplot(df, aes(xax, yax)) + geom_point() + facet_grid(b~a) 
ggsave("eg.plot.png", 
       p + theme(axis.text.x = element_text(angle = 90, hjust = 1)), 
       width=xlvls*nfacetcols(p)/5)
-------------------------------------------------------------------------------------------------------
ggplot(edu_melt[edu_melt$sex!="b", ], aes(x=COUNTRY, y=percent, fill=sex)) +
geom_bar(position="dodge", width=0.25) + facet_grid(location~.) + labs(x="Country") +
theme(axis.text.x = element_text(angle=30))
-------------------------------------------------------------------------------------------------------
grid=c('xy','yz') z <- seq(-10, 10, 0.01)
x <- cos(z)
y <- sin(z)
sactter.grid(x, y, z, highlight.3d=TRUE,col.axis="blue")
              grid=c('xy','xz','yz')  ## add grid to all facets
          col.grid="lightblue") if ("xy" %in% grid || grid) {
        i <- x.min:x.max
        segments(i, z.min, i + (yx.f * y.max), yz.f * y.max + 
                            z.min, col = col.grid, lty = lty.grid)
        i <- 0:y.max
        segments(x.min + (i * yx.f), i * yz.f + z.min, x.max + 
                            (i * yx.f), i * yz.f + z.min, col = col.grid, lty = lty.grid)
    }
    if ("xz" %in% grid) {
        i <- x.min:x.max
        segments(i + (yx.f * y.max), yz.f * y.max + z.min, 
                         i + (yx.f * y.max), yz.f * y.max + z.max, 
                         col = col.grid, lty = lty.grid)
        temp <- yx.f * y.max
        temp1 <- yz.f * y.max
        i <- z.min:z.max
        segments(x.min + temp,temp1 + i, 
                         x.max + temp,temp1 + i , col = col.grid, lty = lty.grid)

    }

    if ("yz" %in% grid) {
        i <- 0:y.max
        segments(x.min + (i * yx.f), i * yz.f + z.min,  
                         x.min + (i * yx.f) ,i * yz.f + z.max,  
                         col = col.grid, lty = lty.grid)
        temp <- yx.f * y.max
        temp1 <- yz.f * y.max
        i <- z.min:z.max
        segments(x.min + temp,temp1 + i, 
                         x.min, i , col = col.grid, lty = lty.grid)



    }
-------------------------------------------------------------------------------------------------------
panel cl <- kmeans(iris[1:4],3)
idx <- subset(expand.grid(x=1:4,y=1:4),x!=y)
i <- 1
pairs(iris[1:4],bg=cl$cluster,pch=21,
            panel=function(x, y,bg, ...) {
                points(x, y, pch=21,bg=bg)
                points(cl$center[,idx[i,'x']],cl$center[,idx[i,'y']],
                             cex=4,pch=10,col='blue')
                i <<- i +1
            }) lattice splom library(lattice)
splom(iris[1:4],groups=cl$cluster,pch=21,
            panel=function(x, y,i,j,groups, ...) {
                panel.points(x, y, pch=21,col=groups)
                panel.points(cl$center[,j],cl$center[,i],
                             pch=10,col='blue')
            },auto.key=TRUE)
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(plyr)
data1 <- ddply(data1,.(Physicians_Out,Physicians_In),transform,label = length(share))
ggplot(data1,aes(x=Physicians_In,y=share,fill=Physicians_In))+ 
    geom_boxplot() + 
    stat_sum_single(mean) +
    facet_grid(.~Physicians_Out,labeller=label_both,scales='free_x') +
    stat_summary(fun.y=min,aes(label=paste0('N=',label)),geom='text',col='blue',cex=5)
-------------------------------------------------------------------------------------------------------
my.panel <- function(x, y, ..., pf = parent.frame()) {
  grid(NA,NULL)
  lines(x, y, ...)
  if (pf$panel.number == 3) axis(1, at = ticks, labels = format(ticks, "%b-%y"))
}

plot(zoo(Factors, ticks), 
   main = "Factors 1, 2 & 3", xlab= "Date", ylab = paste("Factor", 1:3),
   panel = my.panel,
   col = 1:3,
   xaxt = "n")
-------------------------------------------------------------------------------------------------------
# One column (service)
mat1 <- data.frame(service=names(services))

# List (one entry per service name) of service/metric pairs
list1 <- apply(df1, 1, function(service) expand.grid(service=service, metric=names(services[[service]])))

# Two columns (service and metric)
mat2 <- do.call(rbind, list1)

# List (one entry per service/metric pair) of service/metric/stat tuples
list2 <- apply(df2, 1, function(x) expand.grid(service=x[1], metric=x[2], stat=services[[x[1]]][[x[2]]]))

# Three columns (service, metric, and stat)
tuples <- do.call(rbind, list2) data.merged <- apply(tuples, 1, process.stat)
-------------------------------------------------------------------------------------------------------
combinations <- expand.grid(1:num.Patches, 1:num.alleles)
names <- paste0("P", combinations[,1], "A", combinations[,2])
-------------------------------------------------------------------------------------------------------
ggplot df <- data.frame(t(freqTable))        # transpose (more suitable for plotting)
df <- cbind(Response=rownames(df),df) # add row names as first column

plot(as.numeric(df$Response),df$f,type="b",col="red", 
     xaxt="n", ylab="Count",xlab="Response")
lines(as.numeric(df$Response),df$m,type="b",col="blue")
axis(1,at=c(1,2,3,4,5,6),labels=c("Str.Agr.","Sl.Agr","Neither","Sl.Disagr","Str.Disagr","NA")) df df <- data.frame(freqTable)
df <- cbind(Gender=rownames(df),df)    # append rownames (Gender)
df <- df[-3,]                          # drop unknown gender
df
#   Gender X1 X2 X3 X4 X5 X8
# m      m  5 16  3 16  5  0
# f      f 12 25  3 10  3  1

df <- df[-3,]     # remove unknown gender column

library(ggplot2)
library(reshape2)
gg=melt(df)

labels <- c("Agree\nFully","Somewhat\nAgree","Neither Agree\nnor Disagree","Somewhat\nDisagree","Disagree\nFully", "No Answer")
ggp <- ggplot(gg,aes(x=variable,y=value))
ggp <- ggp + geom_bar(aes(fill=Gender), position="dodge", stat="identity")
ggp <- ggp + scale_x_discrete(labels=labels)
ggp <- ggp + theme(axis.text.x = element_text(angle=90, vjust=0.5))
ggp <- ggp + labs(x="", y="Frequency")
ggp ggp + facet_grid(Gender~.)
-------------------------------------------------------------------------------------------------------
points = seq(-2, 0, length=20)

XY = expand.grid(X=points,Y=-points)
Zf <- function(X,Y){
     2./exp((X-.5)^2+Y^2)-2./exp((X+.5)^2+Y^2);
     }
Z <- Zf(XY$X, XY$Y)
zlim <- range(Z)
zlen <- zlim[2] - zlim[1] + 1

jet.colors <- 
      colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan",
                      "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))
colorzjet <- jet.colors(100)
open3d()
rgl.surface(x=points, y=matrix(Z,20), 
            coords=c(1,3,2),z=-points, 
            color=colorzjet[ findInterval(Z, seq(min(Z), max(Z), length=100))] )
axes3d()
rgl.snapshot("copyMatlabstyle.png") clear3d(type = "lights")
light3d(theta=0, phi=0)
light3d(theta=0, phi=0)  # twice as much light. grid3d("x")
 grid3d("y")
 grid3d("z")

 rgl.snapshot("copyMatlabstyle3.png") grid3d("y+") axes3d axis3d R2BayesX::plot3d
-------------------------------------------------------------------------------------------------------
## generate pairs of row numbers
rows <- sequence(nrow(mydf))
grid <- subset(expand.grid(Var1=rows,Var2=rows),Var1 > Var2)

## define some functions
comparison1 <- function(a,b,x)
  match(x[a,-1],x[b,-1])

comparison2 <- function(a,b,x)
  x[a,-1]==x[b,-1]

## apply (comparison1 or comparison2)
matches <- t(mapply(comparison1,grid$Var2,grid$Var1,MoreArgs=list(x=mydf)))
dimnames(matches) <- list(paste(grid$Var2,grid$Var1,sep=","),
                          names(mydf)[-1]) comparison1 > head(matches)
    X1 X2 X3 X4 X5 X6
1,2  1  1 NA  1  1  1
1,3  1  1 NA  1  1  1
1,4  1  1  4  1  1  1
1,5 NA NA  1 NA NA NA
1,6  1  1  2  1  1  1
1,7  4  4  1  4  4  4 comparison2 > head(matches)
       X1    X2    X3    X4    X5    X6
1,2  TRUE  TRUE FALSE  TRUE  TRUE  TRUE
1,3  TRUE  TRUE FALSE  TRUE  TRUE  TRUE
1,4  TRUE  TRUE FALSE FALSE  TRUE  TRUE
1,5 FALSE FALSE  TRUE FALSE FALSE FALSE
1,6  TRUE FALSE  TRUE FALSE FALSE  TRUE
1,7 FALSE FALSE  TRUE  TRUE FALSE FALSE
-------------------------------------------------------------------------------------------------------
ggplot2 googleVis ## PRE-REQS
require(plyr)
require(ggplot2)

## GET SOME BASIC DATA
films<-read.csv("box.csv")

## ALL OF THIS IS FAKING DATA
get_dist<-function(n,g){

  dist<-g-(abs(sort(g-abs(rnorm(n,g,g*runif(1))))))
  dist<-c(0,dist-min(dist),0)
  dist<-dist*g/sum(dist)
  return(dist)
}

get_dates<-function(w){
  start<-as.Date("01-01-00",format="%d-%m-%y")+ceiling(runif(1)*365)
  return(start+w)
}

films$WEEKS<-ceiling(runif(1)*10)+6
f<-ddply(films,.(RANK),function(df)expand.grid(RANK=df$RANK,WEEKGROSS=get_dist(df$WEEKS,df$GROSS)))
weekly<-merge(films,f,by=("RANK"))


## GENERATE THE PLOT DATA
plot.data<-ddply(weekly,.(RANK),summarise,NAME=NAME,WEEKDATE=get_dates(seq_along(WEEKS)*7),WEEKGROSS=ifelse(RANK %% 2 == 0,-WEEKGROSS,WEEKGROSS),GROSS=GROSS)

g<-ggplot() + 

  geom_area(data=plot.data[plot.data$WEEKGROSS>=0,],
            aes(x=WEEKDATE,
                ymin=0,
                y=WEEKGROSS,
                group=NAME,
                fill=cut(GROSS,c(seq(0,1000,100),Inf)))
            ,alpha=0.5,
            stat="smooth", fullrange=T,n=1000,
            colour="white",
            size=0.25,alpha=0.5) +

  geom_area(data=plot.data[plot.data$WEEKGROSS<0,],
            aes(x=WEEKDATE,
                ymin=0,
                y=WEEKGROSS,
                group=NAME,
                fill=cut(GROSS,c(seq(0,1000,100),Inf)))
            ,alpha=0.5,
            stat="smooth", fullrange=T,n=1000,
            colour="white",
            size=0.25,alpha=0.5) +

  theme_bw() + 
  scale_fill_brewer(palette="RdPu",name="Gross\nEUR (M)") +
  ylab("") + xlab("")

b<-ggplot_build(g)$data[[1]]
b.ymax<-max(b$y)


## MAKE LABELS FOR GROSS > 450M
labels<-ddply(plot.data[plot.data$GROSS>450,],.(RANK,NAME),summarise,x=median(WEEKDATE),y=ifelse(sum(WEEKGROSS)>0,b.ymax,-b.ymax),GROSS=max(GROSS))
labels<-ddply(labels,.(y>0),transform,NAME=paste(NAME,GROSS),y=(y*1.1)+((seq_along(y)*20*(y/abs(y)))))

## PLOT
g + 
  geom_segment(data=labels,aes(x=x,xend=x,y=0,yend=y,label=NAME),size=0.5,linetype=2,color="purple",alpha=0.5) +
  geom_text(data=labels,aes(x,y,label=NAME),size=3) dput() structure(list(RANK = 1:50, NAME = structure(c(2L, 45L, 18L, 
                                               33L, 32L, 29L, 34L, 23L, 4L, 21L, 38L, 46L, 15L, 36L, 26L, 49L, 
                                               16L, 8L, 5L, 31L, 17L, 27L, 41L, 3L, 48L, 40L, 28L, 1L, 6L, 24L, 
                                               47L, 13L, 10L, 12L, 39L, 14L, 30L, 20L, 22L, 11L, 19L, 25L, 35L, 
                                               9L, 43L, 44L, 37L, 7L, 42L, 50L), .Label = c("Alice in Wonderland", 
                                                                                            "Avatar", "Despicable Me 2", "E.T.", "Finding Nemo", "Forrest Gump", 
                                                                                            "Harry Potter and the Deathly Hallows Part 1", "Harry Potter and the Deathly Hallows Part 2", 
                                                                                            "Harry Potter and the Half-Blood Prince", "Harry Potter and the Sorcerer's Stone", 
                                                                                            "Independence Day", "Indiana Jones and the Kingdom of the Crystal Skull", 
                                                                                            "Iron Man", "Iron Man 2", "Iron Man 3", "Jurassic Park", "LOTR: The Return of the King", 
                                                                                            "Marvel's The Avengers", "Pirates of the Caribbean", "Pirates of the Caribbean: At World's End", 
                                                                                            "Pirates of the Caribbean: Dead Man's Chest", "Return of the Jedi", 
                                                                                            "Shrek 2", "Shrek the Third", "Skyfall", "Spider-Man", "Spider-Man 2", 
                                                                                            "Spider-Man 3", "Star Wars", "Star Wars: Episode II -- Attack of the Clones", 
                                                                                            "Star Wars: Episode III", "Star Wars: The Phantom Menace", "The Dark Knight", 
                                                                                            "The Dark Knight Rises", "The Hobbit: An Unexpected Journey", 
                                                                                            "The Hunger Games", "The Hunger Games: Catching Fire", "The Lion King", 
                                                                                            "The Lord of the Rings: The Fellowship of the Ring", "The Lord of the Rings: The Two Towers", 
                                                                                            "The Passion of the Christ", "The Sixth Sense", "The Twilight Saga: Eclipse", 
                                                                                            "The Twilight Saga: New Moon", "Titanic", "Toy Story 3", "Transformers", 
                                                                                            "Transformers: Dark of the Moon", "Transformers: Revenge of the Fallen", 
                                                                                            "Up"), class = "factor"), YEAR = c(2009L, 1997L, 2012L, 2008L, 
                                                                                                                               1999L, 1977L, 2012L, 2004L, 1982L, 2006L, 1994L, 2010L, 2013L, 
                                                                                                                               2012L, 2002L, 2009L, 1993L, 2011L, 2003L, 2005L, 2003L, 2004L, 
                                                                                                                               2004L, 2013L, 2011L, 2002L, 2007L, 2010L, 1994L, 2007L, 2007L, 
                                                                                                                               2008L, 2001L, 2008L, 2001L, 2010L, 2002L, 2007L, 1983L, 1996L, 
                                                                                                                               2003L, 2012L, 2012L, 2009L, 2010L, 2009L, 2013L, 2010L, 1999L, 
                                                                                                                               2009L), GROSS = c(760.5, 658.6, 623.4, 533.3, 474.5, 460.9, 448.1, 
                                                                                                                                                 436.5, 434.9, 423.3, 422.7, 415, 409, 408, 403.7, 402.1, 395.8, 
                                                                                                                                                 381, 380.8, 380.2, 377, 373.4, 370.3, 366.9, 352.4, 340.5, 336.5, 
                                                                                                                                                 334.2, 329.7, 321, 319.1, 318.3, 317.6, 317, 313.8, 312.1, 310.7, 
                                                                                                                                                 309.4, 309.1, 306.1, 305.4, 304.4, 303, 301.9, 300.5, 296.6, 
                                                                                                                                                 296.3, 295, 293.5, 293), WEEKS = c(9, 9, 9, 9, 9, 9, 9, 9, 9, 
                                                                                                                                                                                    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 
                                                                                                                                                                                    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9)), .Names = c("RANK", 
                                                                                                                                                                                                                                                             "NAME", "YEAR", "GROSS", "WEEKS"), row.names = c(NA, -50L), class = "data.frame")
-------------------------------------------------------------------------------------------------------
space="free_y" facet_grid() ggplot(data=df) + geom_point(aes(x=t, y=V)) + 
        facet_grid(C2~C1, scales='free_y',space="free_y")
-------------------------------------------------------------------------------------------------------
predict predict data<-expand.grid(age=ag,vehicle=veh, position=0.7)
fit.gam1<-matrix(predict(gam1,data),10,10)
-------------------------------------------------------------------------------------------------------
ggplot(df, aes(x = factor_variable, y = (..count..)/ sapply(PANEL, FUN=function(x) sum(count[PANEL == x])))) +
                 geom_bar(fill = "deepskyblue3", width=.5) +
                 stat_bin(geom = "text",
                          aes(label = paste(round((..count..)/ sapply(PANEL, FUN=function(x) sum(count[PANEL == x])) * 100), "%")),
                          vjust = -1, color = "grey30", size = 6) +
                 facet_grid(. ~ second_factor_variable)
-------------------------------------------------------------------------------------------------------
ggplot(testd, aes(x = fac, y = value)) + geom_point() + facet_grid( ~ id) x = id aes x = fac
-------------------------------------------------------------------------------------------------------
x <- expand.grid(replicate(3, list(0:5)))
x[rowSums(x) == 5, ]
#     Var1 Var2 Var3
# 6      5    0    0
# 11     4    1    0
# 16     3    2    0
# 21     2    3    0
# 26     1    4    0
# 31     0    5    0
# 41     4    0    1
# 46     3    1    1
# 51     2    2    1
# 56     1    3    1
# 61     0    4    1
# 76     3    0    2
# 81     2    1    2
# 86     1    2    2
# 91     0    3    2
# 111    2    0    3
# 116    1    1    3
# 121    0    2    3
# 146    1    0    4
# 151    0    1    4
# 181    0    0    5 expand.grid combn expand.grid permutations library(gtools)
x <- permutations(6, 3, v = 0:5, set = FALSE, repeats.allowed=TRUE)
x[rowSums(x) == 5, ]
-------------------------------------------------------------------------------------------------------
library("ggplot2")
library("plyr")
mydata <- read.table("C:\\myfile.csv", sep="\t", header=TRUE)
seasons <- mydata$seasons
years <- mydata$year
u <- mydata$u
v <- mydata$v
intensity <- mydata$intensity
wind <- cbind(u,v,intensity,seasons,years)
wind <- data.frame(wind)
x <- ddply(wind, .(years, seasons), summarize, x=cumsum(u*0.0108))
y <- ddply(wind, .(years, seasons), summarize, y=cumsum(v*0.0108))
x <- x$x
y <- y$y
wind <- cbind(wind,x,y)
wind <- data.frame(wind)
wind$seasons[wind$seasons == 1] <- "winter"
wind$seasons[wind$seasons == 2] <- "spring"
wind$seasons[wind$seasons == 3] <- "summer"
wind$seasons[wind$seasons == 4] <- "autumn"
p <- ggplot(wind, aes(x, y)) + geom_path(aes(colour = intensity))+ scale_colour_gradientn(colours=c("blue","yellow","red"))
p + facet_grid(seasons ~ years)
-------------------------------------------------------------------------------------------------------
ggplot2 levels <- c('low','med','high')
df <- data.frame(
    sample = c("a","b","d","e","f","g","h","i","l","m"),
    value = seq(0,1,length.out=10),
    level = factor(levels[c(1,1,1,1,2,2,2,3,3,3)], level=rev(levels))
)    

# require(ggplot2)
# require(grid)
ggplot(data=df, aes(x=TRUE, y=sample, fill=value)) + geom_tile() +
scale_fill_gradientn(colours=c('green','black','red')) + 
facet_grid(level~., scales='free', space='free') +
scale_y_discrete(expand=c(0,0)) +
theme(panel.margin=unit(0.1,'mm'), axis.title=element_blank(), 
      axis.text.x=element_blank(), axis.ticks.x=element_blank(), 
      legend.title=element_blank())
-------------------------------------------------------------------------------------------------------
plot(r, col =  matlab.like(25) ggplot library(ggplot2)
library(colorRamps)

x    <- seq(-1,1,len=5)
y    <- seq(-1,1,len=5)
gg   <- expand.grid(x=x,y=-y)
gg$z <- seq(-1,1,len=25)
ggplot(gg) + 
  geom_raster(aes(x=x,y=y,fill=z))+
  scale_fill_gradientn(colours=matlab.like(25), breaks=c(-1,0,1))
-------------------------------------------------------------------------------------------------------
# Load data
data(Feldspar)

# Sort it by decreasing pressure 
# (so small grobs sit on top of large grobs
Feldspar <- Feldspar[with(Feldspar, order(-P.Gpa)), ]

# Build and Render the Plot
ggtern(data = Feldspar, aes(x = An, y = Ab, z = Or)) + 
#the layer
geom_point(aes(fill = T.C, 
               size = P.Gpa, 
               shape = Feldspar)) + 
#scales
scale_shape_manual(values = c(21, 24)) + 
scale_size_continuous(range = c(2.5, 7.5)) + 
scale_fill_gradient(low = "green", high = "red") + 

#theme tweaks
theme_tern_bw()  + 
theme(legend.position      = c(0, 1), 
      legend.justification = c(0, 1), 
      legend.box.just      = "left") + 

#tweak guides
guides(shape= guide_legend(order   =1,
                           override.aes=list(size=5)),
       size = guide_legend(order   =2),
       fill = guide_colourbar(order=3)) +

#labels and title
labs(size = "Pressure/GPa", 
     fill = "Temperature/C") + 
ggtitle("Feldspar - Elkins and Grove 1990") ggtern(data=Feldspar,aes(An,Ab,Or)) +
  geom_confidence(aes(group=Feldspar,
                      fill=..level..,
                      alpha=1-..level..),
                      n=2000,
                  breaks=c(0.01,0.02,0.03,0.04,
                           seq(0.05,0.95,by=0.1),
                           0.99,0.995,0.9995),
                  color=NA,linetype=1) +
  geom_density2d(aes(color=..level..)) + 
  geom_point(fill="white",aes(shape=Feldspar),size=5) +  
  theme_tern_bw() + 
  theme_tern_nogrid() + 
  theme(ternary.options=element_ternary(padding=0.2),
                        legend.position=c(0,1),
                        legend.justification=c(0,1),
                        legend.box.just="left") +
  labs(color="Density",fill="Confidence",
   title="Feldspar - Elkins and Grove 1990 + Confidence Levels + Density") +
  scale_color_gradient(low="gray",high="magenta") +
  scale_fill_gradient2(low="red",mid="orange",high="green",
                       midpoint=0.8) +
  scale_shape_manual(values=c(21,24)) + 
  guides(shape= guide_legend(order   =1,
                             override.aes=list(size=5)),
         size = guide_legend(order   =2),
         fill = guide_colourbar(order=3),
         color= guide_colourbar(order=4),
         alpha= "none")
-------------------------------------------------------------------------------------------------------
ggplot2 library(ggplot2)                           

# Set up the vectors                           
days <- c("Mon","Tues","Wed","Thurs","Fri")
slots <- c("Coffee/Breakfast","Lunch","Happy Hour","Dinner")

# Create the data frame
df <- expand.grid(days, slots)
df$value <- c(1,1,1,1,2,1,1,NA,NA,1,4,4,7,4,1,5,6,14,5,1)    

#Plot the Data
g <- ggplot(df, aes(Var1, Var2)) + geom_point(aes(size = value), colour = "green") + theme_bw() + xlab("") + ylab("")
g + scale_size_continuous(range=c(10,30)) + geom_text(aes(label = value))
-------------------------------------------------------------------------------------------------------
model <- lm( charges~age+hrs+age*hrs, df)
# set up grid of (x,y) values
age <- seq(0,1000, by=20)
hrs <- seq(0,1000, by=20)
gg <- expand.grid(age=age, hrs=hrs)
# prediction from the linear model
gg$charges <-predict(model,newdata=gg)

# contour plot 
library(ggplot2)
library(colorRamps)  
library(grDevices)
jet.colors <- colorRampPalette(matlab.like(9))
ggplot(gg, aes(x=age, y=hrs, z=charges))+
  stat_contour(aes(color=..level..),binwidth=200, size=2)+
  scale_color_gradientn(colours=jet.colors(8)) # 3D scatterplot
library(scatterplot3d)
scatterplot3d(gg$age, gg$hrs, gg$charges) # interactive 3D scatterplot (just a screen shot here)
library(rgl)
plot3d(gg$age,gg$hrs,gg$charges) # interactive 3D surface plot with shading (screen shot)
colorjet <- jet.colors(100)
open3d()
rgl.surface(x=age, z=hrs, y=0.05*gg$charges, 
            color=colorzjet[ findInterval(gg$charges, seq(min(gg$charges), max(gg$charges), length=100))] )
axes3d()
-------------------------------------------------------------------------------------------------------
ggplot(myfile, aes(x= Count, fill = Type))+ geom_histogram (binwidth = 10, alpha = 0.5, position = "identity")+facet_grid(~Type) ggplot
-------------------------------------------------------------------------------------------------------
expand.grid # sweep 1, sweep 2
sweep1 <- c(1, 2, 4)
sweep2 <- c(3, 5, 7)

# expand out the combinations
combinations <- expand.grid(sweep1=sweep1, sweep2=sweep2)

# apply over the data frame
results <- apply(combinations, 1, function(row) {
  # set up the parameters from the row which has been passed in.
  initial_conditions[6] <- row["sweep1"]
  parameters[3]         <- row["sweep2"]

  # call ode23s 
  res <- ode23s(initial_conditons, parameters, function, whatever, ...)

  # there should be a nicer way than calling nrow twice here, but R doesn't
  # seem to have the nice 'end' keyword
  # also, we copy in the row, so that's in the output.
  c(row, one=res[nrow(res), 1], two=res[nrow(res), 2])
})

# because the apply has flipped rows to columns...
results <- as.data.frame(t(results))

results
#     sweep1 sweep2 one  two
#  1  1      3      ...  ...
#  2  2      3      ...  ...
# ... sweep3
-------------------------------------------------------------------------------------------------------
by tapply split # some example data
set.seed(1)
df <- data.frame(x = as.factor(rep(1:5, each=10)), y1=rnorm(50), y2=rnorm(50))

# with `tapply`
a <- do.call(rbind, sapply(df[,2:3], function(i) tapply(i, df$x, summary)))
# with `by`
a <- do.call(rbind, sapply(df[,2:3], function(i) by(i, df$x, summary))) > a
         Min.  1st Qu.    Median    Mean 3rd Qu.   Max.
 [1,] -0.8356 -0.54620  0.256600  0.1322  0.5537 1.5950
 [2,] -2.2150 -0.03775  0.491900  0.2488  0.9132 1.5120
 [3,] -1.9890 -0.39760  0.009218 -0.1337  0.5694 0.9190
 [4,] -1.3770 -0.32140 -0.056560  0.1207  0.6693 1.3590
 [5,] -0.7075 -0.23120  0.126100  0.1341  0.6619 0.8811
 [6,] -1.1290 -0.55080  0.103000  0.1435  0.5268 1.9800
 [7,] -1.8050 -0.02243  0.171000  0.4512  1.2720 2.4020
 [8,] -1.2540 -0.67980 -0.221100 -0.2477  0.2372 0.6107
 [9,] -1.5240 -0.26190  0.300000  0.1274  0.5380 1.1780
[10,] -1.2770 -0.56560  0.042540  0.1123  1.0450 1.5870 b <- expand.grid(level=levels(df$x),var=names(df[,2:3]))
cbind(a,b) > cbind(b,a)
   level var    Min.  1st Qu.    Median    Mean 3rd Qu.   Max.
1      1  y1 -0.8356 -0.54620  0.256600  0.1322  0.5537 1.5950
2      2  y1 -2.2150 -0.03775  0.491900  0.2488  0.9132 1.5120
3      3  y1 -1.9890 -0.39760  0.009218 -0.1337  0.5694 0.9190
4      4  y1 -1.3770 -0.32140 -0.056560  0.1207  0.6693 1.3590
5      5  y1 -0.7075 -0.23120  0.126100  0.1341  0.6619 0.8811
6      1  y2 -1.1290 -0.55080  0.103000  0.1435  0.5268 1.9800
7      2  y2 -1.8050 -0.02243  0.171000  0.4512  1.2720 2.4020
8      3  y2 -1.2540 -0.67980 -0.221100 -0.2477  0.2372 0.6107
9      4  y2 -1.5240 -0.26190  0.300000  0.1274  0.5380 1.1780
10     5  y2 -1.2770 -0.56560  0.042540  0.1123  1.0450 1.5870
-------------------------------------------------------------------------------------------------------
plot(unrate.df, type="n")
makeRectangles(recessions.trim, col="pink", alpha=0.5)
lines(unrate.df)
grid() makeRectangles makeRectangles = function(x, col, alpha=1, border=NA, ...) {

  col = col2rgb(col=col, alpha=FALSE)
  col = rgb(red=col[1], green=col[2], blue=col[3], 
              alpha=floor(255*alpha) , maxColorValue=255)
  rect(x[,1], par("usr")[3], x[,2], par("usr")[4], col=col, border=border, ...)

  return(invisible())
}
-------------------------------------------------------------------------------------------------------
size geom_text aes Data$size <- size

p <- ggplot(data = Data, aes(x = factor(''), y = Freq, fill = Var1)) +
       geom_bar(stat = "identity",position = "fill", width = 1) +
       scale_fill_brewer(palette = 3) +
       geom_text(aes(y = y, label = label, 
                     position ="identity", face = "bold", size = size), hjust=0.5, 
                     vjust=0.5) +
       xlab('') + ylab('') + labs(fill = '') + ggtitle('Example') +
       theme(axis.text.y = element_text(size=14,face="bold"),
             panel.background = element_blank(),
             plot.title = element_text(size = 20, colour = "black", face = "bold")) + 
             facet_grid(facets = . ~ Var2) + 
             guides(size=FALSE) + guides(size=FALSE) size Var2 size + scale_size(range=c(6,10)) 6,10
-------------------------------------------------------------------------------------------------------
library(ggtern)
DATA <- data.frame(x = c(1,0,0),
                   y = c(0,1,0),
                   z = c(0,0,1),
                   xend = c(0,.5,.5),
                   yend = c(.5,0,.5),
                   zend = c(.5,.5,0),
                   Series = c("yz","xz","xy"))
ggtern(data=DATA,aes(x,y,z,xend=xend,yend=yend,zend=zend)) + 
  geom_segment(aes(color=Series),size=1) +
  scale_color_manual(values=c("darkgreen","darkblue","darkred")) +
  theme_bw() + theme_nogrid() + 
  theme(legend.position=c(0,1),legend.justification=c(0,1)) + 
  labs(title = "Sample Midpoint Segments")
-------------------------------------------------------------------------------------------------------
require(ggplot2)

# first subplot
p1 = ggplot(data, aes(x = x, y = y1))
p1 = p1 + geom_point()
p1 = p1 + facet_grid(y2 ~ y3)
p1

# second subplot
p2 = ggplot(data, aes(x = x, y = y2))
p2 = p2 + geom_point()
p2 = p2 + facet_grid(y1 ~ y3)
p2

# third subplot
p3 = ggplot(data, aes(x = x, y = y3))
p3 = p3 + geom_point()
p3 = p3 + facet_grid(y1 ~ y2)
p3 multiplot(p1,p2,p3, cols = 3)
-------------------------------------------------------------------------------------------------------
ggplot(DF, aes(wpbCount , x)) +
  geon_point() +
  facet_grid(. ~ bin)
-------------------------------------------------------------------------------------------------------
baseSum=0.0
Visits = NULL
while(baseSum < 100)
{
  Screen=(rpois (1, lambda=3)) 
  y=runif(Screen,0,1) 
  Base = length(which(y<=0.5))
  baseSum = baseSum + Base
  SF = Screen - Base
  Visits=rbind(Visits,c("Screen"=Screen,"BaseCount"=Base,"SFCount"=SF))    
}
plot(cumsum(Visits[,"BaseCount"]),type="b");grid()
sum(Visits[,"BaseCount"]) tooManyRuns = t(sapply(rpois (110, lambda=3) , function(X) { y=runif(X,0,1); Base = length(which(y<=0.5)); SF = X-Base; return(c("Screen"=X,"BaseCount"=Base,"SFCount"=SF)) } ))
Visits =tooManyRuns[1:min(which(cumsum(tooManyRuns[,"BaseCount"])>=100.0)),]
plot(cumsum(Visits[,"BaseCount"]),type="b");grid()
sum(Visits[,"BaseCount"]) numRunsNeeded = sapply(1:1000,
       function(...)
       {
        tooManyRuns = t(sapply(rpois (110, lambda=3) , function(X) { y=runif(X,0,1); Base = length(which(y<=0.5)); SF = X-Base; return(c("Screen"=X,"BaseCount"=Base,"SFCount"=SF)) } ))
        return(min(which(cumsum(tooManyRuns[,"BaseCount"])>=100.0)))
       } )   

plot(density(numRunsNeeded));rug(numRunsNeeded);abline(v=mean(numRunsNeeded));abline(v=median(numRunsNeeded),lty=2)
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(reshape2)

melted_a <- melt(A)


ggplot(melted_a, aes(variable, value)) +
  geom_jitter() +
  facet_grid(. ~ x_1)

ggplot(melted_a, aes(variable, value)) +
  geom_jitter() +
  facet_grid(variable ~ x_1) aes_string() aes() ggplot_fun <- function(data, x, y, rowfacet, colfacet, ...){
  p <- ggplot(data, aes_string(x, y))
  p <- p + geom_jitter()
  p <- p + facet_grid(as.formula(sprintf("%s ~ %s", rowfacet, colfacet))
}

ggplot_fun(melted_a, variable, value, variable, x_1)
-------------------------------------------------------------------------------------------------------
variable2 variable "Temp. Max./Min." "Temp. Max." "Temp. Min." me$variable2 <- as.character(me$variable)
me$variable2[me$variable2 %in% c("Temp. Max.","Temp. Min.")] <- "Temp. Max./Min." facet_grid facet_grid(variable2 ~., scales = "free_y")
-------------------------------------------------------------------------------------------------------
Collimator Head geom_abline() library(plyr)
#subset only firt two values
 df2<-ddply(df,.(Collimator,Head),function(x) head(x,2))
 head(df2)
   A0   T         A Counts    CR Head Collimator
1  76  97  63.45388  99780  3326   H1       HRGP
2 274  98 228.34282 317952 10598   H1       HRGP
3  76  85  64.88609 102830  3428   H2       HRGP
4 274  87 233.06284 328231 10941   H2       HRGP
5  76 328  41.29136 121230  4041   H1       LEGP
6 274 330 148.31347 424329 14144   H1       LEGP

#caclulate slope and intercept
 df3<-ddply(df2,.(Collimator,Head),summarise, int=coefficients(lm(CR~A))[1],
                      slop=coefficients(lm(CR~A))[2])
 df3
  Collimator Head      int      slop
1       HRGP   H1 527.5309  44.10241
2       HRGP   H2 529.3279  44.67324
3       LEGP   H1 143.0519  94.40105
4       LEGP   H2 146.2766  96.95737
5       LEHS   H1 567.3029 155.85205
6       LEHS   H2 694.4843 162.54077

ggplot(df,aes(x=A,y=CR,col=Head))+geom_point()+geom_line() + 
  facet_grid(Collimator~Head, scales="fixed") + 
  scale_x_continuous("Activity [MBq]", expand = c(0,0))+ ylim(0,80000) + 
  ylab("Count Rate [cps]") + 
  theme_bw()+theme(legend.position = "none")+
  geom_abline(data=df3,aes(intercept=int,slope=slop,color=Head))
-------------------------------------------------------------------------------------------------------
library(ggplot2)
(p <- ggplot(df,aes(x=A,y=CR,col=Head))+
    geom_point()+geom_line() +
    facet_grid(Collimator~Head, scales="fixed")+
    scale_x_continuous("Activity [MBq]",
                       expand = c(0,0))+ylim(0,80000)+
  ylab("Count Rate [cps]") + theme_bw()+theme(legend.position = "none"))

 library(plyr)
 subdf <- ddply(df,c("Collimator","Head"),
                function(x) x[1:2,])
 p + geom_smooth(method="lm",data=subdf,colour="gray",se=FALSE,
                 fullrange=TRUE)
-------------------------------------------------------------------------------------------------------
library(data.table)

#datasets borrowed from @androboy s answer (removed special character for code formatting to work)
quer <- structure(list(QueryID = c(1L, 1L, 1L, 2L, 2L, 3L, 3L, 4L, 4L, 4L), 
                       Table = c("t1", "t2", "t3", "t1", "t3", "t4", "t2", "t2", "t3", "t4")), 
                  .Names = c("QueryID", "Table"), class = "data.frame", row.names = c(NA, -10L))
size <- structure(list(Table = c("t1", "t2", "t3", "t4"), 
                       GB = c(20L, 40L, 10L, 50L)), .Names = c("Table", "GB"), 
                  class = "data.frame", row.names = c(NA, -4L))

quer <- data.table(quer)
size <- data.table(size)
# number of queries to run
queries <- 2

# creating unique combinations of two queries each-------------------
querylist <- vector(mode="list",length=queries)
for(i in seq(queries))
{
  querylist[[i]]<-unique(quer$QueryID)
}
qdf <- (expand.grid(querylist))
# removing rows with same query counted twice
if ( queries > 1)
{
  test <- apply(
    t(combn(seq(queries),2)),
    1,
    function(x)
    {
      (qdf[,x[1]] != qdf[,x[2]])
    }
  )

  qdf <- qdf[rowSums(test) == (queries-1),]
}

qdf <- data.table(qdf)
# checking tablesizes needed to run this combination-------------------
qdf[,tablesneeded := '']
qdf[,sizeneeded := as.integer(NA)]

setkeyv(quer,'QueryID')
setkeyv(size,'Table')

for( i in seq(nrow(qdf)))
{
  Tables <- quer[data.table(V1 =unlist(qdf[i,grep(colnames(qdf), pattern = "Var", value = TRUE), with = FALSE]))[,keyby = 'V1']][,unique(Table)]

  qdf[i, tablesneeded := paste(Tables,collapse = ',')]

  qdf[i, sizeneeded := as.integer(sum(size[data.table(V1 = Tables)[, keyby = 'V1']][,GB], na.rm = TRUE))]

}

# lowest size option for current number of queries-----------------------
qdf[which.min(sizeneeded)]
-------------------------------------------------------------------------------------------------------
gg <- melt(df)
ggplot(gg) + geom_bar(aes(x=value,fill=variable)) + facet_grid(variable~., scale.) ggplot(gg) + 
  stat_density(aes(x=value, color=variable),geom="line",position="dodge")
-------------------------------------------------------------------------------------------------------
ggplot(gg,aes(x=Hour.of.day, y=Distance.travelled)) +
    geom_pointrange(aes(ymin=Distance.travelled-ci,ymax=Distance.travelled+ci,color=Model))+
    facet_grid(Model~.) + 
    stat_smooth(formula=y~1, method="lm",linetype=2,se=F)+
    geom_abline(aes(slope=0,intercept=mean(Distance.travelled)),linetype=3) stat_smooth(...)
-------------------------------------------------------------------------------------------------------
vjust geom_text x y ggplot(data) +
  geom_line(aes(x=x, y=y)) +
  geom_text(data=topValues, aes(x=x, y=y, label=y), vjust = 1.5) + # label the highest y value
  facet_grid(category ~ ., scale="free") +
  scale_x_continuous(expand=c(0,0)) +
  scale_y_continuous(expand=c(0,0))
-------------------------------------------------------------------------------------------------------
data.table require(ggplot2)
require(data.table)
require(scales)

grp <- function(x) {
  percentage = as.numeric(table(x)/length(x))
  list(x = levels(x),
       percentage = percentage,
       label = paste0( round( as.numeric(table(x)/length(x), 0 ) * 100 ), "%")
  )
}

agg <- function(data, x, groupby1 = NULL, groupby2 = NULL,...){
  data = substitute(data)
  x = substitute(x)
  groupby1 = substitute(groupby1)
  groupby2 = substitute(groupby2)

  if(is.null(groupby1) & is.null(groupby2)) {
    eval(data)[, grp(eval(x))]    
  } else if (!is.null(groupby1) & is.null(groupby2)) {
    eval(data)[, grp(eval(x)), by=groupby1]
  } else if (!is.null(groupby1) & !is.null(groupby2)) {
    eval(data)[, grp(eval(x)), by=list(eval((groupby1)),eval(groupby2))]
  } else {
    eval(data)[, grp(eval(x)), by=groupby2]
  }
} 

ggfreq <- function(data, facet_flip = TRUE, bar_fill = "#56B4E9",
                   bar_alpha = 0.9, xlab = NULL, ylab = NULL, 
                   xlim = NULL, x_angle = 0, x_vjust = 0,
                   text_vjust = -0.5, text_size = 5, max_y = NULL,
                   max_y_porc = 1.05, bar_width = 0.6){

  data = eval(substitute(data))
  label = substitute(data$label)
  groupby1 = substitute(groupby1)
  groupby2 = substitute(groupby2)
  nm <- names(data)
  groupby1 <- nm[nm %in% "groupby1"]
  x <- nm[nm %in% "x"]
  y <- nm[nm %in% "percentage"]
  label <- nm[nm %in% "label"]

  if(is.null(max_y)) max_y <- max(data[["percentage"]])*max_y_porc else max_y = max_y

  if(length(nm[nm %in% "groupby2"]) == 0) {
    q_group = 1
    groupby2 = "."
  } else {
    q_group = 2
    groupby2 <- nm[nm %in% "groupby2"]
  }

  p <- ggplot(data, aes_string(x = x, y = y))
  p <- p + geom_bar(stat = "identity", aes_string(x = x, y = y), fill =  bar_fill, alpha = bar_alpha, width = bar_width)
  p <- p + geom_text(aes_string(y = y, ymax = max_y , label = label), vjust = text_vjust, size = text_size)
  p <- p + scale_y_continuous(labels = percent_format())
  p <- p + theme(axis.text.x = element_text(angle = x_angle, vjust = x_vjust))
  p <- p + xlab(xlab) + ylab(ylab)

  if(!is.null(xlim)) {
    p <- p + xlim
  }


  if(facet_flip == FALSE && q_group == 1) {
    p = p + facet_grid(as.formula(sprintf("%s ~ %s", groupby1, groupby2)))
    suppressWarnings(print(p))  
  } else if(facet_flip == TRUE && q_group == 1) {
    p = p + facet_grid(as.formula(sprintf("%s ~ %s", groupby2, groupby1)))
    suppressWarnings(print(p)) 
  } else if(facet_flip == FALSE && q_group == 2) {
    p = p + facet_grid(as.formula(sprintf("%s ~ %s", groupby1, groupby2)))
    suppressWarnings(print(p))
  } else if(facet_flip == TRUE && q_group == 2) {
    p = p + facet_grid(as.formula(sprintf("%s ~ %s", groupby2, groupby1)))
    suppressWarnings(print(p))      
  }

} DT <- data.table(mtcars)
DT[["cyl"]] <- factor(DT[["cyl"]])
DT[["gear"]] <- factor(DT[["gear"]])
DT[["vs"]] <- factor(DT[["vs"]])
DT <- DT[, c("cyl", "gear", "vs"), with=F]
setkey(DT, cyl, gear, vs)

ggfreq(agg(DT, x = cyl, groupby1 = gear), facet_flip = TRUE)
ggfreq(agg(DT, x = cyl, groupby1 = gear), facet_flip = FALSE)

ggfreq(agg(DT, x = cyl, groupby1 = gear, groupby2 = vs), facet_flip = TRUE)
ggfreq(agg(DT, x = cyl, groupby1 = gear, groupby2 = vs), facet_flip = FALSE)

system.time(ggfreq(agg(DT, x = cyl, groupby1 = gear, groupby2 = vs), facet_flip = TRUE))
user  system elapsed 
0.41    0.03    0.50
-------------------------------------------------------------------------------------------------------
library(ggplot2)
data <- data.frame(V1 <- rnorm(700), V2=sample(LETTERS[1:7], 700, replace=TRUE))
ggplot(data, aes(x=V1)) + 
  stat_bin(aes(y=..density..)) + 
  stat_function(fun=dnorm) + 
  facet_grid(V2~.) ggplot(df2, aes(x = value)) + 
  stat_bin(aes(y =..density..)) + 
  stat_function(fun = dnorm) + 
  facet_grid(. ~ variable)


ggplot(data = df2, aes(x = value)) + 
  facet_wrap(~ variable) + 
  geom_histogram(aes(y = ..density..)) + 
  stat_function(fun = dnorm, colour = "blue")
-------------------------------------------------------------------------------------------------------
DF <- read.table(text="       DATA   YEAR1   YEAR2   REGION1   REGION2
OBS1   X      1        0      1         0  
OBS2   Y      1        0      0         1
OBS3   Z      0        1      1         0", header=TRUE)

DF[,-1] <- lapply(DF[,-1], as.logical)
DF[,1] <- as.character(DF[,1])

res <- apply(expand.grid(2:3, 4:5), 1, function(i) {
  tmp <- rep("0", length(DF[,1]))
  ind <- do.call(`&`,DF[,i])
  tmp[ind] <- DF[ind,1]
  tmp <- list(tmp)
  names(tmp) <- paste0(names(DF)[i], collapse="_")
  tmp
})

res <- as.data.frame(res)
rownames(res) <- rownames(DF)


#      YEAR1_REGION1 YEAR2_REGION1 YEAR1_REGION2 YEAR2_REGION2
# OBS1             X             0             0             0
# OBS2             0             0             Y             0
# OBS3             0             Z             0             0
-------------------------------------------------------------------------------------------------------
ffdf require(ffbase)
  data <- expand.ffgrid(Date = ff(seq.Date(Sys.Date(), Sys.Date()+10000, by = "day")), Item = ff(factor(paste("Item", 1:5000))))
  data$sales <- ffrandom(n = nrow(data))
  # split by date -> assuming that all sales of 1 date can fit into RAM
  splitby <- as.character(data$Date, by = 250000)
  grp_qty <- ffdfdply(x=data[c("sales","Date","Item")], 
                      split=splitby, 
                      FUN = function(data){
                        ## This happens in RAM - containing **several** split elements so here we can use data.table which works fine for in RAM computing
                        require(data.table)
                        data <- as.data.table(data)
                        result <- data[, list(sales = sum(sales, na.rm=TRUE)), by = list(Date, Item)]
                        as.data.frame(result)
                      })
  dim(grp_qty) ffdf
-------------------------------------------------------------------------------------------------------
df2 <- melt(df1, id.vars=c("Loc", "Type"))
ggplot(data=df2, aes(x=value, fill=Type)) + 
  geom_bar() + facet_wrap(~ Loc + variable, nrow=1) facet_grid df2 <- melt(df1, id.vars=c("Loc", "Type"))
ggplot(data=df2, aes(x=value, fill=Type)) + 
  geom_bar() + facet_grid(Loc ~ variable) df2 <- melt(df1, id.vars=c("Loc", "Type"))
ggplot(data=df2, aes(x=value, fill=Type)) + 
  geom_rect(aes(fill=Loc),xmin =-Inf,xmax=Inf,ymin=-Inf,ymax=Inf,alpha = 0.1) +
  geom_bar() +
  facet_wrap(~ Loc + variable, nrow=1) ggextra
-------------------------------------------------------------------------------------------------------
by result <- by(df1, INDICES=list(df1$Method, df1$Type), FUN=nrow)
cbind(expand.grid(attributes(result)$dimnames), as.vector(result))

#   Var1   Var2 as.vector(result)
# 1    A   Fast                 2
# 2    B   Fast                 1
# 3    C   Fast                 1
# 4    A Medium                 1
# 5    B Medium                NA
# 6    C Medium                 1
# 7    A   Slow                NA
# 8    B   Slow                 1
# 9    C   Slow                 2
-------------------------------------------------------------------------------------------------------
x <- seq(0,10,by=2)
y <- seq(0, 30, by=10)
grid <- expand.grid(x, y)
N <- 100
points <- cbind(runif(N, 0, 10), runif(N, 0, 30))

plot(grid, t="n", xaxs="i", yaxs="i")
points(points, col="blue", pch="+") 
abline(v=x, h=y)

binxy <- data.frame(x=findInterval(points[,1], x),
                    y=findInterval(points[,2], y))

(results <- table(binxy))
d <- as.data.frame.table(results)
xx <- x[-length(x)] + 0.5*diff(x)
d$x <- xx[d$x]
yy <- y[-length(y)] + 0.5*diff(y)
d$y <- yy[d$y]
with(d, text(x, y, label=Freq))
-------------------------------------------------------------------------------------------------------
df <- expand.grid(id=id, year=unique(year))
frame <- frame[frame$y != 0,]
df$y <- 0
df2 <- rbind(frame, df)
df2 <- df2[!duplicated(df2[,c("id", "year")]),]
df2 <- df2[order(df2$id, df2$year),]
rownames(df2) <- NULL
df2
# id year y
# 1   1 2005 1
# 2   1 2006 0
# 3   1 2007 0
# 4   1 2008 0
# 5   2 2005 0
# 6   2 2006 0
# 7   2 2007 0
# 8   2 2008 0
# 9   3 2005 0
# 10  3 2006 0
# 11  3 2007 0
# 12  3 2008 0
# 13  4 2005 0
# 14  4 2006 0
# 15  4 2007 1
# 16  4 2008 0
-------------------------------------------------------------------------------------------------------
g id rbind frame cast frame melt library(reshape2)

g <- with(frame, expand.grid(year = seq(min(year), max(year)), id = unique(id), y = 0)) #
frame <- rbind(frame, g) #

wide <- dcast(frame, year ~ id, fill = 0, fun = sum, value.var = "y")
long <- melt(wide, id = "year", variable.name = "id", value.name = "y")

long <- long[order(long$id, long$year), c("id", "year", "y")] ## > long
   id year y
1   1 2005 1
2   1 2006 0
3   1 2007 0
4   1 2008 0
5   2 2005 0
6   2 2006 0
7   2 2007 0
8   2 2008 0
9   3 2005 0
10  3 2006 0
11  3 2007 0
12  3 2008 0
13  4 2005 0
14  4 2006 0
15  4 2007 1
16  4 2008 0 aggregate g <- with(frame, expand.grid(year = seq(min(year), max(year)), id = unique(id), y = 0)) #
frame <- rbind(frame, g) # 

aggregate(y ~ year + id, frame, sum)[c("id", "year", "y")] id
-------------------------------------------------------------------------------------------------------
require(reshape2)
#use melt to go from wide to long data
dataM = melt(data,c("nbr"))

#parse labels to identify vertical category and fill the value correspondingly
dataM$vertical = ifelse(grepl("GED",dataM$variable),"GED",ifelse(grepl("RAN",dataM$variable),"RAN",ifelse(grepl("EIG",dataM$variable),"EIG","BET")))
#parse labels to identify horizontal category and fill the value correspondingly
dataM$horizontal = ifelse(grepl("PE",dataM$variable),"PE",ifelse(grepl("GA",dataM$variable),"GA",ifelse(grepl("N1",dataM$variable),"N1","N2")))
#parse label to identify category
dataM$category = ifelse(grepl("mNC",dataM$variable),"mNC",ifelse(grepl("aSPL",dataM$variable),"aSPL",ifelse(grepl("_d",dataM$variable),"d","m")))

#create ggplot objects with sub-setted data
p1 = ggplot(dataM[dataM$category=="mNC",],aes(x=nbr,y=value))
p1 = p1 + geom_line()
#face_grid creates the panels that you are looking for (usage is vertical_categories ~ horizontal_categories)
p1 = p1 + facet_grid(vertical~horizontal)
p1

p2 = ggplot(dataM[dataM$category=="aSPL",],aes(x=nbr,y=value))
p2 = p2 + geom_line()
p2 = p2 + facet_grid(vertical~horizontal)
p2

p3 = ggplot(dataM[dataM$category=="d",],aes(x=nbr,y=value))
p3 = p3 + geom_line()
p3 = p3 + facet_grid(vertical~horizontal)
p3

p4 = ggplot(dataM[dataM$category=="m",],aes(x=nbr,y=value))
p4 = p4 + geom_line()
p4 = p4 + facet_grid(vertical~horizontal)
p4
-------------------------------------------------------------------------------------------------------
ggplot() annotation_custom() # pre-req libraries
require(ggplot2)  
require(grid)     # rasterGrob function 
require(png)      # to read the PNG file

width<-10
height<-10

# generate the points and labels for the grid
points<-data.frame(expand.grid(w=1:width,h=1:height))
points$labs<-paste0("(",points$w,",",points$h,")")
points$x<-points$w-0.5 # center
points$y<-points$h-0.5

# make the gridline co-ordinates
gridx<-data.frame(x=0:width,xend=0:width,y=rep(0,width+1),yend=rep(height,width+1))
gridy<-data.frame(x=rep(0,height+1),xend=rep(width,height+1),y=0:height,yend=0:height)
grids<-rbind(gridx,gridy)

# function to plot using ggplot with annotation_custom for the image
plotgrid<-function(file){
g<-ggplot(points)+theme_bw()+
  annotation_custom(rasterGrob(readPNG(file),0,0,1,1,just=c("left","bottom")),0,width,0,height)+
  geom_text(aes(x=x,y=y,label=labs))+
  geom_segment(aes(x=x,xend=xend,y=y,yend=yend),data=grids) +
  coord_cartesian(c(0,width),c(0,height))
  return(g)
}

# run the function for each file in the folder
setwd("delete_me")
lapply(list.files(),function(x)plotgrid(x))
setwd(wd)
-------------------------------------------------------------------------------------------------------
ggplot(dataM[dataM$category=="m" & dataM$order=="RAN",], aes(x=nbr, y=value, fill=net)) + 
  geom_ribbon(aes(ymin=0, ymax=value),alpha=0.3)+ 
  scale_fill_brewer(palette="Set1") ggplot(dataM[dataM$category=="m" & dataM$order=="RAN",], aes(x=nbr, y=value, fill=net)) + 
  geom_line(aes(color=net))+
  geom_ribbon(aes(ymin=0, ymax=value),alpha=0.3)+ 
  scale_fill_brewer(palette="Set1")+
  facet_grid(net~.)
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(data.table)
library(reshape2)  # for melt(...)
library(plyr)      # for .(...)

xx <- with(iris, data.table(id=1:nrow(iris), group=Species, 
           Sepal.Length, Sepal.Width,Petal.Length, Petal.Width))
# reshape for facetting with ggplot
yy <- melt(xx,id=1:2, variable.name="H", value.name="xval")
yy <- data.table(yy,key="id,group")
ww <- yy[,list(V=H,yval=xval),key="id,group"]
zz <- yy[ww,allow.cartesian=T]
setkey(zz,H,V,group)
zz <- zz[,list(id, group, xval, yval, min.x=min(xval), min.y=min(yval),
               range.x=diff(range(xval)),range.y=diff(range(yval))),by="H,V"]
# points colored by group (=species)
# density plots for each variable by group
d  <-  zz[H==V, list(x=density(xval)$x,
          y=mean(min.y)+mean(range.y)*density(xval)$y/max(density(xval)$y)),
          by="H,V,group"]
ggp = ggplot(zz)
ggp = ggp + geom_point(subset  =.(H!=V), 
                       aes(x=xval, y=yval, color=factor(group)), 
                       size=3, alpha=0.5)
ggp = ggp + geom_line(subset = .(H==V), data=d, aes(x=x, y=y, color=factor(group)))
ggp = ggp + facet_grid(V~H, scales="free")
ggp = ggp + scale_color_discrete(name="Species")
ggp = ggp + labs(x="", y="")
ggp ggpairs(...) ggpairs(...)
-------------------------------------------------------------------------------------------------------
df = maln_complete_recent_melt ggplot(df, aes(x=COUNTRY, y=percent, fill=location)) + 
  geom_histogram(stat="identity") +
  labs(title="Percentage of malnoursihed children according to height for age",  fill="DHS Survey") + 
  geom_text(aes(label=round(percent),y=0),vjust=-0.5,size=4)+
  scale_x_discrete(labels=c(paste(df$COUNTRY, df$Year, sep="")))+
  theme(axis.text.x=element_text(angle=-90, color="black",hjust=0,vjust=0.2))+
  facet_grid(location~.)
-------------------------------------------------------------------------------------------------------
df dft t() reshape2 # to generate a reproducible dataset
test.df = data.frame(
    expand.grid(ch1 = letters[1:3], ch2 = letters[1:3], ch3 = letters[1:3], stringsAsFactors = FALSE),
    test.result = as.character(sample(c("T", "F"), 27, replace = TRUE)))
write.table(t(test.df), file = "testfile.csv", sep = ",", row.names = FALSE, col.names=FALSE)

# now to import the dataset into R
rm(list=ls())
df = read.csv("testfile.csv", header=FALSE)

# transpose your dataset to switch rows and columns and give meaningful names
dft = data.frame(t(df))
names(dft) = c("ch1", "ch2", "ch3", "test.result")
dft$test.result = ifelse(dft$test.result == "T", 1, 0) 

# the data is now in a format to perform analysis and plotting
library(reshape2)
dcast(dft, ch1 + ch2 ~ test.result)
with(dft, table(ch1, test.result, ch2)) character factor ggplot2 factor dft$ch1 = factor(dft$ch1)
-------------------------------------------------------------------------------------------------------
p <- qplot(wt, mpg, data = mtcars)
p <- p + geom_smooth(aes(group=cyl), method="lm", se=FALSE)
p <- p + facet_grid(cyl~.)
print(p) p <- ggplot(data,aes(factor(country),price)) + 
  geom_violin(aes(fill=country,trim=FALSE)) + 
  geom_boxplot(aes(fill=country),position=position_dodge(0.9),width=.1) + 
  geom_jitter(alpha=0.5) + 
  facet_wrap(organic~location+fruit) +
  xlab("Fruit") +
  ylab("Price") +
  labs(fill="country")
p <- p + geom_smooth(aes(group=1,color=country), method="lm", se=FALSE)
p
-------------------------------------------------------------------------------------------------------
caret ncomp mtry modelInfo <- list(label = "PLS-RF",
              library = c("pls", "randomForest"),
              type = "Classification",
              parameters = data.frame(parameter = c('ncomp', 'mtry'),
                                      class = c("numeric", 'numeric'),
                                      label = c('#Components', 
                                                '#Randomly Selected Predictors')),
              grid = function(x, y, len = NULL) {
                grid <- expand.grid(ncomp = seq(1, min(ncol(x) - 1, len), by = 1),mtry = 1:len)
                grid <- subset(grid, mtry <= ncomp)
                },
              loop = NULL,
              fit = function(x, y, wts, param, lev, last, classProbs, ...) { 
                     ## First fit the pls model, generate the training set scores,
                     ## then attach what is needed to the random forest object to 
                     ## be used later
                     pre <- plsda(x, y, ncomp = param$ncomp)
                     scores <- pls:::predict.mvr(pre, x, type = "scores")
                     mod <- randomForest(scores, y, mtry = param$mtry, ...)
                     mod$projection <- pre$projection
                     mod
                   },
                   predict = function(modelFit, newdata, submodels = NULL) {       
                     scores <- as.matrix(newdata)  %*% modelFit$projection
                     predict(modelFit, scores)
                   },
                   prob = NULL,
                   varImp = NULL,
                   predictors = function(x, ...) rownames(x$projection),
                   levels = function(x) x$obsLevels,
                   sort = function(x) x[order(x[,1]),]) train library(ChemometricsWithR)
 data(prostate)

 set.seed(1)
 inTrain <- createDataPartition(prostate.type, p = .90)
 trainX <-prostate[inTrain[[1]], ]
 trainY <- prostate.type[inTrain[[1]]]
 testX <-prostate[-inTrain[[1]], ]
 testY <- prostate.type[-inTrain[[1]]]

 ## These will take a while for these data
 set.seed(2)
 plsrf <- train(trainX, trainY, method = modelInfo,
                preProc = c("center", "scale"),
                tuneLength = 10,
                trControl = trainControl(method = "repeatedcv",
                                         repeats = 5))

 ## How does random forest do on its own?
 set.seed(2)
 rfOnly <- train(trainX, trainY, method = "rf",
                tuneLength = 10,
                trControl = trainControl(method = "repeatedcv",
                                         repeats = 5)) > getTrainPerf(plsrf)
   TrainAccuracy TrainKappa method
 1     0.7940423    0.65879 custom
 > getTrainPerf(rfOnly)
   TrainAccuracy TrainKappa method
 1     0.7794082  0.6205322     rf > postResample(predict(plsrf, testX), testY)
  Accuracy     Kappa 
 0.7741935 0.6226087 
 > postResample(predict(rfOnly, testX), testY)
  Accuracy     Kappa 
 0.9032258 0.8353982
-------------------------------------------------------------------------------------------------------
library(ggplot2)
library(lme4)
library(multcomp)
dataset <- expand.grid(experiment = factor(seq_len(10)), status = factor(c("N", "D", "R"), levels = c("N", "D", "R")), reps = seq_len(10))
dataset$value <- rnorm(nrow(dataset), sd = 0.23) + with(dataset, rnorm(length(levels(experiment)), sd = 0.256)[experiment] + ifelse(status == "D", 0.205, ifelse(status == "R", 0.887, 0))) + 2.78
model <- lmer(value~status+(1|experiment), data = dataset) library(plotrix); sizetree(dataset[,c(1,2)]) my.plotcorr(
matrix(c(1,     .891,   .891,
        .891,   1,      .891,
        .891,   .891,   1), nrow=3)
) My2Boxes(m=4,f1=dataset$experiment,f2=dataset$status,x=dataset$value,color=c("red","yellow","green")) lattice::xyplot(value~status | experiment, groups=experiment, data=dataset, type=c('p','r'), auto.key=F) lattice::xyplot(fitted(model)~status | experiment, groups=experiment, data=dataset, type=c('p','r'), auto.key=F)
-------------------------------------------------------------------------------------------------------
caret method="pls" modelInfo <- list(label = "PLS-LDA",
                  library = c("pls", "MASS"),
                  type = "Classification",
                  parameters = data.frame(parameter = c("ncomp"),
                                          class = c("numeric"),
                                          label = c("#Components")),
                  grid = function(x, y, len = NULL) {
                    grid <- expand.grid(ncomp = seq(1, min(ncol(x) - 1, len), by = 1))
                  },
                  loop = NULL,
                  fit = function(x, y, wts, param, lev, last, classProbs, ...) { 
                    ## First fit the pls model, generate the training set scores,
                    ## then attach what is needed to the lda object to 
                    ## be used later
                    pre <- plsda(x, y, ncomp = param$ncomp)
                    scores <- pls:::predict.mvr(pre, x, type = "scores")
                    mod <- lda(scores, y, ...)
                    mod$projection <- pre$projection
                    mod
                  },
                  predict = function(modelFit, newdata, submodels = NULL) {       
                    scores <- as.matrix(newdata)  %*% modelFit$projection
                    predict(modelFit, scores)$class
                  },
                  prob = function(modelFit, newdata, submodels = NULL) {       
                    scores <- as.matrix(newdata)  %*% modelFit$projection
                    predict(modelFit, scores)$posterior
                  },
                  varImp = NULL,
                  predictors = function(x, ...) rownames(x$projection),
                  levels = function(x) x$obsLevels,
                  sort = function(x) x[order(x[,1]),]) method="pls" library(mlbench) # data set from here
data(Sonar)
dim(Sonar) # 208x60
set.seed(107)
inTrain <- createDataPartition(y = Sonar$Class,
                               ## the outcome data are needed
                               p = .75,
                               ## The percentage of data in the
                               ## training set
                               list = FALSE)
## The format of the results
## The output is a set of integers for the rows of Sonar
## that belong in the training set.
training <- Sonar[ inTrain,] #157
testing <- Sonar[-inTrain,] # 51

ctrl <- trainControl(method = "repeatedcv",
                     repeats = 3,
                     classProbs = TRUE,
                     summaryFunction = twoClassSummary)
set.seed(108)
plsFitSon <- train(Class ~ .,
                data = training,
                method = "pls",
                tuneLength = 15,
                trControl = ctrl,
                metric = "ROC",
                preProc = c("center", "scale"))
plsFitSon
plot(plsFitSon) # might be slightly difference than what in the vignette due to radnomness PLS-LDA set.seed(108)
plsldaFitSon <- train(Class ~ .,
                   data = training,
                   method = modelInfo,
                   tuneLength = 15,
                   trControl = ctrl,
                   metric = "ROC",
                   preProc = c("center", "scale")) getTrainPerf(plsFitSon)
   TrainROC TrainSens TrainSpec method
1 0.8741154 0.7638889 0.8452381    pls
getTrainPerf(plsldaFitSon)
   TrainROC TrainSens TrainSpec method
1 0.8741154 0.7638889 0.8452381 custom

postResample(predict(plsFitSon, testing), testing$Class)
Accuracy    Kappa 
0.745098 0.491954 
postResample(predict(plsldaFitSon, testing), testing$Class)
Accuracy    Kappa 
0.745098 0.491954 lda
-------------------------------------------------------------------------------------------------------
df iris x <- with(iris, data.table(id=1:nrow(iris), group=Species, Sepal.Length, Sepal.Width,Petal.Length, Petal.Width)) xx <- with(df, data.table(id=1:nrow(df), group=drug, df[3:12])) library(ggplot2)
library(reshape2)    # for melt(...)
# convert df into a form suitable to use with ggplot
gg <- melt(df,id=1:2, variable.name="Month", value.name="Weight")
# density plots
ggplot(gg) + 
  stat_density(aes(x=Weight, y=..scaled.., color=factor(drug)),geom="line", position="dodge")+
  facet_grid(Month~.)+
  scale_color_discrete("Drug")
# histograms
ggplot(gg) + 
  geom_histogram(aes(x=Weight, fill=factor(drug)), position="dodge")+
  facet_grid(Month~.)+
  scale_fill_discrete("Drug")
-------------------------------------------------------------------------------------------------------
apply apply( mat , 2 , function(x) colSums( x > mat ) apply apply data.frame > matrices data.frame expand.grid() colSums matrix n <- 1:ncol(mat)
ind <- expand.grid(n,n)
out <- colSums( mat[,c(ind[,1])] > mat[,c(ind[,2])] )

matrix( out , ncol(mat) , byrow = TRUE )
#     [,1] [,2] [,3] [,4] [,5]
#[1,]    0    1    0    0    0
#[2,]    2    0    1    1    2
#[3,]    3    2    0    2    2
#[4,]    2    3    1    0    1
#[5,]    3    2    1    1    0 apply apply matrix apply #  Single apply loop
f1 <- function(mat) apply( mat , 2 , function(x) colSums( x > mat ) )

#  OP double apply loop
f2 <- function(mat) {apply(mat, MARGIN = 2,
                function(x) {
                  return(apply(mat, MARGIN = 2, function(y) {
                    return(sum(x > y))
                  }))})}

require(microbenchmark)
microbenchmark( f1(mat) , f2(mat) )

#Unit: microseconds
#    expr     min       lq   median       uq      max neval
# f1(mat)  95.190  97.6405 102.7145 111.4635  159.584   100
# f2(mat) 361.862 370.7860 398.7830 418.3810 1336.506   100
-------------------------------------------------------------------------------------------------------
bigmat<-matrix(sample(0:5,200,rep=T),nr=10)
    gridfoo <- function(mat) {
    n <- 1:ncol(mat)
    ind <- expand.grid(n,n)
    out <- colSums( mat[,c(ind[,1])] > mat[,c(ind[,2])] )
    }

    appfoo<- function(mat) apply(mat,2,function(x) colSums(sweep(mat,1,x,"-")<0))


    app2foo<- function(mat) t(sapply(seq(ncol(mat)), function(i) colSums(mat[, i] > mat)))

 microbenchmark(gridfoo(bigmat),appfoo(bigmat),app2foo(bigmat),times=10)
Unit: microseconds
            expr      min       lq    median       uq      max neval
 gridfoo(bigmat)  363.909  369.895  381.4410  413.086  522.557    10
  appfoo(bigmat) 1208.892 1231.129 1238.1850 1252.083 1521.913    10
 app2foo(bigmat)  298.482  310.883  317.0835  323.284  762.454    10 Rgames> bigmat<-matrix(sample(0:5,20000,rep=T),nr=100)
Rgames> microbenchmark(gridfoo(bigmat),appfoo(bigmat),app2foo(bigmat),times=10)
Unit: milliseconds
            expr       min        lq   median        uq       max neval
 gridfoo(bigmat) 106.15115 112.98458 149.5746 183.87987 249.35418    10
  appfoo(bigmat) 127.44553 127.92874 132.5372 136.42562 199.12123    10
 app2foo(bigmat)  14.64483  14.99676  18.6089  20.51824  20.91122    10
-------------------------------------------------------------------------------------------------------
ggplot library(ggplot2)

ggplot(aes(x=hp, y=mpg, shape=as.factor(am), color=as.factor(am)), data=mtcars)+ 
  facet_grid(gear~cyl) +
  geom_point(size=I(3)) +
  xlab("Horsepower") +
  ylab("Miles per Gallon") am as.factor(am) shape am guides(shape = guide_legend(title="am"),
       color = guide_legend(title="am"))
-------------------------------------------------------------------------------------------------------
method = 'gbm' nrow(tuneGrid) == 1 y y <- factor(paste("Class", y, sep = "")) tuneGrid <- 
expand.grid(interaction.depth = 1, n.trees = 100:101, shrinkage = 0.1)
-------------------------------------------------------------------------------------------------------
p <- ggplot(data=DT, aes(x = x, y = y)) + aes(shape = factor(grp)) +
     geom_point(aes(colour = factor(grp), shape = factor(grp)), size = 3) + 
     facet_grid(. ~ grp, labeller = label_both)
-------------------------------------------------------------------------------------------------------
facet_grid() require(reshape2)
mdf <- melt(data.frame(y1, y2))
mdf$x <- x

ggplot(mdf, aes(x = x)) +
  geom_line(aes(y = value)) +
  facet_grid(variable ~ ., scales = "free_y")
-------------------------------------------------------------------------------------------------------
# Additional column for faceting
df$not.rea <- df$labels!="rea"

# Your solution + facet_grid with labeller and free scales/space
ggplot(df, aes(x=labels, y=est, ymin=lcl, ymax=ucl)) +
  geom_point(position=position_dodge(), size=2.5) + 
  geom_linerange(position=position_dodge(), size=0.5) +
  geom_hline(aes(yintercept=1)) +
  facet_grid(~not.rea, scales="free", space="free")
labeller=function(var,val) c("rea","other")[val+1]) data.frame ggplot2 ggplot(df[df$labels %in% c("rea","mat"),], ...) + ... # Convert labels to factor - rea should always be first
df$labels <- factor(df$labels, levels=c("rea","sci","mat","apt","hor"))

# Plotting function
one.plot <- function(filter){
  ggplot(df[df$labels %in% c("rea",filter),], aes(x=labels, y=est, ymin=lcl, ymax=ucl)) +
    geom_point(position=position_dodge(), size=2.5) + 
    geom_linerange(position=position_dodge(), size=0.5) +
    geom_hline(aes(yintercept=1)) +
    facet_grid(~labels, scales="free", space="free")
}

# Runner of the batch
sapply(as.character(df$labels[df$labels != "rea"]), function(s) print(one.plot(s)) ) sapply(as.character(df$labels[df$labels != "rea"]), function(s) ggsave(paste0(s,".png"), one.plot(s)) ) *.png gridExtra library(gridExtra)
grid.arrange(one.plot("sci"),
             one.plot("mat"),
             one.plot("apt"),
             one.plot("hor"),
             ncol=2, main="Main Title")
-------------------------------------------------------------------------------------------------------
def expand_grid(x, y):
    xG, yG = np.meshgrid(x, y) # create the actual grid
    xG = xG.flatten() # make the grid 1d
    yG = yG.flatten() # same
    return pd.DataFrame({'x':xG, 'y':yG}) # return a dataframe import numpy as np
import pandas as pd

p, q = np.linspace(1, 10, 10), np.linspace(1, 10, 10)

def expand_grid(x, y):
    xG, yG = np.meshgrid(x, y) # create the actual grid
    xG = xG.flatten() # make the grid 1d
    yG = yG.flatten() # same
    return pd.DataFrame({'x':xG, 'y':yG})

print expand_grid(p, q).head(n = 20)
-------------------------------------------------------------------------------------------------------
plyr::ddply() require(plyr)
# make your data frame
I<-data.frame(lat=seq(0.5,1000,0.5),lon=1,tmp=sample(1:100,2000,replace=T))

# make an adjustment grid
k<-expand.grid(c(0,0.25),c(0,0.25),0)

# use plyr:ddply() to expand out each entry into the correponding 4 entries
new_I<-ddply(I,.(lat,lon),function(x)as.list(x)+k)
colnames(new_I)<-c("lat","lon","newlat","newlon","tmp")

head(new_I)

  lat lon newlat newlon tmp
1 0.5   1   0.50   1.00  64
2 0.5   1   0.75   1.00  64
3 0.5   1   0.50   1.25  64
4 0.5   1   0.75   1.25  64
5 1.0   1   1.00   1.00  31
6 1.0   1   1.25   1.00  31 # make your data frame
I<-data.frame(lat=seq(0.5,1000000,0.5),lon=1,tmp=sample(1:100,2000000,replace=T))

# make an adjustment vector
v<-rep(0.25,times=2000000)

# make 3 new tables, apply the vector appropriately, and rbind
I_latshift<-I
I_lonshift<-I
I_bothshift<-I

I_latshift$lat<-I_latshift$lat+v
I_lonshift$lon<-I_lonshift$lon+v
I_bothshift$lat<-I_bothshift$lat+v
I_bothshift$lon<-I_bothshift$lon+v

I<-rbind(I,I_bothshift,I_latshift,I_lonshift)

# sort it for neatness
I<-I[with(I, order(lat, lon)), ]


head(I)

         lat  lon tmp
1       0.50 1.00   3
6000001 0.50 1.25   3
4000001 0.75 1.00   3
2000001 0.75 1.25   3
2       1.00 1.00  88
6000002 1.00 1.25  88
-------------------------------------------------------------------------------------------------------
facs <- cbind(f1=rep(f1, length(f2)), f2=rep(f2, each=length(f1))) # create factor combos
lst <- list(c(395, 310, 235, 290, 240, 490, 270, 225, 430, 385, 170, 55, 295, 320, 270, 130, 300, 285, 130, 200, 225, 90, 205, 340 ), c(3, 8), c(1, 0, 0, 0, 3, 2, 5, 2, 3, 5, 2, 3), c(1, 0, 0, 0, 3, 2, 5, 2, 3, 5, 2, 3), c(1, 1, 1, 2, 3, 5, 2, 5, 3, 3, 3, 2, 3, 2, 3), c(0, 0, 195, 150, 2, 2, 0, 2, 1, 1, 2, 1, 2, 1, 1, 1, 3, 2, 2, 1, 2, 2, 1, 1, 2, 3, 2, 2, 1, 3, 1, 1))

library(data.table)
facs.dt <- as.data.table(facs)[,list(time=sort(lst[[.GRP]])), by=list(f1, f2)]
facs.dt[, id:=seq_along(time), by=list(f1, f2)]
library(ggplot2)
ggplot(facs.dt, aes(x=id, y=time)) + 
  geom_bar(stat="identity", position="dodge") + 
  scale_y_log10() + facet_grid(f1 ~ f2) ggplot(facs.dt, aes(x=id, y=time)) + 
  geom_bar(stat="identity", position="dodge") + 
  facet_wrap(~ f1 + f2, scales="free") + 
  opts(axis.text.x=element_blank(), axis.ticks.x=element_blank())
-------------------------------------------------------------------------------------------------------
dat <- matrix(c(
                c(0.25,0.25,0.25,0.25),
                c(0.05,0,0.95,0),
                c(0.4,0.1,0.1,0.4)),
                nrow=4,ncol=3,byrow=FALSE,
                dimnames=list(c("A","C","G","T"),
                              c("E","S","I"))
                )

  barplot(dat,border=FALSE,beside=TRUE,
          col=rainbow(4),ylim=c(0,1),
          legend=rownames(dat),main="Plot name",
          xlab="State",ylab="observation")
  grid()
  box()
-------------------------------------------------------------------------------------------------------
melt data.table ggplot series <- 3
samples <- 2
trials <- 4

trial.labs <- paste("tr", seq(len=trials))
trial.class <- sample(c("A", "B"), trials, rep=T)

arr <- array(
  runif(series * samples * trials), 
  dim=c(series, samples, trials),
  dimnames=list(
    ser=paste("ser", seq(len=series)), 
    smp=paste("smp", seq(len=samples)), 
    tr=trial.labs
  )
)
# , , tr = Trial 1
#        smp
# ser         smp 1     smp 2
#   ser 1 0.9648542 0.4134501
#   ser 2 0.7285704 0.1393077
#   ser 3 0.3142587 0.1012979
#
# ... omitted 2 trials ...
# 
# , , tr = Trial 4
#        smp
# ser         smp 1     smp 2
#   ser 1 0.5867905 0.5160964
#   ser 2 0.2432201 0.7702306
#   ser 3 0.2671743 0.8568685 melt data.table melt data.frames data.table data.table library(reshape2)
library(data.table)

dt.raw <- data.table(melt(arr), key="tr")  # we'll get to what the `key` arg is doing later
#       ser   smp   tr      value
#  1: ser 1 smp 1 tr 1 0.53178276
#  2: ser 2 smp 1 tr 1 0.28574271
#  3: ser 3 smp 1 tr 1 0.62991366
#  4: ser 1 smp 2 tr 1 0.31073376
#  5: ser 2 smp 2 tr 1 0.36098971
# ---                            
# 20: ser 2 smp 1 tr 4 0.38049334
# 21: ser 3 smp 1 tr 4 0.14170226
# 22: ser 1 smp 2 tr 4 0.63719962
# 23: ser 2 smp 2 tr 4 0.07100314
# 24: ser 3 smp 2 tr 4 0.11864134 data.tables data.table class dt <- dt.raw[J(trial.labs, class=trial.class)]  # on the fly mapping of trials to class
#          tr   ser   smp     value class
#  1: Trial 1 ser 1 smp 1 0.9648542     A
#  2: Trial 1 ser 2 smp 1 0.7285704     A
#  3: Trial 1 ser 3 smp 1 0.3142587     A
#  4: Trial 1 ser 1 smp 2 0.4134501     A
#  5: Trial 1 ser 2 smp 2 0.1393077     A
# ---                                    
# 20: Trial 4 ser 2 smp 1 0.2432201     A
# 21: Trial 4 ser 3 smp 1 0.2671743     A
# 22: Trial 4 ser 1 smp 2 0.5160964     A
# 23: Trial 4 ser 2 smp 2 0.7702306     A
# 24: Trial 4 ser 3 smp 2 0.8568685     A J data.table data.table data.table [.data.table data.table dt J key data.table melt data.table J(trial.labs, class=trial.class) data.table data.table(trial.labs, class=trial.class) J [.data.table data.table class sample dt[, as.list(summary(value)), by=list(class, smp)]

#    class   smp    Min. 1st Qu. Median   Mean 3rd Qu.   Max.
# 1:     A smp 1 0.08324  0.2537 0.3143 0.4708  0.7286 0.9649
# 2:     A smp 2 0.10130  0.1609 0.5161 0.4749  0.6894 0.8569
# 3:     B smp 1 0.14050  0.3089 0.4773 0.5049  0.6872 0.8970
# 4:     B smp 2 0.08294  0.1196 0.1562 0.3818  0.5313 0.9063 data.table as.list(summary(value)) class smp by as.list data.table list(mean(value), var(value), (value - mean(value))^3 data.table dt[, value:=value * 10]  # modify in place with `:=`, very efficient
dt[1:2]                  # see, `value` now 10x    
#         tr   ser   smp    value class
# 1: Trial 1 ser 1 smp 1 9.648542     A
# 2: Trial 1 ser 2 smp 1 7.285704     A data.table ggplot library(ggplot2)
ggplot(data=dt, aes(x=ser, y=smp, color=class, size=value)) + 
  geom_point() +
  facet_wrap( ~ tr) ggplot(data=dt, aes(x=tr, y=value, fill=class)) + 
  geom_bar(stat="identity") +
  facet_grid(smp ~ ser) ggplot(data=dt, aes(x=tr, y=paste(ser, smp))) + 
  geom_tile(aes(fill=value)) + 
  geom_point(aes(shape=class), size=5) + 
  scale_fill_gradient2(low="yellow", high="blue", midpoint=median(dt$value)) acast reshape2 arr.2 <- acast(dt, ser ~ smp ~ tr, value.var="value")
dimnames(arr.2) <- dimnames(arr)  # unfortunately `acast` doesn't preserve dimnames properly
# , , tr = Trial 1
#        smp
# ser        smp 1    smp 2
#   ser 1 9.648542 4.134501
#   ser 2 7.285704 1.393077
#   ser 3 3.142587 1.012979
# ... omitted 3 trials ... arr.2 arr class shuff.mat <- matrix(c(0, 1, 1, 0), nrow=2) # re-order columns
for(i in 1:dim(arr.2)[3]) arr.2[, , i] <- arr.2[, , i] %*% shuff.mat melt key dt.2 <- data.table(melt(arr.2, value.name="new.value"), key=c("tr", "ser", "smp")) dt dt.2 data.table data.table dt tr setkey(dt, tr, ser, smp)
dt[dt.2]
#          tr   ser   smp    value class new.value
#  1: Trial 1 ser 1 smp 1 9.648542     A  4.134501
#  2: Trial 1 ser 1 smp 2 4.134501     A  9.648542
#  3: Trial 1 ser 2 smp 1 7.285704     A  1.393077
#  4: Trial 1 ser 2 smp 2 1.393077     A  7.285704
#  5: Trial 1 ser 3 smp 1 3.142587     A  1.012979
# ---                                             
# 20: Trial 4 ser 1 smp 2 5.160964     A  5.867905
# 21: Trial 4 ser 2 smp 1 2.432201     A  7.702306
# 22: Trial 4 ser 2 smp 2 7.702306     A  2.432201
# 23: Trial 4 ser 3 smp 1 2.671743     A  8.568685
# 24: Trial 4 ser 3 smp 2 8.568685     A  2.671743 data.table tr data.table
-------------------------------------------------------------------------------------------------------
# Estimating gam model:
x1 = rnorm(1000)
x2 = rnorm(1000)
n = rpois(1000, exp(x1) + x2^2)
model = gam(n ~ s(x1, k=10) + s(x2, k=20), family="poisson")

library(visreg)
library(plyr)

# plot output is redirected to a temporary file, in order to not show the visreg plot on the screen:
png(paste0(tempdir(),"/temporary_R_file.png"))
# make plot and save the plot components:
plot <- visreg(model, type = "contrast")
# output to temporary file turned off:
dev.off()               

# The output from visreg is a list of the same length as the number of 'x' variables,
#   so we use ldply to pick the objects we want from the each list part and make a dataframe: 
smooths <- ldply(plot, function(part)   
  data.frame(x=part$x$xx, smooth=part$y$fit, lower=part$y$lwr, upper=part$y$upr))

# The ggplot:
ggplot(smooths, aes(x, smooth)) + geom_line() +
  geom_line(aes(y=lower), linetype="dashed") + 
  geom_line(aes(y=upper), linetype="dashed") + 
  facet_grid(. ~ .id, scales = "free_x") ggplot.model <- function(model, type="conditional", res=FALSE, 
                         col.line="#7fc97f", col.point="#beaed4", size.line=1, size.point=1) {
  require(visreg)
  require(plyr)
  png(paste0(tempdir(),"/temporary_R_file.png"))
  plot <- visreg(model, type = type)
  dev.off()
  smooths <- ldply(plot, function(part) 
      data.frame(x=part$x$xx, smooth=part$y$fit, lower=part$y$lwr, upper=part$y$upr))
  points <-  ldply(plot, function(part) data.frame(data.x=part$x$x, data.y=part$y$r))
  if (res)
    ggplot(smooths, aes(x, smooth)) + geom_line(col=col.line, size=size.line) +
    geom_line(aes(y=lower), linetype="dashed", col=col.line, size=size.line) + 
    geom_line(aes(y=upper), linetype="dashed", col=col.line, size=size.line) + 
    geom_point(data = points, aes(data.x, data.y), col=col.point, size=size.point) +
    facet_grid(. ~ .id, scales = "free_x")
  else
    ggplot(smooths, aes(x, smooth)) + geom_line(col=col.line, size=size.line) +
    geom_line(aes(y=lower), linetype="dashed", col=col.line, size=size.line) + 
    geom_line(aes(y=upper), linetype="dashed", col=col.line, size=size.line) + 
    facet_grid(. ~ .id, scales = "free_x")
  }

ggplot.model(model)
ggplot.model(model, res=TRUE)
-------------------------------------------------------------------------------------------------------
\0.o/ # create some sample data

tmp <- expand.grid(letters[1:5], LETTERS[1:5])

tmp <- data.frame(product = tmp[ , 1],
                  state = tmp[ , 2],
                  count = rpois(25,10),
                  x = rnorm(25),
                  y = rnorm(25, 5),
                  z = runif(25))

> rbind(head(tmp,5),tail(tmp,5))
   product state count             x        y           z
1        a     A     8  0.0760185973 5.856485 0.550920074
2        b     A    18  1.5590221617 6.029456 0.847110604
3        c     A    15 -0.0493741863 4.080673 0.338941383
4        d     A     7 -0.0008271637 5.536864 0.258434255
5        e     A     8 -0.1232839632 6.040842 0.186286508
21       a     E    10  0.1227696294 4.540420 0.612749444
22       b     E     4 -1.9963691099 5.403566 0.763704302
23       c     E     8  1.5097868461 5.398317 0.003223928
24       d     E    11  0.1316577493 4.944517 0.037830007
25       e     E     9  1.3156144143 5.630903 0.297712275


require(sandwich)
out <- out1 <- list()

for (prod in tmp$product) {
  for (st in tmp$state) {
    # you can separate your results however you want
    # I am just splitting the data by state
    df <- split(tmp, tmp$state)
    # fit some model
    fit <- glm(count ~ x + y + z, data = df[[st]], family = 'poisson')
    cov.fit <- vcovHC(fit, type = 'HC0')
    std.err <- sqrt(diag(cov.fit))
    # this is what you want to save
    r.est <- cbind(Estimate = coef(fit), 
                   `Robust SE` = std.err, 
                   `Pr(>|z|)` = 2 * pnorm(abs(coef(fit) / std.err), lower.tail = FALSE), 
                   LL = coef(fit) - 1.96 * std.err, 
                   UL = coef(fit) + 1.96 * std.err)
    out[[st]] <- r.est
  }
  out1[[prod]] <- out
} user  system elapsed 
  3.709   0.005   3.714 > out1['e']
$e
$e$A
              Estimate  Robust SE      Pr(>|z|)         LL          UL
(Intercept)  1.5740201 0.07606682  4.038713e-95  1.4249291  1.72311107
x            1.0531125 0.14645721  6.451608e-13  0.7660563  1.34016859
y            0.2303536 0.01043567 5.660199e-108  0.2098997  0.25080753
z           -0.0679184 0.02469921  5.962785e-03 -0.1163289 -0.01950795

$e$B
               Estimate  Robust SE     Pr(>|z|)         LL          UL
(Intercept)  2.26423485 0.52505983 0.0000161538  1.2351176  3.29335211
x           -0.19609887 0.05681923 0.0005579416 -0.3074646 -0.08473318
y           -0.02669881 0.12551771 0.8315535596 -0.2727135  0.21931591
z            0.26674963 0.77268305 0.7299251054 -1.2477091  1.78120841

$e$C
              Estimate Robust SE     Pr(>|z|)         LL          UL
(Intercept)  6.9063711 1.5786217 1.214674e-05  3.8122724 10.00046969
x           -0.3323222 0.2150255 1.222250e-01 -0.7537721  0.08912773
y           -0.5345902 0.1808971 3.124483e-03 -0.8891485 -0.18003200
z           -2.7602210 1.0217381 6.902838e-03 -4.7628277 -0.75761438

$e$D
               Estimate  Robust SE      Pr(>|z|)          LL          UL
(Intercept)  2.51089752 0.06057370  0.000000e+00  2.39217307  2.62962196
x           -0.05470455 0.01676923  1.105521e-03 -0.08757225 -0.02183685
y           -0.18355314 0.01284318  2.459054e-46 -0.20872578 -0.15838050
z            1.25654525 0.04673733 3.266189e-159  1.16494009  1.34815040

$e$E
              Estimate  Robust SE     Pr(>|z|)           LL        UL
(Intercept)  1.7652611 0.47081495 0.0001772769  0.842463807 2.6880584
x            0.1888281 0.09325525 0.0428825912  0.006047765 0.3716084
y            0.1490611 0.07466494 0.0458903622  0.002717830 0.2954044
z           -0.1112667 0.19937139 0.5767846777 -0.502034584 0.2795013
-------------------------------------------------------------------------------------------------------
df<-data.frame(type=rep(c('A','B'),each=100),x = rnorm(200,1,2)/10, y = rnorm(200))
df.m<-melt(df)

require(data.table)
DT <- data.table(df.m) DT <- DT[, scaled := scale(value), by = "variable"]
str(DT)

ggplot(DT) +
  geom_density(aes(x = scaled, color = variable)) +
  facet_grid(. ~ type)

qplot(data = DT, x = scaled, color = variable,
      facets = ~ type, geom = "density")

# Using fill (inside aes) and alpha outside(so you don't get a legend for it)
ggplot(DT) +
  geom_density(aes(x = scaled, fill = variable), alpha = 0.2) +
  facet_grid(. ~ type)

qplot(data = DT, x = scaled, fill = variable, geom = "density", alpha = 0.2, facets = ~type)

# Histogram
ggplot(DT, aes(x = scaled, fill = variable)) +
  geom_histogram(binwidth=.2, alpha=.5, position="identity") +
  facet_grid(. ~ type, scales = "free")

qplot(data = DT, x = scaled, fill = variable, alpha = 0.2, facets = ~type)
-------------------------------------------------------------------------------------------------------
set.seed(1)
df <- data.frame(x=toupper(letters[1:10]),
                 y=rnorm(20,0,50),
                 sig=sample(0:1,20,replace=T), 
                 factor=rep(c("Factor1","Factor2"),each=10))

library(ggplot2)
ggplot(df) +
  geom_point(aes(x=x,y=y),shape=1,size=3)+
  geom_linerange(aes(x=x,ymin=0,ymax=y))+
  geom_text(data=df[df$sig==1,], aes(x=x,y=y+10*sign(y)),label="*",size=10)+
  geom_hline(yintercept=0)+
  facet_grid(factor~.)
-------------------------------------------------------------------------------------------------------
